struct	O
font	struct(*(struct),*(char),*(struct))
{	O
struct	O
character	struct(int,int,int,int,int)
*	O
chars	*(struct)
;	O
unsigned	O
char	O
*	O
map	*(char)
;	O
struct	O
kern_pair	struct(char,char,int)
*	O
kern	*(struct)
;	O
}	O
;	O
struct	O
character	struct(int,int,int,int,int)
{	O
int	O
wx	int
;	O
int	O
llx	int
,	O
lly	int
,	O
urx	int
,	O
ury	int
;	O
}	O
;	O
struct	O
kern_pair	struct(char,char,int)
{	O
unsigned	O
char	O
c0	char
,	O
c1	char
;	O
int	O
amt	int
;	O
}	O
;	O
enum	O
output_mode	enum(int,int)
{	O
MODE_TEXT	int
,	O
MODE_POSTSCRIPT	int
}	O
;	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
TOKEN_EOF	int
,	O
TOKEN_LPAREN	int
,	O
TOKEN_RPAREN	int
,	O
TOKEN_LEFT	int
,	O
TOKEN_MIDDLE	int
,	O
TOKEN_RIGHT	int
,	O
TOKEN_COMMA	int
,	O
TOKEN_PRODUCES	int
,	O
TOKEN_TWOWAY	int
,	O
TOKEN_ADJACENT	int
,	O
TOKEN_NO_CIRCLE	int
,	O
TOKEN_LEADER	int
,	O
TOKEN_SHADE	int
,	O
TOKEN_THREAD	int
,	O
TOKEN_NAME	int
,	O
TOKEN_NO_LINE	int
,	O
TOKEN_QUOTE	int
,	O
TOKEN_INCORRECT	int
,	O
TOKEN_JUSTIFICATION	int
,	O
TOKEN_SHAPE	int
,	O
TOKEN_LABEL	int
}	O
;	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
{	O
int	O
ln	int
;	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
c	int
;	O
int	O
eof	int
;	O
}	O
;	O
enum	O
tree_type	enum(int,int,int)
{	O
TREE_BINARY	int
,	O
TREE_PRODUCTION	int
,	O
TREE_SHIFT	int
}	O
;	O
enum	O
tree_options	enum(int,int,int,int)
{	O
TOPT_LEADER	int
=	O
001	int
,	O
TOPT_NO_CIRCLE	int
=	O
002	int
,	O
TOPT_THREAD	int
=	O
004	int
,	O
TOPT_NO_LINE	int
=	O
010	int
}	O
;	O
enum	O
label_position	enum(int,int,int,int)
{	O
LP_MIDDLE	int
,	O
LP_LEFT	int
,	O
LP_RIGHT	int
,	O
LP_COUNT	int
}	O
;	O
struct	O
tree	O
{	O
enum	O
tree_type	enum(int,int,int)
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
w	O
,	O
h	O
;	O
double	O
x	O
,	O
y	O
;	O
int	O
ofs	O
;	O
enum	O
tree_options	enum(int,int,int,int)
options	O
;	O
char	O
*	O
label	O
[	O
LP_COUNT	int
]	O
;	O
struct	O
tree	O
*	O
link	O
[	O
2	int
]	O
;	O
struct	O
tree	O
*	O
thread	O
[	O
2	int
]	O
;	O
int	O
shade	O
;	O
char	O
*	O
name	O
;	O
int	O
margin	O
[	O
2	int
]	O
;	O
int	O
justify	O
;	O
int	O
shape	O
;	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
prod_type	O
;	O
}	O
;	O
static	O
struct	O
tree	O
outside_thread	O
;	O
struct	O
canvas	O
{	O
int	O
w	O
;	O
int	O
ll	O
;	O
int	O
h	O
;	O
unsigned	O
char	O
*	O
buf	O
;	O
}	O
;	O
struct	O
space	O
{	O
int	O
sh	O
;	O
int	O
x0	O
,	O
w	O
;	O
int	O
y0	O
,	O
h	O
;	O
}	O
;	O
enum	O
justification	O
{	O
JT_LEFT	O
=	O
001	int
,	O
JT_RIGHT	O
=	O
002	int
,	O
JT_CENTER	O
=	O
003	int
,	O
JT_HORZ	O
=	O
003	int
,	O
JT_TOP	O
=	O
010	int
,	O
JT_MIDDLE	O
=	O
030	int
,	O
JT_VERT	O
=	O
030	int
}	O
;	O
static	O
void	O
lex_init	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
)	O
;	O
static	O
void	O
lex_get	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
)	O
;	O
static	O
int	O
lex_match	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
static	O
void	O
lex_get_string	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
char	O
*	O
*	O
s	O
)	O
;	O
static	O
struct	O
tree	O
*	O
tree_parse	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
,	O
enum	O
output_mode	enum(int,int)
)	O
;	O
static	O
void	O
tree_free	O
(	O
struct	O
tree	O
*	O
tree	O
)	O
;	O
static	O
void	O
tree_print	O
(	O
struct	O
tree	O
*	O
)	O
;	O
static	O
void	O
ps_resolve_threads	O
(	O
struct	O
tree	O
*	O
this	O
,	O
struct	O
tree	O
*	O
top	O
)	O
;	O
static	O
void	O
ps_measure_tree	O
(	O
struct	O
tree	O
*	O
,	O
int	O
*	O
radius	O
)	O
;	O
static	O
void	O
ps_draw_tree	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
space	O
*	O
space	O
,	O
int	O
radius	O
)	O
;	O
static	O
void	O
ps_draw_threads	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
,	O
double	O
radius	O
)	O
;	O
static	O
int	O
ps_determine_diam	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
;	O
static	O
void	O
ps_measure_text	O
(	O
const	O
char	O
*	O
text	O
,	O
int	O
*	O
w	O
,	O
int	O
*	O
h	O
)	O
;	O
static	O
void	O
ps_layout_tree	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
int	O
radius	O
)	O
;	O
static	O
void	O
ps_draw_tree_justified	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
radius	O
)	O
;	O
static	O
void	O
space_create	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
w	O
,	O
int	O
h	O
)	O
;	O
static	O
void	O
space_subdivide	O
(	O
struct	O
space	O
*	O
dst	O
,	O
const	O
struct	O
space	O
*	O
src	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
)	O
;	O
static	O
void	O
space_line	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
,	O
int	O
radius	O
,	O
int	O
s0	O
,	O
int	O
s1	O
)	O
;	O
static	O
void	O
space_circle	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
radius	O
,	O
int	O
shade	O
)	O
;	O
static	O
void	O
space_square	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
,	O
int	O
shade	O
)	O
;	O
static	O
void	O
space_text	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
const	O
char	O
*	O
text	O
,	O
enum	O
justification	O
,	O
int	O
adjust_height	O
,	O
int	O
shade	O
)	O
;	O
static	O
void	O
space_special	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
w	O
,	O
int	O
h	O
,	O
const	O
char	O
*	O
text	O
)	O
;	O
static	O
double	O
space_xc	O
(	O
const	O
struct	O
space	O
*	O
space	O
,	O
double	O
x	O
)	O
;	O
static	O
double	O
space_yc	O
(	O
const	O
struct	O
space	O
*	O
space	O
,	O
double	O
y	O
)	O
;	O
static	O
void	O
space_distance_along	O
(	O
double	O
x0	O
,	O
double	O
y0	O
,	O
double	O
x1	O
,	O
double	O
y1	O
,	O
double	O
radius	O
,	O
int	O
dir	O
,	O
double	O
*	O
x	O
,	O
double	O
*	O
y	O
,	O
int	O
shape	O
)	O
;	O
static	O
void	O
text_measure_tree	O
(	O
struct	O
tree	O
*	O
)	O
;	O
static	O
void	O
text_draw_tree	O
(	O
const	O
struct	O
tree	O
*	O
,	O
struct	O
canvas	O
*	O
)	O
;	O
static	O
void	O
text_measure_text	O
(	O
const	O
char	O
*	O
text	O
,	O
int	O
*	O
w	O
,	O
int	O
*	O
h	O
)	O
;	O
static	O
struct	O
tree	O
*	O
text_shift_tree	O
(	O
struct	O
tree	O
*	O
old	O
,	O
int	O
direction	O
)	O
;	O
static	O
int	O
text_trivial	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
;	O
static	O
int	O
text_caret	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
;	O
static	O
void	O
text_draw_line	O
(	O
struct	O
canvas	O
*	O
,	O
int	O
x0	O
,	O
int	O
x1	O
,	O
int	O
y	O
)	O
;	O
static	O
void	O
text_draw_text	O
(	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
w	O
,	O
const	O
char	O
*	O
text	O
)	O
;	O
static	O
void	O
text_draw_tree_justified	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
)	O
;	O
static	O
void	O
canvas_create	O
(	O
struct	O
canvas	O
*	O
,	O
int	O
w	O
,	O
int	O
h	O
)	O
;	O
static	O
void	O
canvas_free	O
(	O
struct	O
canvas	O
*	O
)	O
;	O
static	O
int	O
canvas_get	O
(	O
const	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
,	O
int	O
y	O
)	O
;	O
static	O
void	O
canvas_set	O
(	O
struct	O
canvas	O
*	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
c	int
)	O
;	O
static	O
void	O
canvas_subdivide	O
(	O
struct	O
canvas	O
*	O
dst	O
,	O
const	O
struct	O
canvas	O
*	O
src	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
)	O
;	O
static	O
void	O
canvas_print	O
(	O
const	O
struct	O
canvas	O
*	O
)	O
;	O
static	O
void	O
error	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
,	O
const	O
char	O
*	O
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	O
(	O
printf	(*(char))->(int)
,	O
2	int
,	O
3	int
)	O
)	O
)	O
;	O
static	O
void	O
*	O
xmalloc	O
(	O
size_t	long
)	O
;	O
static	O
void	O
*	O
xrealloc	O
(	O
void	O
*	O
ptr	O
,	O
size_t	long
size	O
)	O
;	O
static	O
int	O
max	O
(	O
int	O
a	O
,	O
int	O
b	O
)	O
;	O
int	O
main	O
(	O
int	O
argc	O
,	O
char	O
*	O
argv	O
[	O
]	O
)	O
{	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
;	O
enum	O
output_mode	enum(int,int)
mode	O
=	O
MODE_POSTSCRIPT	int
;	O
struct	O
tree	O
*	O
*	O
input	O
=	O
NULL	O
;	O
int	O
*	O
radius	O
=	O
NULL	O
;	O
int	O
m	O
,	O
n	O
;	O
int	O
width	O
,	O
height	O
;	O
int	O
page_width	O
;	O
int	O
i	O
,	O
y	O
;	O
struct	O
space	O
page	O
;	O
if	O
(	O
argc	O
>=	O
2	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	O
[	O
1	int
]	O
,	O
"--"	*(char)
,	O
2	int
)	O
)	O
argv	O
[	O
1	int
]	O
+=	O
2	int
;	O
if	O
(	O
argc	O
<	O
2	int
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
1	int
]	O
,	O
"help"	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"texitree, a program for drawing binary trees\n"	*(char)
"Usage: %s COMMAND [OPTION...]\n"	*(char)
"\nCommands:\n"	*(char)
"  text < tree.in > tree.txt   output plain text\n"	*(char)
"  ps < tree.in > tree.eps     output PostScript\n"	*(char)
"  help                        print this help, then exit\n"	*(char)
"  version                     show version, then exit\n"	*(char)
"\nOptions:\n"	*(char)
"  -w WIDTH  page width for centering, WIDTH in characters (text)\n"	*(char)
"            or 1/1000 point (PostScript), default 72 or 612000\n"	*(char)
"\nReport bugs to Ben Pfaff <blp@gnu.org>.\n"	*(char)
,	O
argv	O
[	O
0	int
]	O
)	O
;	O
return	O
argc	O
==	O
2	int
?	O
EXIT_SUCCESS	O
:	O
EXIT_FAILURE	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
1	int
]	O
,	O
"version"	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"texitree 0.9.0\n"	*(char)
"Copyright (C) 2000 Free Software Foundation, Inc.\n"	*(char)
"texiweb comes with NO WARRANTY, to the extent permitted by law,\n"	*(char)
"not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	*(char)
"You may redistribute copies of texiweb under the terms of the GNU\n"	*(char)
"General Public License.  For more information about these\n"	*(char)
"matters, see the file named COPYING.\n"	*(char)
"Written by Ben Pfaff <blp@gnu.org>.\n"	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
1	int
]	O
,	O
"ps"	*(char)
)	O
)	O
{	O
mode	O
=	O
MODE_POSTSCRIPT	int
;	O
page_width	O
=	O
612000	int
;	O
if	O
(	O
argc	O
==	O
4	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
2	int
]	O
,	O
"-w"	*(char)
)	O
)	O
page_width	O
=	O
atoi	(*(char))->(int)
(	O
argv	O
[	O
3	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
1	int
]	O
,	O
"text"	*(char)
)	O
)	O
{	O
mode	O
=	O
MODE_TEXT	int
;	O
page_width	O
=	O
72	int
;	O
if	O
(	O
argc	O
==	O
4	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
2	int
]	O
,	O
"-w"	*(char)
)	O
)	O
page_width	O
=	O
atoi	(*(char))->(int)
(	O
argv	O
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"bad command; use --help for usage\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	O
;	O
}	O
lex_init	O
(	O
&	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
lex_get	O
(	O
&	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
n	O
=	O
m	O
=	O
0	int
;	O
while	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
.	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOKEN_EOF	int
)	O
{	O
if	O
(	O
n	O
>=	O
m	O
)	O
{	O
m	O
=	O
2	int
*	O
n	O
+	O
8	int
;	O
input	O
=	O
xrealloc	O
(	O
input	O
,	O
sizeof	O
*	O
input	O
*	O
m	O
)	O
;	O
radius	O
=	O
xrealloc	O
(	O
radius	O
,	O
sizeof	O
*	O
radius	O
*	O
m	O
)	O
;	O
}	O
input	O
[	O
n	O
++	O
]	O
=	O
tree_parse	O
(	O
&	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
mode	O
)	O
;	O
}	O
height	O
=	O
0	int
;	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
{	O
height	O
+=	O
(	O
n	O
-	O
1	int
)	O
*	O
PS_CHAR_HEIGHT	O
;	O
height	O
+=	O
PS_TOP_MARGIN	O
+	O
PS_BOT_MARGIN	O
;	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
n	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
{	O
ps_resolve_threads	O
(	O
input	O
[	O
i	O
]	O
,	O
input	O
[	O
i	O
]	O
)	O
;	O
ps_measure_tree	O
(	O
input	O
[	O
i	O
]	O
,	O
&	O
radius	O
[	O
i	O
]	O
)	O
;	O
}	O
else	O
text_measure_tree	O
(	O
input	O
[	O
i	O
]	O
)	O
;	O
height	O
+=	O
input	O
[	O
i	O
]	O
->	O
h	O
;	O
}	O
width	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
n	O
;	O
i	O
++	O
)	O
width	O
=	O
max	O
(	O
width	O
,	O
input	O
[	O
i	O
]	O
->	O
w	O
)	O
;	O
if	O
(	O
width	O
>	O
page_width	O
)	O
page_width	O
=	O
width	O
;	O
y	O
=	O
mode	O
==	O
MODE_POSTSCRIPT	int
?	O
72000	int
:	O
0	int
;	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
{	O
int	O
x0	O
=	O
page_width	O
/	O
2	int
-	O
width	O
/	O
2	int
-	O
1000	int
;	O
int	O
x1	O
=	O
page_width	O
/	O
2	int
+	O
width	O
/	O
2	int
+	O
1000	int
;	O
int	O
y0	O
=	O
y	O
-	O
1000	int
;	O
int	O
y1	O
=	O
y	O
+	O
height	O
+	O
1000	int
;	O
space_create	O
(	O
&	O
page	O
,	O
page_width	O
,	O
792000	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%%!PS-Adobe-3.0 EPSF-3.0\n"	*(char)
"%%%%BoundingBox: %.0f %.0f %.0f %.0f\n"	*(char)
"/ED { exch def } def\n"	*(char)
"/MT { moveto } def\n"	*(char)
"/LT { lineto } def\n"	*(char)
"/L { newpath MT LT stroke } bind def\n"	*(char)
"/F { exch findfont exch scalefont setfont } bind def\n"	*(char)
"/C { dup 3 index add 2 index MT 0 360 arc stroke } "	*(char)
"bind def\n"	*(char)
"/SG { 100 div setgray } bind def\n"	*(char)
"/D { SG dup 3 index add 2 index MT 0 360 arc fill 0 SG } "	*(char)
"bind def\n"	*(char)
"/TC { SG dup stringwidth pop 2 div 4 -1 roll exch sub\n"	*(char)
"     3 -1 roll MT show 0 SG } bind def\n"	*(char)
"/TR { SG dup stringwidth pop 4 -1 roll exch sub\n"	*(char)
"     3 -1 roll MT show 0 SG } bind def\n"	*(char)
"/TL { SG 0 4 -1 roll exch sub\n"	*(char)
"     3 -1 roll MT show 0 SG } bind def\n"	*(char)
"/S { gsave /Symbol 12 F 0 TC grestore } bind def\n"	*(char)
"/T { [2 1] 0 setdash MT curveto stroke } bind def\n"	*(char)
"/A { [] 0 setdash /y ED /x ED x 1.4 sub y 4 sub\n"	*(char)
"     MT x y LT x 1.4 add y 4 sub LT fill } def\n"	*(char)
"/Q { /y1 ED /x1 ED /y0 ED /x0 ED\n"	*(char)
"     x0 y0 MT x1 y0 LT x1 y1 LT x0 y1 LT\n"	*(char)
"     x0 y0 LT closepath } def\n"	*(char)
"/SD { Q stroke } def\n"	*(char)
"/SS { SG Q fill 0 SG } def\n"	*(char)
"/Helvetica 12 F\n"	*(char)
,	O
space_xc	O
(	O
&	O
page	O
,	O
x0	O
)	O
,	O
space_yc	O
(	O
&	O
page	O
,	O
y1	O
)	O
,	O
space_xc	O
(	O
&	O
page	O
,	O
x1	O
)	O
,	O
space_yc	O
(	O
&	O
page	O
,	O
y0	O
)	O
)	O
;	O
y	O
+=	O
PS_TOP_MARGIN	O
;	O
}	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
n	O
;	O
i	O
++	O
)	O
{	O
int	O
x0	O
=	O
page_width	O
/	O
2	int
-	O
input	O
[	O
i	O
]	O
->	O
w	O
/	O
2	int
;	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
{	O
struct	O
space	O
space	O
;	O
space_subdivide	O
(	O
&	O
space	O
,	O
&	O
page	O
,	O
x0	O
,	O
y	O
,	O
x0	O
+	O
input	O
[	O
i	O
]	O
->	O
w	O
,	O
y	O
+	O
input	O
[	O
i	O
]	O
->	O
h	O
)	O
;	O
ps_draw_tree	O
(	O
input	O
[	O
i	O
]	O
,	O
&	O
space	O
,	O
radius	O
[	O
i	O
]	O
)	O
;	O
ps_draw_threads	O
(	O
input	O
[	O
i	O
]	O
,	O
radius	O
[	O
i	O
]	O
/	O
1000.	int
)	O
;	O
if	O
(	O
i	O
<	O
n	O
-	O
1	int
)	O
y	O
+=	O
input	O
[	O
i	O
]	O
->	O
h	O
+	O
PS_CHAR_HEIGHT	O
;	O
}	O
else	O
{	O
struct	O
canvas	O
canvas	O
,	O
subcanvas	O
;	O
canvas_create	O
(	O
&	O
canvas	O
,	O
x0	O
+	O
input	O
[	O
i	O
]	O
->	O
w	O
,	O
input	O
[	O
i	O
]	O
->	O
h	O
)	O
;	O
canvas_subdivide	O
(	O
&	O
subcanvas	O
,	O
&	O
canvas	O
,	O
x0	O
,	O
0	int
,	O
x0	O
+	O
input	O
[	O
i	O
]	O
->	O
w	O
,	O
input	O
[	O
i	O
]	O
->	O
h	O
)	O
;	O
text_draw_tree	O
(	O
input	O
[	O
i	O
]	O
,	O
&	O
subcanvas	O
)	O
;	O
canvas_print	O
(	O
&	O
canvas	O
)	O
;	O
canvas_free	O
(	O
&	O
canvas	O
)	O
;	O
if	O
(	O
i	O
<	O
n	O
-	O
1	int
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
tree_free	O
(	O
input	O
[	O
i	O
]	O
)	O
;	O
}	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"showpage\n"	*(char)
"%%EOF\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mode	O
==	O
MODE_TEXT	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" \n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
input	O
)	O
;	O
free	(*(void))->(void)
(	O
radius	O
)	O
;	O
return	O
EXIT_SUCCESS	O
;	O
}	O
static	O
void	O
lex_init	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
{	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
ln	int
=	O
1	int
;	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
eof	int
=	O
0	int
;	O
}	O
static	O
void	O
lex_putback	O
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
lex_get	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
{	O
int	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
ln	int
++	O
;	O
}	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
;	O
if	O
(	O
c	int
!=	O
'#'	O
)	O
break	O
;	O
do	O
{	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
ln	int
++	O
;	O
}	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
=	O
c	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_EOF	int
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
eof	int
==	O
1	int
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"unexpected end of file"	*(char)
)	O
;	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
eof	int
=	O
1	int
;	O
break	O
;	O
case	O
'('	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_LPAREN	int
;	O
break	O
;	O
case	O
')'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_RPAREN	int
;	O
break	O
;	O
case	O
'/'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_LEFT	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_RIGHT	int
;	O
break	O
;	O
case	O
','	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
'<'	O
:	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'>'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_TWOWAY	int
;	O
break	O
;	O
case	O
'='	O
:	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'>'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_PRODUCES	int
;	O
else	O
{	O
lex_putback	O
(	O
c	int
)	O
;	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_NAME	int
;	O
}	O
break	O
;	O
case	O
'^'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_NO_CIRCLE	int
;	O
break	O
;	O
case	O
'*'	O
:	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'*'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_INCORRECT	int
;	O
else	O
{	O
lex_putback	O
(	O
c	int
)	O
;	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_LEADER	int
;	O
}	O
break	O
;	O
case	O
'%'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_SHADE	int
;	O
break	O
;	O
case	O
'|'	O
:	O
c	int
=	O
getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'|'	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_ADJACENT	int
;	O
else	O
{	O
lex_putback	O
(	O
c	int
)	O
;	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_MIDDLE	int
;	O
}	O
break	O
;	O
case	O
'>'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_THREAD	int
;	O
break	O
;	O
case	O
'!'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_NO_LINE	int
;	O
break	O
;	O
case	O
'"'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_QUOTE	int
;	O
break	O
;	O
case	O
'$'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_JUSTIFICATION	int
;	O
break	O
;	O
case	O
'@'	O
:	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_SHAPE	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
isprint	(int)->(int)
(	O
c	int
)	O
)	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TOKEN_LABEL	int
;	O
else	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"bad character in input"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
lex_match	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
add_char	O
(	O
char	O
*	O
*	O
s	O
,	O
int	O
c	int
)	O
{	O
size_t	long
len	O
=	O
0	int
;	O
if	O
(	O
*	O
s	O
!=	O
NULL	O
)	O
len	O
=	O
strlen	(*(char))->(long)
(	O
*	O
s	O
)	O
;	O
*	O
s	O
=	O
xrealloc	O
(	O
*	O
s	O
,	O
len	O
+	O
2	int
)	O
;	O
(	O
*	O
s	O
)	O
[	O
len	O
]	O
=	O
c	int
;	O
(	O
*	O
s	O
)	O
[	O
len	O
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
lex_get_string	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
char	O
*	O
*	O
s	O
)	O
{	O
if	O
(	O
*	O
s	O
!=	O
NULL	O
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"duplicate node or thread name"	*(char)
)	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TOKEN_QUOTE	int
)	O
{	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
do	O
{	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOKEN_LABEL	int
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"non-label character inside quoted string"	*(char)
)	O
;	O
add_char	O
(	O
s	O
,	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
)	O
;	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
}	O
while	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOKEN_QUOTE	int
)	O
;	O
}	O
else	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TOKEN_LABEL	int
)	O
add_char	O
(	O
s	O
,	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
)	O
;	O
else	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"node or thread name expected"	*(char)
)	O
;	O
}	O
static	O
struct	O
tree	O
*	O
parse_production	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
struct	O
tree	O
*	O
tree1	O
,	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
enum	O
output_mode	enum(int,int)
)	O
;	O
static	O
void	O
parse_tree_label	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
struct	O
tree	O
*	O
tree	O
,	O
enum	O
output_mode	enum(int,int)
mode	O
)	O
;	O
static	O
struct	O
tree	O
*	O
tree_parse	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
enum	O
output_mode	enum(int,int)
mode	O
)	O
{	O
struct	O
tree	O
*	O
tree	O
=	O
xmalloc	O
(	O
sizeof	O
*	O
tree	O
)	O
;	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TREE_BINARY	int
;	O
tree	O
->	O
options	O
=	O
0	int
;	O
tree	O
->	O
thread	O
[	O
0	int
]	O
=	O
tree	O
->	O
thread	O
[	O
1	int
]	O
=	O
NULL	O
;	O
tree	O
->	O
margin	O
[	O
0	int
]	O
=	O
tree	O
->	O
margin	O
[	O
1	int
]	O
=	O
0	int
;	O
tree	O
->	O
name	O
=	O
NULL	O
;	O
parse_tree_label	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
tree	O
,	O
mode	O
)	O
;	O
tree	O
->	O
link	O
[	O
0	int
]	O
=	O
tree	O
->	O
link	O
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_LPAREN	int
)	O
)	O
{	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOKEN_COMMA	int
)	O
tree	O
->	O
link	O
[	O
0	int
]	O
=	O
tree_parse	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
mode	O
)	O
;	O
if	O
(	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_COMMA	int
)	O
)	O
tree	O
->	O
link	O
[	O
1	int
]	O
=	O
tree_parse	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
mode	O
)	O
;	O
if	O
(	O
!	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_RPAREN	int
)	O
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"expecting right paren"	*(char)
)	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
==	O
0	int
&&	O
tree	O
->	O
label	O
[	O
LP_LEFT	int
]	O
==	O
NULL	O
&&	O
tree	O
->	O
label	O
[	O
LP_RIGHT	int
]	O
==	O
NULL	O
&&	O
tree	O
->	O
link	O
[	O
0	int
]	O
==	O
NULL	O
&&	O
tree	O
->	O
link	O
[	O
1	int
]	O
==	O
NULL	O
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"node has no label and no children"	*(char)
)	O
;	O
if	O
(	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_TWOWAY	int
)	O
)	O
return	O
parse_production	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
tree	O
,	O
TOKEN_TWOWAY	int
,	O
mode	O
)	O
;	O
else	O
if	O
(	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_PRODUCES	int
)	O
)	O
return	O
parse_production	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
tree	O
,	O
TOKEN_PRODUCES	int
,	O
mode	O
)	O
;	O
else	O
if	O
(	O
lex_match	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
TOKEN_ADJACENT	int
)	O
)	O
return	O
parse_production	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
tree	O
,	O
TOKEN_ADJACENT	int
,	O
mode	O
)	O
;	O
else	O
return	O
tree	O
;	O
}	O
static	O
void	O
parse_tree_label	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
struct	O
tree	O
*	O
tree	O
,	O
enum	O
output_mode	enum(int,int)
mode	O
)	O
{	O
enum	O
label_position	enum(int,int,int,int)
pos	O
;	O
size_t	long
count	O
;	O
{	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
LP_COUNT	int
;	O
i	O
++	O
)	O
tree	O
->	O
label	O
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
tree	O
->	O
shade	O
=	O
100	int
;	O
tree	O
->	O
justify	O
=	O
'm'	O
;	O
tree	O
->	O
shape	O
=	O
'c'	O
;	O
pos	O
=	O
LP_MIDDLE	int
;	O
for	O
(	O
count	O
=	O
0	int
;	O
;	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
,	O
count	O
++	O
)	O
switch	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TOKEN_INCORRECT	int
:	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
'*'	O
)	O
;	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
'*'	O
)	O
;	O
tree	O
->	O
options	O
|=	O
TOPT_NO_CIRCLE	int
;	O
break	O
;	O
case	O
TOKEN_LEFT	int
:	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
pos	O
=	O
LP_LEFT	int
;	O
break	O
;	O
case	O
TOKEN_RIGHT	int
:	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
pos	O
=	O
LP_RIGHT	int
;	O
break	O
;	O
case	O
TOKEN_MIDDLE	int
:	O
pos	O
=	O
LP_MIDDLE	int
;	O
break	O
;	O
case	O
TOKEN_LABEL	int
:	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
'\''	O
)	O
{	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
'*'	O
)	O
;	O
}	O
else	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
';'	O
)	O
{	O
if	O
(	O
mode	O
==	O
MODE_TEXT	int
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
','	O
)	O
;	O
}	O
else	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
)	O
;	O
break	O
;	O
break	O
;	O
case	O
TOKEN_SHADE	int
:	O
{	O
char	O
*	O
arg	O
=	O
NULL	O
;	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
lex_get_string	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
&	O
arg	O
)	O
;	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
arg	O
,	O
"b"	*(char)
)	O
)	O
tree	O
->	O
shade	O
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
arg	O
,	O
"g"	*(char)
)	O
)	O
tree	O
->	O
shade	O
=	O
100	int
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
arg	O
,	O
"r"	*(char)
)	O
)	O
tree	O
->	O
shade	O
=	O
75	int
;	O
else	O
for	O
(	O
;	O
*	O
arg	O
!=	O
'\0'	O
;	O
arg	O
++	O
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
*	O
arg	O
)	O
;	O
}	O
else	O
{	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
'&'	O
)	O
;	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
'<'	O
)	O
;	O
for	O
(	O
;	O
*	O
arg	O
!=	O
'\0'	O
;	O
arg	O
++	O
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
*	O
arg	O
)	O
;	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
pos	O
]	O
,	O
'>'	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TOKEN_JUSTIFICATION	int
:	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
't'	O
||	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
'm'	O
||	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
'b'	O
)	O
tree	O
->	O
justify	O
=	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
;	O
else	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"expecting `t', `m', or `b'"	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_SHAPE	int
:	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
'c'	O
||	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
's'	O
)	O
tree	O
->	O
shape	O
=	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
;	O
else	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"expecting `c', `s'"	*(char)
)	O
;	O
if	O
(	O
tree	O
->	O
shape	O
==	O
's'	O
&&	O
mode	O
==	O
MODE_TEXT	int
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
'['	O
)	O
;	O
break	O
;	O
case	O
TOKEN_NO_CIRCLE	int
:	O
tree	O
->	O
options	O
|=	O
TOPT_NO_CIRCLE	int
;	O
break	O
;	O
case	O
TOKEN_NO_LINE	int
:	O
tree	O
->	O
options	O
|=	O
TOPT_NO_LINE	int
;	O
break	O
;	O
case	O
TOKEN_LEADER	int
:	O
tree	O
->	O
options	O
|=	O
TOPT_LEADER	int
;	O
break	O
;	O
case	O
TOKEN_NAME	int
:	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
lex_get_string	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
&	O
tree	O
->	O
name	O
)	O
;	O
break	O
;	O
case	O
TOKEN_THREAD	int
:	O
lex_get	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
)	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
TOKEN_THREAD	int
)	O
lex_get_string	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
&	O
tree	O
->	O
name	O
)	O
;	O
if	O
(	O
mode	O
==	O
MODE_POSTSCRIPT	int
)	O
tree	O
->	O
options	O
|=	O
TOPT_THREAD	int
;	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
'['	O
)	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
!=	O
'>'	O
)	O
{	O
const	O
char	O
*	O
p	O
;	O
for	O
(	O
p	O
=	O
tree	O
->	O
name	O
;	O
*	O
p	O
!=	O
'\0'	O
;	O
p	O
++	O
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
*	O
p	O
)	O
;	O
}	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
']'	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
count	O
==	O
0	int
)	O
error	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
"expecting label"	*(char)
)	O
;	O
if	O
(	O
tree	O
->	O
shape	O
==	O
's'	O
&&	O
mode	O
==	O
MODE_TEXT	int
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
']'	O
)	O
;	O
if	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
==	O
NULL	O
)	O
add_char	O
(	O
&	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
'\0'	O
)	O
;	O
return	O
;	O
}	O
}	O
static	O
struct	O
tree	O
*	O
parse_production	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
struct	O
tree	O
*	O
tree1	O
,	O
enum	O
token_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
prod_type	O
,	O
enum	O
output_mode	enum(int,int)
mode	O
)	O
{	O
struct	O
tree	O
*	O
tree2	O
=	O
tree_parse	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
mode	O
)	O
;	O
struct	O
tree	O
*	O
production	O
=	O
xmalloc	O
(	O
sizeof	O
*	O
production	O
)	O
;	O
production	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TREE_PRODUCTION	int
;	O
production	O
->	O
prod_type	O
=	O
prod_type	O
;	O
production	O
->	O
link	O
[	O
0	int
]	O
=	O
tree1	O
;	O
production	O
->	O
link	O
[	O
1	int
]	O
=	O
tree2	O
;	O
production	O
->	O
name	O
=	O
NULL	O
;	O
return	O
production	O
;	O
}	O
static	O
void	O
tree_free	O
(	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
tree_free	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
tree_free	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
tree	O
->	O
name	O
)	O
;	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
)	O
{	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
LP_COUNT	int
;	O
i	O
++	O
)	O
free	(*(void))->(void)
(	O
tree	O
->	O
label	O
[	O
i	O
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
tree	O
)	O
;	O
}	O
static	O
void	O
tree_print	O
(	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
switch	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TREE_BINARY	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
||	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'('	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
tree_print	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
','	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tree_print	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
')'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
tree_print	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_TWOWAY	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" <> "	*(char)
)	O
;	O
else	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_PRODUCES	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" => "	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" || "	*(char)
)	O
;	O
tree_print	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
struct	O
tree	O
*	O
find_node_by_name	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
const	O
char	O
*	O
name	O
)	O
{	O
if	O
(	O
tree	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
options	O
&	O
TOPT_THREAD	int
)	O
&&	O
tree	O
->	O
name	O
!=	O
NULL	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
tree	O
->	O
name	O
,	O
name	O
)	O
)	O
return	O
tree	O
;	O
{	O
struct	O
tree	O
*	O
tmp	O
=	O
find_node_by_name	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
name	O
)	O
;	O
if	O
(	O
tmp	O
!=	O
NULL	O
)	O
return	O
tmp	O
;	O
}	O
return	O
find_node_by_name	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
name	O
)	O
;	O
}	O
static	O
void	O
ps_resolve_threads	O
(	O
struct	O
tree	O
*	O
this	O
,	O
struct	O
tree	O
*	O
top	O
)	O
{	O
int	O
i	O
;	O
if	O
(	O
this	O
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
2	int
;	O
i	O
++	O
)	O
if	O
(	O
this	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
&&	O
this	O
->	O
link	O
[	O
i	O
]	O
!=	O
NULL	O
&&	O
(	O
this	O
->	O
link	O
[	O
i	O
]	O
->	O
options	O
&	O
TOPT_THREAD	int
)	O
)	O
{	O
if	O
(	O
this	O
->	O
link	O
[	O
i	O
]	O
->	O
name	O
!=	O
NULL	O
)	O
{	O
this	O
->	O
thread	O
[	O
i	O
]	O
=	O
find_node_by_name	O
(	O
top	O
,	O
this	O
->	O
link	O
[	O
i	O
]	O
->	O
name	O
)	O
;	O
if	O
(	O
this	O
->	O
thread	O
[	O
i	O
]	O
==	O
NULL	O
)	O
error	O
(	O
NULL	O
,	O
"thread to nonexistent node %s"	*(char)
,	O
this	O
->	O
link	O
[	O
i	O
]	O
->	O
name	O
)	O
;	O
}	O
else	O
this	O
->	O
thread	O
[	O
i	O
]	O
=	O
&	O
outside_thread	O
;	O
tree_free	O
(	O
this	O
->	O
link	O
[	O
i	O
]	O
)	O
;	O
this	O
->	O
link	O
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
else	O
ps_resolve_threads	O
(	O
this	O
->	O
link	O
[	O
i	O
]	O
,	O
this	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
?	O
top	O
:	O
this	O
->	O
link	O
[	O
i	O
]	O
)	O
;	O
}	O
static	O
int	O
calc_margin	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
int	O
side	O
)	O
{	O
int	O
label_pos	O
=	O
side	O
==	O
0	int
?	O
LP_LEFT	int
:	O
LP_RIGHT	int
;	O
int	O
margin	O
=	O
0	int
;	O
for	O
(	O
;	O
tree	O
!=	O
NULL	O
;	O
tree	O
=	O
tree	O
->	O
link	O
[	O
side	O
]	O
)	O
if	O
(	O
tree	O
->	O
label	O
[	O
label_pos	O
]	O
!=	O
NULL	O
)	O
{	O
int	O
w	O
,	O
h	O
;	O
int	O
threshold	O
;	O
threshold	O
=	O
0	int
;	O
if	O
(	O
tree	O
->	O
thread	O
[	O
side	O
]	O
==	O
&	O
outside_thread	O
)	O
threshold	O
+=	O
PS_THREAD_WIDTH	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
side	O
]	O
!=	O
NULL	O
)	O
threshold	O
+=	O
tree	O
->	O
link	O
[	O
side	O
]	O
->	O
w	O
;	O
ps_measure_text	O
(	O
tree	O
->	O
label	O
[	O
label_pos	O
]	O
,	O
&	O
w	O
,	O
&	O
h	O
)	O
;	O
w	O
+=	O
2	int
*	O
PS_MARGIN	O
;	O
if	O
(	O
w	O
>	O
threshold	O
&&	O
w	O
-	O
threshold	O
>	O
margin	O
)	O
margin	O
=	O
w	O
-	O
threshold	O
;	O
}	O
return	O
margin	O
;	O
}	O
static	O
void	O
pad_top_level_tree	O
(	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
margin	O
[	O
0	int
]	O
=	O
calc_margin	O
(	O
tree	O
,	O
0	int
)	O
;	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
margin	O
[	O
1	int
]	O
=	O
calc_margin	O
(	O
tree	O
,	O
1	int
)	O
;	O
}	O
static	O
void	O
ps_measure_tree	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
int	O
*	O
radius	O
)	O
{	O
*	O
radius	O
=	O
(	O
ps_determine_diam	O
(	O
tree	O
)	O
+	O
PS_MARGIN	O
+	O
1	int
)	O
/	O
2	int
;	O
ps_layout_tree	O
(	O
tree	O
,	O
*	O
radius	O
)	O
;	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
)	O
pad_top_level_tree	O
(	O
tree	O
)	O
;	O
}	O
static	O
void	O
ps_draw_tree	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
space	O
*	O
space	O
,	O
int	O
radius	O
)	O
{	O
switch	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
int	O
x	O
=	O
0	int
;	O
if	O
(	O
tree	O
->	O
thread	O
[	O
0	int
]	O
==	O
&	O
outside_thread	O
)	O
x	O
+=	O
PS_THREAD_WIDTH	O
;	O
x	O
+=	O
tree	O
->	O
margin	O
[	O
0	int
]	O
;	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
space_subdivide	O
(	O
space	O
,	O
space	O
,	O
0	int
,	O
radius	O
,	O
space	O
->	O
w	O
,	O
space	O
->	O
h	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
space	O
subspace	O
;	O
space_subdivide	O
(	O
&	O
subspace	O
,	O
space	O
,	O
x	O
,	O
radius	O
*	O
3	int
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
,	O
radius	O
*	O
3	int
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
)	O
;	O
ps_draw_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
&	O
subspace	O
,	O
radius	O
)	O
;	O
x	O
+=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
options	O
&	O
TOPT_NO_LINE	int
)	O
)	O
space_line	O
(	O
space	O
,	O
x	O
+	O
radius	O
,	O
radius	O
,	O
tree	O
->	O
margin	O
[	O
0	int
]	O
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
+	O
radius	O
,	O
radius	O
*	O
4	int
,	O
radius	O
,	O
tree	O
->	O
shape	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
shape	O
)	O
;	O
}	O
tree	O
->	O
x	O
=	O
space_xc	O
(	O
space	O
,	O
x	O
+	O
radius	O
)	O
;	O
tree	O
->	O
y	O
=	O
space_yc	O
(	O
space	O
,	O
radius	O
)	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
options	O
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
{	O
if	O
(	O
tree	O
->	O
shape	O
==	O
'c'	O
)	O
space_circle	O
(	O
space	O
,	O
x	O
+	O
radius	O
,	O
radius	O
,	O
radius	O
,	O
tree	O
->	O
shade	O
)	O
;	O
else	O
space_square	O
(	O
space	O
,	O
x	O
,	O
0	int
,	O
x	O
+	O
2	int
*	O
radius	O
,	O
2	int
*	O
radius	O
,	O
tree	O
->	O
shade	O
)	O
;	O
space_text	O
(	O
space	O
,	O
x	O
+	O
radius	O
,	O
radius	O
,	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
JT_CENTER	O
|	O
JT_MIDDLE	O
,	O
1	int
,	O
tree	O
->	O
shade	O
<=	O
50	int
?	O
100	int
:	O
0	int
)	O
;	O
if	O
(	O
tree	O
->	O
label	O
[	O
LP_LEFT	int
]	O
!=	O
NULL	O
)	O
space_text	O
(	O
space	O
,	O
x	O
-	O
PS_MARGIN	O
,	O
radius	O
,	O
tree	O
->	O
label	O
[	O
LP_LEFT	int
]	O
,	O
JT_RIGHT	O
|	O
JT_MIDDLE	O
,	O
1	int
,	O
0	int
)	O
;	O
x	O
+=	O
2	int
*	O
radius	O
;	O
if	O
(	O
tree	O
->	O
label	O
[	O
LP_RIGHT	int
]	O
!=	O
NULL	O
)	O
space_text	O
(	O
space	O
,	O
x	O
+	O
PS_MARGIN	O
,	O
radius	O
,	O
tree	O
->	O
label	O
[	O
LP_RIGHT	int
]	O
,	O
JT_LEFT	O
|	O
JT_MIDDLE	O
,	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
int	O
w	O
,	O
h	O
;	O
ps_measure_text	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
&	O
w	O
,	O
&	O
h	O
)	O
;	O
space_text	O
(	O
space	O
,	O
x	O
+	O
PS_MARGIN	O
+	O
w	O
/	O
2	int
,	O
radius	O
,	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
JT_CENTER	O
|	O
JT_TOP	O
,	O
0	int
,	O
0	int
)	O
;	O
x	O
+=	O
w	O
+	O
PS_MARGIN	O
*	O
2	int
;	O
}	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
space_line	O
(	O
space	O
,	O
x	O
-	O
radius	O
,	O
-	O
radius	O
,	O
x	O
-	O
radius	O
,	O
0	int
,	O
0	int
,	O
'c'	O
,	O
tree	O
->	O
shape	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
space	O
subspace	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
options	O
&	O
TOPT_NO_LINE	int
)	O
)	O
space_line	O
(	O
space	O
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
ofs	O
+	O
radius	O
,	O
radius	O
*	O
4	int
,	O
x	O
-	O
radius	O
,	O
radius	O
,	O
radius	O
,	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
shape	O
,	O
tree	O
->	O
shape	O
)	O
;	O
space_subdivide	O
(	O
&	O
subspace	O
,	O
space	O
,	O
x	O
,	O
radius	O
*	O
3	int
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
,	O
radius	O
*	O
3	int
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
ps_draw_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
&	O
subspace	O
,	O
radius	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
int	O
extra_space	O
;	O
ps_draw_tree_justified	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
space	O
,	O
0	int
,	O
radius	O
)	O
;	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_PRODUCES	int
)	O
space_special	O
(	O
space	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
,	O
0	int
,	O
PS_CHAR_WIDTH	O
*	O
4	int
,	O
tree	O
->	O
h	O
,	O
"\\336"	*(char)
)	O
;	O
else	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_TWOWAY	int
)	O
space_special	O
(	O
space	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
,	O
0	int
,	O
PS_CHAR_WIDTH	O
*	O
4	int
,	O
tree	O
->	O
h	O
,	O
"\\333"	*(char)
)	O
;	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_ADJACENT	int
)	O
extra_space	O
=	O
2	int
*	O
PS_CHAR_WIDTH	O
;	O
else	O
extra_space	O
=	O
4	int
*	O
PS_CHAR_WIDTH	O
;	O
ps_draw_tree_justified	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
space	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
extra_space	O
,	O
radius	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
ps_draw_threads	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
,	O
double	O
radius	O
)	O
{	O
int	O
i	O
;	O
if	O
(	O
tree	O
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
2	int
;	O
i	O
++	O
)	O
{	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
&&	O
tree	O
->	O
thread	O
[	O
i	O
]	O
!=	O
NULL	O
)	O
{	O
double	O
x	O
[	O
4	int
]	O
,	O
y	O
[	O
4	int
]	O
;	O
x	O
[	O
0	int
]	O
=	O
tree	O
->	O
x	O
-	O
2	int
+	O
4	int
*	O
i	O
;	O
y	O
[	O
0	int
]	O
=	O
tree	O
->	O
y	O
-	O
radius	O
;	O
x	O
[	O
1	int
]	O
=	O
x	O
[	O
0	int
]	O
;	O
y	O
[	O
1	int
]	O
=	O
y	O
[	O
0	int
]	O
-	O
10.	int
;	O
if	O
(	O
tree	O
->	O
thread	O
[	O
i	O
]	O
!=	O
&	O
outside_thread	O
)	O
{	O
x	O
[	O
3	int
]	O
=	O
tree	O
->	O
thread	O
[	O
i	O
]	O
->	O
x	O
+	O
2	int
-	O
4	int
*	O
i	O
;	O
y	O
[	O
3	int
]	O
=	O
tree	O
->	O
thread	O
[	O
i	O
]	O
->	O
y	O
-	O
radius	O
-	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
i	O
==	O
0	int
)	O
x	O
[	O
3	int
]	O
=	O
x	O
[	O
0	int
]	O
-	O
radius	O
-	O
PS_THREAD_WIDTH	O
/	O
1000.	int
+	O
3	int
;	O
else	O
x	O
[	O
3	int
]	O
=	O
x	O
[	O
0	int
]	O
+	O
radius	O
+	O
PS_THREAD_WIDTH	O
/	O
1000.	int
-	O
3	int
;	O
y	O
[	O
3	int
]	O
=	O
y	O
[	O
0	int
]	O
+	O
radius	O
;	O
}	O
x	O
[	O
2	int
]	O
=	O
x	O
[	O
3	int
]	O
;	O
y	O
[	O
2	int
]	O
=	O
y	O
[	O
1	int
]	O
;	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f T\n"	*(char)
,	O
x	O
[	O
1	int
]	O
,	O
y	O
[	O
1	int
]	O
,	O
x	O
[	O
2	int
]	O
,	O
y	O
[	O
2	int
]	O
,	O
x	O
[	O
3	int
]	O
,	O
y	O
[	O
3	int
]	O
,	O
x	O
[	O
0	int
]	O
,	O
y	O
[	O
0	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%.1f %.1f A\n"	*(char)
,	O
x	O
[	O
3	int
]	O
,	O
y	O
[	O
3	int
]	O
+	O
3	int
)	O
;	O
}	O
ps_draw_threads	O
(	O
tree	O
->	O
link	O
[	O
i	O
]	O
,	O
radius	O
)	O
;	O
}	O
}	O
static	O
int	O
ps_determine_diam	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
int	O
w	O
,	O
h	O
;	O
int	O
diam	O
;	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
&&	O
!	O
(	O
tree	O
->	O
options	O
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
{	O
ps_measure_text	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
&	O
w	O
,	O
&	O
h	O
)	O
;	O
diam	O
=	O
max	O
(	O
w	O
,	O
h	O
)	O
;	O
}	O
else	O
diam	O
=	O
0	int
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
diam	O
=	O
max	O
(	O
diam	O
,	O
ps_determine_diam	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
diam	O
=	O
max	O
(	O
diam	O
,	O
ps_determine_diam	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
)	O
;	O
return	O
diam	O
;	O
}	O
static	O
void	O
ps_measure_text	O
(	O
const	O
char	O
*	O
text	O
,	O
int	O
*	O
w	O
,	O
int	O
*	O
h	O
)	O
{	O
int	O
ll	O
=	O
0	int
;	O
*	O
w	O
=	O
0	int
;	O
*	O
h	O
=	O
PS_CHAR_HEIGHT	O
;	O
for	O
(	O
;	O
;	O
text	O
++	O
)	O
switch	O
(	O
*	O
text	O
)	O
{	O
case	O
'\0'	O
:	O
*	O
w	O
=	O
(	O
*	O
w	O
/	O
10	int
)	O
*	O
(	O
PS_CHAR_HEIGHT	O
/	O
10	int
)	O
/	O
10	int
;	O
return	O
;	O
case	O
'&'	O
:	O
*	O
h	O
+=	O
PS_CHAR_HEIGHT	O
;	O
ll	O
=	O
0	int
;	O
break	O
;	O
default	O
:	O
{	O
int	O
ch	O
=	O
*	O
text	O
==	O
'_'	O
?	O
' '	O
:	O
(	O
unsigned	O
char	O
)	O
*	O
text	O
;	O
int	O
first	O
=	O
ll	O
==	O
0	int
;	O
int	O
last	O
=	O
ch	O
!=	O
'\''	O
&&	O
(	O
text	O
[	O
1	int
]	O
==	O
'&'	O
||	O
text	O
[	O
1	int
]	O
==	O
'\0'	O
)	O
;	O
struct	O
character	struct(int,int,int,int,int)
*	O
c	int
=	O
&	O
font	struct(*(struct),*(char),*(struct))
.	O
chars	*(struct)
[	O
font	struct(*(struct),*(char),*(struct))
.	O
map	*(char)
[	O
ch	O
]	O
]	O
;	O
if	O
(	O
first	O
&&	O
last	O
)	O
ll	O
+=	O
c	int
->	O
urx	int
-	O
c	int
->	O
llx	int
;	O
else	O
if	O
(	O
first	O
)	O
ll	O
+=	O
c	int
->	O
wx	int
-	O
c	int
->	O
llx	int
;	O
else	O
if	O
(	O
last	O
)	O
ll	O
+=	O
c	int
->	O
urx	int
;	O
else	O
ll	O
+=	O
c	int
->	O
wx	int
;	O
}	O
*	O
w	O
=	O
max	O
(	O
ll	O
,	O
*	O
w	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
ps_layout_tree	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
int	O
radius	O
)	O
{	O
switch	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
int	O
subtree_height	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
options	O
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
tree	O
->	O
w	O
=	O
tree	O
->	O
h	O
=	O
2	int
*	O
radius	O
;	O
else	O
{	O
ps_measure_text	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tree	O
->	O
w	O
,	O
&	O
tree	O
->	O
h	O
)	O
;	O
tree	O
->	O
w	O
+=	O
2	int
*	O
PS_MARGIN	O
;	O
tree	O
->	O
h	O
+=	O
2	int
*	O
PS_MARGIN	O
;	O
}	O
tree	O
->	O
ofs	O
=	O
0	int
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
ps_layout_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
radius	O
)	O
;	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
ofs	O
=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
;	O
subtree_height	O
=	O
radius	O
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
;	O
}	O
if	O
(	O
tree	O
->	O
thread	O
[	O
0	int
]	O
==	O
&	O
outside_thread	O
)	O
{	O
tree	O
->	O
w	O
+=	O
PS_THREAD_WIDTH	O
;	O
tree	O
->	O
ofs	O
+=	O
PS_THREAD_WIDTH	O
;	O
}	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
ps_layout_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
radius	O
)	O
;	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
;	O
subtree_height	O
=	O
max	O
(	O
subtree_height	O
,	O
radius	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
}	O
tree	O
->	O
h	O
+=	O
subtree_height	O
;	O
if	O
(	O
tree	O
->	O
thread	O
[	O
1	int
]	O
==	O
&	O
outside_thread	O
)	O
tree	O
->	O
w	O
+=	O
PS_THREAD_WIDTH	O
;	O
if	O
(	O
subtree_height	O
==	O
0	int
&&	O
(	O
tree	O
->	O
thread	O
[	O
0	int
]	O
!=	O
NULL	O
||	O
tree	O
->	O
thread	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
)	O
tree	O
->	O
h	O
+=	O
PS_THREAD_HEIGHT	O
;	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
tree	O
->	O
h	O
+=	O
radius	O
;	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
int	O
extra_space	O
;	O
ps_layout_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
radius	O
)	O
;	O
ps_layout_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
radius	O
)	O
;	O
pad_top_level_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
)	O
pad_top_level_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_ADJACENT	int
)	O
extra_space	O
=	O
2	int
*	O
PS_CHAR_WIDTH	O
;	O
else	O
extra_space	O
=	O
4	int
*	O
PS_CHAR_WIDTH	O
;	O
tree	O
->	O
w	O
=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
extra_space	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
;	O
tree	O
->	O
h	O
=	O
max	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
,	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
ps_draw_tree_justified	O
(	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
radius	O
)	O
{	O
struct	O
space	O
subspace	O
;	O
int	O
ofs	O
;	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
)	O
{	O
if	O
(	O
tree	O
->	O
justify	O
==	O
'm'	O
)	O
ofs	O
=	O
(	O
space	O
->	O
h	O
-	O
tree	O
->	O
h	O
)	O
/	O
2	int
;	O
else	O
if	O
(	O
tree	O
->	O
justify	O
==	O
'b'	O
)	O
ofs	O
=	O
(	O
space	O
->	O
h	O
-	O
tree	O
->	O
h	O
)	O
;	O
else	O
ofs	O
=	O
0	int
;	O
}	O
else	O
ofs	O
=	O
0	int
;	O
space_subdivide	O
(	O
&	O
subspace	O
,	O
space	O
,	O
x	O
,	O
ofs	O
,	O
x	O
+	O
tree	O
->	O
w	O
,	O
ofs	O
+	O
tree	O
->	O
h	O
)	O
;	O
ps_draw_tree	O
(	O
tree	O
,	O
&	O
subspace	O
,	O
radius	O
)	O
;	O
}	O
static	O
void	O
space_create	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
w	O
,	O
int	O
h	O
)	O
{	O
space	O
->	O
x0	O
=	O
space	O
->	O
y0	O
=	O
0	int
;	O
space	O
->	O
w	O
=	O
w	O
;	O
space	O
->	O
h	O
=	O
space	O
->	O
sh	O
=	O
h	O
;	O
}	O
static	O
void	O
space_subdivide	O
(	O
struct	O
space	O
*	O
dst	O
,	O
const	O
struct	O
space	O
*	O
src	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
)	O
{	O
assert	O
(	O
x0	O
>=	O
0	int
&&	O
x0	O
<	O
src	O
->	O
w	O
&&	O
x1	O
>=	O
x0	O
&&	O
x1	O
<=	O
src	O
->	O
w	O
)	O
;	O
assert	O
(	O
y0	O
>=	O
0	int
&&	O
y0	O
<	O
src	O
->	O
h	O
&&	O
y1	O
>=	O
y0	O
&&	O
y1	O
<=	O
src	O
->	O
h	O
)	O
;	O
dst	O
->	O
sh	O
=	O
src	O
->	O
sh	O
;	O
dst	O
->	O
x0	O
=	O
src	O
->	O
x0	O
+	O
x0	O
;	O
dst	O
->	O
w	O
=	O
x1	O
-	O
x0	O
;	O
dst	O
->	O
y0	O
=	O
src	O
->	O
y0	O
+	O
y0	O
;	O
dst	O
->	O
h	O
=	O
y1	O
-	O
y0	O
;	O
}	O
static	O
void	O
space_line	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
,	O
int	O
radius	O
,	O
int	O
s0	O
,	O
int	O
s1	O
)	O
{	O
double	O
ax0	O
,	O
ay0	O
;	O
double	O
ax1	O
,	O
ay1	O
;	O
space_distance_along	O
(	O
x0	O
,	O
y0	O
,	O
x1	O
,	O
y1	O
,	O
radius	O
,	O
-	O
1	int
,	O
&	O
ax0	O
,	O
&	O
ay0	O
,	O
s0	O
)	O
;	O
space_distance_along	O
(	O
x1	O
,	O
y1	O
,	O
x0	O
,	O
y0	O
,	O
radius	O
,	O
+	O
1	int
,	O
&	O
ax1	O
,	O
&	O
ay1	O
,	O
s1	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f %.1f L\n"	*(char)
,	O
space_xc	O
(	O
space	O
,	O
ax0	O
)	O
,	O
space_yc	O
(	O
space	O
,	O
ay0	O
)	O
,	O
space_xc	O
(	O
space	O
,	O
ax1	O
)	O
,	O
space_yc	O
(	O
space	O
,	O
ay1	O
)	O
)	O
;	O
}	O
static	O
void	O
space_circle	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
radius	O
,	O
int	O
shade	O
)	O
{	O
double	O
x0	O
=	O
space_xc	O
(	O
space	O
,	O
x	O
)	O
;	O
double	O
y0	O
=	O
space_yc	O
(	O
space	O
,	O
y	O
)	O
;	O
if	O
(	O
shade	O
!=	O
100	int
)	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f %d D\n"	*(char)
,	O
x0	O
,	O
y0	O
,	O
radius	O
/	O
1000.	int
,	O
shade	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f C\n"	*(char)
,	O
x0	O
,	O
y0	O
,	O
radius	O
/	O
1000.	int
)	O
;	O
}	O
static	O
void	O
space_square	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
px0	O
,	O
int	O
py0	O
,	O
int	O
px1	O
,	O
int	O
py1	O
,	O
int	O
shade	O
)	O
{	O
double	O
x0	O
=	O
space_xc	O
(	O
space	O
,	O
px0	O
)	O
;	O
double	O
y0	O
=	O
space_yc	O
(	O
space	O
,	O
py0	O
)	O
;	O
double	O
x1	O
=	O
space_xc	O
(	O
space	O
,	O
px1	O
)	O
;	O
double	O
y1	O
=	O
space_yc	O
(	O
space	O
,	O
py1	O
)	O
;	O
if	O
(	O
shade	O
!=	O
100	int
)	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f %.1f %d SS\n"	*(char)
,	O
x0	O
,	O
y0	O
,	O
x1	O
,	O
y1	O
,	O
shade	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%.1f %.1f %.1f %.1f SD\n"	*(char)
,	O
x0	O
,	O
y0	O
,	O
x1	O
,	O
y1	O
)	O
;	O
}	O
static	O
void	O
space_text	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
const	O
char	O
*	O
text	O
,	O
enum	O
justification	O
j	O
,	O
int	O
adjust_height	O
,	O
int	O
shade	O
)	O
{	O
enum	O
justification	O
h	O
=	O
j	O
&	O
JT_HORZ	O
;	O
enum	O
justification	O
v	O
=	O
j	O
&	O
JT_VERT	O
;	O
int	O
tw	O
,	O
th	O
;	O
ps_measure_text	O
(	O
text	O
,	O
&	O
tw	O
,	O
&	O
th	O
)	O
;	O
{	O
struct	O
character	struct(int,int,int,int,int)
*	O
c	int
=	O
&	O
font	struct(*(struct),*(char),*(struct))
.	O
chars	*(struct)
[	O
font	struct(*(struct),*(char),*(struct))
.	O
map	*(char)
[	O
(	O
unsigned	O
char	O
)	O
*	O
text	O
]	O
]	O
;	O
if	O
(	O
v	O
==	O
JT_MIDDLE	O
)	O
{	O
if	O
(	O
adjust_height	O
&&	O
strlen	(*(char))->(long)
(	O
text	O
)	O
==	O
1	int
)	O
y	O
+=	O
(	O
(	O
c	int
->	O
ury	int
-	O
c	int
->	O
lly	int
)	O
/	O
2	int
+	O
c	int
->	O
lly	int
)	O
*	O
PS_CHAR_HEIGHT	O
/	O
1000	int
;	O
else	O
y	O
+=	O
PS_CHAR_HEIGHT	O
*	O
3	int
/	O
4	int
-	O
th	O
/	O
2	int
;	O
}	O
else	O
y	O
+=	O
PS_CHAR_HEIGHT	O
*	O
3	int
/	O
8	int
;	O
x	O
-=	O
c	int
->	O
llx	int
;	O
}	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
text	O
,	O
"**"	*(char)
)	O
)	O
{	O
space_special	O
(	O
space	O
,	O
x	O
,	O
y	O
,	O
tw	O
+	O
PS_CHAR_WIDTH	O
,	O
th	O
-	O
PS_CHAR_HEIGHT	O
/	O
2	int
,	O
"**"	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
*	O
text	O
!=	O
'\0'	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%.1f %.1f ("	*(char)
,	O
space_xc	O
(	O
space	O
,	O
x	O
)	O
,	O
space_yc	O
(	O
space	O
,	O
y	O
)	O
)	O
;	O
for	O
(	O
;	O
*	O
text	O
&&	O
*	O
text	O
!=	O
'&'	O
;	O
text	O
++	O
)	O
if	O
(	O
*	O
text	O
==	O
'_'	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
else	O
putchar	(int)->(int)
(	O
*	O
text	O
)	O
;	O
printf	(*(char))->(int)
(	O
") %d T%c\n"	*(char)
,	O
shade	O
,	O
h	O
==	O
JT_CENTER	O
?	O
'C'	O
:	O
h	O
==	O
JT_LEFT	O
?	O
'L'	O
:	O
'R'	O
)	O
;	O
if	O
(	O
*	O
text	O
==	O
'&'	O
)	O
{	O
text	O
++	O
;	O
y	O
+=	O
PS_CHAR_HEIGHT	O
;	O
}	O
}	O
}	O
static	O
void	O
space_special	O
(	O
struct	O
space	O
*	O
space	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
w	O
,	O
int	O
h	O
,	O
const	O
char	O
*	O
c	int
)	O
{	O
x	O
+=	O
w	O
/	O
2	int
;	O
y	O
+=	O
(	O
h	O
-	O
PS_CHAR_HEIGHT	O
)	O
/	O
2	int
+	O
(	O
PS_CHAR_HEIGHT	O
*	O
3	int
/	O
4	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%.0f %.0f (%s) S\n"	*(char)
,	O
space_xc	O
(	O
space	O
,	O
x	O
)	O
,	O
space_yc	O
(	O
space	O
,	O
y	O
)	O
,	O
c	int
)	O
;	O
}	O
static	O
double	O
space_xc	O
(	O
const	O
struct	O
space	O
*	O
space	O
,	O
double	O
x	O
)	O
{	O
return	O
(	O
x	O
+	O
space	O
->	O
x0	O
)	O
/	O
1000.	int
;	O
}	O
static	O
double	O
space_yc	O
(	O
const	O
struct	O
space	O
*	O
space	O
,	O
double	O
y	O
)	O
{	O
return	O
(	O
space	O
->	O
sh	O
-	O
(	O
y	O
+	O
space	O
->	O
y0	O
)	O
)	O
/	O
1000.	int
;	O
}	O
static	O
void	O
space_distance_along	O
(	O
double	O
x0	O
,	O
double	O
y0	O
,	O
double	O
x1	O
,	O
double	O
y1	O
,	O
double	O
radius	O
,	O
int	O
dir	O
,	O
double	O
*	O
x	O
,	O
double	O
*	O
y	O
,	O
int	O
shape	O
)	O
{	O
if	O
(	O
shape	O
==	O
'c'	O
)	O
{	O
if	O
(	O
x1	O
!=	O
x0	O
)	O
{	O
double	O
m	O
=	O
(	O
y1	O
-	O
y0	O
)	O
/	O
(	O
x1	O
-	O
x0	O
)	O
;	O
double	O
dx	O
=	O
radius	O
/	O
sqrt	(double)->(double)
(	O
m	O
*	O
m	O
+	O
1	int
)	O
;	O
double	O
dy	O
=	O
m	O
*	O
dx	O
;	O
*	O
x	O
=	O
x0	O
+	O
dx	O
*	O
dir	O
;	O
*	O
y	O
=	O
y0	O
+	O
dy	O
*	O
dir	O
;	O
}	O
else	O
{	O
*	O
x	O
=	O
x0	O
;	O
*	O
y	O
=	O
y0	O
;	O
}	O
}	O
else	O
{	O
*	O
x	O
=	O
x0	O
;	O
*	O
y	O
=	O
y0	O
-	O
radius	O
;	O
}	O
}	O
static	O
void	O
text_measure_tree	O
(	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
switch	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TREE_BINARY	int
:	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
text_measure_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
text_measure_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
text_caret	O
(	O
tree	O
)	O
)	O
{	O
tree	O
->	O
w	O
=	O
3	int
;	O
tree	O
->	O
h	O
=	O
3	int
;	O
tree	O
->	O
ofs	O
=	O
1	int
;	O
}	O
else	O
{	O
int	O
subtree_height	O
=	O
0	int
;	O
text_measure_text	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tree	O
->	O
w	O
,	O
&	O
tree	O
->	O
h	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
assert	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
>=	O
0	int
&&	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
<	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
==	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
-	O
1	int
)	O
tree	O
->	O
link	O
[	O
0	int
]	O
=	O
text_shift_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
-	O
1	int
)	O
;	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
ofs	O
=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
;	O
subtree_height	O
=	O
max	O
(	O
subtree_height	O
,	O
1	int
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
)	O
;	O
}	O
else	O
tree	O
->	O
ofs	O
=	O
0	int
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
assert	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
ofs	O
>=	O
0	int
&&	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
ofs	O
<	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
ofs	O
==	O
0	int
)	O
tree	O
->	O
link	O
[	O
1	int
]	O
=	O
text_shift_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
+	O
1	int
)	O
;	O
tree	O
->	O
w	O
+=	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
;	O
subtree_height	O
=	O
max	O
(	O
subtree_height	O
,	O
1	int
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
}	O
tree	O
->	O
h	O
+=	O
subtree_height	O
;	O
}	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
tree	O
->	O
h	O
++	O
;	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
text_measure_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
;	O
text_measure_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
;	O
tree	O
->	O
w	O
=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
4	int
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
;	O
tree	O
->	O
h	O
=	O
max	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
,	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
char	O
text_first_char	O
(	O
const	O
char	O
*	O
s	O
)	O
{	O
while	O
(	O
*	O
s	O
==	O
'&'	O
||	O
*	O
s	O
==	O
'_'	O
)	O
s	O
++	O
;	O
return	O
*	O
s	O
;	O
}	O
static	O
void	O
text_draw_tree	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
canvas	O
*	O
canvas	O
)	O
{	O
switch	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
struct	O
canvas	O
c	int
;	O
int	O
x	O
,	O
tx	O
,	O
ty	O
;	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
canvas_subdivide	O
(	O
&	O
c	int
,	O
canvas	O
,	O
0	int
,	O
1	int
,	O
canvas	O
->	O
w	O
,	O
canvas	O
->	O
h	O
)	O
;	O
else	O
c	int
=	O
*	O
canvas	O
;	O
x	O
=	O
0	int
;	O
if	O
(	O
text_caret	O
(	O
tree	O
)	O
)	O
{	O
canvas_set	O
(	O
&	O
c	int
,	O
1	int
,	O
0	int
,	O
text_first_char	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
canvas_set	O
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
'^'	O
)	O
;	O
canvas_set	O
(	O
&	O
c	int
,	O
0	int
,	O
2	int
,	O
text_first_char	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
canvas_set	O
(	O
&	O
c	int
,	O
2	int
,	O
2	int
,	O
text_first_char	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
canvas_set	O
(	O
canvas	O
,	O
1	int
,	O
0	int
,	O
'|'	O
)	O
;	O
return	O
;	O
}	O
text_measure_text	O
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tx	O
,	O
&	O
ty	O
)	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
canvas	O
subcanvas	O
;	O
canvas_subdivide	O
(	O
&	O
subcanvas	O
,	O
&	O
c	int
,	O
x	O
,	O
ty	O
+	O
1	int
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
,	O
ty	O
+	O
1	int
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
h	O
)	O
;	O
text_draw_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
&	O
subcanvas	O
)	O
;	O
x	O
+=	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
options	O
&	O
TOPT_NO_LINE	int
)	O
)	O
text_draw_line	O
(	O
&	O
c	int
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
+	O
1	int
,	O
x	O
,	O
ty	O
)	O
;	O
}	O
if	O
(	O
tree	O
->	O
options	O
&	O
TOPT_LEADER	int
)	O
canvas_set	O
(	O
canvas	O
,	O
x	O
+	O
tx	O
/	O
2	int
,	O
0	int
,	O
'|'	O
)	O
;	O
text_draw_text	O
(	O
&	O
c	int
,	O
x	O
,	O
0	int
,	O
tx	O
,	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
;	O
x	O
+=	O
tx	O
;	O
if	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
canvas	O
subcanvas	O
;	O
canvas_subdivide	O
(	O
&	O
subcanvas	O
,	O
&	O
c	int
,	O
x	O
,	O
ty	O
+	O
1	int
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
w	O
,	O
ty	O
+	O
1	int
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
h	O
)	O
;	O
text_draw_tree	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
&	O
subcanvas	O
)	O
;	O
if	O
(	O
!	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
options	O
&	O
TOPT_NO_LINE	int
)	O
)	O
text_draw_line	O
(	O
&	O
c	int
,	O
x	O
+	O
tree	O
->	O
link	O
[	O
1	int
]	O
->	O
ofs	O
-	O
1	int
,	O
x	O
-	O
1	int
,	O
ty	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
text_draw_tree_justified	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
canvas	O
,	O
0	int
)	O
;	O
if	O
(	O
tree	O
->	O
prod_type	O
==	O
TOKEN_PRODUCES	int
)	O
{	O
canvas_set	O
(	O
canvas	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
1	int
,	O
tree	O
->	O
h	O
/	O
2	int
,	O
'='	O
)	O
;	O
canvas_set	O
(	O
canvas	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
2	int
,	O
tree	O
->	O
h	O
/	O
2	int
,	O
'>'	O
)	O
;	O
}	O
text_draw_tree_justified	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
,	O
canvas	O
,	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
+	O
4	int
)	O
;	O
}	O
break	O
;	O
case	O
TREE_SHIFT	int
:	O
{	O
struct	O
canvas	O
subcanvas	O
;	O
int	O
shift	O
;	O
shift	O
=	O
tree	O
->	O
ofs	O
-	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
ofs	O
;	O
canvas_subdivide	O
(	O
&	O
subcanvas	O
,	O
canvas	O
,	O
shift	O
,	O
0	int
,	O
shift	O
+	O
tree	O
->	O
link	O
[	O
0	int
]	O
->	O
w	O
,	O
tree	O
->	O
h	O
)	O
;	O
text_draw_tree	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
,	O
&	O
subcanvas	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
text_measure_text	O
(	O
const	O
char	O
*	O
text	O
,	O
int	O
*	O
w	O
,	O
int	O
*	O
h	O
)	O
{	O
int	O
ll	O
=	O
0	int
;	O
*	O
w	O
=	O
0	int
;	O
*	O
h	O
=	O
1	int
;	O
while	O
(	O
*	O
text	O
==	O
'&'	O
||	O
*	O
text	O
==	O
'_'	O
)	O
text	O
++	O
;	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
*	O
text	O
++	O
)	O
{	O
case	O
'\0'	O
:	O
return	O
;	O
case	O
'&'	O
:	O
(	O
*	O
h	O
)	O
++	O
;	O
ll	O
=	O
0	int
;	O
break	O
;	O
case	O
'_'	O
:	O
break	O
;	O
default	O
:	O
*	O
w	O
=	O
max	O
(	O
++	O
ll	O
,	O
*	O
w	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
struct	O
tree	O
*	O
text_shift_tree	O
(	O
struct	O
tree	O
*	O
old	O
,	O
int	O
move	O
)	O
{	O
struct	O
tree	O
*	O
new	O
=	O
xmalloc	O
(	O
sizeof	O
*	O
new	O
)	O
;	O
new	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
TREE_SHIFT	int
;	O
new	O
->	O
w	O
=	O
old	O
->	O
w	O
+	O
abs	(int)->(int)
(	O
move	O
)	O
;	O
new	O
->	O
h	O
=	O
old	O
->	O
h	O
;	O
new	O
->	O
ofs	O
=	O
old	O
->	O
ofs	O
+	O
(	O
move	O
>	O
0	int
?	O
move	O
:	O
0	int
)	O
;	O
new	O
->	O
options	O
=	O
old	O
->	O
options	O
;	O
new	O
->	O
name	O
=	O
NULL	O
;	O
assert	O
(	O
new	O
->	O
ofs	O
>=	O
0	int
&&	O
new	O
->	O
ofs	O
<	O
new	O
->	O
w	O
)	O
;	O
new	O
->	O
link	O
[	O
0	int
]	O
=	O
old	O
;	O
new	O
->	O
link	O
[	O
1	int
]	O
=	O
NULL	O
;	O
return	O
new	O
;	O
}	O
static	O
int	O
text_trivial	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
return	O
(	O
tree	O
->	O
w	O
==	O
1	int
&&	O
tree	O
->	O
link	O
[	O
0	int
]	O
==	O
NULL	O
&&	O
tree	O
->	O
link	O
[	O
1	int
]	O
==	O
NULL	O
)	O
;	O
}	O
static	O
int	O
text_caret	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
)	O
{	O
return	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
&&	O
strlen	(*(char))->(long)
(	O
tree	O
->	O
label	O
[	O
LP_MIDDLE	int
]	O
)	O
==	O
1	int
&&	O
tree	O
->	O
link	O
[	O
0	int
]	O
!=	O
NULL	O
&&	O
text_trivial	O
(	O
tree	O
->	O
link	O
[	O
0	int
]	O
)	O
&&	O
tree	O
->	O
link	O
[	O
1	int
]	O
!=	O
NULL	O
&&	O
text_trivial	O
(	O
tree	O
->	O
link	O
[	O
1	int
]	O
)	O
)	O
;	O
}	O
static	O
void	O
text_draw_line	O
(	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x0	O
,	O
int	O
x1	O
,	O
int	O
y	O
)	O
{	O
if	O
(	O
x1	O
==	O
x0	O
+	O
1	int
)	O
canvas_set	O
(	O
canvas	O
,	O
x0	O
,	O
y	O
,	O
'/'	O
)	O
;	O
else	O
if	O
(	O
x1	O
==	O
x0	O
-	O
1	int
)	O
canvas_set	O
(	O
canvas	O
,	O
x0	O
,	O
y	O
,	O
'\\'	O
)	O
;	O
else	O
if	O
(	O
x1	O
>	O
x0	O
)	O
{	O
int	O
x	O
;	O
for	O
(	O
x	O
=	O
x0	O
;	O
x	O
<	O
x1	O
;	O
x	O
++	O
)	O
{	O
static	O
const	O
char	O
lines	O
[	O
]	O
=	O
"_.-'"	*(char)
;	O
size_t	long
frac	O
=	O
(	O
(	O
double	O
)	O
x	O
-	O
x0	O
)	O
/	O
(	O
x1	O
-	O
x0	O
-	O
1	int
)	O
*	O
3	int
;	O
assert	O
(	O
frac	O
<	O
sizeof	O
lines	O
)	O
;	O
canvas_set	O
(	O
canvas	O
,	O
x	O
,	O
y	O
,	O
lines	O
[	O
frac	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
x	O
;	O
for	O
(	O
x	O
=	O
x0	O
;	O
x	O
>	O
x1	O
;	O
x	O
--	O
)	O
{	O
static	O
const	O
char	O
lines	O
[	O
]	O
=	O
"_.-`"	*(char)
;	O
size_t	long
frac	O
=	O
(	O
(	O
double	O
)	O
x0	O
-	O
x	O
)	O
/	O
(	O
x0	O
-	O
x1	O
-	O
1	int
)	O
*	O
3	int
;	O
assert	O
(	O
frac	O
<	O
sizeof	O
lines	O
)	O
;	O
canvas_set	O
(	O
canvas	O
,	O
x	O
,	O
y	O
,	O
lines	O
[	O
frac	O
]	O
)	O
;	O
}	O
}	O
}	O
static	O
size_t	long
text_line_len	O
(	O
const	O
char	O
*	O
text	O
)	O
{	O
size_t	long
len	O
=	O
0	int
;	O
for	O
(	O
;	O
*	O
text	O
!=	O
'\0'	O
&&	O
*	O
text	O
!=	O
'&'	O
;	O
text	O
++	O
)	O
if	O
(	O
*	O
text	O
!=	O
'_'	O
)	O
len	O
++	O
;	O
return	O
len	O
;	O
}	O
static	O
void	O
text_draw_text	O
(	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
w	O
,	O
const	O
char	O
*	O
text	O
)	O
{	O
int	O
y	O
=	O
y0	O
;	O
while	O
(	O
*	O
text	O
==	O
'&'	O
||	O
*	O
text	O
==	O
'_'	O
)	O
text	O
++	O
;	O
while	O
(	O
*	O
text	O
!=	O
'\0'	O
)	O
{	O
int	O
line_len	O
=	O
text_line_len	O
(	O
text	O
)	O
;	O
int	O
x	O
=	O
x0	O
+	O
w	O
/	O
2	int
-	O
line_len	O
/	O
2	int
;	O
for	O
(	O
;	O
*	O
text	O
!=	O
'\0'	O
&&	O
*	O
text	O
!=	O
'&'	O
;	O
text	O
++	O
)	O
if	O
(	O
*	O
text	O
!=	O
'_'	O
)	O
canvas_set	O
(	O
canvas	O
,	O
x	O
++	O
,	O
y	O
,	O
*	O
text	O
)	O
;	O
if	O
(	O
*	O
text	O
==	O
'&'	O
||	O
*	O
text	O
==	O
'_'	O
)	O
{	O
y	O
++	O
;	O
while	O
(	O
*	O
text	O
==	O
'&'	O
||	O
*	O
text	O
==	O
'_'	O
)	O
text	O
++	O
;	O
}	O
}	O
}	O
static	O
void	O
text_draw_tree_justified	O
(	O
const	O
struct	O
tree	O
*	O
tree	O
,	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
)	O
{	O
struct	O
canvas	O
subcanvas	O
;	O
int	O
ofs	O
;	O
if	O
(	O
tree	O
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
TREE_BINARY	int
)	O
{	O
if	O
(	O
tree	O
->	O
justify	O
==	O
'm'	O
)	O
ofs	O
=	O
(	O
canvas	O
->	O
h	O
-	O
tree	O
->	O
h	O
)	O
/	O
2	int
;	O
else	O
if	O
(	O
tree	O
->	O
justify	O
==	O
'b'	O
)	O
ofs	O
=	O
canvas	O
->	O
h	O
-	O
tree	O
->	O
h	O
;	O
else	O
ofs	O
=	O
0	int
;	O
}	O
else	O
ofs	O
=	O
0	int
;	O
canvas_subdivide	O
(	O
&	O
subcanvas	O
,	O
canvas	O
,	O
x	O
,	O
ofs	O
,	O
x	O
+	O
tree	O
->	O
w	O
,	O
ofs	O
+	O
tree	O
->	O
h	O
)	O
;	O
text_draw_tree	O
(	O
tree	O
,	O
&	O
subcanvas	O
)	O
;	O
}	O
static	O
void	O
canvas_create	O
(	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
w	O
,	O
int	O
h	O
)	O
{	O
canvas	O
->	O
w	O
=	O
canvas	O
->	O
ll	O
=	O
w	O
;	O
canvas	O
->	O
h	O
=	O
h	O
;	O
canvas	O
->	O
buf	O
=	O
xmalloc	O
(	O
w	O
*	O
h	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
canvas	O
->	O
buf	O
,	O
' '	O
,	O
w	O
*	O
h	O
)	O
;	O
}	O
static	O
void	O
canvas_subdivide	O
(	O
struct	O
canvas	O
*	O
dst	O
,	O
const	O
struct	O
canvas	O
*	O
src	O
,	O
int	O
x0	O
,	O
int	O
y0	O
,	O
int	O
x1	O
,	O
int	O
y1	O
)	O
{	O
assert	O
(	O
dst	O
!=	O
NULL	O
&&	O
src	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x0	O
>=	O
0	int
&&	O
x0	O
<	O
src	O
->	O
w	O
&&	O
x1	O
>=	O
0	int
&&	O
x1	O
<=	O
src	O
->	O
w	O
&&	O
x0	O
<=	O
x1	O
)	O
;	O
assert	O
(	O
y0	O
>=	O
0	int
&&	O
y0	O
<	O
src	O
->	O
h	O
&&	O
y1	O
>=	O
0	int
&&	O
y1	O
<=	O
src	O
->	O
h	O
&&	O
y0	O
<=	O
y1	O
)	O
;	O
dst	O
->	O
w	O
=	O
x1	O
-	O
x0	O
;	O
dst	O
->	O
ll	O
=	O
src	O
->	O
ll	O
;	O
dst	O
->	O
h	O
=	O
y1	O
-	O
y0	O
;	O
dst	O
->	O
buf	O
=	O
src	O
->	O
buf	O
+	O
x0	O
+	O
y0	O
*	O
src	O
->	O
ll	O
;	O
}	O
static	O
void	O
canvas_free	O
(	O
struct	O
canvas	O
*	O
canvas	O
)	O
{	O
free	(*(void))->(void)
(	O
canvas	O
->	O
buf	O
)	O
;	O
}	O
static	O
void	O
canvas_set	O
(	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
,	O
int	O
y	O
,	O
int	O
c	int
)	O
{	O
assert	O
(	O
canvas	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x	O
>=	O
0	int
&&	O
x	O
<	O
canvas	O
->	O
w	O
)	O
;	O
assert	O
(	O
y	O
>=	O
0	int
&&	O
y	O
<	O
canvas	O
->	O
h	O
)	O
;	O
assert	O
(	O
c	int
>=	O
0	int
&&	O
c	int
<=	O
UCHAR_MAX	O
)	O
;	O
assert	O
(	O
canvas	O
->	O
buf	O
[	O
x	O
+	O
y	O
*	O
canvas	O
->	O
ll	O
]	O
==	O
' '	O
)	O
;	O
canvas	O
->	O
buf	O
[	O
x	O
+	O
y	O
*	O
canvas	O
->	O
ll	O
]	O
=	O
c	int
;	O
}	O
static	O
int	O
canvas_get	O
(	O
const	O
struct	O
canvas	O
*	O
canvas	O
,	O
int	O
x	O
,	O
int	O
y	O
)	O
{	O
assert	O
(	O
canvas	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x	O
>=	O
0	int
&&	O
x	O
<	O
canvas	O
->	O
w	O
)	O
;	O
assert	O
(	O
y	O
>=	O
0	int
&&	O
y	O
<	O
canvas	O
->	O
h	O
)	O
;	O
return	O
canvas	O
->	O
buf	O
[	O
x	O
+	O
y	O
*	O
canvas	O
->	O
ll	O
]	O
;	O
}	O
static	O
void	O
canvas_print	O
(	O
const	O
struct	O
canvas	O
*	O
canvas	O
)	O
{	O
int	O
y	O
;	O
for	O
(	O
y	O
=	O
0	int
;	O
y	O
<	O
canvas	O
->	O
h	O
;	O
y	O
++	O
)	O
{	O
int	O
x	O
,	O
w	O
;	O
w	O
=	O
canvas	O
->	O
w	O
;	O
while	O
(	O
w	O
>	O
0	int
&&	O
canvas_get	O
(	O
canvas	O
,	O
w	O
-	O
1	int
,	O
y	O
)	O
==	O
' '	O
)	O
w	O
--	O
;	O
for	O
(	O
x	O
=	O
0	int
;	O
x	O
<	O
w	O
;	O
x	O
++	O
)	O
putchar	(int)->(int)
(	O
canvas_get	O
(	O
canvas	O
,	O
x	O
,	O
y	O
)	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
static	O
void	O
error	O
(	O
struct	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
*	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
,	O
const	O
char	O
*	O
format	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	O
;	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
==	O
NULL	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"error: "	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
==	O
EOF	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"error at end-of-file: "	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"line %d: error at `%c': "	*(char)
,	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
ln	int
,	O
token	struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int)
->	O
c	int
)	O
;	O
va_start	O
(	O
args	O
,	O
format	O
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	O
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	O
(	O
size_t	long
amt	int
)	O
{	O
void	O
*	O
p	O
;	O
if	O
(	O
amt	int
==	O
0	int
)	O
return	O
NULL	O
;	O
p	O
=	O
malloc	(long)->(*(void))
(	O
amt	int
)	O
;	O
if	O
(	O
p	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"virtual memory exhausted\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
return	O
p	O
;	O
}	O
static	O
void	O
*	O
xrealloc	O
(	O
void	O
*	O
ptr	O
,	O
size_t	long
size	O
)	O
{	O
void	O
*	O
vp	O
;	O
if	O
(	O
!	O
size	O
)	O
{	O
if	O
(	O
ptr	O
)	O
free	(*(void))->(void)
(	O
ptr	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	O
)	O
vp	O
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	O
,	O
size	O
)	O
;	O
else	O
vp	O
=	O
malloc	(long)->(*(void))
(	O
size	O
)	O
;	O
if	O
(	O
!	O
vp	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"virtual memory exhausted\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
return	O
vp	O
;	O
}	O
static	O
int	O
max	O
(	O
int	O
a	O
,	O
int	O
b	O
)	O
{	O
return	O
a	O
>	O
b	O
?	O
a	O
:	O
b	O
;	O
}	O
