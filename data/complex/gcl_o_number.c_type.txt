long	O
fixint	(int)->(long)
(	O
object	O
x	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
)	O
FEwrong_type_argument	()->(int)
(	O
sLfixnum	O
,	O
x	int
)	O
;	O
return	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
}	O
int	O
fixnnint	(int)->(int)
(	O
object	O
x	int
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
!=	O
t_fixnum	O
||	O
fix	()->(int)
(	O
x	int
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"~S is not a non-negative fixnum."	*(char)
,	O
1	int
,	O
x	int
)	O
;	O
return	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
}	O
struct	O
{	O
int	O
min	int
,	O
max	int
;	O
}	O
bigger_fixnums	struct(int,int)
;	O
struct	O
fixnum_struct	O
*	O
bigger_fixnum_table	*(struct)
;	O
DEFUN_NEW	()->(int)
(	O
"ALLOCATE-BIGGER-FIXNUM-RANGE"	*(char)
,	O
object	O
,	O
fSallocate_bigger_fixnum_range	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OI	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
min	int
,	O
fixnum	O
max	int
)	O
,	O
""	*(char)
)	O
{	O
int	O
j	int
;	O
if	O
(	O
min	int
>	O
max	int
)	O
FEerror	()->(int)
(	O
"Need Min <= Max"	*(char)
,	O
0	int
)	O
;	O
bigger_fixnum_table	*(struct)
=	O
(	O
void	O
*	O
)	O
malloc	O
(	O
sizeof	O
(	O
struct	O
fixnum_struct	O
)	O
*	O
(	O
max	int
-	O
min	int
)	O
)	O
;	O
for	O
(	O
j	int
=	O
min	int
;	O
j	int
<	O
max	int
;	O
j	int
=	O
j	int
+	O
1	int
)	O
{	O
object	O
x	int
=	O
(	O
object	O
)	O
(	O
bigger_fixnum_table	*(struct)
+	O
j	int
-	O
min	int
)	O
;	O
x	int
->	O
fw	O
=	O
0	int
;	O
set_type_of	()->(int)
(	O
x	int
,	O
t_fixnum	O
)	O
;	O
x	int
->	O
FIX	O
.	O
FIXVAL	O
=	O
j	int
;	O
}	O
bigger_fixnums	struct(int,int)
.	O
min	int
=	O
min	int
;	O
bigger_fixnums	struct(int,int)
.	O
max	int
=	O
max	int
;	O
return	O
Ct	O
;	O
}	O
object	O
make_fixnum1	(long)->(int)
(	O
long	O
i	long
)	O
{	O
object	O
x	int
;	O
if	O
(	O
bigger_fixnum_table	*(struct)
)	O
{	O
if	O
(	O
i	long
>=	O
bigger_fixnums	struct(int,int)
.	O
min	int
&&	O
i	long
<	O
bigger_fixnums	struct(int,int)
.	O
max	int
)	O
return	O
(	O
object	O
)	O
(	O
bigger_fixnum_table	*(struct)
+	O
(	O
i	long
-	O
bigger_fixnums	struct(int,int)
.	O
min	int
)	O
)	O
;	O
}	O
x	int
=	O
alloc_object	()->(int)
(	O
t_fixnum	O
)	O
;	O
set_fix	()->(int)
(	O
x	int
,	O
i	long
)	O
;	O
return	O
(	O
x	int
)	O
;	O
}	O
object	O
make_ratio	(int,int)->(int)
(	O
object	O
num	int
,	O
object	O
den	int
)	O
{	O
object	O
g	O
,	O
r	int
,	O
get_gcd	()->(int)
(	O
object	O
x	int
,	O
object	O
y	O
)	O
;	O
vs_mark	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
den	int
)	O
)	O
FEerror	()->(int)
(	O
"Zero denominator."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
num	int
)	O
)	O
return	O
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
den	int
)	O
==	O
t_fixnum	O
&&	O
fix	()->(int)
(	O
den	int
)	O
==	O
1	int
)	O
return	O
(	O
num	int
)	O
;	O
if	O
(	O
number_minusp	()->(int)
(	O
den	int
)	O
)	O
{	O
num	int
=	O
number_negate	()->(int)
(	O
num	int
)	O
;	O
vs_push	()->(int)
(	O
num	int
)	O
;	O
den	int
=	O
number_negate	()->(int)
(	O
den	int
)	O
;	O
vs_push	()->(int)
(	O
den	int
)	O
;	O
}	O
g	O
=	O
get_gcd	()->(int)
(	O
num	int
,	O
den	int
)	O
;	O
vs_push	()->(int)
(	O
g	O
)	O
;	O
num	int
=	O
integer_divide1	()->(int)
(	O
num	int
,	O
g	O
,	O
0	int
)	O
;	O
vs_push	()->(int)
(	O
num	int
)	O
;	O
den	int
=	O
integer_divide1	()->(int)
(	O
den	int
,	O
g	O
,	O
0	int
)	O
;	O
vs_push	()->(int)
(	O
den	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
den	int
)	O
==	O
t_fixnum	O
&&	O
fix	()->(int)
(	O
den	int
)	O
==	O
1	int
)	O
{	O
vs_reset	O
;	O
return	O
(	O
num	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
den	int
)	O
==	O
t_fixnum	O
&&	O
fix	()->(int)
(	O
den	int
)	O
==	O
-	O
1	int
)	O
{	O
num	int
=	O
number_negate	()->(int)
(	O
num	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
num	int
)	O
;	O
}	O
r	int
=	O
alloc_object	()->(int)
(	O
t_ratio	O
)	O
;	O
r	int
->	O
rat	O
.	O
rat_num	O
=	O
num	int
;	O
r	int
->	O
rat	O
.	O
rat_den	O
=	O
den	int
;	O
vs_reset	O
;	O
return	O
(	O
r	int
)	O
;	O
}	O
object	O
make_shortfloat	(double)->(int)
(	O
double	O
f	double
)	O
{	O
object	O
x	int
;	O
if	O
(	O
f	double
==	O
(	O
shortfloat	O
)	O
0.0	int
)	O
return	O
(	O
shortfloat_zero	O
)	O
;	O
x	int
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
x	int
)	O
=	O
(	O
shortfloat	O
)	O
f	double
;	O
return	O
(	O
x	int
)	O
;	O
}	O
object	O
make_longfloat	(int)->(int)
(	O
longfloat	O
f	double
)	O
{	O
object	O
x	int
;	O
if	O
(	O
f	double
==	O
(	O
longfloat	O
)	O
0.0	int
)	O
return	O
(	O
longfloat_zero	O
)	O
;	O
x	int
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
x	int
)	O
=	O
f	double
;	O
return	O
(	O
x	int
)	O
;	O
}	O
object	O
make_complex	(int,int)->(int)
(	O
object	O
r	int
,	O
object	O
i	long
)	O
{	O
object	O
c	O
;	O
vs_mark	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
r	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
i	long
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	()->(int)
(	O
i	long
)	O
==	O
0	int
)	O
return	O
(	O
r	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
r	int
=	O
make_shortfloat	(double)->(int)
(	O
(	O
shortfloat	O
)	O
number_to_double	()->(int)
(	O
r	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
r	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
r	int
=	O
make_longfloat	(int)->(int)
(	O
number_to_double	()->(int)
(	O
r	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
r	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
t_shortfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
i	long
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
i	long
=	O
make_shortfloat	(double)->(int)
(	O
(	O
shortfloat	O
)	O
number_to_double	()->(int)
(	O
i	long
)	O
)	O
;	O
vs_push	()->(int)
(	O
i	long
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
r	int
=	O
make_longfloat	(int)->(int)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
r	int
)	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
r	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
t_longfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
i	long
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
case	O
t_shortfloat	O
:	O
i	long
=	O
make_longfloat	(int)->(int)
(	O
number_to_double	()->(int)
(	O
i	long
)	O
)	O
;	O
vs_push	()->(int)
(	O
i	long
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
c	O
=	O
alloc_object	()->(int)
(	O
t_complex	O
)	O
;	O
c	O
->	O
cmp	O
.	O
cmp_real	O
=	O
r	int
;	O
c	O
->	O
cmp	O
.	O
cmp_imag	O
=	O
i	long
;	O
vs_reset	O
;	O
return	O
(	O
c	O
)	O
;	O
}	O
double	O
number_to_double	()->(int)
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
(	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
case	O
t_bignum	O
:	O
return	O
(	O
big_to_double	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
{	O
double	O
dx	double
,	O
dy	double
;	O
object	O
xx	O
,	O
yy	O
;	O
for	O
(	O
xx	O
=	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
yy	O
=	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
dx	double
=	O
number_to_double	()->(int)
(	O
xx	O
)	O
,	O
dy	double
=	O
number_to_double	()->(int)
(	O
yy	O
)	O
;	O
dx	double
&&	O
dy	double
&&	O
(	O
!	O
ISNORMAL	O
(	O
dx	double
)	O
||	O
!	O
ISNORMAL	O
(	O
dy	double
)	O
)	O
;	O
)	O
{	O
if	O
(	O
ISNORMAL	O
(	O
dx	double
)	O
)	O
dx	double
*=	O
0.5	int
;	O
else	O
{	O
xx	O
=	O
integer_divide1	()->(int)
(	O
xx	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
,	O
0	int
)	O
;	O
dx	double
=	O
number_to_double	()->(int)
(	O
xx	O
)	O
;	O
}	O
if	O
(	O
ISNORMAL	O
(	O
dy	double
)	O
)	O
dy	double
*=	O
0.5	int
;	O
else	O
{	O
yy	O
=	O
integer_divide1	()->(int)
(	O
yy	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
,	O
0	int
)	O
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
yy	O
)	O
;	O
}	O
}	O
return	O
dx	double
/	O
dy	double
;	O
}	O
case	O
t_shortfloat	O
:	O
return	O
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
case	O
t_longfloat	O
:	O
return	O
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
;	O
default	O
:	O
wrong_type_argument	()->(int)
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
return	O
(	O
0.0	int
)	O
;	O
}	O
}	O
void	O
gcl_init_number	()->(void)
(	O
void	O
)	O
{	O
FFN	()->(int)
(	O
fSallocate_bigger_fixnum_range	O
)	O
(	O
-	O
1024	int
,	O
1023	int
)	O
;	O
shortfloat_zero	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
shortfloat_zero	O
)	O
=	O
(	O
shortfloat	O
)	O
0.0	int
;	O
longfloat_zero	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
longfloat_zero	O
)	O
=	O
(	O
longfloat	O
)	O
0.0	int
;	O
enter_mark_origin	()->(int)
(	O
&	O
shortfloat_zero	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
longfloat_zero	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-POSITIVE-FIXNUM"	*(char)
,	O
make_fixnum	()->(int)
(	O
MOST_POSITIVE_FIX	O
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-NEGATIVE-FIXNUM"	*(char)
,	O
make_fixnum	()->(int)
(	O
MOST_NEGATIVE_FIX	O
)	O
)	O
;	O
gcl_init_big	()->(int)
(	O
)	O
;	O
gcl_init_num_pred	()->(int)
(	O
)	O
;	O
gcl_init_num_comp	()->(int)
(	O
)	O
;	O
gcl_init_num_arith	()->(int)
(	O
)	O
;	O
gcl_init_num_co	()->(int)
(	O
)	O
;	O
gcl_init_num_log	()->(int)
(	O
)	O
;	O
gcl_init_num_sfun	()->(int)
(	O
)	O
;	O
gcl_init_num_rand	()->(int)
(	O
)	O
;	O
}	O
