static	O
void	O
find_double_threats	(int)->(void)
(	O
int	O
color	int
)	O
;	O
void	O
combinations	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
save_verbose	int
;	O
int	O
attack_point	*(int)
;	O
signed	O
char	O
defense_points	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
aa_val	int
;	O
find_double_threats	(int)->(void)
(	O
color	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"\nlooking for combination attacks ...\n"	*(char)
)	O
;	O
aa_val	int
=	O
atari_atari	(int,*(int),array(char),int)->(int)
(	O
color	int
,	O
&	O
attack_point	*(int)
,	O
NULL	O
,	O
save_verbose	int
)	O
;	O
if	O
(	O
aa_val	int
>	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Combination attack for %C with size %d found at %1m\n"	*(char)
,	O
color	int
,	O
aa_val	int
,	O
attack_point	*(int)
)	O
;	O
add_my_atari_atari_move	(int,int)->(void)
(	O
attack_point	*(int)
,	O
aa_val	int
)	O
;	O
}	O
aa_val	int
=	O
atari_atari	(int,*(int),array(char),int)->(int)
(	O
other	int
,	O
&	O
attack_point	*(int)
,	O
defense_points	array(int)
,	O
save_verbose	int
)	O
;	O
if	O
(	O
aa_val	int
>	O
0	int
)	O
{	O
int	O
pos	int
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Combination attack for %C with size %d found at %1m\n"	*(char)
,	O
other	int
,	O
aa_val	int
,	O
attack_point	*(int)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_points	array(int)
[	O
pos	int
]	O
)	O
{	O
add_your_atari_atari_move	(int,int)->(void)
(	O
pos	int
,	O
aa_val	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"- defense at %1m\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
find_double_threats	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
ii	int
;	O
int	O
k	int
;	O
int	O
l	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
int	O
num_a_threatened_groups	int
;	O
int	O
a_threatened_groups	array(int)
[	O
MAX_THREATENED_STRINGS	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
continue	O
;	O
num_a_threatened_groups	int
=	O
get_attack_threats	(int,int,array(int))->(int)
(	O
ii	int
,	O
MAX_THREATENED_STRINGS	int
,	O
a_threatened_groups	array(int)
)	O
;	O
if	O
(	O
num_a_threatened_groups	int
>	O
1	int
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
ii	int
,	O
color	int
,	O
"find_double_threats-A"	*(char)
,	O
ii	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_a_threatened_groups	int
-	O
1	int
;	O
++	O
k	int
)	O
for	O
(	O
l	int
=	O
k	int
+	O
1	int
;	O
l	int
<	O
num_a_threatened_groups	int
;	O
++	O
l	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
a_threatened_groups	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
a_threatened_groups	array(int)
[	O
l	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
attack	(int,*(int))->(int)
(	O
ii	int
,	O
NULL	O
)	O
)	O
{	O
TRACE	O
(	O
"Double threat at %1m, either %1m or %1m attacked.\n"	*(char)
,	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
add_either_move	(int,int,int,int,int)->(void)
(	O
ii	int
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
remove_attack_threat_move	(int,int)->(void)
(	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
)	O
;	O
remove_attack_threat_move	(int,int)->(void)
(	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
defend_both	(int,int)->(int)
(	O
a_threatened_groups	array(int)
[	O
k	int
]	O
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
)	O
{	O
TRACE	O
(	O
"Double threat at %1m, either %1m or %1m attacked.\n"	*(char)
,	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
add_either_move	(int,int,int,int,int)->(void)
(	O
ii	int
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
remove_attack_threat_move	(int,int)->(void)
(	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
k	int
]	O
)	O
;	O
remove_attack_threat_move	(int,int)->(void)
(	O
ii	int
,	O
a_threatened_groups	array(int)
[	O
l	int
]	O
)	O
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
struct	O
aa_move	struct(int,array(int))
{	O
int	O
move	*(int)
;	O
int	O
target	int
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
;	O
}	O
;	O
static	O
int	O
aa_status	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
forbidden	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
aa_values	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
compute_aa_status	(int,array(char))->(void)
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
compute_aa_values	(int)->(void)
(	O
int	O
color	int
)	O
;	O
static	O
int	O
get_aa_status	(int)->(int)
(	O
int	O
pos	int
)	O
;	O
static	O
int	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
defense_point	*(int)
,	O
signed	O
char	O
all_potential_defenses	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
atari_atari_succeeded	(int,*(int),*(int),int,int,int)->(int)
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
defense_point	*(int)
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
)	O
;	O
static	O
void	O
atari_atari_find_attack_moves	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
atari_atari_attack_patterns	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
atari_atari_attack_callback	(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void))->(void)
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	int
,	O
void	O
*	O
data	*(void)
)	O
;	O
static	O
int	O
atari_atari_find_defense_moves	(array(int),array(int))->(int)
(	O
int	O
targets	array(int)
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
,	O
int	O
moves	array(int)
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
static	O
int	O
get_aa_value	(int)->(int)
(	O
int	O
str	int
)	O
;	O
static	O
int	O
update_aa_goal	(array(char),array(char),int,int)->(int)
(	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_goal	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
,	O
int	O
color	int
)	O
;	O
static	O
void	O
aa_init_moves	(array(struct(int,array(int))))->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
static	O
void	O
aa_add_move	(array(struct(int,array(int))),int,int)->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
;	O
static	O
int	O
aa_move_known	(array(struct(int,array(int))),int,int)->(int)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
;	O
static	O
void	O
aa_sort_moves	(array(struct(int,array(int))))->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
int	O
atari_atari	(int,*(int),array(char),int)->(int)
(	O
int	O
color	int
,	O
int	O
*	O
attack_move	*(int)
,	O
signed	O
char	O
defense_moves	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
save_verbose	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
dpos	int
;	O
int	O
aa_val	int
;	O
signed	O
char	O
saved_defense_moves	array(char)
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
aa_depth	int
<	O
2	int
)	O
return	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
forbidden	array(int)
,	O
0	int
,	O
sizeof	O
(	O
forbidden	array(int)
)	O
)	O
;	O
compute_aa_status	(int,array(char))->(void)
(	O
color	int
,	O
NULL	O
)	O
;	O
compute_aa_values	(int)->(void)
(	O
color	int
)	O
;	O
if	O
(	O
defense_moves	array(char)
)	O
memset	(*(void),int,long)->(*(void))
(	O
defense_moves	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
defense_moves	array(char)
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
return	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
new_aa_val	int
;	O
if	O
(	O
attack_move	*(int)
)	O
*	O
attack_move	*(int)
=	O
apos	int
;	O
forbidden	array(int)
[	O
apos	int
]	O
=	O
1	int
;	O
if	O
(	O
defense_moves	array(char)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved_defense_moves	array(char)
,	O
defense_moves	array(char)
,	O
BOARDMAX	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
defense_moves	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
}	O
new_aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
defense_moves	array(char)
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
aa_val	int
,	O
NULL	O
)	O
;	O
if	O
(	O
new_aa_val	int
==	O
0	int
)	O
break	O
;	O
else	O
aa_val	int
=	O
new_aa_val	int
;	O
}	O
if	O
(	O
defense_moves	array(char)
)	O
{	O
int	O
pos	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
defense_moves	array(char)
,	O
saved_defense_moves	array(char)
,	O
BOARDMAX	O
)	O
;	O
forbidden	array(int)
[	O
apos	int
]	O
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
!	O
defense_moves	array(char)
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
other	int
,	O
"atari_atari"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"%1m deleted defense point, illegal\n"	*(char)
,	O
pos	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"%1m deleted defense point, unsafe\n"	*(char)
,	O
pos	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
NULL	O
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
aa_val	int
,	O
NULL	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"%1m deleted defense point, didn't work\n"	*(char)
,	O
pos	int
)	O
;	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
return	O
aa_val	int
;	O
}	O
int	O
atari_atari_confirm_safety	(int,int,*(int),int,array(char),array(char))->(int)
(	O
int	O
color	int
,	O
int	O
move	*(int)
,	O
int	O
*	O
defense	*(int)
,	O
int	O
minsize	int
,	O
const	O
signed	O
char	O
saved_dragons	array(char)
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
saved_worms	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
defense_moves	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
blunder_size	(int,int,*(int),array(char))->(float)
;	O
mark_safe_stones	(int,int,array(char),array(char),array(char))->(void)
(	O
color	int
,	O
move	*(int)
,	O
saved_dragons	array(char)
,	O
saved_worms	array(char)
,	O
safe_stones	array(char)
)	O
;	O
blunder_size	(int,int,*(int),array(char))->(float)
=	O
atari_atari_blunder_size	(int,int,array(char),array(char))->(int)
(	O
color	int
,	O
move	*(int)
,	O
defense_moves	array(char)
,	O
safe_stones	array(char)
)	O
;	O
if	O
(	O
defense	*(int)
)	O
{	O
*	O
defense	*(int)
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_moves	array(char)
[	O
pos	int
]	O
)	O
{	O
*	O
defense	*(int)
=	O
pos	int
;	O
break	O
;	O
}	O
}	O
return	O
blunder_size	(int,int,*(int),array(char))->(float)
>=	O
minsize	int
;	O
}	O
int	O
atari_atari_blunder_size	(int,int,array(char),array(char))->(int)
(	O
int	O
color	int
,	O
int	O
move	*(int)
,	O
signed	O
char	O
defense_moves	array(char)
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
apos	int
;	O
int	O
defense_point	*(int)
=	O
NO_MOVE	O
;	O
int	O
aa_val	int
,	O
after_aa_val	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
signed	O
char	O
defense_points	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
last_forbidden	int
=	O
NO_MOVE	O
;	O
if	O
(	O
aa_depth	int
<	O
2	int
)	O
return	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
forbidden	array(int)
,	O
0	int
,	O
sizeof	O
(	O
forbidden	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
defense_points	array(int)
,	O
0	int
,	O
sizeof	O
(	O
defense_points	array(int)
)	O
)	O
;	O
compute_aa_status	(int,array(char))->(void)
(	O
other	int
,	O
safe_stones	array(char)
)	O
;	O
compute_aa_values	(int)->(void)
(	O
other	int
)	O
;	O
if	O
(	O
!	O
tryko	(int,int,*(char))->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
)	O
)	O
abortgo	(*(char),int,*(char),int)->(void)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
"trymove"	*(char)
,	O
move	*(int)
)	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	*(int)
,	O
defense_points	array(int)
,	O
NO_MOVE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
after_aa_val	int
=	O
aa_val	int
;	O
if	O
(	O
aa_val	int
==	O
0	int
||	O
defense_point	*(int)
==	O
NO_MOVE	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
aa_val	int
>=	O
after_aa_val	int
&&	O
defense_point	*(int)
!=	O
NO_MOVE	O
)	O
{	O
forbidden	array(int)
[	O
apos	int
]	O
=	O
1	int
;	O
last_forbidden	int
=	O
apos	int
;	O
aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	*(int)
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
aa_val	int
,	O
NULL	O
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
compute_aa_status	(int,array(char))->(void)
(	O
other	int
,	O
NULL	O
)	O
;	O
compute_aa_values	(int)->(void)
(	O
other	int
)	O
;	O
forbidden	array(int)
[	O
last_forbidden	int
]	O
=	O
0	int
;	O
aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
other	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
aa_val	int
>=	O
after_aa_val	int
)	O
return	O
0	int
;	O
if	O
(	O
defense_moves	array(char)
)	O
{	O
int	O
pos	int
;	O
compute_aa_status	(int,array(char))->(void)
(	O
other	int
,	O
safe_stones	array(char)
)	O
;	O
compute_aa_values	(int)->(void)
(	O
other	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
defense_moves	array(char)
,	O
defense_points	array(int)
,	O
sizeof	O
(	O
defense_points	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
!	O
defense_moves	array(char)
[	O
pos	int
]	O
||	O
pos	int
==	O
move	*(int)
)	O
continue	O
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"atari_atari"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
increase_depth_values	()->(void)
(	O
)	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
tryko	(int,int,*(char))->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
)	O
)	O
abortgo	(*(char),int,*(char),int)->(void)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
"trymove"	*(char)
,	O
move	*(int)
)	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
if	O
(	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	*(int)
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
after_aa_val	int
,	O
NULL	O
)	O
>=	O
after_aa_val	int
)	O
defense_moves	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
return	O
after_aa_val	int
-	O
aa_val	int
;	O
}	O
static	O
void	O
compute_aa_status	(int,array(char))->(void)
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
gg_assert	O
(	O
safe_stones	array(char)
||	O
stackp	int
==	O
0	int
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
)	O
{	O
if	O
(	O
safe_stones	array(char)
)	O
{	O
if	O
(	O
safe_stones	array(char)
[	O
pos	int
]	O
)	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
ALIVE	int
;	O
else	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
CRITICAL	int
;	O
else	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
CRITICAL	int
;	O
else	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
ALIVE	int
;	O
}	O
}	O
else	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
aa_status	array(int)
[	O
pos	int
]	O
=	O
UNKNOWN	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
find_origin	(int)->(int)
(	O
pos	int
)	O
==	O
pos	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
==	O
2	int
&&	O
aa_status	array(int)
[	O
pos	int
]	O
==	O
ALIVE	int
)	O
{	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
)	O
&&	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
owl_substantial	(int)->(int)
(	O
pos	int
)	O
)	O
{	O
int	O
pos2	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
other	int
&&	O
find_origin	(int)->(int)
(	O
pos2	int
)	O
==	O
pos	int
)	O
aa_status	array(int)
[	O
pos2	int
]	O
=	O
INSUBSTANTIAL	int
;	O
}	O
}	O
}	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"compute_aa_status() for %C\n"	*(char)
,	O
color	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"aa_status: (ALIVE worms not listed)\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
is_worm_origin	(int,int)->(int)
(	O
pos	int
,	O
pos	int
)	O
)	O
{	O
const	O
char	O
*	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
"UNKNOWN (shouldn't happen)"	*(char)
;	O
if	O
(	O
aa_status	array(int)
[	O
pos	int
]	O
==	O
DEAD	int
)	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
"DEAD"	*(char)
;	O
else	O
if	O
(	O
aa_status	array(int)
[	O
pos	int
]	O
==	O
CRITICAL	int
)	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
"CRITICAL"	*(char)
;	O
else	O
if	O
(	O
aa_status	array(int)
[	O
pos	int
]	O
==	O
INSUBSTANTIAL	int
)	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
"INSUBSTANTIAL"	*(char)
;	O
if	O
(	O
aa_status	array(int)
[	O
pos	int
]	O
!=	O
ALIVE	int
)	O
gprintf	(*(char))->(int)
(	O
"%1M: %s\n"	*(char)
,	O
pos	int
,	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
int	O
get_aa_status	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
k	int
;	O
if	O
(	O
aa_status	array(int)
[	O
pos	int
]	O
!=	O
UNKNOWN	int
)	O
return	O
aa_status	array(int)
[	O
pos	int
]	O
;	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
if	O
(	O
aa_status	array(int)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
!=	O
UNKNOWN	int
)	O
return	O
aa_status	array(int)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
;	O
return	O
UNKNOWN	int
;	O
}	O
static	O
int	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
defense_point	*(int)
,	O
signed	O
char	O
all_potential_defenses	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
;	O
int	O
num_defense_moves	int
;	O
int	O
defense_moves	array(char)
[	O
AA_MAX_MOVES	O
]	O
;	O
int	O
pos	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%odo_atari_atari: "	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oforbidden moves: "	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
forbidden	array(int)
[	O
pos	int
]	O
)	O
gprintf	(*(char))->(int)
(	O
"%o%1m "	*(char)
,	O
pos	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%ogoal: "	*(char)
)	O
;	O
if	O
(	O
!	O
goal	*(char)
)	O
gprintf	(*(char))->(int)
(	O
"none"	*(char)
)	O
;	O
else	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
gprintf	(*(char))->(int)
(	O
"%o%1m "	*(char)
,	O
pos	int
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
last_friendly	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
retval	int
;	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
retval	int
=	O
atari_atari_succeeded	(int,*(int),*(int),int,int,int)->(int)
(	O
color	int
,	O
attack_point	*(int)
,	O
defense_point	*(int)
,	O
last_friendly	int
,	O
save_verbose	int
,	O
minsize	int
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
retval	int
!=	O
0	int
)	O
{	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"attack found"	*(char)
)	O
;	O
return	O
retval	int
;	O
}	O
}	O
if	O
(	O
stackp	int
>	O
aa_depth	int
)	O
return	O
0	int
;	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
atari_atari_find_attack_moves	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
color	int
,	O
minsize	int
,	O
attacks	array(struct(int,array(int)))
,	O
goal	*(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
int	O
aa_val	int
;	O
int	O
str	int
=	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
;	O
int	O
apos	int
=	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
;	O
int	O
bpos	int
;	O
int	O
r	int
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
color	int
,	O
"do_atari_atari-A"	*(char)
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
all_potential_defenses	array(char)
)	O
{	O
all_potential_defenses	array(char)
[	O
apos	int
]	O
=	O
1	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
apos	int
)	O
<=	O
2	int
)	O
{	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
num_libs	int
=	O
findlib	(int,int,*(int))->(int)
(	O
apos	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
all_potential_defenses	array(char)
[	O
libs	*(int)
[	O
0	int
]	O
]	O
=	O
1	int
;	O
if	O
(	O
num_libs	int
==	O
2	int
)	O
all_potential_defenses	array(char)
[	O
libs	*(int)
[	O
1	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
gprintf	(*(char))->(int)
(	O
"%oError condition found by atari_atari\n"	*(char)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
aa_val	int
=	O
get_aa_value	(int)->(int)
(	O
str	int
)	O
;	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
num_defense_moves	int
=	O
atari_atari_find_defense_moves	(array(int),array(int))->(int)
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
,	O
defense_moves	array(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_defense_moves	int
;	O
r	int
++	O
)	O
{	O
bpos	int
=	O
defense_moves	array(char)
[	O
r	int
]	O
;	O
if	O
(	O
all_potential_defenses	array(char)
)	O
all_potential_defenses	array(char)
[	O
bpos	int
]	O
=	O
1	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
bpos	int
,	O
other	int
,	O
"do_atari_atari-B"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
new_aa_val	int
;	O
signed	O
char	O
new_goal	array(char)
[	O
BOARDMAX	O
]	O
;	O
modify_depth_values	(int)->(void)
(	O
2	int
)	O
;	O
update_aa_goal	(array(char),array(char),int,int)->(int)
(	O
goal	*(char)
,	O
new_goal	array(char)
,	O
apos	int
,	O
color	int
)	O
;	O
new_aa_val	int
=	O
do_atari_atari	(int,*(int),*(int),array(char),int,int,int,array(char))->(int)
(	O
color	int
,	O
NULL	O
,	O
defense_point	*(int)
,	O
all_potential_defenses	array(char)
,	O
apos	int
,	O
save_verbose	int
,	O
minsize	int
,	O
new_goal	array(char)
)	O
;	O
modify_depth_values	(int)->(void)
(	O
-	O
2	int
)	O
;	O
if	O
(	O
new_aa_val	int
<	O
aa_val	int
)	O
aa_val	int
=	O
new_aa_val	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
num_defense_moves	int
==	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oThe worm %1m can be attacked at %1m after "	*(char)
,	O
str	int
,	O
apos	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"attack found"	*(char)
)	O
;	O
}	O
if	O
(	O
attack_point	*(int)
)	O
*	O
attack_point	*(int)
=	O
apos	int
;	O
if	O
(	O
defense_point	*(int)
)	O
{	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
find_defense	(int,*(int))->(int)
(	O
str	int
,	O
defense_point	*(int)
)	O
)	O
*	O
defense_point	*(int)
=	O
NO_MOVE	O
;	O
if	O
(	O
(	O
*	O
defense_point	*(int)
==	O
NO_MOVE	O
||	O
!	O
safe_move	(int,int)->(int)
(	O
*	O
defense_point	*(int)
,	O
other	int
)	O
)	O
&&	O
safe_move	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
*	O
defense_point	*(int)
=	O
apos	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"%oreturn value:%d (%1m)\n"	*(char)
,	O
aa_val	int
,	O
str	int
)	O
;	O
return	O
aa_val	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
atari_atari_succeeded	(int,*(int),*(int),int,int,int)->(int)
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
defense_point	*(int)
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
)	O
{	O
int	O
pos	int
;	O
int	O
apos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
pos	int
!=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
minsize	int
>	O
0	int
&&	O
get_aa_value	(int)->(int)
(	O
pos	int
)	O
<	O
minsize	int
)	O
continue	O
;	O
if	O
(	O
get_aa_status	(int)->(int)
(	O
pos	int
)	O
!=	O
ALIVE	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
last_friendly	int
]	O
!=	O
EMPTY	int
&&	O
!	O
adjacent_strings	(int,int)->(int)
(	O
last_friendly	int
,	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
last_friendly	int
]	O
==	O
EMPTY	int
&&	O
!	O
liberty_of_string	(int,int)->(int)
(	O
last_friendly	int
,	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
gprintf	(*(char))->(int)
(	O
"Considering attack of %1m. depth = %d.\n"	*(char)
,	O
pos	int
,	O
depth	int
)	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
apos	int
)	O
&&	O
!	O
forbidden	array(int)
[	O
apos	int
]	O
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oThe worm %1m can be attacked at %1m after "	*(char)
,	O
pos	int
,	O
apos	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
attack_point	*(int)
)	O
*	O
attack_point	*(int)
=	O
apos	int
;	O
if	O
(	O
defense_point	*(int)
)	O
{	O
if	O
(	O
!	O
find_defense	(int,*(int))->(int)
(	O
pos	int
,	O
defense_point	*(int)
)	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
*	O
defense_point	*(int)
=	O
apos	int
;	O
else	O
*	O
defense_point	*(int)
=	O
NO_MOVE	O
;	O
}	O
}	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"%oreturn value:%d (%1m)\n"	*(char)
,	O
get_aa_value	(int)->(int)
(	O
pos	int
)	O
,	O
pos	int
)	O
;	O
return	O
get_aa_value	(int)->(int)
(	O
pos	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
atari_atari_find_attack_moves	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
aa_init_moves	(array(struct(int,array(int))))->(void)
(	O
attacks	array(struct(int,array(int)))
)	O
;	O
atari_atari_attack_patterns	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
color	int
,	O
minsize	int
,	O
attacks	array(struct(int,array(int)))
,	O
goal	*(char)
)	O
;	O
aa_sort_moves	(array(struct(int,array(int))))->(void)
(	O
attacks	array(struct(int,array(int)))
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Attack moves:"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
&&	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%o %1m("	*(char)
,	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
gprintf	(*(char))->(int)
(	O
"%o%s%1m"	*(char)
,	O
r	int
==	O
0	int
?	O
""	*(char)
:	O
","	*(char)
,	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"%o)"	*(char)
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
current_minsize	int
;	O
static	O
struct	O
aa_move	struct(int,array(int))
*	O
current_attacks	*(struct(int,array(int)))
;	O
static	O
int	O
conditional_attack_point	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
atari_atari_attack_patterns	(int,int,array(struct(int,array(int))),array(char))->(void)
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
revised_goal	array(char)
[	O
BOARDMAX	O
]	O
;	O
current_minsize	int
=	O
minsize	int
;	O
current_attacks	*(struct(int,array(int)))
=	O
attacks	array(struct(int,array(int)))
;	O
memset	(*(void),int,long)->(*(void))
(	O
conditional_attack_point	array(int)
,	O
0	int
,	O
sizeof	O
(	O
conditional_attack_point	array(int)
)	O
)	O
;	O
if	O
(	O
goal	*(char)
==	O
NULL	O
&&	O
update_aa_goal	(array(char),array(char),int,int)->(int)
(	O
goal	*(char)
,	O
revised_goal	array(char)
,	O
NO_MOVE	O
,	O
color	int
)	O
)	O
goal	*(char)
=	O
revised_goal	array(char)
;	O
matchpat	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char))->(void)
(	O
atari_atari_attack_callback	(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void))->(void)
,	O
color	int
,	O
&	O
aa_attackpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
,	O
NULL	O
,	O
goal	*(char)
)	O
;	O
}	O
static	O
void	O
atari_atari_attack_callback	(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void))->(void)
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	int
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
move	*(int)
;	O
int	O
k	int
;	O
UNUSED	O
(	O
data	*(void)
)	O
;	O
move	*(int)
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
forbidden	array(int)
[	O
move	*(int)
]	O
)	O
return	O
;	O
if	O
(	O
pattern	*(struct)
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
if	O
(	O
!	O
pattern	*(struct)
->	O
autohelper	*((int,int,int,int)->(int))
(	O
ll	int
,	O
move	*(int)
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
if	O
(	O
pattern	*(struct)
->	O
helper	*((*(struct(*(struct`),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct`),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,int,int)->(int))
)	O
if	O
(	O
!	O
pattern	*(struct)
->	O
helper	*((*(struct(*(struct`),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct`),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,int,int)->(int))
(	O
pattern	*(struct)
,	O
ll	int
,	O
move	*(int)
,	O
color	int
)	O
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
if	O
(	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	int
)	O
{	O
int	O
str	int
=	O
find_origin	(int)->(int)
(	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
)	O
;	O
if	O
(	O
current_minsize	int
>	O
0	int
&&	O
get_aa_value	(int)->(int)
(	O
str	int
)	O
<	O
current_minsize	int
)	O
continue	O
;	O
if	O
(	O
aa_move_known	(array(struct(int,array(int))),int,int)->(int)
(	O
current_attacks	*(struct(int,array(int)))
,	O
move	*(int)
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
get_aa_status	(int)->(int)
(	O
str	int
)	O
!=	O
ALIVE	int
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
pattern	*(struct)
->	O
class	int
&	O
CLASS_s	int
)	O
&&	O
is_self_atari	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
>	O
2	int
)	O
continue	O
;	O
if	O
(	O
!	O
safe_move	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"attack_callback"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
;	O
int	O
attack_point	*(int)
=	O
NO_MOVE	O
;	O
if	O
(	O
!	O
board	*(char)
[	O
str	int
]	O
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
&	O
attack_point	*(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
pattern	*(struct)
->	O
class	int
&	O
CLASS_c	int
)	O
&&	O
!	O
aa_move_known	(array(struct(int,array(int))),int,int)->(int)
(	O
current_attacks	*(struct(int,array(int)))
,	O
move	*(int)
,	O
NO_MOVE	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_attack pattern %s+%d (conditional) found threat on %1m at %1m with code %d\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
,	O
str	int
,	O
move	*(int)
,	O
acode	int
)	O
;	O
if	O
(	O
conditional_attack_point	array(int)
[	O
move	*(int)
]	O
==	O
NO_MOVE	O
)	O
conditional_attack_point	array(int)
[	O
move	*(int)
]	O
=	O
str	int
;	O
else	O
if	O
(	O
conditional_attack_point	array(int)
[	O
move	*(int)
]	O
!=	O
str	int
)	O
{	O
aa_add_move	(array(struct(int,array(int))),int,int)->(void)
(	O
current_attacks	*(struct(int,array(int)))
,	O
move	*(int)
,	O
conditional_attack_point	array(int)
[	O
move	*(int)
]	O
)	O
;	O
aa_add_move	(array(struct(int,array(int))),int,int)->(void)
(	O
current_attacks	*(struct(int,array(int)))
,	O
move	*(int)
,	O
str	int
)	O
;	O
}	O
}	O
else	O
{	O
aa_add_move	(array(struct(int,array(int))),int,int)->(void)
(	O
current_attacks	*(struct(int,array(int)))
,	O
move	*(int)
,	O
str	int
)	O
;	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_attack pattern %s+%d found threat on %1m at %1m with code %d\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
,	O
str	int
,	O
move	*(int)
,	O
acode	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
atari_atari_find_defense_moves	(array(int),array(int))->(int)
(	O
int	O
targets	array(int)
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
,	O
int	O
moves	array(int)
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
move	*(int)
;	O
int	O
k	int
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
neighbors	int
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
mx	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
r	int
,	O
s	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mx	array(char)
,	O
0	int
,	O
sizeof	O
(	O
mx	array(char)
)	O
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
&&	O
targets	array(int)
[	O
r	int
]	O
!=	O
NO_MOVE	O
;	O
r	int
++	O
)	O
{	O
int	O
str	int
=	O
targets	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
!	O
find_defense	(int,*(int))->(int)
(	O
str	int
,	O
&	O
move	*(int)
)	O
)	O
continue	O
;	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
move	*(int)
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
mx	array(char)
[	O
move	*(int)
]	O
=	O
1	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array(char)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
,	O
"aa_defend-A"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
mx	array(char)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
}	O
}	O
neighbors	int
=	O
chainlinks	(int,array(int))->(int)
(	O
str	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
attack_point	*(int)
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
&	O
attack_point	*(int)
)	O
==	O
WIN	int
&&	O
!	O
mx	array(char)
[	O
attack_point	*(int)
]	O
)	O
{	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
attack_point	*(int)
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
mx	array(char)
[	O
attack_point	*(int)
]	O
=	O
1	int
;	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
liberties	*(int)
<=	O
3	int
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	*(int)
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array(char)
[	O
libs	*(int)
[	O
s	int
]	O
]	O
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
s	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
libs	*(int)
[	O
s	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
,	O
"aa_defend-B"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
s	int
]	O
;	O
mx	array(char)
[	O
libs	*(int)
[	O
s	int
]	O
]	O
=	O
1	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Defense moves for %1m:"	*(char)
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%o %1m"	*(char)
,	O
moves	array(int)
[	O
k	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
}	O
}	O
return	O
num_moves	int
;	O
}	O
static	O
void	O
compute_aa_values	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
;	O
int	O
value	*(char)
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
mx	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
r	int
,	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
||	O
pos	int
!=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
||	O
aa_status	array(int)
[	O
pos	int
]	O
!=	O
ALIVE	int
)	O
{	O
aa_values	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
mx	array(char)
,	O
0	int
,	O
sizeof	O
(	O
mx	array(char)
)	O
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
value	*(char)
=	O
2	int
*	O
countstones	(int)->(int)
(	O
pos	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array(char)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
&&	O
(	O
whose_moyo	(*(struct),int)->(int)
(	O
&	O
initial_black_influence	struct
,	O
libs	*(int)
[	O
r	int
]	O
)	O
==	O
other	int
||	O
whose_moyo	(*(struct),int)->(int)
(	O
&	O
initial_white_influence	struct
,	O
libs	*(int)
[	O
r	int
]	O
)	O
==	O
other	int
)	O
)	O
{	O
mx	array(char)
[	O
libs	*(int)
[	O
r	int
]	O
]	O
=	O
1	int
;	O
value	*(char)
++	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
librd	int
=	O
libs	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD1	O
(	O
librd	int
)	O
||	O
mx	array(char)
[	O
librd	int
]	O
)	O
continue	O
;	O
mx	array(char)
[	O
librd	int
]	O
=	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
librd	int
]	O
==	O
EMPTY	int
&&	O
(	O
whose_moyo	(*(struct),int)->(int)
(	O
&	O
initial_black_influence	struct
,	O
librd	int
)	O
==	O
other	int
||	O
(	O
whose_moyo	(*(struct),int)->(int)
(	O
&	O
initial_white_influence	struct
,	O
librd	int
)	O
==	O
other	int
)	O
)	O
)	O
value	*(char)
++	O
;	O
}	O
}	O
aa_values	array(int)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
if	O
(	O
1	int
)	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_value for %1m = %d\n"	*(char)
,	O
pos	int
,	O
value	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
get_aa_value	(int)->(int)
(	O
int	O
str	int
)	O
{	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
k	int
;	O
int	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
str	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
int	O
value	*(char)
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
value	*(char)
+=	O
aa_values	array(int)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
;	O
return	O
value	*(char)
;	O
}	O
static	O
int	O
update_aa_goal	(array(char),array(char),int,int)->(int)
(	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_goal	array(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
dists	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
queue	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
queue_end	int
=	O
0	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
int	O
pos	int
;	O
if	O
(	O
goal	*(char)
==	O
NULL	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
new_goal	array(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
else	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_goal	array(char)
,	O
goal	*(char)
,	O
BOARDMAX	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
dists	array(int)
,	O
0	int
,	O
sizeof	O
(	O
dists	array(int)
)	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
)	O
{	O
dists	array(int)
[	O
apos	int
]	O
=	O
1	int
;	O
queue	array(int)
[	O
queue_end	int
++	O
]	O
=	O
apos	int
;	O
}	O
if	O
(	O
queue_end	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
queue_end	int
;	O
r	int
++	O
)	O
{	O
int	O
smallest_dist	int
=	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
int	O
best_index	int
=	O
-	O
1	int
;	O
gg_assert	O
(	O
queue_end	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
r	int
;	O
k	int
<	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
dists	array(int)
[	O
queue	array(int)
[	O
k	int
]	O
]	O
<	O
smallest_dist	int
)	O
{	O
smallest_dist	int
=	O
dists	array(int)
[	O
queue	array(int)
[	O
k	int
]	O
]	O
;	O
best_index	int
=	O
k	int
;	O
}	O
}	O
if	O
(	O
best_index	int
!=	O
r	int
)	O
{	O
int	O
tmp	int
=	O
queue	array(int)
[	O
r	int
]	O
;	O
queue	array(int)
[	O
r	int
]	O
=	O
queue	array(int)
[	O
best_index	int
]	O
;	O
queue	array(int)
[	O
best_index	int
]	O
=	O
tmp	int
;	O
}	O
pos	int
=	O
queue	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
)	O
new_goal	array(char)
[	O
pos	int
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
color	int
||	O
pos	int
==	O
apos	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE	O
(	O
pos2	int
,	O
dists	array(int)
[	O
pos	int
]	O
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
other	int
&&	O
board	*(char)
[	O
pos2	int
]	O
==	O
other	int
)	O
{	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
size	int
=	O
findstones	(int,int,*(int))->(int)
(	O
pos2	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
int	O
libs	*(int)
=	O
countlib	(int)->(int)
(	O
pos2	int
)	O
;	O
int	O
deltadist	int
=	O
libs	*(int)
-	O
3	int
;	O
if	O
(	O
deltadist	int
<	O
0	int
)	O
deltadist	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
size	int
;	O
s	int
++	O
)	O
ENQUEUE	O
(	O
stones	*(int)
[	O
s	int
]	O
,	O
dists	array(int)
[	O
pos	int
]	O
+	O
deltadist	int
)	O
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
aa_init_moves	(array(struct(int,array(int))))->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
attacks	array(struct(int,array(int)))
[	O
0	int
]	O
.	O
move	*(int)
=	O
NO_MOVE	O
;	O
}	O
static	O
void	O
aa_add_move	(array(struct(int,array(int))),int,int)->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
;	O
k	int
++	O
)	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
move	*(int)
||	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
AA_MAX_MOVES	O
)	O
return	O
;	O
target	int
=	O
find_origin	(int)->(int)
(	O
target	int
)	O
;	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
NO_MOVE	O
)	O
{	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
=	O
move	*(int)
;	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
=	O
target	int
;	O
if	O
(	O
AA_MAX_TARGETS_PER_MOVE	int
>	O
0	int
)	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
1	int
]	O
=	O
NO_MOVE	O
;	O
if	O
(	O
k	int
<	O
AA_MAX_MOVES	O
-	O
1	int
)	O
attacks	array(struct(int,array(int)))
[	O
k	int
+	O
1	int
]	O
.	O
move	*(int)
=	O
NO_MOVE	O
;	O
return	O
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
||	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
r	int
==	O
AA_MAX_TARGETS_PER_MOVE	int
)	O
return	O
;	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
)	O
return	O
;	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
=	O
target	int
;	O
if	O
(	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
-	O
1	int
)	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
+	O
1	int
]	O
=	O
NO_MOVE	O
;	O
}	O
static	O
int	O
aa_move_known	(array(struct(int,array(int))),int,int)->(int)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	*(int)
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
;	O
k	int
++	O
)	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
move	*(int)
||	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
AA_MAX_MOVES	O
)	O
return	O
1	int
;	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
if	O
(	O
target	int
==	O
NO_MOVE	O
)	O
return	O
1	int
;	O
target	int
=	O
find_origin	(int)->(int)
(	O
target	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
||	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
r	int
==	O
AA_MAX_TARGETS_PER_MOVE	int
)	O
return	O
1	int
;	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
target_comp_func	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
int	O
asize	int
=	O
get_aa_value	(int)->(int)
(	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
a	char
)	O
)	O
;	O
int	O
bsize	int
=	O
get_aa_value	(int)->(int)
(	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
b	char
)	O
)	O
;	O
return	O
asize	int
-	O
bsize	int
;	O
}	O
static	O
int	O
move_comp_func	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
const	O
struct	O
aa_move	struct(int,array(int))
*	O
aa	*(struct(int,array(int)))
=	O
a	char
;	O
const	O
struct	O
aa_move	struct(int,array(int))
*	O
bb	*(struct(int,array(int)))
=	O
b	char
;	O
int	O
asize	int
=	O
get_aa_value	(int)->(int)
(	O
aa	*(struct(int,array(int)))
->	O
target	int
[	O
0	int
]	O
)	O
;	O
int	O
bsize	int
=	O
get_aa_value	(int)->(int)
(	O
bb	*(struct(int,array(int)))
->	O
target	int
[	O
0	int
]	O
)	O
;	O
return	O
asize	int
-	O
bsize	int
;	O
}	O
static	O
void	O
aa_sort_moves	(array(struct(int,array(int))))->(void)
(	O
struct	O
aa_move	struct(int,array(int))
attacks	array(struct(int,array(int)))
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
number_of_attacks	int
;	O
int	O
number_of_targets	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
&&	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
move	*(int)
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
number_of_targets	int
=	O
r	int
;	O
gg_sort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
,	O
number_of_targets	int
,	O
sizeof	O
(	O
attacks	array(struct(int,array(int)))
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
)	O
,	O
target_comp_func	(*(void),*(void))->(int)
)	O
;	O
}	O
number_of_attacks	int
=	O
k	int
;	O
gg_sort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
attacks	array(struct(int,array(int)))
,	O
number_of_attacks	int
,	O
sizeof	O
(	O
attacks	array(struct(int,array(int)))
[	O
0	int
]	O
)	O
,	O
move_comp_func	(*(void),*(void))->(int)
)	O
;	O
}	O
