static	O
bool	bool
add_newline	bool
;	O
static	O
bool	bool
do_expand	bool
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"context"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"domain"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"shell-script"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
expand_escape	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
const	O
char	O
*	O
msgid	*(char)
;	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_shell	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
const	O
char	O
*	O
domain	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TEXTDOMAIN"	*(char)
)	O
;	O
const	O
char	O
*	O
domaindir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TEXTDOMAINDIR"	*(char)
)	O
;	O
const	O
char	O
*	O
context	*(char)
=	O
NULL	O
;	O
add_newline	bool
=	O
true	int
;	O
do_expand	bool
=	O
false	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"+c:d:eEhnsV"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'c'	O
:	O
context	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'd'	O
:	O
domain	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'e'	O
:	O
do_expand	bool
=	O
true	int
;	O
break	O
;	O
case	O
'E'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'n'	O
:	O
add_newline	bool
=	O
false	int
;	O
break	O
;	O
case	O
's'	O
:	O
do_shell	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%s (GNU %s) %s\n"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"1995-2019"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Written by %s.\n"	*(char)
)	O
,	O
proper_name	(*(char))->(*(char))
(	O
"Ulrich Drepper"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
!	O
do_shell	bool
)	O
{	O
switch	O
(	O
argc	int
-	O
optind	int
)	O
{	O
default	O
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
case	O
2	int
:	O
domain	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
case	O
1	int
:	O
break	O
;	O
case	O
0	int
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"missing arguments"	*(char)
)	O
)	O
;	O
}	O
msgid	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
do_expand	bool
)	O
msgid	*(char)
=	O
expand_escape	(*(char))->(*(char))
(	O
msgid	*(char)
)	O
;	O
if	O
(	O
domain	*(char)
==	O
NULL	O
||	O
domain	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
msgid	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
domaindir	*(char)
!=	O
NULL	O
&&	O
domaindir	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
domain	*(char)
,	O
domaindir	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
context	*(char)
!=	O
NULL	O
?	O
dpgettext_expr	O
(	O
domain	*(char)
,	O
context	*(char)
,	O
msgid	*(char)
)	O
:	O
dgettext	(*(char),*(char))->(*(char))
(	O
domain	*(char)
,	O
msgid	*(char)
)	O
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
if	O
(	O
domain	*(char)
==	O
NULL	O
||	O
domain	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
domain	*(char)
=	O
NULL	O
;	O
else	O
if	O
(	O
domaindir	*(char)
!=	O
NULL	O
&&	O
domaindir	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
domain	*(char)
,	O
domaindir	*(char)
)	O
;	O
do	O
{	O
msgid	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
do_expand	bool
)	O
msgid	*(char)
=	O
expand_escape	(*(char))->(*(char))
(	O
msgid	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
domain	*(char)
==	O
NULL	O
?	O
msgid	*(char)
:	O
context	*(char)
!=	O
NULL	O
?	O
dpgettext_expr	O
(	O
domain	*(char)
,	O
context	*(char)
,	O
msgid	*(char)
)	O
:	O
dgettext	(*(char),*(char))->(*(char))
(	O
domain	*(char)
,	O
msgid	*(char)
)	O
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
while	O
(	O
optind	int
<	O
argc	int
)	O
;	O
}	O
if	O
(	O
add_newline	bool
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION] [[TEXTDOMAIN] MSGID]\nor:    %s [OPTION] -s [MSGID]...\n"	*(char)
)	O
,	O
program_name	*(char)
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Display native language translation of a textual message.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d, --domain=TEXTDOMAIN   retrieve translated messages from TEXTDOMAIN\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -c, --context=CONTEXT     specify context for MSGID\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -e                        enable expansion of some escape sequences\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -n                        suppress trailing newline\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -E                        (ignored for compatibility)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [TEXTDOMAIN] MSGID        retrieve translated message corresponding\n                            to MSGID from TEXTDOMAIN\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Informative output:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                display this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -V, --version             display version information and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If the TEXTDOMAIN parameter is not given, the domain is determined from the\nenvironment variable TEXTDOMAIN.  If the message catalog is not found in the\nregular directory, another location can be specified with the environment\nvariable TEXTDOMAINDIR.\nWhen used with the -s option the program behaves like the 'echo' command.\nBut it does not simply copy its arguments to stdout.  Instead those messages\nfound in the selected catalog are translated.\nStandard search directory: %s\n"	*(char)
)	O
,	O
getenv	(*(char))->(*(char))
(	O
"IN_HELP2MAN"	*(char)
)	O
==	O
NULL	O
?	O
LOCALEDIR	O
:	O
"@localedir@"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_escape	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
retval	*(char)
,	O
*	O
rp	*(char)
;	O
const	O
char	O
*	O
cp	*(char)
=	O
str	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\\'	O
)	O
++	O
cp	*(char)
;	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
str	*(char)
;	O
if	O
(	O
cp	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
return	O
str	*(char)
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"abcfnrtv\\01234567"	*(char)
,	O
cp	*(char)
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
break	O
;	O
++	O
cp	*(char)
;	O
}	O
retval	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
,	O
char	O
)	O
;	O
rp	*(char)
=	O
retval	*(char)
+	O
(	O
cp	*(char)
-	O
str	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
retval	*(char)
,	O
str	*(char)
,	O
cp	*(char)
-	O
str	*(char)
)	O
;	O
do	O
{	O
switch	O
(	O
*	O
++	O
cp	*(char)
)	O
{	O
case	O
'a'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\a'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\b'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'c'	O
:	O
add_newline	bool
=	O
false	int
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\f'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\n'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\r'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\t'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\v'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
rp	*(char)
=	O
'\\'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
{	O
int	O
ch	int
=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
}	O
}	O
*	O
rp	*(char)
=	O
ch	int
;	O
}	O
break	O
;	O
default	O
:	O
*	O
rp	*(char)
=	O
'\\'	O
;	O
break	O
;	O
}	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\\'	O
)	O
*	O
rp	*(char)
++	O
=	O
*	O
cp	*(char)
++	O
;	O
}	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
*	O
rp	*(char)
=	O
'\0'	O
;	O
return	O
(	O
const	O
char	O
*	O
)	O
retval	*(char)
;	O
}	O
