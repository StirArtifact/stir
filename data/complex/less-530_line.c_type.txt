static	O
char	O
*	O
linebuf	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
attr	int
=	O
NULL	O
;	O
public	O
int	O
size_linebuf	int
=	O
0	int
;	O
static	O
int	O
cshift	int
;	O
public	O
int	O
hshift	int
;	O
public	O
int	O
tabstops	array(int)
[	O
TABSTOP_MAX	int
]	O
=	O
{	O
0	int
}	O
;	O
public	O
int	O
ntabstops	int
=	O
1	int
;	O
public	O
int	O
tabdefault	int
=	O
8	int
;	O
public	O
POSITION	long
highest_hilite	long
;	O
static	O
int	O
curr	int
;	O
static	O
int	O
column	int
;	O
static	O
int	O
right_curr	int
;	O
static	O
int	O
right_column	int
;	O
static	O
int	O
overstrike	int
;	O
static	O
int	O
last_overstrike	int
=	O
AT_NORMAL	O
;	O
static	O
int	O
is_null_line	int
;	O
static	O
int	O
lmargin	int
;	O
static	O
LWCHAR	long
pendc	long
;	O
static	O
POSITION	long
pendpos	long
;	O
static	O
char	O
*	O
end_ansi_chars	*(char)
;	O
static	O
char	O
*	O
mid_ansi_chars	*(char)
;	O
static	O
int	O
attr_swidth	(int)->(int)
LESSPARAMS	O
(	O
(	O
int	O
a	int
)	O
)	O
;	O
static	O
int	O
attr_ewidth	(int)->(int)
LESSPARAMS	O
(	O
(	O
int	O
a	int
)	O
)	O
;	O
static	O
int	O
do_append	(long,*(char),long)->(int)
LESSPARAMS	O
(	O
(	O
LWCHAR	long
ch	long
,	O
char	O
*	O
rep	*(char)
,	O
POSITION	long
pos	long
)	O
)	O
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
bs_mode	int
;	O
extern	O
int	O
linenums	int
;	O
extern	O
int	O
ctldisp	int
;	O
extern	O
int	O
twiddle	int
;	O
extern	O
int	O
binattr	int
;	O
extern	O
int	O
status_col	int
;	O
extern	O
int	O
auto_wrap	int
,	O
ignaw	int
;	O
extern	O
int	O
bo_s_width	int
,	O
bo_e_width	int
;	O
extern	O
int	O
ul_s_width	int
,	O
ul_e_width	int
;	O
extern	O
int	O
bl_s_width	int
,	O
bl_e_width	int
;	O
extern	O
int	O
so_s_width	int
,	O
so_e_width	int
;	O
extern	O
int	O
sc_width	int
,	O
sc_height	int
;	O
extern	O
int	O
utf_mode	int
;	O
extern	O
POSITION	long
start_attnpos	long
;	O
extern	O
POSITION	long
end_attnpos	long
;	O
extern	O
LWCHAR	long
rscroll_char	long
;	O
extern	O
int	O
rscroll_attr	int
;	O
static	O
char	O
mbc_buf	array(char)
[	O
MAX_UTF_CHAR_LEN	int
]	O
;	O
static	O
int	O
mbc_buf_len	int
=	O
0	int
;	O
static	O
int	O
mbc_buf_index	int
=	O
0	int
;	O
static	O
POSITION	long
mbc_pos	long
;	O
public	O
void	O
init_line	()->(void)
(	O
)	O
{	O
end_ansi_chars	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSANSIENDCHARS"	*(char)
)	O
;	O
if	O
(	O
end_ansi_chars	*(char)
==	O
NULL	O
||	O
*	O
end_ansi_chars	*(char)
==	O
'\0'	O
)	O
end_ansi_chars	*(char)
=	O
"m"	*(char)
;	O
mid_ansi_chars	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSANSIMIDCHARS"	*(char)
)	O
;	O
if	O
(	O
mid_ansi_chars	*(char)
==	O
NULL	O
||	O
*	O
mid_ansi_chars	*(char)
==	O
'\0'	O
)	O
mid_ansi_chars	*(char)
=	O
"0123456789:;[?!\"'#%()*+ "	*(char)
;	O
linebuf	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
LINEBUF_SIZE	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
attr	int
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
LINEBUF_SIZE	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
size_linebuf	int
=	O
LINEBUF_SIZE	int
;	O
}	O
static	O
int	O
expand_linebuf	()->(int)
(	O
)	O
{	O
int	O
new_size	int
=	O
size_linebuf	int
*	O
2	int
;	O
char	O
*	O
new_buf	*(char)
=	O
(	O
char	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
new_size	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
char	O
*	O
new_attr	*(char)
=	O
(	O
char	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
new_size	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
new_buf	*(char)
==	O
NULL	O
||	O
new_attr	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
new_attr	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
new_attr	*(char)
)	O
;	O
if	O
(	O
new_buf	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
new_buf	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_buf	*(char)
,	O
linebuf	*(char)
,	O
size_linebuf	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_attr	*(char)
,	O
attr	int
,	O
size_linebuf	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
attr	int
)	O
;	O
free	(*(void))->(void)
(	O
linebuf	*(char)
)	O
;	O
linebuf	*(char)
=	O
new_buf	*(char)
;	O
attr	int
=	O
new_attr	*(char)
;	O
size_linebuf	int
=	O
new_size	int
;	O
return	O
0	int
;	O
}	O
public	O
int	O
is_ascii_char	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
return	O
(	O
ch	long
<=	O
0x7F	int
)	O
;	O
}	O
public	O
void	O
prewind	()->(void)
(	O
)	O
{	O
curr	int
=	O
0	int
;	O
column	int
=	O
0	int
;	O
right_curr	int
=	O
0	int
;	O
right_column	int
=	O
0	int
;	O
cshift	int
=	O
0	int
;	O
overstrike	int
=	O
0	int
;	O
last_overstrike	int
=	O
AT_NORMAL	O
;	O
mbc_buf_len	int
=	O
0	int
;	O
is_null_line	int
=	O
0	int
;	O
pendc	long
=	O
'\0'	O
;	O
lmargin	int
=	O
0	int
;	O
if	O
(	O
status_col	int
)	O
lmargin	int
+=	O
2	int
;	O
}	O
static	O
void	O
set_linebuf	(int,long,int)->(void)
(	O
n	int
,	O
ch	long
,	O
a	int
)	O
int	O
n	int
;	O
LWCHAR	long
ch	long
;	O
char	O
a	int
;	O
{	O
linebuf	*(char)
[	O
n	int
]	O
=	O
ch	long
;	O
attr	int
[	O
n	int
]	O
=	O
a	int
;	O
}	O
static	O
void	O
add_linebuf	(long,int,int)->(void)
(	O
ch	long
,	O
a	int
,	O
w	int
)	O
LWCHAR	long
ch	long
;	O
char	O
a	int
;	O
int	O
w	int
;	O
{	O
set_linebuf	(int,long,int)->(void)
(	O
curr	int
++	O
,	O
ch	long
,	O
a	int
)	O
;	O
column	int
+=	O
w	int
;	O
}	O
public	O
void	O
plinenum	(long)->(void)
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
LINENUM	long
linenum	long
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
linenums	int
==	O
OPT_ONPLUS	int
)	O
{	O
linenum	long
=	O
find_linenum	(long)->(long)
(	O
pos	long
)	O
;	O
}	O
if	O
(	O
status_col	int
)	O
{	O
int	O
a	int
=	O
AT_NORMAL	O
;	O
char	O
c	int
=	O
posmark	(long)->(char)
(	O
pos	long
)	O
;	O
if	O
(	O
c	int
!=	O
0	int
)	O
a	int
|=	O
AT_HILITE	O
;	O
else	O
{	O
c	int
=	O
' '	O
;	O
if	O
(	O
start_attnpos	long
!=	O
NULL_POSITION	O
&&	O
pos	long
>=	O
start_attnpos	long
&&	O
pos	long
<=	O
end_attnpos	long
)	O
a	int
|=	O
AT_HILITE	O
;	O
}	O
add_linebuf	(long,int,int)->(void)
(	O
c	int
,	O
a	int
,	O
1	int
)	O
;	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
linenums	int
==	O
OPT_ONPLUS	int
)	O
{	O
char	O
buf	*(char)
[	O
INT_STRLEN_BOUND	O
(	O
linenum	long
)	O
+	O
2	int
]	O
;	O
int	O
pad	int
=	O
0	int
;	O
int	O
n	int
;	O
linenumtoa	(long,*(char))->(void)
(	O
linenum	long
,	O
buf	*(char)
)	O
;	O
n	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
n	int
<	O
MIN_LINENUM_WIDTH	int
)	O
pad	int
=	O
MIN_LINENUM_WIDTH	int
-	O
n	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pad	int
;	O
i	int
++	O
)	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
add_linebuf	(long,int,int)->(void)
(	O
buf	*(char)
[	O
i	int
]	O
,	O
AT_BOLD	O
,	O
1	int
)	O
;	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
lmargin	int
+=	O
n	int
+	O
pad	int
+	O
1	int
;	O
}	O
while	O
(	O
column	int
<	O
lmargin	int
)	O
{	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
pshift	(int)->(void)
(	O
shift	int
)	O
int	O
shift	int
;	O
{	O
LWCHAR	long
prev_ch	long
=	O
0	int
;	O
unsigned	O
char	O
c	int
;	O
int	O
shifted	int
=	O
0	int
;	O
int	O
to	int
;	O
int	O
from	int
;	O
int	O
len	int
;	O
int	O
width	int
;	O
int	O
prev_attr	int
;	O
int	O
next_attr	int
;	O
if	O
(	O
shift	int
>	O
column	int
-	O
lmargin	int
)	O
shift	int
=	O
column	int
-	O
lmargin	int
;	O
if	O
(	O
shift	int
>	O
curr	int
-	O
lmargin	int
)	O
shift	int
=	O
curr	int
-	O
lmargin	int
;	O
to	int
=	O
from	int
=	O
lmargin	int
;	O
while	O
(	O
shifted	int
<=	O
shift	int
&&	O
from	int
<	O
curr	int
)	O
{	O
c	int
=	O
linebuf	*(char)
[	O
from	int
]	O
;	O
if	O
(	O
ctldisp	int
==	O
OPT_ONPLUS	int
&&	O
IS_CSI_START	O
(	O
c	int
)	O
)	O
{	O
linebuf	*(char)
[	O
to	int
]	O
=	O
c	int
;	O
attr	int
[	O
to	int
++	O
]	O
=	O
attr	int
[	O
from	int
++	O
]	O
;	O
while	O
(	O
from	int
<	O
curr	int
&&	O
linebuf	*(char)
[	O
from	int
]	O
)	O
{	O
linebuf	*(char)
[	O
to	int
]	O
=	O
linebuf	*(char)
[	O
from	int
]	O
;	O
attr	int
[	O
to	int
++	O
]	O
=	O
attr	int
[	O
from	int
]	O
;	O
if	O
(	O
!	O
is_ansi_middle	(long)->(int)
(	O
linebuf	*(char)
[	O
from	int
++	O
]	O
)	O
)	O
break	O
;	O
}	O
continue	O
;	O
}	O
width	int
=	O
0	int
;	O
if	O
(	O
!	O
IS_ASCII_OCTET	O
(	O
c	int
)	O
&&	O
utf_mode	int
)	O
{	O
LWCHAR	long
ch	long
;	O
len	int
=	O
utf_len	(char)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
from	int
+	O
len	int
>	O
curr	int
)	O
break	O
;	O
ch	long
=	O
get_wchar	(*(char))->(long)
(	O
linebuf	*(char)
+	O
from	int
)	O
;	O
if	O
(	O
!	O
is_composing_char	(long)->(int)
(	O
ch	long
)	O
&&	O
!	O
is_combining_char	(long,long)->(int)
(	O
prev_ch	long
,	O
ch	long
)	O
)	O
width	int
=	O
is_wide_char	(long)->(int)
(	O
ch	long
)	O
?	O
2	int
:	O
1	int
;	O
prev_ch	long
=	O
ch	long
;	O
}	O
else	O
{	O
len	int
=	O
1	int
;	O
if	O
(	O
c	int
==	O
'\b'	O
)	O
width	int
=	O
(	O
utf_mode	int
&&	O
is_wide_char	(long)->(int)
(	O
prev_ch	long
)	O
)	O
?	O
-	O
2	int
:	O
-	O
1	int
;	O
else	O
if	O
(	O
!	O
control_char	(long)->(int)
(	O
c	int
)	O
)	O
width	int
=	O
1	int
;	O
prev_ch	long
=	O
0	int
;	O
}	O
if	O
(	O
width	int
==	O
2	int
&&	O
shift	int
-	O
shifted	int
==	O
1	int
)	O
{	O
attr	int
[	O
to	int
]	O
=	O
attr	int
[	O
from	int
]	O
;	O
prev_ch	long
=	O
linebuf	*(char)
[	O
to	int
++	O
]	O
=	O
' '	O
;	O
from	int
+=	O
len	int
;	O
shifted	int
++	O
;	O
continue	O
;	O
}	O
prev_attr	int
=	O
(	O
to	int
>	O
0	int
)	O
?	O
attr	int
[	O
to	int
-	O
1	int
]	O
:	O
AT_NORMAL	O
;	O
next_attr	int
=	O
(	O
from	int
+	O
len	int
<	O
curr	int
)	O
?	O
attr	int
[	O
from	int
+	O
len	int
]	O
:	O
prev_attr	int
;	O
if	O
(	O
!	O
is_at_equiv	(int,int)->(int)
(	O
attr	int
[	O
from	int
]	O
,	O
prev_attr	int
)	O
&&	O
!	O
is_at_equiv	(int,int)->(int)
(	O
attr	int
[	O
from	int
]	O
,	O
next_attr	int
)	O
)	O
{	O
width	int
+=	O
attr_swidth	(int)->(int)
(	O
attr	int
[	O
from	int
]	O
)	O
;	O
if	O
(	O
from	int
+	O
len	int
<	O
curr	int
)	O
width	int
+=	O
attr_ewidth	(int)->(int)
(	O
attr	int
[	O
from	int
]	O
)	O
;	O
if	O
(	O
is_at_equiv	(int,int)->(int)
(	O
prev_attr	int
,	O
next_attr	int
)	O
)	O
{	O
width	int
+=	O
attr_ewidth	(int)->(int)
(	O
prev_attr	int
)	O
;	O
if	O
(	O
from	int
+	O
len	int
<	O
curr	int
)	O
width	int
+=	O
attr_swidth	(int)->(int)
(	O
next_attr	int
)	O
;	O
}	O
}	O
if	O
(	O
shift	int
-	O
shifted	int
<	O
width	int
)	O
break	O
;	O
from	int
+=	O
len	int
;	O
shifted	int
+=	O
width	int
;	O
if	O
(	O
shifted	int
<	O
0	int
)	O
shifted	int
=	O
0	int
;	O
}	O
while	O
(	O
from	int
<	O
curr	int
)	O
{	O
linebuf	*(char)
[	O
to	int
]	O
=	O
linebuf	*(char)
[	O
from	int
]	O
;	O
attr	int
[	O
to	int
++	O
]	O
=	O
attr	int
[	O
from	int
++	O
]	O
;	O
}	O
curr	int
=	O
to	int
;	O
column	int
-=	O
shifted	int
;	O
cshift	int
+=	O
shifted	int
;	O
}	O
public	O
void	O
pshift_all	()->(void)
(	O
)	O
{	O
pshift	(int)->(void)
(	O
column	int
)	O
;	O
}	O
static	O
int	O
attr_swidth	(int)->(int)
(	O
a	int
)	O
int	O
a	int
;	O
{	O
int	O
w	int
=	O
0	int
;	O
a	int
=	O
apply_at_specials	(int)->(int)
(	O
a	int
)	O
;	O
if	O
(	O
a	int
&	O
AT_UNDERLINE	O
)	O
w	int
+=	O
ul_s_width	int
;	O
if	O
(	O
a	int
&	O
AT_BOLD	O
)	O
w	int
+=	O
bo_s_width	int
;	O
if	O
(	O
a	int
&	O
AT_BLINK	O
)	O
w	int
+=	O
bl_s_width	int
;	O
if	O
(	O
a	int
&	O
AT_STANDOUT	O
)	O
w	int
+=	O
so_s_width	int
;	O
return	O
w	int
;	O
}	O
static	O
int	O
attr_ewidth	(int)->(int)
(	O
a	int
)	O
int	O
a	int
;	O
{	O
int	O
w	int
=	O
0	int
;	O
a	int
=	O
apply_at_specials	(int)->(int)
(	O
a	int
)	O
;	O
if	O
(	O
a	int
&	O
AT_UNDERLINE	O
)	O
w	int
+=	O
ul_e_width	int
;	O
if	O
(	O
a	int
&	O
AT_BOLD	O
)	O
w	int
+=	O
bo_e_width	int
;	O
if	O
(	O
a	int
&	O
AT_BLINK	O
)	O
w	int
+=	O
bl_e_width	int
;	O
if	O
(	O
a	int
&	O
AT_STANDOUT	O
)	O
w	int
+=	O
so_e_width	int
;	O
return	O
w	int
;	O
}	O
static	O
int	O
pwidth	(long,int,long)->(int)
(	O
ch	long
,	O
a	int
,	O
prev_ch	long
)	O
LWCHAR	long
ch	long
;	O
int	O
a	int
;	O
LWCHAR	long
prev_ch	long
;	O
{	O
int	O
w	int
;	O
if	O
(	O
ch	long
==	O
'\b'	O
)	O
return	O
(	O
utf_mode	int
&&	O
is_wide_char	(long)->(int)
(	O
prev_ch	long
)	O
)	O
?	O
-	O
2	int
:	O
-	O
1	int
;	O
if	O
(	O
!	O
utf_mode	int
||	O
is_ascii_char	(long)->(int)
(	O
ch	long
)	O
)	O
{	O
if	O
(	O
control_char	(long)->(int)
(	O
(	O
char	O
)	O
ch	long
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_composing_char	(long)->(int)
(	O
ch	long
)	O
||	O
is_combining_char	(long,long)->(int)
(	O
prev_ch	long
,	O
ch	long
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
w	int
=	O
1	int
;	O
if	O
(	O
is_wide_char	(long)->(int)
(	O
ch	long
)	O
)	O
w	int
++	O
;	O
if	O
(	O
curr	int
>	O
0	int
&&	O
!	O
is_at_equiv	(int,int)->(int)
(	O
attr	int
[	O
curr	int
-	O
1	int
]	O
,	O
a	int
)	O
)	O
w	int
+=	O
attr_ewidth	(int)->(int)
(	O
attr	int
[	O
curr	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
apply_at_specials	(int)->(int)
(	O
a	int
)	O
!=	O
AT_NORMAL	O
)	O
&&	O
(	O
curr	int
==	O
0	int
||	O
!	O
is_at_equiv	(int,int)->(int)
(	O
attr	int
[	O
curr	int
-	O
1	int
]	O
,	O
a	int
)	O
)	O
)	O
w	int
+=	O
attr_swidth	(int)->(int)
(	O
a	int
)	O
;	O
return	O
(	O
w	int
)	O
;	O
}	O
static	O
int	O
backc	()->(int)
(	O
)	O
{	O
LWCHAR	long
prev_ch	long
;	O
char	O
*	O
p	*(char)
=	O
linebuf	*(char)
+	O
curr	int
;	O
LWCHAR	long
ch	long
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
&	O
p	*(char)
,	O
-	O
1	int
,	O
linebuf	*(char)
+	O
lmargin	int
)	O
;	O
int	O
width	int
;	O
while	O
(	O
curr	int
>	O
lmargin	int
&&	O
column	int
>	O
lmargin	int
&&	O
(	O
!	O
(	O
attr	int
[	O
curr	int
-	O
1	int
]	O
&	O
(	O
AT_ANSI	O
|	O
AT_BINARY	O
)	O
)	O
)	O
)	O
{	O
curr	int
=	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
linebuf	*(char)
)	O
;	O
prev_ch	long
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
&	O
p	*(char)
,	O
-	O
1	int
,	O
linebuf	*(char)
+	O
lmargin	int
)	O
;	O
width	int
=	O
pwidth	(long,int,long)->(int)
(	O
ch	long
,	O
attr	int
[	O
curr	int
]	O
,	O
prev_ch	long
)	O
;	O
column	int
-=	O
width	int
;	O
if	O
(	O
width	int
>	O
0	int
)	O
return	O
1	int
;	O
ch	long
=	O
prev_ch	long
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
in_ansi_esc_seq	()->(int)
(	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
&	O
linebuf	*(char)
[	O
curr	int
]	O
;	O
p	*(char)
>	O
linebuf	*(char)
;	O
)	O
{	O
LWCHAR	long
ch	long
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
&	O
p	*(char)
,	O
-	O
1	int
,	O
linebuf	*(char)
)	O
;	O
if	O
(	O
IS_CSI_START	O
(	O
ch	long
)	O
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
!	O
is_ansi_middle	(long)->(int)
(	O
ch	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
int	O
is_ansi_end	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
if	O
(	O
!	O
is_ascii_char	(long)->(int)
(	O
ch	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
strchr	(*(char),int)->(*(char))
(	O
end_ansi_chars	*(char)
,	O
(	O
char	O
)	O
ch	long
)	O
!=	O
NULL	O
)	O
;	O
}	O
public	O
int	O
is_ansi_middle	(long)->(int)
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
if	O
(	O
!	O
is_ascii_char	(long)->(int)
(	O
ch	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
is_ansi_end	(long)->(int)
(	O
ch	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
strchr	(*(char),int)->(*(char))
(	O
mid_ansi_chars	*(char)
,	O
(	O
char	O
)	O
ch	long
)	O
!=	O
NULL	O
)	O
;	O
}	O
public	O
void	O
skip_ansi	(*(*(char)),*(char))->(void)
(	O
pp	*(*(char))
,	O
limit	*(char)
)	O
char	O
*	O
*	O
pp	*(*(char))
;	O
constant	O
char	O
*	O
limit	*(char)
;	O
{	O
LWCHAR	long
c	int
;	O
do	O
{	O
c	int
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
pp	*(*(char))
,	O
+	O
1	int
,	O
limit	*(char)
)	O
;	O
}	O
while	O
(	O
*	O
pp	*(*(char))
<	O
limit	*(char)
&&	O
is_ansi_middle	(long)->(int)
(	O
c	int
)	O
)	O
;	O
}	O
static	O
int	O
store_char	(long,int,*(char),long)->(int)
(	O
ch	long
,	O
a	int
,	O
rep	*(char)
,	O
pos	long
)	O
LWCHAR	long
ch	long
;	O
int	O
a	int
;	O
char	O
*	O
rep	*(char)
;	O
POSITION	long
pos	long
;	O
{	O
int	O
w	int
;	O
int	O
replen	int
;	O
char	O
cs	char
;	O
w	int
=	O
(	O
a	int
&	O
(	O
AT_UNDERLINE	O
|	O
AT_BOLD	O
)	O
)	O
;	O
if	O
(	O
w	int
!=	O
AT_NORMAL	O
)	O
last_overstrike	int
=	O
w	int
;	O
{	O
int	O
matches	int
;	O
if	O
(	O
is_hilited	(long,long,int,*(int))->(int)
(	O
pos	long
,	O
pos	long
+	O
1	int
,	O
0	int
,	O
&	O
matches	int
)	O
)	O
{	O
if	O
(	O
a	int
!=	O
AT_ANSI	O
)	O
{	O
if	O
(	O
highest_hilite	long
!=	O
NULL_POSITION	O
&&	O
pos	long
>	O
highest_hilite	long
)	O
highest_hilite	long
=	O
pos	long
;	O
a	int
|=	O
AT_HILITE	O
;	O
}	O
}	O
}	O
if	O
(	O
ctldisp	int
==	O
OPT_ONPLUS	int
&&	O
in_ansi_esc_seq	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
!	O
is_ansi_end	(long)->(int)
(	O
ch	long
)	O
&&	O
!	O
is_ansi_middle	(long)->(int)
(	O
ch	long
)	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
&	O
linebuf	*(char)
[	O
curr	int
]	O
;	O
LWCHAR	long
bch	long
;	O
do	O
{	O
bch	long
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
&	O
p	*(char)
,	O
-	O
1	int
,	O
linebuf	*(char)
)	O
;	O
}	O
while	O
(	O
p	*(char)
>	O
linebuf	*(char)
&&	O
!	O
IS_CSI_START	O
(	O
bch	long
)	O
)	O
;	O
curr	int
=	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
linebuf	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
a	int
=	O
AT_ANSI	O
;	O
w	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ctldisp	int
==	O
OPT_ONPLUS	int
&&	O
IS_CSI_START	O
(	O
ch	long
)	O
)	O
{	O
a	int
=	O
AT_ANSI	O
;	O
w	int
=	O
0	int
;	O
}	O
else	O
{	O
char	O
*	O
p	*(char)
=	O
&	O
linebuf	*(char)
[	O
curr	int
]	O
;	O
LWCHAR	long
prev_ch	long
=	O
step_char	(*(*(char)),int,*(char))->(long)
(	O
&	O
p	*(char)
,	O
-	O
1	int
,	O
linebuf	*(char)
)	O
;	O
w	int
=	O
pwidth	(long,int,long)->(int)
(	O
ch	long
,	O
a	int
,	O
prev_ch	long
)	O
;	O
}	O
if	O
(	O
ctldisp	int
!=	O
OPT_ON	int
&&	O
column	int
+	O
w	int
+	O
attr_ewidth	(int)->(int)
(	O
a	int
)	O
>	O
sc_width	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
rep	*(char)
==	O
NULL	O
)	O
{	O
cs	char
=	O
(	O
char	O
)	O
ch	long
;	O
rep	*(char)
=	O
&	O
cs	char
;	O
replen	int
=	O
1	int
;	O
}	O
else	O
{	O
replen	int
=	O
utf_len	(char)->(int)
(	O
rep	*(char)
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
curr	int
+	O
replen	int
>=	O
size_linebuf	int
-	O
6	int
)	O
{	O
if	O
(	O
expand_linebuf	()->(int)
(	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
column	int
>	O
right_column	int
&&	O
w	int
>	O
0	int
)	O
{	O
right_column	int
=	O
column	int
;	O
right_curr	int
=	O
curr	int
;	O
}	O
while	O
(	O
replen	int
--	O
>	O
0	int
)	O
{	O
add_linebuf	(long,int,int)->(void)
(	O
*	O
rep	*(char)
++	O
,	O
a	int
,	O
0	int
)	O
;	O
}	O
column	int
+=	O
w	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
store_tab	(int,long)->(int)
(	O
attr	int
,	O
pos	long
)	O
int	O
attr	int
;	O
POSITION	long
pos	long
;	O
{	O
int	O
to_tab	int
=	O
column	int
+	O
cshift	int
-	O
lmargin	int
;	O
int	O
i	int
;	O
if	O
(	O
ntabstops	int
<	O
2	int
||	O
to_tab	int
>=	O
tabstops	array(int)
[	O
ntabstops	int
-	O
1	int
]	O
)	O
to_tab	int
=	O
tabdefault	int
-	O
(	O
(	O
to_tab	int
-	O
tabstops	array(int)
[	O
ntabstops	int
-	O
1	int
]	O
)	O
%	O
tabdefault	int
)	O
;	O
else	O
{	O
for	O
(	O
i	int
=	O
ntabstops	int
-	O
2	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
to_tab	int
>=	O
tabstops	array(int)
[	O
i	int
]	O
)	O
break	O
;	O
to_tab	int
=	O
tabstops	array(int)
[	O
i	int
+	O
1	int
]	O
-	O
to_tab	int
;	O
}	O
if	O
(	O
column	int
+	O
to_tab	int
-	O
1	int
+	O
pwidth	(long,int,long)->(int)
(	O
' '	O
,	O
attr	int
,	O
0	int
)	O
+	O
attr_ewidth	(int)->(int)
(	O
attr	int
)	O
>	O
sc_width	int
)	O
return	O
1	int
;	O
do	O
{	O
STORE_CHAR	O
(	O
' '	O
,	O
attr	int
,	O
" "	*(char)
,	O
pos	long
)	O
;	O
}	O
while	O
(	O
--	O
to_tab	int
>	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
store_prchar	(long,long)->(int)
(	O
c	int
,	O
pos	long
)	O
LWCHAR	long
c	int
;	O
POSITION	long
pos	long
;	O
{	O
char	O
*	O
s	*(char)
;	O
s	*(char)
=	O
prchar	(long)->(*(char))
(	O
c	int
)	O
;	O
if	O
(	O
column	int
+	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
-	O
1	int
+	O
pwidth	(long,int,long)->(int)
(	O
' '	O
,	O
binattr	int
,	O
0	int
)	O
+	O
attr_ewidth	(int)->(int)
(	O
binattr	int
)	O
>	O
sc_width	int
)	O
return	O
1	int
;	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
0	int
;	O
s	*(char)
++	O
)	O
STORE_CHAR	O
(	O
*	O
s	*(char)
,	O
AT_BINARY	O
,	O
NULL	O
,	O
pos	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
flush_mbc_buf	(long)->(int)
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mbc_buf_index	int
;	O
i	int
++	O
)	O
if	O
(	O
store_prchar	(long,long)->(int)
(	O
mbc_buf	array(char)
[	O
i	int
]	O
,	O
pos	long
)	O
)	O
return	O
mbc_buf_index	int
-	O
i	int
;	O
return	O
0	int
;	O
}	O
public	O
int	O
pappend	(char,long)->(int)
(	O
c	int
,	O
pos	long
)	O
unsigned	O
char	O
c	int
;	O
POSITION	long
pos	long
;	O
{	O
int	O
r	int
;	O
if	O
(	O
pendc	long
)	O
{	O
if	O
(	O
c	int
==	O
'\r'	O
&&	O
pendc	long
==	O
'\r'	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
do_append	(long,*(char),long)->(int)
(	O
pendc	long
,	O
NULL	O
,	O
pendpos	long
)	O
)	O
return	O
(	O
1	int
)	O
;	O
pendc	long
=	O
'\0'	O
;	O
}	O
if	O
(	O
c	int
==	O
'\r'	O
&&	O
bs_mode	int
==	O
BS_SPECIAL	int
)	O
{	O
if	O
(	O
mbc_buf_len	int
>	O
0	int
)	O
{	O
r	int
=	O
flush_mbc_buf	(long)->(int)
(	O
mbc_pos	long
)	O
;	O
mbc_buf_index	int
=	O
r	int
+	O
1	int
;	O
mbc_buf_len	int
=	O
0	int
;	O
if	O
(	O
r	int
)	O
return	O
(	O
mbc_buf_index	int
)	O
;	O
}	O
pendc	long
=	O
c	int
;	O
pendpos	long
=	O
pos	long
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
utf_mode	int
)	O
{	O
r	int
=	O
do_append	(long,*(char),long)->(int)
(	O
c	int
,	O
NULL	O
,	O
pos	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mbc_buf_len	int
==	O
0	int
)	O
{	O
retry	O
:	O
mbc_buf_index	int
=	O
1	int
;	O
*	O
mbc_buf	array(char)
=	O
c	int
;	O
if	O
(	O
IS_ASCII_OCTET	O
(	O
c	int
)	O
)	O
r	int
=	O
do_append	(long,*(char),long)->(int)
(	O
c	int
,	O
NULL	O
,	O
pos	long
)	O
;	O
else	O
if	O
(	O
IS_UTF8_LEAD	O
(	O
c	int
)	O
)	O
{	O
mbc_buf_len	int
=	O
utf_len	(char)->(int)
(	O
c	int
)	O
;	O
mbc_pos	long
=	O
pos	long
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
flush_mbc_buf	(long)->(int)
(	O
pos	long
)	O
;	O
}	O
else	O
if	O
(	O
IS_UTF8_TRAIL	O
(	O
c	int
)	O
)	O
{	O
mbc_buf	array(char)
[	O
mbc_buf_index	int
++	O
]	O
=	O
c	int
;	O
if	O
(	O
mbc_buf_index	int
<	O
mbc_buf_len	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
is_utf8_well_formed	(*(char),int)->(int)
(	O
mbc_buf	array(char)
,	O
mbc_buf_index	int
)	O
)	O
r	int
=	O
do_append	(long,*(char),long)->(int)
(	O
get_wchar	(*(char))->(long)
(	O
mbc_buf	array(char)
)	O
,	O
mbc_buf	array(char)
,	O
mbc_pos	long
)	O
;	O
else	O
mbc_buf_index	int
=	O
r	int
=	O
flush_mbc_buf	(long)->(int)
(	O
mbc_pos	long
)	O
;	O
mbc_buf_len	int
=	O
0	int
;	O
}	O
else	O
{	O
r	int
=	O
flush_mbc_buf	(long)->(int)
(	O
mbc_pos	long
)	O
;	O
mbc_buf_index	int
=	O
r	int
+	O
1	int
;	O
mbc_buf_len	int
=	O
0	int
;	O
if	O
(	O
!	O
r	int
)	O
goto	O
retry	O
;	O
}	O
}	O
if	O
(	O
cshift	int
<	O
hshift	int
&&	O
column	int
>	O
sc_width	int
/	O
2	int
)	O
{	O
linebuf	*(char)
[	O
curr	int
]	O
=	O
'\0'	O
;	O
pshift	(int)->(void)
(	O
hshift	int
-	O
cshift	int
)	O
;	O
}	O
if	O
(	O
r	int
)	O
{	O
r	int
=	O
(	O
!	O
utf_mode	int
)	O
?	O
1	int
:	O
mbc_buf_index	int
;	O
}	O
return	O
(	O
r	int
)	O
;	O
}	O
static	O
int	O
do_append	(long,*(char),long)->(int)
(	O
ch	long
,	O
rep	*(char)
,	O
pos	long
)	O
LWCHAR	long
ch	long
;	O
char	O
*	O
rep	*(char)
;	O
POSITION	long
pos	long
;	O
{	O
int	O
a	int
;	O
LWCHAR	long
prev_ch	long
;	O
a	int
=	O
AT_NORMAL	O
;	O
if	O
(	O
ch	long
==	O
'\b'	O
)	O
{	O
if	O
(	O
bs_mode	int
==	O
BS_CONTROL	int
)	O
goto	O
do_control_char	O
;	O
if	O
(	O
curr	int
<=	O
lmargin	int
||	O
column	int
<=	O
lmargin	int
||	O
(	O
attr	int
[	O
curr	int
-	O
1	int
]	O
&	O
(	O
AT_ANSI	O
|	O
AT_BINARY	O
)	O
)	O
)	O
STORE_PRCHAR	O
(	O
'\b'	O
,	O
pos	long
)	O
;	O
else	O
if	O
(	O
bs_mode	int
==	O
BS_NORMAL	int
)	O
STORE_CHAR	O
(	O
ch	long
,	O
AT_NORMAL	O
,	O
NULL	O
,	O
pos	long
)	O
;	O
else	O
if	O
(	O
bs_mode	int
==	O
BS_SPECIAL	int
)	O
overstrike	int
=	O
backc	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
overstrike	int
>	O
0	int
)	O
{	O
overstrike	int
=	O
utf_mode	int
?	O
-	O
1	int
:	O
0	int
;	O
if	O
(	O
utf_mode	int
)	O
{	O
prev_ch	long
=	O
get_wchar	(*(char))->(long)
(	O
linebuf	*(char)
+	O
curr	int
)	O
;	O
}	O
else	O
{	O
prev_ch	long
=	O
(	O
unsigned	O
char	O
)	O
linebuf	*(char)
[	O
curr	int
]	O
;	O
}	O
a	int
=	O
attr	int
[	O
curr	int
]	O
;	O
if	O
(	O
ch	long
==	O
prev_ch	long
)	O
{	O
if	O
(	O
ch	long
==	O
'_'	O
)	O
{	O
if	O
(	O
(	O
a	int
&	O
(	O
AT_BOLD	O
|	O
AT_UNDERLINE	O
)	O
)	O
!=	O
AT_NORMAL	O
)	O
a	int
|=	O
(	O
AT_BOLD	O
|	O
AT_UNDERLINE	O
)	O
;	O
else	O
if	O
(	O
last_overstrike	int
!=	O
AT_NORMAL	O
)	O
a	int
|=	O
last_overstrike	int
;	O
else	O
a	int
|=	O
AT_BOLD	O
;	O
}	O
else	O
a	int
|=	O
AT_BOLD	O
;	O
}	O
else	O
if	O
(	O
ch	long
==	O
'_'	O
)	O
{	O
a	int
|=	O
AT_UNDERLINE	O
;	O
ch	long
=	O
prev_ch	long
;	O
rep	*(char)
=	O
linebuf	*(char)
+	O
curr	int
;	O
}	O
else	O
if	O
(	O
prev_ch	long
==	O
'_'	O
)	O
{	O
a	int
|=	O
AT_UNDERLINE	O
;	O
}	O
}	O
else	O
if	O
(	O
overstrike	int
<	O
0	int
)	O
{	O
if	O
(	O
is_composing_char	(long)->(int)
(	O
ch	long
)	O
||	O
is_combining_char	(long,long)->(int)
(	O
get_wchar	(*(char))->(long)
(	O
linebuf	*(char)
+	O
curr	int
)	O
,	O
ch	long
)	O
)	O
a	int
=	O
last_overstrike	int
;	O
else	O
overstrike	int
=	O
0	int
;	O
}	O
if	O
(	O
ch	long
==	O
'\t'	O
)	O
{	O
switch	O
(	O
bs_mode	int
)	O
{	O
case	O
BS_CONTROL	int
:	O
goto	O
do_control_char	O
;	O
case	O
BS_NORMAL	int
:	O
case	O
BS_SPECIAL	int
:	O
STORE_TAB	O
(	O
a	int
,	O
pos	long
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
!	O
utf_mode	int
||	O
is_ascii_char	(long)->(int)
(	O
ch	long
)	O
)	O
&&	O
control_char	(long)->(int)
(	O
(	O
char	O
)	O
ch	long
)	O
)	O
{	O
do_control_char	O
:	O
if	O
(	O
ctldisp	int
==	O
OPT_ON	int
||	O
(	O
ctldisp	int
==	O
OPT_ONPLUS	int
&&	O
IS_CSI_START	O
(	O
ch	long
)	O
)	O
)	O
{	O
STORE_CHAR	O
(	O
ch	long
,	O
AT_NORMAL	O
,	O
rep	*(char)
,	O
pos	long
)	O
;	O
}	O
else	O
{	O
STORE_PRCHAR	O
(	O
(	O
char	O
)	O
ch	long
,	O
pos	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
utf_mode	int
&&	O
ctldisp	int
!=	O
OPT_ON	int
&&	O
is_ubin_char	(long)->(int)
(	O
ch	long
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
s	*(char)
=	O
prutfchar	(long)->(*(char))
(	O
ch	long
)	O
;	O
if	O
(	O
column	int
+	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
-	O
1	int
+	O
pwidth	(long,int,long)->(int)
(	O
' '	O
,	O
binattr	int
,	O
0	int
)	O
+	O
attr_ewidth	(int)->(int)
(	O
binattr	int
)	O
>	O
sc_width	int
)	O
return	O
(	O
1	int
)	O
;	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
0	int
;	O
s	*(char)
++	O
)	O
STORE_CHAR	O
(	O
*	O
s	*(char)
,	O
AT_BINARY	O
,	O
NULL	O
,	O
pos	long
)	O
;	O
}	O
else	O
{	O
STORE_CHAR	O
(	O
ch	long
,	O
a	int
,	O
rep	*(char)
,	O
pos	long
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
int	O
pflushmbc	()->(int)
(	O
)	O
{	O
int	O
r	int
=	O
0	int
;	O
if	O
(	O
mbc_buf_len	int
>	O
0	int
)	O
{	O
r	int
=	O
flush_mbc_buf	(long)->(int)
(	O
mbc_pos	long
)	O
;	O
mbc_buf_len	int
=	O
0	int
;	O
}	O
return	O
r	int
;	O
}	O
static	O
void	O
add_attr_normal	()->(void)
(	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
"\033[m"	*(char)
;	O
if	O
(	O
ctldisp	int
!=	O
OPT_ONPLUS	int
||	O
!	O
is_ansi_end	(long)->(int)
(	O
'm'	O
)	O
)	O
return	O
;	O
for	O
(	O
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
add_linebuf	(long,int,int)->(void)
(	O
*	O
p	*(char)
,	O
AT_ANSI	O
,	O
0	int
)	O
;	O
}	O
public	O
void	O
pdone	(int,int,int)->(void)
(	O
endline	int
,	O
chopped	int
,	O
forw	(int,long,int,int,int)->(void)
)	O
int	O
endline	int
;	O
int	O
chopped	int
;	O
int	O
forw	(int,long,int,int,int)->(void)
;	O
{	O
(	O
void	O
)	O
pflushmbc	()->(int)
(	O
)	O
;	O
if	O
(	O
pendc	long
&&	O
(	O
pendc	long
!=	O
'\r'	O
||	O
!	O
endline	int
)	O
)	O
(	O
void	O
)	O
do_append	(long,*(char),long)->(int)
(	O
pendc	long
,	O
NULL	O
,	O
pendpos	long
)	O
;	O
if	O
(	O
cshift	int
<	O
hshift	int
)	O
pshift	(int)->(void)
(	O
hshift	int
-	O
cshift	int
)	O
;	O
if	O
(	O
chopped	int
&&	O
rscroll_char	long
)	O
{	O
if	O
(	O
column	int
>=	O
sc_width	int
)	O
{	O
column	int
=	O
right_column	int
;	O
curr	int
=	O
right_curr	int
;	O
}	O
add_attr_normal	()->(void)
(	O
)	O
;	O
while	O
(	O
column	int
<	O
sc_width	int
-	O
1	int
)	O
{	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
}	O
add_linebuf	(long,int,int)->(void)
(	O
rscroll_char	long
,	O
rscroll_attr	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
add_attr_normal	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
column	int
<	O
sc_width	int
||	O
!	O
auto_wrap	int
||	O
(	O
endline	int
&&	O
ignaw	int
)	O
||	O
ctldisp	int
==	O
OPT_ON	int
)	O
{	O
add_linebuf	(long,int,int)->(void)
(	O
'\n'	O
,	O
AT_NORMAL	O
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
ignaw	int
&&	O
column	int
>=	O
sc_width	int
&&	O
forw	(int,long,int,int,int)->(void)
)	O
{	O
add_linebuf	(long,int,int)->(void)
(	O
' '	O
,	O
AT_NORMAL	O
,	O
1	int
)	O
;	O
add_linebuf	(long,int,int)->(void)
(	O
'\b'	O
,	O
AT_NORMAL	O
,	O
-	O
1	int
)	O
;	O
}	O
set_linebuf	(int,long,int)->(void)
(	O
curr	int
,	O
'\0'	O
,	O
AT_NORMAL	O
)	O
;	O
}	O
public	O
void	O
set_status_col	(char)->(void)
(	O
c	int
)	O
char	O
c	int
;	O
{	O
set_linebuf	(int,long,int)->(void)
(	O
0	int
,	O
c	int
,	O
AT_NORMAL	O
|	O
AT_HILITE	O
)	O
;	O
}	O
public	O
int	O
gline	(int,*(int))->(int)
(	O
i	int
,	O
ap	*(int)
)	O
int	O
i	int
;	O
int	O
*	O
ap	*(int)
;	O
{	O
if	O
(	O
is_null_line	int
)	O
{	O
if	O
(	O
twiddle	int
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
*	O
ap	*(int)
=	O
AT_BOLD	O
;	O
return	O
'~'	O
;	O
}	O
--	O
i	int
;	O
}	O
*	O
ap	*(int)
=	O
AT_NORMAL	O
;	O
return	O
i	int
?	O
'\0'	O
:	O
'\n'	O
;	O
}	O
*	O
ap	*(int)
=	O
attr	int
[	O
i	int
]	O
;	O
return	O
(	O
linebuf	*(char)
[	O
i	int
]	O
&	O
0xFF	int
)	O
;	O
}	O
public	O
void	O
null_line	()->(void)
(	O
)	O
{	O
is_null_line	int
=	O
1	int
;	O
cshift	int
=	O
0	int
;	O
}	O
public	O
POSITION	long
forw_raw_line	(long,*(*(char)),*(int))->(long)
(	O
curr_pos	long
,	O
linep	*(*(char))
,	O
line_lenp	*(int)
)	O
POSITION	long
curr_pos	long
;	O
char	O
*	O
*	O
linep	*(*(char))
;	O
int	O
*	O
line_lenp	*(int)
;	O
{	O
int	O
n	int
;	O
int	O
c	int
;	O
POSITION	long
new_pos	long
;	O
if	O
(	O
curr_pos	long
==	O
NULL_POSITION	O
||	O
ch_seek	(long)->(int)
(	O
curr_pos	long
)	O
||	O
(	O
c	int
=	O
ch_forw_get	()->(int)
(	O
)	O
)	O
==	O
EOI	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
n	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
EOI	O
||	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
new_pos	long
=	O
ch_tell	()->(long)
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
n	int
>=	O
size_linebuf	int
-	O
1	int
)	O
{	O
if	O
(	O
expand_linebuf	()->(int)
(	O
)	O
)	O
{	O
new_pos	long
=	O
ch_tell	()->(long)
(	O
)	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
linebuf	*(char)
[	O
n	int
++	O
]	O
=	O
c	int
;	O
c	int
=	O
ch_forw_get	()->(int)
(	O
)	O
;	O
}	O
linebuf	*(char)
[	O
n	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
linep	*(*(char))
!=	O
NULL	O
)	O
*	O
linep	*(*(char))
=	O
linebuf	*(char)
;	O
if	O
(	O
line_lenp	*(int)
!=	O
NULL	O
)	O
*	O
line_lenp	*(int)
=	O
n	int
;	O
return	O
(	O
new_pos	long
)	O
;	O
}	O
public	O
POSITION	long
back_raw_line	(long,*(*(char)),*(int))->(long)
(	O
curr_pos	long
,	O
linep	*(*(char))
,	O
line_lenp	*(int)
)	O
POSITION	long
curr_pos	long
;	O
char	O
*	O
*	O
linep	*(*(char))
;	O
int	O
*	O
line_lenp	*(int)
;	O
{	O
int	O
n	int
;	O
int	O
c	int
;	O
POSITION	long
new_pos	long
;	O
if	O
(	O
curr_pos	long
==	O
NULL_POSITION	O
||	O
curr_pos	long
<=	O
ch_zero	O
(	O
)	O
||	O
ch_seek	(long)->(int)
(	O
curr_pos	long
-	O
1	int
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
n	int
=	O
size_linebuf	int
;	O
linebuf	*(char)
[	O
--	O
n	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
ch_back_get	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
new_pos	long
=	O
ch_tell	()->(long)
(	O
)	O
+	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
EOI	O
)	O
{	O
new_pos	long
=	O
ch_zero	O
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
n	int
<=	O
0	int
)	O
{	O
int	O
old_size_linebuf	int
=	O
size_linebuf	int
;	O
char	O
*	O
fm	*(char)
;	O
char	O
*	O
to	int
;	O
if	O
(	O
expand_linebuf	()->(int)
(	O
)	O
)	O
{	O
new_pos	long
=	O
ch_tell	()->(long)
(	O
)	O
+	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
fm	*(char)
=	O
linebuf	*(char)
+	O
old_size_linebuf	int
-	O
1	int
,	O
to	int
=	O
linebuf	*(char)
+	O
size_linebuf	int
-	O
1	int
;	O
fm	*(char)
>=	O
linebuf	*(char)
;	O
fm	*(char)
--	O
,	O
to	int
--	O
)	O
*	O
to	int
=	O
*	O
fm	*(char)
;	O
n	int
=	O
size_linebuf	int
-	O
old_size_linebuf	int
;	O
}	O
linebuf	*(char)
[	O
--	O
n	int
]	O
=	O
c	int
;	O
}	O
if	O
(	O
linep	*(*(char))
!=	O
NULL	O
)	O
*	O
linep	*(*(char))
=	O
&	O
linebuf	*(char)
[	O
n	int
]	O
;	O
if	O
(	O
line_lenp	*(int)
!=	O
NULL	O
)	O
*	O
line_lenp	*(int)
=	O
size_linebuf	int
-	O
1	int
-	O
n	int
;	O
return	O
(	O
new_pos	long
)	O
;	O
}	O
public	O
int	O
rrshift	()->(int)
(	O
)	O
{	O
POSITION	long
pos	long
;	O
int	O
save_width	int
;	O
int	O
line	*(char)
;	O
int	O
longest	int
=	O
0	int
;	O
save_width	int
=	O
sc_width	int
;	O
sc_width	int
=	O
INT_MAX	O
;	O
hshift	int
=	O
0	int
;	O
pos	long
=	O
position	(int)->(long)
(	O
TOP	O
)	O
;	O
for	O
(	O
line	*(char)
=	O
0	int
;	O
line	*(char)
<	O
sc_height	int
&&	O
pos	long
!=	O
NULL_POSITION	O
;	O
line	*(char)
++	O
)	O
{	O
pos	long
=	O
forw_line	(long)->(long)
(	O
pos	long
)	O
;	O
if	O
(	O
column	int
>	O
longest	int
)	O
longest	int
=	O
column	int
;	O
}	O
sc_width	int
=	O
save_width	int
;	O
if	O
(	O
longest	int
<	O
sc_width	int
)	O
return	O
0	int
;	O
return	O
longest	int
-	O
sc_width	int
;	O
}	O
