struct	O
inflate_codes_state	struct(int)
{	O
int	O
dummy	int
;	O
}	O
;	O
uInt	int
inflate_mask	array(int)
[	O
17	int
]	O
=	O
{	O
0x0000	int
,	O
0x0001	int
,	O
0x0003	int
,	O
0x0007	int
,	O
0x000f	int
,	O
0x001f	int
,	O
0x003f	int
,	O
0x007f	int
,	O
0x00ff	int
,	O
0x01ff	int
,	O
0x03ff	int
,	O
0x07ff	int
,	O
0x0fff	int
,	O
0x1fff	int
,	O
0x3fff	int
,	O
0x7fff	int
,	O
0xffff	int
}	O
;	O
int	O
inflate_flush	(*(struct(enum(int,int,int,int,int,int,int,int,int,int),union(int,struct(int,int,*`,int,*`),struct(*`)),int,int,long,*(struct(union`,int)),*(char),*(char),*(char),*(char),*((long,*`,int)->(long)),long)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
r	int
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
int	O
r	int
;	O
{	O
uInt	int
n	int
;	O
Bytef	char
*	O
p	*(char)
;	O
Bytef	char
*	O
q	*(char)
;	O
p	*(char)
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_out	*(char)
;	O
q	*(char)
=	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
;	O
n	int
=	O
(	O
uInt	int
)	O
(	O
(	O
q	*(char)
<=	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
?	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
:	O
s	*(char)
->	O
end	*(char)
)	O
-	O
q	*(char)
)	O
;	O
if	O
(	O
n	int
>	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
)	O
n	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
;	O
if	O
(	O
n	int
&&	O
r	int
==	O
Z_BUF_ERROR	O
)	O
r	int
=	O
Z_OK	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
-=	O
n	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
+=	O
n	int
;	O
if	O
(	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
!=	O
Z_NULL	int
)	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
=	O
s	*(char)
->	O
check	long
=	O
(	O
*	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
)	O
(	O
s	*(char)
->	O
check	long
,	O
q	*(char)
,	O
n	int
)	O
;	O
zmemcpy	O
(	O
p	*(char)
,	O
q	*(char)
,	O
n	int
)	O
;	O
p	*(char)
+=	O
n	int
;	O
q	*(char)
+=	O
n	int
;	O
if	O
(	O
q	*(char)
==	O
s	*(char)
->	O
end	*(char)
)	O
{	O
q	*(char)
=	O
s	*(char)
->	O
window	*(char)
;	O
if	O
(	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
==	O
s	*(char)
->	O
end	*(char)
)	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
=	O
s	*(char)
->	O
window	*(char)
;	O
n	int
=	O
(	O
uInt	int
)	O
(	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
-	O
q	*(char)
)	O
;	O
if	O
(	O
n	int
>	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
)	O
n	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
;	O
if	O
(	O
n	int
&&	O
r	int
==	O
Z_BUF_ERROR	O
)	O
r	int
=	O
Z_OK	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
-=	O
n	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
+=	O
n	int
;	O
if	O
(	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
!=	O
Z_NULL	int
)	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
=	O
s	*(char)
->	O
check	long
=	O
(	O
*	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
)	O
(	O
s	*(char)
->	O
check	long
,	O
q	*(char)
,	O
n	int
)	O
;	O
zmemcpy	O
(	O
p	*(char)
,	O
q	*(char)
,	O
n	int
)	O
;	O
p	*(char)
+=	O
n	int
;	O
q	*(char)
+=	O
n	int
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_out	*(char)
=	O
p	*(char)
;	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
=	O
q	*(char)
;	O
return	O
r	int
;	O
}	O
