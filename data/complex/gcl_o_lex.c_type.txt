object	O
assoc_eq	(int,int)->(int)
(	O
object	O
key	int
,	O
object	O
alist	int
)	O
{	O
while	O
(	O
!	O
endp	()->(int)
(	O
alist	int
)	O
)	O
{	O
if	O
(	O
MMcaar	()->(int)
(	O
alist	int
)	O
==	O
key	int
)	O
return	O
(	O
MMcar	()->(int)
(	O
alist	int
)	O
)	O
;	O
alist	int
=	O
MMcdr	()->(int)
(	O
alist	int
)	O
;	O
}	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
void	O
lex_fun_bind	(int,int)->(void)
(	O
object	O
name	int
,	O
object	O
fun	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
make_cons	()->(int)
(	O
fun	int
,	O
Cnil	O
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
sLfunction	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
name	int
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
[	O
1	int
]	O
=	O
make_cons	()->(int)
(	O
top	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
1	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
void	O
lex_macro_bind	(int,int)->(void)
(	O
object	O
name	int
,	O
object	O
exp_fun	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
make_cons	()->(int)
(	O
exp_fun	int
,	O
Cnil	O
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
sLmacro	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
name	int
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
[	O
1	int
]	O
=	O
make_cons	()->(int)
(	O
top	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
1	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
void	O
lex_tag_bind	(int,int)->(void)
(	O
object	O
tag	int
,	O
object	O
id	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
make_cons	()->(int)
(	O
id	int
,	O
Cnil	O
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
sLtag	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
tag	int
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
[	O
2	int
]	O
=	O
make_cons	()->(int)
(	O
top	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
2	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
void	O
lex_block_bind	(int,int)->(void)
(	O
object	O
name	int
,	O
object	O
id	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
make_cons	()->(int)
(	O
id	int
,	O
Cnil	O
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
sLblock	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
make_cons	()->(int)
(	O
name	int
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
[	O
2	int
]	O
=	O
make_cons	()->(int)
(	O
top	O
[	O
0	int
]	O
,	O
lex_env	O
[	O
2	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
object	O
lex_tag_sch	(int)->(int)
(	O
object	O
tag	int
)	O
{	O
object	O
alist	int
=	O
lex_env	O
[	O
2	int
]	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
alist	int
)	O
)	O
{	O
if	O
(	O
eql	()->(int)
(	O
MMcaar	()->(int)
(	O
alist	int
)	O
,	O
tag	int
)	O
&&	O
MMcadar	()->(int)
(	O
alist	int
)	O
==	O
sLtag	O
)	O
return	O
(	O
MMcar	()->(int)
(	O
alist	int
)	O
)	O
;	O
alist	int
=	O
MMcdr	()->(int)
(	O
alist	int
)	O
;	O
}	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
object	O
lex_block_sch	(int)->(int)
(	O
object	O
name	int
)	O
{	O
object	O
alist	int
=	O
lex_env	O
[	O
2	int
]	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
alist	int
)	O
)	O
{	O
if	O
(	O
MMcaar	()->(int)
(	O
alist	int
)	O
==	O
name	int
&&	O
MMcadar	()->(int)
(	O
alist	int
)	O
==	O
sLblock	O
)	O
return	O
(	O
MMcar	()->(int)
(	O
alist	int
)	O
)	O
;	O
alist	int
=	O
MMcdr	()->(int)
(	O
alist	int
)	O
;	O
}	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
void	O
gcl_init_lex	()->(void)
(	O
void	O
)	O
{	O
sLmacro	O
=	O
make_ordinary	()->(int)
(	O
"MACRO"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
sLmacro	O
)	O
;	O
sLtag	O
=	O
make_ordinary	()->(int)
(	O
"TAG"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
sLtag	O
)	O
;	O
sLblock	O
=	O
make_ordinary	()->(int)
(	O
"BLOCK"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
sLblock	O
)	O
;	O
}	O
