void	O
_matrix_product	(array(double),array(double),array(double))->(void)
(	O
const	O
double	O
m	array(double)
[	O
6	int
]	O
,	O
const	O
double	O
n	array(double)
[	O
6	int
]	O
,	O
double	O
product	array(double)
[	O
6	int
]	O
)	O
{	O
double	O
local_product	array(double)
[	O
6	int
]	O
;	O
local_product	array(double)
[	O
0	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
n	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
n	array(double)
[	O
2	int
]	O
;	O
local_product	array(double)
[	O
1	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
n	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
n	array(double)
[	O
3	int
]	O
;	O
local_product	array(double)
[	O
2	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
n	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
n	array(double)
[	O
2	int
]	O
;	O
local_product	array(double)
[	O
3	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
n	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
n	array(double)
[	O
3	int
]	O
;	O
local_product	array(double)
[	O
4	int
]	O
=	O
m	array(double)
[	O
4	int
]	O
*	O
n	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
5	int
]	O
*	O
n	array(double)
[	O
2	int
]	O
+	O
n	array(double)
[	O
4	int
]	O
;	O
local_product	array(double)
[	O
5	int
]	O
=	O
m	array(double)
[	O
4	int
]	O
*	O
n	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
5	int
]	O
*	O
n	array(double)
[	O
3	int
]	O
+	O
n	array(double)
[	O
5	int
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
product	array(double)
,	O
local_product	array(double)
,	O
6	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
return	O
;	O
}	O
void	O
_matrix_inverse	(array(double),array(double))->(void)
(	O
const	O
double	O
m	array(double)
[	O
6	int
]	O
,	O
double	O
inverse	array(double)
[	O
6	int
]	O
)	O
{	O
double	O
det	double
=	O
m	array(double)
[	O
0	int
]	O
*	O
m	array(double)
[	O
3	int
]	O
-	O
m	array(double)
[	O
1	int
]	O
*	O
m	array(double)
[	O
2	int
]	O
;	O
if	O
(	O
det	double
==	O
0.0	int
)	O
inverse	array(double)
[	O
0	int
]	O
=	O
inverse	array(double)
[	O
1	int
]	O
=	O
inverse	array(double)
[	O
2	int
]	O
=	O
inverse	array(double)
[	O
3	int
]	O
=	O
inverse	array(double)
[	O
4	int
]	O
=	O
inverse	array(double)
[	O
5	int
]	O
=	O
0.0	int
;	O
else	O
{	O
double	O
invdet	double
=	O
1.0	int
/	O
det	double
;	O
inverse	array(double)
[	O
0	int
]	O
=	O
invdet	double
*	O
m	array(double)
[	O
3	int
]	O
;	O
inverse	array(double)
[	O
1	int
]	O
=	O
-	O
invdet	double
*	O
m	array(double)
[	O
1	int
]	O
;	O
inverse	array(double)
[	O
2	int
]	O
=	O
-	O
invdet	double
*	O
m	array(double)
[	O
2	int
]	O
;	O
inverse	array(double)
[	O
3	int
]	O
=	O
invdet	double
*	O
m	array(double)
[	O
0	int
]	O
;	O
inverse	array(double)
[	O
4	int
]	O
=	O
invdet	double
*	O
(	O
m	array(double)
[	O
2	int
]	O
*	O
m	array(double)
[	O
5	int
]	O
-	O
m	array(double)
[	O
3	int
]	O
*	O
m	array(double)
[	O
4	int
]	O
)	O
;	O
inverse	array(double)
[	O
5	int
]	O
=	O
invdet	double
*	O
(	O
m	array(double)
[	O
1	int
]	O
*	O
m	array(double)
[	O
4	int
]	O
-	O
m	array(double)
[	O
0	int
]	O
*	O
m	array(double)
[	O
5	int
]	O
)	O
;	O
}	O
}	O
double	O
_matrix_norm	(array(double))->(double)
(	O
const	O
double	O
m	array(double)
[	O
6	int
]	O
)	O
{	O
double	O
mt	array(double)
[	O
4	int
]	O
,	O
pm	array(double)
[	O
4	int
]	O
;	O
double	O
norm1	double
,	O
norm2	double
;	O
double	O
a	array(double)
[	O
4	int
]	O
;	O
int	O
i	int
;	O
mt	array(double)
[	O
0	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
;	O
mt	array(double)
[	O
1	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
;	O
mt	array(double)
[	O
2	int
]	O
=	O
m	array(double)
[	O
1	int
]	O
;	O
mt	array(double)
[	O
3	int
]	O
=	O
m	array(double)
[	O
3	int
]	O
;	O
pm	array(double)
[	O
0	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
mt	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
mt	array(double)
[	O
2	int
]	O
;	O
pm	array(double)
[	O
1	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
mt	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
mt	array(double)
[	O
3	int
]	O
;	O
pm	array(double)
[	O
2	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
mt	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
mt	array(double)
[	O
2	int
]	O
;	O
pm	array(double)
[	O
3	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
mt	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
mt	array(double)
[	O
3	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
a	array(double)
[	O
i	int
]	O
=	O
fabs	(double)->(double)
(	O
pm	array(double)
[	O
i	int
]	O
)	O
;	O
norm1	double
=	O
DMAX	O
(	O
a	array(double)
[	O
0	int
]	O
+	O
a	array(double)
[	O
1	int
]	O
,	O
a	array(double)
[	O
2	int
]	O
+	O
a	array(double)
[	O
3	int
]	O
)	O
;	O
norm2	double
=	O
DMAX	O
(	O
a	array(double)
[	O
0	int
]	O
+	O
a	array(double)
[	O
2	int
]	O
,	O
a	array(double)
[	O
1	int
]	O
+	O
a	array(double)
[	O
3	int
]	O
)	O
;	O
return	O
sqrt	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
norm1	double
*	O
norm2	double
)	O
)	O
;	O
}	O
void	O
_matrix_sing_vals	(array(double),*(double),*(double))->(void)
(	O
const	O
double	O
m	array(double)
[	O
6	int
]	O
,	O
double	O
*	O
min_sing_val	*(double)
,	O
double	O
*	O
max_sing_val	*(double)
)	O
{	O
double	O
mt	array(double)
[	O
4	int
]	O
,	O
pm	array(double)
[	O
4	int
]	O
;	O
double	O
trace	double
,	O
det	double
,	O
disc	double
,	O
sqrtdisc	double
;	O
double	O
s1	double
,	O
s2	double
;	O
mt	array(double)
[	O
0	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
;	O
mt	array(double)
[	O
1	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
;	O
mt	array(double)
[	O
2	int
]	O
=	O
m	array(double)
[	O
1	int
]	O
;	O
mt	array(double)
[	O
3	int
]	O
=	O
m	array(double)
[	O
3	int
]	O
;	O
pm	array(double)
[	O
0	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
mt	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
mt	array(double)
[	O
2	int
]	O
;	O
pm	array(double)
[	O
1	int
]	O
=	O
m	array(double)
[	O
0	int
]	O
*	O
mt	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
1	int
]	O
*	O
mt	array(double)
[	O
3	int
]	O
;	O
pm	array(double)
[	O
2	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
mt	array(double)
[	O
0	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
mt	array(double)
[	O
2	int
]	O
;	O
pm	array(double)
[	O
3	int
]	O
=	O
m	array(double)
[	O
2	int
]	O
*	O
mt	array(double)
[	O
1	int
]	O
+	O
m	array(double)
[	O
3	int
]	O
*	O
mt	array(double)
[	O
3	int
]	O
;	O
trace	double
=	O
pm	array(double)
[	O
0	int
]	O
+	O
pm	array(double)
[	O
3	int
]	O
;	O
det	double
=	O
pm	array(double)
[	O
0	int
]	O
*	O
pm	array(double)
[	O
3	int
]	O
-	O
pm	array(double)
[	O
1	int
]	O
*	O
pm	array(double)
[	O
2	int
]	O
;	O
disc	double
=	O
trace	double
*	O
trace	double
-	O
4.0	int
*	O
det	double
;	O
disc	double
=	O
DMAX	O
(	O
0.0	int
,	O
disc	double
)	O
;	O
sqrtdisc	double
=	O
sqrt	(double)->(double)
(	O
disc	double
)	O
;	O
s1	double
=	O
0.5	int
*	O
(	O
trace	double
-	O
sqrtdisc	double
)	O
;	O
s2	double
=	O
0.5	int
*	O
(	O
trace	double
+	O
sqrtdisc	double
)	O
;	O
s1	double
=	O
DMAX	O
(	O
0.0	int
,	O
s1	double
)	O
;	O
s2	double
=	O
DMAX	O
(	O
0.0	int
,	O
s2	double
)	O
;	O
*	O
min_sing_val	*(double)
=	O
sqrt	(double)->(double)
(	O
s1	double
)	O
;	O
*	O
max_sing_val	*(double)
=	O
sqrt	(double)->(double)
(	O
s2	double
)	O
;	O
}	O
