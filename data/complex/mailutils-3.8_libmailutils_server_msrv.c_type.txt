typedef	O
RETSIGTYPE	void
(	O
*	O
mu_sig_handler_t	*((int)->(void))
)	O
(	O
int	O
)	O
;	O
static	O
mu_sig_handler_t	*((int)->(void))
set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
int	O
sig	int
,	O
mu_sig_handler_t	*((int)->(void))
handler	*((int)->(void))
)	O
{	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	enum(int,int,int,int,int)
,	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
act	enum(int,int,int,int,int)
.	O
sa_handler	*((int)->(void))
=	O
handler	*((int)->(void))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
act	enum(int,int,int,int,int)
.	O
sa_mask	struct(array(long))
)	O
;	O
act	enum(int,int,int,int,int)
.	O
sa_flags	int
=	O
0	int
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
act	enum(int,int,int,int,int)
,	O
&	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
return	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
;	O
}	O
}	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
{	O
char	O
*	O
ident	*(char)
;	O
int	O
deftype	int
;	O
mu_server_t	*(struct)
server	*(struct)
;	O
mu_list_t	*(struct)
srvlist	*(struct)
;	O
mu_m_server_preflight_fp	*((*(struct))->(int))
preflight	*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int))
;	O
mu_m_server_handler_fp	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
;	O
mu_m_server_handler_fp	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
;	O
void	O
*	O
data	*(void)
;	O
size_t	long
app_data_size	long
;	O
int	O
mode	int
;	O
int	O
foreground	int
;	O
size_t	long
max_children	long
;	O
size_t	long
num_children	long
;	O
pid_t	int
*	O
child_pid	*(int)
;	O
char	O
*	O
pidfile	*(char)
;	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
hints	*(struct(*(char),*(char)))
;	O
time_t	long
timeout	long
;	O
mu_acl_t	*(struct)
acl	*(struct)
;	O
sigset_t	struct(array(long))
sigmask	struct(array(long))
;	O
mu_sig_handler_t	*((int)->(void))
sigtab	array(*((int)->(void)))
[	O
NSIG	O
]	O
;	O
const	O
char	O
*	O
(	O
*	O
strexit	*((int)->(*(char)))
)	O
(	O
int	O
)	O
;	O
}	O
;	O
static	O
int	O
need_cleanup	int
=	O
0	int
;	O
static	O
int	O
stop	int
=	O
0	int
;	O
static	O
mu_list_t	*(struct)
m_server_list	*(struct)
;	O
static	O
void	O
alloc_children	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
)	O
{	O
int	O
i	int
;	O
size_t	long
size	long
=	O
srv	*(struct)
->	O
max_children	long
*	O
sizeof	O
(	O
srv	*(struct)
->	O
child_pid	*(int)
[	O
0	int
]	O
)	O
;	O
srv	*(struct)
->	O
child_pid	*(int)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
->	O
child_pid	*(int)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
srv	*(struct)
->	O
max_children	long
;	O
i	int
++	O
)	O
srv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
=	O
UNUSED_PID	O
;	O
}	O
static	O
void	O
register_child	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),int)->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
pid_t	int
pid	int
)	O
{	O
int	O
i	int
;	O
msrv	*(struct)
->	O
num_children	long
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	*(struct)
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
==	O
UNUSED_PID	O
)	O
{	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
=	O
pid	int
;	O
return	O
;	O
}	O
mu_error	(*(char))->(int)
(	O
"%s:%d: cannot find free PID slot (internal error?)"	*(char)
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
static	O
int	O
unregister_child	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),int)->(int)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
pid_t	int
pid	int
)	O
{	O
int	O
i	int
;	O
msrv	*(struct)
->	O
num_children	long
--	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	*(struct)
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
==	O
pid	int
)	O
{	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
=	O
UNUSED_PID	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
terminate_children	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
if	O
(	O
msrv	*(struct)
->	O
child_pid	*(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	*(struct)
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
!=	O
UNUSED_PID	O
)	O
kill	(int,int)->(int)
(	O
msrv	*(struct)
->	O
child_pid	*(int)
[	O
i	int
]	O
,	O
SIGTERM	int
)	O
;	O
}	O
}	O
void	O
mu_m_server_stop	(int)->(void)
(	O
int	O
code	int
)	O
{	O
stop	int
=	O
code	int
;	O
}	O
struct	O
exit_data	struct(int,int)
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
}	O
;	O
static	O
int	O
m_server_cleanup	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_m_server_t	*(struct)
msrv	*(struct)
=	O
item	*(void)
;	O
struct	O
exit_data	struct(int,int)
*	O
datp	*(struct(int,int))
=	O
data	*(void)
;	O
if	O
(	O
unregister_child	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),int)->(int)
(	O
msrv	*(struct)
,	O
datp	*(struct(int,int))
->	O
pid	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
datp	*(struct(int,int))
->	O
status	int
)	O
)	O
{	O
int	O
prio	int
=	O
MU_DIAG_INFO	O
;	O
int	O
code	int
=	O
WEXITSTATUS	O
(	O
datp	*(struct(int,int))
->	O
status	int
)	O
;	O
if	O
(	O
code	int
==	O
0	int
)	O
prio	int
=	O
MU_DIAG_DEBUG	O
;	O
if	O
(	O
msrv	*(struct)
->	O
strexit	*((int)->(*(char)))
)	O
mu_diag_output	(int,*(char))->(void)
(	O
prio	int
,	O
_	O
(	O
"process %lu finished with code %d (%s)"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
datp	*(struct(int,int))
->	O
pid	int
,	O
code	int
,	O
msrv	*(struct)
->	O
strexit	*((int)->(*(char)))
(	O
code	int
)	O
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
prio	int
,	O
_	O
(	O
"process %lu finished with code %d"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
datp	*(struct(int,int))
->	O
pid	int
,	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
datp	*(struct(int,int))
->	O
status	int
)	O
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERR	O
,	O
"process %lu terminated on signal %d"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
datp	*(struct(int,int))
->	O
pid	int
,	O
WTERMSIG	O
(	O
datp	*(struct(int,int))
->	O
status	int
)	O
)	O
;	O
else	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERR	O
,	O
"process %lu terminated (cause unknown)"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
datp	*(struct(int,int))
->	O
pid	int
)	O
;	O
return	O
MU_ERR_USER0	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
mu_m_server_idle	(*(void))->(int)
(	O
void	O
*	O
server_data	*(void)
MU_ARG_UNUSED	O
)	O
{	O
if	O
(	O
need_cleanup	int
)	O
{	O
struct	O
exit_data	struct(int,int)
ex	struct(int,int)
;	O
need_cleanup	int
=	O
0	int
;	O
while	O
(	O
(	O
ex	struct(int,int)
.	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
-	O
1	int
,	O
&	O
ex	struct(int,int)
.	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
m_server_list	*(struct)
,	O
m_server_cleanup	(*(void),*(void))->(int)
,	O
&	O
ex	struct(int,int)
)	O
;	O
}	O
return	O
stop	int
;	O
}	O
static	O
RETSIGTYPE	void
m_srv_signal	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
switch	O
(	O
signo	int
)	O
{	O
case	O
SIGCHLD	int
:	O
need_cleanup	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
stop	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
void	O
mu_m_server_create	(*(*(struct)),*(char))->(void)
(	O
mu_m_server_t	*(struct)
*	O
psrv	*(*(struct))
,	O
const	O
char	O
*	O
ident	*(char)
)	O
{	O
mu_m_server_t	*(struct)
srv	*(struct)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
srv	*(struct)
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ident	*(char)
)	O
{	O
srv	*(struct)
->	O
ident	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
ident	*(char)
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
->	O
ident	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
srv	*(struct)
->	O
deftype	int
=	O
MU_IP_TCP	int
;	O
MU_ASSERT	O
(	O
mu_server_create	(*(*(struct)))->(int)
(	O
&	O
srv	*(struct)
->	O
server	*(struct)
)	O
)	O
;	O
mu_server_set_idle	(*(struct),*((*(void))->(int)))->(int)
(	O
srv	*(struct)
->	O
server	*(struct)
,	O
mu_m_server_idle	(*(void))->(int)
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGCHLD	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGINT	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGTERM	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGQUIT	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGHUP	int
)	O
;	O
*	O
psrv	*(*(struct))
=	O
srv	*(struct)
;	O
if	O
(	O
!	O
m_server_list	*(struct)
)	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
m_server_list	*(struct)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
m_server_list	*(struct)
,	O
srv	*(struct)
)	O
;	O
}	O
void	O
mu_m_server_set_type	(*(struct),int)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
int	O
type	int
)	O
{	O
srv	*(struct)
->	O
deftype	int
=	O
type	int
;	O
}	O
void	O
mu_m_server_get_type	(*(struct),*(int))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
int	O
*	O
type	int
)	O
{	O
*	O
type	int
=	O
srv	*(struct)
->	O
deftype	int
;	O
}	O
void	O
mu_m_server_set_sigset	(*(struct),*(struct(array(long))))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
sigset_t	struct(array(long))
*	O
sigset	(int,*((int)->(void)))->(*((int)->(void)))
)	O
{	O
srv	*(struct)
->	O
sigmask	struct(array(long))
=	O
*	O
sigset	(int,*((int)->(void)))->(*((int)->(void)))
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
srv	*(struct)
->	O
sigmask	struct(array(long))
,	O
SIGCHLD	int
)	O
;	O
}	O
void	O
mu_m_server_get_sigset	(*(struct),*(struct(array(long))))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
sigset_t	struct(array(long))
*	O
sigset	(int,*((int)->(void)))->(*((int)->(void)))
)	O
{	O
*	O
sigset	(int,*((int)->(void)))->(*((int)->(void)))
=	O
srv	*(struct)
->	O
sigmask	struct(array(long))
;	O
}	O
void	O
mu_m_server_set_mode	(*(struct),int)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
int	O
mode	int
)	O
{	O
srv	*(struct)
->	O
mode	int
=	O
mode	int
;	O
}	O
void	O
mu_m_server_set_conn	(*(struct),*((int,*(struct(short,array(char))),int,*(struct(*`,*`,*`,int,int,long)),*(void))->(int)))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
mu_m_server_handler_fp	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
)	O
{	O
srv	*(struct)
->	O
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
=	O
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
;	O
}	O
void	O
mu_m_server_set_prefork	(*(struct),*((int,*(struct(short,array(char))),int,*(struct(*`,*`,*`,int,int,long)),*(void))->(int)))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
mu_m_server_handler_fp	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
)	O
{	O
srv	*(struct)
->	O
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
=	O
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
;	O
}	O
void	O
mu_m_server_set_data	(*(struct),*(void))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
void	O
*	O
data	*(void)
)	O
{	O
srv	*(struct)
->	O
data	*(void)
=	O
data	*(void)
;	O
}	O
void	O
mu_m_server_set_max_children	(*(struct),long)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
size_t	long
num	long
)	O
{	O
srv	*(struct)
->	O
max_children	long
=	O
num	long
;	O
}	O
int	O
mu_m_server_set_pidfile	(*(struct),*(char))->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
const	O
char	O
*	O
pidfile	*(char)
)	O
{	O
char	O
*	O
p	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
pidfile	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
errno	O
;	O
free	(*(void))->(void)
(	O
srv	*(struct)
->	O
pidfile	*(char)
)	O
;	O
srv	*(struct)
->	O
pidfile	*(char)
=	O
p	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
mu_m_server_set_foreground	(*(struct),int)->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
int	O
enable	int
)	O
{	O
srv	*(struct)
->	O
foreground	int
=	O
enable	int
;	O
return	O
0	int
;	O
}	O
void	O
mu_m_server_set_strexit	(*(struct),*((int)->(*(char))))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
const	O
char	O
*	O
(	O
*	O
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
)	O
(	O
int	O
)	O
)	O
{	O
srv	*(struct)
->	O
strexit	*((int)->(*(char)))
=	O
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
;	O
}	O
void	O
mu_m_server_set_preflight	(*(struct),*((*(struct))->(int)))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
mu_m_server_preflight_fp	*((*(struct))->(int))
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
)	O
{	O
srv	*(struct)
->	O
preflight	*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int))
=	O
fun	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
;	O
}	O
int	O
mu_m_server_get_srvlist	(*(struct),*(*(struct)))->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
)	O
{	O
*	O
plist	*(*(struct))
=	O
srv	*(struct)
->	O
srvlist	*(struct)
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
mu_m_server_pidfile	(*(struct))->(*(char))
(	O
mu_m_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
srv	*(struct)
->	O
pidfile	*(char)
;	O
}	O
void	O
mu_m_server_set_hints	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),*(struct(int,int,int,int,short)))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
*	O
hints	*(struct(*(char),*(char)))
)	O
{	O
if	O
(	O
!	O
hints	*(struct(*(char),*(char)))
)	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
)	O
)	O
;	O
else	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
,	O
hints	*(struct(*(char),*(char)))
,	O
sizeof	O
(	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
)	O
)	O
;	O
}	O
int	O
mu_m_server_get_hints	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),*(struct(int,int,int,int,short)))->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
*	O
hints	*(struct(*(char),*(char)))
)	O
{	O
if	O
(	O
!	O
hints	*(struct(*(char),*(char)))
)	O
return	O
EINVAL	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hints	*(struct(*(char),*(char)))
,	O
&	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
,	O
sizeof	O
(	O
*	O
hints	*(struct(*(char),*(char)))
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_m_server_set_default_port	(*(struct),int)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
int	O
num	long
)	O
{	O
srv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
.	O
port	int
=	O
num	long
;	O
}	O
void	O
mu_m_server_set_timeout	(*(struct),long)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
time_t	long
t	long
)	O
{	O
srv	*(struct)
->	O
timeout	long
=	O
t	long
;	O
}	O
int	O
mu_m_server_mode	(*(struct))->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
srv	*(struct)
->	O
mode	int
;	O
}	O
time_t	long
mu_m_server_timeout	(*(struct))->(long)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
srv	*(struct)
->	O
timeout	long
;	O
}	O
int	O
mu_m_server_foreground	(*(struct))->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
srv	*(struct)
->	O
foreground	int
;	O
}	O
void	O
mu_m_server_set_app_data_size	(*(struct),long)->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
size_t	long
size	long
)	O
{	O
srv	*(struct)
->	O
app_data_size	long
=	O
size	long
;	O
}	O
int	O
mu_m_server_set_config_size	(*(struct),long)->(int)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
<	O
sizeof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
)	O
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
app_data_size	long
=	O
size	long
-	O
sizeof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_srv_config_free	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
=	O
data	*(void)
;	O
free	(*(void))->(void)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
)	O
;	O
}	O
static	O
int	O
m_srv_conn	(int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int)
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
int	O
salen	int
,	O
void	O
*	O
server_data	*(void)
,	O
void	O
*	O
call_data	*(void)
,	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
;	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
mu_m_server_listen	(*(struct),*(struct),int)->(*(struct(*(struct),*(struct),*(struct),int,int,long)))
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
s	*(char)
,	O
int	O
type	int
)	O
{	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
;	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
;	O
MU_ASSERT	O
(	O
mu_ip_server_create	(*(*(struct)),*(struct),int)->(int)
(	O
&	O
tcpsrv	*(struct)
,	O
s	*(char)
,	O
type	int
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_ip_server_set_conn	(*(struct),*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int)))->(int)
(	O
tcpsrv	*(struct)
,	O
m_srv_conn	(int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int)
)	O
)	O
;	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
)	O
+	O
msrv	*(struct)
->	O
app_data_size	long
)	O
;	O
if	O
(	O
!	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
ENOMEM	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
=	O
msrv	*(struct)
;	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
tcpsrv	*(struct)
=	O
tcpsrv	*(struct)
;	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
single_process	int
=	O
0	int
;	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
timeout	long
=	O
msrv	*(struct)
->	O
timeout	long
;	O
MU_ASSERT	O
(	O
mu_ip_server_set_data	(*(struct),*(void),*((*(void))->(void)))->(int)
(	O
tcpsrv	*(struct)
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
mu_srv_config_free	(*(void))->(void)
)	O
)	O
;	O
if	O
(	O
!	O
msrv	*(struct)
->	O
srvlist	*(struct)
)	O
MU_ASSERT	O
(	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
msrv	*(struct)
->	O
srvlist	*(struct)
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_list_append	(*(struct),*(void))->(int)
(	O
msrv	*(struct)
->	O
srvlist	*(struct)
,	O
tcpsrv	*(struct)
)	O
)	O
;	O
return	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
;	O
}	O
void	O
mu_m_server_configured_count	(*(struct),*(long))->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
size_t	long
*	O
count	*(long)
)	O
{	O
mu_list_count	(*(struct),*(long))->(int)
(	O
msrv	*(struct)
->	O
srvlist	*(struct)
,	O
count	*(long)
)	O
;	O
}	O
void	O
mu_m_server_begin	(*(struct))->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
int	O
i	int
,	O
rc	int
;	O
size_t	long
count	*(long)
=	O
0	int
;	O
if	O
(	O
!	O
msrv	*(struct)
->	O
child_pid	*(int)
)	O
alloc_children	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
msrv	*(struct)
)	O
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
msrv	*(struct)
->	O
srvlist	*(struct)
,	O
&	O
count	*(long)
)	O
;	O
if	O
(	O
count	*(long)
==	O
0	int
)	O
{	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
;	O
msrv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
.	O
flags	int
=	O
MU_AH_PASSIVE	int
;	O
rc	int
=	O
mu_sockaddr_from_node	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(char),*(char),*(struct(int,int,int,int,short)))->(int)
(	O
&	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
msrv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
while	O
(	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
)	O
{	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
=	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
;	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
=	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
=	O
NULL	O
;	O
mu_m_server_listen	(*(struct),*(struct),int)->(*(struct(*(struct),*(struct),*(struct),int,int,long)))
(	O
msrv	*(struct)
,	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
,	O
msrv	*(struct)
->	O
deftype	int
)	O
;	O
ta	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
=	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
;	O
}	O
}	O
if	O
(	O
!	O
msrv	*(struct)
->	O
foreground	int
)	O
{	O
if	O
(	O
daemon	(int,int)->(int)
(	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to become a daemon: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
mu_onexit_reset	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
msrv	*(struct)
->	O
pidfile	*(char)
)	O
switch	O
(	O
rc	int
=	O
mu_daemon_create_pidfile	(*(char))->(int)
(	O
msrv	*(struct)
->	O
pidfile	*(char)
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
EINVAL	int
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s: invalid name for a pidfile"	*(char)
)	O
,	O
msrv	*(struct)
->	O
pidfile	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create pidfile `%s': %s"	*(char)
)	O
,	O
msrv	*(struct)
->	O
pidfile	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSIG	O
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	(*(struct(array(long))),int)->(int)
(	O
&	O
msrv	*(struct)
->	O
sigmask	struct(array(long))
,	O
i	int
)	O
)	O
msrv	*(struct)
->	O
sigtab	array(*((int)->(void)))
[	O
i	int
]	O
=	O
set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
i	int
,	O
m_srv_signal	(int)->(void)
)	O
;	O
}	O
void	O
mu_m_server_restore_signals	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSIG	O
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	(*(struct(array(long))),int)->(int)
(	O
&	O
msrv	*(struct)
->	O
sigmask	struct(array(long))
,	O
i	int
)	O
)	O
set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
i	int
,	O
msrv	*(struct)
->	O
sigtab	array(*((int)->(void)))
[	O
i	int
]	O
)	O
;	O
}	O
void	O
mu_m_server_end	(*(struct))->(void)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
mu_m_server_restore_signals	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
msrv	*(struct)
)	O
;	O
}	O
void	O
mu_m_server_destroy	(*(*(struct)))->(void)
(	O
mu_m_server_t	*(struct)
*	O
pmsrv	*(*(struct))
)	O
{	O
mu_m_server_t	*(struct)
msrv	*(struct)
=	O
*	O
pmsrv	*(*(struct))
;	O
mu_list_remove	(*(struct),*(void))->(int)
(	O
m_server_list	*(struct)
,	O
msrv	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
msrv	*(struct)
->	O
srvlist	*(struct)
)	O
;	O
mu_server_destroy	(*(*(struct)))->(int)
(	O
&	O
msrv	*(struct)
->	O
server	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
msrv	*(struct)
->	O
child_pid	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
msrv	*(struct)
->	O
ident	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
msrv	*(struct)
)	O
;	O
*	O
pmsrv	*(*(struct))
=	O
NULL	O
;	O
}	O
static	O
int	O
tcp_conn_handler	(int,*(void),*(void))->(int)
(	O
int	O
fd	int
,	O
void	O
*	O
conn_data	*(void)
,	O
void	O
*	O
server_data	*(void)
)	O
{	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
=	O
(	O
mu_ip_server_t	*(struct)
)	O
conn_data	*(void)
;	O
int	O
rc	int
=	O
mu_ip_server_accept	(*(struct),*(void))->(int)
(	O
tcpsrv	*(struct)
,	O
server_data	*(void)
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
EINTR	int
)	O
{	O
mu_ip_server_shutdown	(*(struct))->(int)
(	O
tcpsrv	*(struct)
)	O
;	O
return	O
MU_SERVER_CLOSE_CONN	int
;	O
}	O
return	O
stop	int
?	O
MU_SERVER_SHUTDOWN	int
:	O
MU_SERVER_SUCCESS	int
;	O
}	O
static	O
void	O
tcp_conn_free	(*(void),*(void))->(void)
(	O
void	O
*	O
conn_data	*(void)
,	O
void	O
*	O
server_data	*(void)
)	O
{	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
=	O
(	O
mu_ip_server_t	*(struct)
)	O
conn_data	*(void)
;	O
mu_ip_server_destroy	(*(*(struct)))->(int)
(	O
&	O
tcpsrv	*(struct)
)	O
;	O
}	O
static	O
int	O
open_connection	(*(struct),*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)
(	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
,	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
int	O
rc	int
=	O
mu_ip_server_open	(*(struct))->(int)
(	O
tcpsrv	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open connection on %s: %s"	*(char)
)	O
,	O
mu_ip_server_addrstr	(*(struct))->(*(char))
(	O
tcpsrv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_server_add_connection	(*(struct),int,*(void),*((int,*(void),*(void))->(int)),*((*(void),*(void))->(void)))->(int)
(	O
msrv	*(struct)
->	O
server	*(struct)
,	O
mu_ip_server_get_fd	(*(struct))->(int)
(	O
tcpsrv	*(struct)
)	O
,	O
tcpsrv	*(struct)
,	O
tcp_conn_handler	(int,*(void),*(void))->(int)
,	O
tcp_conn_free	(*(void),*(void))->(void)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot add connection %s: %s"	*(char)
)	O
,	O
mu_ip_server_addrstr	(*(struct))->(*(char))
(	O
tcpsrv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_ip_server_shutdown	(*(struct))->(int)
(	O
tcpsrv	*(struct)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_m_server_run	(*(struct))->(int)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
)	O
{	O
int	O
rc	int
;	O
size_t	long
count	*(long)
;	O
mode_t	int
saved_umask	int
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
saved_umask	int
=	O
umask	(int)->(int)
(	O
0117	int
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
msrv	*(struct)
->	O
srvlist	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
tcpsrv	*(struct)
)	O
;	O
if	O
(	O
open_connection	(*(struct),*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)
(	O
tcpsrv	*(struct)
,	O
msrv	*(struct)
)	O
)	O
{	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete_nd	int
,	O
NULL	O
)	O
;	O
mu_ip_server_destroy	(*(*(struct)))->(int)
(	O
&	O
tcpsrv	*(struct)
)	O
;	O
}	O
}	O
umask	(int)->(int)
(	O
saved_umask	int
)	O
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
MU_ASSERT	O
(	O
mu_server_count	(*(struct),*(long))->(int)
(	O
msrv	*(struct)
->	O
server	*(struct)
,	O
&	O
count	*(long)
)	O
)	O
;	O
if	O
(	O
count	*(long)
==	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"no servers configured: exiting"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
msrv	*(struct)
->	O
preflight	*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int))
&&	O
msrv	*(struct)
->	O
preflight	*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int))
(	O
msrv	*(struct)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s: preflight check failed"	*(char)
)	O
,	O
msrv	*(struct)
->	O
ident	*(char)
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
if	O
(	O
msrv	*(struct)
->	O
ident	*(char)
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s started"	*(char)
)	O
,	O
msrv	*(struct)
->	O
ident	*(char)
)	O
;	O
rc	int
=	O
mu_server_run	(*(struct))->(int)
(	O
msrv	*(struct)
->	O
server	*(struct)
)	O
;	O
terminate_children	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
msrv	*(struct)
)	O
;	O
if	O
(	O
msrv	*(struct)
->	O
ident	*(char)
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s terminated"	*(char)
)	O
,	O
msrv	*(struct)
->	O
ident	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_m_server_check_acl	(*(struct),*(struct(short,array(char))),int)->(int)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
s	*(char)
,	O
int	O
salen	int
)	O
{	O
if	O
(	O
msrv	*(struct)
->	O
acl	*(struct)
)	O
{	O
mu_acl_result_t	enum(int,int,int)
res	*(int)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
msrv	*(struct)
->	O
acl	*(struct)
,	O
s	*(char)
,	O
salen	int
,	O
&	O
res	*(int)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
s	*(char)
,	O
salen	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"access from %s blocked: cannot check ACLs: %s"	*(char)
)	O
,	O
p	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
res	*(int)
)	O
{	O
case	O
mu_acl_result_undefined	int
:	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
s	*(char)
,	O
salen	int
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s: undefined ACL result; access allowed"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
mu_acl_result_accept	int
:	O
break	O
;	O
case	O
mu_acl_result_deny	int
:	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
s	*(char)
,	O
salen	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"access from %s blocked"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
m_srv_conn	(int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int)
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
int	O
salen	int
,	O
void	O
*	O
server_data	*(void)
,	O
void	O
*	O
call_data	*(void)
,	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
{	O
int	O
status	int
;	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
=	O
server_data	*(void)
;	O
if	O
(	O
mu_m_server_check_acl	(*(struct),*(struct(short,array(char))),int)->(int)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
,	O
sa	*(struct(short,array(char)))
,	O
salen	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
single_process	int
)	O
{	O
pid_t	int
pid	int
;	O
if	O
(	O
mu_m_server_idle	(*(void))->(int)
(	O
server_data	*(void)
)	O
)	O
return	O
MU_SERVER_SHUTDOWN	int
;	O
if	O
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
max_children	long
&&	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
num_children	long
>=	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
max_children	long
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"too many children (%lu)"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
num_children	long
)	O
;	O
pause	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
&&	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
(	O
fd	int
,	O
sa	*(struct(short,array(char)))
,	O
salen	int
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
data	*(void)
)	O
)	O
return	O
0	int
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_ERROR	O
,	O
"fork: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
mu_ip_server_shutdown	(*(struct))->(int)
(	O
srv	*(struct)
)	O
;	O
mu_m_server_restore_signals	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(void)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
)	O
;	O
status	int
=	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
(	O
fd	int
,	O
sa	*(struct(short,array(char)))
,	O
salen	int
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
data	*(void)
)	O
;	O
closelog	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
else	O
{	O
register_child	(*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),int)->(void)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
,	O
pid	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
||	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
prefork	*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int))
(	O
fd	int
,	O
sa	*(struct(short,array(char)))
,	O
salen	int
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
data	*(void)
)	O
==	O
0	int
)	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
(	O
fd	int
,	O
sa	*(struct(short,array(char)))
,	O
salen	int
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
msrv	*(struct)
->	O
data	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_m_server_parse_url	(*(struct),*(char),*(*(struct)))->(int)
(	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
*	O
psa	*(*(struct))
)	O
{	O
int	O
rc	int
;	O
mu_url_t	*(struct)
url	*(struct)
,	O
url_hint	*(struct)
;	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
url_hint	*(struct)
=	O
NULL	O
;	O
else	O
{	O
rc	int
=	O
mu_url_create	(*(*(struct)),*(char))->(int)
(	O
&	O
url_hint	*(struct)
,	O
"inet://"	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_url_create_hint	(*(*(struct)),*(char),int,*(struct))->(int)
(	O
&	O
url	*(struct)
,	O
arg	*(char)
,	O
MU_URL_PARSE_DEFAULT	O
,	O
url_hint	*(struct)
)	O
;	O
mu_url_destroy	(*(*(struct)))->(void)
(	O
&	O
url_hint	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot parse URL `%s': %s"	*(char)
)	O
,	O
arg	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
msrv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
.	O
flags	int
=	O
MU_AH_PASSIVE	int
;	O
rc	int
=	O
mu_sockaddr_from_url	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(struct),*(struct(int,int,int,int,short)))->(int)
(	O
psa	*(*(struct))
,	O
url	*(struct)
,	O
&	O
msrv	*(struct)
->	O
hints	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create sockaddr for URL `%s': %s"	*(char)
)	O
,	O
arg	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_url_destroy	(*(*(struct)))->(void)
(	O
&	O
url	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
server_block_begin	(*(char),*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),*(*(void)))->(int)
(	O
const	O
char	O
*	O
arg	*(char)
,	O
mu_m_server_t	*(struct)
msrv	*(struct)
,	O
void	O
*	O
*	O
pdata	*(*(void))
)	O
{	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
s	*(char)
;	O
if	O
(	O
mu_m_server_parse_url	(*(struct),*(char),*(*(struct)))->(int)
(	O
msrv	*(struct)
,	O
arg	*(char)
,	O
&	O
s	*(char)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
s	*(char)
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"%s resolves to several addresses, "	*(char)
"only the first is used"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
mu_sockaddr_free	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(void)
(	O
s	*(char)
->	O
next	*(struct(array(struct(array(long),int,struct(array(long)))),*(struct(array(struct(array(long),int,struct(array(long)))),*(struct`)))))
)	O
;	O
}	O
*	O
pdata	*(*(void))
=	O
mu_m_server_listen	(*(struct),*(struct),int)->(*(struct(*(struct),*(struct),*(struct),int,int,long)))
(	O
msrv	*(struct)
,	O
s	*(char)
,	O
msrv	*(struct)
->	O
deftype	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
server_section_parser	(enum(int,int),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(char),*(*(void)),*(void),*(struct(*(struct),*(struct))))->(int)
(	O
enum	O
mu_cfg_section_stage	enum(int,int)
stage	enum(int,int)
,	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
section_label	*(char)
,	O
void	O
*	O
*	O
section_data	*(*(void))
,	O
void	O
*	O
call_data	*(void)
,	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
)	O
{	O
switch	O
(	O
stage	enum(int,int)
)	O
{	O
case	O
mu_cfg_section_start	int
:	O
{	O
if	O
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
==	O
NULL	O
||	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
type	int
!=	O
MU_CFG_STRING	int
)	O
return	O
1	int
;	O
return	O
server_block_begin	(*(char),*(struct(*(char),int,*(struct),*(struct),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))),*(*(void)))->(int)
(	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
*	O
section_data	*(*(void))
,	O
section_data	*(*(void))
)	O
;	O
}	O
break	O
;	O
case	O
mu_cfg_section_end	int
:	O
{	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
*	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
=	O
*	O
section_data	*(*(void))
;	O
if	O
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
acl	*(struct)
)	O
mu_ip_server_set_acl	(*(struct),*(struct))->(int)
(	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
tcpsrv	*(struct)
,	O
pconf	*(struct(*(struct),*(struct),*(struct),int,int,long))
->	O
acl	*(struct)
)	O
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_cb_daemon_mode	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
*	O
pmode	*(int)
=	O
data	*(void)
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"inetd"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"interactive"	*(char)
)	O
==	O
0	int
)	O
*	O
pmode	*(int)
=	O
MODE_INTERACTIVE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"daemon"	*(char)
)	O
==	O
0	int
)	O
*	O
pmode	*(int)
=	O
MODE_DAEMON	int
;	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown daemon mode"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
unsigned	O
short	O
get_port	(*(char))->(short)
(	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
if	O
(	O
p	*(char)
)	O
{	O
char	O
*	O
q	*(char)
;	O
unsigned	O
long	O
n	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(char)
,	O
&	O
q	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
0	int
)	O
{	O
if	O
(	O
n	int
>	O
USHRT_MAX	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid port number: %s"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
n	int
;	O
}	O
else	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
p	*(char)
,	O
"tcp"	*(char)
)	O
;	O
if	O
(	O
!	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
)	O
return	O
0	int
;	O
return	O
ntohs	(short)->(short)
(	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_cb_port	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
*	O
hp	*(struct(int,int,int,int,short))
=	O
data	*(void)
;	O
unsigned	O
short	O
num	long
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
num	long
=	O
get_port	(*(char))->(short)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
!	O
num	long
)	O
return	O
1	int
;	O
hp	*(struct(int,int,int,int,short))
->	O
port	int
=	O
num	long
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
dot_server_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"max-children"	*(char)
,	O
mu_c_size	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
max_children	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Maximum number of children processes to run simultaneously."	*(char)
)	O
}	O
,	O
{	O
"mode"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
mode	int
)	O
,	O
_cb_daemon_mode	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set operation mode."	*(char)
)	O
,	O
N_	O
(	O
"mode: inetd|interactive|daemon"	*(char)
)	O
}	O
,	O
{	O
"foreground"	*(char)
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
foreground	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Run in foreground."	*(char)
)	O
}	O
,	O
{	O
"pidfile"	*(char)
,	O
mu_c_string	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
pidfile	*(char)
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Store PID of the master process in this file."	*(char)
)	O
,	O
N_	O
(	O
"file"	*(char)
)	O
}	O
,	O
{	O
"port"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
hints	*(struct(*(char),*(char)))
)	O
,	O
_cb_port	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Default port number."	*(char)
)	O
,	O
N_	O
(	O
"arg: port number or service name"	*(char)
)	O
}	O
,	O
{	O
"timeout"	*(char)
,	O
mu_c_time	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
timeout	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Set idle timeout."	*(char)
)	O
}	O
,	O
{	O
"server"	*(char)
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Server configuration."	*(char)
)	O
}	O
,	O
{	O
"acl"	*(char)
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct(*(char),int,*(struct),*(struct),*((*(struct(*(char),int,*(struct`),*(struct`),*((*`)->(int)),*((int,*`,int,*`,*`)->(int)),*((int,*`,int,*`,*`)->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct`),struct(array(long)),array(*((int)->(void))),*((int)->(*`)))))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*((int,*(struct(short,array(char))),int,*(struct(*(struct`),*(struct`),*(struct`),int,int,long)),*(void))->(int)),*(void),long,int,int,long,long,*(int),*(char),struct(int,int,int,int,short),long,*(struct),struct(array(long)),array(*((int)->(void))),*((int)->(*(char))))
,	O
acl	*(struct)
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Per-server access control list"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
server_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"single-process"	*(char)
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
,	O
single_process	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not spawn sub-process to handle requests in this server."	*(char)
)	O
}	O
,	O
{	O
"transcript"	*(char)
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
,	O
transcript	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Log the session transcript."	*(char)
)	O
}	O
,	O
{	O
"timeout"	*(char)
,	O
mu_c_time	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
,	O
timeout	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Set idle timeout."	*(char)
)	O
}	O
,	O
{	O
"acl"	*(char)
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
,	O
acl	*(struct)
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Global access control list."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
_cb_backlog	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
mu_ip_server_t	*(struct)
*	O
psrv	*(*(struct))
=	O
data	*(void)
;	O
int	O
backlog	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"%d"	*(char)
,	O
&	O
backlog	int
)	O
!=	O
1	int
||	O
backlog	int
<=	O
0	int
||	O
mu_tcp_server_set_backlog	(*(struct),int)->(int)
(	O
*	O
psrv	*(*(struct))
,	O
backlog	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid argument"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
server_tcp_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"backlog"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct(*(struct),*(struct),*(struct),int,int,long)
,	O
tcpsrv	*(struct)
)	O
,	O
_cb_backlog	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Size of the queue of pending connections"	*(char)
)	O
,	O
N_	O
(	O
"number"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mu_m_server_cfg_init	(*(struct),*(struct))->(void)
(	O
mu_m_server_t	*(struct)
srv	*(struct)
,	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
*	O
app_param	*(struct)
)	O
{	O
struct	O
mu_cfg_section	int
*	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
;	O
if	O
(	O
mu_create_canned_section	(*(char),*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)))))->(int)
(	O
"server"	*(char)
,	O
&	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
)	O
==	O
0	int
)	O
{	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
->	O
parser	*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int))
=	O
server_section_parser	(enum(int,int),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(char),*(*(void)),*(void),*(struct(*(struct),*(struct))))->(int)
;	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
->	O
label	*(struct(int,union(*(struct),*(char),struct(long,*(struct`)))))
=	O
N_	O
(	O
"ipaddr[:port]"	*(char)
)	O
;	O
mu_cfg_section_add_params	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
,	O
server_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
)	O
;	O
if	O
(	O
srv	*(struct)
->	O
deftype	int
==	O
MU_IP_TCP	int
)	O
mu_cfg_section_add_params	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
,	O
server_tcp_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
)	O
;	O
if	O
(	O
app_param	*(struct)
)	O
mu_cfg_section_add_params	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
,	O
app_param	*(struct)
)	O
;	O
}	O
if	O
(	O
mu_create_canned_section	(*(char),*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)))))->(int)
(	O
".server"	*(char)
,	O
&	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
)	O
==	O
0	int
)	O
{	O
mu_cfg_section_add_params	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
,	O
dot_server_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
)	O
;	O
}	O
}	O
