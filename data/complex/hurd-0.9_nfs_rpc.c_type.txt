struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
{	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
,	O
*	O
*	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
;	O
void	O
*	O
reply	*(void)
;	O
}	O
;	O
static	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
outstanding_rpcs	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
static	O
pthread_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
rpc_wakeup	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
static	O
inline	O
int	O
generate_xid	()->(int)
(	O
)	O
{	O
static	O
int	O
nextxid	int
;	O
if	O
(	O
nextxid	int
==	O
0	int
)	O
nextxid	int
=	O
mapped_time	*(struct)
->	O
seconds	O
;	O
return	O
nextxid	int
++	O
;	O
}	O
int	O
*	O
initialize_rpc	(int,int,int,long,*(*(void)),int,int,int)->(*(int))
(	O
int	O
program	int
,	O
int	O
version	int
,	O
int	O
rpc_proc	int
,	O
size_t	long
len	long
,	O
void	O
*	O
*	O
bufp	*(*(void))
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
,	O
gid_t	int
second_gid	int
)	O
{	O
void	O
*	O
buf	*(void)
;	O
int	O
*	O
p	*(int)
,	O
*	O
lenaddr	*(int)
;	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
buf	*(void)
=	O
malloc	O
(	O
len	long
+	O
1024	int
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
=	O
buf	*(void)
;	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
=	O
0	int
;	O
p	*(int)
=	O
buf	*(void)
+	O
sizeof	O
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
generate_xid	()->(int)
(	O
)	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
CALL	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
RPC_MSG_VERSION	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
program	int
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
version	int
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
rpc_proc	int
)	O
;	O
assert	()->(int)
(	O
(	O
uid	int
==	O
-	O
1	int
)	O
==	O
(	O
gid	int
==	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
uid	int
==	O
-	O
1	int
)	O
{	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
AUTH_NONE	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
}	O
else	O
{	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
AUTH_UNIX	O
)	O
;	O
lenaddr	*(int)
=	O
p	*(int)
++	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
mapped_time	*(struct)
->	O
seconds	O
)	O
;	O
p	*(int)
=	O
xdr_encode_string	(*(int),*(char))->(*(int))
(	O
p	*(int)
,	O
hostname	*(char)
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
uid	int
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
gid	int
)	O
;	O
if	O
(	O
second_gid	int
==	O
-	O
1	int
)	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
else	O
{	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
1	int
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
second_gid	int
)	O
;	O
}	O
*	O
lenaddr	*(int)
=	O
htonl	()->(int)
(	O
(	O
p	*(int)
-	O
(	O
lenaddr	*(int)
+	O
1	int
)	O
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
htonl	()->(int)
(	O
AUTH_NONE	O
)	O
;	O
*	O
(	O
p	*(int)
++	O
)	O
=	O
0	int
;	O
*	O
bufp	*(*(void))
=	O
buf	*(void)
;	O
return	O
p	*(int)
;	O
}	O
static	O
inline	O
void	O
unlink_rpc	(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
{	O
*	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
=	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
if	O
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
=	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
;	O
}	O
static	O
inline	O
void	O
link_rpc	(*(*(struct(*(struct`),*(*`),*(void)))),*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
*	O
list	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
,	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
{	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
=	O
*	O
list	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
;	O
if	O
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
=	O
&	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
prevp	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
=	O
list	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
;	O
*	O
list	*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))
=	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
}	O
error_t	int
conduct_rpc	(*(*(void)),*(*(int)))->(int)
(	O
void	O
*	O
*	O
rpcbuf	*(*(void))
,	O
int	O
*	O
*	O
pp	*(*(int))
)	O
{	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
=	O
*	O
rpcbuf	*(*(void))
;	O
error_t	int
err	int
;	O
size_t	long
cc	long
,	O
nc	long
;	O
int	O
timeout	int
=	O
initial_transmit_timeout	int
;	O
time_t	long
lasttrans	long
;	O
int	O
ntransmit	int
=	O
0	int
;	O
int	O
*	O
p	*(int)
;	O
int	O
xid	int
;	O
int	O
n	int
;	O
int	O
cancel	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
link_rpc	(*(*(struct(*(struct`),*(*`),*(void)))),*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
&	O
outstanding_rpcs	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
,	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
xid	int
=	O
*	O
(	O
int	O
*	O
)	O
(	O
*	O
rpcbuf	*(*(void))
+	O
sizeof	O
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
)	O
)	O
;	O
do	O
{	O
if	O
(	O
mounted_soft	int
&&	O
ntransmit	int
==	O
soft_retries	int
)	O
{	O
unlink_rpc	(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
ETIMEDOUT	int
;	O
}	O
lasttrans	long
=	O
mapped_time	*(struct)
->	O
seconds	O
;	O
ntransmit	int
++	O
;	O
nc	long
=	O
(	O
void	O
*	O
)	O
*	O
pp	*(*(int))
-	O
*	O
rpcbuf	*(*(void))
-	O
sizeof	O
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
)	O
;	O
cc	long
=	O
write	()->(int)
(	O
main_udp_socket	int
,	O
*	O
rpcbuf	*(*(void))
+	O
sizeof	O
(	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
)	O
,	O
nc	long
)	O
;	O
if	O
(	O
cc	long
==	O
-	O
1	int
)	O
{	O
unlink_rpc	(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
errno	O
;	O
}	O
else	O
assert	()->(int)
(	O
cc	long
==	O
nc	long
)	O
;	O
cancel	int
=	O
0	int
;	O
while	O
(	O
!	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
&&	O
(	O
mapped_time	*(struct)
->	O
seconds	O
-	O
lasttrans	long
<	O
timeout	int
)	O
&&	O
!	O
cancel	int
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
rpc_wakeup	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
unlink_rpc	(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
EINTR	int
;	O
}	O
if	O
(	O
!	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
)	O
{	O
timeout	int
*=	O
2	int
;	O
if	O
(	O
timeout	int
>	O
max_transmit_timeout	int
)	O
timeout	int
=	O
max_transmit_timeout	int
;	O
}	O
}	O
while	O
(	O
!	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
*	O
rpcbuf	*(*(void))
=	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
;	O
free	()->(int)
(	O
hdr	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
p	*(int)
=	O
(	O
int	O
*	O
)	O
*	O
rpcbuf	*(*(void))
;	O
assert	()->(int)
(	O
*	O
p	*(int)
==	O
xid	int
)	O
;	O
p	*(int)
++	O
;	O
switch	O
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
REPLY	O
:	O
p	*(int)
++	O
;	O
switch	O
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
MSG_DENIED	O
:	O
p	*(int)
++	O
;	O
switch	O
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
RPC_MISMATCH	O
:	O
err	int
=	O
ERPCMISMATCH	O
;	O
break	O
;	O
case	O
AUTH_ERROR	O
:	O
p	*(int)
++	O
;	O
switch	O
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
{	O
case	O
AUTH_BADCRED	O
:	O
case	O
AUTH_REJECTEDCRED	O
:	O
err	int
=	O
EAUTH	O
;	O
break	O
;	O
case	O
AUTH_TOOWEAK	O
:	O
err	int
=	O
ENEEDAUTH	O
;	O
break	O
;	O
case	O
AUTH_BADVERF	O
:	O
case	O
AUTH_REJECTEDVERF	O
:	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
MSG_ACCEPTED	O
:	O
p	*(int)
++	O
;	O
p	*(int)
++	O
;	O
n	int
=	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
p	*(int)
+=	O
INTSIZE	O
(	O
n	int
)	O
;	O
switch	O
(	O
ntohl	()->(int)
(	O
*	O
p	*(int)
)	O
)	O
{	O
default	O
:	O
case	O
GARBAGE_ARGS	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
PROG_UNAVAIL	O
:	O
err	int
=	O
EPROGUNAVAIL	O
;	O
break	O
;	O
case	O
PROG_MISMATCH	O
:	O
err	int
=	O
EPROGMISMATCH	O
;	O
break	O
;	O
case	O
PROC_UNAVAIL	O
:	O
err	int
=	O
EPROCUNAVAIL	O
;	O
break	O
;	O
case	O
SUCCESS	O
:	O
p	*(int)
++	O
;	O
*	O
pp	*(*(int))
=	O
p	*(int)
;	O
err	int
=	O
0	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
}	O
return	O
err	int
;	O
}	O
void	O
*	O
timeout_service_thread	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
(	O
void	O
)	O
arg	*(void)
;	O
while	O
(	O
1	int
)	O
{	O
sleep	()->(int)
(	O
1	int
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
rpc_wakeup	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
*	O
rpc_receive_thread	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
void	O
*	O
buf	*(void)
;	O
(	O
void	O
)	O
arg	*(void)
;	O
buf	*(void)
=	O
malloc	O
(	O
1024	int
+	O
read_size	int
)	O
;	O
assert	()->(int)
(	O
buf	*(void)
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
cc	long
=	O
read	()->(int)
(	O
main_udp_socket	int
,	O
buf	*(void)
,	O
1024	int
+	O
read_size	int
)	O
;	O
if	O
(	O
cc	long
==	O
-	O
1	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
errno	O
,	O
"nfs read"	*(char)
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
struct	O
rpc_list	struct(*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void))),*(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void)))),*(void))
*	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
int	O
xid	int
=	O
*	O
(	O
int	O
*	O
)	O
buf	*(void)
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
for	O
(	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
=	O
outstanding_rpcs	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
;	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
=	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
{	O
if	O
(	O
*	O
(	O
int	O
*	O
)	O
&	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
[	O
1	int
]	O
==	O
xid	int
)	O
{	O
unlink_rpc	(*(struct(*(struct(*`,*`,*`)),*(*(struct`)),*(void))))->(void)
(	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
;	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
->	O
reply	*(void)
=	O
buf	*(void)
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
rpc_wakeup	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
break	O
;	O
}	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
outstanding_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
r	*(struct(*(struct(*(struct`),*(*`),*(void))),*(*(struct(*`,*`,*`))),*(void)))
)	O
{	O
buf	*(void)
=	O
malloc	O
(	O
1024	int
+	O
read_size	int
)	O
;	O
assert	()->(int)
(	O
buf	*(void)
)	O
;	O
}	O
}	O
}	O
return	O
NULL	O
;	O
}	O
