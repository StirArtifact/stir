static	O
void	O
parse_authmode	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
;	O
static	O
void	O
parse_linemode	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
;	O
static	O
void	O
parse_debug_level	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
;	O
static	O
void	O
telnetd_setup	(int)->(void)
(	O
int	O
fd	int
)	O
;	O
static	O
int	O
telnetd_run	()->(int)
(	O
void	O
)	O
;	O
static	O
void	O
print_hostinfo	()->(void)
(	O
void	O
)	O
;	O
char	O
*	O
login_invocation	*(char)
=	O
PATH_LOGIN	O
" -p -h %h %?u{-f %u}"	*(char)
;	O
int	O
keepalive	int
=	O
1	int
;	O
int	O
reverse_lookup	int
=	O
0	int
;	O
int	O
alwayslinemode	int
;	O
int	O
lmodetype	int
;	O
int	O
hostinfo	int
=	O
1	int
;	O
int	O
auth_level	int
=	O
0	int
;	O
int	O
debug_level	array(int)
[	O
debug_max_mode	int
]	O
;	O
int	O
debug_tcp	int
=	O
0	int
;	O
int	O
net	int
;	O
int	O
pty	int
;	O
char	O
*	O
remote_hostname	*(char)
;	O
char	O
*	O
local_hostname	*(char)
;	O
char	O
*	O
user_name	*(char)
;	O
char	O
line	array(char)
[	O
256	int
]	O
;	O
char	O
options	array(char)
[	O
256	int
]	O
;	O
char	O
do_dont_resp	array(char)
[	O
256	int
]	O
;	O
char	O
will_wont_resp	array(char)
[	O
256	int
]	O
;	O
int	O
linemode	int
;	O
int	O
uselinemode	int
;	O
int	O
editmode	int
;	O
int	O
useeditmode	int
;	O
int	O
alwayslinemode	int
;	O
int	O
lmodetype	int
;	O
int	O
flowmode	int
;	O
int	O
restartany	int
;	O
int	O
diagnostic	int
;	O
slcfun	struct(struct(char,char),struct(char,char),*(char))
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
NSLC	int
+	O
1	int
]	O
;	O
char	O
*	O
terminaltype	*(char)
;	O
int	O
SYNCHing	int
;	O
struct	O
telnetd_clocks	struct(int,int,int,int,int,int,int,int,int,int,int)
clocks	struct(int,int,int,int,int,int,int,int,int,int,int)
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"authmode"	*(char)
,	O
'a'	O
,	O
"MODE"	*(char)
,	O
0	int
,	O
"specify what mode to use for authentication"	*(char)
}	O
,	O
{	O
"debug"	*(char)
,	O
'D'	O
,	O
"LEVEL"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set debugging level"	*(char)
}	O
,	O
{	O
"exec-login"	*(char)
,	O
'E'	O
,	O
"STRING"	*(char)
,	O
0	int
,	O
"set program to be executed instead of "	*(char)
PATH_LOGIN	O
}	O
,	O
{	O
"no-hostinfo"	*(char)
,	O
'h'	O
,	O
NULL	O
,	O
0	int
,	O
"do not print host information before login has been completed"	*(char)
}	O
,	O
{	O
"linemode"	*(char)
,	O
'l'	O
,	O
"MODE"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set line mode"	*(char)
}	O
,	O
{	O
"no-keepalive"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"disable TCP keep-alives"	*(char)
}	O
,	O
{	O
"reverse-lookup"	*(char)
,	O
'U'	O
,	O
NULL	O
,	O
0	int
,	O
"refuse connections from addresses that "	*(char)
"cannot be mapped back into a symbolic name"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
parse_authmode	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
parse_debug_level	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
login_invocation	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'h'	O
:	O
hostinfo	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
parse_linemode	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
keepalive	int
=	O
0	int
;	O
break	O
;	O
case	O
'U'	O
:	O
reverse_lookup	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
"DARPA telnet protocol server"	*(char)
}	O
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	*(int)
,	O
char	O
*	O
*	O
argv	*(*(*(char)))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(*(char)))
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"telnetd"	*(char)
,	O
default_program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	*(int)
,	O
argv	*(*(*(char)))
,	O
0	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
;	O
if	O
(	O
argc	*(int)
!=	O
index	(*(char),int)->(*(char))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"junk arguments in the command line"	*(char)
)	O
;	O
openlog	(*(char),int,int)->(void)
(	O
"telnetd"	*(char)
,	O
LOG_PID	int
|	O
LOG_ODELAY	int
,	O
LOG_DAEMON	O
)	O
;	O
telnetd_setup	(int)->(void)
(	O
0	int
)	O
;	O
return	O
telnetd_run	()->(int)
(	O
)	O
;	O
}	O
void	O
parse_linemode	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
str	*(char)
)	O
alwayslinemode	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"nokludge"	*(char)
)	O
==	O
0	int
)	O
lmodetype	int
=	O
NO_AUTOKLUDGE	int
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"telnetd: invalid argument to --linemode\n"	*(char)
)	O
;	O
}	O
void	O
parse_authmode	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"none"	*(char)
)	O
==	O
0	int
)	O
auth_level	int
=	O
0	int
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"other"	*(char)
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_OTHER	int
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"user"	*(char)
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_USER	int
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"valid"	*(char)
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_VALID	int
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"off"	*(char)
)	O
==	O
0	int
)	O
auth_level	int
=	O
-	O
1	int
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"telnetd: unknown authorization level for -a\n"	*(char)
)	O
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
modnum	int
;	O
}	O
debug_mode	enum(int,int,int,int,int,int)
[	O
debug_max_mode	int
]	O
=	O
{	O
{	O
"options"	*(char)
,	O
debug_options	int
}	O
,	O
{	O
"report"	*(char)
,	O
debug_report	int
}	O
,	O
{	O
"netdata"	*(char)
,	O
debug_net_data	int
}	O
,	O
{	O
"ptydata"	*(char)
,	O
debug_pty_data	int
}	O
,	O
{	O
"auth"	*(char)
,	O
debug_auth	int
}	O
,	O
}	O
;	O
void	O
parse_debug_level	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
int	O
i	int
;	O
char	O
*	O
tok	*(char)
;	O
if	O
(	O
!	O
str	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
debug_max_mode	int
;	O
i	int
++	O
)	O
debug_level	array(int)
[	O
debug_mode	enum(int,int,int,int,int,int)
[	O
i	int
]	O
.	O
modnum	int
]	O
=	O
MAX_DEBUG_LEVEL	int
;	O
return	O
;	O
}	O
for	O
(	O
tok	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
str	*(char)
,	O
","	*(char)
)	O
;	O
tok	*(char)
;	O
tok	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
","	*(char)
)	O
)	O
{	O
int	O
length	int
,	O
level	int
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	*(char)
,	O
"tcp"	*(char)
)	O
==	O
0	int
)	O
{	O
debug_tcp	int
=	O
1	int
;	O
continue	O
;	O
}	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
tok	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
{	O
length	int
=	O
p	*(void)
-	O
tok	*(char)
;	O
level	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(void)
+	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
length	int
=	O
strlen	(*(char))->(long)
(	O
tok	*(char)
)	O
;	O
level	int
=	O
MAX_DEBUG_LEVEL	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
debug_max_mode	int
;	O
i	int
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
debug_mode	enum(int,int,int,int,int,int)
[	O
i	int
]	O
.	O
name	*(char)
,	O
tok	*(char)
,	O
length	int
)	O
==	O
0	int
)	O
{	O
debug_level	array(int)
[	O
debug_mode	enum(int,int,int,int,int,int)
[	O
i	int
]	O
.	O
modnum	int
]	O
=	O
level	int
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
debug_max_mode	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"telnetd: unknown debug mode: %s"	*(char)
,	O
tok	*(char)
)	O
;	O
}	O
}	O
typedef	O
unsigned	O
int	O
ip_addr_t	int
;	O
void	O
telnetd_setup	(int)->(void)
(	O
int	O
fd	int
)	O
{	O
struct	O
sockaddr_storage	struct(short,array(char),long)
saddr	struct(short,array(char),long)
;	O
char	O
buf	*(void)
[	O
256	int
]	O
,	O
buf2	array(char)
[	O
256	int
]	O
;	O
int	O
err	long
;	O
int	O
true	int
=	O
1	int
;	O
socklen_t	int
len	long
;	O
char	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
[	O
256	int
]	O
;	O
int	O
level	int
;	O
len	long
=	O
sizeof	O
(	O
saddr	struct(short,array(char),long)
)	O
;	O
if	O
(	O
getpeername	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
saddr	struct(short,array(char),long)
,	O
&	O
len	long
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"getpeername: %m"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
err	long
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
saddr	struct(short,array(char),long)
,	O
len	long
,	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	*(char)
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
else	O
errmsg	*(char)
=	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
;	O
syslog	(int,*(char))->(void)
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Cannot get address: %s"	*(char)
,	O
errmsg	*(char)
)	O
;	O
fatal	(int,*(char))->(void)
(	O
fd	int
,	O
"Cannot get address."	*(char)
)	O
;	O
}	O
err	long
=	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
saddr	struct(short,array(char),long)
,	O
len	long
,	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NAMEREQD	int
)	O
;	O
if	O
(	O
reverse_lookup	int
)	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
*	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	*(char)
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
else	O
errmsg	*(char)
=	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
;	O
syslog	(int,*(char))->(void)
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Can't resolve %s: %s"	*(char)
,	O
buf	*(void)
,	O
errmsg	*(char)
)	O
;	O
fatal	(int,*(char))->(void)
(	O
fd	int
,	O
"Cannot resolve address."	*(char)
)	O
;	O
}	O
remote_hostname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buf2	array(char)
)	O
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
remote_hostname	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	*(char)
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
else	O
errmsg	*(char)
=	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
;	O
syslog	(int,*(char))->(void)
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Forward resolve of %s failed: %s"	*(char)
,	O
remote_hostname	*(char)
,	O
errmsg	*(char)
)	O
;	O
fatal	(int,*(char))->(void)
(	O
fd	int
,	O
"Cannot resolve address."	*(char)
)	O
;	O
}	O
for	O
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
&	O
saddr	struct(short,array(char),long)
,	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
)	O
break	O
;	O
if	O
(	O
aip	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
==	O
NULL	O
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"None of addresses of %s matched %s"	*(char)
,	O
remote_hostname	*(char)
,	O
buf	*(void)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
result	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
err	long
)	O
remote_hostname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buf2	array(char)
)	O
;	O
else	O
remote_hostname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buf	*(void)
)	O
;	O
}	O
if	O
(	O
keepalive	int
&&	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
(	O
true	int
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	*(char)
)	O
;	O
if	O
(	O
debug_tcp	int
&&	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
(	O
true	int
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_DEBUG): %m"	*(char)
)	O
;	O
net	int
=	O
fd	int
;	O
local_hostname	*(char)
=	O
localhost	()->(*(char))
(	O
)	O
;	O
io_setup	()->(void)
(	O
)	O
;	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
[	O
0	int
]	O
=	O
0	int
;	O
level	int
=	O
getterminaltype	(*(char))->(int)
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"TERM"	*(char)
,	O
terminaltype	*(char)
?	O
terminaltype	*(char)
:	O
"network"	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
[	O
0	int
]	O
)	O
user_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
)	O
;	O
pty	int
=	O
startslave	(*(char),int,*(char))->(int)
(	O
remote_hostname	*(char)
,	O
level	int
,	O
user_name	*(char)
)	O
;	O
ioctl	(int,long)->(int)
(	O
pty	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
ioctl	(int,long)->(int)
(	O
pty	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
ioctl	(int,long)->(int)
(	O
net	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_OOBINLINE	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTSTP	int
,	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
)	O
;	O
}	O
int	O
telnetd_run	()->(int)
(	O
void	O
)	O
{	O
int	O
nfd	int
;	O
get_slc_defaults	()->(void)
(	O
)	O
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_SGA	int
)	O
)	O
send_will	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
linemode	int
=	O
0	int
;	O
editmode	int
=	O
0	int
;	O
send_do	(int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
}	O
send_do	(int,int)->(void)
(	O
TELOPT_NAWS	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_STATUS	int
,	O
1	int
)	O
;	O
flowmode	int
=	O
1	int
;	O
restartany	int
=	O
-	O
1	int
;	O
send_do	(int,int)->(void)
(	O
TELOPT_LFLOW	int
,	O
1	int
)	O
;	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_NAWS	int
)	O
)	O
;	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_ECHO	int
)	O
&&	O
his_state_is_will	O
(	O
TELOPT_NAWS	int
)	O
)	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_ECHO	int
)	O
)	O
;	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_ECHO	int
)	O
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: simulating recv\r\n"	*(char)
)	O
)	O
;	O
willoption	(int)->(void)
(	O
TELOPT_ECHO	int
)	O
;	O
}	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_ECHO	int
)	O
)	O
send_will	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
if	O
(	O
lmodetype	int
<	O
REAL_LINEMODE	int
)	O
send_do	(int,int)->(void)
(	O
TELOPT_TM	int
,	O
1	int
)	O
;	O
telrcv	()->(void)
(	O
)	O
;	O
if	O
(	O
hostinfo	int
)	O
print_hostinfo	()->(void)
(	O
)	O
;	O
init_termbuf	()->(void)
(	O
)	O
;	O
localstat	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: Entering processing loop\r\n"	*(char)
)	O
)	O
;	O
nfd	int
=	O
(	O
(	O
net	int
>	O
pty	int
)	O
?	O
net	int
:	O
pty	int
)	O
+	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
fd_set	struct(array(long))
ibits	struct(array(long))
,	O
obits	struct(array(long))
,	O
xbits	struct(array(long))
;	O
register	O
int	O
c	int
;	O
if	O
(	O
net_input_level	()->(int)
(	O
)	O
<	O
0	int
&&	O
pty_input_level	()->(int)
(	O
)	O
<	O
0	int
)	O
break	O
;	O
FD_ZERO	O
(	O
&	O
ibits	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
obits	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
xbits	struct(array(long))
)	O
;	O
if	O
(	O
net_output_level	()->(int)
(	O
)	O
||	O
pty_input_level	()->(int)
(	O
)	O
>	O
0	int
)	O
FD_SET	O
(	O
net	int
,	O
&	O
obits	struct(array(long))
)	O
;	O
else	O
FD_SET	O
(	O
pty	int
,	O
&	O
ibits	struct(array(long))
)	O
;	O
if	O
(	O
pty_output_level	()->(int)
(	O
)	O
||	O
net_input_level	()->(int)
(	O
)	O
>	O
0	int
)	O
FD_SET	O
(	O
pty	int
,	O
&	O
obits	struct(array(long))
)	O
;	O
else	O
FD_SET	O
(	O
net	int
,	O
&	O
ibits	struct(array(long))
)	O
;	O
if	O
(	O
!	O
SYNCHing	int
)	O
FD_SET	O
(	O
net	int
,	O
&	O
xbits	struct(array(long))
)	O
;	O
if	O
(	O
(	O
c	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
nfd	int
,	O
&	O
ibits	struct(array(long))
,	O
&	O
obits	struct(array(long))
,	O
&	O
xbits	struct(array(long))
,	O
NULL	O
)	O
)	O
<=	O
0	int
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
sleep	(int)->(int)
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
xbits	struct(array(long))
)	O
)	O
SYNCHing	int
=	O
1	int
;	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
ibits	struct(array(long))
)	O
)	O
{	O
net_read	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
pty	int
,	O
&	O
ibits	struct(array(long))
)	O
)	O
{	O
if	O
(	O
pty_read	()->(int)
(	O
)	O
<	O
0	int
)	O
break	O
;	O
c	int
=	O
pty_get_char	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
c	int
&	O
TIOCPKT_IOCTL	int
)	O
{	O
pty_get_char	(int)->(int)
(	O
0	int
)	O
;	O
copy_termbuf	()->(void)
(	O
)	O
;	O
localstat	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
c	int
&	O
TIOCPKT_FLUSHWRITE	int
)	O
{	O
static	O
char	O
flushdata	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
DM	int
}	O
;	O
pty_get_char	(int)->(int)
(	O
0	int
)	O
;	O
netclear	()->(void)
(	O
)	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
flushdata	array(char)
,	O
sizeof	O
(	O
flushdata	array(char)
)	O
)	O
;	O
set_neturg	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send IAC"	*(char)
,	O
DM	int
)	O
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
&&	O
(	O
c	int
&	O
(	O
TIOCPKT_NOSTOP	int
|	O
TIOCPKT_DOSTOP	int
)	O
)	O
)	O
{	O
int	O
newflow	int
=	O
c	int
&	O
TIOCPKT_DOSTOP	int
?	O
1	int
:	O
0	int
;	O
if	O
(	O
newflow	int
!=	O
flowmode	int
)	O
{	O
net_output_data	(*(char))->(int)
(	O
"%c%c%c%c%c%c"	*(char)
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_LFLOW	int
,	O
flowmode	int
?	O
LFLOW_ON	int
:	O
LFLOW_OFF	int
,	O
IAC	int
,	O
SE	int
)	O
;	O
}	O
pty_get_char	(int)->(int)
(	O
0	int
)	O
;	O
}	O
}	O
while	O
(	O
pty_input_level	()->(int)
(	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
net_buffer_is_full	()->(int)
(	O
)	O
)	O
break	O
;	O
c	int
=	O
pty_get_char	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
c	int
==	O
IAC	int
)	O
net_output_byte	(int)->(void)
(	O
c	int
)	O
;	O
net_output_byte	(int)->(void)
(	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
&&	O
my_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
if	O
(	O
pty_input_level	()->(int)
(	O
)	O
>	O
0	int
&&	O
pty_get_char	(int)->(int)
(	O
1	int
)	O
==	O
'\n'	O
)	O
net_output_byte	(int)->(void)
(	O
pty_get_char	(int)->(int)
(	O
0	int
)	O
)	O
;	O
else	O
net_output_byte	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
obits	struct(array(long))
)	O
&&	O
net_output_level	()->(int)
(	O
)	O
>	O
0	int
)	O
netflush	()->(void)
(	O
)	O
;	O
if	O
(	O
net_input_level	()->(int)
(	O
)	O
>	O
0	int
)	O
telrcv	()->(void)
(	O
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
pty	int
,	O
&	O
obits	struct(array(long))
)	O
&&	O
pty_output_level	()->(int)
(	O
)	O
>	O
0	int
)	O
ptyflush	()->(void)
(	O
)	O
;	O
}	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
print_hostinfo	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
im	*(char)
=	O
NULL	O
;	O
char	O
*	O
str	*(char)
;	O
struct	O
utsname	struct(array(char),array(char),array(char),array(char),array(char),array(char))
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
;	O
if	O
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
(	O
&	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
)	O
==	O
0	int
)	O
{	O
im	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
UNAME_IM_PREFIX	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
sysname	array(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
release	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
UNAME_IM_SUFFIX	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
im	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
im	*(char)
,	O
"%s%s %s%s"	*(char)
,	O
UNAME_IM_PREFIX	*(char)
,	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
sysname	array(char)
,	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
release	array(char)
,	O
UNAME_IM_SUFFIX	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
im	*(char)
)	O
im	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"\r\n\nUNIX (%l) (%t)\r\n\n"	*(char)
)	O
;	O
str	*(char)
=	O
expand_line	(*(char))->(*(char))
(	O
im	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
im	*(char)
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"sending %s"	*(char)
,	O
str	*(char)
)	O
)	O
;	O
pty_input_putback	(*(char),long)->(int)
(	O
str	*(char)
,	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
}	O
