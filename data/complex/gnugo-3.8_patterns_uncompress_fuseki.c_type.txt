static	O
const	O
char	O
*	O
const	O
db_output_strings	array(*(char))
[	O
3	int
]	O
=	O
{	O
DB_PREAMBLE	*(char)
,	O
DB_HEADER	*(char)
,	O
DB_FOOTER	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
const	O
c_output_strings	array(*(char))
[	O
3	int
]	O
=	O
{	O
C_PREAMBLE	*(char)
,	O
C_HEADER	*(char)
,	O
C_FOOTER	*(char)
}	O
;	O
static	O
int	O
set_boards	(array(array(char)),array(char),*(char),char,int)->(int)
(	O
char	O
board	*(char)
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
2	int
]	O
,	O
Intersection	char
board1d	array(char)
[	O
BOARDSIZE	O
]	O
,	O
char	O
*	O
stones	*(int)
,	O
char	O
color	int
,	O
int	O
boardsize	int
)	O
{	O
int	O
i	int
=	O
stones	*(int)
[	O
1	int
]	O
-	O
'a'	O
+	O
1	int
;	O
int	O
j	int
=	O
stones	*(int)
[	O
0	int
]	O
-	O
'a'	O
+	O
1	int
;	O
if	O
(	O
stones	*(int)
[	O
0	int
]	O
!=	O
't'	O
)	O
{	O
assert	O
(	O
i	int
>	O
0	int
&&	O
i	int
<	O
boardsize	int
+	O
2	int
)	O
;	O
board	*(char)
[	O
i	int
]	O
[	O
j	int
]	O
=	O
color	int
;	O
if	O
(	O
color	int
==	O
'O'	O
)	O
board1d	array(char)
[	O
POS	O
(	O
i	int
-	O
1	int
,	O
j	int
-	O
1	int
)	O
]	O
=	O
WHITE	int
;	O
else	O
if	O
(	O
color	int
==	O
'X'	O
)	O
board1d	array(char)
[	O
POS	O
(	O
i	int
-	O
1	int
,	O
j	int
-	O
1	int
)	O
]	O
=	O
BLACK	int
;	O
return	O
POS	O
(	O
i	int
-	O
1	int
,	O
j	int
-	O
1	int
)	O
;	O
}	O
else	O
return	O
NO_MOVE	O
;	O
}	O
static	O
void	O
write_pattern	(*(char),array(array(char)),int,int)->(void)
(	O
char	O
*	O
name	short
,	O
char	O
board	*(char)
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
2	int
]	O
,	O
int	O
value	*(char)
,	O
int	O
boardsize	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
printf	(*(char))->(int)
(	O
"Pattern %s\n\n"	*(char)
,	O
name	short
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
boardsize	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
boardsize	int
+	O
1	int
;	O
j	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
board	*(char)
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n:8,-,value(%d)\n\n\n"	*(char)
,	O
value	*(char)
)	O
;	O
}	O
static	O
void	O
write_pattern_c_code	(*(char),array(char),int,int,int,int)->(void)
(	O
char	O
*	O
name	short
,	O
Intersection	char
board1d	array(char)
[	O
BOARDSIZE	O
]	O
,	O
int	O
move_pos	int
,	O
int	O
value	*(char)
,	O
int	O
boardsize	int
,	O
int	O
patlen	int
)	O
{	O
int	O
k	int
;	O
Hash_data	struct(array(long))
pattern_hash	struct(array(long))
;	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
pattern_hash	struct(array(long))
,	O
board1d	array(char)
,	O
NO_MOVE	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  {{{"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_HASHVALUES	O
;	O
k	int
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"0x%lx"	*(char)
,	O
pattern_hash	struct(array(long))
.	O
hashval	array(long)
[	O
k	int
]	O
)	O
;	O
if	O
(	O
k	int
<	O
NUM_HASHVALUES	O
-	O
1	int
)	O
printf	(*(char))->(int)
(	O
","	*(char)
)	O
;	O
}	O
if	O
(	O
name	short
)	O
printf	(*(char))->(int)
(	O
"}},%d,\"%s\",%d,%d},\n"	*(char)
,	O
patlen	int
,	O
name	short
,	O
OFFSET	O
(	O
I	O
(	O
move_pos	int
)	O
-	O
(	O
boardsize	int
-	O
1	int
)	O
/	O
2	int
,	O
J	O
(	O
move_pos	int
)	O
-	O
(	O
boardsize	int
-	O
1	int
)	O
/	O
2	int
)	O
,	O
value	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"}},-1,NULL,0,0},\n"	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
const	O
char	O
*	O
filename	*(char)
;	O
FILE	struct
*	O
input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
const	O
char	O
*	O
const	O
*	O
output_strings	*(*(char))
;	O
int	O
mode	int
;	O
int	O
move_pos	int
;	O
char	O
line	int
[	O
BUFSIZE	int
]	O
;	O
char	O
name	short
[	O
BUFSIZE	int
]	O
;	O
char	O
stones	*(int)
[	O
BUFSIZE	int
]	O
;	O
int	O
value	*(char)
;	O
char	O
board	*(char)
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
2	int
]	O
;	O
Intersection	char
board1d	array(char)
[	O
BOARDSIZE	O
]	O
;	O
int	O
boardsize	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
int	O
pos	int
;	O
char	O
color	int
;	O
if	O
(	O
argc	int
!=	O
4	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
USAGE	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
boardsize	int
=	O
atoi	(*(char))->(int)
(	O
argv	array(*(char))
[	O
1	int
]	O
)	O
;	O
filename	*(char)
=	O
argv	array(*(char))
[	O
2	int
]	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	array(*(char))
[	O
3	int
]	O
,	O
"c"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
mode	int
=	O
C_OUTPUT	int
;	O
output_strings	*(*(char))
=	O
c_output_strings	array(*(char))
;	O
set_random_seed	(int)->(void)
(	O
HASH_RANDOM_SEED	int
)	O
;	O
hash_init	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	array(*(char))
[	O
3	int
]	O
,	O
"db"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
{	O
mode	int
=	O
DB_OUTPUT	int
;	O
output_strings	*(*(char))
=	O
db_output_strings	array(*(char))
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
USAGE	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
assert	O
(	O
boardsize	int
>	O
0	int
)	O
;	O
if	O
(	O
boardsize	int
>	O
MAX_BOARD	int
)	O
{	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
PREAMBLE	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
HEADER	int
]	O
,	O
boardsize	int
)	O
;	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
FOOTER	int
]	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"uncompress_fuseki: Cannot open file %s\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
board	*(char)
[	O
0	int
]	O
[	O
0	int
]	O
=	O
'+'	O
;	O
board	*(char)
[	O
0	int
]	O
[	O
boardsize	int
+	O
1	int
]	O
=	O
'+'	O
;	O
board	*(char)
[	O
boardsize	int
+	O
1	int
]	O
[	O
0	int
]	O
=	O
'+'	O
;	O
board	*(char)
[	O
boardsize	int
+	O
1	int
]	O
[	O
boardsize	int
+	O
1	int
]	O
=	O
'+'	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
boardsize	int
;	O
k	int
++	O
)	O
{	O
board	*(char)
[	O
0	int
]	O
[	O
k	int
]	O
=	O
'-'	O
;	O
board	*(char)
[	O
boardsize	int
+	O
1	int
]	O
[	O
k	int
]	O
=	O
'-'	O
;	O
board	*(char)
[	O
k	int
]	O
[	O
0	int
]	O
=	O
'|'	O
;	O
board	*(char)
[	O
k	int
]	O
[	O
boardsize	int
+	O
1	int
]	O
=	O
'|'	O
;	O
}	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
PREAMBLE	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
HEADER	int
]	O
,	O
boardsize	int
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	int
,	O
BUFSIZE	int
,	O
input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
int	O
num_stones	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
boardsize	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
boardsize	int
;	O
j	int
++	O
)	O
board	*(char)
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'.'	O
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
BOARDSIZE	O
;	O
pos	int
++	O
)	O
if	O
(	O
I	O
(	O
pos	int
)	O
>=	O
0	int
&&	O
I	O
(	O
pos	int
)	O
<	O
boardsize	int
&&	O
J	O
(	O
pos	int
)	O
>=	O
0	int
&&	O
J	O
(	O
pos	int
)	O
<	O
boardsize	int
)	O
board1d	array(char)
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
else	O
board1d	array(char)
[	O
pos	int
]	O
=	O
GRAY	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
line	int
,	O
"%s %d %s"	*(char)
,	O
name	short
,	O
&	O
value	*(char)
,	O
stones	*(int)
)	O
!=	O
3	int
)	O
continue	O
;	O
move_pos	int
=	O
set_boards	(array(array(char)),array(char),*(char),char,int)->(int)
(	O
board	*(char)
,	O
board1d	array(char)
,	O
stones	*(int)
,	O
'*'	O
,	O
boardsize	int
)	O
;	O
color	int
=	O
'X'	O
;	O
for	O
(	O
k	int
=	O
2	int
;	O
k	int
<	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
stones	*(int)
)	O
;	O
k	int
+=	O
2	int
)	O
{	O
pos	int
=	O
set_boards	(array(array(char)),array(char),*(char),char,int)->(int)
(	O
board	*(char)
,	O
board1d	array(char)
,	O
stones	*(int)
+	O
k	int
,	O
color	int
,	O
boardsize	int
)	O
;	O
if	O
(	O
I	O
(	O
pos	int
)	O
>=	O
0	int
&&	O
I	O
(	O
pos	int
)	O
<	O
boardsize	int
&&	O
J	O
(	O
pos	int
)	O
>=	O
0	int
&&	O
J	O
(	O
pos	int
)	O
<	O
boardsize	int
)	O
num_stones	int
++	O
;	O
if	O
(	O
color	int
==	O
'X'	O
)	O
color	int
=	O
'O'	O
;	O
else	O
color	int
=	O
'X'	O
;	O
}	O
if	O
(	O
mode	int
==	O
DB_OUTPUT	int
)	O
write_pattern	(*(char),array(array(char)),int,int)->(void)
(	O
name	short
,	O
board	*(char)
,	O
value	*(char)
,	O
boardsize	int
)	O
;	O
else	O
write_pattern_c_code	(*(char),array(char),int,int,int,int)->(void)
(	O
name	short
,	O
board1d	array(char)
,	O
move_pos	int
,	O
value	*(char)
,	O
boardsize	int
,	O
num_stones	int
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
C_OUTPUT	int
)	O
write_pattern_c_code	(*(char),array(char),int,int,int,int)->(void)
(	O
NULL	O
,	O
board1d	array(char)
,	O
NO_MOVE	O
,	O
0	int
,	O
boardsize	int
,	O
-	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
output_strings	*(*(char))
[	O
FOOTER	int
]	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
