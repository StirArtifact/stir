enum	O
format_cdr_type	O
{	O
FCT_REQUIRED	O
,	O
FCT_OPTIONAL	O
}	O
;	O
enum	O
format_arg_type	O
{	O
FAT_OBJECT	O
,	O
FAT_CHARACTER_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER	O
,	O
FAT_REAL	O
,	O
FAT_LIST	O
,	O
FAT_FORMATSTRING	O
,	O
FAT_FUNCTION	O
}	O
;	O
struct	O
format_arg	O
{	O
unsigned	O
int	O
repcount	O
;	O
enum	O
format_cdr_type	O
presence	O
;	O
enum	O
format_arg_type	O
type	O
;	O
struct	O
format_arg_list	O
*	O
list	O
;	O
}	O
;	O
struct	O
segment	O
{	O
unsigned	O
int	O
count	O
;	O
unsigned	O
int	O
allocated	O
;	O
struct	O
format_arg	O
*	O
element	O
;	O
unsigned	O
int	O
length	O
;	O
}	O
;	O
struct	O
format_arg_list	O
{	O
struct	O
segment	O
initial	O
;	O
struct	O
segment	O
repeated	O
;	O
}	O
;	O
struct	O
spec	O
{	O
unsigned	O
int	O
directives	O
;	O
struct	O
format_arg_list	O
*	O
list	O
;	O
}	O
;	O
enum	O
param_type	O
{	O
PT_NIL	O
,	O
PT_CHARACTER	O
,	O
PT_INTEGER	O
,	O
PT_ARGCOUNT	O
,	O
PT_V	O
}	O
;	O
struct	O
param	O
{	O
enum	O
param_type	O
type	O
;	O
int	O
value	O
;	O
}	O
;	O
static	O
void	O
verify_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
)	O
;	O
static	O
void	O
free_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
;	O
static	O
struct	O
format_arg_list	O
*	O
copy_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
)	O
;	O
static	O
bool	bool
equal_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
const	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
;	O
static	O
struct	O
format_arg_list	O
*	O
make_intersected_list	O
(	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
;	O
static	O
struct	O
format_arg_list	O
*	O
make_intersection_with_empty_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
;	O
static	O
struct	O
format_arg_list	O
*	O
make_union_list	O
(	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
;	O
static	O
void	O
verify_element	O
(	O
const	O
struct	O
format_arg	O
*	O
e	O
)	O
{	O
ASSERT	O
(	O
e	O
->	O
repcount	O
>	O
0	int
)	O
;	O
if	O
(	O
e	O
->	O
type	O
==	O
FAT_LIST	O
)	O
verify_list	O
(	O
e	O
->	O
list	O
)	O
;	O
}	O
static	O
void	O
verify_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
unsigned	O
int	O
i	long
;	O
unsigned	O
int	O
total_repcount	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
count	O
<=	O
list	O
->	O
initial	O
.	O
allocated	O
)	O
;	O
total_repcount	O
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
initial	O
.	O
count	O
;	O
i	long
++	O
)	O
{	O
verify_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
total_repcount	O
+=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
}	O
ASSERT	O
(	O
total_repcount	O
==	O
list	O
->	O
initial	O
.	O
length	O
)	O
;	O
ASSERT	O
(	O
list	O
->	O
repeated	O
.	O
count	O
<=	O
list	O
->	O
repeated	O
.	O
allocated	O
)	O
;	O
total_repcount	O
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
{	O
verify_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
total_repcount	O
+=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
}	O
ASSERT	O
(	O
total_repcount	O
==	O
list	O
->	O
repeated	O
.	O
length	O
)	O
;	O
}	O
static	O
inline	O
void	O
free_element	O
(	O
struct	O
format_arg	O
*	O
element	O
)	O
{	O
if	O
(	O
element	O
->	O
type	O
==	O
FAT_LIST	O
)	O
free_list	O
(	O
element	O
->	O
list	O
)	O
;	O
}	O
static	O
void	O
free_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
initial	O
.	O
count	O
;	O
i	long
++	O
)	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
list	O
->	O
initial	O
.	O
element	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
free_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
list	O
->	O
repeated	O
.	O
element	O
)	O
;	O
}	O
static	O
inline	O
void	O
copy_element	O
(	O
struct	O
format_arg	O
*	O
newelement	O
,	O
const	O
struct	O
format_arg	O
*	O
oldelement	O
)	O
{	O
newelement	O
->	O
repcount	O
=	O
oldelement	O
->	O
repcount	O
;	O
newelement	O
->	O
presence	O
=	O
oldelement	O
->	O
presence	O
;	O
newelement	O
->	O
type	O
=	O
oldelement	O
->	O
type	O
;	O
if	O
(	O
oldelement	O
->	O
type	O
==	O
FAT_LIST	O
)	O
newelement	O
->	O
list	O
=	O
copy_list	O
(	O
oldelement	O
->	O
list	O
)	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
copy_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
struct	O
format_arg_list	O
*	O
newlist	O
;	O
unsigned	O
int	O
length	O
;	O
unsigned	O
int	O
i	long
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
newlist	O
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
newlist	O
->	O
initial	O
.	O
count	O
=	O
newlist	O
->	O
initial	O
.	O
allocated	O
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
length	O
=	O
0	int
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
count	O
==	O
0	int
)	O
newlist	O
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
else	O
{	O
newlist	O
->	O
initial	O
.	O
element	O
=	O
XNMALLOC	O
(	O
newlist	O
->	O
initial	O
.	O
allocated	O
,	O
struct	O
format_arg	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
initial	O
.	O
count	O
;	O
i	long
++	O
)	O
{	O
copy_element	O
(	O
&	O
newlist	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
length	O
+=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
}	O
}	O
ASSERT	O
(	O
length	O
==	O
list	O
->	O
initial	O
.	O
length	O
)	O
;	O
newlist	O
->	O
initial	O
.	O
length	O
=	O
length	O
;	O
newlist	O
->	O
repeated	O
.	O
count	O
=	O
newlist	O
->	O
repeated	O
.	O
allocated	O
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
length	O
=	O
0	int
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
newlist	O
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
else	O
{	O
newlist	O
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
newlist	O
->	O
repeated	O
.	O
allocated	O
,	O
struct	O
format_arg	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
{	O
copy_element	O
(	O
&	O
newlist	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
length	O
+=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
}	O
}	O
ASSERT	O
(	O
length	O
==	O
list	O
->	O
repeated	O
.	O
length	O
)	O
;	O
newlist	O
->	O
repeated	O
.	O
length	O
=	O
length	O
;	O
VERIFY_LIST	O
(	O
newlist	O
)	O
;	O
return	O
newlist	O
;	O
}	O
static	O
bool	bool
equal_element	O
(	O
const	O
struct	O
format_arg	O
*	O
e1	O
,	O
const	O
struct	O
format_arg	O
*	O
e2	O
)	O
{	O
return	O
(	O
e1	O
->	O
presence	O
==	O
e2	O
->	O
presence	O
&&	O
e1	O
->	O
type	O
==	O
e2	O
->	O
type	O
&&	O
(	O
e1	O
->	O
type	O
==	O
FAT_LIST	O
?	O
equal_list	O
(	O
e1	O
->	O
list	O
,	O
e2	O
->	O
list	O
)	O
:	O
true	O
)	O
)	O
;	O
}	O
static	O
bool	bool
equal_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
const	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
;	O
VERIFY_LIST	O
(	O
list1	O
)	O
;	O
VERIFY_LIST	O
(	O
list2	O
)	O
;	O
n	long
=	O
list1	O
->	O
initial	O
.	O
count	O
;	O
if	O
(	O
n	long
!=	O
list2	O
->	O
initial	O
.	O
count	O
)	O
return	O
false	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
const	O
struct	O
format_arg	O
*	O
e1	O
=	O
&	O
list1	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
const	O
struct	O
format_arg	O
*	O
e2	O
=	O
&	O
list2	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
e1	O
->	O
repcount	O
==	O
e2	O
->	O
repcount	O
&&	O
equal_element	O
(	O
e1	O
,	O
e2	O
)	O
)	O
)	O
return	O
false	O
;	O
}	O
n	long
=	O
list1	O
->	O
repeated	O
.	O
count	O
;	O
if	O
(	O
n	long
!=	O
list2	O
->	O
repeated	O
.	O
count	O
)	O
return	O
false	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
const	O
struct	O
format_arg	O
*	O
e1	O
=	O
&	O
list1	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
;	O
const	O
struct	O
format_arg	O
*	O
e2	O
=	O
&	O
list2	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
e1	O
->	O
repcount	O
==	O
e2	O
->	O
repcount	O
&&	O
equal_element	O
(	O
e1	O
,	O
e2	O
)	O
)	O
)	O
return	O
false	O
;	O
}	O
return	O
true	O
;	O
}	O
static	O
inline	O
void	O
ensure_initial_alloc	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
newcount	O
)	O
{	O
if	O
(	O
newcount	O
>	O
list	O
->	O
initial	O
.	O
allocated	O
)	O
{	O
list	O
->	O
initial	O
.	O
allocated	O
=	O
MAX	O
(	O
2	int
*	O
list	O
->	O
initial	O
.	O
allocated	O
+	O
1	int
,	O
newcount	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
=	O
(	O
struct	O
format_arg	O
*	O
)	O
xrealloc	O
(	O
list	O
->	O
initial	O
.	O
element	O
,	O
list	O
->	O
initial	O
.	O
allocated	O
*	O
sizeof	O
(	O
struct	O
format_arg	O
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
grow_initial_alloc	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
if	O
(	O
list	O
->	O
initial	O
.	O
count	O
>=	O
list	O
->	O
initial	O
.	O
allocated	O
)	O
{	O
list	O
->	O
initial	O
.	O
allocated	O
=	O
MAX	O
(	O
2	int
*	O
list	O
->	O
initial	O
.	O
allocated	O
+	O
1	int
,	O
list	O
->	O
initial	O
.	O
count	O
+	O
1	int
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
=	O
(	O
struct	O
format_arg	O
*	O
)	O
xrealloc	O
(	O
list	O
->	O
initial	O
.	O
element	O
,	O
list	O
->	O
initial	O
.	O
allocated	O
*	O
sizeof	O
(	O
struct	O
format_arg	O
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
ensure_repeated_alloc	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
newcount	O
)	O
{	O
if	O
(	O
newcount	O
>	O
list	O
->	O
repeated	O
.	O
allocated	O
)	O
{	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
MAX	O
(	O
2	int
*	O
list	O
->	O
repeated	O
.	O
allocated	O
+	O
1	int
,	O
newcount	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
(	O
struct	O
format_arg	O
*	O
)	O
xrealloc	O
(	O
list	O
->	O
repeated	O
.	O
element	O
,	O
list	O
->	O
repeated	O
.	O
allocated	O
*	O
sizeof	O
(	O
struct	O
format_arg	O
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
grow_repeated_alloc	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
>=	O
list	O
->	O
repeated	O
.	O
allocated	O
)	O
{	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
MAX	O
(	O
2	int
*	O
list	O
->	O
repeated	O
.	O
allocated	O
+	O
1	int
,	O
list	O
->	O
repeated	O
.	O
count	O
+	O
1	int
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
(	O
struct	O
format_arg	O
*	O
)	O
xrealloc	O
(	O
list	O
->	O
repeated	O
.	O
element	O
,	O
list	O
->	O
repeated	O
.	O
allocated	O
*	O
sizeof	O
(	O
struct	O
format_arg	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
normalize_outermost_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
,	O
j	O
;	O
n	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
for	O
(	O
i	long
=	O
j	O
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
j	O
>	O
0	int
&&	O
equal_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
j	O
-	O
1	int
]	O
)	O
)	O
{	O
list	O
->	O
initial	O
.	O
element	O
[	O
j	O
-	O
1	int
]	O
.	O
repcount	O
+=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
j	O
<	O
i	long
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
j	O
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
j	O
++	O
;	O
}	O
list	O
->	O
initial	O
.	O
count	O
=	O
j	O
;	O
n	long
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
for	O
(	O
i	long
=	O
j	O
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
j	O
>	O
0	int
&&	O
equal_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
-	O
1	int
]	O
)	O
)	O
{	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
-	O
1	int
]	O
.	O
repcount	O
+=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
free_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
j	O
<	O
i	long
)	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
;	O
j	O
++	O
;	O
}	O
list	O
->	O
repeated	O
.	O
count	O
=	O
j	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
m	O
,	O
repcount0_extra	O
;	O
n	long
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
repcount0_extra	O
=	O
0	int
;	O
if	O
(	O
n	long
>	O
1	int
&&	O
equal_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
n	long
-	O
1	int
]	O
)	O
)	O
{	O
repcount0_extra	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
n	long
-	O
1	int
]	O
.	O
repcount	O
;	O
n	long
--	O
;	O
}	O
for	O
(	O
m	O
=	O
2	int
;	O
m	O
<=	O
n	long
/	O
2	int
;	O
n	long
++	O
)	O
if	O
(	O
(	O
n	long
%	O
m	O
)	O
==	O
0	int
)	O
{	O
bool	bool
ok	O
=	O
true	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
-	O
m	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
(	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
+	O
(	O
i	long
==	O
0	int
?	O
repcount0_extra	O
:	O
0	int
)	O
==	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
+	O
m	O
]	O
.	O
repcount	O
)	O
&&	O
equal_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
+	O
m	O
]	O
)	O
)	O
)	O
{	O
ok	O
=	O
false	O
;	O
break	O
;	O
}	O
if	O
(	O
ok	O
)	O
{	O
for	O
(	O
i	long
=	O
m	O
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
free_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
if	O
(	O
n	long
<	O
list	O
->	O
repeated	O
.	O
count	O
)	O
list	O
->	O
repeated	O
.	O
element	O
[	O
m	O
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
n	long
]	O
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
list	O
->	O
repeated	O
.	O
count	O
-	O
n	long
+	O
m	O
;	O
list	O
->	O
repeated	O
.	O
length	O
/=	O
n	long
/	O
m	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
1	int
)	O
{	O
if	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
&&	O
equal_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
)	O
)	O
{	O
list	O
->	O
initial	O
.	O
length	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
;	O
list	O
->	O
initial	O
.	O
count	O
--	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
&&	O
equal_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
)	O
)	O
{	O
unsigned	O
int	O
moved_repcount	O
=	O
MIN	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
,	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
)	O
;	O
if	O
(	O
equal_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
)	O
)	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
+=	O
moved_repcount	O
;	O
else	O
{	O
unsigned	O
int	O
newcount	O
=	O
list	O
->	O
repeated	O
.	O
count	O
+	O
1	int
;	O
ensure_repeated_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
for	O
(	O
i	long
=	O
newcount	O
-	O
1	int
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
-	O
1	int
]	O
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
newcount	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
=	O
moved_repcount	O
;	O
}	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
-=	O
moved_repcount	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
==	O
0	int
)	O
{	O
free_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
list	O
->	O
repeated	O
.	O
count	O
-	O
1	int
]	O
)	O
;	O
list	O
->	O
repeated	O
.	O
count	O
--	O
;	O
}	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
-=	O
moved_repcount	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
.	O
repcount	O
==	O
0	int
)	O
{	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
--	O
;	O
}	O
list	O
->	O
initial	O
.	O
length	O
-=	O
moved_repcount	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
normalize_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
n	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
type	O
==	O
FAT_LIST	O
)	O
normalize_list	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
list	O
)	O
;	O
n	long
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
type	O
==	O
FAT_LIST	O
)	O
normalize_list	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
.	O
list	O
)	O
;	O
normalize_outermost_list	O
(	O
list	O
)	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_unconstrained_list	O
(	O
)	O
{	O
struct	O
format_arg_list	O
*	O
list	O
;	O
list	O
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
1	int
;	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
1	int
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
1	int
,	O
struct	O
format_arg	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
=	O
1	int
;	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
type	O
=	O
FAT_OBJECT	O
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
1	int
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_empty_list	O
(	O
)	O
{	O
struct	O
format_arg_list	O
*	O
list	O
;	O
list	O
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
bool	bool
is_empty_list	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
return	O
(	O
list	O
->	O
initial	O
.	O
count	O
==	O
0	int
&&	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
;	O
}	O
static	O
void	O
unfold_loop	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
m	O
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	O
,	O
k	O
;	O
if	O
(	O
m	O
>	O
1	int
)	O
{	O
unsigned	O
int	O
newcount	O
=	O
list	O
->	O
repeated	O
.	O
count	O
*	O
m	O
;	O
ensure_repeated_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
i	long
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
for	O
(	O
k	O
=	O
1	int
;	O
k	O
<	O
m	O
;	O
k	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
j	O
++	O
,	O
i	long
++	O
)	O
copy_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
)	O
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
newcount	O
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
list	O
->	O
repeated	O
.	O
length	O
*	O
m	O
;	O
}	O
}	O
static	O
void	O
rotate_loop	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
m	O
)	O
{	O
if	O
(	O
m	O
==	O
list	O
->	O
initial	O
.	O
length	O
)	O
return	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
newcount	O
;	O
newcount	O
=	O
list	O
->	O
initial	O
.	O
count	O
+	O
1	int
;	O
ensure_initial_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
=	O
m	O
-	O
list	O
->	O
initial	O
.	O
length	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
newcount	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
m	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
n	long
=	O
list	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
q	O
=	O
(	O
m	O
-	O
list	O
->	O
initial	O
.	O
length	O
)	O
/	O
n	long
;	O
unsigned	O
int	O
r	O
=	O
(	O
m	O
-	O
list	O
->	O
initial	O
.	O
length	O
)	O
%	O
n	long
;	O
unsigned	O
int	O
s	*(char)
;	O
unsigned	O
int	O
t	O
;	O
for	O
(	O
t	O
=	O
r	O
,	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
list	O
->	O
repeated	O
.	O
count	O
&&	O
t	O
>=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
t	O
-=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
,	O
s	*(char)
++	O
)	O
;	O
ASSERT	O
(	O
s	*(char)
<	O
list	O
->	O
repeated	O
.	O
count	O
)	O
;	O
{	O
unsigned	O
int	O
i	long
,	O
j	O
,	O
k	O
,	O
newcount	O
;	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
newcount	O
=	O
i	long
+	O
q	O
*	O
list	O
->	O
repeated	O
.	O
count	O
+	O
s	*(char)
+	O
(	O
t	O
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ensure_initial_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
q	O
;	O
k	O
++	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
j	O
++	O
,	O
i	long
++	O
)	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
s	*(char)
;	O
j	O
++	O
,	O
i	long
++	O
)	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
)	O
;	O
if	O
(	O
t	O
>	O
0	int
)	O
{	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
=	O
t	O
;	O
i	long
++	O
;	O
}	O
ASSERT	O
(	O
i	long
==	O
newcount	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
newcount	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
m	O
;	O
}	O
if	O
(	O
r	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	O
,	O
oldcount	O
,	O
newcount	O
;	O
struct	O
format_arg	O
*	O
newelement	O
;	O
oldcount	O
=	O
list	O
->	O
repeated	O
.	O
count	O
;	O
newcount	O
=	O
list	O
->	O
repeated	O
.	O
count	O
+	O
(	O
t	O
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
newelement	O
=	O
XNMALLOC	O
(	O
newcount	O
,	O
struct	O
format_arg	O
)	O
;	O
i	long
=	O
0	int
;	O
for	O
(	O
j	O
=	O
s	*(char)
;	O
j	O
<	O
oldcount	O
;	O
j	O
++	O
,	O
i	long
++	O
)	O
newelement	O
[	O
i	long
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
s	*(char)
;	O
j	O
++	O
,	O
i	long
++	O
)	O
newelement	O
[	O
i	long
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
;	O
if	O
(	O
t	O
>	O
0	int
)	O
{	O
copy_element	O
(	O
&	O
newelement	O
[	O
oldcount	O
]	O
,	O
&	O
newelement	O
[	O
0	int
]	O
)	O
;	O
newelement	O
[	O
0	int
]	O
.	O
repcount	O
-=	O
t	O
;	O
newelement	O
[	O
oldcount	O
]	O
.	O
repcount	O
=	O
t	O
;	O
}	O
free	(*(void))->(void)
(	O
list	O
->	O
repeated	O
.	O
element	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
newelement	O
;	O
}	O
}	O
}	O
static	O
unsigned	O
int	O
initial_splitelement	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	*(char)
;	O
unsigned	O
int	O
t	O
;	O
unsigned	O
int	O
oldrepcount	O
;	O
unsigned	O
int	O
newcount	O
;	O
unsigned	O
int	O
i	long
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
n	long
>	O
list	O
->	O
initial	O
.	O
length	O
)	O
{	O
ASSERT	O
(	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
)	O
;	O
rotate_loop	O
(	O
list	O
,	O
n	long
)	O
;	O
ASSERT	O
(	O
n	long
<=	O
list	O
->	O
initial	O
.	O
length	O
)	O
;	O
}	O
for	O
(	O
t	O
=	O
n	long
,	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
&&	O
t	O
>=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
t	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
,	O
s	*(char)
++	O
)	O
;	O
if	O
(	O
t	O
==	O
0	int
)	O
return	O
s	*(char)
;	O
ASSERT	O
(	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
)	O
;	O
oldrepcount	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
newcount	O
=	O
list	O
->	O
initial	O
.	O
count	O
+	O
1	int
;	O
ensure_initial_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
for	O
(	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
;	O
i	long
>	O
s	*(char)
;	O
i	long
--	O
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
+	O
1	int
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
=	O
t	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
.	O
repcount	O
=	O
oldrepcount	O
-	O
t	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
newcount	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
s	*(char)
+	O
1	int
;	O
}	O
static	O
unsigned	O
int	O
initial_unshare	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	*(char)
;	O
unsigned	O
int	O
t	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
n	long
>=	O
list	O
->	O
initial	O
.	O
length	O
)	O
{	O
ASSERT	O
(	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
)	O
;	O
rotate_loop	O
(	O
list	O
,	O
n	long
+	O
1	int
)	O
;	O
ASSERT	O
(	O
n	long
<	O
list	O
->	O
initial	O
.	O
length	O
)	O
;	O
}	O
for	O
(	O
t	O
=	O
n	long
,	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
&&	O
t	O
>=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
t	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
,	O
s	*(char)
++	O
)	O
;	O
ASSERT	O
(	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
)	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
>	O
1	int
)	O
{	O
unsigned	O
int	O
oldrepcount	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
unsigned	O
int	O
newcount	O
=	O
list	O
->	O
initial	O
.	O
count	O
+	O
(	O
t	O
==	O
0	int
||	O
t	O
==	O
oldrepcount	O
-	O
1	int
?	O
1	int
:	O
2	int
)	O
;	O
ensure_initial_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
if	O
(	O
t	O
==	O
0	int
||	O
t	O
==	O
oldrepcount	O
-	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
;	O
i	long
>	O
s	*(char)
;	O
i	long
--	O
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
+	O
1	int
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
if	O
(	O
t	O
==	O
0	int
)	O
{	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
=	O
1	int
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
.	O
repcount	O
=	O
oldrepcount	O
-	O
1	int
;	O
}	O
else	O
{	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
=	O
oldrepcount	O
-	O
1	int
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
.	O
repcount	O
=	O
1	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
;	O
i	long
>	O
s	*(char)
;	O
i	long
--	O
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
+	O
2	int
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
2	int
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
=	O
t	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
1	int
]	O
.	O
repcount	O
=	O
1	int
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
+	O
2	int
]	O
.	O
repcount	O
=	O
oldrepcount	O
-	O
1	int
-	O
t	O
;	O
}	O
list	O
->	O
initial	O
.	O
count	O
=	O
newcount	O
;	O
if	O
(	O
t	O
>	O
0	int
)	O
s	*(char)
++	O
;	O
}	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
==	O
1	int
)	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
s	*(char)
;	O
}	O
static	O
void	O
shift_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
grow_initial_alloc	O
(	O
list	O
)	O
;	O
for	O
(	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
-	O
1	int
]	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
=	O
n	long
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
=	O
FCT_REQUIRED	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
type	O
=	O
FAT_OBJECT	O
;	O
list	O
->	O
initial	O
.	O
count	O
++	O
;	O
list	O
->	O
initial	O
.	O
length	O
+=	O
n	long
;	O
normalize_outermost_list	O
(	O
list	O
)	O
;	O
}	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
}	O
static	O
bool	bool
make_intersected_element	O
(	O
struct	O
format_arg	O
*	O
re	O
,	O
const	O
struct	O
format_arg	O
*	O
e1	O
,	O
const	O
struct	O
format_arg	O
*	O
e2	O
)	O
{	O
if	O
(	O
e1	O
->	O
presence	O
==	O
FCT_REQUIRED	O
||	O
e2	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
re	O
->	O
presence	O
=	O
FCT_REQUIRED	O
;	O
else	O
re	O
->	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_OBJECT	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
if	O
(	O
re	O
->	O
type	O
==	O
FAT_LIST	O
)	O
re	O
->	O
list	O
=	O
copy_list	O
(	O
e2	O
->	O
list	O
)	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_OBJECT	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
if	O
(	O
re	O
->	O
type	O
==	O
FAT_LIST	O
)	O
re	O
->	O
list	O
=	O
copy_list	O
(	O
e1	O
->	O
list	O
)	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_LIST	O
&&	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
re	O
->	O
list	O
=	O
make_intersection_with_empty_list	O
(	O
e1	O
->	O
list	O
)	O
;	O
if	O
(	O
re	O
->	O
list	O
==	O
NULL	O
)	O
return	O
false	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_LIST	O
&&	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
re	O
->	O
list	O
=	O
make_intersection_with_empty_list	O
(	O
e2	O
->	O
list	O
)	O
;	O
if	O
(	O
re	O
->	O
list	O
==	O
NULL	O
)	O
return	O
false	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
&&	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
&&	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_REAL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_REAL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
e2	O
->	O
type	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
if	O
(	O
re	O
->	O
type	O
==	O
FAT_LIST	O
)	O
{	O
re	O
->	O
list	O
=	O
make_intersected_list	O
(	O
copy_list	O
(	O
e1	O
->	O
list	O
)	O
,	O
copy_list	O
(	O
e2	O
->	O
list	O
)	O
)	O
;	O
if	O
(	O
re	O
->	O
list	O
==	O
NULL	O
)	O
return	O
false	O
;	O
}	O
}	O
else	O
return	O
false	O
;	O
return	O
true	O
;	O
}	O
static	O
void	O
append_repeated_to_initial	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	O
,	O
newcount	O
;	O
newcount	O
=	O
list	O
->	O
initial	O
.	O
count	O
+	O
list	O
->	O
repeated	O
.	O
count	O
;	O
ensure_initial_alloc	O
(	O
list	O
,	O
newcount	O
)	O
;	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
j	O
++	O
,	O
i	long
++	O
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
newcount	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
list	O
->	O
initial	O
.	O
length	O
+	O
list	O
->	O
repeated	O
.	O
length	O
;	O
free	(*(void))->(void)
(	O
list	O
->	O
repeated	O
.	O
element	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
}	O
}	O
static	O
struct	O
format_arg_list	O
*	O
backtrack_in_initial	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
ASSERT	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
;	O
while	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
=	O
list	O
->	O
initial	O
.	O
count	O
-	O
1	int
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
list	O
->	O
initial	O
.	O
length	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
i	long
;	O
}	O
else	O
{	O
list	O
->	O
initial	O
.	O
length	O
--	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
>	O
1	int
)	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
--	O
;	O
else	O
{	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
i	long
;	O
}	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
}	O
free_list	O
(	O
list	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_intersected_list	O
(	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
{	O
struct	O
format_arg_list	O
*	O
result	*(*(void))
;	O
VERIFY_LIST	O
(	O
list1	O
)	O
;	O
VERIFY_LIST	O
(	O
list2	O
)	O
;	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
&&	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
n1	O
=	O
list1	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
n2	O
=	O
list2	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
g	O
=	O
gcd	O
(	O
n1	O
,	O
n2	O
)	O
;	O
unsigned	O
int	O
m1	O
=	O
n2	O
/	O
g	O
;	O
unsigned	O
int	O
m2	O
=	O
n1	O
/	O
g	O
;	O
unfold_loop	O
(	O
list1	O
,	O
m1	O
)	O
;	O
unfold_loop	O
(	O
list2	O
,	O
m2	O
)	O
;	O
}	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
||	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
m	O
=	O
MAX	O
(	O
list1	O
->	O
initial	O
.	O
length	O
,	O
list2	O
->	O
initial	O
.	O
length	O
)	O
;	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
rotate_loop	O
(	O
list1	O
,	O
m	O
)	O
;	O
if	O
(	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
rotate_loop	O
(	O
list2	O
,	O
m	O
)	O
;	O
}	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
&&	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list1	O
->	O
initial	O
.	O
length	O
==	O
list2	O
->	O
initial	O
.	O
length	O
)	O
;	O
ASSERT	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
==	O
list2	O
->	O
repeated	O
.	O
length	O
)	O
;	O
}	O
result	*(*(void))
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
result	*(*(void))
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
result	*(*(void))
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
{	O
struct	O
format_arg	O
*	O
e1	O
;	O
struct	O
format_arg	O
*	O
e2	O
;	O
unsigned	O
int	O
c1	O
;	O
unsigned	O
int	O
c2	O
;	O
e1	O
=	O
list1	O
->	O
initial	O
.	O
element	O
;	O
c1	O
=	O
list1	O
->	O
initial	O
.	O
count	O
;	O
e2	O
=	O
list2	O
->	O
initial	O
.	O
element	O
;	O
c2	O
=	O
list2	O
->	O
initial	O
.	O
count	O
;	O
while	O
(	O
c1	O
>	O
0	int
&&	O
c2	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_initial_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
re	O
->	O
repcount	O
=	O
MIN	O
(	O
e1	O
->	O
repcount	O
,	O
e2	O
->	O
repcount	O
)	O
;	O
if	O
(	O
!	O
make_intersected_element	O
(	O
re	O
,	O
e1	O
,	O
e2	O
)	O
)	O
{	O
if	O
(	O
re	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
goto	O
done	O
;	O
}	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e1	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e1	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
e2	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e2	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
count	O
==	O
0	int
&&	O
list2	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
{	O
if	O
(	O
c1	O
>	O
0	int
)	O
{	O
if	O
(	O
e1	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
}	O
else	O
if	O
(	O
c2	O
>	O
0	int
)	O
{	O
if	O
(	O
e2	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
}	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
{	O
ASSERT	O
(	O
c1	O
==	O
0	int
)	O
;	O
if	O
(	O
(	O
c2	O
>	O
0	int
?	O
e2	O
->	O
presence	O
:	O
list2	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
)	O
==	O
FCT_REQUIRED	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
list2	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
{	O
ASSERT	O
(	O
c2	O
==	O
0	int
)	O
;	O
if	O
(	O
(	O
c1	O
>	O
0	int
?	O
e1	O
->	O
presence	O
:	O
list1	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
)	O
==	O
FCT_REQUIRED	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
goto	O
done	O
;	O
}	O
ASSERT	O
(	O
c1	O
==	O
0	int
&&	O
c2	O
==	O
0	int
)	O
;	O
}	O
{	O
struct	O
format_arg	O
*	O
e1	O
;	O
struct	O
format_arg	O
*	O
e2	O
;	O
unsigned	O
int	O
c1	O
;	O
unsigned	O
int	O
c2	O
;	O
e1	O
=	O
list1	O
->	O
repeated	O
.	O
element	O
;	O
c1	O
=	O
list1	O
->	O
repeated	O
.	O
count	O
;	O
e2	O
=	O
list2	O
->	O
repeated	O
.	O
element	O
;	O
c2	O
=	O
list2	O
->	O
repeated	O
.	O
count	O
;	O
while	O
(	O
c1	O
>	O
0	int
&&	O
c2	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_repeated_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
[	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
]	O
;	O
re	O
->	O
repcount	O
=	O
MIN	O
(	O
e1	O
->	O
repcount	O
,	O
e2	O
->	O
repcount	O
)	O
;	O
if	O
(	O
!	O
make_intersected_element	O
(	O
re	O
,	O
e1	O
,	O
e2	O
)	O
)	O
{	O
bool	bool
re_is_required	O
=	O
re	O
->	O
presence	O
==	O
FCT_REQUIRED	O
;	O
append_repeated_to_initial	O
(	O
result	*(*(void))
)	O
;	O
if	O
(	O
re_is_required	O
)	O
result	*(*(void))
=	O
backtrack_in_initial	O
(	O
result	*(*(void))
)	O
;	O
goto	O
done	O
;	O
}	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e1	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e1	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
e2	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e2	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	O
==	O
0	int
&&	O
c2	O
==	O
0	int
)	O
;	O
}	O
done	O
:	O
free_list	O
(	O
list1	O
)	O
;	O
free_list	O
(	O
list2	O
)	O
;	O
if	O
(	O
result	*(*(void))
!=	O
NULL	O
)	O
{	O
normalize_outermost_list	O
(	O
result	*(*(void))
)	O
;	O
VERIFY_LIST	O
(	O
result	*(*(void))
)	O
;	O
}	O
return	O
result	*(*(void))
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_intersection_with_empty_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
if	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
?	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
:	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
&&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
return	O
NULL	O
;	O
else	O
return	O
make_empty_list	O
(	O
)	O
;	O
}	O
static	O
void	O
make_union_element	O
(	O
struct	O
format_arg	O
*	O
re	O
,	O
const	O
struct	O
format_arg	O
*	O
e1	O
,	O
const	O
struct	O
format_arg	O
*	O
e2	O
)	O
{	O
if	O
(	O
e1	O
->	O
presence	O
==	O
FCT_REQUIRED	O
&&	O
e2	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
re	O
->	O
presence	O
=	O
FCT_REQUIRED	O
;	O
else	O
re	O
->	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
if	O
(	O
e1	O
->	O
type	O
==	O
e2	O
->	O
type	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
if	O
(	O
re	O
->	O
type	O
==	O
FAT_LIST	O
)	O
re	O
->	O
list	O
=	O
make_union_list	O
(	O
copy_list	O
(	O
e1	O
->	O
list	O
)	O
,	O
copy_list	O
(	O
e2	O
->	O
list	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
&&	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
&&	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_REAL	O
&&	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_REAL	O
&&	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
{	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
}	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_LIST	O
&&	O
is_empty_list	O
(	O
e1	O
->	O
list	O
)	O
)	O
{	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
re	O
->	O
type	O
=	O
e2	O
->	O
type	O
;	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
re	O
->	O
type	O
=	O
FAT_CHARACTER_NULL	O
;	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
re	O
->	O
type	O
=	O
FAT_INTEGER_NULL	O
;	O
else	O
re	O
->	O
type	O
=	O
FAT_OBJECT	O
;	O
}	O
else	O
if	O
(	O
e2	O
->	O
type	O
==	O
FAT_LIST	O
&&	O
is_empty_list	O
(	O
e2	O
->	O
list	O
)	O
)	O
{	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_INTEGER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
re	O
->	O
type	O
=	O
e1	O
->	O
type	O
;	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
)	O
re	O
->	O
type	O
=	O
FAT_CHARACTER_NULL	O
;	O
else	O
if	O
(	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
)	O
re	O
->	O
type	O
=	O
FAT_INTEGER_NULL	O
;	O
else	O
re	O
->	O
type	O
=	O
FAT_OBJECT	O
;	O
}	O
else	O
if	O
(	O
(	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e1	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
)	O
&&	O
(	O
e2	O
->	O
type	O
==	O
FAT_INTEGER	O
||	O
e2	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
FAT_CHARACTER_INTEGER_NULL	O
;	O
}	O
else	O
if	O
(	O
(	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER	O
||	O
e2	O
->	O
type	O
==	O
FAT_CHARACTER_NULL	O
)	O
&&	O
(	O
e1	O
->	O
type	O
==	O
FAT_INTEGER	O
||	O
e1	O
->	O
type	O
==	O
FAT_INTEGER_NULL	O
)	O
)	O
{	O
re	O
->	O
type	O
=	O
FAT_CHARACTER_INTEGER_NULL	O
;	O
}	O
else	O
{	O
re	O
->	O
type	O
=	O
FAT_OBJECT	O
;	O
}	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_union_list	O
(	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
{	O
struct	O
format_arg_list	O
*	O
result	*(*(void))
;	O
VERIFY_LIST	O
(	O
list1	O
)	O
;	O
VERIFY_LIST	O
(	O
list2	O
)	O
;	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
&&	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
{	O
unsigned	O
int	O
n1	O
=	O
list1	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
n2	O
=	O
list2	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
g	O
=	O
gcd	O
(	O
n1	O
,	O
n2	O
)	O
;	O
unsigned	O
int	O
m1	O
=	O
n2	O
/	O
g	O
;	O
unsigned	O
int	O
m2	O
=	O
n1	O
/	O
g	O
;	O
unfold_loop	O
(	O
list1	O
,	O
m1	O
)	O
;	O
unfold_loop	O
(	O
list2	O
,	O
m2	O
)	O
;	O
}	O
{	O
unsigned	O
int	O
m	O
=	O
MAX	O
(	O
list1	O
->	O
initial	O
.	O
length	O
,	O
list2	O
->	O
initial	O
.	O
length	O
)	O
;	O
rotate_loop	O
(	O
list1	O
,	O
m	O
)	O
;	O
rotate_loop	O
(	O
list2	O
,	O
m	O
)	O
;	O
}	O
ASSERT	O
(	O
list1	O
->	O
initial	O
.	O
length	O
==	O
list2	O
->	O
initial	O
.	O
length	O
)	O
;	O
ASSERT	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
==	O
list2	O
->	O
repeated	O
.	O
length	O
)	O
;	O
}	O
else	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
if	O
(	O
list2	O
->	O
initial	O
.	O
length	O
>=	O
list1	O
->	O
initial	O
.	O
length	O
)	O
{	O
rotate_loop	O
(	O
list1	O
,	O
list2	O
->	O
initial	O
.	O
length	O
)	O
;	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
rotate_loop	O
(	O
list1	O
,	O
list1	O
->	O
initial	O
.	O
length	O
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
if	O
(	O
list1	O
->	O
initial	O
.	O
length	O
>=	O
list2	O
->	O
initial	O
.	O
length	O
)	O
{	O
rotate_loop	O
(	O
list2	O
,	O
list1	O
->	O
initial	O
.	O
length	O
)	O
;	O
if	O
(	O
list2	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
rotate_loop	O
(	O
list2	O
,	O
list2	O
->	O
initial	O
.	O
length	O
+	O
1	int
)	O
;	O
}	O
}	O
result	*(*(void))
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
result	*(*(void))
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
result	*(*(void))
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
{	O
struct	O
format_arg	O
*	O
e1	O
;	O
struct	O
format_arg	O
*	O
e2	O
;	O
unsigned	O
int	O
c1	O
;	O
unsigned	O
int	O
c2	O
;	O
e1	O
=	O
list1	O
->	O
initial	O
.	O
element	O
;	O
c1	O
=	O
list1	O
->	O
initial	O
.	O
count	O
;	O
e2	O
=	O
list2	O
->	O
initial	O
.	O
element	O
;	O
c2	O
=	O
list2	O
->	O
initial	O
.	O
count	O
;	O
while	O
(	O
c1	O
>	O
0	int
&&	O
c2	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_initial_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
re	O
->	O
repcount	O
=	O
MIN	O
(	O
e1	O
->	O
repcount	O
,	O
e2	O
->	O
repcount	O
)	O
;	O
make_union_element	O
(	O
re	O
,	O
e1	O
,	O
e2	O
)	O
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e1	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e1	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
e2	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e2	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
if	O
(	O
c1	O
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list2	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
;	O
if	O
(	O
e1	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_initial_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
copy_element	O
(	O
re	O
,	O
e1	O
)	O
;	O
re	O
->	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
re	O
->	O
repcount	O
=	O
1	int
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
1	int
;	O
e1	O
->	O
repcount	O
-=	O
1	int
;	O
if	O
(	O
e1	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
}	O
ensure_initial_alloc	O
(	O
result	*(*(void))
,	O
result	*(*(void))
->	O
initial	O
.	O
count	O
+	O
c1	O
)	O
;	O
while	O
(	O
c1	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
copy_element	O
(	O
re	O
,	O
e1	O
)	O
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
}	O
else	O
if	O
(	O
c2	O
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list1	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
;	O
if	O
(	O
e2	O
->	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_initial_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
copy_element	O
(	O
re	O
,	O
e2	O
)	O
;	O
re	O
->	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
re	O
->	O
repcount	O
=	O
1	int
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
1	int
;	O
e2	O
->	O
repcount	O
-=	O
1	int
;	O
if	O
(	O
e2	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
ensure_initial_alloc	O
(	O
result	*(*(void))
,	O
result	*(*(void))
->	O
initial	O
.	O
count	O
+	O
c2	O
)	O
;	O
while	O
(	O
c2	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
initial	O
.	O
element	O
[	O
result	*(*(void))
->	O
initial	O
.	O
count	O
]	O
;	O
copy_element	O
(	O
re	O
,	O
e2	O
)	O
;	O
result	*(*(void))
->	O
initial	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
initial	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	O
==	O
0	int
&&	O
c2	O
==	O
0	int
)	O
;	O
}	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
&&	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
e1	O
;	O
struct	O
format_arg	O
*	O
e2	O
;	O
unsigned	O
int	O
c1	O
;	O
unsigned	O
int	O
c2	O
;	O
e1	O
=	O
list1	O
->	O
repeated	O
.	O
element	O
;	O
c1	O
=	O
list1	O
->	O
repeated	O
.	O
count	O
;	O
e2	O
=	O
list2	O
->	O
repeated	O
.	O
element	O
;	O
c2	O
=	O
list2	O
->	O
repeated	O
.	O
count	O
;	O
while	O
(	O
c1	O
>	O
0	int
&&	O
c2	O
>	O
0	int
)	O
{	O
struct	O
format_arg	O
*	O
re	O
;	O
grow_repeated_alloc	O
(	O
result	*(*(void))
)	O
;	O
re	O
=	O
&	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
[	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
]	O
;	O
re	O
->	O
repcount	O
=	O
MIN	O
(	O
e1	O
->	O
repcount	O
,	O
e2	O
->	O
repcount	O
)	O
;	O
make_union_element	O
(	O
re	O
,	O
e1	O
,	O
e2	O
)	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
++	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
+=	O
re	O
->	O
repcount	O
;	O
e1	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e1	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e1	O
++	O
;	O
c1	O
--	O
;	O
}	O
e2	O
->	O
repcount	O
-=	O
re	O
->	O
repcount	O
;	O
if	O
(	O
e2	O
->	O
repcount	O
==	O
0	int
)	O
{	O
e2	O
++	O
;	O
c2	O
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	O
==	O
0	int
&&	O
c2	O
==	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
list1	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
=	O
list1	O
->	O
repeated	O
.	O
count	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
=	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
,	O
struct	O
format_arg	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list1	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
copy_element	O
(	O
&	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list1	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
=	O
list1	O
->	O
repeated	O
.	O
length	O
;	O
}	O
else	O
if	O
(	O
list2	O
->	O
repeated	O
.	O
length	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
=	O
list2	O
->	O
repeated	O
.	O
count	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
=	O
result	*(*(void))
->	O
repeated	O
.	O
count	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
result	*(*(void))
->	O
repeated	O
.	O
allocated	O
,	O
struct	O
format_arg	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list2	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
copy_element	O
(	O
&	O
result	*(*(void))
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
,	O
&	O
list2	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
result	*(*(void))
->	O
repeated	O
.	O
length	O
=	O
list2	O
->	O
repeated	O
.	O
length	O
;	O
}	O
free_list	O
(	O
list1	O
)	O
;	O
free_list	O
(	O
list2	O
)	O
;	O
normalize_outermost_list	O
(	O
result	*(*(void))
)	O
;	O
VERIFY_LIST	O
(	O
result	*(*(void))
)	O
;	O
return	O
result	*(*(void))
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_union_with_empty_list	O
(	O
struct	O
format_arg_list	O
*	O
list	O
)	O
{	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
?	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
:	O
list	O
->	O
repeated	O
.	O
count	O
>	O
0	int
&&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
initial_splitelement	O
(	O
list	O
,	O
1	int
)	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
)	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
==	O
1	int
)	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
normalize_outermost_list	O
(	O
list	O
)	O
;	O
}	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
union	O
(	O
struct	O
format_arg_list	O
*	O
list1	O
,	O
struct	O
format_arg_list	O
*	O
list2	O
)	O
{	O
if	O
(	O
list1	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
list2	O
!=	O
NULL	O
)	O
return	O
make_union_list	O
(	O
list1	O
,	O
list2	O
)	O
;	O
else	O
return	O
list1	O
;	O
}	O
else	O
{	O
if	O
(	O
list2	O
!=	O
NULL	O
)	O
return	O
list2	O
;	O
else	O
return	O
NULL	O
;	O
}	O
}	O
static	O
bool	bool
is_required	O
(	O
const	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	*(char)
;	O
unsigned	O
int	O
t	O
;	O
t	O
=	O
n	long
+	O
1	int
;	O
for	O
(	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
&&	O
t	O
>=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
t	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
,	O
s	*(char)
++	O
)	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
presence	O
!=	O
FCT_REQUIRED	O
)	O
return	O
false	O
;	O
if	O
(	O
t	O
==	O
0	int
)	O
return	O
true	O
;	O
if	O
(	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
)	O
{	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
presence	O
!=	O
FCT_REQUIRED	O
)	O
return	O
false	O
;	O
else	O
return	O
true	O
;	O
}	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
return	O
false	O
;	O
for	O
(	O
s	*(char)
=	O
0	int
;	O
s	*(char)
<	O
list	O
->	O
repeated	O
.	O
count	O
&&	O
t	O
>=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
;	O
t	O
-=	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
repcount	O
,	O
s	*(char)
++	O
)	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
presence	O
!=	O
FCT_REQUIRED	O
)	O
return	O
false	O
;	O
if	O
(	O
t	O
==	O
0	int
)	O
return	O
true	O
;	O
if	O
(	O
s	*(char)
<	O
list	O
->	O
repeated	O
.	O
count	O
)	O
{	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
presence	O
!=	O
FCT_REQUIRED	O
)	O
return	O
false	O
;	O
else	O
return	O
true	O
;	O
}	O
return	O
true	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
add_required_constraint	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
i	long
,	O
rest	O
;	O
if	O
(	O
list	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
&&	O
list	O
->	O
initial	O
.	O
length	O
<=	O
n	long
)	O
{	O
free_list	O
(	O
list	O
)	O
;	O
return	O
NULL	O
;	O
}	O
initial_splitelement	O
(	O
list	O
,	O
n	long
+	O
1	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
rest	O
=	O
n	long
+	O
1	int
;	O
rest	O
>	O
0	int
;	O
)	O
{	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
presence	O
=	O
FCT_REQUIRED	O
;	O
rest	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
i	long
++	O
;	O
}	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
add_end_constraint	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	*(char)
,	O
i	long
;	O
enum	O
format_cdr_type	O
n_presence	O
;	O
if	O
(	O
list	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
count	O
==	O
0	int
&&	O
list	O
->	O
initial	O
.	O
length	O
<=	O
n	long
)	O
return	O
list	O
;	O
s	*(char)
=	O
initial_splitelement	O
(	O
list	O
,	O
n	long
)	O
;	O
n_presence	O
=	O
(	O
s	*(char)
<	O
list	O
->	O
initial	O
.	O
count	O
?	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
presence	O
:	O
list	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
)	O
;	O
for	O
(	O
i	long
=	O
s	*(char)
;	O
i	long
<	O
list	O
->	O
initial	O
.	O
count	O
;	O
i	long
++	O
)	O
{	O
list	O
->	O
initial	O
.	O
length	O
-=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
.	O
repcount	O
;	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
}	O
list	O
->	O
initial	O
.	O
count	O
=	O
s	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
)	O
free_element	O
(	O
&	O
list	O
->	O
repeated	O
.	O
element	O
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	O
->	O
repeated	O
.	O
element	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
list	O
->	O
repeated	O
.	O
element	O
)	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
if	O
(	O
n_presence	O
==	O
FCT_REQUIRED	O
)	O
return	O
backtrack_in_initial	O
(	O
list	O
)	O
;	O
else	O
return	O
list	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
add_type_constraint	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
,	O
enum	O
format_arg_type	O
type	O
)	O
{	O
unsigned	O
int	O
s	*(char)
;	O
struct	O
format_arg	O
newconstraint	O
;	O
struct	O
format_arg	O
tmpelement	O
;	O
if	O
(	O
list	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
s	*(char)
=	O
initial_unshare	O
(	O
list	O
,	O
n	long
)	O
;	O
newconstraint	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
newconstraint	O
.	O
type	O
=	O
type	O
;	O
if	O
(	O
!	O
make_intersected_element	O
(	O
&	O
tmpelement	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
,	O
&	O
newconstraint	O
)	O
)	O
return	O
add_end_constraint	O
(	O
list	O
,	O
n	long
)	O
;	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
type	O
=	O
tmpelement	O
.	O
type	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
list	O
=	O
tmpelement	O
.	O
list	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
add_listtype_constraint	O
(	O
struct	O
format_arg_list	O
*	O
list	O
,	O
unsigned	O
int	O
n	long
,	O
enum	O
format_arg_type	O
type	O
,	O
struct	O
format_arg_list	O
*	O
sublist	O
)	O
{	O
unsigned	O
int	O
s	*(char)
;	O
struct	O
format_arg	O
newconstraint	O
;	O
struct	O
format_arg	O
tmpelement	O
;	O
if	O
(	O
list	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
s	*(char)
=	O
initial_unshare	O
(	O
list	O
,	O
n	long
)	O
;	O
newconstraint	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
newconstraint	O
.	O
type	O
=	O
type	O
;	O
newconstraint	O
.	O
list	O
=	O
sublist	O
;	O
if	O
(	O
!	O
make_intersected_element	O
(	O
&	O
tmpelement	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
,	O
&	O
newconstraint	O
)	O
)	O
return	O
add_end_constraint	O
(	O
list	O
,	O
n	long
)	O
;	O
free_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
type	O
=	O
tmpelement	O
.	O
type	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
s	*(char)
]	O
.	O
list	O
=	O
tmpelement	O
.	O
list	O
;	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
void	O
add_req_type_constraint	O
(	O
struct	O
format_arg_list	O
*	O
*	O
listp	O
,	O
unsigned	O
int	O
position	O
,	O
enum	O
format_arg_type	O
type	O
)	O
{	O
*	O
listp	O
=	O
add_required_constraint	O
(	O
*	O
listp	O
,	O
position	O
)	O
;	O
*	O
listp	O
=	O
add_type_constraint	O
(	O
*	O
listp	O
,	O
position	O
,	O
type	O
)	O
;	O
}	O
static	O
void	O
add_req_listtype_constraint	O
(	O
struct	O
format_arg_list	O
*	O
*	O
listp	O
,	O
unsigned	O
int	O
position	O
,	O
enum	O
format_arg_type	O
type	O
,	O
struct	O
format_arg_list	O
*	O
sublist	O
)	O
{	O
*	O
listp	O
=	O
add_required_constraint	O
(	O
*	O
listp	O
,	O
position	O
)	O
;	O
*	O
listp	O
=	O
add_listtype_constraint	O
(	O
*	O
listp	O
,	O
position	O
,	O
type	O
,	O
sublist	O
)	O
;	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_repeated_list_of_lists	O
(	O
struct	O
format_arg_list	O
*	O
sublist	O
)	O
{	O
if	O
(	O
sublist	O
==	O
NULL	O
)	O
return	O
make_empty_list	O
(	O
)	O
;	O
else	O
{	O
struct	O
format_arg_list	O
*	O
listlist	O
;	O
listlist	O
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
listlist	O
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
listlist	O
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
listlist	O
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
listlist	O
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
listlist	O
->	O
repeated	O
.	O
count	O
=	O
1	int
;	O
listlist	O
->	O
repeated	O
.	O
allocated	O
=	O
1	int
;	O
listlist	O
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
1	int
,	O
struct	O
format_arg	O
)	O
;	O
listlist	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
=	O
1	int
;	O
listlist	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
listlist	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
type	O
=	O
FAT_LIST	O
;	O
listlist	O
->	O
repeated	O
.	O
element	O
[	O
0	int
]	O
.	O
list	O
=	O
sublist	O
;	O
listlist	O
->	O
repeated	O
.	O
length	O
=	O
1	int
;	O
VERIFY_LIST	O
(	O
listlist	O
)	O
;	O
return	O
listlist	O
;	O
}	O
}	O
static	O
struct	O
format_arg_list	O
*	O
make_repeated_list	O
(	O
struct	O
format_arg_list	O
*	O
sublist	O
,	O
unsigned	O
int	O
period	O
)	O
{	O
struct	O
segment	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
struct	O
segment	O
*	O
srcseg	O
;	O
struct	O
format_arg_list	O
*	O
list	O
;	O
unsigned	O
int	O
p	*(void)
,	O
n	long
,	O
i	long
,	O
si	O
,	O
ti	O
,	O
j	O
,	O
sj	O
,	O
tj	O
,	O
splitindex	O
,	O
newcount	O
;	O
bool	bool
ended	O
;	O
VERIFY_LIST	O
(	O
sublist	O
)	O
;	O
ASSERT	O
(	O
period	O
>	O
0	int
)	O
;	O
if	O
(	O
sublist	O
->	O
repeated	O
.	O
count	O
==	O
0	int
)	O
{	O
if	O
(	O
sublist	O
->	O
initial	O
.	O
length	O
<	O
period	O
)	O
return	O
make_union_with_empty_list	O
(	O
sublist	O
)	O
;	O
srcseg	O
=	O
&	O
sublist	O
->	O
initial	O
;	O
p	*(void)
=	O
period	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
Lp	O
=	O
sublist	O
->	O
repeated	O
.	O
length	O
;	O
unsigned	O
int	O
m	O
=	O
period	O
/	O
gcd	O
(	O
period	O
,	O
Lp	O
)	O
;	O
unfold_loop	O
(	O
sublist	O
,	O
m	O
)	O
;	O
p	*(void)
=	O
m	O
*	O
Lp	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
count	O
=	O
sublist	O
->	O
initial	O
.	O
count	O
+	O
sublist	O
->	O
repeated	O
.	O
count	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
allocated	O
=	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
count	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
element	O
=	O
XNMALLOC	O
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
allocated	O
,	O
struct	O
format_arg	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sublist	O
->	O
initial	O
.	O
count	O
;	O
i	long
++	O
)	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
element	O
[	O
i	long
]	O
=	O
sublist	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
sublist	O
->	O
repeated	O
.	O
count	O
;	O
i	long
++	O
,	O
j	O
++	O
)	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
element	O
[	O
i	long
]	O
=	O
sublist	O
->	O
initial	O
.	O
element	O
[	O
j	O
]	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
.	O
length	O
=	O
sublist	O
->	O
initial	O
.	O
length	O
+	O
sublist	O
->	O
repeated	O
.	O
length	O
;	O
srcseg	O
=	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
}	O
n	long
=	O
srcseg	O
->	O
length	O
;	O
list	O
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	O
)	O
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
initial	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
0	int
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
NULL	O
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
0	int
;	O
ended	O
=	O
false	O
;	O
i	long
=	O
0	int
,	O
ti	O
=	O
0	int
,	O
si	O
=	O
0	int
;	O
while	O
(	O
i	long
<	O
p	*(void)
)	O
{	O
unsigned	O
int	O
k	O
=	O
MIN	O
(	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
.	O
repcount	O
-	O
ti	O
,	O
p	*(void)
-	O
i	long
)	O
;	O
grow_initial_alloc	O
(	O
list	O
)	O
;	O
copy_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
]	O
,	O
&	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
]	O
.	O
repcount	O
=	O
k	O
;	O
list	O
->	O
initial	O
.	O
count	O
++	O
;	O
list	O
->	O
initial	O
.	O
length	O
+=	O
k	O
;	O
i	long
+=	O
k	O
;	O
ti	O
+=	O
k	O
;	O
if	O
(	O
ti	O
==	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
.	O
repcount	O
)	O
{	O
ti	O
=	O
0	int
;	O
si	O
++	O
;	O
}	O
}	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
count	O
>	O
0	int
)	O
;	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
initial_splitelement	O
(	O
list	O
,	O
1	int
)	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
;	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
repcount	O
==	O
1	int
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
0	int
]	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
}	O
j	O
=	O
0	int
,	O
tj	O
=	O
0	int
,	O
sj	O
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n	long
)	O
{	O
unsigned	O
int	O
k	O
=	O
MIN	O
(	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
.	O
repcount	O
-	O
ti	O
,	O
list	O
->	O
initial	O
.	O
element	O
[	O
sj	O
]	O
.	O
repcount	O
-	O
tj	O
)	O
;	O
grow_initial_alloc	O
(	O
list	O
)	O
;	O
if	O
(	O
!	O
make_intersected_element	O
(	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
]	O
,	O
&	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
,	O
&	O
list	O
->	O
initial	O
.	O
element	O
[	O
sj	O
]	O
)	O
)	O
{	O
if	O
(	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
]	O
.	O
presence	O
==	O
FCT_REQUIRED	O
)	O
{	O
list	O
=	O
backtrack_in_initial	O
(	O
list	O
)	O
;	O
ASSERT	O
(	O
list	O
!=	O
NULL	O
)	O
;	O
return	O
list	O
;	O
}	O
else	O
{	O
ended	O
=	O
true	O
;	O
break	O
;	O
}	O
}	O
list	O
->	O
initial	O
.	O
element	O
[	O
list	O
->	O
initial	O
.	O
count	O
]	O
.	O
repcount	O
=	O
k	O
;	O
list	O
->	O
initial	O
.	O
count	O
++	O
;	O
list	O
->	O
initial	O
.	O
length	O
+=	O
k	O
;	O
i	long
+=	O
k	O
;	O
ti	O
+=	O
k	O
;	O
if	O
(	O
ti	O
==	O
srcseg	O
->	O
element	O
[	O
si	O
]	O
.	O
repcount	O
)	O
{	O
ti	O
=	O
0	int
;	O
si	O
++	O
;	O
}	O
j	O
+=	O
k	O
;	O
tj	O
+=	O
k	O
;	O
if	O
(	O
tj	O
==	O
list	O
->	O
initial	O
.	O
element	O
[	O
sj	O
]	O
.	O
repcount	O
)	O
{	O
tj	O
=	O
0	int
;	O
sj	O
++	O
;	O
}	O
}	O
if	O
(	O
!	O
ended	O
)	O
ASSERT	O
(	O
list	O
->	O
initial	O
.	O
length	O
==	O
n	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	O
->	O
initial	O
.	O
length	O
;	O
i	long
+=	O
period	O
)	O
{	O
si	O
=	O
initial_unshare	O
(	O
list	O
,	O
i	long
)	O
;	O
list	O
->	O
initial	O
.	O
element	O
[	O
si	O
]	O
.	O
presence	O
=	O
FCT_OPTIONAL	O
;	O
}	O
if	O
(	O
!	O
ended	O
)	O
{	O
splitindex	O
=	O
initial_splitelement	O
(	O
list	O
,	O
n	long
-	O
p	*(void)
)	O
;	O
newcount	O
=	O
list	O
->	O
initial	O
.	O
count	O
-	O
splitindex	O
;	O
if	O
(	O
newcount	O
>	O
list	O
->	O
repeated	O
.	O
allocated	O
)	O
{	O
list	O
->	O
repeated	O
.	O
allocated	O
=	O
newcount	O
;	O
list	O
->	O
repeated	O
.	O
element	O
=	O
XNMALLOC	O
(	O
newcount	O
,	O
struct	O
format_arg	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
splitindex	O
,	O
j	O
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
,	O
j	O
++	O
)	O
list	O
->	O
repeated	O
.	O
element	O
[	O
j	O
]	O
=	O
list	O
->	O
initial	O
.	O
element	O
[	O
i	long
]	O
;	O
list	O
->	O
repeated	O
.	O
count	O
=	O
newcount	O
;	O
list	O
->	O
repeated	O
.	O
length	O
=	O
p	*(void)
;	O
list	O
->	O
initial	O
.	O
count	O
=	O
splitindex	O
;	O
list	O
->	O
initial	O
.	O
length	O
=	O
n	long
-	O
p	*(void)
;	O
}	O
VERIFY_LIST	O
(	O
list	O
)	O
;	O
return	O
list	O
;	O
}	O
static	O
const	O
enum	O
format_arg_type	O
I	O
[	O
1	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
II	O
[	O
2	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
ICCI	O
[	O
4	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_INTEGER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
IIIC	O
[	O
4	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
IICCI	O
[	O
5	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_INTEGER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
IIICC	O
[	O
5	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
IIIICCC	O
[	O
7	int
]	O
=	O
{	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_INTEGER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER_NULL	O
,	O
FAT_CHARACTER_NULL	O
}	O
;	O
static	O
const	O
enum	O
format_arg_type	O
THREE	O
[	O
3	int
]	O
=	O
{	O
FAT_CHARACTER_INTEGER_NULL	O
,	O
FAT_CHARACTER_INTEGER_NULL	O
,	O
FAT_CHARACTER_INTEGER_NULL	O
}	O
;	O
static	O
bool	bool
check_params	O
(	O
struct	O
format_arg_list	O
*	O
*	O
listp	O
,	O
unsigned	O
int	O
paramcount	O
,	O
struct	O
param	O
*	O
params	O
,	O
unsigned	O
int	O
t_count	O
,	O
const	O
enum	O
format_arg_type	O
*	O
t_types	O
,	O
unsigned	O
int	O
directives	O
,	O
char	O
*	O
*	O
invalid_reason	O
)	O
{	O
unsigned	O
int	O
orig_paramcount	O
=	O
paramcount	O
;	O
unsigned	O
int	O
orig_t_count	O
=	O
t_count	O
;	O
for	O
(	O
;	O
paramcount	O
>	O
0	int
&&	O
t_count	O
>	O
0	int
;	O
params	O
++	O
,	O
paramcount	O
--	O
,	O
t_types	O
++	O
,	O
t_count	O
--	O
)	O
{	O
switch	O
(	O
*	O
t_types	O
)	O
{	O
case	O
FAT_CHARACTER_INTEGER_NULL	O
:	O
break	O
;	O
case	O
FAT_CHARACTER_NULL	O
:	O
switch	O
(	O
params	O
->	O
type	O
)	O
{	O
case	O
PT_NIL	O
:	O
case	O
PT_CHARACTER	O
:	O
case	O
PT_V	O
:	O
break	O
;	O
case	O
PT_INTEGER	O
:	O
case	O
PT_ARGCOUNT	O
:	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, parameter %u is of type '%s' but a parameter of type '%s' is expected."	*(char)
)	O
,	O
directives	O
,	O
orig_paramcount	O
-	O
paramcount	O
+	O
1	int
,	O
"integer"	*(char)
,	O
"character"	*(char)
)	O
;	O
return	O
false	O
;	O
}	O
break	O
;	O
case	O
FAT_INTEGER_NULL	O
:	O
switch	O
(	O
params	O
->	O
type	O
)	O
{	O
case	O
PT_NIL	O
:	O
case	O
PT_INTEGER	O
:	O
case	O
PT_ARGCOUNT	O
:	O
case	O
PT_V	O
:	O
break	O
;	O
case	O
PT_CHARACTER	O
:	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, parameter %u is of type '%s' but a parameter of type '%s' is expected."	*(char)
)	O
,	O
directives	O
,	O
orig_paramcount	O
-	O
paramcount	O
+	O
1	int
,	O
"character"	*(char)
,	O
"integer"	*(char)
)	O
;	O
return	O
false	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
params	O
->	O
type	O
==	O
PT_V	O
)	O
{	O
int	O
position	O
=	O
params	O
->	O
value	O
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
listp	O
,	O
position	O
,	O
*	O
t_types	O
)	O
;	O
}	O
}	O
for	O
(	O
;	O
paramcount	O
>	O
0	int
;	O
params	O
++	O
,	O
paramcount	O
--	O
)	O
switch	O
(	O
params	O
->	O
type	O
)	O
{	O
case	O
PT_NIL	O
:	O
break	O
;	O
case	O
PT_CHARACTER	O
:	O
case	O
PT_INTEGER	O
:	O
case	O
PT_ARGCOUNT	O
:	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
ngettext	O
(	O
"In the directive number %u, too many parameters are given; expected at most %u parameter."	*(char)
,	O
"In the directive number %u, too many parameters are given; expected at most %u parameters."	*(char)
,	O
orig_t_count	O
)	O
,	O
directives	O
,	O
orig_t_count	O
)	O
;	O
return	O
false	O
;	O
case	O
PT_V	O
:	O
{	O
int	O
position	O
=	O
params	O
->	O
value	O
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	O
*	O
empty_list	O
=	O
make_empty_list	O
(	O
)	O
;	O
add_req_listtype_constraint	O
(	O
listp	O
,	O
position	O
,	O
FAT_LIST	O
,	O
empty_list	O
)	O
;	O
free_list	O
(	O
empty_list	O
)	O
;	O
}	O
}	O
break	O
;	O
}	O
return	O
true	O
;	O
}	O
static	O
bool	bool
nocheck_params	O
(	O
struct	O
format_arg_list	O
*	O
*	O
listp	O
,	O
unsigned	O
int	O
paramcount	O
,	O
struct	O
param	O
*	O
params	O
,	O
unsigned	O
int	O
directives	O
,	O
char	O
*	O
*	O
invalid_reason	O
)	O
{	O
(	O
void	O
)	O
directives	O
;	O
(	O
void	O
)	O
invalid_reason	O
;	O
for	O
(	O
;	O
paramcount	O
>	O
0	int
;	O
params	O
++	O
,	O
paramcount	O
--	O
)	O
if	O
(	O
params	O
->	O
type	O
==	O
PT_V	O
)	O
{	O
int	O
position	O
=	O
params	O
->	O
value	O
;	O
add_req_type_constraint	O
(	O
listp	O
,	O
position	O
,	O
FAT_CHARACTER_INTEGER_NULL	O
)	O
;	O
}	O
return	O
true	O
;	O
}	O
static	O
bool	bool
parse_upto	O
(	O
const	O
char	O
*	O
*	O
formatp	O
,	O
int	O
*	O
positionp	O
,	O
struct	O
format_arg_list	O
*	O
*	O
listp	O
,	O
struct	O
format_arg_list	O
*	O
*	O
escapep	O
,	O
int	O
*	O
separatorp	O
,	O
struct	O
spec	O
*	O
spec	O
,	O
char	O
terminator	char
,	O
bool	bool
separator	*(char)
,	O
char	O
*	O
fdi	O
,	O
char	O
*	O
*	O
invalid_reason	O
)	O
{	O
const	O
char	O
*	O
format	O
=	O
*	O
formatp	O
;	O
const	O
char	O
*	O
const	O
format_start	O
=	O
format	O
;	O
int	O
position	O
=	O
*	O
positionp	O
;	O
struct	O
format_arg_list	O
*	O
list	O
=	O
*	O
listp	O
;	O
struct	O
format_arg_list	O
*	O
escape	O
=	O
*	O
escapep	O
;	O
for	O
(	O
;	O
*	O
format	O
!=	O
'\0'	O
;	O
)	O
if	O
(	O
*	O
format	O
++	O
==	O
'~'	O
)	O
{	O
bool	bool
colon_p	O
=	O
false	O
;	O
bool	bool
atsign_p	O
=	O
false	O
;	O
unsigned	O
int	O
paramcount	O
=	O
0	int
;	O
struct	O
param	O
*	O
params	O
=	O
NULL	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_START	O
)	O
;	O
spec	O
->	O
directives	O
++	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
enum	O
param_type	O
type	O
=	O
PT_NIL	O
;	O
int	O
value	O
=	O
0	int
;	O
if	O
(	O
c_isdigit	O
(	O
*	O
format	O
)	O
)	O
{	O
type	O
=	O
PT_INTEGER	O
;	O
do	O
{	O
value	O
=	O
10	int
*	O
value	O
+	O
(	O
*	O
format	O
-	O
'0'	O
)	O
;	O
format	O
++	O
;	O
}	O
while	O
(	O
c_isdigit	O
(	O
*	O
format	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
format	O
==	O
'+'	O
||	O
*	O
format	O
==	O
'-'	O
)	O
{	O
bool	bool
negative	O
=	O
(	O
*	O
format	O
==	O
'-'	O
)	O
;	O
type	O
=	O
PT_INTEGER	O
;	O
format	O
++	O
;	O
if	O
(	O
!	O
c_isdigit	O
(	O
*	O
format	O
)	O
)	O
{	O
if	O
(	O
*	O
format	O
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	O
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
}	O
else	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, '%c' is not followed by a digit."	*(char)
)	O
,	O
spec	O
->	O
directives	O
,	O
format	O
[	O
-	O
1	int
]	O
)	O
;	O
FDI_SET	O
(	O
format	O
,	O
FMTDIR_ERROR	O
)	O
;	O
}	O
return	O
false	O
;	O
}	O
do	O
{	O
value	O
=	O
10	int
*	O
value	O
+	O
(	O
*	O
format	O
-	O
'0'	O
)	O
;	O
format	O
++	O
;	O
}	O
while	O
(	O
c_isdigit	O
(	O
*	O
format	O
)	O
)	O
;	O
if	O
(	O
negative	O
)	O
value	O
=	O
-	O
value	O
;	O
}	O
else	O
if	O
(	O
*	O
format	O
==	O
'\''	O
)	O
{	O
type	O
=	O
PT_CHARACTER	O
;	O
format	O
++	O
;	O
if	O
(	O
*	O
format	O
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	O
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
format	O
++	O
;	O
}	O
else	O
if	O
(	O
*	O
format	O
==	O
'V'	O
||	O
*	O
format	O
==	O
'v'	O
)	O
{	O
type	O
=	O
PT_V	O
;	O
format	O
++	O
;	O
value	O
=	O
position	O
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
position	O
++	O
;	O
}	O
else	O
if	O
(	O
*	O
format	O
==	O
'#'	O
)	O
{	O
type	O
=	O
PT_ARGCOUNT	O
;	O
format	O
++	O
;	O
}	O
params	O
=	O
(	O
struct	O
param	O
*	O
)	O
xrealloc	O
(	O
params	O
,	O
(	O
paramcount	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
param	O
)	O
)	O
;	O
params	O
[	O
paramcount	O
]	O
.	O
type	O
=	O
type	O
;	O
params	O
[	O
paramcount	O
]	O
.	O
value	O
=	O
value	O
;	O
paramcount	O
++	O
;	O
if	O
(	O
*	O
format	O
==	O
','	O
)	O
format	O
++	O
;	O
else	O
break	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
format	O
==	O
':'	O
)	O
{	O
format	O
++	O
;	O
colon_p	O
=	O
true	O
;	O
}	O
else	O
if	O
(	O
*	O
format	O
==	O
'@'	O
)	O
{	O
format	O
++	O
;	O
atsign_p	O
=	O
true	O
;	O
}	O
else	O
break	O
;	O
}	O
switch	O
(	O
*	O
format	O
++	O
)	O
{	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
case	O
'S'	O
:	O
case	O
's'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
4	int
,	O
IIIC	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
case	O
'w'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
case	O
'B'	O
:	O
case	O
'b'	O
:	O
case	O
'O'	O
:	O
case	O
'o'	O
:	O
case	O
'X'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
4	int
,	O
ICCI	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_INTEGER	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
5	int
,	O
IICCI	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_INTEGER	O
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
colon_p	O
)	O
{	O
if	O
(	O
position	O
>	O
0	int
)	O
position	O
--	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'c'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_CHARACTER	O
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
5	int
,	O
IIICC	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_REAL	O
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
case	O
'G'	O
:	O
case	O
'g'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
7	int
,	O
IIIICCC	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_REAL	O
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
4	int
,	O
IIIC	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_REAL	O
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
case	O
'&'	O
:	O
case	O
'|'	O
:	O
case	O
'~'	O
:	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
1	int
,	O
I	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'_'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
break	O
;	O
case	O
'T'	O
:	O
case	O
't'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
2	int
,	O
II	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
break	O
;	O
case	O
'*'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
1	int
,	O
I	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
{	O
int	O
n	long
;	O
if	O
(	O
paramcount	O
==	O
0	int
||	O
(	O
paramcount	O
>=	O
1	int
&&	O
params	O
[	O
0	int
]	O
.	O
type	O
==	O
PT_NIL	O
)	O
)	O
n	long
=	O
(	O
atsign_p	O
?	O
0	int
:	O
1	int
)	O
;	O
else	O
if	O
(	O
paramcount	O
>=	O
1	int
&&	O
params	O
[	O
0	int
]	O
.	O
type	O
==	O
PT_INTEGER	O
)	O
n	long
=	O
params	O
[	O
0	int
]	O
.	O
value	O
;	O
else	O
{	O
position	O
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, the argument %d is negative."	*(char)
)	O
,	O
spec	O
->	O
directives	O
,	O
n	long
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
atsign_p	O
)	O
{	O
position	O
=	O
n	long
;	O
}	O
else	O
if	O
(	O
colon_p	O
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
if	O
(	O
position	O
>=	O
n	long
)	O
position	O
-=	O
n	long
;	O
else	O
position	O
=	O
0	int
;	O
}	O
else	O
position	O
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
position	O
>=	O
0	int
)	O
position	O
+=	O
n	long
;	O
}	O
}	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_FORMATSTRING	O
)	O
;	O
if	O
(	O
atsign_p	O
)	O
position	O
=	O
-	O
1	int
;	O
else	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	O
*	O
sublist	O
=	O
make_unconstrained_list	O
(	O
)	O
;	O
add_req_listtype_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_LIST	O
,	O
sublist	O
)	O
;	O
free_list	O
(	O
sublist	O
)	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
while	O
(	O
*	O
format	O
!=	O
'\0'	O
&&	O
*	O
format	O
!=	O
'/'	O
)	O
format	O
++	O
;	O
if	O
(	O
*	O
format	O
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xstrdup	O
(	O
_	O
(	O
"The string ends in the middle of a ~/.../ directive."	*(char)
)	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
format	O
++	O
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
{	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
positionp	O
,	O
listp	O
,	O
escapep	O
,	O
NULL	O
,	O
spec	O
,	O
')'	O
,	O
false	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
}	O
format	O
=	O
*	O
formatp	O
;	O
position	O
=	O
*	O
positionp	O
;	O
list	O
=	O
*	O
listp	O
;	O
escape	O
=	O
*	O
escapep	O
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
terminator	char
!=	O
')'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	*(char)
)	O
,	O
')'	O
,	O
'('	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
return	O
true	O
;	O
case	O
'['	O
:	O
if	O
(	O
atsign_p	O
&&	O
colon_p	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, both the @ and the : modifiers are given."	*(char)
)	O
,	O
spec	O
->	O
directives	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
else	O
if	O
(	O
atsign_p	O
)	O
{	O
struct	O
format_arg_list	O
*	O
nil_list	O
;	O
struct	O
format_arg_list	O
*	O
union_list	O
;	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
nil_list	O
=	O
(	O
list	O
!=	O
NULL	O
?	O
copy_list	O
(	O
list	O
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	O
*	O
empty_list	O
=	O
make_empty_list	O
(	O
)	O
;	O
add_req_listtype_constraint	O
(	O
&	O
nil_list	O
,	O
position	O
,	O
FAT_LIST	O
,	O
empty_list	O
)	O
;	O
free_list	O
(	O
empty_list	O
)	O
;	O
}	O
{	O
int	O
sub_position	O
=	O
position	O
;	O
struct	O
format_arg_list	O
*	O
sub_list	O
=	O
(	O
list	O
!=	O
NULL	O
?	O
copy_list	O
(	O
list	O
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
&	O
sub_position	O
,	O
&	O
sub_list	O
,	O
escapep	O
,	O
NULL	O
,	O
spec	O
,	O
']'	O
,	O
false	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
sub_list	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
if	O
(	O
sub_position	O
==	O
position	O
+	O
1	int
)	O
position	O
=	O
position	O
+	O
1	int
;	O
else	O
position	O
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
position	O
>=	O
0	int
)	O
position	O
=	O
position	O
+	O
1	int
;	O
}	O
union_list	O
=	O
union	O
(	O
nil_list	O
,	O
sub_list	O
)	O
;	O
}	O
format	O
=	O
*	O
formatp	O
;	O
escape	O
=	O
*	O
escapep	O
;	O
if	O
(	O
list	O
!=	O
NULL	O
)	O
free_list	O
(	O
list	O
)	O
;	O
list	O
=	O
union_list	O
;	O
}	O
else	O
if	O
(	O
colon_p	O
)	O
{	O
int	O
union_position	O
;	O
struct	O
format_arg_list	O
*	O
union_list	O
;	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
*	O
formatp	O
=	O
format	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
union_position	O
=	O
-	O
2	int
;	O
union_list	O
=	O
NULL	O
;	O
{	O
int	O
sub_position	O
=	O
position	O
;	O
struct	O
format_arg_list	O
*	O
sub_list	O
=	O
(	O
list	O
!=	O
NULL	O
?	O
copy_list	O
(	O
list	O
)	O
:	O
NULL	O
)	O
;	O
int	O
sub_separator	O
=	O
0	int
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	O
*	O
empty_list	O
=	O
make_empty_list	O
(	O
)	O
;	O
add_req_listtype_constraint	O
(	O
&	O
sub_list	O
,	O
position	O
-	O
1	int
,	O
FAT_LIST	O
,	O
empty_list	O
)	O
;	O
free_list	O
(	O
empty_list	O
)	O
;	O
}	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
&	O
sub_position	O
,	O
&	O
sub_list	O
,	O
escapep	O
,	O
&	O
sub_separator	O
,	O
spec	O
,	O
']'	O
,	O
true	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
sub_separator	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, '~:[' is not followed by two clauses, separated by '~;'."	*(char)
)	O
,	O
spec	O
->	O
directives	O
)	O
;	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
sub_list	O
!=	O
NULL	O
)	O
union_position	O
=	O
sub_position	O
;	O
union_list	O
=	O
union	O
(	O
union_list	O
,	O
sub_list	O
)	O
;	O
}	O
{	O
int	O
sub_position	O
=	O
position	O
;	O
struct	O
format_arg_list	O
*	O
sub_list	O
=	O
(	O
list	O
!=	O
NULL	O
?	O
copy_list	O
(	O
list	O
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
&	O
sub_position	O
,	O
&	O
sub_list	O
,	O
escapep	O
,	O
NULL	O
,	O
spec	O
,	O
']'	O
,	O
false	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
sub_list	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
union_position	O
==	O
-	O
2	int
)	O
union_position	O
=	O
sub_position	O
;	O
else	O
if	O
(	O
sub_position	O
<	O
0	int
||	O
sub_position	O
!=	O
union_position	O
)	O
union_position	O
=	O
-	O
1	int
;	O
}	O
union_list	O
=	O
union	O
(	O
union_list	O
,	O
sub_list	O
)	O
;	O
}	O
format	O
=	O
*	O
formatp	O
;	O
escape	O
=	O
*	O
escapep	O
;	O
if	O
(	O
union_position	O
!=	O
-	O
2	int
)	O
position	O
=	O
union_position	O
;	O
if	O
(	O
list	O
!=	O
NULL	O
)	O
free_list	O
(	O
list	O
)	O
;	O
list	O
=	O
union_list	O
;	O
}	O
else	O
{	O
int	O
arg_position	O
;	O
int	O
union_position	O
;	O
struct	O
format_arg_list	O
*	O
union_list	O
;	O
bool	bool
last_alternative	O
;	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
1	int
,	O
I	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
arg_position	O
=	O
-	O
1	int
;	O
if	O
(	O
!	O
(	O
paramcount	O
>=	O
1	int
&&	O
params	O
[	O
0	int
]	O
.	O
type	O
!=	O
PT_NIL	O
)	O
)	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
arg_position	O
=	O
position	O
;	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
union_position	O
=	O
-	O
2	int
;	O
union_list	O
=	O
NULL	O
;	O
last_alternative	O
=	O
false	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
sub_position	O
=	O
position	O
;	O
struct	O
format_arg_list	O
*	O
sub_list	O
=	O
(	O
list	O
!=	O
NULL	O
?	O
copy_list	O
(	O
list	O
)	O
:	O
NULL	O
)	O
;	O
int	O
sub_separator	O
=	O
0	int
;	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
&	O
sub_position	O
,	O
&	O
sub_list	O
,	O
escapep	O
,	O
&	O
sub_separator	O
,	O
spec	O
,	O
']'	O
,	O
!	O
last_alternative	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
last_alternative	O
&&	O
arg_position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
sub_list	O
,	O
arg_position	O
,	O
FAT_INTEGER	O
)	O
;	O
if	O
(	O
sub_list	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
union_position	O
==	O
-	O
2	int
)	O
union_position	O
=	O
sub_position	O
;	O
else	O
if	O
(	O
sub_position	O
<	O
0	int
||	O
sub_position	O
!=	O
union_position	O
)	O
union_position	O
=	O
-	O
1	int
;	O
}	O
union_list	O
=	O
union	O
(	O
union_list	O
,	O
sub_list	O
)	O
;	O
if	O
(	O
sub_separator	O
==	O
2	int
)	O
last_alternative	O
=	O
true	O
;	O
if	O
(	O
!	O
sub_separator	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
last_alternative	O
)	O
{	O
if	O
(	O
union_position	O
==	O
-	O
2	int
)	O
union_position	O
=	O
position	O
;	O
else	O
if	O
(	O
position	O
<	O
0	int
||	O
position	O
!=	O
union_position	O
)	O
union_position	O
=	O
-	O
1	int
;	O
if	O
(	O
list	O
!=	O
NULL	O
)	O
union_list	O
=	O
union	O
(	O
union_list	O
,	O
copy_list	O
(	O
list	O
)	O
)	O
;	O
}	O
format	O
=	O
*	O
formatp	O
;	O
escape	O
=	O
*	O
escapep	O
;	O
if	O
(	O
union_position	O
!=	O
-	O
2	int
)	O
position	O
=	O
union_position	O
;	O
if	O
(	O
list	O
!=	O
NULL	O
)	O
free_list	O
(	O
list	O
)	O
;	O
list	O
=	O
union_list	O
;	O
}	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
terminator	char
!=	O
']'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	*(char)
)	O
,	O
']'	O
,	O
'['	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
return	O
true	O
;	O
case	O
'{'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
1	int
,	O
I	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
{	O
int	O
sub_position	O
=	O
0	int
;	O
struct	O
format_arg_list	O
*	O
sub_list	O
=	O
make_unconstrained_list	O
(	O
)	O
;	O
struct	O
format_arg_list	O
*	O
sub_escape	O
=	O
NULL	O
;	O
struct	O
spec	O
sub_spec	O
;	O
sub_spec	O
.	O
directives	O
=	O
0	int
;	O
sub_spec	O
.	O
list	O
=	O
sub_list	O
;	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
&	O
sub_position	O
,	O
&	O
sub_list	O
,	O
&	O
sub_escape	O
,	O
NULL	O
,	O
&	O
sub_spec	O
,	O
'}'	O
,	O
false	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
spec	O
->	O
directives	O
+=	O
sub_spec	O
.	O
directives	O
;	O
if	O
(	O
*	O
format	O
==	O
'~'	O
&&	O
sub_spec	O
.	O
directives	O
==	O
1	int
)	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_FORMATSTRING	O
)	O
;	O
if	O
(	O
colon_p	O
)	O
{	O
struct	O
format_arg_list	O
*	O
listlist	O
;	O
sub_list	O
=	O
union	O
(	O
sub_list	O
,	O
sub_escape	O
)	O
;	O
listlist	O
=	O
make_repeated_list_of_lists	O
(	O
sub_list	O
)	O
;	O
sub_list	O
=	O
listlist	O
;	O
}	O
else	O
{	O
struct	O
format_arg_list	O
*	O
looplist	O
;	O
sub_list	O
=	O
union	O
(	O
sub_list	O
,	O
sub_escape	O
)	O
;	O
if	O
(	O
sub_list	O
==	O
NULL	O
)	O
looplist	O
=	O
make_empty_list	O
(	O
)	O
;	O
else	O
if	O
(	O
sub_position	O
<	O
0	int
||	O
sub_position	O
==	O
0	int
)	O
looplist	O
=	O
make_union_with_empty_list	O
(	O
sub_list	O
)	O
;	O
else	O
looplist	O
=	O
make_repeated_list	O
(	O
sub_list	O
,	O
sub_position	O
)	O
;	O
sub_list	O
=	O
looplist	O
;	O
}	O
if	O
(	O
atsign_p	O
)	O
{	O
if	O
(	O
list	O
!=	O
NULL	O
&&	O
position	O
>=	O
0	int
)	O
{	O
shift_list	O
(	O
sub_list	O
,	O
position	O
)	O
;	O
list	O
=	O
make_intersected_list	O
(	O
list	O
,	O
sub_list	O
)	O
;	O
}	O
position	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
position	O
>=	O
0	int
)	O
add_req_listtype_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_LIST	O
,	O
sub_list	O
)	O
;	O
}	O
}	O
format	O
=	O
*	O
formatp	O
;	O
break	O
;	O
case	O
'}'	O
:	O
if	O
(	O
terminator	char
!=	O
'}'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	*(char)
)	O
,	O
'}'	O
,	O
'{'	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
return	O
true	O
;	O
case	O
'<'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
4	int
,	O
IIIC	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
{	O
struct	O
format_arg_list	O
*	O
sub_escape	O
=	O
NULL	O
;	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
sub_separator	O
=	O
0	int
;	O
if	O
(	O
!	O
parse_upto	O
(	O
formatp	O
,	O
positionp	O
,	O
listp	O
,	O
&	O
sub_escape	O
,	O
&	O
sub_separator	O
,	O
spec	O
,	O
'>'	O
,	O
true	O
,	O
NULL	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	O
==	O
'\0'	O
?	O
*	O
formatp	O
-	O
1	int
:	O
*	O
formatp	O
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
sub_separator	O
)	O
break	O
;	O
}	O
format	O
=	O
*	O
formatp	O
;	O
position	O
=	O
*	O
positionp	O
;	O
list	O
=	O
*	O
listp	O
;	O
if	O
(	O
sub_escape	O
!=	O
NULL	O
)	O
position	O
=	O
-	O
1	int
;	O
list	O
=	O
union	O
(	O
list	O
,	O
sub_escape	O
)	O
;	O
}	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
terminator	char
!=	O
'>'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	*(char)
)	O
,	O
'>'	O
,	O
'<'	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
return	O
true	O
;	O
case	O
'^'	O
:	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
3	int
,	O
THREE	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
&&	O
list	O
!=	O
NULL	O
&&	O
is_required	O
(	O
list	O
,	O
position	O
)	O
)	O
break	O
;	O
if	O
(	O
list	O
!=	O
NULL	O
)	O
{	O
struct	O
format_arg_list	O
*	O
this_escape	O
=	O
copy_list	O
(	O
list	O
)	O
;	O
if	O
(	O
position	O
>=	O
0	int
)	O
this_escape	O
=	O
add_end_constraint	O
(	O
this_escape	O
,	O
position	O
)	O
;	O
escape	O
=	O
union	O
(	O
escape	O
,	O
this_escape	O
)	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
list	O
=	O
add_required_constraint	O
(	O
list	O
,	O
position	O
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
if	O
(	O
!	O
separator	*(char)
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"In the directive number %u, '~;' is used in an invalid position."	*(char)
)	O
,	O
spec	O
->	O
directives	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
terminator	char
==	O
'>'	O
)	O
{	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
1	int
,	O
I	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
check_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
0	int
,	O
NULL	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
*	O
separatorp	O
=	O
(	O
colon_p	O
?	O
2	int
:	O
1	int
)	O
;	O
return	O
true	O
;	O
case	O
'!'	O
:	O
if	O
(	O
!	O
nocheck_params	O
(	O
&	O
list	O
,	O
paramcount	O
,	O
params	O
,	O
spec	O
->	O
directives	O
,	O
invalid_reason	O
)	O
)	O
{	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
return	O
false	O
;	O
}	O
if	O
(	O
position	O
>=	O
0	int
)	O
{	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_FUNCTION	O
)	O
;	O
add_req_type_constraint	O
(	O
&	O
list	O
,	O
position	O
++	O
,	O
FAT_OBJECT	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
--	O
format	O
;	O
if	O
(	O
*	O
format	O
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	O
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_ERROR	O
)	O
;	O
}	O
else	O
{	O
*	O
invalid_reason	O
=	O
INVALID_CONVERSION_SPECIFIER	O
(	O
spec	O
->	O
directives	O
,	O
*	O
format	O
)	O
;	O
FDI_SET	O
(	O
format	O
,	O
FMTDIR_ERROR	O
)	O
;	O
}	O
return	O
false	O
;	O
}	O
FDI_SET	O
(	O
format	O
-	O
1	int
,	O
FMTDIR_END	O
)	O
;	O
free	(*(void))->(void)
(	O
params	O
)	O
;	O
}	O
*	O
formatp	O
=	O
format	O
;	O
*	O
positionp	O
=	O
position	O
;	O
*	O
listp	O
=	O
list	O
;	O
*	O
escapep	O
=	O
escape	O
;	O
if	O
(	O
terminator	char
!=	O
'\0'	O
)	O
{	O
*	O
invalid_reason	O
=	O
xasprintf	O
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	*(char)
)	O
,	O
terminator	char
-	O
1	int
,	O
terminator	char
)	O
;	O
return	O
false	O
;	O
}	O
return	O
true	O
;	O
}	O
static	O
void	O
*	O
format_parse	O
(	O
const	O
char	O
*	O
format	O
,	O
bool	bool
translated	O
,	O
char	O
*	O
fdi	O
,	O
char	O
*	O
*	O
invalid_reason	O
)	O
{	O
struct	O
spec	O
spec	O
;	O
struct	O
spec	O
*	O
result	*(*(void))
;	O
int	O
position	O
=	O
0	int
;	O
struct	O
format_arg_list	O
*	O
escape	O
;	O
spec	O
.	O
directives	O
=	O
0	int
;	O
spec	O
.	O
list	O
=	O
make_unconstrained_list	O
(	O
)	O
;	O
escape	O
=	O
NULL	O
;	O
if	O
(	O
!	O
parse_upto	O
(	O
&	O
format	O
,	O
&	O
position	O
,	O
&	O
spec	O
.	O
list	O
,	O
&	O
escape	O
,	O
NULL	O
,	O
&	O
spec	O
,	O
'\0'	O
,	O
false	O
,	O
fdi	O
,	O
invalid_reason	O
)	O
)	O
return	O
NULL	O
;	O
spec	O
.	O
list	O
=	O
union	O
(	O
spec	O
.	O
list	O
,	O
escape	O
)	O
;	O
if	O
(	O
spec	O
.	O
list	O
==	O
NULL	O
)	O
{	O
*	O
invalid_reason	O
=	O
xstrdup	O
(	O
_	O
(	O
"The string refers to some argument in incompatible ways."	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
normalize_list	O
(	O
spec	O
.	O
list	O
)	O
;	O
result	*(*(void))
=	O
XMALLOC	O
(	O
struct	O
spec	O
)	O
;	O
*	O
result	*(*(void))
=	O
spec	O
;	O
return	O
result	*(*(void))
;	O
}	O
static	O
void	O
format_free	O
(	O
void	O
*	O
descr	O
)	O
{	O
struct	O
spec	O
*	O
spec	O
=	O
(	O
struct	O
spec	O
*	O
)	O
descr	O
;	O
free_list	O
(	O
spec	O
->	O
list	O
)	O
;	O
}	O
static	O
int	O
format_get_number_of_directives	O
(	O
void	O
*	O
descr	O
)	O
{	O
struct	O
spec	O
*	O
spec	O
=	O
(	O
struct	O
spec	O
*	O
)	O
descr	O
;	O
return	O
spec	O
->	O
directives	O
;	O
}	O
static	O
bool	bool
format_check	O
(	O
void	O
*	O
msgid_descr	O
,	O
void	O
*	O
msgstr_descr	O
,	O
bool	bool
equality	O
,	O
formatstring_error_logger_t	O
error_logger	O
,	O
const	O
char	O
*	O
pretty_msgid	O
,	O
const	O
char	O
*	O
pretty_msgstr	O
)	O
{	O
struct	O
spec	O
*	O
spec1	O
=	O
(	O
struct	O
spec	O
*	O
)	O
msgid_descr	O
;	O
struct	O
spec	O
*	O
spec2	O
=	O
(	O
struct	O
spec	O
*	O
)	O
msgstr_descr	O
;	O
bool	bool
err	O
=	O
false	O
;	O
if	O
(	O
equality	O
)	O
{	O
if	O
(	O
!	O
equal_list	O
(	O
spec1	O
->	O
list	O
,	O
spec2	O
->	O
list	O
)	O
)	O
{	O
if	O
(	O
error_logger	O
)	O
error_logger	O
(	O
_	O
(	O
"format specifications in '%s' and '%s' are not equivalent"	*(char)
)	O
,	O
pretty_msgid	O
,	O
pretty_msgstr	O
)	O
;	O
err	O
=	O
true	O
;	O
}	O
}	O
else	O
{	O
struct	O
format_arg_list	O
*	O
intersection	O
=	O
make_intersected_list	O
(	O
copy_list	O
(	O
spec1	O
->	O
list	O
)	O
,	O
copy_list	O
(	O
spec2	O
->	O
list	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
intersection	O
!=	O
NULL	O
&&	O
(	O
normalize_list	O
(	O
intersection	O
)	O
,	O
equal_list	O
(	O
intersection	O
,	O
spec2	O
->	O
list	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
error_logger	O
)	O
error_logger	O
(	O
_	O
(	O
"format specifications in '%s' are not a subset of those in '%s'"	*(char)
)	O
,	O
pretty_msgstr	O
,	O
pretty_msgid	O
)	O
;	O
err	O
=	O
true	O
;	O
}	O
}	O
return	O
err	O
;	O
}	O
struct	O
formatstring_parser	O
formatstring_lisp	O
=	O
{	O
format_parse	O
,	O
format_free	O
,	O
format_get_number_of_directives	O
,	O
NULL	O
,	O
format_check	O
}	O
;	O
