extern	O
FILE	struct
*	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
const	O
*	O
const	O
program_name	*(char)
=	O
"uudecode"	*(char)
;	O
static	O
char	O
const	O
uudecode_opt_strs	array(char)
[	O
4756	int
]	O
=	O
"uudecode (GNU sharutils) 4.15\n"	*(char)
"Copyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\n"	*(char)
"This is free software. It is licensed for use, modification and\n"	*(char)
"redistribution under the terms of the GNU General Public License,\n"	*(char)
"version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"	*(char)
"uudecode is free software: you can redistribute it and/or modify it under\n"	*(char)
"the terms of the GNU General Public License as published by the Free\n"	*(char)
"Software Foundation, either version 3 of the License, or (at your option)\n"	*(char)
"any later version.\n\n"	*(char)
"uudecode is distributed in the hope that it will be useful, but WITHOUT ANY\n"	*(char)
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"	*(char)
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"	*(char)
"details.\n\n"	*(char)
"You should have received a copy of the GNU General Public License along\n"	*(char)
"with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"	*(char)
"direct output to file\0"	*(char)
"OUTPUT_FILE\0"	*(char)
"output-file\0"	*(char)
"ignore fchmod(3P) errors\0"	*(char)
"IGNORE_CHMOD\0"	*(char)
"ignore-chmod\0"	*(char)
"display extended usage information and exit\0"	*(char)
"help\0"	*(char)
"extended usage information passed thru pager\0"	*(char)
"more-help\0"	*(char)
"output version information and exit\0"	*(char)
"version\0"	*(char)
"save the option state to a config file\0"	*(char)
"save-opts\0"	*(char)
"load options from a config file\0"	*(char)
"LOAD_OPTS\0"	*(char)
"no-load-opts\0"	*(char)
"no\0"	*(char)
"UUDECODE\0"	*(char)
"uudecode (GNU sharutils) - decode an encoded file\n"	*(char)
"Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\0"	*(char)
"$HOME\0"	*(char)
".sharrc\0"	*(char)
"bug-gnu-utils@gnu.org\0"	*(char)
"If no 'file'(s) are provided, then standard input is decoded.\n\0"	*(char)
"'uudecode' transforms uuencoded files into their original form.\n\n"	*(char)
"The encoded file(s) may be specified on the command line, or one may be\n"	*(char)
"read from standard input.  The output file name is specified in the encoded\n"	*(char)
"file, but may be overridden with the '-o' option.  It will have the mode of\n"	*(char)
"the original file, except that setuid and execute bits are not retained.  If\n"	*(char)
"the output file is specified to be '/dev/stdout' or '-', the result will be\n"	*(char)
"written to standard output.  If there are multiple input files and the\n"	*(char)
"second or subsquent file specifies standard output, the decoded data will\n"	*(char)
"be written to the same file as the previous output.  Don't do that.\n\n"	*(char)
"'uudecode' ignores any leading and trailing lines.  It looks for a line\n"	*(char)
"that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n"	*(char)
"found.  The program determines from the header line of the encoded file\n"	*(char)
"which of the two supported encoding schemes was used and whether or not the\n"	*(char)
"output file name has been encoded with base64 encoding.  See 'uuencode(5)'.\n\0"	*(char)
"uudecode (GNU sharutils) 4.15\0"	*(char)
"uudecode (GNU sharutils) - decode an encoded file\n"	*(char)
"Usage:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\n"	*(char)
"   -o, --output-file=str      direct output to file\n"	*(char)
"   -c, --ignore-chmod         ignore fchmod(3P) errors\n"	*(char)
"   -v, --version[=MODE]       output version information and exit\n"	*(char)
"   -h, --help                 display extended usage information and exit\n"	*(char)
"   -!, --more-help            extended usage information passed thru pager\n"	*(char)
"   -R, --save-opts[=FILE]     save the option state to a config file FILE\n"	*(char)
"   -r, --load-opts=FILE       load options from the config file FILE\n"	*(char)
"                                - disabled with '--no-load-opts'\n"	*(char)
"                                - may appear multiple times\n\n"	*(char)
"Options are specified by doubled hyphens and their name or by a single\n"	*(char)
"hyphen and the flag character.\n"	*(char)
"If no 'file'(s) are provided, then standard input is decoded.\n\n"	*(char)
"The following option preset mechanisms are supported:\n"	*(char)
" - reading file $HOME/.sharrc\n\n"	*(char)
"'uudecode' transforms uuencoded files into their original form.\n\n"	*(char)
"The encoded file(s) may be specified on the command line, or one may be\n"	*(char)
"read from standard input.  The output file name is specified in the encoded\n"	*(char)
"file, but may be overridden with the '-o' option.  It will have the mode of\n"	*(char)
"the original file, except that setuid and execute bits are not retained.  If\n"	*(char)
"the output file is specified to be '/dev/stdout' or '-', the result will be\n"	*(char)
"written to standard output.  If there are multiple input files and the\n"	*(char)
"second or subsquent file specifies standard output, the decoded data will\n"	*(char)
"be written to the same file as the previous output.  Don't do that.\n\n"	*(char)
"'uudecode' ignores any leading and trailing lines.  It looks for a line\n"	*(char)
"that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n"	*(char)
"found.  The program determines from the header line of the encoded file\n"	*(char)
"which of the two supported encoding schemes was used and whether or not the\n"	*(char)
"output file name has been encoded with base64 encoding.  See 'uuencode(5)'.\n\n"	*(char)
"Please send bug reports to:  <bug-gnu-utils@gnu.org>\n\0"	*(char)
"uudecode (GNU sharutils) - decode an encoded file\n"	*(char)
"Usage:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n"	*(char)
"Try 'uudecode --help' for more information.\n"	*(char)
;	O
extern	O
tOptProc	(*(struct),*(struct))->(void)
optionBooleanVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNestedVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPrintVersion	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionResetOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionStackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeDate	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionUnstackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionVendorOption	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptProc	(*(struct),*(struct))->(void)
doOptOutput_File	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptDesc	struct
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
[	O
OPTION_CT	int
]	O
=	O
{	O
{	O
0	int
,	O
VALUE_OPT_OUTPUT_FILE	char
,	O
0	int
,	O
VALUE_OPT_OUTPUT_FILE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OUTPUT_FILE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptOutput_File	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
OUTPUT_FILE_DESC	O
,	O
OUTPUT_FILE_NAME	O
,	O
OUTPUT_FILE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
1	int
,	O
VALUE_OPT_IGNORE_CHMOD	char
,	O
1	int
,	O
VALUE_OPT_IGNORE_CHMOD	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
IGNORE_CHMOD_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
IGNORE_CHMOD_DESC	O
,	O
IGNORE_CHMOD_NAME	O
,	O
IGNORE_CHMOD_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_VERSION	int
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VER_FLAGS	O
,	O
AOUSE_VERSION	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
VER_PROC	O
,	O
VER_DESC	O
,	O
NULL	O
,	O
VER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_HELP	int
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_IMM	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
HELP_DESC	O
,	O
NULL	O
,	O
HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MORE_HELP_FLAGS	O
,	O
AOUSE_MORE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
MORE_HELP_DESC	O
,	O
NULL	O
,	O
MORE_HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_SAVE_OPTS	int
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_ARG_OPTIONAL	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_SAVE_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SAVE_OPTS_DESC	O
,	O
NULL	O
,	O
SAVE_OPTS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_LOAD_OPTS	int
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_DISABLE_IMM	int
,	O
AOUSE_LOAD_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionLoadOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
LOAD_OPTS_DESC	O
,	O
LOAD_OPTS_NAME	O
,	O
LOAD_OPTS_name	O
,	O
NO_LOAD_OPTS_name	O
,	O
LOAD_OPTS_pfx	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
apzHomeList	array(*(char))
[	O
2	int
]	O
=	O
{	O
uudecode_opt_strs	array(char)
+	O
1378	int
,	O
NULL	O
}	O
;	O
static	O
tOptionXlateProc	()->(void)
translate_option_strings	()->(void)
;	O
static	O
void	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
int	O
ex_code	int
;	O
ex_code	int
=	O
UUDECODE_EXIT_SUCCESS	int
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
uudecodeOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
ex_code	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptOutput_File	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
switch	O
(	O
*	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
return	O
;	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
+	O
1	int
,	O
"dev/stdout"	*(char)
)	O
==	O
0	int
)	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
,	O
"w"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fserr	(int,*(char),*(char))->(void)
(	O
UUDECODE_EXIT_NO_OUTPUT	int
,	O
"freopen-ing for stdout"	*(char)
,	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
)	O
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
void	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
er_leader	*(char)
=	O
_	O
(	O
"uudecode usage error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
er_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
uudecodeOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
UUDECODE_EXIT_USAGE_ERROR	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
usage_message	(*(char))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
die_leader	*(char)
=	O
_	O
(	O
"uudecode fatal error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
die_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
void	O
die	(int,*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
exit_code	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
fserr	(int,*(char),*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
op	*(char)
,	O
char	O
const	O
*	O
fname	*(char)
)	O
{	O
char	O
const	O
*	O
fserr_fmt	*(char)
=	O
_	O
(	O
"fserr %d (%s) performing '%s' on %s\n"	*(char)
)	O
;	O
die	(int,*(char))->(void)
(	O
exit_code	int
,	O
fserr_fmt	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
op	*(char)
,	O
fname	*(char)
)	O
;	O
}	O
tOptions	struct
uudecodeOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
=	O
{	O
OPTIONS_STRUCT_VERSION	int
,	O
0	int
,	O
NULL	O
,	O
(	O
OPTPROC_BASE	O
+	O
OPTPROC_ERRSTOP	int
+	O
OPTPROC_SHORTOPT	int
+	O
OPTPROC_LONGOPT	int
+	O
OPTPROC_NO_REQ_OPT	int
+	O
OPTPROC_GNUUSAGE	int
+	O
OPTPROC_MISUSE	int
)	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
zPROGNAME	O
,	O
zRcName	O
,	O
zCopyright	O
,	O
zLicenseDescrip	O
,	O
zFullVersion	O
,	O
apzHomeList	array(*(char))
,	O
zUsageTitle	O
,	O
zExplain	O
,	O
zDetail	O
,	O
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
,	O
zBugsAddr	O
,	O
NULL	O
,	O
NULL	O
,	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
,	O
translate_option_strings	()->(void)
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
INDEX_OPT_SAVE_OPTS	int
,	O
NO_EQUIVALENT	O
,	O
NO_EQUIVALENT	O
}	O
,	O
7	int
,	O
2	int
,	O
uudecode_full_usage	O
,	O
uudecode_short_usage	O
,	O
NULL	O
,	O
NULL	O
,	O
PKGDATADIR	*(char)
,	O
uudecode_packager_info	O
}	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
;	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
{	O
char	O
*	O
res	*(char)
;	O
if	O
(	O
pz	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
res	*(char)
=	O
dgettext	(*(char),*(char))->(*(char))
(	O
"libopts"	*(char)
,	O
pz	*(char)
)	O
;	O
if	O
(	O
res	*(char)
==	O
pz	*(char)
)	O
res	*(char)
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
}	O
else	O
res	*(char)
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
if	O
(	O
res	*(char)
==	O
pz	*(char)
)	O
return	O
res	*(char)
;	O
res	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
res	*(char)
)	O
;	O
if	O
(	O
res	*(char)
==	O
NULL	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"No memory for duping translated strings\n"	*(char)
)	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
UUDECODE_EXIT_NO_MEM	int
)	O
;	O
}	O
return	O
res	*(char)
;	O
}	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
static	O
void	O
translate_option_strings	()->(void)
(	O
void	O
)	O
{	O
tOptions	struct
*	O
const	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
=	O
&	O
uudecodeOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
ppz	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
VOIDP	O
(	O
&	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
)	O
)	O
;	O
int	O
ix	int
=	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
;	O
do	O
{	O
ppz	*(*(char))
++	O
;	O
*	O
ppz	*(*(char))
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
ppz	*(*(char))
)	O
;	O
}	O
while	O
(	O
--	O
ix	int
>	O
0	int
)	O
;	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
=	O
0	int
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyright	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyNotice	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzFullVersion	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
