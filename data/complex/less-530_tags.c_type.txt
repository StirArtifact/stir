public	O
char	O
ztags	array(char)
[	O
]	O
=	O
"tags"	*(char)
;	O
public	O
char	O
*	O
tags	*(char)
=	O
ztags	array(char)
;	O
static	O
int	O
total	int
;	O
static	O
int	O
curseq	int
;	O
extern	O
int	O
linenums	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
ctldisp	int
;	O
enum	O
tag_result	enum(int,int,int,int,int)
{	O
TAG_FOUND	int
,	O
TAG_NOFILE	int
,	O
TAG_NOTAG	int
,	O
TAG_NOTYPE	int
,	O
TAG_INTR	int
}	O
;	O
enum	O
{	O
T_CTAGS	int
,	O
T_CTAGS_X	int
,	O
T_GTAGS	int
,	O
T_GRTAGS	int
,	O
T_GSYMS	int
,	O
T_GPATH	int
}	O
;	O
static	O
enum	O
tag_result	enum(int,int,int,int,int)
findctag	()->(enum(int,int,int,int,int))
(	O
)	O
;	O
static	O
enum	O
tag_result	enum(int,int,int,int,int)
findgtag	()->(enum(int,int,int,int,int))
(	O
)	O
;	O
static	O
char	O
*	O
nextgtag	()->(*(char))
(	O
)	O
;	O
static	O
char	O
*	O
prevgtag	()->(*(char))
(	O
)	O
;	O
static	O
POSITION	long
ctagsearch	()->(long)
(	O
)	O
;	O
static	O
POSITION	long
gtagsearch	()->(long)
(	O
)	O
;	O
static	O
int	O
getentry	()->(int)
(	O
)	O
;	O
struct	O
taglist	struct(*(struct),*(struct))
{	O
struct	O
tag	*(char)
*	O
tl_first	*(struct)
;	O
struct	O
tag	*(char)
*	O
tl_last	*(struct)
;	O
}	O
;	O
struct	O
tag	*(char)
{	O
struct	O
tag	*(char)
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
,	O
*	O
prev	*(char)
;	O
char	O
*	O
tag_file	*(char)
;	O
LINENUM	long
tag_linenum	long
;	O
char	O
*	O
tag_pattern	*(char)
;	O
char	O
tag_endline	char
;	O
}	O
;	O
static	O
struct	O
taglist	struct(*(struct),*(struct))
taglist	struct(*(struct),*(struct))
=	O
{	O
TAG_END	O
,	O
TAG_END	O
}	O
;	O
static	O
struct	O
tag	*(char)
*	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
public	O
void	O
cleantags	()->(void)
(	O
)	O
{	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
while	O
(	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
taglist	struct(*(struct),*(struct))
.	O
tl_first	*(struct)
)	O
!=	O
TAG_END	O
)	O
{	O
TAG_RM	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
)	O
;	O
free	(*(void))->(void)
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
)	O
;	O
}	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
NULL	O
;	O
total	int
=	O
curseq	int
=	O
0	int
;	O
}	O
static	O
struct	O
tag	*(char)
*	O
maketagent	(*(char),*(char),long,*(char),int)->(*(struct(*(struct(*`,*`,*`,long,*`,char)),*(struct(*`,*`,*`,long,*`,char)),*(char),long,*(char),char)))
(	O
name	*(char)
,	O
file	*(char)
,	O
linenum	long
,	O
pattern	*(char)
,	O
endline	int
)	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
file	*(char)
;	O
LINENUM	long
linenum	long
;	O
char	O
*	O
pattern	*(char)
;	O
int	O
endline	int
;	O
{	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
(	O
struct	O
tag	*(char)
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
sizeof	O
(	O
struct	O
tag	*(char)
)	O
,	O
1	int
)	O
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
file	*(char)
)	O
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
,	O
file	*(char)
)	O
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_linenum	long
=	O
linenum	long
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_endline	char
=	O
endline	int
;	O
if	O
(	O
pattern	*(char)
==	O
NULL	O
)	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
=	O
NULL	O
;	O
else	O
{	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
,	O
pattern	*(char)
)	O
;	O
}	O
return	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
)	O
;	O
}	O
public	O
int	O
gettagtype	()->(int)
(	O
)	O
{	O
int	O
f	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tags	*(char)
,	O
"GTAGS"	*(char)
)	O
==	O
0	int
)	O
return	O
T_GTAGS	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tags	*(char)
,	O
"GRTAGS"	*(char)
)	O
==	O
0	int
)	O
return	O
T_GRTAGS	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tags	*(char)
,	O
"GSYMS"	*(char)
)	O
==	O
0	int
)	O
return	O
T_GSYMS	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tags	*(char)
,	O
"GPATH"	*(char)
)	O
==	O
0	int
)	O
return	O
T_GPATH	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tags	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
return	O
T_CTAGS_X	int
;	O
f	int
=	O
open	(*(char),int)->(int)
(	O
tags	*(char)
,	O
OPEN_READ	O
)	O
;	O
if	O
(	O
f	int
>=	O
0	int
)	O
{	O
close	(int)->(int)
(	O
f	int
)	O
;	O
return	O
T_CTAGS	int
;	O
}	O
return	O
T_GTAGS	int
;	O
}	O
public	O
void	O
findtag	(*(char))->(void)
(	O
tag	*(char)
)	O
char	O
*	O
tag	*(char)
;	O
{	O
int	O
type	int
=	O
gettagtype	()->(int)
(	O
)	O
;	O
enum	O
tag_result	enum(int,int,int,int,int)
result	enum(int,int,int,int,int)
;	O
if	O
(	O
type	int
==	O
T_CTAGS	int
)	O
result	enum(int,int,int,int,int)
=	O
findctag	()->(enum(int,int,int,int,int))
(	O
tag	*(char)
)	O
;	O
else	O
result	enum(int,int,int,int,int)
=	O
findgtag	()->(enum(int,int,int,int,int))
(	O
tag	*(char)
,	O
type	int
)	O
;	O
switch	O
(	O
result	enum(int,int,int,int,int)
)	O
{	O
case	O
TAG_FOUND	int
:	O
case	O
TAG_INTR	int
:	O
break	O
;	O
case	O
TAG_NOFILE	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No tags file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
TAG_NOTAG	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No such tag in tags file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
TAG_NOTYPE	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"unknown tag type"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
}	O
public	O
POSITION	long
tagsearch	()->(long)
(	O
)	O
{	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
NULL	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_linenum	long
!=	O
0	int
)	O
return	O
gtagsearch	()->(long)
(	O
)	O
;	O
else	O
return	O
ctagsearch	()->(long)
(	O
)	O
;	O
}	O
public	O
char	O
*	O
nexttag	(int)->(*(char))
(	O
n	int
)	O
int	O
n	int
;	O
{	O
char	O
*	O
tagfile	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
tagfile	*(char)
=	O
nextgtag	()->(*(char))
(	O
)	O
;	O
return	O
tagfile	*(char)
;	O
}	O
public	O
char	O
*	O
prevtag	(int)->(*(char))
(	O
n	int
)	O
int	O
n	int
;	O
{	O
char	O
*	O
tagfile	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
tagfile	*(char)
=	O
prevgtag	()->(*(char))
(	O
)	O
;	O
return	O
tagfile	*(char)
;	O
}	O
public	O
int	O
ntags	()->(int)
(	O
)	O
{	O
return	O
total	int
;	O
}	O
public	O
int	O
curr_tag	()->(int)
(	O
)	O
{	O
return	O
curseq	int
;	O
}	O
static	O
enum	O
tag_result	enum(int,int,int,int,int)
findctag	()->(enum(int,int,int,int,int))
(	O
tag	*(char)
)	O
char	O
*	O
tag	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
FILE	struct
*	O
f	int
;	O
int	O
taglen	int
;	O
LINENUM	long
taglinenum	long
;	O
char	O
*	O
tagfile	*(char)
;	O
char	O
*	O
tagpattern	*(char)
;	O
int	O
tagendline	int
;	O
int	O
search_char	int
;	O
int	O
err	int
;	O
char	O
tline	array(char)
[	O
TAGLINE_SIZE	int
]	O
;	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
p	*(char)
=	O
shell_unquote	(*(char))->(*(char))
(	O
tags	*(char)
)	O
;	O
f	int
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(char)
,	O
"r"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
f	int
==	O
NULL	O
)	O
return	O
TAG_NOFILE	int
;	O
cleantags	()->(void)
(	O
)	O
;	O
total	int
=	O
0	int
;	O
taglen	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
tag	*(char)
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
tline	array(char)
,	O
sizeof	O
(	O
tline	array(char)
)	O
,	O
f	int
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
tline	array(char)
[	O
0	int
]	O
==	O
'!'	O
)	O
continue	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
tag	*(char)
,	O
tline	array(char)
,	O
taglen	int
)	O
!=	O
0	int
||	O
!	O
WHITESP	O
(	O
tline	array(char)
[	O
taglen	int
]	O
)	O
)	O
continue	O
;	O
tagpattern	*(char)
=	O
NULL	O
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
tline	array(char)
+	O
taglen	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
continue	O
;	O
tagfile	*(char)
=	O
p	*(char)
;	O
while	O
(	O
!	O
WHITESP	O
(	O
*	O
p	*(char)
)	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
p	*(char)
++	O
;	O
*	O
p	*(char)
++	O
=	O
'\0'	O
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
continue	O
;	O
tagendline	int
=	O
0	int
;	O
taglinenum	long
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
p	*(char)
,	O
0	int
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
taglinenum	long
=	O
0	int
;	O
search_char	int
=	O
*	O
p	*(char)
++	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'^'	O
)	O
p	*(char)
++	O
;	O
tagpattern	*(char)
=	O
p	*(char)
;	O
while	O
(	O
*	O
p	*(char)
!=	O
search_char	int
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
'\\'	O
)	O
p	*(char)
++	O
;	O
p	*(char)
++	O
;	O
}	O
tagendline	int
=	O
(	O
p	*(char)
[	O
-	O
1	int
]	O
==	O
'$'	O
)	O
;	O
if	O
(	O
tagendline	int
)	O
p	*(char)
--	O
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
}	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
maketagent	(*(char),*(char),long,*(char),int)->(*(struct(*(struct(*`,*`,*`,long,*`,char)),*(struct(*`,*`,*`,long,*`,char)),*(char),long,*(char),char)))
(	O
tag	*(char)
,	O
tagfile	*(char)
,	O
taglinenum	long
,	O
tagpattern	*(char)
,	O
tagendline	int
)	O
;	O
TAG_INS	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
)	O
;	O
total	int
++	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	int
)	O
;	O
if	O
(	O
total	int
==	O
0	int
)	O
return	O
TAG_NOTAG	int
;	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
taglist	struct(*(struct),*(struct))
.	O
tl_first	*(struct)
;	O
curseq	int
=	O
1	int
;	O
return	O
TAG_FOUND	int
;	O
}	O
public	O
int	O
edit_tagfile	()->(int)
(	O
)	O
{	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
NULL	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
edit	(*(char))->(int)
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
curtag_match	(*(char),long)->(int)
(	O
char	O
const	O
*	O
line	*(char)
,	O
POSITION	long
linepos	long
)	O
{	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_pattern	*(char)
,	O
line	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
!	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_endline	char
||	O
line	*(char)
[	O
len	int
]	O
==	O
'\0'	O
||	O
line	*(char)
[	O
len	int
]	O
==	O
'\r'	O
)	O
)	O
{	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_linenum	long
=	O
find_linenum	(long)->(long)
(	O
linepos	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
POSITION	long
ctagsearch	()->(long)
(	O
)	O
{	O
POSITION	long
pos	long
,	O
linepos	long
;	O
LINENUM	long
linenum	long
;	O
int	O
line_len	int
;	O
char	O
*	O
line	*(char)
;	O
int	O
found	int
;	O
pos	long
=	O
ch_zero	O
(	O
)	O
;	O
linenum	long
=	O
find_linenum	(long)->(long)
(	O
pos	long
)	O
;	O
for	O
(	O
found	int
=	O
0	int
;	O
!	O
found	int
;	O
)	O
{	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
linepos	long
=	O
pos	long
;	O
pos	long
=	O
forw_raw_line	(long,*(*(char)),*(int))->(long)
(	O
pos	long
,	O
&	O
line	*(char)
,	O
&	O
line_len	int
)	O
;	O
if	O
(	O
linenum	long
!=	O
0	int
)	O
linenum	long
++	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Tag not found"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
}	O
if	O
(	O
linenums	int
)	O
add_lnum	(long,long)->(void)
(	O
linenum	long
,	O
pos	long
)	O
;	O
if	O
(	O
ctldisp	int
!=	O
OPT_ONPLUS	int
)	O
{	O
if	O
(	O
curtag_match	(*(char),long)->(int)
(	O
line	*(char)
,	O
linepos	long
)	O
)	O
found	int
=	O
1	int
;	O
}	O
else	O
{	O
int	O
cvt_ops	int
=	O
CVT_ANSI	int
;	O
int	O
cvt_len	int
=	O
cvt_length	(int,int)->(int)
(	O
line_len	int
,	O
cvt_ops	int
)	O
;	O
int	O
*	O
chpos	*(int)
=	O
cvt_alloc_chpos	(int)->(*(int))
(	O
cvt_len	int
)	O
;	O
char	O
*	O
cline	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
1	int
,	O
cvt_len	int
)	O
;	O
cvt_text	(*(char),*(char),*(int),*(int),int)->(void)
(	O
cline	*(char)
,	O
line	*(char)
,	O
chpos	*(int)
,	O
&	O
line_len	int
,	O
cvt_ops	int
)	O
;	O
if	O
(	O
curtag_match	(*(char),long)->(int)
(	O
cline	*(char)
,	O
linepos	long
)	O
)	O
found	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
chpos	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
cline	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
linepos	long
)	O
;	O
}	O
static	O
enum	O
tag_result	enum(int,int,int,int,int)
findgtag	()->(enum(int,int,int,int,int))
(	O
tag	*(char)
,	O
type	int
)	O
char	O
*	O
tag	*(char)
;	O
int	O
type	int
;	O
{	O
char	O
buf	*(char)
[	O
256	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
if	O
(	O
type	int
!=	O
T_CTAGS_X	int
&&	O
tag	*(char)
==	O
NULL	O
)	O
return	O
TAG_NOFILE	int
;	O
cleantags	()->(void)
(	O
)	O
;	O
total	int
=	O
0	int
;	O
if	O
(	O
type	int
==	O
T_CTAGS_X	int
)	O
{	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
tags	*(char)
=	O
ztags	array(char)
;	O
}	O
else	O
{	O
char	O
*	O
command	*(char)
;	O
char	O
*	O
flag	*(char)
;	O
char	O
*	O
qtag	*(char)
;	O
char	O
*	O
cmd	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESSGLOBALTAGS"	*(char)
)	O
;	O
if	O
(	O
cmd	*(char)
==	O
NULL	O
||	O
*	O
cmd	*(char)
==	O
'\0'	O
)	O
return	O
TAG_NOFILE	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
T_GTAGS	int
:	O
flag	*(char)
=	O
""	*(char)
;	O
break	O
;	O
case	O
T_GRTAGS	int
:	O
flag	*(char)
=	O
"r"	*(char)
;	O
break	O
;	O
case	O
T_GSYMS	int
:	O
flag	*(char)
=	O
"s"	*(char)
;	O
break	O
;	O
case	O
T_GPATH	int
:	O
flag	*(char)
=	O
"P"	*(char)
;	O
break	O
;	O
default	O
:	O
return	O
TAG_NOTYPE	int
;	O
}	O
qtag	*(char)
=	O
shell_quote	(*(char))->(*(char))
(	O
tag	*(char)
)	O
;	O
if	O
(	O
qtag	*(char)
==	O
NULL	O
)	O
qtag	*(char)
=	O
tag	*(char)
;	O
command	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
cmd	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
flag	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
qtag	*(char)
)	O
+	O
5	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
command	*(char)
,	O
"%s -x%s %s"	*(char)
,	O
cmd	*(char)
,	O
flag	*(char)
,	O
qtag	*(char)
)	O
;	O
if	O
(	O
qtag	*(char)
!=	O
tag	*(char)
)	O
free	(*(void))->(void)
(	O
qtag	*(char)
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
"r"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
char	O
*	O
name	*(char)
,	O
*	O
file	*(char)
,	O
*	O
line	*(char)
;	O
int	O
len	int
;	O
if	O
(	O
sigs	int
)	O
{	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
TAG_INTR	int
;	O
}	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
buf	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	*(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
else	O
{	O
int	O
c	int
;	O
do	O
{	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
}	O
if	O
(	O
getentry	()->(int)
(	O
buf	*(char)
,	O
&	O
name	*(char)
,	O
&	O
file	*(char)
,	O
&	O
line	*(char)
)	O
)	O
{	O
break	O
;	O
}	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
maketagent	(*(char),*(char),long,*(char),int)->(*(struct(*(struct(*`,*`,*`,long,*`,char)),*(struct(*`,*`,*`,long,*`,char)),*(char),long,*(char),char)))
(	O
name	*(char)
,	O
file	*(char)
,	O
(	O
LINENUM	long
)	O
atoi	(*(char))->(int)
(	O
line	*(char)
)	O
,	O
NULL	O
,	O
0	int
)	O
;	O
TAG_INS	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
)	O
;	O
total	int
++	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
NULL	O
;	O
total	int
=	O
curseq	int
=	O
0	int
;	O
return	O
TAG_NOFILE	int
;	O
}	O
}	O
}	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
taglist	struct(*(struct),*(struct))
.	O
tl_first	*(struct)
;	O
if	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
TAG_END	O
)	O
return	O
TAG_NOTAG	int
;	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
curseq	int
=	O
1	int
;	O
return	O
TAG_FOUND	int
;	O
}	O
static	O
int	O
circular	int
=	O
0	int
;	O
static	O
char	O
*	O
nextgtag	()->(*(char))
(	O
)	O
{	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
if	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
TAG_END	O
)	O
{	O
if	O
(	O
!	O
circular	int
)	O
return	O
NULL	O
;	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
taglist	struct(*(struct),*(struct))
.	O
tl_first	*(struct)
;	O
curseq	int
=	O
1	int
;	O
}	O
else	O
{	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
curseq	int
++	O
;	O
}	O
return	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
prevgtag	()->(*(char))
(	O
)	O
{	O
struct	O
tag	*(char)
*	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
prev	*(char)
;	O
if	O
(	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
TAG_END	O
)	O
{	O
if	O
(	O
!	O
circular	int
)	O
return	O
NULL	O
;	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
taglist	struct(*(struct),*(struct))
.	O
tl_last	*(struct)
;	O
curseq	int
=	O
total	int
;	O
}	O
else	O
{	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
=	O
tp	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
;	O
curseq	int
--	O
;	O
}	O
return	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_file	*(char)
)	O
;	O
}	O
static	O
POSITION	long
gtagsearch	()->(long)
(	O
)	O
{	O
if	O
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
==	O
NULL	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
return	O
(	O
find_pos	(long)->(long)
(	O
curtag	*(struct(*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(struct(*(struct`),*(struct`),*(char),long,*(char),char)),*(char),long,*(char),char))
->	O
tag_linenum	long
)	O
)	O
;	O
}	O
static	O
int	O
getentry	()->(int)
(	O
buf	*(char)
,	O
tag	*(char)
,	O
file	*(char)
,	O
line	*(char)
)	O
char	O
*	O
buf	*(char)
;	O
char	O
*	O
*	O
tag	*(char)
;	O
char	O
*	O
*	O
file	*(char)
;	O
char	O
*	O
*	O
line	*(char)
;	O
{	O
char	O
*	O
p	*(char)
=	O
buf	*(char)
;	O
for	O
(	O
*	O
tag	*(char)
=	O
p	*(char)
;	O
*	O
p	*(char)
&&	O
!	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
for	O
(	O
;	O
*	O
p	*(char)
&&	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
IS_DIGIT	O
(	O
*	O
p	*(char)
)	O
)	O
{	O
for	O
(	O
;	O
*	O
p	*(char)
&&	O
!	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
for	O
(	O
;	O
*	O
p	*(char)
&&	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
}	O
if	O
(	O
!	O
IS_DIGIT	O
(	O
*	O
p	*(char)
)	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
*	O
line	*(char)
=	O
p	*(char)
;	O
for	O
(	O
*	O
line	*(char)
=	O
p	*(char)
;	O
*	O
p	*(char)
&&	O
!	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
for	O
(	O
;	O
*	O
p	*(char)
&&	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
*	O
file	*(char)
=	O
p	*(char)
;	O
for	O
(	O
*	O
file	*(char)
=	O
p	*(char)
;	O
*	O
p	*(char)
&&	O
!	O
IS_SPACE	O
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
*	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
*	O
tag	*(char)
)	O
&&	O
strlen	(*(char))->(long)
(	O
*	O
line	*(char)
)	O
&&	O
strlen	(*(char))->(long)
(	O
*	O
file	*(char)
)	O
&&	O
atoi	(*(char))->(int)
(	O
*	O
line	*(char)
)	O
>	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
