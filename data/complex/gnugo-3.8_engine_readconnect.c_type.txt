typedef	O
struct	O
_zone	O
{	O
int	O
array	*(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
bits	O
[	O
1	int
+	O
BOARDMAX	O
/	O
32	int
]	O
;	O
int	O
i	int
;	O
}	O
zone	O
;	O
static	O
int	O
recursive_connect2	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
)	O
;	O
static	O
int	O
recursive_disconnect2	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
)	O
;	O
static	O
int	O
recursive_break	O
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
)	O
;	O
static	O
int	O
recursive_block	O
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
)	O
;	O
static	O
int	O
add_array	O
(	O
int	O
*	O
array	*(struct(array(long)))
,	O
int	O
elt	O
)	O
;	O
static	O
int	O
element_array	O
(	O
int	O
*	O
array	*(struct(array(long)))
,	O
int	O
elt	O
)	O
;	O
static	O
void	O
intersection_array	O
(	O
int	O
*	O
array1	O
,	O
int	O
*	O
array2	O
)	O
;	O
static	O
int	O
snapback	O
(	O
int	O
str	int
)	O
;	O
static	O
int	O
connection_one_move	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
prevent_connection_one_move	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
connected_one_move	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
moves_to_connect_in_two_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
connection_two_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
prevent_connection_two_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
moves_to_connect_in_three_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
does_connect	O
)	O
;	O
static	O
int	O
recursive_connect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
recursive_disconnect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
quiescence_connect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
quiescence_capture	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
prevent_capture_one_move	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
)	O
;	O
static	O
int	O
recursive_transitivity	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
recursive_non_transitivity	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
void	O
order_connection_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
const	O
char	O
*	O
funcname	O
)	O
;	O
static	O
int	O
nodes_connect	O
=	O
0	int
;	O
static	O
signed	O
char	O
connection_shadow	array(char)
[	O
BOARDMAX	O
]	O
;	O
static	O
signed	O
char	O
breakin_shadow	array(char)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
global_connection_node_counter	O
=	O
0	int
;	O
static	O
void	O
init_zone	O
(	O
zone	O
*	O
zn	O
)	O
{	O
zn	O
->	O
array	*(struct(array(long)))
[	O
0	int
]	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
zn	O
->	O
bits	O
,	O
0	int
,	O
1	int
+	O
BOARDMAX	O
/	O
8	int
)	O
;	O
}	O
static	O
void	O
add_zone	O
(	O
zone	O
*	O
zn	O
,	O
int	O
elt	O
)	O
{	O
if	O
(	O
(	O
(	O
zn	O
->	O
bits	O
[	O
elt	O
>>	O
5	int
]	O
>>	O
(	O
elt	O
&	O
31	int
)	O
)	O
&	O
1	int
)	O
==	O
0	int
)	O
{	O
zn	O
->	O
bits	O
[	O
elt	O
>>	O
5	int
]	O
|=	O
(	O
1	int
<<	O
(	O
elt	O
&	O
31	int
)	O
)	O
;	O
zn	O
->	O
array	*(struct(array(long)))
[	O
0	int
]	O
++	O
;	O
zn	O
->	O
array	*(struct(array(long)))
[	O
zn	O
->	O
array	*(struct(array(long)))
[	O
0	int
]	O
]	O
=	O
elt	O
;	O
}	O
}	O
static	O
int	O
add_array	O
(	O
int	O
*	O
array	*(struct(array(long)))
,	O
int	O
elt	O
)	O
{	O
int	O
r	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<	O
array	*(struct(array(long)))
[	O
0	int
]	O
+	O
1	int
;	O
r	O
++	O
)	O
if	O
(	O
array	*(struct(array(long)))
[	O
r	O
]	O
==	O
elt	O
)	O
return	O
0	int
;	O
array	*(struct(array(long)))
[	O
0	int
]	O
++	O
;	O
array	*(struct(array(long)))
[	O
array	*(struct(array(long)))
[	O
0	int
]	O
]	O
=	O
elt	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
element_array	O
(	O
int	O
*	O
array	*(struct(array(long)))
,	O
int	O
elt	O
)	O
{	O
int	O
r	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<	O
array	*(struct(array(long)))
[	O
0	int
]	O
+	O
1	int
;	O
r	O
++	O
)	O
if	O
(	O
array	*(struct(array(long)))
[	O
r	O
]	O
==	O
elt	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
intersection_array	O
(	O
int	O
*	O
array1	O
,	O
int	O
*	O
array2	O
)	O
{	O
int	O
r	O
,	O
s	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<	O
array1	O
[	O
0	int
]	O
+	O
1	int
;	O
r	O
++	O
)	O
if	O
(	O
!	O
element_array	O
(	O
array2	O
,	O
array1	O
[	O
r	O
]	O
)	O
)	O
{	O
for	O
(	O
s	O
=	O
r	O
;	O
s	O
<	O
array1	O
[	O
0	int
]	O
;	O
s	O
++	O
)	O
array1	O
[	O
s	O
]	O
=	O
array1	O
[	O
s	O
+	O
1	int
]	O
;	O
array1	O
[	O
0	int
]	O
--	O
;	O
r	O
--	O
;	O
}	O
}	O
static	O
int	O
snapback	O
(	O
int	O
str	int
)	O
{	O
int	O
stones	*(int)
,	O
liberties	*(int)
,	O
lib	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
stones	*(int)
=	O
countstones	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
stones	*(int)
>	O
1	int
)	O
return	O
0	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
1	int
)	O
return	O
0	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
"snapback"	*(char)
,	O
str	int
)	O
)	O
{	O
liberties	*(int)
=	O
0	int
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
lib	int
]	O
)	O
)	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
lib	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
if	O
(	O
liberties	*(int)
>	O
1	int
)	O
return	O
0	int
;	O
return	O
WIN	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ponnuki_connect	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
zone	O
*	O
zn	O
)	O
{	O
int	O
r	O
,	O
s	O
,	O
k	int
,	O
res	O
=	O
0	int
;	O
int	O
liberties	*(int)
,	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighb	O
,	O
neighbs	O
[	O
MAXCHAIN	int
]	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
r	O
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
)	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
board	*(char)
[	O
str1	int
]	O
&&	O
!	O
same_string	(int,int)->(int)
(	O
pos	int
,	O
str1	int
)	O
&&	O
!	O
same_string	(int,int)->(int)
(	O
pos	int
,	O
str2	int
)	O
)	O
{	O
neighb	O
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAXLIBS	O
,	O
neighbs	O
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
neighb	O
;	O
s	O
++	O
)	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
neighbs	O
[	O
s	O
]	O
,	O
str2	int
)	O
)	O
{	O
res	O
=	O
1	int
;	O
add_zone	O
(	O
zn	O
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_zone	O
(	O
zn	O
,	O
neighbs	O
[	O
s	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
neighbs	O
[	O
s	O
]	O
)	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
pos	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adj	array(int)
;	O
s	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
s	O
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	O
(	O
adjs	O
[	O
s	O
]	O
)	O
)	O
{	O
res	O
=	O
1	int
;	O
neighb	O
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
s	O
]	O
,	O
1	int
,	O
neighbs	O
)	O
;	O
add_zone	O
(	O
zn	O
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_zone	O
(	O
zn	O
,	O
neighbs	O
[	O
0	int
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
neighbs	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
return	O
res	O
;	O
}	O
static	O
int	O
moves_connection_one_move	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
zone	O
*	O
zn	O
)	O
{	O
int	O
r	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
str1	int
,	O
str2	int
,	O
NULL	O
)	O
)	O
return	O
WIN	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	O
(	O
adjs	O
[	O
r	O
]	O
)	O
)	O
return	O
WIN	O
;	O
if	O
(	O
ponnuki_connect	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
zn	O
)	O
)	O
return	O
WIN	O
;	O
if	O
(	O
ponnuki_connect	O
(	O
moves	array(int)
,	O
str2	int
,	O
str1	int
,	O
zn	O
)	O
)	O
return	O
WIN	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
connection_one_move	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
zone	O
zn	O
;	O
init_zone	O
(	O
&	O
zn	O
)	O
;	O
moves	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
return	O
moves_connection_one_move	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
&	O
zn	O
)	O
;	O
}	O
static	O
int	O
prevent_connection_one_move	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
s	O
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	O
,	O
adjadjs	O
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
str1	int
,	O
str2	int
,	O
libs	*(int)
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
return	O
WIN	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	O
(	O
adjs	O
[	O
r	O
]	O
)	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
adjadj	O
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
adjadjs	O
,	O
1	int
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adjadj	O
;	O
s	O
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjadjs	O
[	O
s	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
}	O
return	O
WIN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
connected_one_move	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
moves	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
{	O
order_connection_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"connected_one_move"	*(char)
)	O
;	O
res	O
=	O
WIN	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
(	O
(	O
r	O
<	O
moves	array(int)
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
res	O
)	O
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
moves	array(int)
[	O
r	O
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"connected_one_move"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	O
(	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
moves_to_connect_in_two_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
s	O
,	O
common_adj_liberty	O
;	O
int	O
liberties	*(int)
,	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	O
,	O
adjadjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
str1	int
]	O
;	O
int	O
move	*(int)
;	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
str1	int
,	O
str2	int
,	O
libs	*(int)
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
adj	array(int)
=	O
chainlinks3	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
2	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
common_adj_liberty	O
=	O
0	int
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
s	O
]	O
,	O
str2	int
)	O
)	O
common_adj_liberty	O
=	O
1	int
;	O
if	O
(	O
common_adj_liberty	O
||	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
)	O
{	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
adjadj	O
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
adjadjs	O
,	O
1	int
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adjadj	O
;	O
s	O
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjadjs	O
[	O
s	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
adj	array(int)
=	O
chainlinks3	(int,array(int),int)->(int)
(	O
str2	int
,	O
adjs	O
,	O
2	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
common_adj_liberty	O
=	O
0	int
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
s	O
]	O
,	O
str1	int
)	O
)	O
common_adj_liberty	O
=	O
1	int
;	O
if	O
(	O
common_adj_liberty	O
||	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str1	int
)	O
)	O
{	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
adjadj	O
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
adjadjs	O
,	O
1	int
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adjadj	O
;	O
s	O
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjadjs	O
[	O
s	O
]	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
SOUTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
SOUTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
WEST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
WEST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
NORTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
NORTH	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
EAST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
EAST	O
(	O
libs	*(int)
[	O
r	O
]	O
)	O
)	O
;	O
}	O
}	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
same_string	(int,int)->(int)
(	O
pos	int
,	O
str1	int
)	O
&&	O
quiescence_connect	O
(	O
pos	int
,	O
str2	int
,	O
&	O
move	*(int)
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str2	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
same_string	(int,int)->(int)
(	O
pos	int
,	O
str2	int
)	O
&&	O
quiescence_connect	O
(	O
pos	int
,	O
str1	int
,	O
&	O
move	*(int)
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
r	O
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
connection_two_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
,	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
moves	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
moves_to_connect_in_two_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
WIN	O
;	O
order_connection_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"connection_two_moves"	*(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
(	O
(	O
r	O
<	O
moves	array(int)
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
!	O
res	O
)	O
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
moves	array(int)
[	O
r	O
]	O
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"connection_two_moves"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
connected_one_move	O
(	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
WIN	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
moves_to_prevent_connection_in_two_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
if	O
(	O
moves_to_connect_in_two_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
prevent_connection_two_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
;	O
int	O
possible_moves	O
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
connection_two_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	O
=	O
WIN	O
;	O
possible_moves	O
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_two_moves	O
(	O
possible_moves	O
,	O
str1	int
,	O
str2	int
)	O
;	O
order_connection_moves	O
(	O
possible_moves	O
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"prevent_connection_two_moves"	*(char)
)	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<	O
possible_moves	O
[	O
0	int
]	O
+	O
1	int
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
possible_moves	O
[	O
r	O
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"prevent_connection_two_moves"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	O
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
add_array	O
(	O
moves	array(int)
,	O
possible_moves	O
[	O
r	O
]	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
moves_to_connect_in_three_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
does_connect	O
)	O
{	O
int	O
r	O
,	O
s	O
;	O
int	O
liberties	*(int)
,	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties2	int
,	O
libs2	O
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	O
,	O
adjadjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
move	*(int)
;	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
secondlib1	O
[	O
BOARDMAX	O
]	O
;	O
int	O
secondlib2	O
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
moves_to_connect_in_two_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
secondlib1	O
,	O
0	int
,	O
sizeof	O
(	O
secondlib1	O
)	O
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
secondlib1	O
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
board	*(char)
[	O
str1	int
]	O
)	O
{	O
liberties2	int
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs2	O
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties2	int
;	O
s	O
++	O
)	O
secondlib1	O
[	O
libs2	O
[	O
s	O
]	O
]	O
=	O
1	int
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
secondlib2	O
,	O
0	int
,	O
sizeof	O
(	O
secondlib2	O
)	O
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str2	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
secondlib2	O
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
board	*(char)
[	O
str2	int
]	O
)	O
{	O
liberties2	int
=	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs2	O
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties2	int
;	O
s	O
++	O
)	O
secondlib2	O
[	O
libs2	O
[	O
s	O
]	O
]	O
=	O
1	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
secondlib1	O
[	O
pos	int
]	O
&&	O
secondlib2	O
[	O
pos	int
]	O
)	O
add_array	O
(	O
moves	array(int)
,	O
pos	int
)	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
adjadj	O
=	O
chainlinks	(int,array(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
adjadjs	O
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adjadj	O
;	O
s	O
++	O
)	O
{	O
if	O
(	O
!	O
same_string	(int,int)->(int)
(	O
adjadjs	O
[	O
s	O
]	O
,	O
str1	int
)	O
&&	O
quiescence_connect	O
(	O
adjadjs	O
[	O
s	O
]	O
,	O
str2	int
,	O
&	O
move	*(int)
)	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
1	int
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str2	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
adjadj	O
=	O
chainlinks	(int,array(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
adjadjs	O
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
adjadj	O
;	O
s	O
++	O
)	O
{	O
if	O
(	O
!	O
same_string	(int,int)->(int)
(	O
adjadjs	O
[	O
s	O
]	O
,	O
str2	int
)	O
&&	O
quiescence_connect	O
(	O
adjadjs	O
[	O
s	O
]	O
,	O
str1	int
,	O
&	O
move	*(int)
)	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
1	int
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
adj	array(int)
=	O
chainlinks3	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
2	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
if	O
(	O
second_order_liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
s	O
]	O
,	O
str2	int
)	O
)	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
}	O
adj	array(int)
=	O
chainlinks3	(int,array(int),int)->(int)
(	O
str2	int
,	O
adjs	O
,	O
2	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
if	O
(	O
second_order_liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
s	O
]	O
,	O
str1	int
)	O
)	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
3	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
,	O
NULL	O
)	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
does_connect	O
||	O
(	O
ON_BOARD	O
(	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
(	O
secondlib1	O
[	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
||	O
secondlib2	O
[	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str2	int
,	O
adjs	O
,	O
3	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str1	int
,	O
NULL	O
)	O
)	O
{	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
liberties	*(int)
;	O
s	O
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
does_connect	O
||	O
(	O
ON_BOARD	O
(	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
(	O
secondlib1	O
[	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
||	O
secondlib2	O
[	O
libs	*(int)
[	O
s	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
)	O
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
s	O
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
moves_to_prevent_connection_in_three_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
if	O
(	O
moves_to_connect_in_three_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
0	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
simply_connected_two_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
moves	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	O
=	O
WIN	O
;	O
order_connection_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"simply_connected_two_moves"	*(char)
)	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
(	O
(	O
r	O
<	O
moves	array(int)
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
res	O
)	O
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
moves	array(int)
[	O
r	O
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"simply_connected_two_moves"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	O
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
simple_connection_three_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
,	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
moves	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
moves_to_connect_in_two_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
WIN	O
;	O
order_connection_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"simple_connection_three_moves"	*(char)
)	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
(	O
(	O
r	O
<	O
moves	array(int)
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
!	O
res	O
)	O
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
moves	array(int)
[	O
r	O
]	O
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"simple_connection_three_moves"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
simply_connected_two_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
WIN	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
prevent_simple_connection_three_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
;	O
int	O
possible_moves	O
[	O
MAX_MOVES	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
simple_connection_three_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	O
=	O
WIN	O
;	O
possible_moves	O
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_three_moves	O
(	O
possible_moves	O
,	O
str1	int
,	O
str2	int
)	O
;	O
order_connection_moves	O
(	O
moves	array(int)
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"prevent_simple_connection_three_moves"	*(char)
)	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<	O
possible_moves	O
[	O
0	int
]	O
+	O
1	int
;	O
r	O
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
possible_moves	O
[	O
r	O
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"prevent_simple_connection_three_moves"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	O
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
simple_connection_three_moves	O
(	O
str1	int
,	O
str2	int
)	O
)	O
add_array	O
(	O
moves	array(int)
,	O
possible_moves	O
[	O
r	O
]	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
quiescence_connect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
r	O
;	O
int	O
lib	int
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
str1	int
,	O
str2	int
,	O
&	O
lib	int
)	O
)	O
{	O
*	O
move	*(int)
=	O
lib	int
;	O
return	O
WIN	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	O
(	O
adjs	O
[	O
r	O
]	O
)	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
1	int
,	O
move	*(int)
)	O
;	O
return	O
WIN	O
;	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
2	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
)	O
if	O
(	O
quiescence_capture	O
(	O
adjs	O
[	O
r	O
]	O
,	O
move	*(int)
)	O
)	O
return	O
WIN	O
;	O
return	O
0	int
;	O
}	O
int	O
string_connect	(int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
dummy_move	O
;	O
int	O
save_verbose	int
;	O
int	O
result	int
;	O
if	O
(	O
move	*(int)
==	O
NULL	O
)	O
move	*(int)
=	O
&	O
dummy_move	O
;	O
nodes_connect	O
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
if	O
(	O
alternate_connections	int
)	O
{	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
double	O
start	O
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
save_connection_node_limit	O
=	O
connection_node_limit	int
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
str1	int
=	O
find_origin	(int)->(int)
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	(int)->(int)
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	O
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	O
;	O
}	O
connection_node_limit	int
*=	O
pow	(double,double)->(double)
(	O
1.45	int
,	O
-	O
stackp	int
+	O
get_depth_modification	()->(int)
(	O
)	O
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	O
=	O
gg_cputime	()->(double)
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
connection_shadow	array(char)
,	O
0	int
,	O
sizeof	O
(	O
connection_shadow	array(char)
)	O
)	O
;	O
result	int
=	O
recursive_connect2	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
connection_node_limit	int
=	O
save_connection_node_limit	O
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oconnect    %1M %1M, result %d %1M (%d, %d nodes, %f seconds)\n"	*(char)
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	*(int)
,	O
nodes_connect	O
,	O
tactical_nodes	int
,	O
gg_cputime	()->(double)
(	O
)	O
-	O
start	O
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oconnect %1m %1m %d %1m "	*(char)
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	*(int)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
return	O
recursive_connect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
;	O
}	O
static	O
int	O
recursive_connect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
,	O
res	O
=	O
0	int
,	O
Moves	O
[	O
MAX_MOVES	O
]	O
,	O
ForcedMoves	O
[	O
MAX_MOVES	O
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_connect"	*(char)
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"already connected"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
quiescence_connect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"quiescence_connect"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
ForcedMoves	O
[	O
0	int
]	O
=	O
0	int
;	O
Moves	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
prevent_capture_one_move	O
(	O
ForcedMoves	O
,	O
str1	int
)	O
)	O
prevent_capture_one_move	O
(	O
ForcedMoves	O
,	O
str2	int
)	O
;	O
moves_to_connect_in_three_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
1	int
)	O
;	O
if	O
(	O
ForcedMoves	O
[	O
0	int
]	O
!=	O
0	int
&&	O
Moves	O
[	O
0	int
]	O
!=	O
0	int
)	O
intersection_array	O
(	O
Moves	O
,	O
ForcedMoves	O
)	O
;	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"recursive_connect"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"recursive_connect"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_disconnect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
res	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"success"	*(char)
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"failure"	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
int	O
disconnect	(int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
;	O
int	O
res	O
=	O
WIN	O
;	O
int	O
Moves	O
[	O
MAX_MOVES	O
]	O
;	O
int	O
dummy_move	O
;	O
int	O
result	int
;	O
int	O
save_verbose	int
;	O
if	O
(	O
move	*(int)
==	O
NULL	O
)	O
move	*(int)
=	O
&	O
dummy_move	O
;	O
nodes_connect	O
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
if	O
(	O
alternate_connections	int
)	O
{	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
save_connection_node_limit	O
=	O
connection_node_limit	int
;	O
double	O
start	O
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
WIN	O
;	O
str1	int
=	O
find_origin	(int)->(int)
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	(int)->(int)
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	O
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	O
;	O
}	O
connection_node_limit	int
*=	O
pow	(double,double)->(double)
(	O
1.5	int
,	O
-	O
stackp	int
+	O
get_depth_modification	()->(int)
(	O
)	O
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	O
=	O
gg_cputime	()->(double)
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
connection_shadow	array(char)
,	O
0	int
,	O
sizeof	O
(	O
connection_shadow	array(char)
)	O
)	O
;	O
result	int
=	O
recursive_disconnect2	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
connection_node_limit	int
=	O
save_connection_node_limit	O
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%odisconnect %1m %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	*(int)
,	O
nodes_connect	O
,	O
tactical_nodes	int
,	O
gg_cputime	()->(double)
(	O
)	O
-	O
start	O
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%odisconnect %1m %1m %d %1m "	*(char)
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	*(int)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
Moves	O
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_three_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
Moves	O
[	O
0	int
]	O
>	O
0	int
)	O
res	O
=	O
0	int
;	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"disconnect"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"disconnect"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_connect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
res	O
;	O
}	O
int	O
fast_disconnect	(int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
result	int
;	O
int	O
save_limit	O
=	O
connection_node_limit	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
WIN	O
;	O
str1	int
=	O
find_origin	(int)->(int)
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	(int)->(int)
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	O
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	O
;	O
}	O
modify_depth_values	(int)->(void)
(	O
-	O
3	int
)	O
;	O
connection_node_limit	int
/=	O
4	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
result	int
=	O
recursive_disconnect2	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
connection_node_limit	int
=	O
save_limit	O
;	O
modify_depth_values	(int)->(void)
(	O
3	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
recursive_disconnect	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
,	O
res	O
=	O
WIN	O
,	O
Moves	O
[	O
MAX_MOVES	O
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_disconnect"	*(char)
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
quiescence_capture	O
(	O
str1	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"first string capturable"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
quiescence_capture	O
(	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"second string capturable"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"already connected"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
Moves	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
0	int
;	O
else	O
if	O
(	O
prevent_connection_two_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
0	int
;	O
else	O
if	O
(	O
prevent_simple_connection_three_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
)	O
)	O
res	O
=	O
0	int
;	O
if	O
(	O
res	O
==	O
0	int
)	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"recursive_disconnect"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"recursive_disconnect"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_connect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
res	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"success"	*(char)
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"failure"	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
int	O
quiescence_capture	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
result	int
=	O
0	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
move	*(int)
)	O
;	O
result	int
=	O
WIN	O
;	O
}	O
else	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
)	O
result	int
=	O
simple_ladder	(int,*(int))->(int)
(	O
str	int
,	O
move	*(int)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
prevent_capture_one_move	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
)	O
{	O
int	O
r	O
,	O
res	O
=	O
0	int
;	O
int	O
liberties	*(int)
,	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
if	O
(	O
liberties	*(int)
==	O
1	int
)	O
{	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
res	O
=	O
WIN	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str1	int
,	O
adjs	O
,	O
1	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
1	int
,	O
libs	*(int)
)	O
;	O
add_array	O
(	O
moves	array(int)
,	O
libs	*(int)
[	O
0	int
]	O
)	O
;	O
}	O
}	O
return	O
res	O
;	O
}	O
static	O
int	O
recursive_transitivity	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
,	O
res	O
=	O
0	int
,	O
Moves	O
[	O
MAX_MOVES	O
]	O
,	O
ForcedMoves	O
[	O
MAX_MOVES	O
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_transitivity"	*(char)
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str3	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
&&	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str3	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"already connected"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
quiescence_connect	O
(	O
str1	int
,	O
str3	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"quiescence_connect"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str2	int
,	O
str3	int
)	O
)	O
if	O
(	O
quiescence_connect	O
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"quiescence_connect"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
ForcedMoves	O
[	O
0	int
]	O
=	O
0	int
;	O
Moves	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
prevent_capture_one_move	O
(	O
ForcedMoves	O
,	O
str1	int
)	O
)	O
if	O
(	O
!	O
prevent_capture_one_move	O
(	O
ForcedMoves	O
,	O
str2	int
)	O
)	O
prevent_capture_one_move	O
(	O
ForcedMoves	O
,	O
str3	int
)	O
;	O
moves_to_connect_in_two_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
)	O
;	O
moves_to_connect_in_two_moves	O
(	O
Moves	O
,	O
str2	int
,	O
str3	int
)	O
;	O
if	O
(	O
(	O
ForcedMoves	O
[	O
0	int
]	O
!=	O
0	int
)	O
&&	O
(	O
Moves	O
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
intersection_array	O
(	O
Moves	O
,	O
ForcedMoves	O
)	O
;	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"recursive_transitivity"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
board	*(char)
[	O
str1	int
]	O
,	O
"recursive_transitivity"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_non_transitivity	O
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
res	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"success"	*(char)
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"failure"	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
int	O
non_transitivity	(int,int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
,	O
res	O
=	O
WIN	O
,	O
Moves	O
[	O
MAX_MOVES	O
]	O
;	O
nodes_connect	O
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
moves_to_prevent_connection_in_three_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
Moves	O
[	O
0	int
]	O
>	O
0	int
)	O
res	O
=	O
0	int
;	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"non_transitivity"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"non_transitivity"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_transitivity	O
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
int	O
recursive_non_transitivity	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
i	int
,	O
res	O
=	O
WIN	O
,	O
Moves	O
[	O
MAX_MOVES	O
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_non_transitivity"	*(char)
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str3	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
quiescence_capture	O
(	O
str1	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"first string capturable"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
quiescence_capture	O
(	O
str2	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"second string capturable"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
quiescence_capture	O
(	O
str3	int
,	O
move	*(int)
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"third string capturable"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
&&	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str3	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"already connected"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
Moves	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	O
(	O
Moves	O
,	O
str1	int
,	O
str3	int
)	O
)	O
res	O
=	O
0	int
;	O
else	O
if	O
(	O
prevent_connection_two_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str3	int
)	O
)	O
res	O
=	O
0	int
;	O
else	O
if	O
(	O
prevent_simple_connection_three_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str3	int
)	O
)	O
res	O
=	O
0	int
;	O
if	O
(	O
res	O
==	O
0	int
)	O
order_connection_moves	O
(	O
Moves	O
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"recursive_non_transitivity"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	O
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	O
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
Moves	O
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
"recursive_non_transitivity"	*(char)
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_transitivity	O
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	*(int)
)	O
)	O
{	O
*	O
move	*(int)
=	O
Moves	O
[	O
i	int
]	O
;	O
res	O
=	O
WIN	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
res	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	*(int)
,	O
WIN	O
,	O
"success"	*(char)
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"failure"	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
void	O
order_connection_moves	O
(	O
int	O
*	O
moves	array(int)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
const	O
char	O
*	O
funcname	O
)	O
{	O
int	O
scores	O
[	O
MAX_MOVES	O
]	O
;	O
int	O
r	O
;	O
int	O
i	int
,	O
j	int
;	O
UNUSED	O
(	O
str2	int
)	O
;	O
UNUSED	O
(	O
color_to_move	int
)	O
;	O
for	O
(	O
r	O
=	O
1	int
;	O
r	O
<=	O
moves	array(int)
[	O
0	int
]	O
;	O
r	O
++	O
)	O
{	O
int	O
move	*(int)
=	O
moves	array(int)
[	O
r	O
]	O
;	O
int	O
number_edges	*(int)
=	O
0	int
;	O
int	O
number_same_string	*(int)
=	O
0	int
;	O
int	O
number_own	*(int)
=	O
0	int
;	O
int	O
number_opponent	*(int)
=	O
0	int
;	O
int	O
captured_stones	*(int)
=	O
0	int
;	O
int	O
threatened_stones	*(int)
=	O
0	int
;	O
int	O
saved_stones	*(int)
=	O
0	int
;	O
int	O
number_open	*(int)
=	O
0	int
;	O
int	O
libs	*(int)
;	O
incremental_order_moves	(int,int,int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(void)
(	O
move	*(int)
,	O
color_to_move	int
,	O
str1	int
,	O
&	O
number_edges	*(int)
,	O
&	O
number_same_string	*(int)
,	O
&	O
number_own	*(int)
,	O
&	O
number_opponent	*(int)
,	O
&	O
captured_stones	*(int)
,	O
&	O
threatened_stones	*(int)
,	O
&	O
saved_stones	*(int)
,	O
&	O
number_open	*(int)
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o %1m values: %d %d %d %d %d %d %d %d\n"	*(char)
,	O
move	*(int)
,	O
number_edges	*(int)
,	O
number_same_string	*(int)
,	O
number_own	*(int)
,	O
number_opponent	*(int)
,	O
captured_stones	*(int)
,	O
threatened_stones	*(int)
,	O
saved_stones	*(int)
,	O
number_open	*(int)
)	O
;	O
scores	O
[	O
r	O
]	O
=	O
0	int
;	O
libs	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
color_to_move	int
,	O
10	int
,	O
NULL	O
)	O
;	O
if	O
(	O
libs	*(int)
==	O
1	int
&&	O
captured_stones	*(int)
==	O
0	int
)	O
scores	O
[	O
r	O
]	O
-=	O
10	int
;	O
if	O
(	O
libs	*(int)
<	O
4	int
)	O
scores	O
[	O
r	O
]	O
+=	O
libs	*(int)
;	O
else	O
scores	O
[	O
r	O
]	O
+=	O
4	int
;	O
if	O
(	O
captured_stones	*(int)
>	O
0	int
)	O
scores	O
[	O
r	O
]	O
+=	O
5	int
+	O
captured_stones	*(int)
;	O
if	O
(	O
threatened_stones	*(int)
>	O
0	int
)	O
scores	O
[	O
r	O
]	O
+=	O
3	int
;	O
if	O
(	O
saved_stones	*(int)
>	O
0	int
)	O
scores	O
[	O
r	O
]	O
+=	O
10	int
+	O
saved_stones	*(int)
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array(int)
[	O
0	int
]	O
;	O
i	int
++	O
)	O
{	O
int	O
maxscore	O
=	O
scores	O
[	O
i	int
]	O
;	O
int	O
max_at	O
=	O
i	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<=	O
moves	array(int)
[	O
0	int
]	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
scores	O
[	O
j	int
]	O
>	O
maxscore	O
)	O
{	O
maxscore	O
=	O
scores	O
[	O
j	int
]	O
;	O
max_at	O
=	O
j	int
;	O
}	O
}	O
if	O
(	O
max_at	O
!=	O
i	int
)	O
{	O
int	O
temp	O
=	O
moves	array(int)
[	O
i	int
]	O
;	O
int	O
tempmax	O
=	O
scores	O
[	O
i	int
]	O
;	O
moves	array(int)
[	O
i	int
]	O
=	O
moves	array(int)
[	O
max_at	O
]	O
;	O
scores	O
[	O
i	int
]	O
=	O
scores	O
[	O
max_at	O
]	O
;	O
moves	array(int)
[	O
max_at	O
]	O
=	O
temp	O
;	O
scores	O
[	O
max_at	O
]	O
=	O
tempmax	O
;	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oVariation %d:\n"	*(char)
,	O
count_variations	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array(int)
[	O
0	int
]	O
;	O
i	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%o  %1M %d\n"	*(char)
,	O
moves	array(int)
[	O
i	int
]	O
,	O
scores	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
chars	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"Move order for %s: %n"	*(char)
,	O
funcname	O
,	O
&	O
chars	O
)	O
;	O
pos	int
=	O
buf	*(char)
+	O
chars	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array(int)
[	O
0	int
]	O
;	O
i	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
pos	int
,	O
"%c%d (%d) %n"	*(char)
,	O
J	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
,	O
scores	O
[	O
i	int
]	O
,	O
&	O
chars	O
)	O
;	O
pos	int
+=	O
chars	O
;	O
}	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
}	O
void	O
reset_connection_node_counter	()->(void)
(	O
)	O
{	O
global_connection_node_counter	O
=	O
0	int
;	O
}	O
int	O
get_connection_node_counter	()->(int)
(	O
)	O
{	O
return	O
global_connection_node_counter	O
;	O
}	O
static	O
int	O
find_string_connection_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
*	O
total_distance	O
)	O
;	O
static	O
void	O
clear_connection_data	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
;	O
static	O
int	O
trivial_connection	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
does_secure_through_ladder	O
(	O
int	O
color	int
,	O
int	O
move	*(int)
,	O
int	O
pos	int
)	O
;	O
static	O
int	O
ladder_capture	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
ladder_capturable	O
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
no_escape_from_atari	O
(	O
int	O
str	int
)	O
;	O
static	O
int	O
no_escape_from_ladder	O
(	O
int	O
str	int
)	O
;	O
static	O
int	O
check_self_atari	O
(	O
int	O
pos	int
,	O
int	O
color_to_move	int
)	O
;	O
static	O
int	O
common_vulnerabilities	O
(	O
int	O
a1	O
,	O
int	O
a2	O
,	O
int	O
b1	O
,	O
int	O
b2	O
,	O
int	O
color	int
)	O
;	O
static	O
int	O
common_vulnerability	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
recursive_connect2	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str1	int
]	O
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	O
;	O
int	O
savemove	O
=	O
NO_MOVE	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
tried_moves	O
=	O
0	int
;	O
int	O
value	*(char)
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_connect2"	*(char)
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"already connected"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>	O
connect_depth2	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
str1	int
=	O
find_origin	(int)->(int)
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	(int)->(int)
(	O
str2	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_passed	O
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value	*(char)
,	O
NULL	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value	*(char)
,	O
value	*(char)
,	O
xpos	O
)	O
;	O
if	O
(	O
value	*(char)
!=	O
0	int
)	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
SGFTRACE2	O
(	O
xpos	O
,	O
value	*(char)
,	O
"cached"	*(char)
)	O
;	O
return	O
value	*(char)
;	O
}	O
if	O
(	O
trivial_connection	O
(	O
str1	int
,	O
str2	int
,	O
&	O
xpos	O
)	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
xpos	O
,	O
WIN	O
,	O
"trivial connection"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
num_moves	int
=	O
find_string_connection_moves	O
(	O
str1	int
,	O
str2	int
,	O
color	int
,	O
moves	array(int)
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	O
;	O
xpos	O
=	O
moves	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
xpos	O
,	O
color	int
,	O
"recursive_connect2"	*(char)
,	O
str1	int
,	O
&	O
ko_move	O
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	O
==	O
0	int
)	O
)	O
{	O
tried_moves	O
++	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
int	O
acode	int
=	O
recursive_disconnect2	O
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	O
,	O
WIN	O
,	O
"connection effective"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
acode	int
,	O
xpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_disconnect2	O
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	O
)	O
!=	O
WIN	O
)	O
{	O
savemove	O
=	O
xpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	O
==	O
0	int
&&	O
distance	int
<	O
FP	O
(	O
1.0	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
NO_MOVE	O
,	O
WIN	O
,	O
"no move, probably connected"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
savecode	O
!=	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
savemove	O
,	O
savecode	O
,	O
"saved move"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
SGFTRACE2	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
recursive_disconnect2	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str1	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	O
;	O
int	O
savemove	O
=	O
NO_MOVE	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
tried_moves	O
=	O
0	int
;	O
int	O
attack_code1	O
;	O
int	O
attack_pos1	O
;	O
int	O
attack_code2	O
;	O
int	O
attack_pos2	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
value	*(char)
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_disconnect2"	*(char)
,	O
str1	int
,	O
str2	int
)	O
;	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
if	O
(	O
board	*(char)
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
same_string	(int,int)->(int)
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"already connected"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
stackp	int
>	O
connect_depth2	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
str1	int
=	O
find_origin	(int)->(int)
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	(int)->(int)
(	O
str2	int
)	O
;	O
attack_code1	O
=	O
attack	(int,*(int))->(int)
(	O
str1	int
,	O
&	O
attack_pos1	O
)	O
;	O
if	O
(	O
attack_code1	O
==	O
WIN	O
)	O
{	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
SGFTRACE2	O
(	O
attack_pos1	O
,	O
WIN	O
,	O
"one string is capturable"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
attack_pos1	O
;	O
return	O
WIN	O
;	O
}	O
attack_code2	O
=	O
attack	(int,*(int))->(int)
(	O
str2	int
,	O
&	O
attack_pos2	O
)	O
;	O
if	O
(	O
attack_code2	O
==	O
WIN	O
)	O
{	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
SGFTRACE2	O
(	O
attack_pos2	O
,	O
WIN	O
,	O
"one string is capturable"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
attack_pos2	O
;	O
return	O
WIN	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value	*(char)
,	O
NULL	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value	*(char)
,	O
value	*(char)
,	O
xpos	O
)	O
;	O
if	O
(	O
value	*(char)
!=	O
0	int
)	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
SGFTRACE2	O
(	O
xpos	O
,	O
value	*(char)
,	O
"cached"	*(char)
)	O
;	O
return	O
value	*(char)
;	O
}	O
if	O
(	O
ladder_capture	O
(	O
str1	int
,	O
&	O
xpos	O
)	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
xpos	O
,	O
WIN	O
,	O
"first string capturable"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
ladder_capture	O
(	O
str2	int
,	O
&	O
xpos	O
)	O
==	O
WIN	O
)	O
{	O
SGFTRACE2	O
(	O
xpos	O
,	O
WIN	O
,	O
"second string capturable"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
num_moves	int
=	O
find_string_connection_moves	O
(	O
str1	int
,	O
str2	int
,	O
other	O
,	O
moves	array(int)
,	O
&	O
distance	int
)	O
;	O
if	O
(	O
attack_code1	O
!=	O
0	int
&&	O
num_moves	int
<	O
MAX_MOVES	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
==	O
attack_pos1	O
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_moves	int
)	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
attack_pos1	O
;	O
}	O
if	O
(	O
attack_code2	O
!=	O
0	int
&&	O
num_moves	int
<	O
MAX_MOVES	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
==	O
attack_pos2	O
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_moves	int
)	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
attack_pos2	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	O
;	O
xpos	O
=	O
moves	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
xpos	O
,	O
other	O
,	O
"recursive_disconnect2"	*(char)
,	O
str1	int
,	O
&	O
ko_move	O
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	O
==	O
0	int
)	O
)	O
{	O
tried_moves	O
++	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
int	O
dcode	int
=	O
recursive_connect2	O
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	O
,	O
WIN	O
,	O
"disconnection effective"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
dcode	int
,	O
xpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_connect2	O
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	O
)	O
!=	O
WIN	O
)	O
{	O
savemove	O
=	O
xpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	O
==	O
0	int
&&	O
distance	int
>=	O
FP	O
(	O
1.0	int
)	O
&&	O
(	O
has_passed	O
||	O
!	O
recursive_connect2	O
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
1	int
)	O
)	O
)	O
{	O
SGFTRACE2	O
(	O
NO_MOVE	O
,	O
WIN	O
,	O
"no move, probably disconnected"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
savecode	O
!=	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
savemove	O
,	O
savecode	O
,	O
"saved move"	*(char)
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
SGFTRACE2	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
find_connection_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
struct	O
connection_data	O
*	O
conn1	O
,	O
struct	O
connection_data	O
*	O
conn2	O
,	O
int	O
max_dist1	O
,	O
int	O
max_dist2	O
,	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
total_distance	O
,	O
int	O
cutoff	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str1	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
connect_move	O
=	O
(	O
color_to_move	int
==	O
color	int
)	O
;	O
int	O
r	O
;	O
int	O
distances	O
[	O
MAX_MOVES	O
]	O
;	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
attack_move	*(int)
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
defense_move	O
=	O
NO_MOVE	O
;	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
distance_limit	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
conn1	O
->	O
queue_end	O
;	O
r	O
++	O
)	O
{	O
int	O
pos	int
=	O
conn1	O
->	O
queue	O
[	O
r	O
]	O
;	O
int	O
dist1	O
=	O
conn1	O
->	O
distances	O
[	O
pos	int
]	O
;	O
int	O
deltadist1	O
=	O
conn1	O
->	O
deltas	O
[	O
pos	int
]	O
;	O
int	O
dist2	O
=	O
conn2	O
->	O
distances	O
[	O
pos	int
]	O
;	O
int	O
deltadist2	O
=	O
conn2	O
->	O
deltas	O
[	O
pos	int
]	O
;	O
int	O
d1	int
;	O
int	O
d2	int
;	O
int	O
distance	int
;	O
if	O
(	O
dist1	O
-	O
deltadist1	O
+	O
dist2	O
-	O
deltadist2	O
>	O
FP	O
(	O
2.5	int
)	O
||	O
dist1	O
>	O
max_dist1	O
+	O
FP	O
(	O
0.2	int
)	O
||	O
dist2	O
>	O
max_dist2	O
+	O
FP	O
(	O
0.2	int
)	O
)	O
continue	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%oMove %1m, (%f, %f, %f, %f)\n"	*(char)
,	O
pos	int
,	O
FIXED_TO_FLOAT	O
(	O
dist1	O
)	O
,	O
FIXED_TO_FLOAT	O
(	O
deltadist1	O
)	O
,	O
FIXED_TO_FLOAT	O
(	O
dist2	O
)	O
,	O
FIXED_TO_FLOAT	O
(	O
deltadist2	O
)	O
)	O
;	O
d1	int
=	O
dist1	O
-	O
deltadist1	O
;	O
d2	int
=	O
dist2	O
-	O
deltadist2	O
;	O
distance	int
=	O
d1	int
+	O
d2	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  %f, primary distance\n"	*(char)
,	O
FIXED_TO_FLOAT	O
(	O
distance	int
)	O
)	O
;	O
if	O
(	O
(	O
3	int
*	O
d1	int
)	O
/	O
2	int
>	O
d2	int
&&	O
(	O
3	int
*	O
d2	int
)	O
/	O
2	int
>	O
d1	int
)	O
{	O
distance	int
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  -0.1, well balanced\n"	*(char)
)	O
;	O
}	O
if	O
(	O
conn1	O
->	O
coming_from	int
[	O
pos	int
]	O
!=	O
NO_MOVE	O
&&	O
conn1	O
->	O
coming_from	int
[	O
pos	int
]	O
==	O
conn2	O
->	O
coming_from	int
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  discarded, not between strings\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
check_self_atari	O
(	O
pos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
pos	int
,	O
distance	int
,	O
moves	array(int)
,	O
distances	O
,	O
num_moves	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  discarded, self atari\n"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	O
)	O
{	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
pos	int
,	O
&	O
acode	int
,	O
&	O
attack_move	*(int)
,	O
&	O
dcode	int
,	O
&	O
defense_move	O
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  attack with code %d at %1m, defense with code %d at %1m\n"	*(char)
,	O
acode	int
,	O
attack_move	*(int)
,	O
dcode	int
,	O
defense_move	O
)	O
;	O
if	O
(	O
connect_move	O
&&	O
acode	int
!=	O
0	int
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
distance	int
+=	O
FP	O
(	O
0.5	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  +0.5, no defense\n"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
conn1	O
->	O
distances	O
[	O
attack_move	*(int)
]	O
+	O
conn2	O
->	O
distances	O
[	O
attack_move	*(int)
]	O
>	O
dist1	O
+	O
dist2	O
)	O
{	O
distance	int
+=	O
FP	O
(	O
0.5	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  +0.5, attack point not on shortest path\n"	*(char)
)	O
;	O
}	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
attack_move	*(int)
,	O
distance	int
-	O
FP	O
(	O
0.15	int
)	O
,	O
moves	array(int)
,	O
distances	O
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  -0.15 at %1m, capturing a string\n"	*(char)
,	O
attack_move	*(int)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
connect_move	O
&&	O
acode	int
!=	O
0	int
&&	O
dcode	int
!=	O
0	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
defense_move	O
,	O
distance	int
-	O
FP	O
(	O
0.5	int
)	O
,	O
moves	array(int)
,	O
distances	O
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  -0.5 at %1m, defending a string\n"	*(char)
,	O
defense_move	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
,	O
bpos	int
;	O
if	O
(	O
k	int
&	O
1	int
)	O
apos	int
=	O
conn1	O
->	O
vulnerable1	O
[	O
pos	int
]	O
;	O
else	O
apos	int
=	O
conn1	O
->	O
vulnerable2	O
[	O
pos	int
]	O
;	O
if	O
(	O
k	int
&	O
2	int
)	O
bpos	int
=	O
conn2	O
->	O
vulnerable1	O
[	O
pos	int
]	O
;	O
else	O
bpos	int
=	O
conn2	O
->	O
vulnerable2	O
[	O
pos	int
]	O
;	O
if	O
(	O
common_vulnerability	O
(	O
apos	int
,	O
bpos	int
,	O
color	int
)	O
)	O
{	O
if	O
(	O
check_self_atari	O
(	O
apos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
distance	int
,	O
moves	array(int)
,	O
distances	O
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  +0.0 at %1m, vulnerability\n"	*(char)
,	O
apos	int
)	O
;	O
}	O
if	O
(	O
bpos	int
!=	O
apos	int
&&	O
check_self_atari	O
(	O
bpos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
bpos	int
,	O
distance	int
,	O
moves	array(int)
,	O
distances	O
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o  +0.0 at %1m, vulnerability\n"	*(char)
,	O
bpos	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
num_moves	int
;	O
r	O
++	O
)	O
{	O
int	O
move	*(int)
=	O
moves	array(int)
[	O
r	O
]	O
;	O
int	O
adjacent_to_attacker	O
=	O
0	int
;	O
int	O
bonus_given	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	O
)	O
{	O
adjacent_to_attacker	O
=	O
1	int
;	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.15	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.15, adjacent to attacker string\n"	*(char)
,	O
move	*(int)
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
pos	int
)	O
<=	O
2	int
)	O
{	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.2	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.2, adjacent to attacker string with at most two liberties\n"	*(char)
,	O
move	*(int)
)	O
;	O
if	O
(	O
(	O
connect_move	O
||	O
!	O
bonus_given	O
)	O
&&	O
(	O
conn1	O
->	O
distances	O
[	O
move	*(int)
]	O
-	O
conn1	O
->	O
deltas	O
[	O
move	*(int)
]	O
<=	O
FP	O
(	O
0.5	int
)	O
||	O
conn1	O
->	O
distances	O
[	O
pos	int
]	O
-	O
conn1	O
->	O
deltas	O
[	O
pos	int
]	O
<=	O
FP	O
(	O
0.5	int
)	O
)	O
&&	O
(	O
conn2	O
->	O
distances	O
[	O
move	*(int)
]	O
-	O
conn2	O
->	O
deltas	O
[	O
move	*(int)
]	O
<=	O
FP	O
(	O
0.5	int
)	O
||	O
conn2	O
->	O
distances	O
[	O
pos	int
]	O
-	O
conn2	O
->	O
deltas	O
[	O
pos	int
]	O
<=	O
FP	O
(	O
0.5	int
)	O
)	O
&&	O
conn1	O
->	O
distances	O
[	O
pos	int
]	O
<	O
total_distance	O
&&	O
conn2	O
->	O
distances	O
[	O
pos	int
]	O
<	O
total_distance	O
)	O
{	O
bonus_given	O
=	O
1	int
;	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.7	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.7, capture or atari of immediately connecting string\n"	*(char)
,	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
pos	int
)	O
<=	O
2	int
)	O
{	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.2	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.2, adjacent to defender string with at most two liberties\n"	*(char)
,	O
move	*(int)
)	O
;	O
}	O
if	O
(	O
!	O
connect_move	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
==	O
1	int
&&	O
accuratelib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
other	O
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
{	O
int	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
bonus	O
;	O
bonus	O
=	O
FP	O
(	O
0.1	int
)	O
*	O
chainlinks2	(int,array(int),int)->(int)
(	O
pos	int
,	O
adjs	O
,	O
2	int
)	O
;	O
bonus	O
+=	O
FP	O
(	O
0.5	int
)	O
*	O
chainlinks2	(int,array(int),int)->(int)
(	O
pos	int
,	O
adjs	O
,	O
1	int
)	O
;	O
distances	O
[	O
r	O
]	O
-=	O
bonus	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -%f, capture of defender string\n"	*(char)
,	O
move	*(int)
,	O
FIXED_TO_FLOAT	O
(	O
bonus	O
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
adjacent_to_attacker	O
&&	O
!	O
connect_move	O
&&	O
is_edge_vertex	(int)->(int)
(	O
move	*(int)
)	O
)	O
{	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.1, disconnect move on edge\n"	*(char)
,	O
move	*(int)
)	O
;	O
}	O
if	O
(	O
ladder_capturable	O
(	O
move	*(int)
,	O
color_to_move	int
)	O
)	O
{	O
distances	O
[	O
r	O
]	O
+=	O
FP	O
(	O
0.3	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M +0.3, can be captured in a ladder\n"	*(char)
,	O
move	*(int)
)	O
;	O
}	O
if	O
(	O
(	O
liberty_of_string	(int,int)->(int)
(	O
move	*(int)
,	O
str1	int
)	O
&&	O
countlib	(int)->(int)
(	O
str1	int
)	O
==	O
3	int
)	O
||	O
(	O
ON_BOARD	O
(	O
str2	int
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
move	*(int)
,	O
str2	int
)	O
&&	O
countlib	(int)->(int)
(	O
str2	int
)	O
==	O
3	int
)	O
)	O
{	O
distances	O
[	O
r	O
]	O
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M -0.1, liberty of endpoint string with 3 libs\n"	*(char)
,	O
move	*(int)
)	O
;	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
int	O
mindistance	O
=	O
distances	O
[	O
i	int
]	O
;	O
int	O
min_at	O
=	O
i	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
num_moves	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
distances	O
[	O
j	int
]	O
<	O
mindistance	O
)	O
{	O
mindistance	O
=	O
distances	O
[	O
j	int
]	O
;	O
min_at	O
=	O
j	int
;	O
}	O
}	O
if	O
(	O
min_at	O
!=	O
i	int
)	O
{	O
int	O
temp	O
=	O
moves	array(int)
[	O
i	int
]	O
;	O
int	O
tempmin	O
=	O
distances	O
[	O
i	int
]	O
;	O
moves	array(int)
[	O
i	int
]	O
=	O
moves	array(int)
[	O
min_at	O
]	O
;	O
distances	O
[	O
i	int
]	O
=	O
distances	O
[	O
min_at	O
]	O
;	O
moves	array(int)
[	O
min_at	O
]	O
=	O
temp	O
;	O
distances	O
[	O
min_at	O
]	O
=	O
tempmin	O
;	O
}	O
}	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oSorted moves:\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%o%1M %f\n"	*(char)
,	O
moves	array(int)
[	O
i	int
]	O
,	O
FIXED_TO_FLOAT	O
(	O
distances	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
chars	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"Move order for %sconnect: %n"	*(char)
,	O
connect_move	O
?	O
""	*(char)
:	O
"dis"	*(char)
,	O
&	O
chars	O
)	O
;	O
pos	int
=	O
buf	*(char)
+	O
chars	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
pos	int
,	O
"%c%d (%4.2f) %n"	*(char)
,	O
J	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array(int)
[	O
i	int
]	O
)	O
,	O
FIXED_TO_FLOAT	O
(	O
distances	O
[	O
i	int
]	O
)	O
,	O
&	O
chars	O
)	O
;	O
pos	int
+=	O
chars	O
;	O
}	O
if	O
(	O
cutoff	int
<	O
HUGE_CONNECTION_DISTANCE	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
pos	int
,	O
"(cutoff %f)%n"	*(char)
,	O
FIXED_TO_FLOAT	O
(	O
cutoff	int
)	O
,	O
&	O
chars	O
)	O
;	O
pos	int
+=	O
chars	O
;	O
}	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
num_moves	int
==	O
0	int
)	O
return	O
num_moves	int
;	O
if	O
(	O
num_moves	int
<=	O
1	int
||	O
!	O
is_ko	(int,int,*(int))->(int)
(	O
moves	array(int)
[	O
0	int
]	O
,	O
color_to_move	int
,	O
NULL	O
)	O
)	O
distance_limit	O
=	O
distances	O
[	O
0	int
]	O
+	O
FP	O
(	O
1.5	int
)	O
;	O
else	O
distance_limit	O
=	O
distances	O
[	O
1	int
]	O
+	O
FP	O
(	O
1.5	int
)	O
;	O
if	O
(	O
num_moves	int
>	O
1	int
&&	O
distances	O
[	O
1	int
]	O
<	O
FP	O
(	O
1.0	int
)	O
&&	O
distances	O
[	O
1	int
]	O
>	O
distance_limit	O
)	O
distance_limit	O
=	O
distances	O
[	O
1	int
]	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
num_moves	int
;	O
r	O
++	O
)	O
{	O
if	O
(	O
r	O
>	O
1	int
&&	O
distances	O
[	O
r	O
]	O
>	O
distances	O
[	O
r	O
-	O
1	int
]	O
&&	O
distances	O
[	O
r	O
]	O
-	O
distances	O
[	O
r	O
-	O
1	int
]	O
>	O
(	O
8	int
-	O
r	O
)	O
*	O
FP	O
(	O
0.2	int
)	O
)	O
break	O
;	O
if	O
(	O
distances	O
[	O
r	O
]	O
>	O
distance_limit	O
||	O
distances	O
[	O
r	O
]	O
>	O
cutoff	int
)	O
break	O
;	O
}	O
num_moves	int
=	O
r	O
;	O
return	O
num_moves	int
;	O
}	O
static	O
int	O
find_string_connection_moves	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
*	O
total_distance	O
)	O
{	O
struct	O
connection_data	O
conn1	O
;	O
struct	O
connection_data	O
conn2	O
;	O
int	O
max_dist1	O
;	O
int	O
max_dist2	O
;	O
int	O
num_moves	int
;	O
int	O
lib	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
compute_connection_distances	O
(	O
str1	int
,	O
str2	int
,	O
FP	O
(	O
3.051	int
)	O
,	O
&	O
conn1	O
,	O
1	int
)	O
;	O
compute_connection_distances	O
(	O
str2	int
,	O
str1	int
,	O
FP	O
(	O
3.051	int
)	O
,	O
&	O
conn2	O
,	O
1	int
)	O
;	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn1	O
.	O
distances	O
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	O
.	O
coming_from	int
[	O
lib	int
]	O
=	O
NO_MOVE	O
;	O
conn2	O
.	O
distances	O
[	O
lib	int
]	O
=	O
conn2	O
.	O
distances	O
[	O
str1	int
]	O
;	O
conn2	O
.	O
coming_from	int
[	O
lib	int
]	O
=	O
conn1	O
.	O
coming_from	int
[	O
str1	int
]	O
;	O
}	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
str2	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn2	O
.	O
distances	O
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	O
.	O
distances	O
[	O
lib	int
]	O
=	O
conn1	O
.	O
distances	O
[	O
str2	int
]	O
;	O
}	O
max_dist1	O
=	O
conn1	O
.	O
distances	O
[	O
str2	int
]	O
;	O
max_dist2	O
=	O
conn2	O
.	O
distances	O
[	O
str1	int
]	O
;	O
*	O
total_distance	O
=	O
gg_min	O
(	O
max_dist1	O
,	O
max_dist2	O
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oVariation %d\n"	*(char)
,	O
save_count_variations	O
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
print_connection_distances	O
(	O
&	O
conn1	O
)	O
;	O
print_connection_distances	O
(	O
&	O
conn2	O
)	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
num_moves	int
=	O
find_connection_moves	O
(	O
str1	int
,	O
str2	int
,	O
color_to_move	int
,	O
&	O
conn1	O
,	O
&	O
conn2	O
,	O
max_dist1	O
,	O
max_dist2	O
,	O
moves	array(int)
,	O
*	O
total_distance	O
,	O
HUGE_CONNECTION_DISTANCE	O
)	O
;	O
return	O
num_moves	int
;	O
}	O
static	O
void	O
add_to_start_queue	O
(	O
int	O
pos	int
,	O
int	O
dist	O
,	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
conn	*(struct)
->	O
queue	O
[	O
conn	*(struct)
->	O
queue_end	O
++	O
]	O
=	O
pos	int
;	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
=	O
dist	O
;	O
conn	*(struct)
->	O
deltas	O
[	O
pos	int
]	O
=	O
dist	O
;	O
conn	*(struct)
->	O
coming_from	int
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
void	O
init_connection_data	O
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
target	int
,	O
int	O
cutoff	int
,	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
speculative	O
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
mark	char
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mark	char
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
conn	*(struct)
,	O
sizeof	O
(	O
conn	*(struct)
)	O
)	O
;	O
clear_connection_data	O
(	O
conn	*(struct)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
int	O
origin	int
=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
mark	char
[	O
origin	int
]	O
)	O
{	O
add_to_start_queue	O
(	O
origin	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	*(struct)
)	O
;	O
mark	char
[	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
add_to_start_queue	O
(	O
pos	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
conn	*(struct)
)	O
;	O
}	O
}	O
conn	*(struct)
->	O
target	int
=	O
target	int
;	O
conn	*(struct)
->	O
cutoff_distance	O
=	O
cutoff	int
;	O
conn	*(struct)
->	O
speculative	O
=	O
speculative	O
;	O
}	O
static	O
int	O
find_break_moves	O
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
color_to_move	int
,	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
*	O
total_distance	O
)	O
{	O
struct	O
connection_data	O
conn1	O
;	O
struct	O
connection_data	O
conn2	O
;	O
int	O
max_dist1	O
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
int	O
max_dist2	O
;	O
int	O
num_moves	int
;	O
int	O
str2	int
=	O
NO_MOVE	O
;	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
lib	int
;	O
int	O
k	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
compute_connection_distances	O
(	O
str	int
,	O
NO_MOVE	O
,	O
FP	O
(	O
2.501	int
)	O
,	O
&	O
conn1	O
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn1	O
.	O
queue_end	O
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
conn1	O
.	O
queue	O
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
conn1	O
.	O
queue	O
[	O
k	int
]	O
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_stones	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
goal	*(char)
[	O
stones	*(int)
[	O
i	int
]	O
]	O
)	O
{	O
str2	int
=	O
find_origin	(int)->(int)
(	O
stones	*(int)
[	O
i	int
]	O
)	O
;	O
TRACE	O
(	O
"%oUsing %1m as secondary target.\n"	*(char)
,	O
str2	int
)	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
str2	int
,	O
breakin_shadow	array(char)
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
<	O
num_stones	int
)	O
break	O
;	O
}	O
init_connection_data	O
(	O
color	int
,	O
goal	*(char)
,	O
str	int
,	O
FP	O
(	O
2.501	int
)	O
,	O
&	O
conn2	O
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn2	O
.	O
queue_end	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
max_dist1	O
>	O
conn1	O
.	O
distances	O
[	O
conn2	O
.	O
queue	O
[	O
k	int
]	O
]	O
)	O
max_dist1	O
=	O
conn1	O
.	O
distances	O
[	O
conn2	O
.	O
queue	O
[	O
k	int
]	O
]	O
;	O
}	O
spread_connection_distances	O
(	O
color	int
,	O
&	O
conn2	O
)	O
;	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn1	O
.	O
distances	O
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	O
.	O
coming_from	int
[	O
lib	int
]	O
=	O
NO_MOVE	O
;	O
conn2	O
.	O
distances	O
[	O
lib	int
]	O
=	O
conn2	O
.	O
distances	O
[	O
str	int
]	O
;	O
conn2	O
.	O
coming_from	int
[	O
lib	int
]	O
=	O
conn1	O
.	O
coming_from	int
[	O
str	int
]	O
;	O
}	O
max_dist2	O
=	O
conn2	O
.	O
distances	O
[	O
str	int
]	O
;	O
*	O
total_distance	O
=	O
gg_min	O
(	O
max_dist1	O
,	O
max_dist2	O
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oVariation %d\n"	*(char)
,	O
save_count_variations	O
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
print_connection_distances	O
(	O
&	O
conn1	O
)	O
;	O
print_connection_distances	O
(	O
&	O
conn2	O
)	O
;	O
}	O
{	O
int	O
cutoff	int
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
if	O
(	O
breakin_depth	int
-	O
stackp	int
<=	O
5	int
)	O
cutoff	int
=	O
FP	O
(	O
1.101	int
)	O
+	O
(	O
breakin_depth	int
-	O
stackp	int
)	O
*	O
FP	O
(	O
0.15	int
)	O
;	O
num_moves	int
=	O
find_connection_moves	O
(	O
str	int
,	O
str2	int
,	O
color_to_move	int
,	O
&	O
conn1	O
,	O
&	O
conn2	O
,	O
max_dist1	O
,	O
max_dist2	O
,	O
moves	array(int)
,	O
*	O
total_distance	O
,	O
cutoff	int
)	O
;	O
}	O
if	O
(	O
color_to_move	int
!=	O
board	*(char)
[	O
str	int
]	O
)	O
{	O
int	O
move	*(int)
;	O
if	O
(	O
num_moves	int
<	O
MAX_MOVES	O
&&	O
ON_BOARD	O
(	O
str2	int
)	O
&&	O
ladder_capture	O
(	O
str2	int
,	O
&	O
move	*(int)
)	O
)	O
{	O
moves	array(int)
[	O
num_moves	int
++	O
]	O
=	O
move	*(int)
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
breakin_shadow	array(char)
[	O
moves	array(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
return	O
num_moves	int
;	O
}	O
static	O
int	O
recursive_break	O
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	O
;	O
int	O
savemove	O
=	O
NO_MOVE	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
tried_moves	O
=	O
0	int
;	O
int	O
retval	O
;	O
SETUP_TRACE_INFO	O
(	O
"recursive_break"	*(char)
,	O
str	int
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"one string already captured"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
breakin_node_limit	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>	O
breakin_depth	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_passed	O
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
BREAK_IN	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
&	O
retval	O
,	O
NULL	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	O
,	O
xpos	O
)	O
;	O
SGFTRACE	O
(	O
xpos	O
,	O
retval	O
,	O
"cached"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
return	O
retval	O
;	O
}	O
num_moves	int
=	O
find_break_moves	O
(	O
str	int
,	O
goal	*(char)
,	O
color	int
,	O
moves	array(int)
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	O
;	O
xpos	O
=	O
moves	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
xpos	O
,	O
color	int
,	O
"recursive_break"	*(char)
,	O
str	int
,	O
&	O
ko_move	O
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	O
==	O
0	int
)	O
)	O
{	O
tried_moves	O
++	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
int	O
acode	int
=	O
recursive_block	O
(	O
str	int
,	O
goal	*(char)
,	O
NULL	O
,	O
has_passed	O
,	O
goal_hash	*(struct(array(long)))
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	O
,	O
WIN	O
,	O
"break effective"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
acode	int
,	O
xpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_block	O
(	O
str	int
,	O
goal	*(char)
,	O
NULL	O
,	O
has_passed	O
,	O
goal_hash	*(struct(array(long)))
)	O
!=	O
WIN	O
)	O
{	O
savemove	O
=	O
xpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	O
==	O
0	int
&&	O
distance	int
<	O
FP	O
(	O
0.89	int
)	O
)	O
{	O
SGFTRACE	O
(	O
NO_MOVE	O
,	O
WIN	O
,	O
"no move, probably connected"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
savecode	O
!=	O
0	int
)	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"saved move"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
recursive_block	O
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
,	O
int	O
has_passed	O
,	O
Hash_data	struct(array(long))
*	O
goal_hash	*(struct(array(long)))
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	O
;	O
int	O
savemove	O
=	O
NO_MOVE	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
tried_moves	O
=	O
0	int
;	O
int	O
retval	O
;	O
SETUP_TRACE_INFO	O
(	O
"recursive_block"	*(char)
,	O
str	int
)	O
;	O
nodes_connect	O
++	O
;	O
global_connection_node_counter	O
++	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"string already captured"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
nodes_connect	O
>	O
breakin_node_limit	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection node limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
if	O
(	O
stackp	int
>	O
breakin_depth	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
"connection depth limit reached"	*(char)
)	O
;	O
return	O
WIN	O
;	O
}	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
BLOCK_OFF	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
&	O
retval	O
,	O
NULL	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	O
,	O
xpos	O
)	O
;	O
SGFTRACE	O
(	O
xpos	O
,	O
retval	O
,	O
"cached"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
return	O
retval	O
;	O
}	O
if	O
(	O
ladder_capture	O
(	O
str	int
,	O
&	O
xpos	O
)	O
==	O
WIN	O
)	O
{	O
SGFTRACE	O
(	O
xpos	O
,	O
WIN	O
,	O
"string capturable"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
num_moves	int
=	O
find_break_moves	O
(	O
str	int
,	O
goal	*(char)
,	O
other	O
,	O
moves	array(int)
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	O
;	O
xpos	O
=	O
moves	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
xpos	O
,	O
other	O
,	O
"recursive_block"	*(char)
,	O
str	int
,	O
&	O
ko_move	O
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	O
==	O
0	int
)	O
)	O
{	O
tried_moves	O
++	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
int	O
dcode	int
=	O
recursive_break	O
(	O
str	int
,	O
goal	*(char)
,	O
NULL	O
,	O
has_passed	O
,	O
goal_hash	*(struct(array(long)))
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	O
,	O
WIN	O
,	O
"block effective"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
xpos	O
,	O
WIN	O
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
dcode	int
,	O
xpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_break	O
(	O
str	int
,	O
goal	*(char)
,	O
NULL	O
,	O
has_passed	O
,	O
goal_hash	*(struct(array(long)))
)	O
!=	O
WIN	O
)	O
{	O
savemove	O
=	O
xpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	O
==	O
0	int
&&	O
distance	int
>=	O
FP	O
(	O
1.0	int
)	O
&&	O
(	O
has_passed	O
||	O
!	O
recursive_break	O
(	O
str	int
,	O
goal	*(char)
,	O
NULL	O
,	O
1	int
,	O
goal_hash	*(struct(array(long)))
)	O
)	O
)	O
{	O
SGFTRACE	O
(	O
NO_MOVE	O
,	O
WIN	O
,	O
"no move, probably disconnected"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
savecode	O
!=	O
0	int
)	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"saved move"	*(char)
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	*(struct(array(long)))
,	O
move	*(int)
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
int	O
break_in	(int,array(char),*(int))->(int)
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
dummy_move	O
;	O
int	O
save_verbose	int
;	O
int	O
result	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
double	O
start	O
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
Hash_data	struct(array(long))
goal_hash	*(struct(array(long)))
=	O
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
goal	*(char)
)	O
;	O
if	O
(	O
move	*(int)
==	O
NULL	O
)	O
move	*(int)
=	O
&	O
dummy_move	O
;	O
nodes_connect	O
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,*(int),*(int))->(int)
(	O
BREAK_IN	int
,	O
str	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
breakin_node_limit	int
,	O
&	O
result	int
,	O
move	*(int)
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Break-in from %1m to:\n"	*(char)
,	O
str	int
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"Result cached: %s %1m\n"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
*	O
move	*(int)
)	O
;	O
}	O
return	O
result	int
;	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	O
=	O
gg_cputime	()->(double)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
breakin_shadow	array(char)
,	O
goal	*(char)
,	O
sizeof	O
(	O
breakin_shadow	array(char)
)	O
)	O
;	O
result	int
=	O
recursive_break	O
(	O
str	int
,	O
goal	*(char)
,	O
move	*(int)
,	O
0	int
,	O
&	O
goal_hash	*(struct(array(long)))
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%obreak_in    %1M, result %s %1M (%d, %d nodes, %f seconds)\n"	*(char)
,	O
str	int
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
*	O
move	*(int)
,	O
nodes_connect	O
,	O
tactical_nodes	int
,	O
gg_cputime	()->(double)
(	O
)	O
-	O
start	O
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%obreak_in %1m %d %1m "	*(char)
,	O
str	int
,	O
result	int
,	O
*	O
move	*(int)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
}	O
store_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,int,int,int,array(char))->(void)
(	O
BREAK_IN	int
,	O
str	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
result	int
,	O
*	O
move	*(int)
,	O
tactical_nodes	int
,	O
breakin_node_limit	int
,	O
breakin_shadow	array(char)
)	O
;	O
return	O
result	int
;	O
}	O
int	O
block_off	(int,array(char),*(int))->(int)
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
dummy_move	O
;	O
int	O
result	int
;	O
int	O
save_verbose	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
double	O
start	O
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
Hash_data	struct(array(long))
goal_hash	*(struct(array(long)))
=	O
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
goal	*(char)
)	O
;	O
if	O
(	O
move	*(int)
==	O
NULL	O
)	O
move	*(int)
=	O
&	O
dummy_move	O
;	O
nodes_connect	O
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,*(int),*(int))->(int)
(	O
BLOCK_OFF	int
,	O
str	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
breakin_node_limit	int
,	O
&	O
result	int
,	O
move	*(int)
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Blocking off %1m from:\n"	*(char)
,	O
str	int
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"Result cached: %s %1m\n"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
*	O
move	*(int)
)	O
;	O
}	O
return	O
result	int
;	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	O
=	O
gg_cputime	()->(double)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
breakin_shadow	array(char)
,	O
goal	*(char)
,	O
sizeof	O
(	O
breakin_shadow	array(char)
)	O
)	O
;	O
result	int
=	O
recursive_block	O
(	O
str	int
,	O
goal	*(char)
,	O
move	*(int)
,	O
0	int
,	O
&	O
goal_hash	*(struct(array(long)))
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oblock_off %1m, result %s %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
str	int
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
*	O
move	*(int)
,	O
nodes_connect	O
,	O
tactical_nodes	int
,	O
gg_cputime	()->(double)
(	O
)	O
-	O
start	O
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oblock_off %1m %d %1m "	*(char)
,	O
str	int
,	O
result	int
,	O
*	O
move	*(int)
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
store_persistent_breakin_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct(array(long))),int,int,int,int,array(char))->(void)
(	O
BLOCK_OFF	int
,	O
str	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
result	int
,	O
*	O
move	*(int)
,	O
tactical_nodes	int
,	O
breakin_node_limit	int
,	O
breakin_shadow	array(char)
)	O
;	O
return	O
result	int
;	O
}	O
static	O
void	O
push_connection_heap_entry	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
distance	int
,	O
int	O
coming_from	int
,	O
int	O
target	int
,	O
connection_helper_fn_ptr	*((*(struct),int)->(void))
helper	*((*(struct),int)->(void))
)	O
{	O
int	O
k	int
;	O
int	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
heap_entry	struct(int,int,int,*((*(struct),int)->(void)))
*	O
new_entry	O
=	O
&	O
conn	*(struct)
->	O
heap_data	O
[	O
conn	*(struct)
->	O
heap_data_size	O
]	O
;	O
gg_assert	O
(	O
conn	*(struct)
->	O
heap_data_size	O
<	O
4	int
*	O
BOARDMAX	O
)	O
;	O
gg_assert	O
(	O
conn	*(struct)
->	O
heap_size	O
<	O
BOARDMAX	O
)	O
;	O
new_entry	O
->	O
distance	int
=	O
distance	int
;	O
new_entry	O
->	O
coming_from	int
=	O
coming_from	int
;	O
new_entry	O
->	O
target	int
=	O
target	int
;	O
new_entry	O
->	O
helper	*((*(struct),int)->(void))
=	O
helper	*((*(struct),int)->(void))
;	O
conn	*(struct)
->	O
heap_data_size	O
++	O
;	O
for	O
(	O
k	int
=	O
conn	*(struct)
->	O
heap_size	O
++	O
;	O
k	int
>	O
0	int
;	O
k	int
=	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
(	O
k	int
-	O
1	int
)	O
/	O
2	int
;	O
if	O
(	O
conn	*(struct)
->	O
heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
->	O
distance	int
<=	O
distance	int
)	O
break	O
;	O
conn	*(struct)
->	O
heap	O
[	O
k	int
]	O
=	O
conn	*(struct)
->	O
heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
;	O
}	O
conn	*(struct)
->	O
heap	O
[	O
k	int
]	O
=	O
new_entry	O
;	O
}	O
static	O
void	O
pop_connection_heap_entry	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
k	int
;	O
int	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
conn	*(struct)
->	O
heap_size	O
--	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
2	int
*	O
k	int
+	O
1	int
<	O
conn	*(struct)
->	O
heap_size	O
;	O
k	int
=	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
2	int
*	O
k	int
+	O
1	int
;	O
if	O
(	O
conn	*(struct)
->	O
heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
->	O
distance	int
>	O
conn	*(struct)
->	O
heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
]	O
->	O
distance	int
)	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
;	O
if	O
(	O
conn	*(struct)
->	O
heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
->	O
distance	int
>=	O
conn	*(struct)
->	O
heap	O
[	O
conn	*(struct)
->	O
heap_size	O
]	O
->	O
distance	int
)	O
break	O
;	O
conn	*(struct)
->	O
heap	O
[	O
k	int
]	O
=	O
conn	*(struct)
->	O
heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
;	O
}	O
conn	*(struct)
->	O
heap	O
[	O
k	int
]	O
=	O
conn	*(struct)
->	O
heap	O
[	O
conn	*(struct)
->	O
heap_size	O
]	O
;	O
}	O
static	O
void	O
case_6_7_helper	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct(int,int,int,*((*(struct),int)->(void)))
*	O
data	*(void)
=	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	*(void)
->	O
coming_from	int
;	O
int	O
apos	int
=	O
data	*(void)
->	O
target	int
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
ladder_capturable	O
(	O
apos	int
,	O
other	O
)	O
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
data	*(void)
->	O
distance	int
,	O
FP	O
(	O
0.6	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
{	O
int	O
this_delta	O
=	O
FP	O
(	O
0.85	int
)	O
+	O
FP	O
(	O
0.05	int
)	O
*	O
gg_min	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	O
,	O
5	int
,	O
NULL	O
)	O
,	O
5	int
)	O
;	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
data	*(void)
->	O
distance	int
+	O
this_delta	O
-	O
FP	O
(	O
0.6	int
)	O
,	O
this_delta	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
static	O
void	O
case_9_10_helper	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct(int,int,int,*((*(struct),int)->(void)))
*	O
data	*(void)
=	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	*(void)
->	O
coming_from	int
;	O
int	O
apos	int
=	O
data	*(void)
->	O
target	int
;	O
UNUSED	O
(	O
color	int
)	O
;	O
if	O
(	O
no_escape_from_ladder	O
(	O
apos	int
)	O
)	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
data	*(void)
->	O
distance	int
,	O
FP	O
(	O
0.3	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
else	O
{	O
if	O
(	O
conn	*(struct)
->	O
speculative	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.7	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.8	int
)	O
,	O
FP	O
(	O
1.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
case_16_17_18_helper	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct(int,int,int,*((*(struct),int)->(void)))
*	O
data	*(void)
=	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	*(void)
->	O
coming_from	int
;	O
int	O
bpos	int
=	O
data	*(void)
->	O
target	int
;	O
int	O
apos	int
=	O
SOUTH	O
(	O
gg_min	O
(	O
pos	int
,	O
bpos	int
)	O
)	O
;	O
int	O
gpos	O
=	O
NORTH	O
(	O
gg_max	O
(	O
pos	int
,	O
bpos	int
)	O
)	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
does_secure_through_ladder	O
(	O
color	int
,	O
bpos	int
,	O
apos	int
)	O
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
data	*(void)
->	O
distance	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
does_secure_through_ladder	O
(	O
color	int
,	O
bpos	int
,	O
gpos	O
)	O
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
data	*(void)
->	O
distance	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	O
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
other	O
&&	O
countlib	(int)->(int)
(	O
gpos	O
)	O
<=	O
3	int
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
&&	O
countlib	(int)->(int)
(	O
apos	int
)	O
<=	O
3	int
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	O
,	O
NO_MOVE	O
)	O
;	O
else	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
data	*(void)
->	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
,	O
FP	O
(	O
0.9	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
void	O
spread_connection_distances	O
(	O
int	O
color	int
,	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
=	O
0	int
;	O
int	O
stone	O
=	O
0	int
;	O
while	O
(	O
conn	*(struct)
->	O
queue_start	O
<	O
conn	*(struct)
->	O
queue_end	O
||	O
conn	*(struct)
->	O
heap_size	O
>	O
0	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
distance	int
;	O
while	O
(	O
conn	*(struct)
->	O
heap_size	O
>	O
0	int
&&	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
->	O
distance	int
>=	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
->	O
target	int
]	O
)	O
pop_connection_heap_entry	O
(	O
conn	*(struct)
)	O
;	O
if	O
(	O
stone	O
==	O
num_stones	int
)	O
{	O
int	O
best_index	O
=	O
-	O
1	int
;	O
int	O
smallest_dist	O
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
if	O
(	O
conn	*(struct)
->	O
queue_start	O
==	O
conn	*(struct)
->	O
queue_end	O
)	O
{	O
if	O
(	O
conn	*(struct)
->	O
heap_size	O
>	O
0	int
)	O
{	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
->	O
helper	*((*(struct),int)->(void))
(	O
conn	*(struct)
,	O
color	int
)	O
;	O
pop_connection_heap_entry	O
(	O
conn	*(struct)
)	O
;	O
}	O
continue	O
;	O
}	O
gg_assert	O
(	O
conn	*(struct)
->	O
queue_end	O
<=	O
MAX_BOARD	int
*	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
conn	*(struct)
->	O
queue_start	O
;	O
k	int
<	O
conn	*(struct)
->	O
queue_end	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
]	O
<	O
smallest_dist	O
)	O
{	O
smallest_dist	O
=	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
]	O
;	O
best_index	O
=	O
k	int
;	O
}	O
}	O
if	O
(	O
best_index	O
!=	O
conn	*(struct)
->	O
queue_start	O
)	O
{	O
int	O
temp	O
=	O
conn	*(struct)
->	O
queue	O
[	O
conn	*(struct)
->	O
queue_start	O
]	O
;	O
conn	*(struct)
->	O
queue	O
[	O
conn	*(struct)
->	O
queue_start	O
]	O
=	O
conn	*(struct)
->	O
queue	O
[	O
best_index	O
]	O
;	O
conn	*(struct)
->	O
queue	O
[	O
best_index	O
]	O
=	O
temp	O
;	O
}	O
if	O
(	O
conn	*(struct)
->	O
heap_size	O
>	O
0	int
&&	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
->	O
distance	int
<	O
smallest_dist	O
)	O
{	O
conn	*(struct)
->	O
heap	O
[	O
0	int
]	O
->	O
helper	*((*(struct),int)->(void))
(	O
conn	*(struct)
,	O
color	int
)	O
;	O
pop_connection_heap_entry	O
(	O
conn	*(struct)
)	O
;	O
continue	O
;	O
}	O
pos	int
=	O
conn	*(struct)
->	O
queue	O
[	O
conn	*(struct)
->	O
queue_start	O
++	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
{	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
pos	int
=	O
stones	*(int)
[	O
0	int
]	O
;	O
stone	O
=	O
1	int
;	O
}	O
}	O
else	O
{	O
pos	int
=	O
stones	*(int)
[	O
stone	O
++	O
]	O
;	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
=	O
conn	*(struct)
->	O
distances	O
[	O
stones	*(int)
[	O
0	int
]	O
]	O
;	O
conn	*(struct)
->	O
deltas	O
[	O
pos	int
]	O
=	O
conn	*(struct)
->	O
deltas	O
[	O
stones	*(int)
[	O
0	int
]	O
]	O
;	O
conn	*(struct)
->	O
coming_from	int
[	O
pos	int
]	O
=	O
conn	*(struct)
->	O
coming_from	int
[	O
stones	*(int)
[	O
0	int
]	O
]	O
;	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
=	O
conn	*(struct)
->	O
vulnerable1	O
[	O
stones	*(int)
[	O
0	int
]	O
]	O
;	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
=	O
conn	*(struct)
->	O
vulnerable2	O
[	O
stones	*(int)
[	O
0	int
]	O
]	O
;	O
}	O
distance	int
=	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
;	O
if	O
(	O
distance	int
>	O
conn	*(struct)
->	O
cutoff_distance	O
)	O
break	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
right	O
=	O
delta	array(int)
[	O
k	int
]	O
;	O
int	O
up	O
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
apos	int
=	O
pos	int
+	O
right	O
;	O
int	O
bpos	int
=	O
pos	int
+	O
right	O
+	O
up	O
;	O
int	O
cpos	int
=	O
pos	int
+	O
2	int
*	O
right	O
;	O
int	O
epos	O
=	O
pos	int
+	O
2	int
*	O
up	O
;	O
int	O
fpos	O
=	O
pos	int
+	O
right	O
+	O
2	int
*	O
up	O
;	O
int	O
gpos	O
=	O
pos	int
+	O
up	O
;	O
int	O
hpos	O
=	O
pos	int
-	O
right	O
;	O
int	O
ipos	O
=	O
pos	int
-	O
right	O
+	O
up	O
;	O
int	O
jpos	O
=	O
pos	int
-	O
right	O
+	O
2	int
*	O
up	O
;	O
int	O
kpos	O
=	O
pos	int
-	O
2	int
*	O
right	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
is_suicide	(int,int)->(int)
(	O
apos	int
,	O
other	O
)	O
)	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
&&	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	O
)	O
)	O
{	O
int	O
lib	int
;	O
int	O
vulnerable1	O
=	O
NO_MOVE	O
;	O
int	O
vulnerable2	O
=	O
NO_MOVE	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	O
,	O
1	int
,	O
&	O
lib	int
)	O
>=	O
1	int
)	O
{	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
other	O
,	O
2	int
,	O
NULL	O
)	O
>	O
2	int
)	O
vulnerable1	O
=	O
lib	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
pos	int
)	O
==	O
2	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
lib	int
+	O
delta	array(int)
[	O
i	int
]	O
]	O
==	O
EMPTY	int
&&	O
lib	int
+	O
delta	array(int)
[	O
i	int
]	O
!=	O
apos	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
lib	int
+	O
delta	array(int)
[	O
i	int
]	O
,	O
other	O
,	O
"compute_connection_distances"	*(char)
,	O
pos	int
)	O
)	O
{	O
if	O
(	O
ladder_capture	O
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
vulnerable2	O
=	O
lib	int
+	O
delta	array(int)
[	O
i	int
]	O
;	O
popgo	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
vulnerable1	O
,	O
vulnerable2	O
,	O
color	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
vulnerable1	O
,	O
vulnerable2	O
)	O
;	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
==	O
color	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
color	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
gpos	O
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
apos	int
,	O
gpos	O
,	O
color	int
)	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
apos	int
,	O
gpos	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
color	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
gpos	O
,	O
other	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
bpos	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
&&	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
color	int
||	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
apos	int
,	O
gpos	O
,	O
color	int
)	O
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
&&	O
(	O
board	*(char)
[	O
fpos	O
]	O
==	O
color	int
||	O
(	O
board	*(char)
[	O
fpos	O
]	O
==	O
EMPTY	int
&&	O
countlib	(int)->(int)
(	O
epos	O
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
fpos	O
,	O
gpos	O
,	O
color	int
)	O
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
fpos	O
,	O
other	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
apos	int
,	O
fpos	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
!=	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
fpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
!=	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
ipos	O
]	O
==	O
EMPTY	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
ipos	O
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
&&	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
color	int
||	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
EMPTY	int
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
hpos	O
,	O
gpos	O
,	O
color	int
)	O
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
hpos	O
,	O
other	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
&&	O
(	O
board	*(char)
[	O
jpos	O
]	O
==	O
color	int
||	O
(	O
board	*(char)
[	O
jpos	O
]	O
==	O
EMPTY	int
&&	O
countlib	(int)->(int)
(	O
epos	O
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
,	O
jpos	O
,	O
gpos	O
,	O
color	int
)	O
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
jpos	O
,	O
other	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
jpos	O
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
hpos	O
,	O
jpos	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
jpos	O
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
hpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
hpos	O
]	O
!=	O
EMPTY	int
&&	O
board	*(char)
[	O
jpos	O
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
jpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
hpos	O
]	O
!=	O
EMPTY	int
&&	O
board	*(char)
[	O
jpos	O
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
)	O
{	O
push_connection_heap_entry	O
(	O
conn	*(struct)
,	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
,	O
pos	int
,	O
apos	int
,	O
case_6_7_helper	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
&&	O
no_escape_from_atari	O
(	O
apos	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
)	O
{	O
push_connection_heap_entry	O
(	O
conn	*(struct)
,	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
pos	int
,	O
apos	int
,	O
case_9_10_helper	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	(int,int,int)->(int)
(	O
color	int
,	O
bpos	int
,	O
apos	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	(int,int,int)->(int)
(	O
color	int
,	O
bpos	int
,	O
gpos	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	(int,int,int)->(int)
(	O
color	int
,	O
epos	O
,	O
gpos	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
(	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
fpos	O
]	O
==	O
color	int
&&	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
)	O
||	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
color	int
&&	O
board	*(char)
[	O
jpos	O
]	O
==	O
color	int
&&	O
board	*(char)
[	O
ipos	O
]	O
==	O
EMPTY	int
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
gpos	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	O
]	O
==	O
EMPTY	int
&&	O
(	O
conn	*(struct)
->	O
distances	O
[	O
fpos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
||	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>=	O
3	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
cpos	int
)	O
||	O
!	O
ON_BOARD	O
(	O
hpos	O
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
fpos	O
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
hpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
ipos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
jpos	O
]	O
==	O
EMPTY	int
&&	O
(	O
conn	*(struct)
->	O
distances	O
[	O
jpos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
||	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>=	O
3	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
)	O
||	O
!	O
ON_BOARD	O
(	O
kpos	O
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
jpos	O
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
)	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.2	int
)	O
)	O
{	O
push_connection_heap_entry	O
(	O
conn	*(struct)
,	O
distance	int
+	O
FP	O
(	O
1.2	int
)	O
,	O
pos	int
,	O
bpos	int
,	O
case_16_17_18_helper	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
gpos	O
]	O
==	O
other	O
&&	O
board	*(char)
[	O
epos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
epos	O
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
countstones	(int)->(int)
(	O
gpos	O
)	O
==	O
1	int
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
epos	O
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
other	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
(	O
countlib	(int)->(int)
(	O
apos	int
)	O
+	O
countlib	(int)->(int)
(	O
gpos	O
)	O
<=	O
6	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
other	O
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
(	O
countlib	(int)->(int)
(	O
apos	int
)	O
+	O
countlib	(int)->(int)
(	O
gpos	O
)	O
<=	O
5	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
<=	O
2	int
&&	O
no_escape_from_ladder	O
(	O
pos	int
)	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
right	O
=	O
delta	array(int)
[	O
k	int
]	O
;	O
int	O
up	O
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
apos	int
=	O
pos	int
+	O
right	O
;	O
int	O
bpos	int
=	O
pos	int
+	O
right	O
+	O
up	O
;	O
int	O
gpos	O
=	O
pos	int
+	O
up	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
color	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
this_delta	O
=	O
FP	O
(	O
0.8	int
)	O
+	O
FP	O
(	O
0.05	int
)	O
*	O
gg_min	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	O
,	O
6	int
,	O
NULL	O
)	O
,	O
6	int
)	O
;	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
this_delta	O
,	O
this_delta	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
other	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
1.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.5	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.5	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
gpos	O
]	O
==	O
EMPTY	int
&&	O
conn	*(struct)
->	O
distances	O
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	*(struct)
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
sort_connection_queue_tail	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
conn	*(struct)
->	O
queue_start	O
;	O
k	int
<	O
conn	*(struct)
->	O
queue_end	O
-	O
1	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
int	O
best_index	O
=	O
k	int
;	O
int	O
smallest_dist	O
=	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
]	O
;	O
for	O
(	O
i	int
=	O
k	int
+	O
1	int
;	O
i	int
<	O
conn	*(struct)
->	O
queue_end	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
queue	O
[	O
i	int
]	O
]	O
<	O
smallest_dist	O
)	O
{	O
best_index	O
=	O
i	int
;	O
smallest_dist	O
=	O
conn	*(struct)
->	O
distances	O
[	O
conn	*(struct)
->	O
queue	O
[	O
i	int
]	O
]	O
;	O
}	O
}	O
if	O
(	O
best_index	O
!=	O
k	int
)	O
{	O
int	O
temp	O
=	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
;	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
=	O
conn	*(struct)
->	O
queue	O
[	O
best_index	O
]	O
;	O
conn	*(struct)
->	O
queue	O
[	O
best_index	O
]	O
=	O
temp	O
;	O
}	O
}	O
}	O
void	O
expand_connection_queue	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
k	int
;	O
int	O
full_queue	O
[	O
BOARDMAX	O
]	O
;	O
int	O
full_queue_position	O
=	O
0	int
;	O
int	O
full_queue_start	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn	*(struct)
->	O
queue_end	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
conn	*(struct)
->	O
queue_start	O
)	O
full_queue_start	O
=	O
full_queue_position	O
;	O
if	O
(	O
board	*(char)
[	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
full_queue	O
[	O
full_queue_position	O
++	O
]	O
=	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
;	O
else	O
{	O
full_queue_position	O
+=	O
findstones	(int,int,*(int))->(int)
(	O
conn	*(struct)
->	O
queue	O
[	O
k	int
]	O
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
full_queue	O
+	O
full_queue_position	O
)	O
;	O
}	O
}	O
conn	*(struct)
->	O
queue_start	O
=	O
full_queue_start	O
;	O
conn	*(struct)
->	O
queue_end	O
=	O
full_queue_position	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
conn	*(struct)
->	O
queue	O
,	O
full_queue	O
,	O
conn	*(struct)
->	O
queue_end	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
static	O
void	O
clear_connection_data	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
pos	int
;	O
conn	*(struct)
->	O
queue_start	O
=	O
0	int
;	O
conn	*(struct)
->	O
queue_end	O
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
conn	*(struct)
->	O
deltas	O
[	O
pos	int
]	O
=	O
FP	O
(	O
0.0	int
)	O
;	O
conn	*(struct)
->	O
coming_from	int
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
conn	*(struct)
->	O
heap_data_size	O
=	O
0	int
;	O
conn	*(struct)
->	O
heap_size	O
=	O
0	int
;	O
}	O
void	O
compute_connection_distances	O
(	O
int	O
str	int
,	O
int	O
target	int
,	O
int	O
cutoff	int
,	O
struct	O
connection_data	O
*	O
conn	*(struct)
,	O
int	O
speculative	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
clear_connection_data	O
(	O
conn	*(struct)
)	O
;	O
add_to_start_queue	O
(	O
find_origin	(int)->(int)
(	O
str	int
)	O
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	*(struct)
)	O
;	O
conn	*(struct)
->	O
target	int
=	O
target	int
;	O
conn	*(struct)
->	O
cutoff_distance	O
=	O
cutoff	int
;	O
conn	*(struct)
->	O
speculative	O
=	O
speculative	O
;	O
spread_connection_distances	O
(	O
color	int
,	O
conn	*(struct)
)	O
;	O
}	O
void	O
print_connection_distances	O
(	O
struct	O
connection_data	O
*	O
conn	*(struct)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ch	O
;	O
int	O
pos	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  "	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
,	O
ch	O
=	O
'A'	O
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
,	O
ch	O
++	O
)	O
{	O
if	O
(	O
ch	O
==	O
'I'	O
)	O
ch	O
++	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %c "	*(char)
,	O
ch	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%2d "	*(char)
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
==	O
HUGE_CONNECTION_DISTANCE	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" O  "	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" X  "	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" .  "	*(char)
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3.1f "	*(char)
,	O
FIXED_TO_FLOAT	O
(	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
)	O
)	O
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Vulnerable:\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
conn	*(struct)
->	O
distances	O
[	O
pos	int
]	O
<	O
HUGE_CONNECTION_DISTANCE	O
&&	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
!=	O
NO_MOVE	O
||	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
" %1m:"	*(char)
,	O
pos	int
)	O
;	O
if	O
(	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
" %1m"	*(char)
,	O
conn	*(struct)
->	O
vulnerable1	O
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
" %1m"	*(char)
,	O
conn	*(struct)
->	O
vulnerable2	O
[	O
pos	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
int	O
trivial_connection	O
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
r	O
;	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
have_common_lib	(int,int,*(int))->(int)
(	O
str1	int
,	O
str2	int
,	O
move	*(int)
)	O
)	O
return	O
WIN	O
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
str1	int
,	O
adjs	O
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
str2	int
)	O
&&	O
attack	(int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
move	*(int)
)	O
==	O
WIN	O
)	O
{	O
result	int
=	O
WIN	O
;	O
break	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
does_secure_through_ladder	O
(	O
int	O
color	int
,	O
int	O
move	*(int)
,	O
int	O
pos	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
ladder_capturable	O
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
result	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
ladder_capture	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
result	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
liberties	*(int)
==	O
1	int
)	O
result	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
move	*(int)
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
2	int
)	O
result	int
=	O
simple_ladder	(int,*(int))->(int)
(	O
str	int
,	O
move	*(int)
)	O
;	O
else	O
result	int
=	O
0	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
ladder_capturable	O
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
pos	int
)	O
;	O
if	O
(	O
liberties	*(int)
==	O
1	int
&&	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
==	O
WIN	O
)	O
result	int
=	O
1	int
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
2	int
&&	O
simple_ladder	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
==	O
WIN	O
)	O
result	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
result	int
=	O
1	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
no_escape_from_atari	O
(	O
int	O
str	int
)	O
{	O
int	O
lib	int
;	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
>	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
accuratelib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
board	*(char)
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adj	array(int)
,	O
1	int
)	O
>	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
no_escape_from_ladder	O
(	O
int	O
str	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
&&	O
find_defense	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
result	int
=	O
1	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
&&	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adj	array(int)
,	O
1	int
)	O
==	O
0	int
&&	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
2	int
,	O
libs	*(int)
)	O
==	O
2	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
==	O
1	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
==	O
1	int
&&	O
ladder_capture	O
(	O
str	int
,	O
NULL	O
)	O
&&	O
!	O
find_defense	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
)	O
result	int
=	O
1	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
check_self_atari	O
(	O
int	O
pos	int
,	O
int	O
color_to_move	int
)	O
{	O
int	O
lib	int
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
pos	int
,	O
color_to_move	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
is_ko	(int,int,*(int))->(int)
(	O
pos	int
,	O
color_to_move	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color_to_move	int
,	O
1	int
,	O
&	O
lib	int
)	O
>=	O
1	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
color_to_move	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
ladder_capturable	O
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
color_to_move	int
)	O
)	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color_to_move	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
4	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
common_vulnerabilities	O
(	O
int	O
a1	O
,	O
int	O
a2	O
,	O
int	O
b1	O
,	O
int	O
b2	O
,	O
int	O
color	int
)	O
{	O
return	O
(	O
common_vulnerability	O
(	O
a1	O
,	O
b1	O
,	O
color	int
)	O
||	O
common_vulnerability	O
(	O
a1	O
,	O
b2	O
,	O
color	int
)	O
||	O
common_vulnerability	O
(	O
a2	O
,	O
b1	O
,	O
color	int
)	O
||	O
common_vulnerability	O
(	O
a2	O
,	O
b2	O
,	O
color	int
)	O
)	O
;	O
}	O
static	O
int	O
common_vulnerability	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
||	O
bpos	int
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
if	O
(	O
apos	int
==	O
bpos	int
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
countlib	(int)->(int)
(	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
<=	O
3	int
&&	O
liberty_of_string	(int,int)->(int)
(	O
bpos	int
,	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
