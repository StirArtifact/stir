extern	O
int	O
__check_rhosts_file	int
;	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
from	struct(short,short,struct(int),array(char))
;	O
char	O
*	O
hostname	*(char)
;	O
char	O
*	O
lusername	*(char)
;	O
char	O
*	O
rusername	*(char)
;	O
char	O
*	O
term	*(char)
;	O
char	O
*	O
env	array(*(char))
[	O
2	int
]	O
;	O
}	O
;	O
int	O
mode	int
=	O
MODE_INETD	int
;	O
int	O
port	int
=	O
0	int
;	O
int	O
maxchildren	int
=	O
DEFMAXCHILDREN	int
;	O
int	O
allow_root	int
=	O
0	int
;	O
int	O
verify_hostname	int
=	O
0	int
;	O
int	O
keepalive	int
=	O
1	int
;	O
int	O
reverse_required	int
=	O
0	int
;	O
int	O
debug_level	int
=	O
0	int
;	O
int	O
numchildren	int
;	O
int	O
netf	int
;	O
char	O
line	*(char)
[	O
1024	int
]	O
;	O
int	O
confirmed	int
;	O
const	O
char	O
*	O
path_login	*(char)
=	O
PATH_LOGIN	O
;	O
char	O
*	O
local_domain_name	*(char)
;	O
int	O
local_dot_count	int
;	O
struct	O
winsize	struct(short,short,short,short)
win	struct(short,short,short,short)
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
extern	O
int	O
iruserok	(int,int,*(char),*(char))->(int)
(	O
uint32_t	int
raddr	int
,	O
int	O
superuser	int
,	O
const	O
char	O
*	O
ruser	*(char)
,	O
const	O
char	O
*	O
luser	*(char)
)	O
;	O
void	O
rlogin_daemon	(int,int)->(void)
(	O
int	O
maxchildren	int
,	O
int	O
port	int
)	O
;	O
int	O
rlogind_auth	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
void	O
setup_tty	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
void	O
exec_login	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
int	O
authenticated	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
int	O
rlogind_mainloop	(int,int)->(int)
(	O
int	O
infd	int
,	O
int	O
outfd	int
)	O
;	O
int	O
do_rlogin	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
int	O
do_krb_login	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))),*(*(char)))->(int)
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
,	O
const	O
char	O
*	O
*	O
msg	*(*(char))
)	O
;	O
void	O
getstr	(int,*(*(char)),*(char))->(void)
(	O
int	O
infd	int
,	O
char	O
*	O
*	O
ptr	char
,	O
const	O
char	O
*	O
prefix	*(char)
)	O
;	O
void	O
protocol	char
(	O
int	O
f	int
,	O
int	O
p	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
int	O
control	(int,*(char),long)->(int)
(	O
int	O
pty	int
,	O
char	O
*	O
cp	*(char)
,	O
size_t	long
n	long
)	O
;	O
void	O
cleanup	(int)->(void)
(	O
int	O
signo	int
)	O
;	O
void	O
fatal	(int,*(char),int)->(void)
(	O
int	O
f	int
,	O
const	O
char	O
*	O
msg	*(*(char))
,	O
int	O
syserr	int
)	O
;	O
int	O
in_local_domain	(*(char))->(int)
(	O
char	O
*	O
hostname	*(char)
)	O
;	O
char	O
*	O
topdomain	(*(char),int)->(*(char))
(	O
char	O
*	O
name	*(char)
,	O
int	O
max_dots	int
)	O
;	O
void	O
rlogind_sigchld	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
--	O
numchildren	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
sig	int
,	O
rlogind_sigchld	(int)->(void)
)	O
;	O
}	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"Remote login server"	*(char)
;	O
const	O
char	O
*	O
program_authors	array(*(char))
[	O
]	O
=	O
{	O
"Alain Magloire"	*(char)
,	O
"Sergey Poznyakoff"	*(char)
,	O
NULL	O
}	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"allow-root"	*(char)
,	O
'o'	O
,	O
NULL	O
,	O
0	int
,	O
"allow uid == 0 to login, disabled by default"	*(char)
}	O
,	O
{	O
"verify-hostname"	*(char)
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
"ask hostname for verification"	*(char)
}	O
,	O
{	O
"daemon"	*(char)
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"daemon mode"	*(char)
}	O
,	O
{	O
"no-rhosts"	*(char)
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"ignore .rhosts file"	*(char)
}	O
,	O
{	O
"no-keepalive"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"do not set SO_KEEPALIVE"	*(char)
}	O
,	O
{	O
"local-domain"	*(char)
,	O
'L'	O
,	O
"NAME"	*(char)
,	O
0	int
,	O
"set local domain name"	*(char)
}	O
,	O
{	O
"debug"	*(char)
,	O
'D'	O
,	O
"LEVEL"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set debug level"	*(char)
}	O
,	O
{	O
"port"	*(char)
,	O
'p'	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"listen on given port (valid only in daemon mode)"	*(char)
}	O
,	O
{	O
"reverse-required"	*(char)
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
"require reverse resolving of a remote host IP"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
verify_hostname	int
=	O
1	int
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
arg	*(char)
)	O
debug_level	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
mode	int
=	O
MODE_DAEMON	int
;	O
if	O
(	O
arg	*(char)
)	O
maxchildren	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
maxchildren	int
==	O
0	int
)	O
maxchildren	int
=	O
DEFMAXCHILDREN	int
;	O
break	O
;	O
case	O
'l'	O
:	O
__check_rhosts_file	int
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
local_domain_name	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'n'	O
:	O
keepalive	int
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
allow_root	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
port	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
reverse_required	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
doc	*(char)
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"rlogind"	*(char)
,	O
program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
;	O
openlog	(*(char),int,int)->(void)
(	O
"rlogind"	*(char)
,	O
LOG_PID	int
|	O
LOG_CONS	int
,	O
LOG_AUTH	O
)	O
;	O
argc	int
-=	O
index	(*(char),int)->(*(char))
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"%d extra arguments"	*(char)
,	O
argc	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
!	O
local_domain_name	*(char)
)	O
{	O
char	O
*	O
p	int
=	O
localhost	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
p	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"can't determine local hostname"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
local_dot_count	int
=	O
2	int
;	O
local_domain_name	*(char)
=	O
topdomain	(*(char),int)->(*(char))
(	O
p	int
,	O
local_dot_count	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	int
;	O
local_dot_count	int
=	O
0	int
;	O
for	O
(	O
p	int
=	O
local_domain_name	*(char)
;	O
*	O
p	int
;	O
p	int
++	O
)	O
if	O
(	O
*	O
p	int
==	O
'.'	O
)	O
local_dot_count	int
++	O
;	O
}	O
if	O
(	O
mode	int
==	O
MODE_DAEMON	int
)	O
rlogin_daemon	(int,int)->(void)
(	O
maxchildren	int
,	O
port	int
)	O
;	O
else	O
exit	(int)->(void)
(	O
rlogind_mainloop	(int,int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rlogin_daemon	(int,int)->(void)
(	O
int	O
maxchildren	int
,	O
int	O
port	int
)	O
{	O
pid_t	int
pid	int
;	O
socklen_t	int
size	int
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
saddr	int
;	O
int	O
listenfd	int
,	O
fd	int
;	O
if	O
(	O
port	int
==	O
0	int
)	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
;	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
"login"	*(char)
,	O
"tcp"	*(char)
)	O
;	O
if	O
(	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
!=	O
NULL	O
)	O
port	int
=	O
ntohs	(short)->(short)
(	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
)	O
;	O
else	O
port	int
=	O
DEFPORT	int
;	O
}	O
if	O
(	O
daemon	(int,int)->(int)
(	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"failed to become a daemon %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
"fork failed, exiting"	*(char)
,	O
0	int
)	O
;	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
rlogind_sigchld	(int)->(void)
)	O
;	O
listenfd	int
=	O
socket	(int,int,int)->(int)
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
listenfd	int
==	O
-	O
1	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"socket: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
int	O
on	int
=	O
1	int
;	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
listenfd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
&	O
on	int
,	O
sizeof	O
on	int
)	O
;	O
}	O
size	int
=	O
sizeof	O
saddr	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
saddr	int
,	O
0	int
,	O
size	int
)	O
;	O
saddr	int
.	O
sin_family	short
=	O
AF_INET	O
;	O
saddr	int
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
htonl	(int)->(int)
(	O
INADDR_ANY	O
)	O
;	O
saddr	int
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
size	int
=	O
sizeof	O
saddr	int
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
listenfd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
saddr	int
,	O
size	int
)	O
==	O
-	O
1	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"bind: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
listen	(int,int)->(int)
(	O
listenfd	int
,	O
128	int
)	O
==	O
-	O
1	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"listen: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
numchildren	int
>	O
maxchildren	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"too many children (%d)"	*(char)
,	O
numchildren	int
)	O
;	O
pause	()->(int)
(	O
)	O
;	O
continue	O
;	O
}	O
size	int
=	O
sizeof	O
saddr	int
;	O
fd	int
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
listenfd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
saddr	int
,	O
&	O
size	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"accept: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"fork: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
listenfd	int
)	O
;	O
exit	(int)->(void)
(	O
rlogind_mainloop	(int,int)->(int)
(	O
fd	int
,	O
fd	int
)	O
)	O
;	O
}	O
else	O
numchildren	int
++	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
}	O
int	O
rlogind_auth	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
{	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
char	O
*	O
hostname	*(char)
;	O
int	O
authenticated	int
=	O
0	int
;	O
confirmed	int
=	O
0	int
;	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyaddr	(*(void),int,int)->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
(	O
char	O
*	O
)	O
&	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
sizeof	O
(	O
struct	O
in_addr	struct(int)
)	O
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_family	short
)	O
;	O
if	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
)	O
hostname	*(char)
=	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_name	*(char)
;	O
else	O
if	O
(	O
reverse_required	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"can't resolve remote IP address"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
hostname	*(char)
=	O
inet_ntoa	(struct(int))->(*(char))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
;	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
hostname	*(char)
)	O
;	O
if	O
(	O
verify_hostname	int
||	O
in_local_domain	(*(char))->(int)
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
)	O
)	O
{	O
int	O
match	int
=	O
0	int
;	O
for	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
)	O
;	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
&&	O
!	O
match	int
;	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
++	O
)	O
{	O
if	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
break	O
;	O
match	int
=	O
memcmp	(*(void),*(void),long)->(int)
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
[	O
0	int
]	O
,	O
&	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
sizeof	O
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
==	O
0	int
;	O
}	O
if	O
(	O
!	O
match	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
|	O
LOG_AUTH	O
,	O
"cannot find matching IP for %s (%s)"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
fd	int
,	O
"Permission denied"	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
{	O
int	O
port	int
=	O
ntohs	(short)->(short)
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_port	short
)	O
;	O
if	O
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_family	short
!=	O
AF_INET	O
||	O
port	int
>=	O
IPPORT_RESERVED	int
||	O
port	int
<	O
IPPORT_RESERVED	int
/	O
2	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"Connection from %s on illegal port %d"	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
,	O
port	int
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
fd	int
,	O
"Permission denied"	*(char)
,	O
0	int
)	O
;	O
}	O
{	O
unsigned	O
char	O
optbuf	array(char)
[	O
BUFSIZ	int
/	O
3	int
]	O
,	O
*	O
cp	*(char)
;	O
char	O
lbuf	array(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
lp	*(char)
;	O
socklen_t	int
optsize	int
=	O
sizeof	O
(	O
optbuf	array(char)
)	O
;	O
int	O
ipproto	int
;	O
struct	O
protoent	struct(*(char),*(*(char)),int)
*	O
ip	struct(int,int,char,short,short,short,char,char,short,struct(int),struct(int))
;	O
if	O
(	O
(	O
ip	struct(int,int,char,short,short,short,char,char,short,struct(int),struct(int))
=	O
getprotobyname	(*(char))->(*(struct(*(char),*(*(char)),int)))
(	O
"ip"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
ipproto	int
=	O
ip	struct(int,int,char,short,short,short,char,char,short,struct(int),struct(int))
->	O
p_proto	int
;	O
else	O
ipproto	int
=	O
IPPROTO_IP	int
;	O
if	O
(	O
getsockopt	(int,int,int,*(void),*(int))->(int)
(	O
0	int
,	O
ipproto	int
,	O
IP_OPTIONS	int
,	O
(	O
char	O
*	O
)	O
optbuf	array(char)
,	O
&	O
optsize	int
)	O
==	O
0	int
&&	O
optsize	int
!=	O
0	int
)	O
{	O
lp	*(char)
=	O
lbuf	array(char)
;	O
for	O
(	O
cp	*(char)
=	O
optbuf	array(char)
;	O
optsize	int
>	O
0	int
;	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
lp	*(char)
,	O
" %2.2x"	*(char)
,	O
*	O
cp	*(char)
)	O
;	O
lp	*(char)
+=	O
3	int
;	O
if	O
(	O
*	O
cp	*(char)
==	O
IPOPT_SSRR	int
||	O
*	O
cp	*(char)
==	O
IPOPT_LSRR	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"Discarding connection from %s with set source routing"	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
*	O
cp	*(char)
==	O
IPOPT_EOL	int
)	O
break	O
;	O
if	O
(	O
*	O
cp	*(char)
==	O
IPOPT_NOP	int
)	O
cp	*(char)
++	O
,	O
optsize	int
--	O
;	O
else	O
{	O
int	O
inc	int
=	O
cp	*(char)
[	O
1	int
]	O
;	O
optsize	int
-=	O
inc	int
;	O
cp	*(char)
+=	O
inc	int
;	O
}	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"Ignoring IP options: %s"	*(char)
,	O
lbuf	array(char)
)	O
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
0	int
,	O
ipproto	int
,	O
IP_OPTIONS	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
optsize	int
)	O
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"setsockopt IP_OPTIONS NULL: %m"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
do_rlogin	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
fd	int
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
==	O
0	int
)	O
authenticated	int
++	O
;	O
}	O
if	O
(	O
confirmed	int
==	O
0	int
)	O
{	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
""	*(char)
,	O
1	int
)	O
;	O
confirmed	int
=	O
1	int
;	O
}	O
IF_ENCRYPT	O
(	O
des_write	O
(	O
fd	int
,	O
SECURE_MESSAGE	O
,	O
sizeof	O
(	O
SECURE_MESSAGE	O
)	O
-	O
1	int
)	O
)	O
;	O
return	O
authenticated	int
;	O
}	O
void	O
setup_tty	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
{	O
register	O
char	O
*	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
term	*(char)
+	O
ENVSIZE	O
,	O
'/'	O
)	O
;	O
char	O
*	O
speed	*(char)
;	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
tt	struct(int,int,int,int,char,array(char),int,int)
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
fd	int
,	O
&	O
tt	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
speed	*(char)
=	O
cp	*(char)
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
speed	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
cfsetspeed	(*(struct(int,int,int,int,char,array(char),int,int)),int)->(int)
(	O
&	O
tt	struct(int,int,int,int,char,array(char),int,int)
,	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
speed	*(char)
,	O
NULL	O
,	O
10	int
)	O
)	O
;	O
}	O
tt	struct(int,int,int,int,char,array(char),int,int)
.	O
c_iflag	int
=	O
TTYDEF_IFLAG	O
;	O
tt	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	int
=	O
TTYDEF_OFLAG	O
;	O
tt	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
=	O
TTYDEF_LFLAG	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
fd	int
,	O
TCSAFLUSH	int
,	O
&	O
tt	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
env	array(*(char))
[	O
0	int
]	O
=	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
term	*(char)
;	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
env	array(*(char))
[	O
1	int
]	O
=	O
0	int
;	O
}	O
void	O
exec_login	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
int	O
authenticated	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
{	O
if	O
(	O
authenticated	int
)	O
{	O
execle	(*(char),*(char))->(int)
(	O
path_login	*(char)
,	O
"login"	*(char)
,	O
"-p"	*(char)
,	O
"-h"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
,	O
"-f"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
,	O
NULL	O
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
env	array(*(char))
)	O
;	O
}	O
else	O
{	O
execle	(*(char),*(char))->(int)
(	O
path_login	*(char)
,	O
"login"	*(char)
,	O
"-p"	*(char)
,	O
"-h"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
hostname	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
,	O
NULL	O
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
env	array(*(char))
)	O
;	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"can't exec login: %m"	*(char)
)	O
;	O
}	O
int	O
rlogind_mainloop	(int,int)->(int)
(	O
int	O
infd	int
,	O
int	O
outfd	int
)	O
{	O
socklen_t	int
size	int
;	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
;	O
int	O
true	int
;	O
char	O
c	char
;	O
int	O
authenticated	int
;	O
pid_t	int
pid	int
;	O
int	O
master	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
,	O
0	int
,	O
sizeof	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
)	O
;	O
size	int
=	O
sizeof	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
.	O
from	struct(short,short,struct(int),array(char))
;	O
if	O
(	O
getpeername	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
infd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
.	O
from	struct(short,short,struct(int),array(char))
,	O
&	O
size	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"Can't get peer name of remote host: %m"	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
outfd	int
,	O
"Can't get peer name of remote host"	*(char)
,	O
1	int
)	O
;	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"Connect from %s:%d"	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
.	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
,	O
ntohs	(short)->(short)
(	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
.	O
from	struct(short,short,struct(int),array(char))
.	O
sin_port	short
)	O
)	O
;	O
true	int
=	O
1	int
;	O
if	O
(	O
keepalive	int
&&	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
infd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	*(char)
)	O
;	O
true	int
=	O
IPTOS_LOWDELAY	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
infd	int
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	*(char)
)	O
;	O
alarm	(int)->(int)
(	O
60	int
)	O
;	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
infd	int
,	O
&	O
c	char
,	O
1	int
)	O
!=	O
1	int
||	O
c	char
!=	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
"protocol error: expected 0 byte"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
authenticated	int
=	O
rlogind_auth	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
infd	int
,	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
)	O
;	O
pid	int
=	O
forkpty	(*(int),*(char),*(struct(int,int,int,int,char,array(char),int,int)),*(struct(short,short,short,short)))->(int)
(	O
&	O
master	int
,	O
line	*(char)
,	O
NULL	O
,	O
&	O
win	struct(short,short,short,short)
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"Out of ptys"	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
infd	int
,	O
"Out of ptys"	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"forkpty: %m"	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
infd	int
,	O
"Forkpty"	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
if	O
(	O
infd	int
>	O
2	int
)	O
close	*((*(void))->(int))
(	O
infd	int
)	O
;	O
setup_tty	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
0	int
,	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
)	O
;	O
setup_utmp	O
(	O
line	*(char)
)	O
;	O
exec_login	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(void)
(	O
authenticated	int
,	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
infd	int
,	O
"can't execute login"	*(char)
,	O
1	int
)	O
;	O
}	O
true	int
=	O
1	int
;	O
IF_NOT_ENCRYPT	O
(	O
ioctl	(int,long)->(int)
(	O
infd	int
,	O
FIONBIO	int
,	O
&	O
true	int
)	O
)	O
;	O
ioctl	(int,long)->(int)
(	O
master	int
,	O
FIONBIO	int
,	O
&	O
true	int
)	O
;	O
ioctl	(int,long)->(int)
(	O
master	int
,	O
TIOCPKT	int
,	O
&	O
true	int
)	O
;	O
netf	int
=	O
infd	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
cleanup	(int)->(void)
)	O
;	O
protocol	char
(	O
infd	int
,	O
master	int
,	O
&	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_IGN	O
)	O
;	O
cleanup	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
do_rlogin	(int,*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))))->(int)
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
int	O
rc	int
;	O
getstr	(int,*(*(char)),*(char))->(void)
(	O
infd	int
,	O
&	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
rusername	*(char)
,	O
NULL	O
)	O
;	O
getstr	(int,*(*(char)),*(char))->(void)
(	O
infd	int
,	O
&	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
,	O
NULL	O
)	O
;	O
getstr	(int,*(*(char)),*(char))->(void)
(	O
infd	int
,	O
&	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
term	*(char)
,	O
"TERM="	*(char)
)	O
;	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
)	O
;	O
if	O
(	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
==	O
NULL	O
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"no passwd entry for %s"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
infd	int
,	O
"Permission denied"	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
allow_root	int
&&	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
==	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"root logins not permitted"	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
infd	int
,	O
"Permission denied"	*(char)
,	O
0	int
)	O
;	O
}	O
rc	int
=	O
iruserok	(int,int,*(char),*(char))->(int)
(	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
from	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
,	O
0	int
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
rusername	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"iruserok failed: rusername=%s, lusername=%s"	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
rusername	*(char)
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
->	O
lusername	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
getstr	(int,*(*(char)),*(char))->(void)
(	O
int	O
infd	int
,	O
char	O
*	O
*	O
ptr	char
,	O
const	O
char	O
*	O
prefix	*(char)
)	O
{	O
char	O
c	char
;	O
char	O
*	O
buf	*(char)
;	O
int	O
pos	int
;	O
int	O
size	int
=	O
BUFFER_SIZE	int
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
int	O
len	char
=	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
;	O
if	O
(	O
size	int
<	O
len	char
+	O
1	int
)	O
size	int
=	O
len	char
+	O
1	int
;	O
}	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
!	O
buf	*(char)
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"not enough memory"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
pos	int
=	O
0	int
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
prefix	*(char)
)	O
;	O
pos	int
+=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
}	O
do	O
{	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
infd	int
,	O
&	O
c	char
,	O
1	int
)	O
!=	O
1	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"read error: %m"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
pos	int
==	O
size	int
)	O
{	O
size	int
+=	O
BUFFER_SIZE	int
;	O
buf	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
size	int
)	O
;	O
if	O
(	O
!	O
buf	*(char)
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"not enough memory"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
buf	*(char)
[	O
pos	int
++	O
]	O
=	O
c	char
;	O
}	O
while	O
(	O
c	char
!=	O
0	int
)	O
;	O
*	O
ptr	char
=	O
buf	*(char)
;	O
}	O
char	O
magic	array(char)
[	O
2	int
]	O
=	O
{	O
0377	int
,	O
0377	int
}	O
;	O
char	O
oobdata	array(char)
[	O
]	O
=	O
{	O
TIOCPKT_WINDOW	int
}	O
;	O
void	O
protocol	char
(	O
int	O
f	int
,	O
int	O
p	int
,	O
struct	O
auth_data	struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char)))
*	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
{	O
char	O
fibuf	array(char)
[	O
1024	int
]	O
,	O
*	O
pbp	*(char)
=	O
NULL	O
,	O
*	O
fbp	*(char)
=	O
NULL	O
;	O
int	O
pcc	int
=	O
0	int
,	O
fcc	int
=	O
0	int
;	O
int	O
cc	int
,	O
nfd	int
,	O
n	long
;	O
char	O
cntl	char
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
send	(int,*(void),long,int)->(long)
(	O
f	int
,	O
oobdata	array(char)
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
if	O
(	O
f	int
>	O
p	int
)	O
nfd	int
=	O
f	int
+	O
1	int
;	O
else	O
nfd	int
=	O
p	int
+	O
1	int
;	O
if	O
(	O
nfd	int
>	O
FD_SETSIZE	O
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"select mask too small, increase FD_SETSIZE"	*(char)
)	O
;	O
fatal	(int,*(char),int)->(void)
(	O
f	int
,	O
"internal error (select mask too small)"	*(char)
,	O
0	int
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
fd_set	struct(array(long))
ibits	struct(array(long))
,	O
obits	struct(array(long))
,	O
ebits	struct(array(long))
,	O
*	O
omask	*(struct(array(long)))
;	O
FD_ZERO	O
(	O
&	O
ebits	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
ibits	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
obits	struct(array(long))
)	O
;	O
omask	*(struct(array(long)))
=	O
(	O
fd_set	struct(array(long))
*	O
)	O
NULL	O
;	O
if	O
(	O
fcc	int
)	O
{	O
FD_SET	O
(	O
p	int
,	O
&	O
obits	struct(array(long))
)	O
;	O
omask	*(struct(array(long)))
=	O
&	O
obits	struct(array(long))
;	O
}	O
else	O
FD_SET	O
(	O
f	int
,	O
&	O
ibits	struct(array(long))
)	O
;	O
if	O
(	O
pcc	int
>=	O
0	int
)	O
{	O
if	O
(	O
pcc	int
)	O
{	O
FD_SET	O
(	O
f	int
,	O
&	O
obits	struct(array(long))
)	O
;	O
omask	*(struct(array(long)))
=	O
&	O
obits	struct(array(long))
;	O
}	O
else	O
FD_SET	O
(	O
p	int
,	O
&	O
ibits	struct(array(long))
)	O
;	O
}	O
FD_SET	O
(	O
p	int
,	O
&	O
ebits	struct(array(long))
)	O
;	O
if	O
(	O
(	O
n	long
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
nfd	int
,	O
&	O
ibits	struct(array(long))
,	O
omask	*(struct(array(long)))
,	O
&	O
ebits	struct(array(long))
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
fatal	(int,*(char),int)->(void)
(	O
f	int
,	O
"select"	*(char)
,	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
sleep	(int)->(int)
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ebits	struct(array(long))
)	O
)	O
{	O
cc	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
p	int
,	O
&	O
cntl	char
,	O
1	int
)	O
;	O
if	O
(	O
cc	int
==	O
1	int
&&	O
pkcontrol	O
(	O
cntl	char
)	O
)	O
{	O
cntl	char
|=	O
oobdata	array(char)
[	O
0	int
]	O
;	O
send	(int,*(void),long,int)->(long)
(	O
f	int
,	O
&	O
cntl	char
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
if	O
(	O
cntl	char
&	O
TIOCPKT_FLUSHWRITE	int
)	O
{	O
pcc	int
=	O
0	int
;	O
FD_CLR	O
(	O
p	int
,	O
&	O
ibits	struct(array(long))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
f	int
,	O
&	O
ibits	struct(array(long))
)	O
)	O
{	O
ENC_READ	O
(	O
fcc	int
,	O
f	int
,	O
fibuf	array(char)
,	O
sizeof	O
(	O
fibuf	array(char)
)	O
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
if	O
(	O
fcc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
fcc	int
=	O
0	int
;	O
else	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
int	O
left	int
;	O
if	O
(	O
fcc	int
<=	O
0	int
)	O
break	O
;	O
fbp	*(char)
=	O
fibuf	array(char)
;	O
for	O
(	O
cp	*(char)
=	O
fibuf	array(char)
;	O
cp	*(char)
<	O
fibuf	array(char)
+	O
fcc	int
-	O
1	int
;	O
cp	*(char)
++	O
)	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
magic	array(char)
[	O
0	int
]	O
&&	O
cp	*(char)
[	O
1	int
]	O
==	O
magic	array(char)
[	O
1	int
]	O
)	O
{	O
int	O
len	char
;	O
left	int
=	O
fcc	int
-	O
(	O
cp	*(char)
-	O
fibuf	array(char)
)	O
;	O
len	char
=	O
control	(int,*(char),long)->(int)
(	O
p	int
,	O
cp	*(char)
,	O
left	int
)	O
;	O
if	O
(	O
len	char
)	O
{	O
left	int
-=	O
len	char
;	O
if	O
(	O
left	int
>	O
0	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
cp	*(char)
,	O
cp	*(char)
+	O
len	char
,	O
left	int
)	O
;	O
fcc	int
-=	O
len	char
;	O
cp	*(char)
--	O
;	O
}	O
}	O
FD_SET	O
(	O
p	int
,	O
&	O
obits	struct(array(long))
)	O
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
obits	struct(array(long))
)	O
&&	O
fcc	int
>	O
0	int
)	O
{	O
cc	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
p	int
,	O
fbp	*(char)
,	O
fcc	int
)	O
;	O
if	O
(	O
cc	int
>	O
0	int
)	O
{	O
fcc	int
-=	O
cc	int
;	O
fbp	*(char)
+=	O
cc	int
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ibits	struct(array(long))
)	O
)	O
{	O
char	O
dbuf	array(char)
[	O
1024	int
+	O
1	int
]	O
;	O
pcc	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
p	int
,	O
dbuf	array(char)
,	O
sizeof	O
dbuf	array(char)
)	O
;	O
pbp	*(char)
=	O
dbuf	array(char)
;	O
if	O
(	O
pcc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
pcc	int
=	O
0	int
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
pcc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
dbuf	array(char)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
pbp	*(char)
++	O
;	O
pcc	int
--	O
;	O
IF_NOT_ENCRYPT	O
(	O
FD_SET	O
(	O
f	int
,	O
&	O
obits	struct(array(long))
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pkcontrol	O
(	O
dbuf	array(char)
[	O
0	int
]	O
)	O
)	O
{	O
dbuf	array(char)
[	O
0	int
]	O
|=	O
oobdata	array(char)
[	O
0	int
]	O
;	O
send	(int,*(void),long,int)->(long)
(	O
f	int
,	O
&	O
dbuf	array(char)
[	O
0	int
]	O
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
}	O
pcc	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
FD_ISSET	O
(	O
f	int
,	O
&	O
obits	struct(array(long))
)	O
)	O
&&	O
pcc	int
>	O
0	int
)	O
{	O
ENC_WRITE	O
(	O
cc	int
,	O
f	int
,	O
pbp	*(char)
,	O
pcc	int
,	O
ap	*(struct(struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),array(*(char))))
)	O
;	O
if	O
(	O
cc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
if	O
(	O
!	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ibits	struct(array(long))
)	O
)	O
sleep	(int)->(int)
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
cc	int
>	O
0	int
)	O
{	O
pcc	int
-=	O
cc	int
;	O
pbp	*(char)
+=	O
cc	int
;	O
}	O
}	O
}	O
}	O
int	O
control	(int,*(char),long)->(int)
(	O
int	O
pty	int
,	O
char	O
*	O
cp	*(char)
,	O
size_t	long
n	long
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
w	struct(short,short,short,short)
;	O
if	O
(	O
n	long
<	O
4	int
+	O
sizeof	O
(	O
w	struct(short,short,short,short)
)	O
||	O
cp	*(char)
[	O
2	int
]	O
!=	O
's'	O
||	O
cp	*(char)
[	O
3	int
]	O
!=	O
's'	O
)	O
return	O
(	O
0	int
)	O
;	O
oobdata	array(char)
[	O
0	int
]	O
&=	O
~	O
TIOCPKT_WINDOW	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
&	O
w	struct(short,short,short,short)
,	O
cp	*(char)
+	O
4	int
,	O
sizeof	O
w	struct(short,short,short,short)
)	O
;	O
w	struct(short,short,short,short)
.	O
ws_row	short
=	O
ntohs	(short)->(short)
(	O
w	struct(short,short,short,short)
.	O
ws_row	short
)	O
;	O
w	struct(short,short,short,short)
.	O
ws_col	short
=	O
ntohs	(short)->(short)
(	O
w	struct(short,short,short,short)
.	O
ws_col	short
)	O
;	O
w	struct(short,short,short,short)
.	O
ws_xpixel	short
=	O
ntohs	(short)->(short)
(	O
w	struct(short,short,short,short)
.	O
ws_xpixel	short
)	O
;	O
w	struct(short,short,short,short)
.	O
ws_ypixel	short
=	O
ntohs	(short)->(short)
(	O
w	struct(short,short,short,short)
.	O
ws_ypixel	short
)	O
;	O
ioctl	(int,long)->(int)
(	O
pty	int
,	O
TIOCSWINSZ	int
,	O
&	O
w	struct(short,short,short,short)
)	O
;	O
return	O
(	O
4	int
+	O
sizeof	O
w	struct(short,short,short,short)
)	O
;	O
}	O
void	O
cleanup	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
char	O
*	O
p	int
;	O
p	int
=	O
line	*(char)
+	O
sizeof	O
(	O
PATH_DEV	O
)	O
-	O
1	int
;	O
if	O
(	O
logout	(*(char))->(int)
(	O
p	int
)	O
)	O
logwtmp	(*(char),*(char),*(char))->(void)
(	O
p	int
,	O
""	*(char)
,	O
""	*(char)
)	O
;	O
chmod	(*(char),int)->(int)
(	O
line	*(char)
,	O
0666	int
)	O
;	O
chown	(*(char),int,int)->(int)
(	O
line	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
*	O
p	int
=	O
'p'	O
;	O
chmod	(*(char),int)->(int)
(	O
line	*(char)
,	O
0666	int
)	O
;	O
chown	(*(char),int,int)->(int)
(	O
line	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
shutdown	(int,int)->(int)
(	O
netf	int
,	O
2	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
int	O
in_local_domain	(*(char))->(int)
(	O
char	O
*	O
hostname	*(char)
)	O
{	O
char	O
*	O
p	int
=	O
topdomain	(*(char),int)->(*(char))
(	O
hostname	*(char)
,	O
local_dot_count	int
)	O
;	O
return	O
p	int
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
p	int
,	O
local_domain_name	*(char)
)	O
==	O
0	int
;	O
}	O
char	O
*	O
topdomain	(*(char),int)->(*(char))
(	O
char	O
*	O
name	*(char)
,	O
int	O
max_dots	int
)	O
{	O
char	O
*	O
p	int
;	O
int	O
dot_count	int
=	O
0	int
;	O
for	O
(	O
p	int
=	O
name	*(char)
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
-	O
1	int
;	O
p	int
>=	O
name	*(char)
;	O
p	int
--	O
)	O
{	O
if	O
(	O
*	O
p	int
==	O
'.'	O
&&	O
++	O
dot_count	int
==	O
max_dots	int
)	O
return	O
p	int
+	O
1	int
;	O
}	O
return	O
name	*(char)
;	O
}	O
void	O
fatal	(int,*(char),int)->(void)
(	O
int	O
f	int
,	O
const	O
char	O
*	O
msg	*(*(char))
,	O
int	O
syserr	int
)	O
{	O
int	O
len	char
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
bp	*(char)
=	O
buf	*(char)
;	O
if	O
(	O
!	O
confirmed	int
)	O
*	O
bp	*(char)
++	O
=	O
'\01'	O
;	O
if	O
(	O
syserr	int
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
bp	*(char)
,	O
sizeof	O
buf	*(char)
-	O
(	O
bp	*(char)
-	O
buf	*(char)
)	O
,	O
"rlogind: %s: %s.\r\n"	*(char)
,	O
msg	*(*(char))
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
bp	*(char)
,	O
sizeof	O
buf	*(char)
-	O
(	O
bp	*(char)
-	O
buf	*(char)
)	O
,	O
"rlogind: %s.\r\n"	*(char)
,	O
msg	*(*(char))
)	O
;	O
len	char
=	O
strlen	(*(char))->(long)
(	O
bp	*(char)
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
f	int
,	O
buf	*(char)
,	O
bp	*(char)
+	O
len	char
-	O
buf	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
