inline	O
static	O
double	O
locMAX3	(double,double,double)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
)	O
{	O
double	O
xy	double
=	O
GSL_MAX	O
(	O
x	double
,	O
y	double
)	O
;	O
return	O
GSL_MAX	O
(	O
xy	double
,	O
z	double
)	O
;	O
}	O
inline	O
static	O
double	O
locMAX4	(double,double,double,double)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
double	O
w	double
)	O
{	O
double	O
xy	double
=	O
GSL_MAX	O
(	O
x	double
,	O
y	double
)	O
;	O
double	O
xyz	double
=	O
GSL_MAX	O
(	O
xy	double
,	O
z	double
)	O
;	O
return	O
GSL_MAX	O
(	O
xyz	double
,	O
w	double
)	O
;	O
}	O
int	O
gsl_sf_ellint_RC_e	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
lolim	double
=	O
5.0	int
*	O
GSL_DBL_MIN	int
;	O
const	O
double	O
uplim	double
=	O
0.2	int
*	O
GSL_DBL_MAX	int
;	O
const	O
gsl_prec_t	int
goal	int
=	O
GSL_MODE_PREC	(int)->(int)
(	O
mode	int
)	O
;	O
const	O
double	O
errtol	double
=	O
(	O
goal	int
==	O
GSL_PREC_DOUBLE	int
?	O
0.001	int
:	O
0.03	int
)	O
;	O
const	O
double	O
prec	double
=	O
gsl_prec_eps	array(double)
[	O
goal	int
]	O
;	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
y	double
<	O
0.0	int
||	O
x	double
+	O
y	double
<	O
lolim	double
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
GSL_MAX	O
(	O
x	double
,	O
y	double
)	O
<	O
uplim	double
)	O
{	O
const	O
double	O
c1	double
=	O
1.0	int
/	O
7.0	int
;	O
const	O
double	O
c2	double
=	O
9.0	int
/	O
22.0	int
;	O
double	O
xn	double
=	O
x	double
;	O
double	O
yn	(int,double)->(double)
=	O
y	double
;	O
double	O
mu	double
,	O
sn	double
,	O
lamda	double
,	O
s	double
;	O
int	O
n	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
mu	double
=	O
(	O
xn	double
+	O
yn	(int,double)->(double)
+	O
yn	(int,double)->(double)
)	O
/	O
3.0	int
;	O
sn	double
=	O
(	O
yn	(int,double)->(double)
+	O
mu	double
)	O
/	O
mu	double
-	O
2.0	int
;	O
if	O
(	O
fabs	(double)->(double)
(	O
sn	double
)	O
<	O
errtol	double
)	O
break	O
;	O
lamda	double
=	O
2.0	int
*	O
sqrt	(double)->(double)
(	O
xn	double
)	O
*	O
sqrt	(double)->(double)
(	O
yn	(int,double)->(double)
)	O
+	O
yn	(int,double)->(double)
;	O
xn	double
=	O
(	O
xn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
yn	(int,double)->(double)
=	O
(	O
yn	(int,double)->(double)
+	O
lamda	double
)	O
*	O
0.25	int
;	O
n	int
++	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
{	O
MAXITER_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
s	double
=	O
sn	double
*	O
sn	double
*	O
(	O
0.3	int
+	O
sn	double
*	O
(	O
c1	double
+	O
sn	double
*	O
(	O
0.375	int
+	O
sn	double
*	O
c2	double
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
+	O
s	double
)	O
/	O
sqrt	(double)->(double)
(	O
mu	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
prec	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
gsl_prec_t	int
goal	int
=	O
GSL_MODE_PREC	(int)->(int)
(	O
mode	int
)	O
;	O
const	O
double	O
errtol	double
=	O
(	O
goal	int
==	O
GSL_PREC_DOUBLE	int
?	O
0.001	int
:	O
0.03	int
)	O
;	O
const	O
double	O
prec	double
=	O
gsl_prec_eps	array(double)
[	O
goal	int
]	O
;	O
const	O
double	O
lolim	double
=	O
2.0	int
/	O
pow	(double,double)->(double)
(	O
GSL_DBL_MAX	int
,	O
2.0	int
/	O
3.0	int
)	O
;	O
const	O
double	O
uplim	double
=	O
pow	(double,double)->(double)
(	O
0.1	int
*	O
errtol	double
/	O
GSL_DBL_MIN	int
,	O
2.0	int
/	O
3.0	int
)	O
;	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
if	O
(	O
GSL_MIN	O
(	O
x	double
,	O
y	double
)	O
<	O
0.0	int
||	O
GSL_MIN	O
(	O
x	double
+	O
y	double
,	O
z	double
)	O
<	O
lolim	double
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
locMAX3	(double,double,double)->(double)
(	O
x	double
,	O
y	double
,	O
z	double
)	O
<	O
uplim	double
)	O
{	O
const	O
double	O
c1	double
=	O
3.0	int
/	O
14.0	int
;	O
const	O
double	O
c2	double
=	O
1.0	int
/	O
6.0	int
;	O
const	O
double	O
c3	double
=	O
9.0	int
/	O
22.0	int
;	O
const	O
double	O
c4	double
=	O
3.0	int
/	O
26.0	int
;	O
double	O
xn	double
=	O
x	double
;	O
double	O
yn	(int,double)->(double)
=	O
y	double
;	O
double	O
zn	double
=	O
z	double
;	O
double	O
sigma	double
=	O
0.0	int
;	O
double	O
power4	double
=	O
1.0	int
;	O
double	O
ea	double
,	O
eb	double
,	O
ec	double
,	O
ed	double
,	O
ef	double
,	O
s1	double
,	O
s2	double
;	O
double	O
mu	double
,	O
xndev	double
,	O
yndev	double
,	O
zndev	double
;	O
int	O
n	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
double	O
xnroot	double
,	O
ynroot	double
,	O
znroot	double
,	O
lamda	double
;	O
double	O
epslon	double
;	O
mu	double
=	O
(	O
xn	double
+	O
yn	(int,double)->(double)
+	O
3.0	int
*	O
zn	double
)	O
*	O
0.2	int
;	O
xndev	double
=	O
(	O
mu	double
-	O
xn	double
)	O
/	O
mu	double
;	O
yndev	double
=	O
(	O
mu	double
-	O
yn	(int,double)->(double)
)	O
/	O
mu	double
;	O
zndev	double
=	O
(	O
mu	double
-	O
zn	double
)	O
/	O
mu	double
;	O
epslon	double
=	O
locMAX3	(double,double,double)->(double)
(	O
fabs	(double)->(double)
(	O
xndev	double
)	O
,	O
fabs	(double)->(double)
(	O
yndev	double
)	O
,	O
fabs	(double)->(double)
(	O
zndev	double
)	O
)	O
;	O
if	O
(	O
epslon	double
<	O
errtol	double
)	O
break	O
;	O
xnroot	double
=	O
sqrt	(double)->(double)
(	O
xn	double
)	O
;	O
ynroot	double
=	O
sqrt	(double)->(double)
(	O
yn	(int,double)->(double)
)	O
;	O
znroot	double
=	O
sqrt	(double)->(double)
(	O
zn	double
)	O
;	O
lamda	double
=	O
xnroot	double
*	O
(	O
ynroot	double
+	O
znroot	double
)	O
+	O
ynroot	double
*	O
znroot	double
;	O
sigma	double
+=	O
power4	double
/	O
(	O
znroot	double
*	O
(	O
zn	double
+	O
lamda	double
)	O
)	O
;	O
power4	double
*=	O
0.25	int
;	O
xn	double
=	O
(	O
xn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
yn	(int,double)->(double)
=	O
(	O
yn	(int,double)->(double)
+	O
lamda	double
)	O
*	O
0.25	int
;	O
zn	double
=	O
(	O
zn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
n	int
++	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
{	O
MAXITER_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
ea	double
=	O
xndev	double
*	O
yndev	double
;	O
eb	double
=	O
zndev	double
*	O
zndev	double
;	O
ec	double
=	O
ea	double
-	O
eb	double
;	O
ed	double
=	O
ea	double
-	O
6.0	int
*	O
eb	double
;	O
ef	double
=	O
ed	double
+	O
ec	double
+	O
ec	double
;	O
s1	double
=	O
ed	double
*	O
(	O
-	O
c1	double
+	O
0.25	int
*	O
c3	double
*	O
ed	double
-	O
1.5	int
*	O
c4	double
*	O
zndev	double
*	O
ef	double
)	O
;	O
s2	double
=	O
zndev	double
*	O
(	O
c2	double
*	O
ef	double
+	O
zndev	double
*	O
(	O
-	O
c3	double
*	O
ec	double
+	O
zndev	double
*	O
c4	double
*	O
ea	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
3.0	int
*	O
sigma	double
+	O
power4	double
*	O
(	O
1.0	int
+	O
s1	double
+	O
s2	double
)	O
/	O
(	O
mu	double
*	O
sqrt	(double)->(double)
(	O
mu	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
prec	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
lolim	double
=	O
5.0	int
*	O
GSL_DBL_MIN	int
;	O
const	O
double	O
uplim	double
=	O
0.2	int
*	O
GSL_DBL_MAX	int
;	O
const	O
gsl_prec_t	int
goal	int
=	O
GSL_MODE_PREC	(int)->(int)
(	O
mode	int
)	O
;	O
const	O
double	O
errtol	double
=	O
(	O
goal	int
==	O
GSL_PREC_DOUBLE	int
?	O
0.001	int
:	O
0.03	int
)	O
;	O
const	O
double	O
prec	double
=	O
gsl_prec_eps	array(double)
[	O
goal	int
]	O
;	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
y	double
<	O
0.0	int
||	O
z	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
+	O
y	double
<	O
lolim	double
||	O
x	double
+	O
z	double
<	O
lolim	double
||	O
y	double
+	O
z	double
<	O
lolim	double
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
locMAX3	(double,double,double)->(double)
(	O
x	double
,	O
y	double
,	O
z	double
)	O
<	O
uplim	double
)	O
{	O
const	O
double	O
c1	double
=	O
1.0	int
/	O
24.0	int
;	O
const	O
double	O
c2	double
=	O
3.0	int
/	O
44.0	int
;	O
const	O
double	O
c3	double
=	O
1.0	int
/	O
14.0	int
;	O
double	O
xn	double
=	O
x	double
;	O
double	O
yn	(int,double)->(double)
=	O
y	double
;	O
double	O
zn	double
=	O
z	double
;	O
double	O
mu	double
,	O
xndev	double
,	O
yndev	double
,	O
zndev	double
,	O
e2	double
,	O
e3	double
,	O
s	double
;	O
int	O
n	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
double	O
epslon	double
,	O
lamda	double
;	O
double	O
xnroot	double
,	O
ynroot	double
,	O
znroot	double
;	O
mu	double
=	O
(	O
xn	double
+	O
yn	(int,double)->(double)
+	O
zn	double
)	O
/	O
3.0	int
;	O
xndev	double
=	O
2.0	int
-	O
(	O
mu	double
+	O
xn	double
)	O
/	O
mu	double
;	O
yndev	double
=	O
2.0	int
-	O
(	O
mu	double
+	O
yn	(int,double)->(double)
)	O
/	O
mu	double
;	O
zndev	double
=	O
2.0	int
-	O
(	O
mu	double
+	O
zn	double
)	O
/	O
mu	double
;	O
epslon	double
=	O
locMAX3	(double,double,double)->(double)
(	O
fabs	(double)->(double)
(	O
xndev	double
)	O
,	O
fabs	(double)->(double)
(	O
yndev	double
)	O
,	O
fabs	(double)->(double)
(	O
zndev	double
)	O
)	O
;	O
if	O
(	O
epslon	double
<	O
errtol	double
)	O
break	O
;	O
xnroot	double
=	O
sqrt	(double)->(double)
(	O
xn	double
)	O
;	O
ynroot	double
=	O
sqrt	(double)->(double)
(	O
yn	(int,double)->(double)
)	O
;	O
znroot	double
=	O
sqrt	(double)->(double)
(	O
zn	double
)	O
;	O
lamda	double
=	O
xnroot	double
*	O
(	O
ynroot	double
+	O
znroot	double
)	O
+	O
ynroot	double
*	O
znroot	double
;	O
xn	double
=	O
(	O
xn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
yn	(int,double)->(double)
=	O
(	O
yn	(int,double)->(double)
+	O
lamda	double
)	O
*	O
0.25	int
;	O
zn	double
=	O
(	O
zn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
n	int
++	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
{	O
MAXITER_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
e2	double
=	O
xndev	double
*	O
yndev	double
-	O
zndev	double
*	O
zndev	double
;	O
e3	double
=	O
xndev	double
*	O
yndev	double
*	O
zndev	double
;	O
s	double
=	O
1.0	int
+	O
(	O
c1	double
*	O
e2	double
-	O
0.1	int
-	O
c2	double
*	O
e3	double
)	O
*	O
e2	double
+	O
c3	double
*	O
e3	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
s	double
/	O
sqrt	(double)->(double)
(	O
mu	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
prec	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_ellint_RJ_e	(double,double,double,double,int,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
double	O
p	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
gsl_prec_t	int
goal	int
=	O
GSL_MODE_PREC	(int)->(int)
(	O
mode	int
)	O
;	O
const	O
double	O
errtol	double
=	O
(	O
goal	int
==	O
GSL_PREC_DOUBLE	int
?	O
0.001	int
:	O
0.03	int
)	O
;	O
const	O
double	O
prec	double
=	O
gsl_prec_eps	array(double)
[	O
goal	int
]	O
;	O
const	O
double	O
lolim	double
=	O
pow	(double,double)->(double)
(	O
5.0	int
*	O
GSL_DBL_MIN	int
,	O
1.0	int
/	O
3.0	int
)	O
;	O
const	O
double	O
uplim	double
=	O
0.3	int
*	O
pow	(double,double)->(double)
(	O
0.2	int
*	O
GSL_DBL_MAX	int
,	O
1.0	int
/	O
3.0	int
)	O
;	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
y	double
<	O
0.0	int
||	O
z	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
+	O
y	double
<	O
lolim	double
||	O
x	double
+	O
z	double
<	O
lolim	double
||	O
y	double
+	O
z	double
<	O
lolim	double
||	O
p	double
<	O
lolim	double
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
locMAX4	(double,double,double,double)->(double)
(	O
x	double
,	O
y	double
,	O
z	double
,	O
p	double
)	O
<	O
uplim	double
)	O
{	O
const	O
double	O
c1	double
=	O
3.0	int
/	O
14.0	int
;	O
const	O
double	O
c2	double
=	O
1.0	int
/	O
3.0	int
;	O
const	O
double	O
c3	double
=	O
3.0	int
/	O
22.0	int
;	O
const	O
double	O
c4	double
=	O
3.0	int
/	O
26.0	int
;	O
double	O
xn	double
=	O
x	double
;	O
double	O
yn	(int,double)->(double)
=	O
y	double
;	O
double	O
zn	double
=	O
z	double
;	O
double	O
pn	double
=	O
p	double
;	O
double	O
sigma	double
=	O
0.0	int
;	O
double	O
power4	double
=	O
1.0	int
;	O
double	O
mu	double
,	O
xndev	double
,	O
yndev	double
,	O
zndev	double
,	O
pndev	double
;	O
double	O
ea	double
,	O
eb	double
,	O
ec	double
,	O
e2	double
,	O
e3	double
,	O
s1	double
,	O
s2	double
,	O
s3	double
;	O
int	O
n	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
double	O
xnroot	double
,	O
ynroot	double
,	O
znroot	double
;	O
double	O
lamda	double
,	O
alfa	double
,	O
beta	double
;	O
double	O
epslon	double
;	O
gsl_sf_result	struct(double,double)
rcresult	struct(double,double)
;	O
int	O
rcstatus	int
;	O
mu	double
=	O
(	O
xn	double
+	O
yn	(int,double)->(double)
+	O
zn	double
+	O
pn	double
+	O
pn	double
)	O
*	O
0.2	int
;	O
xndev	double
=	O
(	O
mu	double
-	O
xn	double
)	O
/	O
mu	double
;	O
yndev	double
=	O
(	O
mu	double
-	O
yn	(int,double)->(double)
)	O
/	O
mu	double
;	O
zndev	double
=	O
(	O
mu	double
-	O
zn	double
)	O
/	O
mu	double
;	O
pndev	double
=	O
(	O
mu	double
-	O
pn	double
)	O
/	O
mu	double
;	O
epslon	double
=	O
locMAX4	(double,double,double,double)->(double)
(	O
fabs	(double)->(double)
(	O
xndev	double
)	O
,	O
fabs	(double)->(double)
(	O
yndev	double
)	O
,	O
fabs	(double)->(double)
(	O
zndev	double
)	O
,	O
fabs	(double)->(double)
(	O
pndev	double
)	O
)	O
;	O
if	O
(	O
epslon	double
<	O
errtol	double
)	O
break	O
;	O
xnroot	double
=	O
sqrt	(double)->(double)
(	O
xn	double
)	O
;	O
ynroot	double
=	O
sqrt	(double)->(double)
(	O
yn	(int,double)->(double)
)	O
;	O
znroot	double
=	O
sqrt	(double)->(double)
(	O
zn	double
)	O
;	O
lamda	double
=	O
xnroot	double
*	O
(	O
ynroot	double
+	O
znroot	double
)	O
+	O
ynroot	double
*	O
znroot	double
;	O
alfa	double
=	O
pn	double
*	O
(	O
xnroot	double
+	O
ynroot	double
+	O
znroot	double
)	O
+	O
xnroot	double
*	O
ynroot	double
*	O
znroot	double
;	O
alfa	double
=	O
alfa	double
*	O
alfa	double
;	O
beta	double
=	O
pn	double
*	O
(	O
pn	double
+	O
lamda	double
)	O
*	O
(	O
pn	double
+	O
lamda	double
)	O
;	O
rcstatus	int
=	O
gsl_sf_ellint_RC_e	(double,double,int,*(struct(double,double)))->(int)
(	O
alfa	double
,	O
beta	double
,	O
mode	int
,	O
&	O
rcresult	struct(double,double)
)	O
;	O
if	O
(	O
rcstatus	int
!=	O
GSL_SUCCESS	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
rcstatus	int
;	O
}	O
sigma	double
+=	O
power4	double
*	O
rcresult	struct(double,double)
.	O
val	double
;	O
power4	double
*=	O
0.25	int
;	O
xn	double
=	O
(	O
xn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
yn	(int,double)->(double)
=	O
(	O
yn	(int,double)->(double)
+	O
lamda	double
)	O
*	O
0.25	int
;	O
zn	double
=	O
(	O
zn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
pn	double
=	O
(	O
pn	double
+	O
lamda	double
)	O
*	O
0.25	int
;	O
n	int
++	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
{	O
MAXITER_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
ea	double
=	O
xndev	double
*	O
(	O
yndev	double
+	O
zndev	double
)	O
+	O
yndev	double
*	O
zndev	double
;	O
eb	double
=	O
xndev	double
*	O
yndev	double
*	O
zndev	double
;	O
ec	double
=	O
pndev	double
*	O
pndev	double
;	O
e2	double
=	O
ea	double
-	O
3.0	int
*	O
ec	double
;	O
e3	double
=	O
eb	double
+	O
2.0	int
*	O
pndev	double
*	O
(	O
ea	double
-	O
ec	double
)	O
;	O
s1	double
=	O
1.0	int
+	O
e2	double
*	O
(	O
-	O
c1	double
+	O
0.75	int
*	O
c3	double
*	O
e2	double
-	O
1.5	int
*	O
c4	double
*	O
e3	double
)	O
;	O
s2	double
=	O
eb	double
*	O
(	O
0.5	int
*	O
c2	double
+	O
pndev	double
*	O
(	O
-	O
c3	double
-	O
c3	double
+	O
pndev	double
*	O
c4	double
)	O
)	O
;	O
s3	double
=	O
pndev	double
*	O
ea	double
*	O
(	O
c2	double
-	O
pndev	double
*	O
c3	double
)	O
-	O
c2	double
*	O
pndev	double
*	O
ec	double
;	O
result	*(struct(double,double))
->	O
val	double
=	O
3.0	int
*	O
sigma	double
+	O
power4	double
*	O
(	O
s1	double
+	O
s2	double
+	O
s3	double
)	O
/	O
(	O
mu	double
*	O
sqrt	(double)->(double)
(	O
mu	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
prec	double
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_ellint_F_e	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
nc	double
=	O
floor	(double)->(double)
(	O
phi	double
/	O
M_PI	int
+	O
0.5	int
)	O
;	O
double	O
phi_red	double
=	O
phi	double
-	O
nc	double
*	O
M_PI	int
;	O
phi	double
=	O
phi_red	double
;	O
{	O
double	O
sin_phi	double
=	O
sin	(double)->(double)
(	O
phi	double
)	O
;	O
double	O
sin2_phi	double
=	O
sin_phi	double
*	O
sin_phi	double
;	O
double	O
x	double
=	O
1.0	int
-	O
sin2_phi	double
;	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
*	O
sin2_phi	double
;	O
gsl_sf_result	struct(double,double)
rf	struct(double,double)
;	O
int	O
status	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rf	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
err	double
)	O
;	O
if	O
(	O
nc	double
==	O
0	int
)	O
{	O
return	O
status	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rk	struct(double,double)
;	O
const	O
int	O
rkstatus	int
=	O
gsl_sf_ellint_Kcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
rk	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
+=	O
2	int
*	O
nc	double
*	O
rk	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2	int
*	O
fabs	(double)->(double)
(	O
nc	double
)	O
*	O
rk	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
status	int
,	O
rkstatus	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_ellint_E_e	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
nc	double
=	O
floor	(double)->(double)
(	O
phi	double
/	O
M_PI	int
+	O
0.5	int
)	O
;	O
double	O
phi_red	double
=	O
phi	double
-	O
nc	double
*	O
M_PI	int
;	O
phi	double
=	O
phi_red	double
;	O
{	O
const	O
double	O
sin_phi	double
=	O
sin	(double)->(double)
(	O
phi	double
)	O
;	O
const	O
double	O
sin2_phi	double
=	O
sin_phi	double
*	O
sin_phi	double
;	O
const	O
double	O
x	double
=	O
1.0	int
-	O
sin2_phi	double
;	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
*	O
sin2_phi	double
;	O
if	O
(	O
x	double
<	O
GSL_DBL_EPSILON	int
)	O
{	O
gsl_sf_result	struct(double,double)
re	*(struct(double,double,int))
;	O
const	O
int	O
status	int
=	O
gsl_sf_ellint_Ecomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
re	*(struct(double,double,int))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
2	int
*	O
nc	double
*	O
re	*(struct(double,double,int))
.	O
val	double
+	O
GSL_SIGN	O
(	O
sin_phi	double
)	O
*	O
re	*(struct(double,double,int))
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2	int
*	O
fabs	(double)->(double)
(	O
nc	double
)	O
*	O
re	*(struct(double,double,int))
.	O
err	double
+	O
re	*(struct(double,double,int))
.	O
err	double
;	O
return	O
status	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rf	struct(double,double)
,	O
rd	struct(double,double)
;	O
const	O
double	O
sin3_phi	double
=	O
sin2_phi	double
*	O
sin_phi	double
;	O
const	O
int	O
rfstatus	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rf	struct(double,double)
)	O
;	O
const	O
int	O
rdstatus	int
=	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rd	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
val	double
-	O
k	double
*	O
k	double
/	O
3.0	int
*	O
sin3_phi	double
*	O
rd	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
k	double
*	O
k	double
/	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sin3_phi	double
*	O
rd	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
k	double
*	O
k	double
/	O
3.0	int
*	O
fabs	(double)->(double)
(	O
sin3_phi	double
*	O
rd	struct(double,double)
.	O
err	double
)	O
;	O
if	O
(	O
nc	double
==	O
0	int
)	O
{	O
return	O
GSL_ERROR_SELECT_2	O
(	O
rfstatus	int
,	O
rdstatus	int
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
re	*(struct(double,double,int))
;	O
const	O
int	O
restatus	int
=	O
gsl_sf_ellint_Ecomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
re	*(struct(double,double,int))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
+=	O
2	int
*	O
nc	double
*	O
re	*(struct(double,double,int))
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2	int
*	O
fabs	(double)->(double)
(	O
nc	double
)	O
*	O
re	*(struct(double,double,int))
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
rfstatus	int
,	O
rdstatus	int
,	O
restatus	int
)	O
;	O
}	O
}	O
}	O
}	O
int	O
gsl_sf_ellint_P_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
double	O
n	int
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
nc	double
=	O
floor	(double)->(double)
(	O
phi	double
/	O
M_PI	int
+	O
0.5	int
)	O
;	O
double	O
phi_red	double
=	O
phi	double
-	O
nc	double
*	O
M_PI	int
;	O
phi	double
=	O
phi_red	double
;	O
{	O
const	O
double	O
sin_phi	double
=	O
sin	(double)->(double)
(	O
phi	double
)	O
;	O
const	O
double	O
sin2_phi	double
=	O
sin_phi	double
*	O
sin_phi	double
;	O
const	O
double	O
sin3_phi	double
=	O
sin2_phi	double
*	O
sin_phi	double
;	O
const	O
double	O
x	double
=	O
1.0	int
-	O
sin2_phi	double
;	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
*	O
sin2_phi	double
;	O
gsl_sf_result	struct(double,double)
rf	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
rj	struct(double,double)
;	O
const	O
int	O
rfstatus	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rf	struct(double,double)
)	O
;	O
const	O
int	O
rjstatus	int
=	O
gsl_sf_ellint_RJ_e	(double,double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
1.0	int
+	O
n	int
*	O
sin2_phi	double
,	O
mode	int
,	O
&	O
rj	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
val	double
-	O
n	int
/	O
3.0	int
*	O
sin3_phi	double
*	O
rj	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
fabs	(double)->(double)
(	O
sin_phi	double
*	O
rf	struct(double,double)
.	O
err	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
n	int
/	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
sin3_phi	double
*	O
rj	struct(double,double)
.	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
n	int
/	O
3.0	int
*	O
fabs	(double)->(double)
(	O
sin3_phi	double
*	O
rj	struct(double,double)
.	O
err	double
)	O
;	O
if	O
(	O
nc	double
==	O
0	int
)	O
{	O
return	O
GSL_ERROR_SELECT_2	O
(	O
rfstatus	int
,	O
rjstatus	int
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rp	struct(double,double)
;	O
const	O
int	O
rpstatus	int
=	O
gsl_sf_ellint_Pcomp_e	(double,double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
n	int
,	O
mode	int
,	O
&	O
rp	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
+=	O
2	int
*	O
nc	double
*	O
rp	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2	int
*	O
fabs	(double)->(double)
(	O
nc	double
)	O
*	O
rp	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
rfstatus	int
,	O
rjstatus	int
,	O
rpstatus	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_ellint_D_e	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
nc	double
=	O
floor	(double)->(double)
(	O
phi	double
/	O
M_PI	int
+	O
0.5	int
)	O
;	O
double	O
phi_red	double
=	O
phi	double
-	O
nc	double
*	O
M_PI	int
;	O
phi	double
=	O
phi_red	double
;	O
{	O
const	O
double	O
sin_phi	double
=	O
sin	(double)->(double)
(	O
phi	double
)	O
;	O
const	O
double	O
sin2_phi	double
=	O
sin_phi	double
*	O
sin_phi	double
;	O
const	O
double	O
sin3_phi	double
=	O
sin2_phi	double
*	O
sin_phi	double
;	O
const	O
double	O
x	double
=	O
1.0	int
-	O
sin2_phi	double
;	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
*	O
sin2_phi	double
;	O
gsl_sf_result	struct(double,double)
rd	struct(double,double)
;	O
const	O
int	O
status	int
=	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rd	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
sin3_phi	double
/	O
3.0	int
*	O
rd	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
sin3_phi	double
/	O
3.0	int
*	O
rd	struct(double,double)
.	O
err	double
)	O
;	O
if	O
(	O
nc	double
==	O
0	int
)	O
{	O
return	O
status	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rd	struct(double,double)
;	O
const	O
int	O
rdstatus	int
=	O
gsl_sf_ellint_Dcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
rd	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
+=	O
2	int
*	O
nc	double
*	O
rd	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2	int
*	O
fabs	(double)->(double)
(	O
nc	double
)	O
*	O
rd	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
status	int
,	O
rdstatus	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_ellint_Dcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
gsl_sf_result	struct(double,double)
rd	struct(double,double)
;	O
const	O
int	O
status	int
=	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rd	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
/	O
3.0	int
)	O
*	O
rd	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
1.0	int
/	O
3.0	int
*	O
rd	struct(double,double)
.	O
err	double
)	O
;	O
return	O
status	int
;	O
}	O
}	O
int	O
gsl_sf_ellint_Kcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
-	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
const	O
double	O
a	double
[	O
]	O
=	O
{	O
1.38629436112	int
,	O
0.09666344259	int
,	O
0.03590092383	int
}	O
;	O
const	O
double	O
b	double
[	O
]	O
=	O
{	O
0.5	int
,	O
0.12498593597	int
,	O
0.06880248576	int
}	O
;	O
const	O
double	O
ta	double
=	O
a	double
[	O
0	int
]	O
+	O
y	double
*	O
(	O
a	double
[	O
1	int
]	O
+	O
y	double
*	O
a	double
[	O
2	int
]	O
)	O
;	O
const	O
double	O
tb	double
=	O
-	O
log	(double)->(double)
(	O
y	double
)	O
*	O
(	O
b	double
[	O
0	int
]	O
+	O
y	double
*	O
(	O
b	double
[	O
1	int
]	O
+	O
y	double
*	O
b	double
[	O
2	int
]	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ta	double
+	O
tb	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
+	O
fabs	(double)->(double)
(	O
k	double
/	O
y	double
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
int	O
status	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
0.5	int
*	O
GSL_DBL_EPSILON	int
/	O
y	double
;	O
return	O
status	int
;	O
}	O
}	O
int	O
gsl_sf_ellint_Ecomp_e	(double,int,*(struct(double,double)))->(int)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
-	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
const	O
double	O
a	double
[	O
]	O
=	O
{	O
0.44325141463	int
,	O
0.06260601220	int
,	O
0.04757383546	int
}	O
;	O
const	O
double	O
b	double
[	O
]	O
=	O
{	O
0.24998368310	int
,	O
0.09200180037	int
,	O
0.04069697526	int
}	O
;	O
const	O
double	O
ta	double
=	O
1.0	int
+	O
y	double
*	O
(	O
a	double
[	O
0	int
]	O
+	O
y	double
*	O
(	O
a	double
[	O
1	int
]	O
+	O
a	double
[	O
2	int
]	O
*	O
y	double
)	O
)	O
;	O
const	O
double	O
tb	double
=	O
-	O
y	double
*	O
log	(double)->(double)
(	O
y	double
)	O
*	O
(	O
b	double
[	O
0	int
]	O
+	O
y	double
*	O
(	O
b	double
[	O
1	int
]	O
+	O
b	double
[	O
2	int
]	O
*	O
y	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
ta	double
+	O
tb	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
result	*(struct(double,double))
->	O
val	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rf	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
rd	struct(double,double)
;	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
const	O
int	O
rfstatus	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rf	struct(double,double)
)	O
;	O
const	O
int	O
rdstatus	int
=	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rd	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
rf	struct(double,double)
.	O
val	double
-	O
k	double
*	O
k	double
/	O
3.0	int
*	O
rd	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
rf	struct(double,double)
.	O
err	double
+	O
k	double
*	O
k	double
/	O
3.0	int
*	O
rd	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
rfstatus	int
,	O
rdstatus	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_ellint_Pcomp_e	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
k	double
,	O
double	O
n	int
,	O
gsl_mode_t	int
mode	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
k	double
*	O
k	double
>=	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
rf	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
rj	struct(double,double)
;	O
const	O
double	O
y	double
=	O
1.0	int
-	O
k	double
*	O
k	double
;	O
const	O
int	O
rfstatus	int
=	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
mode	int
,	O
&	O
rf	struct(double,double)
)	O
;	O
const	O
int	O
rjstatus	int
=	O
gsl_sf_ellint_RJ_e	(double,double,double,double,int,*(struct(double,double)))->(int)
(	O
0.0	int
,	O
y	double
,	O
1.0	int
,	O
1.0	int
+	O
n	int
,	O
mode	int
,	O
&	O
rj	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
rf	struct(double,double)
.	O
val	double
-	O
(	O
n	int
/	O
3.0	int
)	O
*	O
rj	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
rf	struct(double,double)
.	O
err	double
+	O
fabs	(double)->(double)
(	O
n	int
/	O
3.0	int
)	O
*	O
rj	struct(double,double)
.	O
err	double
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
rfstatus	int
,	O
rjstatus	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_ellint_Kcomp	(double,int)->(double)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_Kcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_Ecomp	(double,int)->(double)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_Ecomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_Pcomp	(double,double,int)->(double)
(	O
double	O
k	double
,	O
double	O
n	int
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_Pcomp_e	(double,double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
n	int
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_Dcomp	(double,int)->(double)
(	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_Dcomp_e	(double,int,*(struct(double,double)))->(int)
(	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_F	(double,double,int)->(double)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_F_e	(double,double,int,*(struct(double,double)))->(int)
(	O
phi	double
,	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_E	(double,double,int)->(double)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_E_e	(double,double,int,*(struct(double,double)))->(int)
(	O
phi	double
,	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_P	(double,double,double,int)->(double)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
double	O
n	int
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_P_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
phi	double
,	O
k	double
,	O
n	int
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_D	(double,double,int)->(double)
(	O
double	O
phi	double
,	O
double	O
k	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_D_e	(double,double,int,*(struct(double,double)))->(int)
(	O
phi	double
,	O
k	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_RC	(double,double,int)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_RC_e	(double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_RD	(double,double,double,int)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_RD_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
z	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_RF	(double,double,double,int)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_RF_e	(double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
z	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_ellint_RJ	(double,double,double,double,int)->(double)
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
z	double
,	O
double	O
p	double
,	O
gsl_mode_t	int
mode	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_ellint_RJ_e	(double,double,double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
y	double
,	O
z	double
,	O
p	double
,	O
mode	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
