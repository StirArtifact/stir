static	O
char	O
*	O
version	*(char)
=	O
"MARST -- Algol-to-C Translator, Version 2.7"	*(char)
;	O
static	O
char	O
*	O
infilename	*(char)
=	O
""	*(char)
;	O
static	O
FILE	struct
*	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
char	O
*	O
outfilename	*(char)
=	O
""	*(char)
;	O
static	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
int	O
debug	int
=	O
0	int
;	O
static	O
int	O
errmax	int
=	O
0	int
;	O
static	O
int	O
warn	int
=	O
1	int
;	O
static	O
int	O
width	int
=	O
72	int
;	O
static	O
int	O
time_stamp	int
=	O
1	int
;	O
static	O
int	O
first_pass	int
;	O
static	O
int	O
second_pass	int
;	O
static	O
int	O
e_count	int
=	O
0	int
;	O
static	O
int	O
w_count	int
=	O
0	int
;	O
static	O
int	O
l_count	int
;	O
static	O
int	O
l_maxlen	int
=	O
100	int
;	O
static	O
char	O
*	O
line	*(char)
;	O
static	O
int	O
pos	int
;	O
static	O
int	O
symbol	int
;	O
static	O
int	O
s_char	int
;	O
static	O
void	O
my_assert	(*(char),*(char),int)->(void)
(	O
char	O
*	O
expr	*(char)
,	O
char	O
*	O
file	*(char)
,	O
int	O
line	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Internal translator error: %s, file %s, line %d\n"	*(char)
,	O
expr	*(char)
,	O
file	*(char)
,	O
line	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Please, report to <bug-marst@gnu.org>\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
my_malloc	(int)->(*(void))
(	O
int	O
size	int
)	O
{	O
void	O
*	O
ptr	*(void)
;	O
assert	O
(	O
size	int
>	O
0	int
)	O
;	O
ptr	*(void)
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
ptr	*(void)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Main storage requested not available\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
ptr	*(void)
;	O
}	O
static	O
void	O
*	O
my_realloc	(*(void),int)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
int	O
size	int
)	O
{	O
assert	O
(	O
ptr	*(void)
!=	O
NULL	O
&&	O
size	int
>	O
0	int
)	O
;	O
ptr	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	int
)	O
;	O
if	O
(	O
ptr	*(void)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Main storage requested not available\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
ptr	*(void)
;	O
}	O
static	O
void	O
my_free	(*(void))->(void)
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
assert	O
(	O
ptr	*(void)
!=	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
return	O
;	O
}	O
static	O
void	O
error	(*(char))->(void)
(	O
char	O
*	O
msg	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:%d: "	*(char)
,	O
infilename	*(char)
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
msg	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
if	O
(	O
debug	int
&&	O
first_pass	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>%s:%d: "	*(char)
,	O
infilename	*(char)
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
msg	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
e_count	int
++	O
;	O
if	O
(	O
e_count	int
==	O
errmax	int
)	O
{	O
error	(*(char))->(void)
(	O
"too many errors detected; translation terminated"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
warning	(*(char))->(void)
(	O
char	O
*	O
msg	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
first_pass	int
&&	O
warn	int
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:%d: warning: "	*(char)
,	O
infilename	*(char)
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
msg	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>%s:%d: warning: "	*(char)
,	O
infilename	*(char)
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
msg	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
w_count	int
++	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
read_line	()->(int)
(	O
void	O
)	O
{	O
int	O
c	int
,	O
len	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Read error on `%s' - %s\n"	*(char)
,	O
infilename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
l_count	int
++	O
;	O
warning	(*(char))->(void)
(	O
"missing final newline"	*(char)
)	O
;	O
l_count	int
--	O
;	O
break	O
;	O
}	O
line	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
iscntrl	(int)->(int)
(	O
c	int
)	O
&&	O
!	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
{	O
l_count	int
++	O
;	O
error	(*(char))->(void)
(	O
"invalid control character 0x%02X"	*(char)
,	O
c	int
)	O
;	O
l_count	int
--	O
;	O
c	int
=	O
' '	O
;	O
}	O
if	O
(	O
len	int
==	O
l_maxlen	int
)	O
{	O
l_maxlen	int
+=	O
l_maxlen	int
;	O
line	*(char)
=	O
my_realloc	(*(void),int)->(*(void))
(	O
line	*(char)
,	O
l_maxlen	int
+	O
1	int
)	O
;	O
}	O
line	*(char)
[	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
}	O
line	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
l_count	int
++	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
skip_pad	()->(void)
(	O
void	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
read_line	()->(int)
(	O
)	O
)	O
line	*(char)
[	O
0	int
]	O
=	O
0x1A	int
;	O
pos	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
isspace	(int)->(int)
(	O
line	*(char)
[	O
pos	int
]	O
)	O
)	O
{	O
pos	int
++	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
scan_symbol	()->(void)
(	O
void	O
)	O
{	O
scan	O
:	O
skip_pad	()->(void)
(	O
)	O
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
line	*(char)
[	O
pos	int
]	O
)	O
)	O
{	O
if	O
(	O
pos	int
>	O
0	int
&&	O
isalnum	(int)->(int)
(	O
line	*(char)
[	O
pos	int
-	O
1	int
]	O
)	O
)	O
goto	O
alfa	O
;	O
switch	O
(	O
line	*(char)
[	O
pos	int
]	O
)	O
{	O
case	O
'a'	O
:	O
check_word	O
(	O
5	int
,	O
"array"	*(char)
,	O
S_ARRAY	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'b'	O
:	O
check_word	O
(	O
5	int
,	O
"begin"	*(char)
,	O
S_BEGIN	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"boolean"	*(char)
,	O
S_BOOLEAN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'B'	O
:	O
check_word	O
(	O
7	int
,	O
"Boolean"	*(char)
,	O
S_BOOLEAN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'c'	O
:	O
check_word	O
(	O
4	int
,	O
"code"	*(char)
,	O
S_CODE	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"comment"	*(char)
,	O
S_COMMENT	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'd'	O
:	O
check_word	O
(	O
2	int
,	O
"do"	*(char)
,	O
S_DO	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'e'	O
:	O
check_word	O
(	O
4	int
,	O
"else"	*(char)
,	O
S_ELSE	int
)	O
;	O
check_word	O
(	O
3	int
,	O
"end"	*(char)
,	O
S_END	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'f'	O
:	O
check_word	O
(	O
5	int
,	O
"false"	*(char)
,	O
S_FALSE	int
)	O
;	O
check_word	O
(	O
3	int
,	O
"for"	*(char)
,	O
S_FOR	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'g'	O
:	O
check_word	O
(	O
4	int
,	O
"goto"	*(char)
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
5	int
,	O
"go to"	*(char)
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"go  to"	*(char)
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"go   to"	*(char)
,	O
S_GOTO	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'i'	O
:	O
check_word	O
(	O
2	int
,	O
"if"	*(char)
,	O
S_IF	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"integer"	*(char)
,	O
S_INTEGER	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'l'	O
:	O
check_word	O
(	O
5	int
,	O
"label"	*(char)
,	O
S_LABEL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'o'	O
:	O
check_word	O
(	O
3	int
,	O
"own"	*(char)
,	O
S_OWN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'p'	O
:	O
check_word	O
(	O
9	int
,	O
"procedure"	*(char)
,	O
S_PROCEDURE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'r'	O
:	O
check_word	O
(	O
4	int
,	O
"real"	*(char)
,	O
S_REAL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
's'	O
:	O
check_word	O
(	O
4	int
,	O
"step"	*(char)
,	O
S_STEP	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"string"	*(char)
,	O
S_STRING	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"switch"	*(char)
,	O
S_SWITCH	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
't'	O
:	O
check_word	O
(	O
4	int
,	O
"then"	*(char)
,	O
S_THEN	int
)	O
;	O
check_word	O
(	O
4	int
,	O
"true"	*(char)
,	O
S_TRUE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'u'	O
:	O
check_word	O
(	O
5	int
,	O
"until"	*(char)
,	O
S_UNTIL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'v'	O
:	O
check_word	O
(	O
5	int
,	O
"value"	*(char)
,	O
S_VALUE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'w'	O
:	O
check_word	O
(	O
5	int
,	O
"while"	*(char)
,	O
S_WHILE	int
)	O
;	O
goto	O
alfa	O
;	O
default	O
:	O
alfa	O
:	O
symbol	int
=	O
S_LETTER	int
,	O
s_char	int
=	O
(	O
unsigned	O
char	O
)	O
line	*(char)
[	O
pos	int
++	O
]	O
;	O
}	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
line	*(char)
[	O
pos	int
]	O
)	O
)	O
{	O
symbol	int
=	O
S_DIGIT	int
,	O
s_char	int
=	O
(	O
unsigned	O
char	O
)	O
line	*(char)
[	O
pos	int
++	O
]	O
;	O
}	O
else	O
{	O
switch	O
(	O
line	*(char)
[	O
pos	int
]	O
)	O
{	O
case	O
0x1A	int
:	O
symbol	int
=	O
S_EOF	int
;	O
break	O
;	O
case	O
'+'	O
:	O
symbol	int
=	O
S_PLUS	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'-'	O
:	O
check_spec	O
(	O
'>'	O
,	O
S_MINUS	int
,	O
S_IMPL	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
check_spec	O
(	O
'*'	O
,	O
S_TIMES	int
,	O
S_POWER	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
symbol	int
=	O
S_SLASH	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
symbol	int
=	O
S_INTDIV	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'^'	O
:	O
symbol	int
=	O
S_POWER	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'<'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_LESS	int
,	O
S_NOTGREATER	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
check_spec	O
(	O
'='	O
,	O
S_EQUAL	int
,	O
S_EQUIV	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_GREATER	int
,	O
S_NOTLESS	int
)	O
;	O
break	O
;	O
case	O
'!'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_NOT	int
,	O
S_NOTEQUAL	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
symbol	int
=	O
S_OR	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'&'	O
:	O
symbol	int
=	O
S_AND	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
','	O
:	O
symbol	int
=	O
S_COMMA	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'.'	O
:	O
symbol	int
=	O
S_POINT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
TEN_CHAR	char
:	O
symbol	int
=	O
S_TEN	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
':'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_COLON	int
,	O
S_ASSIGN	int
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
symbol	int
=	O
S_SEMICOLON	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'('	O
:	O
symbol	int
=	O
S_LEFT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
symbol	int
=	O
S_RIGHT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'['	O
:	O
symbol	int
=	O
S_BEGSUB	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
']'	O
:	O
symbol	int
=	O
S_ENDSUB	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'"'	O
:	O
symbol	int
=	O
S_OPEN	int
,	O
pos	int
++	O
;	O
break	O
;	O
default	O
:	O
error	(*(char))->(void)
(	O
"invalid character `%c'"	*(char)
,	O
line	*(char)
[	O
pos	int
]	O
)	O
;	O
pos	int
++	O
;	O
goto	O
scan	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
int	O
t_maxlen	int
=	O
100	int
;	O
static	O
struct	O
{	O
int	O
ssn	int
;	O
int	O
code	int
;	O
int	O
delim	int
;	O
int	O
len	int
;	O
char	O
*	O
image	*(char)
;	O
}	O
token	array(struct(int,int,int,int,*(char)))
[	O
3	int
]	O
;	O
static	O
void	O
add_char	(int,int)->(void)
(	O
int	O
k	int
,	O
int	O
c	int
)	O
{	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
len	int
==	O
t_maxlen	int
)	O
{	O
int	O
kk	int
;	O
t_maxlen	int
+=	O
t_maxlen	int
;	O
for	O
(	O
kk	int
=	O
0	int
;	O
kk	int
<=	O
2	int
;	O
kk	int
++	O
)	O
token	array(struct(int,int,int,int,*(char)))
[	O
kk	int
]	O
.	O
image	*(char)
=	O
my_realloc	(*(void),int)->(*(void))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
kk	int
]	O
.	O
image	*(char)
,	O
t_maxlen	int
+	O
1	int
)	O
;	O
}	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
[	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
[	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
static	O
void	O
scan_token	(int)->(void)
(	O
int	O
k	int
)	O
{	O
assert	O
(	O
k	int
==	O
1	int
||	O
(	O
k	int
==	O
2	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
)	O
;	O
scan	O
:	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_END	int
)	O
{	O
int	O
some	int
=	O
0	int
;	O
int	O
flag	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
symbol	int
==	O
S_EOF	int
||	O
symbol	int
==	O
S_SEMICOLON	int
||	O
symbol	int
==	O
S_ELSE	int
||	O
symbol	int
==	O
S_END	int
)	O
break	O
;	O
some	int
=	O
1	int
;	O
if	O
(	O
!	O
(	O
symbol	int
==	O
S_LETTER	int
||	O
symbol	int
==	O
S_DIGIT	int
||	O
symbol	int
==	O
S_FALSE	int
||	O
symbol	int
==	O
S_TRUE	int
)	O
&&	O
!	O
flag	int
)	O
{	O
warning	(*(char))->(void)
(	O
"comment sequence following `end' contains delim"	*(char)
"iter(s)"	*(char)
)	O
;	O
flag	int
=	O
1	int
;	O
}	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
symbol	int
==	O
S_EOF	int
&&	O
some	int
)	O
warning	(*(char))->(void)
(	O
"comment sequence following `end' terminated by eof"	*(char)
)	O
;	O
}	O
{	O
int	O
flag	int
=	O
0	int
;	O
while	O
(	O
symbol	int
==	O
S_COMMENT	int
)	O
{	O
if	O
(	O
!	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_BEGIN	int
)	O
)	O
)	O
{	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_EOF	int
)	O
{	O
if	O
(	O
!	O
flag	int
)	O
{	O
warning	(*(char))->(void)
(	O
"no symbols preceding delimiter `comment'"	*(char)
)	O
;	O
flag	int
=	O
1	int
;	O
}	O
}	O
else	O
error	(*(char))->(void)
(	O
"delimiter `comment' in invalid position"	*(char)
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
skip_pad	()->(void)
(	O
)	O
;	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
0x1A	int
)	O
{	O
error	(*(char))->(void)
(	O
"comment sequence following `comment' terminate"	*(char)
"d by eof"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
line	*(char)
[	O
pos	int
++	O
]	O
==	O
';'	O
)	O
break	O
;	O
}	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
}	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
ssn	int
=	O
l_count	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
delim	int
=	O
0	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
len	int
=	O
0	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
symbol	int
==	O
S_LETTER	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_IDENT	int
;	O
while	O
(	O
symbol	int
==	O
S_LETTER	int
||	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
>	O
T_MAXLEN	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
[	O
T_MAXLEN	int
]	O
=	O
'\0'	O
;	O
error	(*(char))->(void)
(	O
"identifier `%s...' too long"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_INT	int
;	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
symbol	int
==	O
S_POINT	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'.'	O
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
error	(*(char))->(void)
(	O
"real constant `%s' incomplete"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
;	O
frac	O
:	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
symbol	int
==	O
S_TEN	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	(int,int)->(void)
(	O
k	int
,	O
TEN_CHAR	char
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
dexp	O
:	O
if	O
(	O
symbol	int
==	O
S_PLUS	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'+'	O
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
symbol	int
==	O
S_MINUS	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'-'	O
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
error	(*(char))->(void)
(	O
"real constant `%s' incomplete"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
;	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	(int,int)->(void)
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
>	O
T_MAXLEN	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
[	O
T_MAXLEN	int
]	O
=	O
'\0'	O
;	O
error	(*(char))->(void)
(	O
"constant `%s...' too long"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_FALSE	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_FALSE	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
,	O
"false"	*(char)
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_TRUE	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_TRUE	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
,	O
"true"	*(char)
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_OPEN	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_STRING	int
;	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'"'	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
0x1A	int
)	O
{	O
error	(*(char))->(void)
(	O
"unexpected eof within string"	*(char)
)	O
;	O
goto	O
clos	O
;	O
}	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
error	(*(char))->(void)
(	O
"string incomplete"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
iscntrl	(int)->(int)
(	O
line	*(char)
[	O
pos	int
]	O
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of control character 0x%02X within"	*(char)
" string"	*(char)
,	O
line	*(char)
[	O
pos	int
]	O
)	O
;	O
pos	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
'\\'	O
)	O
{	O
pos	int
++	O
;	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
0x1A	int
||	O
line	*(char)
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of backslash within string"	*(char)
)	O
;	O
continue	O
;	O
}	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'\\'	O
)	O
;	O
}	O
else	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
==	O
'"'	O
)	O
{	O
pos	int
++	O
;	O
break	O
;	O
}	O
add_char	(int,int)->(void)
(	O
k	int
,	O
line	*(char)
[	O
pos	int
++	O
]	O
)	O
;	O
}	O
skip_pad	()->(void)
(	O
)	O
;	O
if	O
(	O
line	*(char)
[	O
pos	int
]	O
!=	O
'"'	O
)	O
break	O
;	O
pos	int
++	O
;	O
}	O
clos	O
:	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'"'	O
)	O
;	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_POINT	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	(int,int)->(void)
(	O
k	int
,	O
'.'	O
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of period"	*(char)
)	O
;	O
goto	O
scan	O
;	O
}	O
goto	O
frac	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_TEN	int
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	(int,int)->(void)
(	O
k	int
,	O
TEN_CHAR	char
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
symbol	int
==	O
S_PLUS	int
||	O
symbol	int
==	O
S_MINUS	int
||	O
symbol	int
==	O
S_DIGIT	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of subscripted ten"	*(char)
)	O
;	O
goto	O
scan	O
;	O
}	O
goto	O
dexp	O
;	O
}	O
else	O
{	O
char	O
*	O
image	*(char)
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
delim	int
=	O
symbol	int
;	O
switch	O
(	O
symbol	int
)	O
{	O
case	O
S_EOF	int
:	O
image	*(char)
=	O
"eof"	*(char)
;	O
break	O
;	O
case	O
S_PLUS	int
:	O
image	*(char)
=	O
"+"	*(char)
;	O
break	O
;	O
case	O
S_MINUS	int
:	O
image	*(char)
=	O
"-"	*(char)
;	O
break	O
;	O
case	O
S_TIMES	int
:	O
image	*(char)
=	O
"*"	*(char)
;	O
break	O
;	O
case	O
S_SLASH	int
:	O
image	*(char)
=	O
"/"	*(char)
;	O
break	O
;	O
case	O
S_INTDIV	int
:	O
image	*(char)
=	O
"%"	*(char)
;	O
break	O
;	O
case	O
S_POWER	int
:	O
image	*(char)
=	O
"^"	*(char)
;	O
break	O
;	O
case	O
S_LESS	int
:	O
image	*(char)
=	O
"<"	*(char)
;	O
break	O
;	O
case	O
S_NOTGREATER	int
:	O
image	*(char)
=	O
"<="	*(char)
;	O
break	O
;	O
case	O
S_EQUAL	int
:	O
image	*(char)
=	O
"="	*(char)
;	O
break	O
;	O
case	O
S_NOTLESS	int
:	O
image	*(char)
=	O
">="	*(char)
;	O
break	O
;	O
case	O
S_GREATER	int
:	O
image	*(char)
=	O
">"	*(char)
;	O
break	O
;	O
case	O
S_NOTEQUAL	int
:	O
image	*(char)
=	O
"!="	*(char)
;	O
break	O
;	O
case	O
S_EQUIV	int
:	O
image	*(char)
=	O
"=="	*(char)
;	O
break	O
;	O
case	O
S_IMPL	int
:	O
image	*(char)
=	O
"->"	*(char)
;	O
break	O
;	O
case	O
S_OR	int
:	O
image	*(char)
=	O
"|"	*(char)
;	O
break	O
;	O
case	O
S_AND	int
:	O
image	*(char)
=	O
"&"	*(char)
;	O
break	O
;	O
case	O
S_NOT	int
:	O
image	*(char)
=	O
"!"	*(char)
;	O
break	O
;	O
case	O
S_COMMA	int
:	O
image	*(char)
=	O
","	*(char)
;	O
break	O
;	O
case	O
S_COLON	int
:	O
image	*(char)
=	O
":"	*(char)
;	O
break	O
;	O
case	O
S_SEMICOLON	int
:	O
image	*(char)
=	O
";"	*(char)
;	O
break	O
;	O
case	O
S_ASSIGN	int
:	O
image	*(char)
=	O
":="	*(char)
;	O
break	O
;	O
case	O
S_LEFT	int
:	O
image	*(char)
=	O
"("	*(char)
;	O
break	O
;	O
case	O
S_RIGHT	int
:	O
image	*(char)
=	O
")"	*(char)
;	O
break	O
;	O
case	O
S_BEGSUB	int
:	O
image	*(char)
=	O
"["	*(char)
;	O
break	O
;	O
case	O
S_ENDSUB	int
:	O
image	*(char)
=	O
"]"	*(char)
;	O
break	O
;	O
case	O
S_ARRAY	int
:	O
image	*(char)
=	O
"array"	*(char)
;	O
break	O
;	O
case	O
S_BEGIN	int
:	O
image	*(char)
=	O
"begin"	*(char)
;	O
break	O
;	O
case	O
S_BOOLEAN	int
:	O
image	*(char)
=	O
"Boolean"	*(char)
;	O
break	O
;	O
case	O
S_CODE	int
:	O
image	*(char)
=	O
"code"	*(char)
;	O
break	O
;	O
case	O
S_DO	int
:	O
image	*(char)
=	O
"do"	*(char)
;	O
break	O
;	O
case	O
S_ELSE	int
:	O
image	*(char)
=	O
"else"	*(char)
;	O
break	O
;	O
case	O
S_END	int
:	O
image	*(char)
=	O
"end"	*(char)
;	O
break	O
;	O
case	O
S_FOR	int
:	O
image	*(char)
=	O
"for"	*(char)
;	O
break	O
;	O
case	O
S_GOTO	int
:	O
image	*(char)
=	O
"go to"	*(char)
;	O
break	O
;	O
case	O
S_IF	int
:	O
image	*(char)
=	O
"if"	*(char)
;	O
break	O
;	O
case	O
S_INTEGER	int
:	O
image	*(char)
=	O
"integer"	*(char)
;	O
break	O
;	O
case	O
S_LABEL	int
:	O
image	*(char)
=	O
"label"	*(char)
;	O
break	O
;	O
case	O
S_OWN	int
:	O
image	*(char)
=	O
"own"	*(char)
;	O
break	O
;	O
case	O
S_PROCEDURE	int
:	O
image	*(char)
=	O
"procedure"	*(char)
;	O
break	O
;	O
case	O
S_REAL	int
:	O
image	*(char)
=	O
"real"	*(char)
;	O
break	O
;	O
case	O
S_STEP	int
:	O
image	*(char)
=	O
"step"	*(char)
;	O
break	O
;	O
case	O
S_STRING	int
:	O
image	*(char)
=	O
"string"	*(char)
;	O
break	O
;	O
case	O
S_SWITCH	int
:	O
image	*(char)
=	O
"switch"	*(char)
;	O
break	O
;	O
case	O
S_THEN	int
:	O
image	*(char)
=	O
"then"	*(char)
;	O
break	O
;	O
case	O
S_UNTIL	int
:	O
image	*(char)
=	O
"until"	*(char)
;	O
break	O
;	O
case	O
S_VALUE	int
:	O
image	*(char)
=	O
"value"	*(char)
;	O
break	O
;	O
case	O
S_WHILE	int
:	O
image	*(char)
=	O
"while"	*(char)
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
symbol	int
!=	O
symbol	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
,	O
image	*(char)
)	O
,	O
scan_symbol	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
debug	int
&&	O
first_pass	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%6d: %-6s |%s|\n"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
ssn	int
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_IDENT	int
?	O
"ident"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_INT	int
?	O
"int"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_REAL	int
?	O
"real"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_FALSE	int
?	O
"false"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_TRUE	int
?	O
"true"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_STRING	int
?	O
"string"	*(char)
:	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
code	int
==	O
T_DELIM	int
?	O
"delim"	*(char)
:	O
"???"	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
k	int
]	O
.	O
image	*(char)
)	O
;	O
}	O
return	O
;	O
}	O
;	O
static	O
void	O
get_token	()->(void)
(	O
void	O
)	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
ssn	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
ssn	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
code	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
code	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
delim	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
len	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
len	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
image	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
image	*(char)
)	O
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
scan_token	(int)->(void)
(	O
1	int
)	O
;	O
else	O
{	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
ssn	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
ssn	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
code	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
len	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
len	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
image	*(char)
,	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
image	*(char)
)	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
}	O
return	O
;	O
}	O
static	O
void	O
get_token2	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
scan_token	(int)->(void)
(	O
2	int
)	O
;	O
return	O
;	O
}	O
typedef	O
struct	O
CODE	struct
CODE	struct
;	O
typedef	O
struct	O
CSQE	struct
CSQE	struct
;	O
struct	O
CODE	struct
{	O
int	O
lval	int
;	O
int	O
type	int
;	O
CSQE	struct
*	O
head	*(struct)
;	O
CSQE	struct
*	O
tail	*(struct)
;	O
}	O
;	O
struct	O
CSQE	struct
{	O
char	O
*	O
str	*(char)
;	O
CSQE	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
;	O
static	O
char	O
codebuf	array(char)
[	O
4000	int
]	O
;	O
static	O
CODE	struct
*	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
if	O
(	O
first_pass	int
)	O
return	O
NULL	O
;	O
else	O
{	O
CODE	struct
*	O
code	int
=	O
my_malloc	(int)->(*(void))
(	O
sizeof	O
(	O
CODE	struct
)	O
)	O
;	O
code	int
->	O
lval	int
=	O
code	int
->	O
type	int
=	O
0	int
;	O
code	int
->	O
head	*(struct)
=	O
code	int
->	O
tail	*(struct)
=	O
NULL	O
;	O
return	O
code	int
;	O
}	O
}	O
static	O
void	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
CODE	struct
*	O
code	int
,	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	array(struct(int,int,*(void),*(void)))
;	O
CSQE	struct
*	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vsprintf	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
codebuf	array(char)
,	O
fmt	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
codebuf	array(char)
)	O
<	O
sizeof	O
(	O
codebuf	array(char)
)	O
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
my_malloc	(int)->(*(void))
(	O
sizeof	O
(	O
CSQE	struct
)	O
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
codebuf	array(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
,	O
codebuf	array(char)
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
code	int
->	O
head	*(struct)
;	O
code	int
->	O
head	*(struct)
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
code	int
->	O
tail	*(struct)
==	O
NULL	O
)	O
code	int
->	O
tail	*(struct)
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
return	O
;	O
}	O
static	O
void	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
CODE	struct
*	O
code	int
,	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	array(struct(int,int,*(void),*(void)))
;	O
CSQE	struct
*	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
va_start	O
(	O
arg	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vsprintf	(*(char),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
codebuf	array(char)
,	O
fmt	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
codebuf	array(char)
)	O
<	O
sizeof	O
(	O
codebuf	array(char)
)	O
)	O
;	O
va_end	O
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
my_malloc	(int)->(*(void))
(	O
sizeof	O
(	O
CSQE	struct
)	O
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
codebuf	array(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
,	O
codebuf	array(char)
)	O
;	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
code	int
->	O
head	*(struct)
==	O
NULL	O
)	O
code	int
->	O
head	*(struct)
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
else	O
code	int
->	O
tail	*(struct)
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
code	int
->	O
tail	*(struct)
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
return	O
;	O
}	O
static	O
void	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
CODE	struct
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
head	*(struct)
==	O
NULL	O
)	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
head	*(struct)
=	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
head	*(struct)
;	O
else	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
tail	*(struct)
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
head	*(struct)
;	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
tail	*(struct)
!=	O
NULL	O
)	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
tail	*(struct)
=	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
tail	*(struct)
;	O
my_free	(*(void))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
CODE	struct
*	O
code	int
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
CSQE	struct
*	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
while	O
(	O
code	int
->	O
head	*(struct)
!=	O
NULL	O
)	O
{	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
code	int
->	O
head	*(struct)
;	O
code	int
->	O
head	*(struct)
=	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
my_free	(*(void))->(void)
(	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
)	O
;	O
my_free	(*(void))->(void)
(	O
sqe	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
;	O
}	O
my_free	(*(void))->(void)
(	O
code	int
)	O
;	O
}	O
return	O
;	O
}	O
typedef	O
struct	O
BLOCK	struct
BLOCK	struct
;	O
typedef	O
struct	O
IDENT	struct
IDENT	struct
;	O
struct	O
BLOCK	struct
{	O
int	O
seqn	int
;	O
int	O
ssn	int
;	O
IDENT	struct
*	O
proc	*(struct)
;	O
IDENT	struct
*	O
first	*(struct)
,	O
*	O
last	*(struct)
;	O
BLOCK	struct
*	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
BLOCK	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
;	O
static	O
BLOCK	struct
*	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
*	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
static	O
BLOCK	struct
*	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
struct	O
IDENT	struct
{	O
char	O
*	O
name	*(char)
;	O
int	O
ssn_decl	int
;	O
int	O
ssn_used	int
;	O
int	O
flags	int
;	O
int	O
dim	int
;	O
BLOCK	struct
*	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
IDENT	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
;	O
static	O
int	O
array_decl_flag	int
=	O
0	int
;	O
static	O
IDENT	struct
*	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
char	O
*	O
name	*(char)
,	O
int	O
decl	int
,	O
int	O
ssn	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
if	O
(	O
first_pass	int
)	O
{	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
decl	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
!=	O
0	int
)	O
{	O
error	(*(char))->(void)
(	O
"identifier `%s' multiply declared (see line %d)"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
my_malloc	(int)->(*(void))
(	O
sizeof	O
(	O
IDENT	struct
)	O
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
-	O
1	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
==	O
NULL	O
)	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
else	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
last	*(struct)
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
last	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
}	O
if	O
(	O
decl	int
)	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
ssn	int
;	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
==	O
0	int
)	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
=	O
ssn	int
;	O
}	O
else	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
assert	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
array_decl_flag	int
&&	O
!	O
decl	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
error	(*(char))->(void)
(	O
"identifier `%s' in bound expression declared in same"	*(char)
" program block as array"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
return	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
}	O
static	O
void	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
second_pass	int
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
)	O
{	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_REAL	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_int2real	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
second_pass	int
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
{	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_real2int	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
level	int
++	O
;	O
return	O
level	int
;	O
}	O
static	O
int	O
current_level	()->(int)
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
level	int
++	O
;	O
return	O
level	int
;	O
}	O
static	O
CODE	struct
*	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
subscripted_variable	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
IDENT	struct
*	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
int	O
dim	int
=	O
0	int
;	O
char	O
*	O
place	*(char)
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
!	O
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
error	(*(char))->(void)
(	O
"invalid use of `%s' as array identifier"	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
1	int
;	O
code	int
->	O
type	int
=	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"(*%s("	*(char)
,	O
code	int
->	O
type	int
==	O
F_REAL	int
?	O
a_loc_real	*(char)
:	O
code	int
->	O
type	int
==	O
F_INT	int
?	O
a_loc_int	*(char)
:	O
a_loc_bool	*(char)
)	O
;	O
if	O
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s_%d, ?, "	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d, ?, "	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
place	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
code	int
->	O
tail	*(struct)
->	O
str	*(char)
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	*(char)
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
expr	*(char)
;	O
if	O
(	O
dim	int
==	O
9	int
)	O
{	O
error	(*(char))->(void)
(	O
"number of subscripts exceeds allowable maximum"	*(char)
)	O
;	O
dim	int
=	O
0	int
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
,	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
if	O
(	O
second_pass	int
&&	O
expr	*(char)
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid type of subscript expression"	*(char)
)	O
;	O
expr	*(char)
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing right parenthesis in subscripted variable"	*(char)
)	O
;	O
if	O
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
<	O
0	int
)	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
&&	O
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
&&	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
!=	O
dim	int
)	O
{	O
if	O
(	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
error	(*(char))->(void)
(	O
"number of subscripts in subscripted variable conflic"	*(char)
"ts with earlier use of array `%s'"	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"number of subscripts in subscripted variable conflic"	*(char)
"ts with declaration of array `%s' at line %d"	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arr	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
assert	O
(	O
1	int
<=	O
dim	int
&&	O
dim	int
<=	O
9	int
)	O
;	O
if	O
(	O
second_pass	int
)	O
*	O
place	*(char)
=	O
(	O
char	O
)	O
(	O
dim	int
+	O
'0'	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"))"	*(char)
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
switch_designator	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
IDENT	struct
*	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
int	O
dim	int
=	O
0	int
;	O
assert	O
(	O
second_pass	int
)	O
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
assert	O
(	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
dim	int
==	O
1	int
)	O
error	(*(char))->(void)
(	O
"invalid number of subscripts in switch designator fo"	*(char)
"r `%s'"	*(char)
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
,	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
)	O
;	O
if	O
(	O
code	int
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid type of subscript expression"	*(char)
)	O
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
}	O
dim	int
++	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
}	O
assert	O
(	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
if	O
(	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
{	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
a_global_dsa	*(char)
" = dsa_%d->%s_%d.arg2, (*(stru"	*(char)
"ct label (*)(int))dsa_%d->%s_%d.arg1)("	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
a_global_dsa	*(char)
" = (void *)dsa_%d, %s_%d("	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
swit	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"))"	*(char)
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
static	O
void	O
emit_dsa_pointers	()->(void)
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
level	int
=	O
current_level	()->(int)
(	O
)	O
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
NULL	O
)	O
continue	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      register struct dsa_%s_%d *dsa_%d = (vo"	*(char)
"id *)"	*(char)
a_global_dsa	*(char)
"->vector[%d];\n"	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
level	int
,	O
level	int
)	O
;	O
level	int
--	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
thunk_count	int
=	O
0	int
;	O
static	O
int	O
thunk_real0	int
=	O
0	int
;	O
static	O
int	O
thunk_real1	int
=	O
0	int
;	O
static	O
int	O
thunk_int0	int
=	O
0	int
;	O
static	O
int	O
thunk_int1	int
=	O
0	int
;	O
static	O
int	O
thunk_false	int
=	O
0	int
;	O
static	O
int	O
thunk_true	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
int	O
ssn	int
)	O
;	O
static	O
CODE	struct
*	O
actual_parameter	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
arg	array(struct(int,int,*(void),*(void)))
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
if	O
(	O
second_pass	int
&&	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
&&	O
!	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"string passed as actual parameter conflicts with kin"	*(char)
"d of formal parameter `%s' as specified in declaration "	*(char)
"of procedure `%s' beginning at line %d"	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
t_image	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", NULL)"	*(char)
)	O
;	O
skip1	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
(	O
F_REAL	int
|	O
F_BYNAME	int
)	O
||	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
(	O
F_INT	int
|	O
F_BYNAME	int
)	O
||	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
(	O
F_BOOL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"formal parameter `%s' called by name and pa"	*(char)
"ssed as actual parameter conflicts with kind o"	*(char)
"f formal parameter `%s' as specified in declar"	*(char)
"ation of procedure `%s' beginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1a	O
;	O
}	O
actual_type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	(*(char))->(void)
(	O
"type of formal parameter `%s' called by nam"	*(char)
"e and passed as actual parameter conflicts wit"	*(char)
"h type of formal parameter `%s' as specified i"	*(char)
"n declaration of procedure `%s' beginning at l"	*(char)
"ine %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1a	O
;	O
}	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
skip1a	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
!	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"array `%s' passed as actual parameter confl"	*(char)
"icts with kind of formal parameter `%s' as spe"	*(char)
"cified in declaration of procedure `%s' beginn"	*(char)
"ing at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
actual_type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_BYVAL	int
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	(*(char))->(void)
(	O
"type of array `%s' passed as actual paramet"	*(char)
"er conflicts with type of formal array `%s' as"	*(char)
" specified in declaration of procedure `%s' be"	*(char)
"ginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
>=	O
0	int
&&	O
arg	array(struct(int,int,*(void),*(void)))
->	O
dim	int
>=	O
0	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
!=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
dim	int
)	O
{	O
error	(*(char))->(void)
(	O
"dimension of array `%s' passed as actual pa"	*(char)
"rameter not equal to dimension of formal array"	*(char)
" `%s' as implied in declaration of procedure `"	*(char)
"%s' beginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"(dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"(%s_%d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", (void *)'%c')"	*(char)
,	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
'r'	O
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
?	O
'i'	O
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
'b'	O
:	O
'?'	O
)	O
;	O
skip2	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_SWITCH	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"switch `%s' passed as actual parameter conf"	*(char)
"licts with kind of formal parameter `%s' as sp"	*(char)
"ecified in declaration of procedure `%s' begin"	*(char)
"ning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip3	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"((void *)%s_%d, dsa_%d)"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
current_level	()->(int)
(	O
)	O
)	O
;	O
}	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
skip3	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_PROC	int
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
{	O
int	O
simple	int
=	O
!	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
;	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
!	O
(	O
simple	int
||	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"procedure `%s' passed as actual parameter c"	*(char)
"onflicts with kind of formal parameter `%s' as"	*(char)
" specified in declaration of procedure `%s' be"	*(char)
"ginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
actual_type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
!	O
simple	int
)	O
goto	O
proc	*(struct)
;	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
||	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
>	O
0	int
)	O
{	O
error	(*(char))->(void)
(	O
"procedure identifier `%s' that is not in it"	*(char)
"self a complete expression and passed as actua"	*(char)
"l parameter conflicts with kind of formal para"	*(char)
"meter `%s' as specified in declaration of proc"	*(char)
"edure `%s' beginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	(*(char))->(void)
(	O
"procedure identifier `%s' that is in itself"	*(char)
" a complete expression and passed as actual pa"	*(char)
"rameter conflicts with type of formal paramete"	*(char)
"r `%s' as specified in declaration of procedur"	*(char)
"e `%s' beginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
goto	O
gen1	O
;	O
proc	*(struct)
:	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
&&	O
formal_type	int
)	O
{	O
error	(*(char))->(void)
(	O
"type of procedure `%s' passed as actual par"	*(char)
"ameter conflicts with type of formal procedure"	*(char)
" `%s' as specified in declaration of procedure"	*(char)
" `%s' beginning at line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
>=	O
0	int
&&	O
arg	array(struct(int,int,*(void),*(void)))
->	O
dim	int
>=	O
0	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
!=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
dim	int
)	O
{	O
error	(*(char))->(void)
(	O
"number of parameters of procedure `%s' pass"	*(char)
"ed as actual parameter not equal to number of "	*(char)
"parameters of formal procedure `%s' as implied"	*(char)
" in declaration of procedure `%s' beginning at"	*(char)
" line %d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
}	O
gen1	O
:	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"((void *)%s_%d, dsa_%d)"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
current_level	()->(int)
(	O
)	O
)	O
;	O
}	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
skip4	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_STRING	int
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
&&	O
!	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"formal string passed as actual parameter confl"	*(char)
"icts with kind of formal parameter `%s' as specif"	*(char)
"ied in declaration of procedure `%s' beginning at"	*(char)
" line %d"	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip5	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"(dsa_%d->%s_%d, NULL)"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
skip5	O
:	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
}	O
{	O
CODE	struct
*	O
expr	*(char)
;	O
int	O
need_dsa	int
=	O
1	int
,	O
thunk	int
,	O
ssn	int
;	O
if	O
(	O
(	O
t_code	O
==	O
T_REAL	int
||	O
t_code	O
==	O
T_INT	int
||	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
need_dsa	int
=	O
0	int
;	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_REAL	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t_image	O
,	O
"0.0"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
t_image	O
,	O
".0"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_real0	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_real0	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_real0	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t_image	O
,	O
"1.0"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_real1	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_real1	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_real1	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_INT	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t_image	O
,	O
"0"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_int0	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_int0	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_int0	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t_image	O
,	O
"1"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_int1	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_int1	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_int1	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_FALSE	int
)	O
{	O
if	O
(	O
thunk_false	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_false	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_false	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_TRUE	int
)	O
{	O
if	O
(	O
thunk_true	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_true	int
,	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_true	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
ssn	int
=	O
t_ssn	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_LABEL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"expression passed as actual parameter conflict"	*(char)
"s with kind of formal parameter `%s' as specified"	*(char)
" in declaration of procedure `%s' beginning at li"	*(char)
"ne %d"	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip6	O
;	O
}	O
actual_type	int
=	O
expr	*(char)
->	O
type	int
;	O
formal_type	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_LABEL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	(*(char))->(void)
(	O
"type of expression passed as actual parameter "	*(char)
"conflicts with type of formal parameter `%s' as s"	*(char)
"pecified in declaration of procedure `%s' beginni"	*(char)
"ng at line %d"	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
arg	array(struct(int,int,*(void),*(void)))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
goto	O
skip6	O
;	O
}	O
}	O
thunk_count	int
++	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static struct desc _thunk_%d(void)\n"	*(char)
,	O
thunk_count	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"{     /* actual parameter at line %d */\n"	*(char)
,	O
ssn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct desc res;\n"	*(char)
)	O
;	O
if	O
(	O
need_dsa	int
)	O
{	O
emit_dsa_pointers	()->(void)
(	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
ssn	int
)	O
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.lval = %d;\n"	*(char)
,	O
expr	*(char)
->	O
lval	int
)	O
;	O
switch	O
(	O
expr	*(char)
->	O
type	int
)	O
{	O
case	O
F_REAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.type = 'r';\n"	*(char)
)	O
;	O
if	O
(	O
expr	*(char)
->	O
lval	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.real_ptr = "	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.real_val = "	*(char)
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.type = 'i';\n"	*(char)
)	O
;	O
if	O
(	O
expr	*(char)
->	O
lval	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.int_ptr = "	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.int_val = "	*(char)
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.type = 'b';\n"	*(char)
)	O
;	O
if	O
(	O
expr	*(char)
->	O
lval	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.bool_ptr = "	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.bool_val = "	*(char)
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.type = 'l';\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      res.u.label = "	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
expr	*(char)
->	O
type	int
!=	O
expr	*(char)
->	O
type	int
)	O
;	O
}	O
if	O
(	O
expr	*(char)
->	O
lval	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"&("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
else	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
";\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      return res;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"}\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
thunk	int
=	O
thunk_count	int
;	O
gen2	O
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_arg	*(char)
"((void *)_thunk_%d, dsa_%d)"	*(char)
,	O
thunk	int
,	O
current_level	()->(int)
(	O
)	O
)	O
;	O
skip6	O
:	O
;	O
}	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
int	O
ext_comma	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
{	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
!=	O
T_IDENT	int
)	O
return	O
0	int
;	O
get_token	()->(void)
(	O
)	O
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
{	O
char	O
*	O
t	*(char)
;	O
for	O
(	O
t	*(char)
=	O
t_image	O
;	O
*	O
t	*(char)
;	O
t	*(char)
++	O
)	O
{	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
*	O
t	*(char)
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid letter string in parameter delimiter"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_COLON	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing colon in parameter delimiter"	*(char)
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing left parenthesis in parameter delimiter"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
function_designator	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
int	O
stmt	int
)	O
{	O
IDENT	struct
*	O
proc	*(struct)
;	O
IDENT	struct
*	O
arg	array(struct(int,int,*(void),*(void)))
=	O
NULL	O
;	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
int	O
list	int
;	O
int	O
dim	int
=	O
0	int
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
proc	*(struct)
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
error	(*(char))->(void)
(	O
"invalid use of `%s' as procedure identifier"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
proc	*(struct)
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BLTIN	int
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"inline"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"print"	*(char)
)	O
==	O
0	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of pseudo procedure `%s' in function des"	*(char)
"ignator"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
code	int
->	O
type	int
==	O
0	int
&&	O
!	O
stmt	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of typeless procedure `%s' in function d"	*(char)
"esignator"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s("	*(char)
,	O
(	O
code	int
->	O
type	int
&	O
F_REAL	int
)	O
?	O
a_get_real	*(char)
:	O
(	O
code	int
->	O
type	int
&	O
F_INT	int
)	O
?	O
a_get_int	*(char)
:	O
(	O
code	int
->	O
type	int
&	O
F_BOOL	int
)	O
?	O
a_get_bool	*(char)
:	O
""	*(char)
)	O
;	O
if	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BYNAME	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
a_global_dsa	*(char)
" = dsa_%d->%s_%d.arg2, (*(st"	*(char)
"ruct desc (*)())dsa_%d->%s_%d.arg1)("	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
a_global_dsa	*(char)
" = (void *)dsa_%d, %s_%d("	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
list	int
=	O
t_delim	O
(	O
S_LEFT	int
)	O
;	O
if	O
(	O
!	O
list	int
)	O
goto	O
skip	O
;	O
if	O
(	O
second_pass	int
&&	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
!	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
proc	*(struct)
)	O
break	O
;	O
assert	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
actual_parameter	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
arg	array(struct(int,int,*(void),*(void)))
)	O
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
!	O
ext_comma	()->(int)
(	O
)	O
)	O
break	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
if	O
(	O
second_pass	int
&&	O
arg	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
arg	array(struct(int,int,*(void),*(void)))
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing right parenthesis after actual parameter list"	*(char)
)	O
;	O
skip	O
:	O
if	O
(	O
proc	*(struct)
->	O
dim	int
<	O
0	int
)	O
proc	*(struct)
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
&&	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
proc	*(struct)
->	O
dim	int
!=	O
dim	int
)	O
{	O
if	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BYNAME	int
)	O
error	(*(char))->(void)
(	O
"number of parameters in function designator or proce"	*(char)
"dure statement conflicts with earlier use of procedure "	*(char)
"`%s'"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"number of parameters in function designator or proce"	*(char)
"dure statement conflicts with declaration of procedure "	*(char)
"`%s' beginning at line %d"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
}	O
if	O
(	O
list	int
&&	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")))"	*(char)
)	O
;	O
return	O
code	int
;	O
}	O
static	O
int	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
level	int
++	O
;	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
break	O
;	O
}	O
assert	O
(	O
level	int
>=	O
0	int
)	O
;	O
return	O
level	int
;	O
}	O
static	O
CODE	struct
*	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
a_global_dsa	*(char)
" = dsa_%d->%s_%d.arg2, (*(struct desc (*)"	*(char)
"(void))dsa_%d->%s_%d.arg1)())"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
if	O
(	O
t_code	O
==	O
T_REAL	int
)	O
{	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_REAL	int
;	O
{	O
char	O
*	O
ptr	*(void)
,	O
*	O
ten	*(char)
;	O
for	O
(	O
ptr	*(void)
=	O
t_image	O
;	O
*	O
ptr	*(void)
!=	O
'\0'	O
;	O
ptr	*(void)
++	O
)	O
if	O
(	O
*	O
ptr	*(void)
!=	O
'0'	O
)	O
break	O
;	O
assert	O
(	O
*	O
ptr	*(void)
!=	O
'\0'	O
)	O
;	O
if	O
(	O
*	O
ptr	*(void)
==	O
TEN_CHAR	char
&&	O
ptr	*(void)
!=	O
t_image	O
)	O
ptr	*(void)
--	O
;	O
ten	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr	*(void)
,	O
TEN_CHAR	char
)	O
;	O
if	O
(	O
ten	*(char)
!=	O
NULL	O
)	O
*	O
ten	*(char)
=	O
'e'	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s%s"	*(char)
,	O
ten	*(char)
==	O
ptr	*(void)
?	O
"1"	*(char)
:	O
""	*(char)
,	O
ptr	*(void)
)	O
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
)	O
{	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
{	O
char	O
*	O
ptr	*(void)
;	O
for	O
(	O
ptr	*(void)
=	O
t_image	O
;	O
*	O
ptr	*(void)
!=	O
'\0'	O
;	O
ptr	*(void)
++	O
)	O
if	O
(	O
*	O
ptr	*(void)
!=	O
'0'	O
)	O
break	O
;	O
if	O
(	O
*	O
ptr	*(void)
==	O
'\0'	O
)	O
ptr	*(void)
--	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s"	*(char)
,	O
ptr	*(void)
)	O
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
{	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_BOOL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s"	*(char)
,	O
t_code	O
==	O
T_FALSE	int
?	O
a_false	*(char)
:	O
a_true	*(char)
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_BEGSUB	int
)	O
{	O
if	O
(	O
first_pass	int
||	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
)	O
code	int
=	O
subscripted_variable	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
else	O
code	int
=	O
switch_designator	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_LEFT	int
)	O
{	O
proc	*(struct)
:	O
code	int
=	O
function_designator	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
second_pass	int
&&	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
goto	O
proc	*(struct)
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
code	int
->	O
lval	int
=	O
1	int
;	O
code	int
->	O
type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s_%d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_REAL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_get_real	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_get_int	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_BOOL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_get_bool	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_make_label	*(char)
"(dsa_%d->jump_%d, %d)"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_get_label	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
error	(*(char))->(void)
(	O
"invalid use of identifier `%s' as expressio"	*(char)
"n operand"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
break	O
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing right parenthesis after expression"	*(char)
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of string as expression operand"	*(char)
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_DELIM	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of delimiter `%s' as expression operand"	*(char)
,	O
t_image	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
assert	O
(	O
t_code	O
!=	O
t_code	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_POWER	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `^' is not of arithmetic type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `^' is not of arithmetic type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
,	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_expr	*(char)
"("	*(char)
)	O
;	O
else	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_expn	*(char)
"("	*(char)
)	O
;	O
else	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_expi	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_TIMES	int
)	O
||	O
t_delim	O
(	O
S_SLASH	int
)	O
||	O
t_delim	O
(	O
S_INTDIV	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `*', `/', or `%%' is not of ari"	*(char)
"thmetic type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
op	int
==	O
S_INTDIV	int
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `%%' is not of integer type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `*', `/', or `%%' is not of ari"	*(char)
"thmetic type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
op	int
==	O
S_INTDIV	int
&&	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `%%' is not of integer type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
||	O
op	int
==	O
S_SLASH	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
,	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" %c "	*(char)
,	O
op	int
==	O
S_TIMES	int
?	O
'*'	O
:	O
'/'	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
arith_expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
||	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
;	O
get_token	()->(void)
(	O
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand following unary `+' or `-' is not of arit"	*(char)
"hmetic type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"%c"	*(char)
,	O
op	int
==	O
S_PLUS	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
}	O
}	O
else	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
||	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `+' or `-' is not of arithmetic"	*(char)
" type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `+' or `-' is not of arithmetic"	*(char)
" type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
,	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" %c "	*(char)
,	O
op	int
==	O
S_PLUS	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
relation	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
int	O
flag	int
=	O
0	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
arith_expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_LESS	int
)	O
||	O
t_delim	O
(	O
S_NOTGREATER	int
)	O
||	O
t_delim	O
(	O
S_EQUAL	int
)	O
||	O
t_delim	O
(	O
S_NOTLESS	int
)	O
||	O
t_delim	O
(	O
S_GREATER	int
)	O
||	O
t_delim	O
(	O
S_NOTEQUAL	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
flag	int
)	O
error	(*(char))->(void)
(	O
"invalid use of relational operator"	*(char)
)	O
;	O
flag	int
=	O
1	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding relational operator is not of a"	*(char)
"rithmetic type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
arith_expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"operand following relational operator is not of a"	*(char)
"rithmetic type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
||	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
,	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"%s("	*(char)
,	O
op	int
==	O
S_LESS	int
?	O
a_less	*(char)
:	O
op	int
==	O
S_NOTGREATER	int
?	O
a_notgreater	*(char)
:	O
op	int
==	O
S_EQUAL	int
?	O
a_equal	*(char)
:	O
op	int
==	O
S_NOTLESS	int
?	O
a_notless	*(char)
:	O
op	int
==	O
S_GREATER	int
?	O
a_greater	*(char)
:	O
op	int
==	O
S_NOTEQUAL	int
?	O
a_notequal	*(char)
:	O
"???"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
bool_primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_NOT	int
)	O
)	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
relation	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
else	O
{	O
get_token	()->(void)
(	O
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
relation	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `!' is not of Boolean type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_not	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
bool_factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_AND	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `&' is not of Boolean type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_primary	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `&' is not of Boolean type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_and	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
bool_term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_OR	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `|' is not of Boolean type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_factor	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `|' is not of Boolean type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_or	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
implication	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_IMPL	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `->' is not of Boolean type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
bool_term	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `->' is not of Boolean type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_impl	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
simple_expr	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
implication	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_EQUIV	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand preceding `==' is not of Boolean type"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
implication	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"operand following `==' is not of Boolean type"	*(char)
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
a_equiv	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
")"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_IF	int
)	O
)	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
simple_expr	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
else	O
{	O
CODE	struct
*	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
get_token	()->(void)
(	O
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing `then' delimiter"	*(char)
)	O
;	O
if	O
(	O
second_pass	int
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_BOOL	int
)	O
error	(*(char))->(void)
(	O
"expression following `if' is not of Boolean type"	*(char)
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
simple_expr	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing `else' delimiter"	*(char)
)	O
;	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
&&	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
&&	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
)	O
error	(*(char))->(void)
(	O
"expressions before and after 'else' incompatible"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"(("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
") ? ("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
sae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
") : ("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
ae	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"))"	*(char)
)	O
;	O
}	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
assignment_statement	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
int	O
flag	int
)	O
{	O
CODE	struct
*	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_ASSIGN	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
first_pass	int
)	O
{	O
get_token	()->(void)
(	O
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
assignment_statement	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
1	int
)	O
;	O
goto	O
skip1	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_LABEL	int
)	O
error	(*(char))->(void)
(	O
"invalid use of label `%s' in left part of assignment"	*(char)
" statement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
error	(*(char))->(void)
(	O
"invalid use of array identifier `%s' in left part of"	*(char)
" assignment statement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
error	(*(char))->(void)
(	O
"invalid use of switch identifier `%s' in left part o"	*(char)
"f assignment statement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_STRING	int
)	O
error	(*(char))->(void)
(	O
"invalid use of formal string `%s' in left part of as"	*(char)
"signment statement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_PROC	int
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
break	O
;	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
error	(*(char))->(void)
(	O
"invalid assignment to procedure identifier `%s' o"	*(char)
"utside procedure declaration body"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
)	O
error	(*(char))->(void)
(	O
"invalid use of typeless procedure identifier `%s'"	*(char)
" in left part of assignment statement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
assignment_statement	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
1	int
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
!=	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
)	O
error	(*(char))->(void)
(	O
"type of identifier `%s' in left part of assignmen"	*(char)
"t statement incompatible with type of assigned expre"	*(char)
"ssion"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
!=	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
)	O
error	(*(char))->(void)
(	O
"different types in left part list of assignment s"	*(char)
"tatement"	*(char)
)	O
;	O
}	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"%s_%d = "	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"dsa_%d->%s_%d = "	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_set_real	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
code	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_REAL	int
;	O
}	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_set_int	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
code	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
break	O
;	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_set_bool	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
code	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
break	O
;	O
case	O
F_REAL	int
|	O
F_PROC	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
:	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"dsa_%d->retval.u.%s = "	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
+	O
1	int
,	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
?	O
"real_val"	*(char)
:	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
?	O
"int_val"	*(char)
:	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_BOOL	int
?	O
"bool_val"	*(char)
:	O
"???"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
skip1	O
:	O
;	O
}	O
else	O
{	O
CODE	struct
*	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
&&	O
!	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
)	O
error	(*(char))->(void)
(	O
"invalid use of delimiter `:=' after expression in"	*(char)
" assignment statement"	*(char)
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
assignment_statement	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
1	int
)	O
;	O
if	O
(	O
first_pass	int
)	O
goto	O
skip2	O
;	O
if	O
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
==	O
0	int
)	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
&&	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
&&	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
)	O
error	(*(char))->(void)
(	O
"type of destination in left part of assignment"	*(char)
" statement incompatible with type of assigned exp"	*(char)
"ression"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
)	O
error	(*(char))->(void)
(	O
"different types in left part list of assignmen"	*(char)
"t statement"	*(char)
)	O
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
1	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" = "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
y	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
skip2	O
:	O
;	O
}	O
else	O
{	O
if	O
(	O
first_pass	int
)	O
goto	O
skip3	O
;	O
if	O
(	O
!	O
flag	int
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of expression"	*(char)
)	O
;	O
goto	O
skip3	O
;	O
}	O
if	O
(	O
!	O
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_INT	int
||	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_BOOL	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid type of assigned expression in assignment"	*(char)
" statement"	*(char)
)	O
;	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_REAL	int
;	O
}	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
lval	int
=	O
0	int
;	O
skip3	O
:	O
;	O
}	O
}	O
if	O
(	O
!	O
flag	int
)	O
{	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      "	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
";\n"	*(char)
)	O
;	O
}	O
return	O
x	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
}	O
static	O
CODE	struct
*	O
go_to_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
assert	O
(	O
t_delim	O
(	O
S_GOTO	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_ELSE	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_END	int
)	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_LABEL	int
)	O
)	O
error	(*(char))->(void)
(	O
"invalid use identifier `%s' as a label in go to s"	*(char)
"tatement"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      goto %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
}	O
code	int
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
code	int
->	O
type	int
!=	O
F_LABEL	int
)	O
error	(*(char))->(void)
(	O
"expression following `go to' is not of label type"	*(char)
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_go_to	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
");\n"	*(char)
)	O
;	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
dummy_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      /* <dummy statement> */;\n"	*(char)
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
int	O
ssn	int
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->line = %d;\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
ssn	int
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
warning	(*(char))->(void)
(	O
"unlabelled dummy statement"	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
||	O
t_code	O
==	O
T_INT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
IDENT	struct
*	O
label	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
label	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
label	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_LABEL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s_%d:\n"	*(char)
,	O
label	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
label	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
get_token	()->(void)
(	O
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use unsigned integer `%s' as a label"	*(char)
,	O
t_image	O
)	O
;	O
get_token	()->(void)
(	O
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
t_ssn	O
)	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
;	O
static	O
int	O
label_count	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
conditional_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
,	O
*	O
then_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
*	O
else_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
int	O
no_else	int
;	O
assert	O
(	O
t_delim	O
(	O
S_IF	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing `then' delimiter"	*(char)
)	O
;	O
if	O
(	O
second_pass	int
&&	O
code	int
->	O
type	int
!=	O
F_BOOL	int
)	O
error	(*(char))->(void)
(	O
"expression following `if' is not of Boolean type"	*(char)
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
then_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
no_else	int
=	O
(	O
t_delim	O
(	O
S_IF	int
)	O
||	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
then_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (!("	*(char)
)	O
;	O
label_count	int
++	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")) goto _omega_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
then_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_omega_%d:\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
no_else	int
)	O
error	(*(char))->(void)
(	O
"invalid use of delimiter `else' after if or for stat"	*(char)
"ement"	*(char)
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
else_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
else_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (!("	*(char)
)	O
;	O
if	O
(	O
second_pass	int
)	O
label_count	int
++	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")) goto _gamma_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
then_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      goto _omega_%d;\n_gamma_%d:\n"	*(char)
,	O
label_count	int
,	O
label_count	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
else_part	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_omega_%d:\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
get_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
{	O
CODE	struct
*	O
expr	*(char)
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
expr	*(char)
->	O
lval	int
=	O
0	int
;	O
expr	*(char)
->	O
type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"%s_%d"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"dsa_%d->%s_%d"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
expr	*(char)
->	O
lval	int
=	O
0	int
;	O
expr	*(char)
->	O
type	int
=	O
F_REAL	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
a_get_real	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
")"	*(char)
)	O
;	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
expr	*(char)
->	O
lval	int
=	O
0	int
;	O
expr	*(char)
->	O
type	int
=	O
F_INT	int
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
a_get_int	*(char)
"("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
,	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
")"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"???"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
return	O
expr	*(char)
;	O
}	O
static	O
CODE	struct
*	O
set_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
CODE	struct
*	O
expr	*(char)
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
expr	*(char)
->	O
type	int
==	O
F_INT	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
expr	*(char)
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
expr	*(char)
->	O
type	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"%s_%d = "	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"dsa_%d->%s_%d = "	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_set_real	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
expr	*(char)
=	O
code	int
;	O
expr	*(char)
->	O
lval	int
=	O
1	int
;	O
expr	*(char)
->	O
type	int
=	O
F_REAL	int
;	O
}	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
a_set_int	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")"	*(char)
)	O
;	O
expr	*(char)
=	O
code	int
;	O
expr	*(char)
->	O
lval	int
=	O
1	int
;	O
expr	*(char)
->	O
type	int
=	O
F_INT	int
;	O
}	O
break	O
;	O
default	O
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"???"	*(char)
)	O
;	O
break	O
;	O
}	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"      "	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
";\n"	*(char)
)	O
;	O
}	O
return	O
expr	*(char)
;	O
}	O
static	O
CODE	struct
*	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
proc	*(struct)
,	O
int	O
ssn	int
)	O
;	O
static	O
CODE	struct
*	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
;	O
static	O
int	O
for_count	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
for_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
int	O
count	int
=	O
first_pass	int
?	O
0	int
:	O
++	O
for_count	int
;	O
assert	O
(	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
char	O
str	*(char)
[	O
50	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"i_%d"	*(char)
,	O
t_ssn	O
)	O
;	O
error	(*(char))->(void)
(	O
"missing controlled variable identifier after `for'; dum"	*(char)
"my identifier `%s' used"	*(char)
,	O
str	*(char)
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
=	O
t_ssn	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
error	(*(char))->(void)
(	O
"subscripted controlled variable not allowed"	*(char)
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing ':=' after controlled variable identifier"	*(char)
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_LABEL	int
|	O
F_ARRAY	int
|	O
F_SWITCH	int
|	O
F_PROC	int
|	O
F_STRING	int
)	O
)	O
error	(*(char))->(void)
(	O
"invalid use of identifier `%s' as controlled variabl"	*(char)
"e"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
)	O
error	(*(char))->(void)
(	O
"invalid type of controlled variable `%s'"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
loop	O
:	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
t_ssn	O
)	O
)	O
;	O
{	O
CODE	struct
*	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
expr	*(char)
->	O
type	int
==	O
F_REAL	int
||	O
expr	*(char)
->	O
type	int
==	O
F_INT	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid type of expression assigned to controlled"	*(char)
" variable"	*(char)
)	O
;	O
expr	*(char)
->	O
type	int
=	O
F_REAL	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_WHILE	int
)	O
)	O
{	O
label_count	int
++	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_gamma_%d:\n"	*(char)
,	O
label_count	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
t_ssn	O
)	O
)	O
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
set_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
expr	*(char)
)	O
)	O
;	O
}	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
||	O
t_delim	O
(	O
S_DO	int
)	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_global_dsa	*(char)
" = (void *)dsa_%d, _sigma_%d();\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
count	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_STEP	int
)	O
)	O
{	O
IDENT	struct
*	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
CODE	struct
*	O
expr	*(char)
;	O
if	O
(	O
first_pass	int
)	O
{	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"teta_r"	*(char)
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
==	O
0	int
)	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
;	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"teta_i"	*(char)
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
==	O
0	int
)	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
expr	*(char)
->	O
type	int
==	O
F_REAL	int
)	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"teta_r"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
expr	*(char)
->	O
type	int
==	O
F_INT	int
)	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"teta_i"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
else	O
{	O
error	(*(char))->(void)
(	O
"expression following `step' is not of arithmetic "	*(char)
"type"	*(char)
)	O
;	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"teta_r"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
assert	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
";\n"	*(char)
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
label_count	int
++	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_gamma_%d:\n"	*(char)
,	O
label_count	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
t_ssn	O
)	O
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_UNTIL	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing `until' delimiter"	*(char)
)	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
expr	*(char)
->	O
type	int
==	O
F_INT	int
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
expr	*(char)
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
expr	*(char)
->	O
type	int
==	O
F_REAL	int
||	O
expr	*(char)
->	O
type	int
==	O
F_INT	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"expression following `until' is not of arithmetic"	*(char)
" type"	*(char)
)	O
;	O
expr	*(char)
->	O
type	int
=	O
F_REAL	int
;	O
}	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
get_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
" - ("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")) * (double)("	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")) * ("	*(char)
)	O
;	O
if	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d < 0.0 ? -1 : dsa_%d->%s_%d >"	*(char)
" 0.0 ? +1 : 0"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d < 0 ? -1 : dsa_%d->%s_%d > 0"	*(char)
" ? +1 : 0"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
") > 0.0) "	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
") > 0) "	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"goto _omega_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_global_dsa	*(char)
" = (void *)dsa_%d, _sigma_%d();\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
count	int
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
expr	*(char)
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
expr	*(char)
->	O
lval	int
=	O
0	int
;	O
expr	*(char)
->	O
type	int
=	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"dsa_%d->%s_%d"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
)	O
to_real	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
(	O
teta	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
" + "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
expr	*(char)
,	O
get_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
set_variable	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
expr	*(char)
)	O
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      goto _gamma_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_omega_%d: /* element exhausted */\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_WHILE	int
)	O
)	O
{	O
CODE	struct
*	O
expr	*(char)
;	O
get_token	()->(void)
(	O
)	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
expr	*(char)
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	(*(char))->(void)
(	O
"expression following `while' is not of Boolean ty"	*(char)
"pe"	*(char)
)	O
;	O
expr	*(char)
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (!("	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
")) goto _omega_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_global_dsa	*(char)
" = (void *)dsa_%d, _sigma_%d();\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
count	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      goto _gamma_%d;\n"	*(char)
,	O
label_count	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"_omega_%d:\n"	*(char)
,	O
label_count	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
loop	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_DO	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing `do' delimiter after for list"	*(char)
)	O
;	O
{	O
CODE	struct
*	O
stmt	int
;	O
int	O
ssn	int
=	O
t_ssn	O
;	O
stmt	int
=	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
,	O
t_ssn	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
stmt	int
,	O
"      dsa_%d->new_top_%d = "	*(char)
a_stack_top	*(char)
";\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_DO	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
stmt	int
,	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
stmt	int
,	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
stmt	int
,	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static void _sigma_%d(void)\n"	*(char)
,	O
count	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"{     /* statement following 'do' at line %d */\n"	*(char)
,	O
ssn	int
)	O
;	O
emit_dsa_pointers	()->(void)
(	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
stmt	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      return;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"}\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
procedure_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
IDENT	struct
*	O
proc	*(struct)
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
proc	*(struct)
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"inline"	*(char)
)	O
==	O
0	int
&&	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BLTIN	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
err	O
:	O
{	O
error	(*(char))->(void)
(	O
"invalid use of pseudo procedure `inline'; translatio"	*(char)
"n terminated"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
!=	O
T_STRING	int
)	O
goto	O
err	O
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      /* inline code */\n      "	*(char)
)	O
;	O
{	O
char	O
*	O
p	*(char)
=	O
t_image	O
,	O
*	O
q	*(char)
=	O
t_image	O
+	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
q	*(char)
==	O
'"'	O
)	O
break	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
'\\'	O
)	O
q	*(char)
++	O
;	O
assert	O
(	O
*	O
q	*(char)
)	O
;	O
*	O
p	*(char)
++	O
=	O
*	O
q	*(char)
++	O
;	O
}	O
*	O
p	*(char)
=	O
'\0'	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s\n"	*(char)
,	O
t_image	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_RIGHT	int
)	O
||	O
ext_comma	()->(int)
(	O
)	O
)	O
goto	O
err	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"print"	*(char)
)	O
==	O
0	int
&&	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BLTIN	int
)	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
char	O
*	O
place	*(char)
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of pseudo procedure `print'"	*(char)
)	O
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_print	*(char)
"(???"	*(char)
)	O
;	O
place	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
code	int
->	O
tail	*(struct)
->	O
str	*(char)
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	*(char)
!=	O
NULL	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
CODE	struct
*	O
expr	*(char)
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
}	O
else	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
{	O
expr	*(char)
=	O
actual_parameter	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", 0x%04X, "	*(char)
,	O
F_ARRAY	int
)	O
;	O
}	O
else	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
expr	*(char)
=	O
actual_parameter	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", 0x%04X, "	*(char)
,	O
F_STRING	int
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
expr	*(char)
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
a_make_arg	*(char)
"("	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
"%s"	*(char)
,	O
t_image	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
expr	*(char)
,	O
", NULL)"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", 0x%04X, "	*(char)
,	O
F_STRING	int
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", 0x%04X, "	*(char)
,	O
expr	*(char)
->	O
type	int
)	O
;	O
}	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"\"%s\", "	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"NULL, "	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
count	int
++	O
;	O
if	O
(	O
!	O
ext_comma	()->(int)
(	O
)	O
)	O
break	O
;	O
}	O
assert	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
");\n"	*(char)
)	O
;	O
assert	O
(	O
count	int
<=	O
255	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
place	*(char)
,	O
"%3d"	*(char)
,	O
count	int
)	O
;	O
}	O
else	O
{	O
code	int
=	O
function_designator	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
1	int
)	O
;	O
prepend	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
";\n"	*(char)
)	O
;	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
int	O
is_declaration	()->(int)
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
block_or_compound_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
{	O
code	int
=	O
block_or_compound_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_ASSIGN	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_BEGSUB	int
)	O
)	O
{	O
code	int
=	O
assignment_statement	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_GOTO	int
)	O
)	O
{	O
code	int
=	O
go_to_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
code	int
=	O
dummy_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_IF	int
)	O
)	O
{	O
code	int
=	O
conditional_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
{	O
code	int
=	O
for_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_LEFT	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_ELSE	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_END	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
)	O
)	O
{	O
code	int
=	O
procedure_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
error	(*(char))->(void)
(	O
"unexpected eof"	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
error	(*(char))->(void)
(	O
"invalid use of identifier `%s'"	*(char)
,	O
t_image	O
)	O
;	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
||	O
t_code	O
==	O
T_REAL	int
||	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
error	(*(char))->(void)
(	O
"invalid use of constant `%s'"	*(char)
,	O
t_image	O
)	O
;	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
error	(*(char))->(void)
(	O
"invalid use of string"	*(char)
)	O
;	O
else	O
if	O
(	O
is_declaration	()->(int)
(	O
)	O
)	O
error	(*(char))->(void)
(	O
"declarator `%s' in invalid position"	*(char)
,	O
t_image	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"invalid use of delimiter `%s'"	*(char)
,	O
t_image	O
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon, `else', or `end' after statement"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
int	O
has_labels	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
assert	O
(	O
second_pass	int
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
!=	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
IDENT	struct
*	O
proc	*(struct)
,	O
int	O
ssn	int
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
first_pass	int
)	O
{	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
my_malloc	(int)->(*(void))
(	O
sizeof	O
(	O
BLOCK	struct
)	O
)	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
=	O
(	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
?	O
0	int
:	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
+	O
1	int
)	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
ssn	int
=	O
ssn	int
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
proc	*(struct)
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
last	*(struct)
=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
else	O
{	O
if	O
(	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
assert	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      /* start of %s block %d (level %d) at line"	*(char)
" %d */\n"	*(char)
,	O
proc	*(struct)
!=	O
NULL	O
?	O
"procedure"	*(char)
:	O
"local"	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
ssn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->old_top_%d = "	*(char)
a_stack_top	*(char)
";\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
if	O
(	O
has_labels	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      /* jmp_buf must be of array type (ISO) "	*(char)
"*/\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      switch (setjmp(&dsa_%d->jump_%d[0]))\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      {  case 0: break;\n"	*(char)
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
!=	O
0	int
)	O
)	O
continue	O
;	O
assert	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
>	O
0	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"         case %d: "	*(char)
a_pop_stack	*(char)
"(dsa_%d->"	*(char)
"new_top_%d); "	*(char)
a_active_dsa	*(char)
" = (struct dsa *)dsa_%d"	*(char)
"; goto %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
current_level	()->(int)
(	O
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"         default: "	*(char)
a_fault	*(char)
"(\"internal erro"	*(char)
"r on global go to\");\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      }\n"	*(char)
)	O
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
old	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
assert	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_pop_stack	*(char)
"(dsa_%d->old_top_%d);\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      /* end of block %d */\n"	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
first_pass	int
&&	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
IDENT	struct
*	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
*	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
old	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
while	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
0	int
)	O
{	O
if	O
(	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
==	O
NULL	O
)	O
old	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
else	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
old	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
last	*(struct)
==	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
old	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
last	*(struct)
=	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
0	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
)	O
;	O
if	O
(	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
<	O
0	int
)	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
;	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
my_free	(*(void))->(void)
(	O
it	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
}	O
else	O
pred	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
int	O
is_declaration	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_OWN	int
)	O
||	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
||	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
declaration	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
block_or_compound_statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
int	O
is_block	int
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
is_block	int
=	O
is_declaration	()->(int)
(	O
)	O
;	O
if	O
(	O
is_block	int
)	O
{	O
code	int
=	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
,	O
t_ssn	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
is_declaration	()->(int)
(	O
)	O
)	O
break	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
declaration	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	*(char)
a_stack_top	*(char)
";\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
}	O
else	O
{	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing `end' bracket"	*(char)
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid use of delimiter `else' outside if statement"	*(char)
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_END	int
)	O
)	O
break	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
}	O
if	O
(	O
is_block	int
)	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_END	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
void	O
type_declaration	(int)->(void)
(	O
int	O
flags	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing simple variable identifier"	*(char)
)	O
;	O
break	O
;	O
}	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
{	O
if	O
(	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static double %s_%d = 0.0;\n\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_INT	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static int %s_%d = 0;\n\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_BOOL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static bool %s_%d = false;\n\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
assert	O
(	O
flags	int
!=	O
flags	int
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after type declaration"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
CODE	struct
*	O
own_bound	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
,	O
*	O
expr	*(char)
;	O
if	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"+"	*(char)
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"-"	*(char)
)	O
,	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_INT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
t_code	O
==	O
T_INT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_ENDSUB	int
)	O
)	O
)	O
error	(*(char))->(void)
(	O
"invalid bound expression for own array"	*(char)
)	O
;	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
code	int
->	O
type	int
=	O
expr	*(char)
->	O
type	int
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
expr	*(char)
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
array_declaration	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
int	O
flags	int
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
1	int
+	O
100	int
]	O
;	O
int	O
n	int
,	O
dim	int
;	O
char	O
*	O
place	*(char)
;	O
array_decl_flag	int
=	O
1	int
;	O
loop	O
:	O
for	O
(	O
n	int
=	O
1	int
;	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing array identifier"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
if	O
(	O
n	int
>	O
100	int
)	O
{	O
error	(*(char))->(void)
(	O
"too many identifiers in array segment"	*(char)
)	O
;	O
n	int
=	O
1	int
;	O
}	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
flags	int
=	O
flags	int
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static struct dv *%s_%d = NULL;\n\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing left parenthesis after array segment"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
ssn_decl	int
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (%s_%d == NULL) %s_%d = "	*(char)
a_own_array	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	*(char)
a_alloc_array	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"('%s', ?, "	*(char)
,	O
(	O
flags	int
&	O
F_REAL	int
)	O
?	O
"r"	*(char)
:	O
(	O
flags	int
&	O
F_INT	int
)	O
?	O
"i"	*(char)
:	O
"b"	*(char)
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
place	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
code	int
->	O
tail	*(struct)
->	O
str	*(char)
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	*(char)
!=	O
NULL	O
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
dim	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
dim	int
==	O
9	int
)	O
{	O
error	(*(char))->(void)
(	O
"array dimension exceeds allowable maximum"	*(char)
)	O
;	O
dim	int
=	O
0	int
;	O
}	O
dim	int
++	O
;	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
flags	int
&	O
F_OWN	int
?	O
own_bound	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
:	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"bound expression is not of arithmetic type"	*(char)
)	O
;	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
", "	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_COLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing colon between bound expressions"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
flags	int
&	O
F_OWN	int
?	O
own_bound	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
:	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
==	O
F_REAL	int
)	O
to_int	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
if	O
(	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	(*(char))->(void)
(	O
"bound expression is not of arithmetic type"	*(char)
)	O
;	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
bound	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
t_delim	O
(	O
S_COMMA	int
)	O
?	O
", "	*(char)
:	O
");\n"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing right parenthesis after bound list"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
{	O
int	O
k	int
;	O
assert	O
(	O
1	int
<=	O
dim	int
&&	O
dim	int
<=	O
9	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
n	int
;	O
k	int
++	O
)	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
k	int
]	O
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
)	O
*	O
place	*(char)
=	O
(	O
char	O
)	O
(	O
dim	int
+	O
'0'	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
--	O
n	int
<	O
1	int
)	O
break	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
ssn_decl	int
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      if (%s_%d == NULL) %s_%d = "	*(char)
a_own_same	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	*(char)
a_alloc_same	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"('%s', "	*(char)
,	O
(	O
flags	int
&	O
F_REAL	int
)	O
?	O
"r"	*(char)
:	O
(	O
flags	int
&	O
F_INT	int
)	O
?	O
"i"	*(char)
:	O
"b"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"%s_%d);\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
+	O
1	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
+	O
1	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"dsa_%d->%s_%d);\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
+	O
1	int
]	O
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
[	O
n	int
+	O
1	int
]	O
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
goto	O
loop	O
;	O
}	O
array_decl_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after array declaration"	*(char)
)	O
;	O
skip	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
void	O
switch_declaration	()->(void)
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
int	O
dim	int
;	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing switch identifier"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_SWITCH	int
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing `:=' after switch identifier"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static struct label %s_%d(int kase)\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"{     /* switch declaration at line %d */\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
emit_dsa_pointers	()->(void)
(	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
emit_ssn	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      switch (kase)\n"	*(char)
)	O
;	O
dim	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
expr	*(char)
=	O
expression	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
second_pass	int
&&	O
expr	*(char)
->	O
type	int
!=	O
F_LABEL	int
)	O
{	O
error	(*(char))->(void)
(	O
"expression in switch list is not of label type"	*(char)
)	O
;	O
expr	*(char)
->	O
type	int
=	O
F_LABEL	int
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      %s  case %d: dsa_%d->line = %d; return "	*(char)
,	O
dim	int
==	O
1	int
?	O
"{"	*(char)
:	O
" "	*(char)
,	O
dim	int
,	O
current_level	()->(int)
(	O
)	O
,	O
t_ssn	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
expr	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
";\n"	*(char)
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"         default: "	*(char)
a_fault	*(char)
"(\"switch designator u"	*(char)
"ndefined\");\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      }\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      return "	*(char)
a_make_label	*(char)
"(NULL, 0);\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"}\n\n"	*(char)
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after switch declaration"	*(char)
)	O
;	O
skip	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_proc_head	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(void)
(	O
IDENT	struct
*	O
proc	*(struct)
,	O
int	O
flag	int
)	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
if	O
(	O
first_pass	int
)	O
goto	O
skip	O
;	O
if	O
(	O
(	O
proc	*(struct)
->	O
flags	int
&	O
F_BLTIN	int
)	O
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"inline"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"print"	*(char)
)	O
==	O
0	int
)	O
)	O
goto	O
skip	O
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
proc	*(struct)
)	O
break	O
;	O
assert	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
flag	int
)	O
{	O
if	O
(	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
==	O
0	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"extern "	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static "	*(char)
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"struct desc %s_%d"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
proc	*(struct)
->	O
name	*(char)
,	O
"main_program"	*(char)
)	O
==	O
0	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" /* program */"	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" /* %s %s procedure */"	*(char)
,	O
proc	*(struct)
->	O
flags	int
&	O
F_CODE	int
?	O
"code"	*(char)
:	O
proc	*(struct)
->	O
flags	int
&	O
F_BLTIN	int
?	O
"builtin"	*(char)
:	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
==	O
0	int
?	O
"precompiled"	*(char)
:	O
"local"	*(char)
,	O
proc	*(struct)
->	O
flags	int
&	O
F_REAL	int
?	O
"real"	*(char)
:	O
proc	*(struct)
->	O
flags	int
&	O
F_INT	int
?	O
"integer"	*(char)
:	O
proc	*(struct)
->	O
flags	int
&	O
F_BOOL	int
?	O
"Boolean"	*(char)
:	O
"void"	*(char)
)	O
;	O
if	O
(	O
proc	*(struct)
->	O
dim	int
==	O
0	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" (void)"	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"%s     struct arg "	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
==	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
?	O
"("	*(char)
:	O
" "	*(char)
)	O
;	O
if	O
(	O
flag	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* %s:"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"%s_%d /*"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYVAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" by value"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" by name"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" real"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" integer"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BOOL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" Boolean"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_LABEL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" label"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" array"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" switch"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_PROC	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" procedure"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_STRING	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" string"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" */%s"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
==	O
NULL	O
?	O
"\n)"	*(char)
:	O
",\n"	*(char)
)	O
;	O
}	O
done	O
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
flag	int
?	O
";\n\n"	*(char)
:	O
"\n"	*(char)
)	O
;	O
skip	O
:	O
return	O
;	O
}	O
static	O
void	O
procedure_declaration	(int)->(void)
(	O
int	O
flags	int
)	O
{	O
CODE	struct
*	O
code	int
,	O
*	O
prolog	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
;	O
IDENT	struct
*	O
proc	*(struct)
;	O
int	O
is_main	int
;	O
int	O
dim	int
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
delim	int
==	O
S_PROCEDURE	int
)	O
{	O
is_main	int
=	O
0	int
;	O
}	O
else	O
{	O
is_main	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
is_main	int
)	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
proc	*(struct)
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
char	O
str	*(char)
[	O
50	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"p_%d"	*(char)
,	O
t_ssn	O
)	O
;	O
error	(*(char))->(void)
(	O
"missing procedure identifier after `procedure'; dumm"	*(char)
"y identifier `%s' used"	*(char)
,	O
str	*(char)
)	O
;	O
proc	*(struct)
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
str	*(char)
,	O
1	int
,	O
t_ssn	O
)	O
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
==	O
0	int
)	O
;	O
proc	*(struct)
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"main_program"	*(char)
,	O
1	int
,	O
t_ssn	O
)	O
;	O
}	O
proc	*(struct)
->	O
flags	int
=	O
flags	int
;	O
prolog	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
proc	*(struct)
,	O
t_ssn	O
)	O
;	O
dim	int
=	O
0	int
;	O
if	O
(	O
is_main	int
)	O
goto	O
skip	O
;	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing formal parameter identifier"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
error	(*(char))->(void)
(	O
"formal parameter `%s' repeated in formal param"	*(char)
"eter list"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_BYNAME	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
==	O
0	int
)	O
error	(*(char))->(void)
(	O
"formal parameter identifier `%s' is the same a"	*(char)
"s procedure identifier"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
dim	int
++	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
ext_comma	()->(int)
(	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"missing right parenthesis after formal parameter lis"	*(char)
"t"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after formal parameter part"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_VALUE	int
)	O
)	O
valp	O
:	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing formal parameter identifier"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
error	(*(char))->(void)
(	O
"identifier `%s' missing from formal parameter "	*(char)
"list"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYVAL	int
)	O
error	(*(char))->(void)
(	O
"formal parameter `%s' repeated in value part"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_BYVAL	int
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after value part"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_LABEL	int
)	O
||	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
||	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_STRING	int
)	O
||	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
{	O
int	O
flags	int
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
{	O
flags	int
=	O
t_delim	O
(	O
S_REAL	int
)	O
?	O
F_REAL	int
:	O
t_delim	O
(	O
S_INTEGER	int
)	O
?	O
F_INT	int
:	O
F_BOOL	int
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_LABEL	int
)	O
)	O
flags	int
=	O
F_LABEL	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
=	O
F_REAL	int
|	O
F_ARRAY	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
flags	int
=	O
F_SWITCH	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
=	O
F_PROC	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_STRING	int
)	O
)	O
flags	int
=	O
F_STRING	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing formal parameter identifier"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
error	(*(char))->(void)
(	O
"identifier `%s' missing from formal parameter "	*(char)
"list"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
~	O
(	O
F_BYNAME	int
|	O
F_BYVAL	int
)	O
)	O
error	(*(char))->(void)
(	O
"formal parameter `%s' multiply specified"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
|=	O
flags	int
;	O
if	O
(	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYVAL	int
)	O
&&	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_SWITCH	int
|	O
F_PROC	int
|	O
F_STRING	int
)	O
)	O
)	O
error	(*(char))->(void)
(	O
"invalid call by value of switch, procedure, or"	*(char)
" string `%s'"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after specification"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_VALUE	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"specification part precedes value part"	*(char)
)	O
;	O
goto	O
valp	O
;	O
}	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
int	O
ok	int
=	O
1	int
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
~	O
(	O
F_BYNAME	int
|	O
F_BYVAL	int
)	O
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"formal parameter `%s' not specified"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
ok	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
ok	int
)	O
error	(*(char))->(void)
(	O
"specification part of procedure `%s' incomplete"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
}	O
skip	O
:	O
proc	*(struct)
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
t_delim	O
(	O
S_CODE	int
)	O
)	O
{	O
assert	O
(	O
!	O
is_main	int
)	O
;	O
if	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
!=	O
0	int
)	O
error	(*(char))->(void)
(	O
"invalid declaration of code procedure inside block"	*(char)
)	O
;	O
proc	*(struct)
->	O
flags	int
|=	O
F_CODE	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
prolog	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after 'code'"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
goto	O
done	O
;	O
}	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"{     struct dsa_%s_%d my_dsa;\n"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
{	O
int	O
level	int
=	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
+	O
1	int
;	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
NULL	O
)	O
continue	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      register struct dsa_%s_%d *dsa_%d = "	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
name	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
level	int
)	O
;	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
proc	*(struct)
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"&my_dsa;\n"	*(char)
)	O
;	O
else	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"(void *)"	*(char)
a_global_dsa	*(char)
"->vector[%d];\n"	*(char)
,	O
level	int
)	O
;	O
level	int
--	O
;	O
}	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.proc = \"%s\";\n"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
)	O
;	O
{	O
char	O
str	*(char)
[	O
100	int
+	O
10	int
]	O
,	O
*	O
t	*(char)
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
,	O
t	*(char)
=	O
infilename	*(char)
;	O
k	int
<	O
100	int
&&	O
*	O
t	*(char)
;	O
t	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
t	*(char)
==	O
'\\'	O
||	O
*	O
t	*(char)
==	O
'\"'	O
)	O
str	*(char)
[	O
k	int
++	O
]	O
=	O
'\\'	O
;	O
str	*(char)
[	O
k	int
++	O
]	O
=	O
*	O
t	*(char)
;	O
}	O
str	*(char)
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
t	*(char)
)	O
strcat	(*(char),*(char))->(*(char))
(	O
str	*(char)
,	O
"..."	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.file = \"%s\";\n"	*(char)
,	O
str	*(char)
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	*(char)
,	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.parent = "	*(char)
a_active_dsa	*(char)
", "	*(char)
a_active_dsa	*(char)
" = (struct dsa *)&my_dsa;\n"	*(char)
)	O
;	O
{	O
int	O
level	int
=	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
+	O
1	int
,	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
level	int
;	O
k	int
++	O
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.vector[%d] = (void *)dsa_%d;\n"	*(char)
,	O
k	int
,	O
k	int
)	O
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
prolog	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.%s_%d = %s(("	*(char)
a_global_dsa	*(char)
" = %s_%d.arg2, (*(struct desc (*)(void))%s_%d.arg"	*(char)
"1)()));\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
"get_real"	*(char)
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
?	O
"get_int"	*(char)
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
"get_bool"	*(char)
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_LABEL	int
)	O
?	O
"get_label"	*(char)
:	O
"???"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.%s_%d = %s(%s_%d);\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
a_copy_real	*(char)
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
?	O
a_copy_int	*(char)
:	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
a_copy_bool	*(char)
:	O
"???"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
case	O
F_SWITCH	int
|	O
F_BYNAME	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_PROC	int
|	O
F_BYNAME	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.%s_%d = %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_STRING	int
|	O
F_BYNAME	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.%s_%d = %s_%d.arg1;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
!=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
;	O
}	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	*(char)
a_stack_top	*(char)
";\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
}	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
,	O
t_ssn	O
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	*(char)
a_stack_top	*(char)
";\n"	*(char)
,	O
current_level	()->(int)
(	O
)	O
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
label_list	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
is_main	int
&&	O
!	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
error	(*(char))->(void)
(	O
"missing bracket 'begin'"	*(char)
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
statement	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
code	int
,	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.retval.lval = 0;\n"	*(char)
)	O
;	O
switch	O
(	O
proc	*(struct)
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
{	O
case	O
F_REAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.retval.type = 'r';\n"	*(char)
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.retval.type = 'i';\n"	*(char)
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.retval.type = 'b';\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      my_dsa.retval.type = 0;\n"	*(char)
)	O
;	O
break	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      "	*(char)
a_active_dsa	*(char)
" = my_dsa.parent;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"      return my_dsa.retval;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
code	int
,	O
"}\n\n"	*(char)
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
emit_proc_head	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(void)
(	O
proc	*(struct)
,	O
0	int
)	O
;	O
catenate	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
code	int
)	O
;	O
}	O
if	O
(	O
!	O
is_main	int
&&	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"missing semicolon after procedure declaration"	*(char)
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
is_main	int
&&	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
warning	(*(char))->(void)
(	O
"semicolon found after program"	*(char)
)	O
;	O
done	O
:	O
return	O
;	O
}	O
static	O
CODE	struct
*	O
declaration	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
int	O
flags	int
;	O
assert	O
(	O
is_declaration	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
{	O
flags	int
=	O
t_delim	O
(	O
S_REAL	int
)	O
?	O
F_REAL	int
:	O
t_delim	O
(	O
S_INTEGER	int
)	O
?	O
F_INT	int
:	O
F_BOOL	int
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
=	O
F_REAL	int
|	O
F_ARRAY	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_OWN	int
)	O
)	O
{	O
flags	int
=	O
F_OWN	int
,	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
)	O
flags	int
|=	O
F_REAL	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_INTEGER	int
)	O
)	O
flags	int
|=	O
F_INT	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
flags	int
|=	O
F_BOOL	int
,	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
{	O
if	O
(	O
flags	int
==	O
F_OWN	int
)	O
flags	int
|=	O
F_REAL	int
;	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
flags	int
==	O
F_OWN	int
)	O
{	O
error	(*(char))->(void)
(	O
"missing declarator after 'own'"	*(char)
)	O
;	O
flags	int
|=	O
F_REAL	int
;	O
}	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
flags	int
=	O
F_SWITCH	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
=	O
F_PROC	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
if	O
(	O
flags	int
&	O
F_ARRAY	int
)	O
code	int
=	O
array_declaration	(int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
flags	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_SWITCH	int
)	O
switch_declaration	()->(void)
(	O
)	O
,	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_PROC	int
)	O
procedure_declaration	(int)->(void)
(	O
flags	int
)	O
,	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
else	O
type_declaration	(int)->(void)
(	O
flags	int
)	O
,	O
code	int
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
void	O
resolving	()->(void)
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
*	O
arg	array(struct(int,int,*(void),*(void)))
;	O
assert	O
(	O
first_pass	int
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"abs"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"iabs"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"sign"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"entier"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"sqrt"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"sin"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"cos"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"arctan"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"ln"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"exp"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"E"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"stop"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"fault"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"str"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"r"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"inchar"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
3	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"str"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"int"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"outchar"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
3	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"str"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"int"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"length"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"str"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"outstring"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"str"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"outterminator"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"ininteger"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"int"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"outinteger"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"int"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"inreal"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"re"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"outreal"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
2	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"channel"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"re"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"maxreal"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"minreal"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"maxint"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"epsilon"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"inline"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
1	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
arg	array(struct(int,int,*(void),*(void)))
=	O
look_up	(*(char),int,int)->(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))
(	O
"statement"	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_decl	int
=	O
arg	array(struct(int,int,*(void),*(void)))
->	O
ssn_used	int
=	O
1	int
;	O
arg	array(struct(int,int,*(void),*(void)))
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
warning	(*(char))->(void)
(	O
"pseudo procedure `inline' used"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
"print"	*(char)
)	O
==	O
0	int
)	O
{	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
=	O
0	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
,	O
1	int
)	O
)	O
;	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
warning	(*(char))->(void)
(	O
"pseudo procedure `print' used"	*(char)
)	O
;	O
}	O
else	O
error	(*(char))->(void)
(	O
"identifier `%s' not declared (see line %d)"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
entire_module	()->(int)
(	O
void	O
)	O
{	O
int	O
is_main	int
=	O
0	int
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
enter_block	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
NULL	O
,	O
0	int
)	O
)	O
;	O
l_count	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
line	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
l_maxlen	int
+	O
1	int
)	O
;	O
line	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
read_line	()->(int)
(	O
)	O
;	O
pos	int
=	O
0	int
;	O
symbol	int
=	O
S_EOF	int
;	O
s_char	int
=	O
'?'	O
;	O
scan_symbol	()->(void)
(	O
)	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
image	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
0	int
]	O
.	O
image	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
image	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
image	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
image	*(char)
=	O
my_malloc	(int)->(*(void))
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
image	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
1	int
]	O
.	O
delim	int
==	O
S_EOF	int
)	O
{	O
error	(*(char))->(void)
(	O
"null program not allowed"	*(char)
)	O
;	O
goto	O
skip	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
flags	int
;	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
break	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
||	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array(struct(int,int,int,int,*(char)))
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
if	O
(	O
is_main	int
)	O
error	(*(char))->(void)
(	O
"only one program allowed"	*(char)
)	O
;	O
is_main	int
=	O
1	int
,	O
flags	int
=	O
F_PROC	int
;	O
}	O
else	O
{	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
)	O
flags	int
=	O
F_REAL	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_INTEGER	int
)	O
)	O
flags	int
=	O
F_INT	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
flags	int
=	O
F_BOOL	int
,	O
get_token	()->(void)
(	O
)	O
;	O
else	O
flags	int
=	O
0	int
;	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
F_PROC	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"invalid start of program or precompiled procedure"	*(char)
)	O
;	O
err	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
continue	O
;	O
}	O
procedure_declaration	(int)->(void)
(	O
flags	int
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
!	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
{	O
error	(*(char))->(void)
(	O
"equal number of 'begin' and 'end' brackets found"	*(char)
)	O
;	O
goto	O
err	O
;	O
}	O
}	O
skip	O
:	O
if	O
(	O
first_pass	int
)	O
resolving	()->(void)
(	O
)	O
;	O
free_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
leave_block	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
)	O
;	O
assert	O
(	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
;	O
return	O
is_main	int
;	O
}	O
static	O
BLOCK	struct
*	O
proc_block	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))
(	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
for	O
(	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
surr	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
break	O
;	O
return	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
void	O
emit_decl_code	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(void)
(	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
{	O
int	O
seqn	int
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
;	O
switch	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      double %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      int %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      bool %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct label %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct dv *%s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
case	O
F_SWITCH	int
|	O
F_BYNAME	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_PROC	int
|	O
F_BYNAME	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct arg %s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_STRING	int
|	O
F_BYNAME	int
:	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      char *%s_%d;\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_LABEL	int
:	O
case	O
F_SWITCH	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
:	O
case	O
F_PROC	int
:	O
break	O
;	O
default	O
:	O
assert	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
!=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_dsa_code	()->(void)
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
IDENT	struct
*	O
proc	*(struct)
;	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
proc	*(struct)
=	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
;	O
if	O
(	O
proc	*(struct)
==	O
NULL	O
||	O
(	O
proc	*(struct)
->	O
flags	int
&	O
(	O
F_CODE	int
|	O
F_BLTIN	int
)	O
)	O
)	O
continue	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"struct dsa_%s_%d\n"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
,	O
proc	*(struct)
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"{     /* procedure %s (level %d) declared at line %d */\n"	*(char)
,	O
proc	*(struct)
->	O
name	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
+	O
1	int
,	O
proc	*(struct)
->	O
ssn_decl	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      char *proc;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      char *file;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      int line;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct dsa *parent;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct dsa *vector[%d+1];\n"	*(char)
,	O
dsa_level	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(int)
(	O
proc	*(struct)
)	O
+	O
1	int
)	O
;	O
{	O
int	O
maxlev	int
=	O
0	int
,	O
k	int
,	O
need	int
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
proc_block	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
==	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
maxlev	int
<	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
maxlev	int
=	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      /* level of innermost block = %d */\n"	*(char)
,	O
maxlev	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
maxlev	int
;	O
k	int
++	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct mem *old_top_%d;\n"	*(char)
,	O
k	int
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct mem *new_top_%d;\n"	*(char)
,	O
k	int
)	O
;	O
need	int
=	O
0	int
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
proc_block	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
==	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
==	O
k	int
&&	O
has_labels	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
need	int
=	O
1	int
;	O
}	O
if	O
(	O
need	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      jmp_buf jump_%d;\n"	*(char)
,	O
k	int
)	O
;	O
}	O
}	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
int	O
count	int
=	O
0	int
;	O
if	O
(	O
proc_block	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
!=	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
continue	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      /* %s block %d (level %d) beginning at "	*(char)
"line %d */\n"	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
?	O
"procedure"	*(char)
:	O
"local"	*(char)
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
,	O
block_level	(*(struct(int,int,*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(int,int,*`,*`,*`,*`,*`)))))->(int)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
ssn	int
)	O
;	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
{	O
assert	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
==	O
proc	*(struct)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      struct desc retval;\n"	*(char)
)	O
;	O
}	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      /* %s:"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_OWN	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" own"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYVAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" by value"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BYNAME	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" by name"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_REAL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" real"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_INT	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" integer"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_BOOL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" Boolean"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_LABEL	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" label"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_ARRAY	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" array"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_SWITCH	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" switch"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_PROC	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" procedure"	*(char)
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
F_STRING	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
" string"	*(char)
)	O
;	O
assert	O
(	O
!	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_CODE	int
|	O
F_BLTIN	int
)	O
)	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n         %s at line %d and "	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
&	O
(	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
?	O
"specified"	*(char)
:	O
"declared"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_decl	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
==	O
0	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"never referenced */\n"	*(char)
)	O
;	O
else	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"first referenced at line %d */\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
ssn_used	int
)	O
;	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
F_LABEL	int
)	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
dim	int
=	O
++	O
count	int
;	O
}	O
emit_decl_code	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))))->(void)
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
)	O
;	O
}	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"};\n\n"	*(char)
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_startup_code	()->(void)
(	O
void	O
)	O
{	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"int main(void)\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"{     /* Algol program startup code */\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      main_program_0();\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"      return 0;\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"}\n\n"	*(char)
)	O
;	O
return	O
;	O
}	O
static	O
CSQE	struct
*	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
static	O
int	O
sqe_pos	int
;	O
static	O
int	O
get_code_char	()->(int)
(	O
void	O
)	O
{	O
int	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
str	*(char)
[	O
sqe_pos	int
++	O
]	O
;	O
if	O
(	O
c	int
!=	O
'\0'	O
)	O
break	O
;	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
if	O
(	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
==	O
NULL	O
)	O
{	O
c	int
=	O
0x1A	int
;	O
break	O
;	O
}	O
sqe_pos	int
=	O
0	int
;	O
}	O
return	O
c	int
;	O
}	O
static	O
void	O
output_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
CODE	struct
*	O
code	int
)	O
{	O
int	O
size	int
;	O
int	O
len	int
;	O
char	O
str	*(char)
[	O
255	int
+	O
1	int
]	O
;	O
int	O
c	int
;	O
assert	O
(	O
50	int
<=	O
width	int
&&	O
width	int
<=	O
255	int
)	O
;	O
sqe_ptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
code	int
->	O
head	*(struct)
;	O
sqe_pos	int
=	O
0	int
;	O
size	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
len	int
=	O
0	int
,	O
str	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
get_code_char	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
0x1A	int
)	O
break	O
;	O
assert	O
(	O
len	int
<	O
sizeof	O
(	O
str	*(char)
)	O
-	O
1	int
)	O
;	O
str	*(char)
[	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
,	O
str	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
' '	O
||	O
c	int
==	O
'('	O
||	O
c	int
==	O
')'	O
||	O
c	int
==	O
':'	O
||	O
c	int
==	O
','	O
||	O
c	int
==	O
';'	O
||	O
c	int
==	O
'"'	O
)	O
break	O
;	O
}	O
if	O
(	O
size	int
+	O
len	int
+	O
(	O
c	int
==	O
'\n'	O
?	O
-	O
1	int
:	O
c	int
==	O
'"'	O
?	O
6	int
:	O
0	int
)	O
>	O
width	int
)	O
{	O
if	O
(	O
size	int
>	O
0	int
)	O
{	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"         "	*(char)
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
size	int
=	O
9	int
;	O
}	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
str	*(char)
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
size	int
=	O
0	int
;	O
else	O
size	int
+=	O
len	int
;	O
if	O
(	O
c	int
==	O
0x1A	int
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'"'	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
oldc	int
=	O
c	int
;	O
c	int
=	O
get_code_char	()->(int)
(	O
)	O
;	O
assert	O
(	O
c	int
!=	O
0x1A	int
)	O
;	O
if	O
(	O
size	int
+	O
2	int
>	O
width	int
&&	O
oldc	int
!=	O
'\\'	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\"\n         \""	*(char)
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
size	int
=	O
10	int
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
size	int
++	O
;	O
if	O
(	O
oldc	int
!=	O
'\\'	O
&&	O
c	int
==	O
'"'	O
)	O
break	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
display_help	(*(char))->(void)
(	O
char	O
*	O
my_name	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"Usage: %s [options...] [filename]\n"	*(char)
,	O
my_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Options:\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -d, --debug          run translator in debug mode\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -e nnn, --errormax nnn\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                        maximal error allowance (0 <= nnn"	*(char)
" <= 255);\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                        default: -e 0 (continue translati"	*(char)
"on in any case)\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -h, --help           display this help information and"	*(char)
" exit(0)\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -l nnn, --linewidth nnn\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                        desirable output line width (50 <"	*(char)
"= nnn <= 255);\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                        default: -l 72\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -o filename, --output filename\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                        send output C code to filename\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -t, --notimestamp    suppress time stamp in output C c"	*(char)
"ode\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -v, --version        display translator version and ex"	*(char)
"it(0)\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"   -w, --nowarn         suppress all warning messages\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"N.B.  The translator reads input file TWICE, therefore th"	*(char)
"is file should\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"      be assigned to regular file (but not to terminal, p"	*(char)
"ipe, etc.)\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Please, report bugs to <bug-marst@gnu.org>\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
display_version	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"                                 Was sich ueberhaupt sage"	*(char)
"n laesst, laesst\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                                 sich klar sagen; und wov"	*(char)
"on man nicht reden\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                                 kann, darueber muss man "	*(char)
"schweigen.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"                                                         "	*(char)
"Ludwig Wittgenstein\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
version	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Copyright (C) 2000, 2001, 2002, 2007, 2013 Free Software "	*(char)
"Foundation, Inc.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"This program is free software; you may redistribute it un"	*(char)
"der the terms of\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"the GNU General Public License. This program has absolute"	*(char)
"ly no warranty.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
process_cmdline	(int,array(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
argc	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-d"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--debug"	*(char)
)	O
==	O
0	int
)	O
debug	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-e"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--errormax"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
endptr	*(char)
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No error count specified\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
errmax	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
&	O
endptr	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
endptr	*(char)
==	O
'\0'	O
&&	O
0	int
<=	O
errmax	int
&&	O
errmax	int
<=	O
255	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid error count `%s'"	*(char)
,	O
argv	array(*(char))
[	O
k	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-h"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--help"	*(char)
)	O
==	O
0	int
)	O
display_help	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-l"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--linewidth"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
endptr	*(char)
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No line width specified\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
width	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
&	O
endptr	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
endptr	*(char)
==	O
'\0'	O
&&	O
50	int
<=	O
width	int
&&	O
width	int
<=	O
255	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid line width `%s'"	*(char)
,	O
argv	array(*(char))
[	O
k	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-o"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--output"	*(char)
)	O
==	O
0	int
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No output file name specified\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
outfilename	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Only one output file allowed\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
outfilename	*(char)
=	O
argv	array(*(char))
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-t"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--notimestamp"	*(char)
)	O
==	O
0	int
)	O
time_stamp	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-v"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--version"	*(char)
)	O
==	O
0	int
)	O
display_version	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"-w"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	array(*(char))
[	O
k	int
]	O
,	O
"--nowarn"	*(char)
)	O
==	O
0	int
)	O
warn	int
=	O
0	int
;	O
else	O
if	O
(	O
argv	array(*(char))
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
||	O
(	O
argv	array(*(char))
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
argv	array(*(char))
[	O
k	int
]	O
[	O
1	int
]	O
==	O
'-'	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid option `%s'; try %s --help\n"	*(char)
,	O
argv	array(*(char))
[	O
k	int
]	O
,	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
infilename	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Only one input file allowed\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
infilename	*(char)
=	O
argv	array(*(char))
[	O
k	int
]	O
;	O
}	O
}	O
return	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
process_cmdline	(int,array(*(char)))->(void)
(	O
argc	int
,	O
argv	array(*(char))
)	O
;	O
if	O
(	O
infilename	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
infilename	*(char)
=	O
"(stdin)"	*(char)
;	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
{	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
infilename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unable to open input file `%s' - %s\n"	*(char)
,	O
infilename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
outfilename	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
outfilename	*(char)
=	O
"(stdout)"	*(char)
;	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
{	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outfilename	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unable to open output file `%s' - %s\n"	*(char)
,	O
outfilename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
first_pass	int
=	O
1	int
,	O
second_pass	int
=	O
0	int
;	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
current	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#if 0 /* start of translator debug output */"	*(char)
"\n\n"	*(char)
)	O
;	O
entire_module	()->(int)
(	O
)	O
;	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n#endif /* end of translator debug output */\n\n"	*(char)
)	O
;	O
if	O
(	O
e_count	int
)	O
{	O
if	O
(	O
e_count	int
==	O
1	int
)	O
error	(*(char))->(void)
(	O
"one error detected on the first pass; translation te"	*(char)
"rminated"	*(char)
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"%d errors detected on the first pass; translation te"	*(char)
"rminated"	*(char)
,	O
e_count	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
first_pass	int
=	O
0	int
,	O
second_pass	int
=	O
1	int
;	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
=	O
new_code	()->(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))
(	O
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* %s */\n"	*(char)
,	O
outfilename	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* generated by GNU %s */\n"	*(char)
,	O
version	*(char)
)	O
;	O
if	O
(	O
time_stamp	int
)	O
{	O
time_t	long
zeit	long
=	O
time	(*(long))->(long)
(	O
NULL	O
)	O
;	O
char	O
stamp	array(char)
[	O
25	int
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
stamp	array(char)
,	O
ctime	(*(long))->(*(char))
(	O
&	O
zeit	long
)	O
,	O
24	int
)	O
;	O
stamp	array(char)
[	O
24	int
]	O
=	O
'\0'	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* %s */\n"	*(char)
,	O
stamp	array(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* source file: %s */\n"	*(char)
,	O
infilename	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* object file: %s */\n"	*(char)
,	O
outfilename	*(char)
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"#include \"algol.h\"\n"	*(char)
)	O
;	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"\n"	*(char)
)	O
;	O
{	O
BLOCK	struct
*	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
first_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
IDENT	struct
*	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
;	O
if	O
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
!=	O
NULL	O
)	O
emit_proc_head	(*(struct(*(char),int,int,int,int,*(struct(int,int,*`,*`,*`,*`,*`)),*(struct(*`,int,int,int,int,*`,*`)))),int)->(void)
(	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
proc	*(struct)
,	O
1	int
)	O
;	O
for	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
b	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
first	*(struct)
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
!=	O
NULL	O
;	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
=	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
)	O
{	O
if	O
(	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
flags	int
==	O
F_SWITCH	int
)	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"static struct label %s_%d /* local swit"	*(char)
"ch */ (int);\n\n"	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
id	*(struct(*(char),int,int,int,int,*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`)))))
->	O
block	*(struct(int,int,*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(*(char),int,int,int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
seqn	int
)	O
;	O
}	O
}	O
}	O
emit_dsa_code	()->(void)
(	O
)	O
;	O
last_b	*(struct(int,int,*(struct),*(struct),*(struct),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
int	O
is_main	int
;	O
is_main	int
=	O
entire_module	()->(int)
(	O
)	O
;	O
if	O
(	O
is_main	int
)	O
emit_startup_code	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
e_count	int
)	O
{	O
if	O
(	O
e_count	int
==	O
1	int
)	O
error	(*(char))->(void)
(	O
"one error detected on the second pass; translation t"	*(char)
"erminated"	*(char)
)	O
;	O
else	O
error	(*(char))->(void)
(	O
"%d errors detected on the second pass; translation t"	*(char)
"erminated"	*(char)
,	O
e_count	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
append	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))),*(char))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
,	O
"/* eof */\n"	*(char)
)	O
;	O
output_code	(*(struct(int,int,*(struct(*`,*`)),*(struct(*`,*`)))))->(void)
(	O
emit	*(struct(int,int,*(struct(*(char),*(struct`))),*(struct(*(char),*(struct`)))))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Write error on `%s' - %s\n"	*(char)
,	O
outfilename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
