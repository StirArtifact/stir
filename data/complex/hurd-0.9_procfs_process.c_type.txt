static	O
char	O
state_char	(*(struct))->(char)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
1	int
<<	O
i	int
)	O
&	O
(	O
PSTAT_STATE_P_STATES	O
|	O
PSTAT_STATE_T_STATES	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
proc_stat_state	()->(int)
(	O
ps	*(struct)
)	O
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
return	O
proc_stat_state_tags	O
[	O
i	int
]	O
;	O
return	O
'?'	O
;	O
}	O
static	O
const	O
char	O
*	O
state_string	(*(struct))->(*(char))
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
)	O
{	O
static	O
const	O
char	O
*	O
const	O
state_strings	array(*(char))
[	O
]	O
=	O
{	O
"T (stopped)"	*(char)
,	O
"Z (zombie)"	*(char)
,	O
"R (running)"	*(char)
,	O
"H (halted)"	*(char)
,	O
"D (disk sleep)"	*(char)
,	O
"S (sleeping)"	*(char)
,	O
"I (idle)"	*(char)
,	O
NULL	O
}	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
state_strings	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
proc_stat_state	()->(int)
(	O
ps	*(struct)
)	O
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
return	O
state_strings	array(*(char))
[	O
i	int
]	O
;	O
return	O
"? (unknown)"	*(char)
;	O
}	O
static	O
long	O
long	O
int	O
timeval_jiffies	(int)->(long long)
(	O
time_value_t	O
tv	int
)	O
{	O
double	O
secs	double
=	O
tv	int
.	O
seconds	O
*	O
1000000.	int
+	O
tv	int
.	O
microseconds	O
;	O
return	O
secs	double
*	O
opt_clk_tck	O
/	O
1000000.	int
;	O
}	O
static	O
const	O
char	O
*	O
args_filename	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
sp	*(char)
=	O
strrchr	O
(	O
name	*(char)
,	O
'/'	O
)	O
;	O
return	O
sp	*(char)
!=	O
NULL	O
&&	O
*	O
(	O
sp	*(char)
+	O
1	int
)	O
!=	O
'\0'	O
?	O
sp	*(char)
+	O
1	int
:	O
name	*(char)
;	O
}	O
static	O
int	O
args_filename_length	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
strchrnul	()->(int)
(	O
name	*(char)
,	O
' '	O
)	O
-	O
name	*(char)
;	O
}	O
static	O
ssize_t	long
process_file_gc_cmdline	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
*	O
contents	*(*(char))
=	O
proc_stat_args	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
proc_stat_args_len	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
static	O
ssize_t	long
process_file_gc_environ	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
*	O
contents	*(*(char))
=	O
proc_stat_env	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
proc_stat_env_len	()->(int)
(	O
ps	*(struct)
)	O
;	O
}	O
static	O
ssize_t	long
process_file_gc_maps	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
error_t	O
err	O
;	O
FILE	struct
*	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
size_t	long
contents_len	long
;	O
vm_offset_t	O
addr	O
=	O
0	int
;	O
vm_size_t	O
size	O
;	O
vm_prot_t	O
prot	O
,	O
max_prot	O
;	O
mach_port_t	O
obj	O
;	O
vm_offset_t	O
offs	O
;	O
vm_inherit_t	O
inh	O
;	O
int	O
shared	int
;	O
struct	O
mem_obj	struct(int,*(struct(int,*(struct(int,*(struct`))))))
{	O
mach_port_t	O
port	int
;	O
struct	O
mem_obj	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
}	O
;	O
struct	O
mem_obj	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
objects	*(struct(int,*(struct(int,*(struct`)))))
=	O
NULL	O
;	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_memstream	(*(*(char)),*(long))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
contents	*(*(char))
,	O
&	O
contents_len	long
)	O
;	O
if	O
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
*	O
contents	*(*(char))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
1	int
)	O
{	O
err	O
=	O
vm_region	()->(int)
(	O
ps	*(struct)
->	O
task	O
,	O
&	O
addr	O
,	O
&	O
size	O
,	O
&	O
prot	O
,	O
&	O
max_prot	O
,	O
&	O
inh	O
,	O
&	O
shared	int
,	O
&	O
obj	O
,	O
&	O
offs	O
)	O
;	O
if	O
(	O
err	O
)	O
break	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%0*lx-%0*lx %c%c%c%c %0*lx %s %d "	*(char)
,	O
2	int
*	O
sizeof	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
addr	O
,	O
2	int
*	O
sizeof	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
addr	O
+	O
size	O
,	O
prot	O
&	O
VM_PROT_READ	O
?	O
'r'	O
:	O
'-'	O
,	O
prot	O
&	O
VM_PROT_WRITE	O
?	O
'w'	O
:	O
'-'	O
,	O
prot	O
&	O
VM_PROT_EXECUTE	O
?	O
'x'	O
:	O
'-'	O
,	O
shared	int
?	O
's'	O
:	O
'p'	O
,	O
2	int
*	O
sizeof	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
offs	O
,	O
"00:00"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
obj	O
)	O
)	O
{	O
struct	O
mem_obj	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
o	*(struct(int,*(struct(int,*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
o	*(struct(int,*(struct(int,*(struct`)))))
)	O
;	O
if	O
(	O
o	*(struct(int,*(struct(int,*(struct`)))))
)	O
{	O
o	*(struct(int,*(struct(int,*(struct`)))))
->	O
port	int
=	O
obj	O
;	O
o	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
=	O
objects	*(struct(int,*(struct(int,*(struct`)))))
;	O
objects	*(struct(int,*(struct(int,*(struct`)))))
=	O
o	*(struct(int,*(struct(int,*(struct`)))))
;	O
}	O
else	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
obj	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[mem_obj=%lu]\n"	*(char)
,	O
obj	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
addr	O
+=	O
size	O
;	O
}	O
while	O
(	O
objects	*(struct(int,*(struct(int,*(struct`)))))
)	O
{	O
struct	O
mem_obj	struct(int,*(struct(int,*(struct(int,*(struct`))))))
*	O
o	*(struct(int,*(struct(int,*(struct`)))))
=	O
objects	*(struct(int,*(struct(int,*(struct`)))))
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
o	*(struct(int,*(struct(int,*(struct`)))))
->	O
port	int
)	O
;	O
objects	*(struct(int,*(struct(int,*(struct`)))))
=	O
o	*(struct(int,*(struct(int,*(struct`)))))
->	O
next	*(struct(int,*(struct(int,*(struct`)))))
;	O
free	(*(void))->(void)
(	O
o	*(struct(int,*(struct(int,*(struct`)))))
)	O
;	O
}	O
if	O
(	O
err	O
!=	O
KERN_NO_SPACE	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
strerror	O
(	O
err	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
s	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
contents_len	long
;	O
}	O
static	O
ssize_t	long
process_file_gc_stat	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
struct	O
procinfo	O
*	O
pi	*(struct)
=	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
;	O
task_basic_info_t	O
tbi	O
=	O
proc_stat_task_basic_info	O
(	O
ps	*(struct)
)	O
;	O
thread_basic_info_t	O
thbi	O
=	O
proc_stat_thread_basic_info	O
(	O
ps	*(struct)
)	O
;	O
const	O
char	O
*	O
fn	*(char)
=	O
args_filename	(*(char))->(*(char))
(	O
proc_stat_args	()->(int)
(	O
ps	*(struct)
)	O
)	O
;	O
vm_address_t	O
start_code	O
=	O
1	int
;	O
vm_address_t	O
end_code	O
=	O
1	int
;	O
process_t	O
p	O
;	O
error_t	O
err	O
=	O
proc_pid2proc	O
(	O
ps	*(struct)
->	O
context	O
->	O
server	O
,	O
ps	*(struct)
->	O
pid	int
,	O
&	O
p	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
boolean_t	O
essential	O
=	O
0	int
;	O
proc_is_important	()->(int)
(	O
p	O
,	O
&	O
essential	O
)	O
;	O
if	O
(	O
essential	O
)	O
start_code	O
=	O
end_code	O
=	O
0	int
;	O
else	O
proc_get_code	()->(int)
(	O
p	O
,	O
&	O
start_code	O
,	O
&	O
end_code	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
p	O
)	O
;	O
}	O
return	O
asprintf	(*(*(char)),*(char))->(int)
(	O
contents	*(*(char))
,	O
"%d (%.*s) %c "	*(char)
"%d %d %d "	*(char)
"%d %d "	*(char)
"%u "	*(char)
"%lu %lu %lu %lu "	*(char)
"%lu %lu %ld %ld "	*(char)
"%d %d "	*(char)
"%d %ld "	*(char)
"%llu "	*(char)
"%lu %ld %lu "	*(char)
"%lu %lu %lu %lu %lu "	*(char)
"%lu %lu %lu %lu "	*(char)
"%lu "	*(char)
"%lu %lu "	*(char)
"%d "	*(char)
"%d "	*(char)
"%u %u "	*(char)
"%llu "	*(char)
"\n"	*(char)
,	O
proc_stat_pid	()->(int)
(	O
ps	*(struct)
)	O
,	O
args_filename_length	(*(char))->(int)
(	O
fn	*(char)
)	O
,	O
fn	*(char)
,	O
state_char	(*(struct))->(char)
(	O
ps	*(struct)
)	O
,	O
pi	*(struct)
->	O
ppid	O
,	O
pi	*(struct)
->	O
pgrp	O
,	O
pi	*(struct)
->	O
session	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
(	O
long	O
unsigned	O
)	O
timeval_jiffies	(int)->(long long)
(	O
thbi	O
->	O
user_time	O
)	O
,	O
(	O
long	O
unsigned	O
)	O
timeval_jiffies	(int)->(long long)
(	O
thbi	O
->	O
system_time	O
)	O
,	O
0L	int
,	O
0L	int
,	O
MACH_PRIORITY_TO_NICE	()->(int)
(	O
thbi	O
->	O
base_priority	O
)	O
+	O
20	int
,	O
MACH_PRIORITY_TO_NICE	()->(int)
(	O
thbi	O
->	O
base_priority	O
)	O
,	O
pi	*(struct)
->	O
nthreads	O
,	O
0L	int
,	O
timeval_jiffies	(int)->(long long)
(	O
thbi	O
->	O
creation_time	O
)	O
,	O
(	O
long	O
unsigned	O
)	O
tbi	O
->	O
virtual_size	O
,	O
(	O
long	O
unsigned	O
)	O
tbi	O
->	O
resident_size	O
/	O
PAGE_SIZE	O
,	O
0L	int
,	O
start_code	O
,	O
end_code	O
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
0L	int
,	O
(	O
long	O
unsigned	O
)	O
proc_stat_thread_rpc	()->(int)
(	O
ps	*(struct)
)	O
,	O
0L	int
,	O
0L	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0LL	int
)	O
;	O
}	O
static	O
ssize_t	long
process_file_gc_statm	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
task_basic_info_t	O
tbi	O
=	O
proc_stat_task_basic_info	O
(	O
ps	*(struct)
)	O
;	O
return	O
asprintf	(*(*(char)),*(char))->(int)
(	O
contents	*(*(char))
,	O
"%lu %lu 0 0 0 0 0\n"	*(char)
,	O
tbi	O
->	O
virtual_size	O
/	O
sysconf	(int)->(long)
(	O
_SC_PAGE_SIZE	O
)	O
,	O
tbi	O
->	O
resident_size	O
/	O
sysconf	(int)->(long)
(	O
_SC_PAGE_SIZE	O
)	O
)	O
;	O
}	O
static	O
ssize_t	long
process_file_gc_status	(*(struct),*(*(char)))->(long)
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
{	O
task_basic_info_t	O
tbi	O
=	O
proc_stat_task_basic_info	O
(	O
ps	*(struct)
)	O
;	O
const	O
char	O
*	O
fn	*(char)
=	O
args_filename	(*(char))->(*(char))
(	O
proc_stat_args	()->(int)
(	O
ps	*(struct)
)	O
)	O
;	O
return	O
asprintf	(*(*(char)),*(char))->(int)
(	O
contents	*(*(char))
,	O
"Name:\t%.*s\n"	*(char)
"State:\t%s\n"	*(char)
"Tgid:\t%u\n"	*(char)
"Pid:\t%u\n"	*(char)
"PPid:\t%u\n"	*(char)
"Uid:\t%u\t%u\t%u\t%u\n"	*(char)
"VmSize:\t%8u kB\n"	*(char)
"VmPeak:\t%8u kB\n"	*(char)
"VmRSS:\t%8u kB\n"	*(char)
"VmHWM:\t%8u kB\n"	*(char)
"Threads:\t%u\n"	*(char)
,	O
args_filename_length	(*(char))->(int)
(	O
fn	*(char)
)	O
,	O
fn	*(char)
,	O
state_string	(*(struct))->(*(char))
(	O
ps	*(struct)
)	O
,	O
proc_stat_pid	()->(int)
(	O
ps	*(struct)
)	O
,	O
proc_stat_pid	()->(int)
(	O
ps	*(struct)
)	O
,	O
proc_stat_proc_info	()->(int)
(	O
ps	*(struct)
)	O
->	O
ppid	O
,	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
,	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
,	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
,	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
,	O
tbi	O
->	O
virtual_size	O
/	O
1024	int
,	O
tbi	O
->	O
virtual_size	O
/	O
1024	int
,	O
tbi	O
->	O
resident_size	O
/	O
1024	int
,	O
tbi	O
->	O
resident_size	O
/	O
1024	int
,	O
proc_stat_num_threads	()->(int)
(	O
ps	*(struct)
)	O
)	O
;	O
}	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
{	O
ps_flags_t	O
needs	int
;	O
ssize_t	long
(	O
*	O
get_contents	*((*(struct),*(*(char)))->(long))
)	O
(	O
struct	O
proc_stat	O
*	O
ps	*(struct)
,	O
char	O
*	O
*	O
contents	*(*(char))
)	O
;	O
int	O
no_cleanup	int
;	O
mode_t	int
mode	int
;	O
}	O
;	O
struct	O
process_file_node	struct(*(struct(int,*((*(struct`),*(*`))->(long)),int,int)),*(struct))
{	O
const	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
*	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
;	O
struct	O
proc_stat	O
*	O
ps	*(struct)
;	O
}	O
;	O
static	O
error_t	O
process_file_get_contents	(*(void),*(*(char)),*(long))->(int)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
*	O
contents	*(*(char))
,	O
ssize_t	long
*	O
contents_len	long
)	O
{	O
struct	O
process_file_node	struct(*(struct(int,*((*(struct`),*(*`))->(long)),int,int)),*(struct))
*	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
=	O
hook	*(void)
;	O
error_t	O
err	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
ps	*(struct)
,	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
needs	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
EIO	O
;	O
if	O
(	O
(	O
proc_stat_flags	()->(int)
(	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
ps	*(struct)
)	O
&	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
needs	int
)	O
!=	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
needs	int
)	O
return	O
EIO	O
;	O
*	O
contents_len	long
=	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
get_contents	*((*(struct),*(*(char)))->(long))
(	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
ps	*(struct)
,	O
contents	*(*(char))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
process_file_cleanup_contents	(*(void),*(char),long)->(void)
(	O
void	O
*	O
hook	*(void)
,	O
char	O
*	O
contents	*(*(char))
,	O
ssize_t	long
len	long
)	O
{	O
struct	O
process_file_node	struct(*(struct(int,*((*(struct`),*(*`))->(long)),int,int)),*(struct))
*	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
=	O
hook	*(void)
;	O
if	O
(	O
!	O
file	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
no_cleanup	int
)	O
free	(*(void))->(void)
(	O
contents	*(*(char))
)	O
;	O
}	O
static	O
struct	O
node	O
*	O
process_file_make_node	(*(void),*(void))->(*(struct))
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
static	O
const	O
struct	O
procfs_node_ops	O
ops	struct
=	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_get_contents	(*(void),*(*(char)),*(long))->(int)
,	O
.	O
cleanup_contents	O
=	O
process_file_cleanup_contents	(*(void),*(char),long)->(void)
,	O
.	O
cleanup	O
=	O
free	(*(void))->(void)
,	O
}	O
;	O
struct	O
process_file_node	struct(*(struct(int,*((*(struct`),*(*`))->(long)),int,int)),*(struct))
*	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
;	O
struct	O
node	O
*	O
np	*(struct)
;	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
)	O
;	O
if	O
(	O
!	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
)	O
return	O
NULL	O
;	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
=	O
entry_hook	*(void)
;	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
ps	*(struct)
=	O
dir_hook	*(void)
;	O
np	*(struct)
=	O
procfs_make_node	()->(int)
(	O
&	O
ops	struct
,	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
)	O
;	O
if	O
(	O
!	O
np	*(struct)
)	O
return	O
NULL	O
;	O
procfs_node_chown	()->(int)
(	O
np	*(struct)
,	O
proc_stat_owner_uid	()->(int)
(	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
ps	*(struct)
)	O
)	O
;	O
if	O
(	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
mode	int
)	O
procfs_node_chmod	()->(int)
(	O
np	*(struct)
,	O
f	*(struct(*(struct(int,*((*`,*`)->(long)),int,int)),*(struct)))
->	O
desc	*(struct(int,*((*(struct`),*(*`))->(long)),int,int))
->	O
mode	int
)	O
;	O
return	O
np	*(struct)
;	O
}	O
static	O
struct	O
node	O
*	O
process_stat_make_node	(*(void),*(void))->(*(struct))
(	O
void	O
*	O
dir_hook	*(void)
,	O
const	O
void	O
*	O
entry_hook	*(void)
)	O
{	O
struct	O
node	O
*	O
np	*(struct)
=	O
process_file_make_node	(*(void),*(void))->(*(struct))
(	O
dir_hook	*(void)
,	O
entry_hook	*(void)
)	O
;	O
if	O
(	O
np	*(struct)
)	O
procfs_node_chmod	()->(int)
(	O
np	*(struct)
,	O
opt_stat_mode	O
)	O
;	O
return	O
np	*(struct)
;	O
}	O
static	O
struct	O
procfs_dir_entry	O
entries	int
[	O
]	O
=	O
{	O
{	O
.	O
name	*(char)
=	O
"cmdline"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_cmdline	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_ARGS	O
,	O
.	O
no_cleanup	int
=	O
1	int
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"environ"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_environ	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_ENV	O
,	O
.	O
no_cleanup	int
=	O
1	int
,	O
.	O
mode	int
=	O
0400	int
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"maps"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_maps	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_TASK	O
,	O
.	O
mode	int
=	O
0400	int
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"stat"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_stat	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_PID	O
|	O
PSTAT_ARGS	O
|	O
PSTAT_STATE	O
|	O
PSTAT_PROC_INFO	O
|	O
PSTAT_TASK	O
|	O
PSTAT_TASK_BASIC	O
|	O
PSTAT_THREAD_BASIC	O
|	O
PSTAT_THREAD_WAIT	O
,	O
}	O
,	O
.	O
ops	struct
=	O
{	O
.	O
make_node	O
=	O
process_stat_make_node	(*(void),*(void))->(*(struct))
,	O
}	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"statm"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_statm	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_TASK_BASIC	O
,	O
}	O
,	O
}	O
,	O
{	O
.	O
name	*(char)
=	O
"status"	*(char)
,	O
.	O
hook	*(void)
=	O
&	O
(	O
struct	O
process_file_desc	struct(int,*((*(struct),*(*(char)))->(long)),int,int)
)	O
{	O
.	O
get_contents	*((*(struct),*(*(char)))->(long))
=	O
process_file_gc_status	(*(struct),*(*(char)))->(long)
,	O
.	O
needs	int
=	O
PSTAT_PID	O
|	O
PSTAT_ARGS	O
|	O
PSTAT_STATE	O
|	O
PSTAT_PROC_INFO	O
|	O
PSTAT_TASK_BASIC	O
|	O
PSTAT_OWNER_UID	O
|	O
PSTAT_NUM_THREADS	O
,	O
}	O
,	O
}	O
,	O
{	O
}	O
}	O
;	O
error_t	O
process_lookup_pid	(*(struct),int,*(*(struct)))->(int)
(	O
struct	O
ps_context	O
*	O
pc	*(struct)
,	O
pid_t	int
pid	int
,	O
struct	O
node	O
*	O
*	O
np	*(struct)
)	O
{	O
static	O
const	O
struct	O
procfs_dir_ops	O
dir_ops	struct
=	O
{	O
.	O
entries	int
=	O
entries	int
,	O
.	O
cleanup	O
=	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
_proc_stat_free	()->(int)
,	O
.	O
entry_ops	O
=	O
{	O
.	O
make_node	O
=	O
process_file_make_node	(*(void),*(void))->(*(struct))
,	O
}	O
,	O
}	O
;	O
struct	O
proc_stat	O
*	O
ps	*(struct)
;	O
int	O
owner	int
;	O
error_t	O
err	O
;	O
err	O
=	O
_proc_stat_create	()->(int)
(	O
pid	int
,	O
pc	*(struct)
,	O
&	O
ps	*(struct)
)	O
;	O
if	O
(	O
err	O
==	O
ESRCH	O
)	O
return	O
ENOENT	O
;	O
if	O
(	O
err	O
)	O
return	O
EIO	O
;	O
err	O
=	O
proc_stat_set_flags	()->(int)
(	O
ps	*(struct)
,	O
PSTAT_OWNER_UID	O
)	O
;	O
if	O
(	O
err	O
||	O
!	O
(	O
proc_stat_flags	()->(int)
(	O
ps	*(struct)
)	O
&	O
PSTAT_OWNER_UID	O
)	O
)	O
{	O
_proc_stat_free	()->(int)
(	O
ps	*(struct)
)	O
;	O
return	O
EIO	O
;	O
}	O
*	O
np	*(struct)
=	O
procfs_dir_make_node	()->(int)
(	O
&	O
dir_ops	struct
,	O
ps	*(struct)
)	O
;	O
if	O
(	O
!	O
*	O
np	*(struct)
)	O
return	O
ENOMEM	O
;	O
owner	int
=	O
proc_stat_owner_uid	()->(int)
(	O
ps	*(struct)
)	O
;	O
procfs_node_chown	()->(int)
(	O
*	O
np	*(struct)
,	O
owner	int
>=	O
0	int
?	O
owner	int
:	O
opt_anon_owner	O
)	O
;	O
return	O
0	int
;	O
}	O
