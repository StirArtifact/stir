struct	O
stab_handle	O
{	O
bfd	struct
*	O
abfd	*(struct)
;	O
bfd_boolean	int
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
;	O
long	O
symcount	int
;	O
char	O
*	O
so_string	O
;	O
bfd_vma	long
so_value	O
;	O
bfd_vma	long
file_start_offset	O
;	O
bfd_vma	long
function_start_offset	O
;	O
int	O
gcc_compiled	O
;	O
bfd_boolean	int
n_opt_found	O
;	O
char	O
*	O
main_filename	O
;	O
struct	O
bincl_file	O
*	O
bincl_stack	O
;	O
struct	O
bincl_file	O
*	O
bincl_list	O
;	O
bfd_boolean	int
within_function	O
;	O
bfd_vma	long
function_end	O
;	O
int	O
block_depth	O
;	O
struct	O
stab_pending_var	O
*	O
pending	O
;	O
unsigned	O
int	O
files	O
;	O
struct	O
stab_types	O
*	O
*	O
file_types	O
;	O
debug_type	O
xcoff_types	O
[	O
XCOFF_TYPE_COUNT	O
]	O
;	O
struct	O
stab_tag	O
*	O
tags	O
;	O
bfd_boolean	int
self_crossref	O
;	O
}	O
;	O
struct	O
stab_pending_var	O
{	O
struct	O
stab_pending_var	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
name	*(char)
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
enum	O
debug_var_kind	O
kind	O
;	O
bfd_vma	long
val	array(int)
;	O
}	O
;	O
struct	O
stab_types	O
{	O
struct	O
stab_types	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
debug_type	O
types	O
[	O
STAB_TYPES_SLOTS	O
]	O
;	O
}	O
;	O
struct	O
stab_tag	O
{	O
struct	O
stab_tag	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
name	*(char)
;	O
enum	O
debug_type_kind	O
kind	O
;	O
debug_type	O
slot	O
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
}	O
;	O
static	O
char	O
*	O
savestring	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
bad_stab	O
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
warn_stab	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_string	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
int	O
,	O
int	O
,	O
bfd_vma	long
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_type_number	O
(	O
const	O
char	O
*	O
*	O
,	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_range_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_sun_builtin_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_sun_floating_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_enum_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_struct_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_boolean	int
,	O
const	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_baseclasses	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_baseclass	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_struct_fields	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_field	O
*	O
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_cpp_abbrev	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_field	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_one_struct_field	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
,	O
debug_field	O
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_members	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
debug_method	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_argtypes	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
debug_type	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
debug_type	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_tilde_field	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
debug_type	O
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	O
parse_stab_array_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
push_bincl	O
(	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
const	O
char	O
*	O
pop_bincl	O
(	O
struct	O
stab_handle	O
*	O
)	O
;	O
static	O
bfd_boolean	int
find_excl	O
(	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
stab_record_variable	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
debug_type	O
,	O
enum	O
debug_var_kind	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
stab_emit_pending_vars	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
)	O
;	O
static	O
debug_type	O
*	O
stab_find_slot	O
(	O
struct	O
stab_handle	O
*	O
,	O
const	O
int	O
*	O
)	O
;	O
static	O
debug_type	O
stab_find_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_record_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
int	O
*	O
,	O
debug_type	O
)	O
;	O
static	O
debug_type	O
stab_xcoff_builtin_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
int	O
)	O
;	O
static	O
debug_type	O
stab_find_tagged_type	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
int	O
,	O
enum	O
debug_type_kind	O
)	O
;	O
static	O
debug_type	O
*	O
stab_demangle_argtypes	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
debug_type	O
*	O
stab_demangle_v3_argtypes	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
debug_type	O
*	O
stab_demangle_v3_arglist	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
struct	O
demangle_component	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
debug_type	O
stab_demangle_v3_arg	O
(	O
void	O
*	O
,	O
struct	O
stab_handle	O
*	O
,	O
struct	O
demangle_component	O
*	O
,	O
debug_type	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
int	O
demangle_flags	O
=	O
DMGL_ANSI	O
;	O
static	O
char	O
*	O
savestring	O
(	O
const	O
char	O
*	O
start	O
,	O
int	O
len	long
)	O
{	O
char	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
,	O
start	O
,	O
len	long
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
bfd_vma	long
parse_number	O
(	O
const	O
char	O
*	O
*	O
pp	O
,	O
bfd_boolean	int
*	O
poverflow	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
unsigned	O
long	O
ul	O
;	O
const	O
char	O
*	O
orig	O
;	O
if	O
(	O
poverflow	O
!=	O
NULL	O
)	O
*	O
poverflow	O
=	O
FALSE	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
(	O
bfd_vma	long
)	O
0	int
;	O
if	O
(	O
*	O
orig	O
==	O
0	int
)	O
return	O
(	O
bfd_vma	long
)	O
0	int
;	O
errno	O
=	O
0	int
;	O
ul	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
*	O
pp	O
,	O
(	O
char	O
*	O
*	O
)	O
pp	O
,	O
0	int
)	O
;	O
if	O
(	O
ul	O
+	O
1	int
!=	O
0	int
||	O
errno	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
orig	O
==	O
'-'	O
)	O
return	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
(	O
long	O
)	O
ul	O
;	O
return	O
(	O
bfd_vma	long
)	O
ul	O
;	O
}	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
>	O
sizeof	O
(	O
unsigned	O
long	O
)	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
bfd_boolean	int
neg	O
;	O
int	O
base	int
;	O
bfd_vma	long
over	O
,	O
lastdig	O
;	O
bfd_boolean	int
overflow	O
;	O
bfd_vma	long
v	O
;	O
p	*(void)
=	O
orig	O
;	O
neg	O
=	O
FALSE	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'+'	O
)	O
++	O
p	*(void)
;	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'-'	O
)	O
{	O
neg	O
=	O
TRUE	int
;	O
++	O
p	*(void)
;	O
}	O
base	int
=	O
10	int
;	O
if	O
(	O
*	O
p	*(void)
==	O
'0'	O
)	O
{	O
if	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
'x'	O
||	O
p	*(void)
[	O
1	int
]	O
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
p	*(void)
+=	O
2	int
;	O
}	O
else	O
{	O
base	int
=	O
8	int
;	O
++	O
p	*(void)
;	O
}	O
}	O
over	O
=	O
(	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
-	O
1	int
)	O
/	O
(	O
bfd_vma	long
)	O
base	int
;	O
lastdig	O
=	O
(	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
-	O
1	int
)	O
%	O
(	O
bfd_vma	long
)	O
base	int
;	O
overflow	O
=	O
FALSE	O
;	O
v	O
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
d	O
;	O
d	O
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
ISDIGIT	O
(	O
d	O
)	O
)	O
d	O
-=	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
d	O
)	O
)	O
d	O
-=	O
'A'	O
;	O
else	O
if	O
(	O
ISLOWER	O
(	O
d	O
)	O
)	O
d	O
-=	O
'a'	O
;	O
else	O
break	O
;	O
if	O
(	O
d	O
>=	O
base	int
)	O
break	O
;	O
if	O
(	O
v	O
>	O
over	O
||	O
(	O
v	O
==	O
over	O
&&	O
(	O
bfd_vma	long
)	O
d	O
>	O
lastdig	O
)	O
)	O
{	O
overflow	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
overflow	O
)	O
{	O
if	O
(	O
neg	O
)	O
v	O
=	O
-	O
v	O
;	O
return	O
v	O
;	O
}	O
}	O
if	O
(	O
poverflow	O
!=	O
NULL	O
)	O
*	O
poverflow	O
=	O
TRUE	int
;	O
else	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"numeric overflow"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
bad_stab	O
(	O
const	O
char	O
*	O
p	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Bad stab: %s\n"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
}	O
static	O
void	O
warn_stab	O
(	O
const	O
char	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
err	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Warning: %s: %s\n"	*(char)
)	O
,	O
err	O
,	O
p	*(void)
)	O
;	O
}	O
void	O
*	O
start_stab	O
(	O
void	O
*	O
dhandle	O
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	*(struct)
,	O
bfd_boolean	int
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
,	O
long	O
symcount	int
)	O
{	O
struct	O
stab_handle	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
struct	O
stab_handle	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
,	O
0	int
,	O
sizeof	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
abfd	*(struct)
=	O
abfd	*(struct)
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
=	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
symcount	int
=	O
symcount	int
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
files	O
=	O
1	int
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
file_types	O
=	O
(	O
struct	O
stab_types	O
*	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
file_types	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
file_types	O
[	O
0	int
]	O
=	O
NULL	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
function_end	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
(	O
void	O
*	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
bfd_boolean	int
finish_stab	O
(	O
void	O
*	O
dhandle	O
,	O
void	O
*	O
handle	O
)	O
{	O
struct	O
stab_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
stab_handle	O
*	O
)	O
handle	O
;	O
struct	O
stab_tag	O
*	O
st	O
;	O
if	O
(	O
info	*(void)
->	O
within_function	O
)	O
{	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
||	O
!	O
debug_end_function	O
(	O
dhandle	O
,	O
info	*(void)
->	O
function_end	O
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
within_function	O
=	O
FALSE	O
;	O
info	*(void)
->	O
function_end	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
for	O
(	O
st	O
=	O
info	*(void)
->	O
tags	O
;	O
st	O
!=	O
NULL	O
;	O
st	O
=	O
st	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
enum	O
debug_type_kind	O
kind	O
;	O
kind	O
=	O
st	O
->	O
kind	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_KIND_ILLEGAL	O
)	O
kind	O
=	O
DEBUG_KIND_STRUCT	O
;	O
st	O
->	O
slot	O
=	O
debug_make_undefined_tagged_type	O
(	O
dhandle	O
,	O
st	O
->	O
name	*(char)
,	O
kind	O
)	O
;	O
if	O
(	O
st	O
->	O
slot	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
parse_stab	O
(	O
void	O
*	O
dhandle	O
,	O
void	O
*	O
handle	O
,	O
int	O
type	enum(int,int,int,int)
,	O
int	O
desc	O
,	O
bfd_vma	long
value	long
,	O
const	O
char	O
*	O
string	*(char)
)	O
{	O
const	O
char	O
*	O
string_end	O
;	O
struct	O
stab_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
stab_handle	O
*	O
)	O
handle	O
;	O
if	O
(	O
info	*(void)
->	O
so_string	O
!=	O
NULL	O
&&	O
(	O
type	enum(int,int,int,int)
!=	O
N_SO	O
||	O
*	O
string	*(char)
==	O
'\0'	O
||	O
value	long
!=	O
info	*(void)
->	O
so_value	O
)	O
)	O
{	O
if	O
(	O
!	O
debug_set_filename	O
(	O
dhandle	O
,	O
info	*(void)
->	O
so_string	O
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
main_filename	O
=	O
info	*(void)
->	O
so_string	O
;	O
info	*(void)
->	O
gcc_compiled	O
=	O
0	int
;	O
info	*(void)
->	O
n_opt_found	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
info	*(void)
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
info	*(void)
->	O
file_start_offset	O
=	O
info	*(void)
->	O
so_value	O
;	O
info	*(void)
->	O
files	O
=	O
1	int
;	O
info	*(void)
->	O
file_types	O
=	O
(	O
(	O
struct	O
stab_types	O
*	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
info	*(void)
->	O
file_types	O
)	O
)	O
;	O
info	*(void)
->	O
file_types	O
[	O
0	int
]	O
=	O
NULL	O
;	O
info	*(void)
->	O
so_string	O
=	O
NULL	O
;	O
}	O
string_end	O
=	O
string	*(char)
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
N_FN	O
:	O
case	O
N_FN_SEQ	O
:	O
break	O
;	O
case	O
N_LBRAC	O
:	O
if	O
(	O
info	*(void)
->	O
n_opt_found	O
&&	O
desc	O
==	O
1	int
)	O
break	O
;	O
if	O
(	O
!	O
info	*(void)
->	O
within_function	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"N_LBRAC not within function\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
debug_start_block	O
(	O
dhandle	O
,	O
(	O
value	long
+	O
info	*(void)
->	O
file_start_offset	O
+	O
info	*(void)
->	O
function_start_offset	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
)	O
return	O
FALSE	O
;	O
++	O
info	*(void)
->	O
block_depth	O
;	O
break	O
;	O
case	O
N_RBRAC	O
:	O
if	O
(	O
info	*(void)
->	O
n_opt_found	O
&&	O
desc	O
==	O
1	int
)	O
break	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_end_block	O
(	O
dhandle	O
,	O
(	O
value	long
+	O
info	*(void)
->	O
file_start_offset	O
+	O
info	*(void)
->	O
function_start_offset	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
--	O
info	*(void)
->	O
block_depth	O
;	O
if	O
(	O
info	*(void)
->	O
block_depth	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Too many N_RBRACs\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
N_SO	O
:	O
if	O
(	O
info	*(void)
->	O
within_function	O
)	O
{	O
bfd_vma	long
endval	O
;	O
endval	O
=	O
value	long
;	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
&&	O
info	*(void)
->	O
function_end	O
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
info	*(void)
->	O
function_end	O
<	O
endval	O
)	O
endval	O
=	O
info	*(void)
->	O
function_end	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
||	O
!	O
debug_end_function	O
(	O
dhandle	O
,	O
endval	O
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
within_function	O
=	O
FALSE	O
;	O
info	*(void)
->	O
function_end	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
*	O
string	*(char)
==	O
'\0'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
info	*(void)
->	O
so_string	O
==	O
NULL	O
)	O
info	*(void)
->	O
so_string	O
=	O
xstrdup	O
(	O
string	*(char)
)	O
;	O
else	O
{	O
char	O
*	O
f	O
;	O
f	O
=	O
info	*(void)
->	O
so_string	O
;	O
if	O
(	O
IS_ABSOLUTE_PATH	O
(	O
string	*(char)
)	O
)	O
info	*(void)
->	O
so_string	O
=	O
xstrdup	O
(	O
string	*(char)
)	O
;	O
else	O
info	*(void)
->	O
so_string	O
=	O
concat	O
(	O
info	*(void)
->	O
so_string	O
,	O
string	*(char)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
f	O
)	O
;	O
}	O
info	*(void)
->	O
so_value	O
=	O
value	long
;	O
break	O
;	O
case	O
N_SOL	O
:	O
if	O
(	O
!	O
debug_start_source	O
(	O
dhandle	O
,	O
string	*(char)
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_BINCL	O
:	O
push_bincl	O
(	O
info	*(void)
,	O
string	*(char)
,	O
value	long
)	O
;	O
if	O
(	O
!	O
debug_start_source	O
(	O
dhandle	O
,	O
string	*(char)
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_EINCL	O
:	O
if	O
(	O
!	O
debug_start_source	O
(	O
dhandle	O
,	O
pop_bincl	O
(	O
info	*(void)
)	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_EXCL	O
:	O
if	O
(	O
!	O
find_excl	O
(	O
info	*(void)
,	O
string	*(char)
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_SLINE	O
:	O
if	O
(	O
!	O
debug_record_line	O
(	O
dhandle	O
,	O
desc	O
,	O
value	long
+	O
(	O
info	*(void)
->	O
within_function	O
?	O
info	*(void)
->	O
function_start_offset	O
:	O
0	int
)	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_BCOMM	O
:	O
if	O
(	O
!	O
debug_start_common_block	O
(	O
dhandle	O
,	O
string	*(char)
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_ECOMM	O
:	O
if	O
(	O
!	O
debug_end_common_block	O
(	O
dhandle	O
,	O
string	*(char)
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
N_FUN	O
:	O
if	O
(	O
*	O
string	*(char)
==	O
'\0'	O
)	O
{	O
if	O
(	O
info	*(void)
->	O
within_function	O
)	O
{	O
if	O
(	O
info	*(void)
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
value	long
+=	O
info	*(void)
->	O
function_start_offset	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
||	O
!	O
debug_end_function	O
(	O
dhandle	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
within_function	O
=	O
FALSE	O
;	O
info	*(void)
->	O
function_end	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
within_function	O
&&	O
(	O
info	*(void)
->	O
function_end	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
value	long
<	O
info	*(void)
->	O
function_end	O
)	O
)	O
info	*(void)
->	O
function_end	O
=	O
value	long
;	O
default	O
:	O
{	O
const	O
char	O
*	O
colon	O
;	O
colon	O
=	O
strchr	(*(char),int)->(*(char))
(	O
string	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
colon	O
!=	O
NULL	O
&&	O
(	O
colon	O
[	O
1	int
]	O
==	O
'f'	O
||	O
colon	O
[	O
1	int
]	O
==	O
'F'	O
)	O
)	O
{	O
if	O
(	O
info	*(void)
->	O
within_function	O
)	O
{	O
bfd_vma	long
endval	O
;	O
endval	O
=	O
value	long
;	O
if	O
(	O
info	*(void)
->	O
function_end	O
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
info	*(void)
->	O
function_end	O
<	O
endval	O
)	O
endval	O
=	O
info	*(void)
->	O
function_end	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	O
(	O
dhandle	O
,	O
info	*(void)
)	O
||	O
!	O
debug_end_function	O
(	O
dhandle	O
,	O
endval	O
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
function_end	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
info	*(void)
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
info	*(void)
->	O
function_start_offset	O
=	O
value	long
;	O
info	*(void)
->	O
within_function	O
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
parse_stab_string	O
(	O
dhandle	O
,	O
info	*(void)
,	O
type	enum(int,int,int,int)
,	O
desc	O
,	O
value	long
,	O
string	*(char)
,	O
string_end	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
N_OPT	O
:	O
if	O
(	O
string	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
string	*(char)
,	O
"gcc2_compiled."	*(char)
)	O
==	O
0	int
)	O
info	*(void)
->	O
gcc_compiled	O
=	O
2	int
;	O
else	O
if	O
(	O
string	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
string	*(char)
,	O
"gcc_compiled."	*(char)
)	O
==	O
0	int
)	O
info	*(void)
->	O
gcc_compiled	O
=	O
1	int
;	O
else	O
info	*(void)
->	O
n_opt_found	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
N_OBJ	O
:	O
case	O
N_ENDM	O
:	O
case	O
N_MAIN	O
:	O
case	O
N_WARNING	O
:	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_string	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
int	O
stabtype	O
,	O
int	O
desc	O
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
value	long
,	O
const	O
char	O
*	O
string	*(char)
,	O
const	O
char	O
*	O
string_end	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
name	*(char)
;	O
int	O
type	enum(int,int,int,int)
;	O
debug_type	O
dtype	O
;	O
bfd_boolean	int
synonym	O
;	O
bfd_boolean	int
self_crossref	O
;	O
debug_type	O
*	O
slot	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
string	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
while	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
p	*(void)
+=	O
2	int
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
name	*(char)
=	O
NULL	O
;	O
if	O
(	O
string	*(char)
[	O
0	int
]	O
==	O
'$'	O
)	O
{	O
switch	O
(	O
string	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
't'	O
:	O
name	*(char)
=	O
"this"	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
break	O
;	O
case	O
'e'	O
:	O
name	*(char)
=	O
"eh_throw"	*(char)
;	O
break	O
;	O
case	O
'_'	O
:	O
break	O
;	O
case	O
'X'	O
:	O
break	O
;	O
default	O
:	O
warn_stab	O
(	O
string	*(char)
,	O
_	O
(	O
"unknown C++ encoded name"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
p	*(void)
==	O
string	*(char)
||	O
(	O
string	*(char)
[	O
0	int
]	O
==	O
' '	O
&&	O
p	*(void)
==	O
string	*(char)
+	O
1	int
)	O
)	O
name	*(char)
=	O
NULL	O
;	O
else	O
name	*(char)
=	O
savestring	O
(	O
string	*(char)
,	O
p	*(void)
-	O
string	*(char)
)	O
;	O
}	O
++	O
p	*(void)
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
||	O
*	O
p	*(void)
==	O
'('	O
||	O
*	O
p	*(void)
==	O
'-'	O
)	O
type	enum(int,int,int,int)
=	O
'l'	O
;	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
else	O
type	enum(int,int,int,int)
=	O
*	O
p	*(void)
++	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
'c'	O
:	O
if	O
(	O
*	O
p	*(void)
!=	O
'='	O
)	O
{	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
p	*(void)
;	O
switch	O
(	O
*	O
p	*(void)
++	O
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
!	O
debug_record_float_const	O
(	O
dhandle	O
,	O
name	*(char)
,	O
atof	(*(char))->(double)
(	O
p	*(void)
)	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
!	O
debug_record_int_const	O
(	O
dhandle	O
,	O
name	*(char)
,	O
atoi	(*(char))->(int)
(	O
p	*(void)
)	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'e'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
debug_record_typed_const	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
atoi	(*(char))->(int)
(	O
p	*(void)
)	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
default	O
:	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_label	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_function	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
type	enum(int,int,int,int)
==	O
'F'	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
while	O
(	O
*	O
p	*(void)
==	O
';'	O
)	O
{	O
++	O
p	*(void)
;	O
if	O
(	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
'G'	O
:	O
{	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
ps	O
;	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
{	O
char	O
leading	O
;	O
long	O
c	O
;	O
leading	O
=	O
bfd_get_symbol_leading_char	O
(	O
info	*(void)
->	O
abfd	*(struct)
)	O
;	O
for	O
(	O
c	O
=	O
info	*(void)
->	O
symcount	int
,	O
ps	O
=	O
info	*(void)
->	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
;	O
c	O
>	O
0	int
;	O
--	O
c	O
,	O
++	O
ps	O
)	O
{	O
const	O
char	O
*	O
n	O
;	O
n	O
=	O
bfd_asymbol_name	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))->(*(char))
(	O
*	O
ps	O
)	O
;	O
if	O
(	O
leading	O
!=	O
'\0'	O
&&	O
*	O
n	O
==	O
leading	O
)	O
++	O
n	O
;	O
if	O
(	O
*	O
n	O
==	O
*	O
name	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
n	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
c	O
>	O
0	int
)	O
value	long
=	O
bfd_asymbol_value	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))->(long)
(	O
*	O
ps	O
)	O
;	O
}	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_GLOBAL	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
case	O
's'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_LOCAL	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
p	*(void)
!=	O
'F'	O
)	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
else	O
{	O
++	O
p	*(void)
;	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
debug_type	O
ftype	O
;	O
ftype	O
=	O
debug_make_function_type	O
(	O
dhandle	O
,	O
dtype	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
,	O
FALSE	O
)	O
;	O
dtype	O
=	O
debug_make_pointer_type	O
(	O
dhandle	O
,	O
ftype	O
)	O
;	O
}	O
}	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_parameter	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_PARM_STACK	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
stabtype	O
==	O
N_FUN	O
)	O
{	O
while	O
(	O
*	O
p	*(void)
==	O
';'	O
)	O
{	O
++	O
p	*(void)
;	O
if	O
(	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
}	O
case	O
'R'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_parameter	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_PARM_REG	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'r'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_REGISTER	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'S'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_STATIC	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
't'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
&	O
p	*(void)
,	O
&	O
slot	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
dtype	O
=	O
debug_name_type	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
slot	O
!=	O
NULL	O
)	O
*	O
slot	O
=	O
dtype	O
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
*	O
p	*(void)
!=	O
't'	O
)	O
{	O
synonym	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
synonym	O
=	O
TRUE	int
;	O
++	O
p	*(void)
;	O
}	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
&	O
p	*(void)
,	O
&	O
slot	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
self_crossref	O
=	O
info	*(void)
->	O
self_crossref	O
;	O
dtype	O
=	O
debug_tag_type	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
slot	O
!=	O
NULL	O
)	O
*	O
slot	O
=	O
dtype	O
;	O
if	O
(	O
!	O
self_crossref	O
)	O
{	O
register	O
struct	O
stab_tag	O
*	O
*	O
pst	O
;	O
for	O
(	O
pst	O
=	O
&	O
info	*(void)
->	O
tags	O
;	O
*	O
pst	O
!=	O
NULL	O
;	O
pst	O
=	O
&	O
(	O
*	O
pst	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
(	O
*	O
pst	O
)	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
name	*(char)
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
*	O
pst	O
)	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
(	O
*	O
pst	O
)	O
->	O
slot	O
=	O
dtype	O
;	O
*	O
pst	O
=	O
(	O
*	O
pst	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
synonym	O
)	O
{	O
dtype	O
=	O
debug_name_type	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
slot	O
!=	O
NULL	O
)	O
*	O
slot	O
=	O
dtype	O
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_LOCAL_STATIC	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'v'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_parameter	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_PARM_REFERENCE	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'a'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_record_parameter	O
(	O
dhandle	O
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_PARM_REF_REG	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'X'	O
:	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	*(void)
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
string_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
stab_record_variable	O
(	O
dhandle	O
,	O
info	*(void)
,	O
name	*(char)
,	O
dtype	O
,	O
DEBUG_LOCAL	O
,	O
value	long
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
*	O
(	O
++	O
p	*(void)
)	O
==	O
'n'	O
&&	O
*	O
(	O
++	O
p	*(void)
)	O
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
p	*(void)
!=	O
';'	O
)	O
++	O
p	*(void)
;	O
++	O
p	*(void)
;	O
return	O
TRUE	int
;	O
}	O
default	O
:	O
bad_stab	O
(	O
string	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
parse_stab_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
type_name	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
*	O
slotp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
int	O
typenums	O
[	O
2	int
]	O
;	O
int	O
size	int
;	O
bfd_boolean	int
stringp	O
;	O
int	O
descriptor	O
;	O
debug_type	O
dtype	O
;	O
if	O
(	O
slotp	O
!=	O
NULL	O
)	O
*	O
slotp	O
=	O
NULL	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
size	int
=	O
-	O
1	int
;	O
stringp	O
=	O
FALSE	O
;	O
info	*(void)
->	O
self_crossref	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
&&	O
*	O
*	O
pp	O
!=	O
'('	O
&&	O
*	O
*	O
pp	O
!=	O
'-'	O
)	O
{	O
typenums	O
[	O
0	int
]	O
=	O
typenums	O
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
parse_stab_type_number	O
(	O
pp	O
,	O
typenums	O
,	O
p_end	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'='	O
)	O
return	O
stab_find_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
typenums	O
)	O
;	O
if	O
(	O
slotp	O
!=	O
NULL	O
&&	O
typenums	O
[	O
0	int
]	O
>=	O
0	int
&&	O
typenums	O
[	O
1	int
]	O
>=	O
0	int
)	O
*	O
slotp	O
=	O
stab_find_slot	O
(	O
info	*(void)
,	O
typenums	O
)	O
;	O
++	O
*	O
pp	O
;	O
while	O
(	O
*	O
*	O
pp	O
==	O
'@'	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
*	O
pp	O
+	O
1	int
;	O
const	O
char	O
*	O
attr	O
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
||	O
*	O
p	*(void)
==	O
'('	O
||	O
*	O
p	*(void)
==	O
'-'	O
)	O
break	O
;	O
attr	O
=	O
p	*(void)
;	O
for	O
(	O
;	O
*	O
p	*(void)
!=	O
';'	O
;	O
++	O
p	*(void)
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'\0'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
}	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
switch	O
(	O
*	O
attr	O
)	O
{	O
case	O
's'	O
:	O
size	int
=	O
atoi	(*(char))->(int)
(	O
attr	O
+	O
1	int
)	O
;	O
size	int
/=	O
8	int
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
size	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
stringp	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
descriptor	O
=	O
*	O
*	O
pp	O
;	O
++	O
*	O
pp	O
;	O
switch	O
(	O
descriptor	O
)	O
{	O
case	O
'x'	O
:	O
{	O
enum	O
debug_type_kind	O
code	int
;	O
const	O
char	O
*	O
q1	O
,	O
*	O
q2	O
,	O
*	O
p	*(void)
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
's'	O
:	O
code	int
=	O
DEBUG_KIND_STRUCT	O
;	O
break	O
;	O
case	O
'u'	O
:	O
code	int
=	O
DEBUG_KIND_UNION	O
;	O
break	O
;	O
case	O
'e'	O
:	O
code	int
=	O
DEBUG_KIND_ENUM	O
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unrecognized cross reference type"	*(char)
)	O
)	O
;	O
code	int
=	O
DEBUG_KIND_STRUCT	O
;	O
break	O
;	O
}	O
++	O
*	O
pp	O
;	O
q1	O
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
pp	O
,	O
'<'	O
)	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
pp	O
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
q1	O
!=	O
NULL	O
&&	O
p	*(void)
>	O
q1	O
&&	O
p	*(void)
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
int	O
nest	O
=	O
0	int
;	O
for	O
(	O
q2	O
=	O
q1	O
;	O
*	O
q2	O
!=	O
'\0'	O
;	O
++	O
q2	O
)	O
{	O
if	O
(	O
*	O
q2	O
==	O
'<'	O
)	O
++	O
nest	O
;	O
else	O
if	O
(	O
*	O
q2	O
==	O
'>'	O
)	O
--	O
nest	O
;	O
else	O
if	O
(	O
*	O
q2	O
==	O
':'	O
&&	O
nest	O
==	O
0	int
)	O
break	O
;	O
}	O
p	*(void)
=	O
q2	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
':'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
}	O
if	O
(	O
type_name	O
!=	O
NULL	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
type_name	O
,	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
==	O
0	int
&&	O
type_name	O
[	O
p	*(void)
-	O
*	O
pp	O
]	O
==	O
'\0'	O
)	O
info	*(void)
->	O
self_crossref	O
=	O
TRUE	int
;	O
dtype	O
=	O
stab_find_tagged_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
,	O
code	int
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
}	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'('	O
:	O
{	O
const	O
char	O
*	O
hold	O
;	O
int	O
xtypenums	O
[	O
2	int
]	O
;	O
(	O
*	O
pp	O
)	O
--	O
;	O
hold	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
parse_stab_type_number	O
(	O
pp	O
,	O
xtypenums	O
,	O
p_end	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	O
[	O
0	int
]	O
==	O
xtypenums	O
[	O
0	int
]	O
&&	O
typenums	O
[	O
1	int
]	O
==	O
xtypenums	O
[	O
1	int
]	O
)	O
{	O
dtype	O
=	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
}	O
else	O
{	O
*	O
pp	O
=	O
hold	O
;	O
dtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
typenums	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
stab_record_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
typenums	O
,	O
dtype	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
'*'	O
:	O
dtype	O
=	O
debug_make_pointer_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
dtype	O
=	O
(	O
debug_make_reference_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
dtype	O
=	O
(	O
debug_make_function_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
,	O
FALSE	O
)	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
dtype	O
=	O
debug_make_const_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
dtype	O
=	O
(	O
debug_make_volatile_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'@'	O
:	O
{	O
debug_type	O
domain	O
;	O
debug_type	O
memtype	O
;	O
domain	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
domain	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
memtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
memtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
dtype	O
=	O
debug_make_offset_type	O
(	O
dhandle	O
,	O
domain	O
,	O
memtype	O
)	O
;	O
}	O
break	O
;	O
case	O
'#'	O
:	O
if	O
(	O
*	O
*	O
pp	O
==	O
'#'	O
)	O
{	O
debug_type	O
return_type	O
;	O
++	O
*	O
pp	O
;	O
return_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
return_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
dtype	O
=	O
debug_make_method_type	O
(	O
dhandle	O
,	O
return_type	O
,	O
DEBUG_TYPE_NULL	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
debug_type	O
domain	O
;	O
debug_type	O
return_type	O
;	O
debug_type	O
*	O
args	O
;	O
unsigned	O
int	O
n	O
;	O
unsigned	O
int	O
alloc	O
;	O
bfd_boolean	int
varargs	O
;	O
domain	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
domain	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
return_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
return_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
alloc	O
=	O
10	int
;	O
args	O
=	O
(	O
debug_type	O
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
args	O
)	O
;	O
n	O
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
n	O
+	O
1	int
>=	O
alloc	O
)	O
{	O
alloc	O
+=	O
10	int
;	O
args	O
=	O
(	O
(	O
debug_type	O
*	O
)	O
xrealloc	O
(	O
args	O
,	O
alloc	O
*	O
sizeof	O
*	O
args	O
)	O
)	O
;	O
}	O
args	O
[	O
n	O
]	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
args	O
[	O
n	O
]	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
++	O
n	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
n	O
==	O
0	int
||	O
debug_get_type_kind	O
(	O
dhandle	O
,	O
args	O
[	O
n	O
-	O
1	int
]	O
)	O
!=	O
DEBUG_KIND_VOID	O
)	O
varargs	O
=	O
TRUE	int
;	O
else	O
{	O
--	O
n	O
;	O
varargs	O
=	O
FALSE	O
;	O
}	O
args	O
[	O
n	O
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
dtype	O
=	O
debug_make_method_type	O
(	O
dhandle	O
,	O
return_type	O
,	O
domain	O
,	O
args	O
,	O
varargs	O
)	O
;	O
}	O
break	O
;	O
case	O
'r'	O
:	O
dtype	O
=	O
parse_stab_range_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
type_name	O
,	O
pp	O
,	O
typenums	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
dtype	O
=	O
parse_stab_sun_builtin_type	O
(	O
dhandle	O
,	O
pp	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
dtype	O
=	O
parse_stab_sun_floating_type	O
(	O
dhandle	O
,	O
pp	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
dtype	O
=	O
parse_stab_enum_type	O
(	O
dhandle	O
,	O
pp	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'u'	O
:	O
dtype	O
=	O
parse_stab_struct_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
type_name	O
,	O
pp	O
,	O
descriptor	O
==	O
's'	O
,	O
typenums	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'r'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
dtype	O
=	O
parse_stab_array_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
stringp	O
,	O
p_end	O
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
dtype	O
=	O
debug_make_set_type	O
(	O
dhandle	O
,	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
,	O
stringp	O
)	O
;	O
break	O
;	O
default	O
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
dtype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
stab_record_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
typenums	O
,	O
dtype	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
size	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
debug_record_type_size	O
(	O
dhandle	O
,	O
dtype	O
,	O
(	O
unsigned	O
int	O
)	O
size	int
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
return	O
dtype	O
;	O
}	O
static	O
bfd_boolean	int
parse_stab_type_number	O
(	O
const	O
char	O
*	O
*	O
pp	O
,	O
int	O
*	O
typenums	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'('	O
)	O
{	O
typenums	O
[	O
0	int
]	O
=	O
0	int
;	O
typenums	O
[	O
1	int
]	O
=	O
(	O
int	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
++	O
*	O
pp	O
;	O
typenums	O
[	O
0	int
]	O
=	O
(	O
int	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
typenums	O
[	O
1	int
]	O
=	O
(	O
int	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
')'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
parse_stab_range_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
type_name	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
int	O
*	O
typenums	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
int	O
rangenums	O
[	O
2	int
]	O
;	O
bfd_boolean	int
self_subrange	O
;	O
debug_type	O
index_type	O
;	O
const	O
char	O
*	O
s2	O
,	O
*	O
s3	O
;	O
bfd_signed_vma	long
n2	O
,	O
n3	O
;	O
bfd_boolean	int
ov2	O
,	O
ov3	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
index_type	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
!	O
parse_stab_type_number	O
(	O
pp	O
,	O
rangenums	O
,	O
p_end	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
self_subrange	O
=	O
(	O
rangenums	O
[	O
0	int
]	O
==	O
typenums	O
[	O
0	int
]	O
&&	O
rangenums	O
[	O
1	int
]	O
==	O
typenums	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'='	O
)	O
{	O
*	O
pp	O
=	O
orig	O
;	O
index_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
==	O
';'	O
)	O
++	O
*	O
pp	O
;	O
s2	O
=	O
*	O
pp	O
;	O
n2	O
=	O
parse_number	O
(	O
pp	O
,	O
&	O
ov2	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
s3	O
=	O
*	O
pp	O
;	O
n3	O
=	O
parse_number	O
(	O
pp	O
,	O
&	O
ov3	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
ov2	O
||	O
ov3	O
)	O
{	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
s2	O
,	O
LLLOW	O
)	O
&&	O
CONST_STRNEQ	O
(	O
s3	O
,	O
LLHIGH	O
)	O
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
ov2	O
&&	O
n2	O
==	O
0	int
&&	O
CONST_STRNEQ	O
(	O
s3	O
,	O
ULLHIGH	O
)	O
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"numeric overflow"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
self_subrange	O
&&	O
n2	O
==	O
0	int
&&	O
n3	O
==	O
0	int
)	O
return	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
if	O
(	O
self_subrange	O
&&	O
n3	O
==	O
0	int
&&	O
n2	O
>	O
0	int
)	O
return	O
debug_make_complex_type	O
(	O
dhandle	O
,	O
n2	O
)	O
;	O
if	O
(	O
n3	O
==	O
0	int
&&	O
n2	O
>	O
0	int
)	O
return	O
debug_make_float_type	O
(	O
dhandle	O
,	O
n2	O
)	O
;	O
if	O
(	O
n2	O
==	O
0	int
&&	O
n3	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
type_name	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
type_name	O
,	O
"long long int"	*(char)
)	O
==	O
0	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
type_name	O
,	O
"long long unsigned int"	*(char)
)	O
==	O
0	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
}	O
if	O
(	O
self_subrange	O
&&	O
n2	O
==	O
0	int
&&	O
n3	O
==	O
127	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
n2	O
==	O
0	int
)	O
{	O
if	O
(	O
n3	O
<	O
0	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
-	O
n3	O
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
0xff	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
0xffff	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
(	O
bfd_signed_vma	long
)	O
0xffffffff	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
(	O
bfd_signed_vma	long
)	O
0xffffffffffffffffLL	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
else	O
if	O
(	O
n3	O
==	O
0	int
&&	O
n2	O
<	O
0	int
&&	O
(	O
self_subrange	O
||	O
n2	O
==	O
-	O
8	int
)	O
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
-	O
n2	O
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n2	O
==	O
-	O
n3	O
-	O
1	int
||	O
n2	O
==	O
n3	O
+	O
1	int
)	O
{	O
if	O
(	O
n3	O
==	O
0x7f	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
0x7fff	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
0x7fffffff	int
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
n3	O
==	O
(	O
(	O
(	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
)	O
<<	O
32	int
)	O
|	O
0xffffffff	int
)	O
)	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
}	O
}	O
if	O
(	O
self_subrange	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
index_type	O
=	O
stab_find_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
rangenums	O
)	O
;	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"missing index type"	*(char)
)	O
)	O
;	O
index_type	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
}	O
return	O
debug_make_range_type	O
(	O
dhandle	O
,	O
index_type	O
,	O
n2	O
,	O
n3	O
)	O
;	O
}	O
static	O
debug_type	O
parse_stab_sun_builtin_type	O
(	O
void	O
*	O
dhandle	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
bfd_boolean	int
unsignedp	O
;	O
bfd_vma	long
bits	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
's'	O
:	O
unsignedp	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'u'	O
:	O
unsignedp	O
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'c'	O
||	O
*	O
*	O
pp	O
==	O
'b'	O
||	O
*	O
*	O
pp	O
==	O
'v'	O
)	O
++	O
*	O
pp	O
;	O
(	O
void	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
(	O
void	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
bits	O
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
';'	O
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
bits	O
==	O
0	int
)	O
return	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
return	O
debug_make_int_type	O
(	O
dhandle	O
,	O
bits	O
/	O
8	int
,	O
unsignedp	O
)	O
;	O
}	O
static	O
debug_type	O
parse_stab_sun_floating_type	O
(	O
void	O
*	O
dhandle	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
bfd_vma	long
details	O
;	O
bfd_vma	long
bytes	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
details	O
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
bytes	O
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
details	O
==	O
NF_COMPLEX	O
||	O
details	O
==	O
NF_COMPLEX16	O
||	O
details	O
==	O
NF_COMPLEX32	O
)	O
return	O
debug_make_complex_type	O
(	O
dhandle	O
,	O
bytes	O
)	O
;	O
return	O
debug_make_float_type	O
(	O
dhandle	O
,	O
bytes	O
)	O
;	O
}	O
static	O
debug_type	O
parse_stab_enum_type	O
(	O
void	O
*	O
dhandle	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
const	O
char	O
*	O
*	O
names	O
;	O
bfd_signed_vma	long
*	O
values	O
;	O
unsigned	O
int	O
n	O
;	O
unsigned	O
int	O
alloc	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'-'	O
)	O
{	O
while	O
(	O
*	O
*	O
pp	O
!=	O
':'	O
&&	O
*	O
*	O
pp	O
!=	O
0	int
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
0	int
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
}	O
alloc	O
=	O
10	int
;	O
names	O
=	O
(	O
const	O
char	O
*	O
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
names	O
)	O
;	O
values	O
=	O
(	O
bfd_signed_vma	long
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
values	O
)	O
;	O
n	O
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
'\0'	O
&&	O
*	O
*	O
pp	O
!=	O
';'	O
&&	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
name	*(char)
;	O
bfd_signed_vma	long
val	array(int)
;	O
p	*(void)
=	O
*	O
pp	O
;	O
while	O
(	O
*	O
p	*(void)
!=	O
':'	O
&&	O
*	O
p	*(void)
!=	O
0	int
)	O
++	O
p	*(void)
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
names	O
)	O
;	O
free	(*(void))->(void)
(	O
values	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
val	array(int)
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
names	O
)	O
;	O
free	(*(void))->(void)
(	O
values	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
n	O
+	O
1	int
>=	O
alloc	O
)	O
{	O
alloc	O
+=	O
10	int
;	O
names	O
=	O
(	O
(	O
const	O
char	O
*	O
*	O
)	O
xrealloc	O
(	O
names	O
,	O
alloc	O
*	O
sizeof	O
*	O
names	O
)	O
)	O
;	O
values	O
=	O
(	O
(	O
bfd_signed_vma	long
*	O
)	O
xrealloc	O
(	O
values	O
,	O
alloc	O
*	O
sizeof	O
*	O
values	O
)	O
)	O
;	O
}	O
names	O
[	O
n	O
]	O
=	O
name	*(char)
;	O
values	O
[	O
n	O
]	O
=	O
val	array(int)
;	O
++	O
n	O
;	O
}	O
names	O
[	O
n	O
]	O
=	O
NULL	O
;	O
values	O
[	O
n	O
]	O
=	O
0	int
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
';'	O
)	O
++	O
*	O
pp	O
;	O
return	O
debug_make_enum_type	O
(	O
dhandle	O
,	O
names	O
,	O
values	O
)	O
;	O
}	O
static	O
debug_type	O
parse_stab_struct_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
tagname	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
bfd_boolean	int
structp	O
,	O
const	O
int	O
*	O
typenums	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
bfd_vma	long
size	int
;	O
debug_baseclass	O
*	O
baseclasses	O
;	O
debug_field	O
*	O
fields	O
=	O
NULL	O
;	O
bfd_boolean	int
statics	O
;	O
debug_method	O
*	O
methods	O
;	O
debug_type	O
vptrbase	O
;	O
bfd_boolean	int
ownvptr	O
;	O
size	int
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
!	O
parse_stab_baseclasses	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
&	O
baseclasses	O
,	O
p_end	O
)	O
||	O
!	O
parse_stab_struct_fields	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
&	O
fields	O
,	O
&	O
statics	O
,	O
p_end	O
)	O
||	O
!	O
parse_stab_members	O
(	O
dhandle	O
,	O
info	*(void)
,	O
tagname	O
,	O
pp	O
,	O
typenums	O
,	O
&	O
methods	O
,	O
p_end	O
)	O
||	O
!	O
parse_stab_tilde_field	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
typenums	O
,	O
&	O
vptrbase	O
,	O
&	O
ownvptr	O
,	O
p_end	O
)	O
)	O
{	O
if	O
(	O
fields	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
fields	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
!	O
statics	O
&&	O
baseclasses	O
==	O
NULL	O
&&	O
methods	O
==	O
NULL	O
&&	O
vptrbase	O
==	O
DEBUG_TYPE_NULL	O
&&	O
!	O
ownvptr	O
)	O
return	O
debug_make_struct_type	O
(	O
dhandle	O
,	O
structp	O
,	O
size	int
,	O
fields	O
)	O
;	O
return	O
debug_make_object_type	O
(	O
dhandle	O
,	O
structp	O
,	O
size	int
,	O
fields	O
,	O
baseclasses	O
,	O
methods	O
,	O
vptrbase	O
,	O
ownvptr	O
)	O
;	O
}	O
static	O
bfd_boolean	int
parse_stab_baseclasses	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_baseclass	O
*	O
*	O
retp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
unsigned	O
int	O
c	O
,	O
i	*(struct)
;	O
debug_baseclass	O
*	O
classes	O
;	O
*	O
retp	O
=	O
NULL	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'!'	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
++	O
*	O
pp	O
;	O
c	O
=	O
(	O
unsigned	O
int	O
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
classes	O
=	O
(	O
debug_baseclass	O
*	O
)	O
xmalloc	O
(	O
(	O
c	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
*	O
retp	O
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
c	O
;	O
i	*(struct)
++	O
)	O
{	O
bfd_boolean	int
is_virtual	O
;	O
enum	O
debug_visibility	O
visibility	O
;	O
bfd_vma	long
bitpos	int
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'0'	O
:	O
is_virtual	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'1'	O
:	O
is_virtual	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unknown virtual character for baseclass"	*(char)
)	O
)	O
;	O
is_virtual	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
++	O
*	O
pp	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'0'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PRIVATE	O
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PROTECTED	O
;	O
break	O
;	O
case	O
'2'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unknown visibility character for baseclass"	*(char)
)	O
)	O
;	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
break	O
;	O
}	O
++	O
*	O
pp	O
;	O
bitpos	int
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
type	enum(int,int,int,int)
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
classes	O
[	O
i	*(struct)
]	O
=	O
debug_make_baseclass	O
(	O
dhandle	O
,	O
type	enum(int,int,int,int)
,	O
bitpos	int
,	O
is_virtual	O
,	O
visibility	O
)	O
;	O
if	O
(	O
classes	O
[	O
i	*(struct)
]	O
==	O
DEBUG_BASECLASS_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
return	O
FALSE	O
;	O
++	O
*	O
pp	O
;	O
}	O
classes	O
[	O
i	*(struct)
]	O
=	O
DEBUG_BASECLASS_NULL	O
;	O
*	O
retp	O
=	O
classes	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_struct_fields	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_field	O
*	O
*	O
retp	O
,	O
bfd_boolean	int
*	O
staticsp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
const	O
char	O
*	O
p	*(void)
;	O
debug_field	O
*	O
fields	O
;	O
unsigned	O
int	O
c	O
;	O
unsigned	O
int	O
alloc	O
;	O
*	O
retp	O
=	O
NULL	O
;	O
*	O
staticsp	O
=	O
FALSE	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
c	O
=	O
0	int
;	O
alloc	O
=	O
10	int
;	O
fields	O
=	O
(	O
debug_field	O
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
fields	O
)	O
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
p	*(void)
=	O
*	O
pp	O
;	O
if	O
(	O
c	O
+	O
1	int
>=	O
alloc	O
)	O
{	O
alloc	O
+=	O
10	int
;	O
fields	O
=	O
(	O
(	O
debug_field	O
*	O
)	O
xrealloc	O
(	O
fields	O
,	O
alloc	O
*	O
sizeof	O
*	O
fields	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
*	O
p	*(void)
==	O
'$'	O
||	O
*	O
p	*(void)
==	O
'.'	O
)	O
&&	O
p	*(void)
[	O
1	int
]	O
!=	O
'_'	O
)	O
{	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
parse_stab_cpp_abbrev	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
fields	O
+	O
c	O
,	O
p_end	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
fields	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
c	O
;	O
continue	O
;	O
}	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
fields	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
':'	O
)	O
break	O
;	O
if	O
(	O
!	O
parse_stab_one_struct_field	O
(	O
dhandle	O
,	O
info	*(void)
,	O
pp	O
,	O
p	*(void)
,	O
fields	O
+	O
c	O
,	O
staticsp	O
,	O
p_end	O
)	O
)	O
return	O
FALSE	O
;	O
++	O
c	O
;	O
}	O
fields	O
[	O
c	O
]	O
=	O
DEBUG_FIELD_NULL	O
;	O
*	O
retp	O
=	O
fields	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_cpp_abbrev	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_field	O
*	O
retp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
int	O
cpp_abbrev	O
;	O
debug_type	O
context	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
type_name	O
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_vma	long
bitpos	int
;	O
*	O
retp	O
=	O
DEBUG_FIELD_NULL	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'v'	O
)	O
{	O
bad_stab	O
(	O
*	O
pp	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
cpp_abbrev	O
=	O
*	O
*	O
pp	O
;	O
if	O
(	O
cpp_abbrev	O
==	O
0	int
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
context	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
context	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
switch	O
(	O
cpp_abbrev	O
)	O
{	O
case	O
'f'	O
:	O
name	*(char)
=	O
"_vptr$"	*(char)
;	O
break	O
;	O
case	O
'b'	O
:	O
type_name	O
=	O
debug_get_type_name	O
(	O
dhandle	O
,	O
context	O
)	O
;	O
if	O
(	O
type_name	O
==	O
NULL	O
)	O
{	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unnamed $vb type"	*(char)
)	O
)	O
;	O
type_name	O
=	O
"FOO"	*(char)
;	O
}	O
name	*(char)
=	O
concat	O
(	O
"_vb$"	*(char)
,	O
type_name	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unrecognized C++ abbreviation"	*(char)
)	O
)	O
;	O
name	*(char)
=	O
"INVALID_CPLUSPLUS_ABBREV"	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
':'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
type	enum(int,int,int,int)
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
bitpos	int
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
*	O
retp	O
=	O
debug_make_field	O
(	O
dhandle	O
,	O
name	*(char)
,	O
type	enum(int,int,int,int)
,	O
bitpos	int
,	O
0	int
,	O
DEBUG_VISIBILITY_PRIVATE	O
)	O
;	O
if	O
(	O
*	O
retp	O
==	O
DEBUG_FIELD_NULL	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_one_struct_field	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
p	*(void)
,	O
debug_field	O
*	O
retp	O
,	O
bfd_boolean	int
*	O
staticsp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
char	O
*	O
name	*(char)
;	O
enum	O
debug_visibility	O
visibility	O
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_vma	long
bitpos	int
;	O
bfd_vma	long
bitsize	int
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'/'	O
)	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
else	O
{	O
++	O
*	O
pp	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'0'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PRIVATE	O
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PROTECTED	O
;	O
break	O
;	O
case	O
'2'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"unknown visibility character for field"	*(char)
)	O
)	O
;	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
break	O
;	O
}	O
++	O
*	O
pp	O
;	O
}	O
type	enum(int,int,int,int)
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
==	O
':'	O
)	O
{	O
char	O
*	O
varname	O
;	O
++	O
*	O
pp	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
pp	O
,	O
';'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
varname	O
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
*	O
retp	O
=	O
debug_make_static_member	O
(	O
dhandle	O
,	O
name	*(char)
,	O
type	enum(int,int,int,int)
,	O
varname	O
,	O
visibility	O
)	O
;	O
*	O
staticsp	O
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
bitpos	int
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
','	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
bitsize	int
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
bitpos	int
==	O
0	int
&&	O
bitsize	int
==	O
0	int
)	O
{	O
visibility	O
=	O
DEBUG_VISIBILITY_IGNORE	O
;	O
}	O
*	O
retp	O
=	O
debug_make_field	O
(	O
dhandle	O
,	O
name	*(char)
,	O
type	enum(int,int,int,int)
,	O
bitpos	int
,	O
bitsize	int
,	O
visibility	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_members	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
tagname	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
int	O
*	O
typenums	O
,	O
debug_method	O
*	O
*	O
retp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
debug_method	O
*	O
methods	O
;	O
unsigned	O
int	O
c	O
;	O
unsigned	O
int	O
alloc	O
;	O
char	O
*	O
name	*(char)
=	O
NULL	O
;	O
debug_method_variant	O
*	O
variants	O
=	O
NULL	O
;	O
char	O
*	O
argtypes	O
=	O
NULL	O
;	O
*	O
retp	O
=	O
NULL	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
alloc	O
=	O
0	int
;	O
methods	O
=	O
NULL	O
;	O
c	O
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
unsigned	O
int	O
cvars	O
;	O
unsigned	O
int	O
allocvars	O
;	O
debug_type	O
look_ahead_type	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
pp	O
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
||	O
p	*(void)
[	O
1	int
]	O
!=	O
':'	O
)	O
break	O
;	O
if	O
(	O
(	O
*	O
pp	O
)	O
[	O
0	int
]	O
!=	O
'o'	O
||	O
(	O
*	O
pp	O
)	O
[	O
1	int
]	O
!=	O
'p'	O
||	O
(	O
*	O
pp	O
)	O
[	O
2	int
]	O
!=	O
'$'	O
)	O
{	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
2	int
;	O
}	O
else	O
{	O
*	O
pp	O
=	O
p	*(void)
+	O
2	int
;	O
for	O
(	O
p	*(void)
=	O
*	O
pp	O
;	O
*	O
p	*(void)
!=	O
'.'	O
&&	O
*	O
p	*(void)
!=	O
'\0'	O
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
'.'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
}	O
allocvars	O
=	O
10	int
;	O
variants	O
=	O
(	O
(	O
debug_method_variant	O
*	O
)	O
xmalloc	O
(	O
allocvars	O
*	O
sizeof	O
*	O
variants	O
)	O
)	O
;	O
cvars	O
=	O
0	int
;	O
look_ahead_type	O
=	O
DEBUG_TYPE_NULL	O
;	O
do	O
{	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_boolean	int
stub	O
;	O
enum	O
debug_visibility	O
visibility	O
;	O
bfd_boolean	int
constp	O
,	O
volatilep	O
,	O
staticp	O
;	O
bfd_vma	long
voffset	O
;	O
debug_type	O
context	O
;	O
const	O
char	O
*	O
physname	O
;	O
bfd_boolean	int
varargs	O
;	O
if	O
(	O
look_ahead_type	O
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
type	enum(int,int,int,int)
=	O
look_ahead_type	O
;	O
look_ahead_type	O
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
type	enum(int,int,int,int)
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
':'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
}	O
++	O
*	O
pp	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
pp	O
,	O
';'	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
stub	O
=	O
FALSE	O
;	O
if	O
(	O
debug_get_type_kind	O
(	O
dhandle	O
,	O
type	enum(int,int,int,int)
)	O
==	O
DEBUG_KIND_METHOD	O
&&	O
debug_get_parameter_types	O
(	O
dhandle	O
,	O
type	enum(int,int,int,int)
,	O
&	O
varargs	O
)	O
==	O
NULL	O
)	O
stub	O
=	O
TRUE	int
;	O
argtypes	O
=	O
savestring	O
(	O
*	O
pp	O
,	O
p	*(void)
-	O
*	O
pp	O
)	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'0'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PRIVATE	O
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PROTECTED	O
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
default	O
:	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
break	O
;	O
}	O
++	O
*	O
pp	O
;	O
constp	O
=	O
FALSE	O
;	O
volatilep	O
=	O
FALSE	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'A'	O
:	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'B'	O
:	O
constp	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'C'	O
:	O
volatilep	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'D'	O
:	O
constp	O
=	O
TRUE	int
;	O
volatilep	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'*'	O
:	O
case	O
'?'	O
:	O
case	O
'.'	O
:	O
break	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
_	O
(	O
"const/volatile indicator missing"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
staticp	O
=	O
FALSE	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'*'	O
:	O
++	O
*	O
pp	O
;	O
voffset	O
=	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
++	O
*	O
pp	O
;	O
voffset	O
&=	O
0x7fffffff	int
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
';'	O
||	O
*	O
*	O
pp	O
==	O
'\0'	O
)	O
{	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
look_ahead_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
':'	O
)	O
{	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
context	O
=	O
look_ahead_type	O
;	O
look_ahead_type	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
++	O
*	O
pp	O
;	O
}	O
}	O
break	O
;	O
case	O
'?'	O
:	O
++	O
*	O
pp	O
;	O
staticp	O
=	O
TRUE	int
;	O
voffset	O
=	O
0	int
;	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argtypes	O
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
)	O
!=	O
0	int
)	O
stub	O
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
warn_stab	O
(	O
orig	O
,	O
"member function type missing"	*(char)
)	O
;	O
voffset	O
=	O
0	int
;	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
break	O
;	O
case	O
'.'	O
:	O
++	O
*	O
pp	O
;	O
voffset	O
=	O
0	int
;	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
break	O
;	O
}	O
physname	O
=	O
argtypes	O
;	O
if	O
(	O
stub	O
)	O
{	O
debug_type	O
class_type	O
,	O
return_type	O
;	O
class_type	O
=	O
stab_find_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
typenums	O
)	O
;	O
if	O
(	O
class_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
return_type	O
=	O
debug_get_return_type	O
(	O
dhandle	O
,	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
return_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
goto	O
fail	O
;	O
}	O
type	enum(int,int,int,int)
=	O
parse_stab_argtypes	O
(	O
dhandle	O
,	O
info	*(void)
,	O
class_type	O
,	O
name	*(char)
,	O
tagname	O
,	O
return_type	O
,	O
argtypes	O
,	O
constp	O
,	O
volatilep	O
,	O
&	O
physname	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
}	O
if	O
(	O
cvars	O
+	O
1	int
>=	O
allocvars	O
)	O
{	O
allocvars	O
+=	O
10	int
;	O
variants	O
=	O
(	O
(	O
debug_method_variant	O
*	O
)	O
xrealloc	O
(	O
variants	O
,	O
allocvars	O
*	O
sizeof	O
*	O
variants	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
staticp	O
)	O
variants	O
[	O
cvars	O
]	O
=	O
debug_make_method_variant	O
(	O
dhandle	O
,	O
physname	O
,	O
type	enum(int,int,int,int)
,	O
visibility	O
,	O
constp	O
,	O
volatilep	O
,	O
voffset	O
,	O
context	O
)	O
;	O
else	O
variants	O
[	O
cvars	O
]	O
=	O
debug_make_static_method_variant	O
(	O
dhandle	O
,	O
physname	O
,	O
type	enum(int,int,int,int)
,	O
visibility	O
,	O
constp	O
,	O
volatilep	O
)	O
;	O
if	O
(	O
variants	O
[	O
cvars	O
]	O
==	O
DEBUG_METHOD_VARIANT_NULL	O
)	O
goto	O
fail	O
;	O
++	O
cvars	O
;	O
}	O
while	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
&&	O
*	O
*	O
pp	O
!=	O
'\0'	O
)	O
;	O
variants	O
[	O
cvars	O
]	O
=	O
DEBUG_METHOD_VARIANT_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'\0'	O
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
c	O
+	O
1	int
>=	O
alloc	O
)	O
{	O
alloc	O
+=	O
10	int
;	O
methods	O
=	O
(	O
(	O
debug_method	O
*	O
)	O
xrealloc	O
(	O
methods	O
,	O
alloc	O
*	O
sizeof	O
*	O
methods	O
)	O
)	O
;	O
}	O
methods	O
[	O
c	O
]	O
=	O
debug_make_method	O
(	O
dhandle	O
,	O
name	*(char)
,	O
variants	O
)	O
;	O
++	O
c	O
;	O
}	O
if	O
(	O
methods	O
!=	O
NULL	O
)	O
methods	O
[	O
c	O
]	O
=	O
DEBUG_METHOD_NULL	O
;	O
*	O
retp	O
=	O
methods	O
;	O
return	O
TRUE	int
;	O
fail	O
:	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
variants	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
variants	O
)	O
;	O
if	O
(	O
argtypes	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
argtypes	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
debug_type	O
parse_stab_argtypes	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
debug_type	O
class_type	O
,	O
const	O
char	O
*	O
fieldname	O
,	O
const	O
char	O
*	O
tagname	O
,	O
debug_type	O
return_type	O
,	O
const	O
char	O
*	O
argtypes	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
,	O
const	O
char	O
*	O
*	O
pphysname	O
)	O
{	O
bfd_boolean	int
is_full_physname_constructor	O
;	O
bfd_boolean	int
is_constructor	O
;	O
bfd_boolean	int
is_destructor	O
;	O
bfd_boolean	int
is_v3	O
;	O
debug_type	O
*	O
args	O
;	O
bfd_boolean	int
varargs	O
;	O
unsigned	O
int	O
physname_len	O
=	O
0	int
;	O
is_full_physname_constructor	O
=	O
(	O
(	O
argtypes	O
[	O
0	int
]	O
==	O
'_'	O
&&	O
argtypes	O
[	O
1	int
]	O
==	O
'_'	O
&&	O
(	O
ISDIGIT	O
(	O
argtypes	O
[	O
2	int
]	O
)	O
||	O
argtypes	O
[	O
2	int
]	O
==	O
'Q'	O
||	O
argtypes	O
[	O
2	int
]	O
==	O
't'	O
)	O
)	O
||	O
CONST_STRNEQ	O
(	O
argtypes	O
,	O
"__ct"	*(char)
)	O
)	O
;	O
is_constructor	O
=	O
(	O
is_full_physname_constructor	O
||	O
(	O
tagname	O
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
fieldname	O
,	O
tagname	O
)	O
==	O
0	int
)	O
)	O
;	O
is_destructor	O
=	O
(	O
(	O
argtypes	O
[	O
0	int
]	O
==	O
'_'	O
&&	O
(	O
argtypes	O
[	O
1	int
]	O
==	O
'$'	O
||	O
argtypes	O
[	O
1	int
]	O
==	O
'.'	O
)	O
&&	O
argtypes	O
[	O
2	int
]	O
==	O
'_'	O
)	O
||	O
CONST_STRNEQ	O
(	O
argtypes	O
,	O
"__dt"	*(char)
)	O
)	O
;	O
is_v3	O
=	O
argtypes	O
[	O
0	int
]	O
==	O
'_'	O
&&	O
argtypes	O
[	O
1	int
]	O
==	O
'Z'	O
;	O
if	O
(	O
!	O
(	O
is_destructor	O
||	O
is_full_physname_constructor	O
||	O
is_v3	O
)	O
)	O
{	O
unsigned	O
int	O
len	long
;	O
const	O
char	O
*	O
const_prefix	O
;	O
const	O
char	O
*	O
volatile_prefix	O
;	O
char	O
buf	*(void)
[	O
20	int
]	O
;	O
unsigned	O
int	O
mangled_name_len	O
;	O
char	O
*	O
physname	O
;	O
len	long
=	O
tagname	O
==	O
NULL	O
?	O
0	int
:	O
strlen	(*(char))->(long)
(	O
tagname	O
)	O
;	O
const_prefix	O
=	O
constp	O
?	O
"C"	*(char)
:	O
""	*(char)
;	O
volatile_prefix	O
=	O
volatilep	O
?	O
"V"	*(char)
:	O
""	*(char)
;	O
if	O
(	O
len	long
==	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"__%s%s"	*(char)
,	O
const_prefix	O
,	O
volatile_prefix	O
)	O
;	O
else	O
if	O
(	O
tagname	O
!=	O
NULL	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
tagname	O
,	O
'<'	O
)	O
!=	O
NULL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"__%s%s"	*(char)
,	O
const_prefix	O
,	O
volatile_prefix	O
)	O
;	O
tagname	O
=	O
NULL	O
;	O
len	long
=	O
0	int
;	O
}	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"__%s%s%d"	*(char)
,	O
const_prefix	O
,	O
volatile_prefix	O
,	O
len	long
)	O
;	O
mangled_name_len	O
=	O
(	O
(	O
is_constructor	O
?	O
0	int
:	O
strlen	(*(char))->(long)
(	O
fieldname	O
)	O
)	O
+	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
+	O
len	long
+	O
strlen	(*(char))->(long)
(	O
argtypes	O
)	O
+	O
1	int
)	O
;	O
if	O
(	O
fieldname	O
[	O
0	int
]	O
==	O
'o'	O
&&	O
fieldname	O
[	O
1	int
]	O
==	O
'p'	O
&&	O
(	O
fieldname	O
[	O
2	int
]	O
==	O
'$'	O
||	O
fieldname	O
[	O
2	int
]	O
==	O
'.'	O
)	O
)	O
{	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
physname	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
mangled_name_len	O
)	O
;	O
if	O
(	O
is_constructor	O
)	O
physname	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
physname	O
,	O
fieldname	O
)	O
;	O
physname_len	O
=	O
strlen	(*(char))->(long)
(	O
physname	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
physname	O
,	O
buf	*(void)
)	O
;	O
if	O
(	O
tagname	O
!=	O
NULL	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
physname	O
,	O
tagname	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
physname	O
,	O
argtypes	O
)	O
;	O
*	O
pphysname	O
=	O
physname	O
;	O
}	O
if	O
(	O
*	O
argtypes	O
==	O
'\0'	O
||	O
is_destructor	O
)	O
{	O
args	O
=	O
(	O
debug_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
args	O
)	O
;	O
*	O
args	O
=	O
NULL	O
;	O
return	O
debug_make_method_type	O
(	O
dhandle	O
,	O
return_type	O
,	O
class_type	O
,	O
args	O
,	O
FALSE	O
)	O
;	O
}	O
args	O
=	O
stab_demangle_argtypes	O
(	O
dhandle	O
,	O
info	*(void)
,	O
*	O
pphysname	O
,	O
&	O
varargs	O
,	O
physname_len	O
)	O
;	O
if	O
(	O
args	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
return	O
debug_make_method_type	O
(	O
dhandle	O
,	O
return_type	O
,	O
class_type	O
,	O
args	O
,	O
varargs	O
)	O
;	O
}	O
static	O
bfd_boolean	int
parse_stab_tilde_field	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
int	O
*	O
typenums	O
,	O
debug_type	O
*	O
retvptrbase	O
,	O
bfd_boolean	int
*	O
retownvptr	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
const	O
char	O
*	O
hold	O
;	O
int	O
vtypenums	O
[	O
2	int
]	O
;	O
*	O
retvptrbase	O
=	O
DEBUG_TYPE_NULL	O
;	O
*	O
retownvptr	O
=	O
FALSE	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
';'	O
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'~'	O
)	O
return	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'='	O
||	O
*	O
*	O
pp	O
==	O
'+'	O
||	O
*	O
*	O
pp	O
==	O
'-'	O
)	O
{	O
++	O
*	O
pp	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'%'	O
)	O
return	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
hold	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
parse_stab_type_number	O
(	O
pp	O
,	O
vtypenums	O
,	O
p_end	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
vtypenums	O
[	O
0	int
]	O
==	O
typenums	O
[	O
0	int
]	O
&&	O
vtypenums	O
[	O
1	int
]	O
==	O
typenums	O
[	O
1	int
]	O
)	O
*	O
retownvptr	O
=	O
TRUE	int
;	O
else	O
{	O
debug_type	O
vtype	O
;	O
const	O
char	O
*	O
p	*(void)
;	O
*	O
pp	O
=	O
hold	O
;	O
vtype	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
*	O
pp	O
;	O
*	O
p	*(void)
!=	O
';'	O
&&	O
*	O
p	*(void)
!=	O
'\0'	O
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
*	O
retvptrbase	O
=	O
vtype	O
;	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
parse_stab_array_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
bfd_boolean	int
stringp	O
,	O
const	O
char	O
*	O
p_end	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
const	O
char	O
*	O
p	*(void)
;	O
int	O
typenums	O
[	O
2	int
]	O
;	O
debug_type	O
index_type	O
;	O
bfd_boolean	int
adjustable	O
;	O
bfd_signed_vma	long
lower	O
,	O
upper	O
;	O
debug_type	O
element_type	O
;	O
orig	O
=	O
*	O
pp	O
;	O
if	O
(	O
orig	O
>=	O
p_end	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
p	*(void)
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
parse_stab_type_number	O
(	O
&	O
p	*(void)
,	O
typenums	O
,	O
p_end	O
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	O
[	O
0	int
]	O
==	O
0	int
&&	O
typenums	O
[	O
1	int
]	O
==	O
0	int
&&	O
*	O
*	O
pp	O
!=	O
'='	O
)	O
{	O
index_type	O
=	O
debug_find_named_type	O
(	O
dhandle	O
,	O
"int"	*(char)
)	O
;	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
index_type	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
index_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
*	O
pp	O
=	O
p	*(void)
;	O
}	O
else	O
{	O
index_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
adjustable	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
&&	O
*	O
*	O
pp	O
!=	O
'-'	O
&&	O
*	O
*	O
pp	O
!=	O
0	int
)	O
{	O
++	O
*	O
pp	O
;	O
adjustable	O
=	O
TRUE	int
;	O
}	O
lower	O
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
&&	O
*	O
*	O
pp	O
!=	O
'-'	O
&&	O
*	O
*	O
pp	O
!=	O
0	int
)	O
{	O
++	O
*	O
pp	O
;	O
adjustable	O
=	O
TRUE	int
;	O
}	O
upper	O
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	O
(	O
pp	O
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
';'	O
)	O
{	O
bad_stab	O
(	O
orig	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	O
;	O
element_type	O
=	O
parse_stab_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
,	O
p_end	O
)	O
;	O
if	O
(	O
element_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
adjustable	O
)	O
{	O
lower	O
=	O
0	int
;	O
upper	O
=	O
-	O
1	int
;	O
}	O
return	O
debug_make_array_type	O
(	O
dhandle	O
,	O
element_type	O
,	O
index_type	O
,	O
lower	O
,	O
upper	O
,	O
stringp	O
)	O
;	O
}	O
struct	O
bincl_file	O
{	O
struct	O
bincl_file	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
bincl_file	O
*	O
next_stack	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
bfd_vma	long
hash	long
;	O
unsigned	O
int	O
file	*(void)
;	O
struct	O
stab_types	O
*	O
file_types	O
;	O
}	O
;	O
static	O
void	O
push_bincl	O
(	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
hash	long
)	O
{	O
struct	O
bincl_file	O
*	O
n	O
;	O
n	O
=	O
(	O
struct	O
bincl_file	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
n	O
)	O
;	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
bincl_list	O
;	O
n	O
->	O
next_stack	O
=	O
info	*(void)
->	O
bincl_stack	O
;	O
n	O
->	O
name	*(char)
=	O
name	*(char)
;	O
n	O
->	O
hash	long
=	O
hash	long
;	O
n	O
->	O
file	*(void)
=	O
info	*(void)
->	O
files	O
;	O
n	O
->	O
file_types	O
=	O
NULL	O
;	O
info	*(void)
->	O
bincl_list	O
=	O
n	O
;	O
info	*(void)
->	O
bincl_stack	O
=	O
n	O
;	O
++	O
info	*(void)
->	O
files	O
;	O
info	*(void)
->	O
file_types	O
=	O
(	O
(	O
struct	O
stab_types	O
*	O
*	O
)	O
xrealloc	O
(	O
info	*(void)
->	O
file_types	O
,	O
(	O
info	*(void)
->	O
files	O
*	O
sizeof	O
*	O
info	*(void)
->	O
file_types	O
)	O
)	O
)	O
;	O
info	*(void)
->	O
file_types	O
[	O
n	O
->	O
file	*(void)
]	O
=	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
pop_bincl	O
(	O
struct	O
stab_handle	O
*	O
info	*(void)
)	O
{	O
struct	O
bincl_file	O
*	O
o	O
;	O
o	O
=	O
info	*(void)
->	O
bincl_stack	O
;	O
if	O
(	O
o	O
==	O
NULL	O
)	O
return	O
info	*(void)
->	O
main_filename	O
;	O
info	*(void)
->	O
bincl_stack	O
=	O
o	O
->	O
next_stack	O
;	O
if	O
(	O
o	O
->	O
file	*(void)
>=	O
info	*(void)
->	O
files	O
)	O
return	O
info	*(void)
->	O
main_filename	O
;	O
o	O
->	O
file_types	O
=	O
info	*(void)
->	O
file_types	O
[	O
o	O
->	O
file	*(void)
]	O
;	O
if	O
(	O
info	*(void)
->	O
bincl_stack	O
==	O
NULL	O
)	O
return	O
info	*(void)
->	O
main_filename	O
;	O
return	O
info	*(void)
->	O
bincl_stack	O
->	O
name	*(char)
;	O
}	O
static	O
bfd_boolean	int
find_excl	O
(	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
hash	long
)	O
{	O
struct	O
bincl_file	O
*	O
l	O
;	O
++	O
info	*(void)
->	O
files	O
;	O
info	*(void)
->	O
file_types	O
=	O
(	O
(	O
struct	O
stab_types	O
*	O
*	O
)	O
xrealloc	O
(	O
info	*(void)
->	O
file_types	O
,	O
(	O
info	*(void)
->	O
files	O
*	O
sizeof	O
*	O
info	*(void)
->	O
file_types	O
)	O
)	O
)	O
;	O
for	O
(	O
l	O
=	O
info	*(void)
->	O
bincl_list	O
;	O
l	O
!=	O
NULL	O
;	O
l	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
l	O
->	O
hash	long
==	O
hash	long
&&	O
strcmp	(*(char),*(char))->(int)
(	O
l	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
l	O
==	O
NULL	O
)	O
{	O
warn_stab	O
(	O
name	*(char)
,	O
_	O
(	O
"Undefined N_EXCL"	*(char)
)	O
)	O
;	O
info	*(void)
->	O
file_types	O
[	O
info	*(void)
->	O
files	O
-	O
1	int
]	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
info	*(void)
->	O
file_types	O
[	O
info	*(void)
->	O
files	O
-	O
1	int
]	O
=	O
l	O
->	O
file_types	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_record_variable	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
enum	O
debug_var_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
stab_pending_var	O
*	O
v	O
;	O
if	O
(	O
(	O
kind	O
==	O
DEBUG_GLOBAL	O
||	O
kind	O
==	O
DEBUG_STATIC	O
)	O
||	O
!	O
info	*(void)
->	O
within_function	O
||	O
(	O
info	*(void)
->	O
gcc_compiled	O
==	O
0	int
&&	O
info	*(void)
->	O
n_opt_found	O
)	O
)	O
return	O
debug_record_variable	O
(	O
dhandle	O
,	O
name	*(char)
,	O
type	enum(int,int,int,int)
,	O
kind	O
,	O
val	array(int)
)	O
;	O
v	O
=	O
(	O
struct	O
stab_pending_var	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
v	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
v	O
,	O
0	int
,	O
sizeof	O
*	O
v	O
)	O
;	O
v	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
pending	O
;	O
v	O
->	O
name	*(char)
=	O
name	*(char)
;	O
v	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
v	O
->	O
kind	O
=	O
kind	O
;	O
v	O
->	O
val	array(int)
=	O
val	array(int)
;	O
info	*(void)
->	O
pending	O
=	O
v	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_emit_pending_vars	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
)	O
{	O
struct	O
stab_pending_var	O
*	O
v	O
;	O
v	O
=	O
info	*(void)
->	O
pending	O
;	O
while	O
(	O
v	O
!=	O
NULL	O
)	O
{	O
struct	O
stab_pending_var	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
if	O
(	O
!	O
debug_record_variable	O
(	O
dhandle	O
,	O
v	O
->	O
name	*(char)
,	O
v	O
->	O
type	enum(int,int,int,int)
,	O
v	O
->	O
kind	O
,	O
v	O
->	O
val	array(int)
)	O
)	O
return	O
FALSE	O
;	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
v	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
free	(*(void))->(void)
(	O
v	O
)	O
;	O
v	O
=	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
info	*(void)
->	O
pending	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
*	O
stab_find_slot	O
(	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
int	O
*	O
typenums	O
)	O
{	O
int	O
filenum	O
;	O
int	O
tindex	O
;	O
struct	O
stab_types	O
*	O
*	O
ps	O
;	O
filenum	O
=	O
typenums	O
[	O
0	int
]	O
;	O
tindex	O
=	O
typenums	O
[	O
1	int
]	O
;	O
if	O
(	O
filenum	O
<	O
0	int
||	O
(	O
unsigned	O
int	O
)	O
filenum	O
>=	O
info	*(void)
->	O
files	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Type file number %d out of range\n"	*(char)
)	O
,	O
filenum	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
tindex	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Type index number %d out of range\n"	*(char)
)	O
,	O
tindex	O
)	O
;	O
return	O
NULL	O
;	O
}	O
ps	O
=	O
info	*(void)
->	O
file_types	O
+	O
filenum	O
;	O
while	O
(	O
tindex	O
>=	O
STAB_TYPES_SLOTS	O
)	O
{	O
if	O
(	O
*	O
ps	O
==	O
NULL	O
)	O
{	O
*	O
ps	O
=	O
(	O
struct	O
stab_types	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
*	O
ps	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
*	O
ps	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
ps	O
)	O
;	O
}	O
ps	O
=	O
&	O
(	O
*	O
ps	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
tindex	O
-=	O
STAB_TYPES_SLOTS	O
;	O
}	O
if	O
(	O
*	O
ps	O
==	O
NULL	O
)	O
{	O
*	O
ps	O
=	O
(	O
struct	O
stab_types	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
*	O
ps	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
*	O
ps	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
ps	O
)	O
;	O
}	O
return	O
(	O
*	O
ps	O
)	O
->	O
types	O
+	O
tindex	O
;	O
}	O
static	O
debug_type	O
stab_find_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
int	O
*	O
typenums	O
)	O
{	O
debug_type	O
*	O
slot	O
;	O
if	O
(	O
typenums	O
[	O
0	int
]	O
==	O
0	int
&&	O
typenums	O
[	O
1	int
]	O
<	O
0	int
)	O
{	O
return	O
stab_xcoff_builtin_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
typenums	O
[	O
1	int
]	O
)	O
;	O
}	O
slot	O
=	O
stab_find_slot	O
(	O
info	*(void)
,	O
typenums	O
)	O
;	O
if	O
(	O
slot	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
slot	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
debug_make_indirect_type	O
(	O
dhandle	O
,	O
slot	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
*	O
slot	O
;	O
}	O
static	O
bfd_boolean	int
stab_record_type	O
(	O
void	O
*	O
dhandle	O
ATTRIBUTE_UNUSED	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
int	O
*	O
typenums	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
debug_type	O
*	O
slot	O
;	O
slot	O
=	O
stab_find_slot	O
(	O
info	*(void)
,	O
typenums	O
)	O
;	O
if	O
(	O
slot	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
*	O
slot	O
=	O
type	enum(int,int,int,int)
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
stab_xcoff_builtin_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
int	O
typenum	O
)	O
{	O
debug_type	O
rettype	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
typenum	O
>=	O
0	int
||	O
typenum	O
<	O
-	O
XCOFF_TYPE_COUNT	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Unrecognized XCOFF type %d\n"	*(char)
)	O
,	O
typenum	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
xcoff_types	O
[	O
-	O
typenum	O
]	O
!=	O
NULL	O
)	O
return	O
info	*(void)
->	O
xcoff_types	O
[	O
-	O
typenum	O
]	O
;	O
switch	O
(	O
-	O
typenum	O
)	O
{	O
case	O
1	int
:	O
name	*(char)
=	O
"int"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
name	*(char)
=	O
"char"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
name	*(char)
=	O
"short"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
name	*(char)
=	O
"long"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
name	*(char)
=	O
"unsigned char"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
6	int
:	O
name	*(char)
=	O
"signed char"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
name	*(char)
=	O
"unsigned short"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
8	int
:	O
name	*(char)
=	O
"unsigned int"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
9	int
:	O
name	*(char)
=	O
"unsigned"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
10	int
:	O
name	*(char)
=	O
"unsigned long"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
11	int
:	O
name	*(char)
=	O
"void"	*(char)
;	O
rettype	O
=	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
break	O
;	O
case	O
12	int
:	O
name	*(char)
=	O
"float"	*(char)
;	O
rettype	O
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
13	int
:	O
name	*(char)
=	O
"double"	*(char)
;	O
rettype	O
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
break	O
;	O
case	O
14	int
:	O
name	*(char)
=	O
"long double"	*(char)
;	O
rettype	O
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
break	O
;	O
case	O
15	int
:	O
name	*(char)
=	O
"integer"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
16	int
:	O
name	*(char)
=	O
"boolean"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
17	int
:	O
name	*(char)
=	O
"short real"	*(char)
;	O
rettype	O
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
18	int
:	O
name	*(char)
=	O
"real"	*(char)
;	O
rettype	O
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
break	O
;	O
case	O
19	int
:	O
name	*(char)
=	O
"stringptr"	*(char)
;	O
rettype	O
=	O
NULL	O
;	O
break	O
;	O
case	O
20	int
:	O
name	*(char)
=	O
"character"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
21	int
:	O
name	*(char)
=	O
"logical*1"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
22	int
:	O
name	*(char)
=	O
"logical*2"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
2	int
)	O
;	O
break	O
;	O
case	O
23	int
:	O
name	*(char)
=	O
"logical*4"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
24	int
:	O
name	*(char)
=	O
"logical"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
25	int
:	O
name	*(char)
=	O
"complex"	*(char)
;	O
rettype	O
=	O
debug_make_complex_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
break	O
;	O
case	O
26	int
:	O
name	*(char)
=	O
"double complex"	*(char)
;	O
rettype	O
=	O
debug_make_complex_type	O
(	O
dhandle	O
,	O
16	int
)	O
;	O
break	O
;	O
case	O
27	int
:	O
name	*(char)
=	O
"integer*1"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
28	int
:	O
name	*(char)
=	O
"integer*2"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
29	int
:	O
name	*(char)
=	O
"integer*4"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
30	int
:	O
name	*(char)
=	O
"wchar"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
31	int
:	O
name	*(char)
=	O
"long long"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
32	int
:	O
name	*(char)
=	O
"unsigned long long"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
33	int
:	O
name	*(char)
=	O
"logical*8"	*(char)
;	O
rettype	O
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
break	O
;	O
case	O
34	int
:	O
name	*(char)
=	O
"integer*8"	*(char)
;	O
rettype	O
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
rettype	O
=	O
debug_name_type	O
(	O
dhandle	O
,	O
name	*(char)
,	O
rettype	O
)	O
;	O
info	*(void)
->	O
xcoff_types	O
[	O
-	O
typenum	O
]	O
=	O
rettype	O
;	O
return	O
rettype	O
;	O
}	O
static	O
debug_type	O
stab_find_tagged_type	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
p	*(void)
,	O
int	O
len	long
,	O
enum	O
debug_type_kind	O
kind	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
debug_type	O
dtype	O
;	O
struct	O
stab_tag	O
*	O
st	O
;	O
name	*(char)
=	O
savestring	O
(	O
p	*(void)
,	O
len	long
)	O
;	O
dtype	O
=	O
debug_find_tagged_type	O
(	O
dhandle	O
,	O
name	*(char)
,	O
DEBUG_KIND_ILLEGAL	O
)	O
;	O
if	O
(	O
dtype	O
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
dtype	O
;	O
}	O
for	O
(	O
st	O
=	O
info	*(void)
->	O
tags	O
;	O
st	O
!=	O
NULL	O
;	O
st	O
=	O
st	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
st	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
name	*(char)
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
st	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
st	O
->	O
kind	O
==	O
DEBUG_KIND_ILLEGAL	O
)	O
st	O
->	O
kind	O
=	O
kind	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
st	O
==	O
NULL	O
)	O
{	O
st	O
=	O
(	O
struct	O
stab_tag	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
st	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
st	O
,	O
0	int
,	O
sizeof	O
*	O
st	O
)	O
;	O
st	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
tags	O
;	O
st	O
->	O
name	*(char)
=	O
name	*(char)
;	O
st	O
->	O
kind	O
=	O
kind	O
;	O
st	O
->	O
slot	O
=	O
DEBUG_TYPE_NULL	O
;	O
st	O
->	O
type	enum(int,int,int,int)
=	O
debug_make_indirect_type	O
(	O
dhandle	O
,	O
&	O
st	O
->	O
slot	O
,	O
name	*(char)
)	O
;	O
info	*(void)
->	O
tags	O
=	O
st	O
;	O
}	O
return	O
st	O
->	O
type	enum(int,int,int,int)
;	O
}	O
struct	O
stab_demangle_typestring	O
{	O
const	O
char	O
*	O
typestring	O
;	O
unsigned	O
int	O
len	long
;	O
}	O
;	O
struct	O
stab_demangle_info	O
{	O
void	O
*	O
dhandle	O
;	O
struct	O
stab_handle	O
*	O
info	*(void)
;	O
debug_type	O
*	O
args	O
;	O
bfd_boolean	int
varargs	O
;	O
struct	O
stab_demangle_typestring	O
*	O
typestrings	O
;	O
unsigned	O
int	O
typestring_count	O
;	O
unsigned	O
int	O
typestring_alloc	O
;	O
}	O
;	O
static	O
void	O
stab_bad_demangle	O
(	O
const	O
char	O
*	O
)	O
;	O
static	O
unsigned	O
int	O
stab_demangle_count	O
(	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_get_count	O
(	O
const	O
char	O
*	O
*	O
,	O
unsigned	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_prefix	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_function_name	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_signature	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_qualified	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_template	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_class	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_args	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_arg	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
*	O
,	O
unsigned	O
int	O
*	O
,	O
unsigned	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_type	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_fund_type	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_remember_type	O
(	O
struct	O
stab_demangle_info	O
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
stab_bad_demangle	O
(	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"bad mangled name `%s'\n"	*(char)
)	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
}	O
static	O
unsigned	O
int	O
stab_demangle_count	O
(	O
const	O
char	O
*	O
*	O
pp	O
)	O
{	O
unsigned	O
int	O
count	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
{	O
count	int
*=	O
10	int
;	O
count	int
+=	O
*	O
*	O
pp	O
-	O
'0'	O
;	O
++	O
*	O
pp	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_get_count	O
(	O
const	O
char	O
*	O
*	O
pp	O
,	O
unsigned	O
int	O
*	O
pi	O
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
return	O
FALSE	O
;	O
*	O
pi	O
=	O
*	O
*	O
pp	O
-	O
'0'	O
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
{	O
unsigned	O
int	O
count	int
;	O
const	O
char	O
*	O
p	*(void)
;	O
count	int
=	O
*	O
pi	O
;	O
p	*(void)
=	O
*	O
pp	O
;	O
do	O
{	O
count	int
*=	O
10	int
;	O
count	int
+=	O
*	O
p	*(void)
-	O
'0'	O
;	O
++	O
p	*(void)
;	O
}	O
while	O
(	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'_'	O
)	O
{	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
*	O
pi	O
=	O
count	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
*	O
stab_demangle_argtypes	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
physname	O
,	O
bfd_boolean	int
*	O
pvarargs	O
,	O
unsigned	O
int	O
physname_len	O
)	O
{	O
struct	O
stab_demangle_info	O
minfo	O
;	O
if	O
(	O
physname	O
[	O
0	int
]	O
==	O
'_'	O
&&	O
physname	O
[	O
1	int
]	O
==	O
'Z'	O
)	O
return	O
stab_demangle_v3_argtypes	O
(	O
dhandle	O
,	O
info	*(void)
,	O
physname	O
,	O
pvarargs	O
)	O
;	O
minfo	O
.	O
dhandle	O
=	O
dhandle	O
;	O
minfo	O
.	O
info	*(void)
=	O
info	*(void)
;	O
minfo	O
.	O
args	O
=	O
NULL	O
;	O
minfo	O
.	O
varargs	O
=	O
FALSE	O
;	O
minfo	O
.	O
typestring_alloc	O
=	O
10	int
;	O
minfo	O
.	O
typestrings	O
=	O
(	O
(	O
struct	O
stab_demangle_typestring	O
*	O
)	O
xmalloc	O
(	O
minfo	O
.	O
typestring_alloc	O
*	O
sizeof	O
*	O
minfo	O
.	O
typestrings	O
)	O
)	O
;	O
minfo	O
.	O
typestring_count	O
=	O
0	int
;	O
if	O
(	O
!	O
stab_demangle_prefix	O
(	O
&	O
minfo	O
,	O
&	O
physname	O
,	O
physname_len	O
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
*	O
physname	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
stab_demangle_signature	O
(	O
&	O
minfo	O
,	O
&	O
physname	O
)	O
)	O
goto	O
error_return	O
;	O
}	O
free	(*(void))->(void)
(	O
minfo	O
.	O
typestrings	O
)	O
;	O
minfo	O
.	O
typestrings	O
=	O
NULL	O
;	O
if	O
(	O
minfo	O
.	O
args	O
==	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"no argument types in mangled string\n"	*(char)
)	O
)	O
;	O
*	O
pvarargs	O
=	O
minfo	O
.	O
varargs	O
;	O
return	O
minfo	O
.	O
args	O
;	O
error_return	O
:	O
if	O
(	O
minfo	O
.	O
typestrings	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
minfo	O
.	O
typestrings	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_prefix	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
unsigned	O
int	O
physname_len	O
)	O
{	O
const	O
char	O
*	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
;	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
physname_len	O
)	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
=	O
*	O
pp	O
+	O
physname_len	O
;	O
else	O
{	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
=	O
*	O
pp	O
;	O
do	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
=	O
strchr	(*(char),int)->(*(char))
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
,	O
'_'	O
)	O
;	O
while	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
!=	O
NULL	O
&&	O
*	O
++	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
!=	O
'_'	O
)	O
;	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
==	O
NULL	O
)	O
{	O
stab_bad_demangle	O
(	O
*	O
pp	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
--	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
;	O
i	*(struct)
=	O
strspn	(*(char),*(char))->(long)
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
,	O
"_"	*(char)
)	O
;	O
if	O
(	O
i	*(struct)
>	O
2	int
)	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
+=	O
i	*(struct)
-	O
2	int
;	O
}	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
==	O
*	O
pp	O
&&	O
(	O
ISDIGIT	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
)	O
||	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
==	O
'Q'	O
||	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
==	O
't'	O
)	O
)	O
{	O
*	O
pp	O
=	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
+	O
2	int
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
==	O
*	O
pp	O
&&	O
!	O
ISDIGIT	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
)	O
&&	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
!=	O
't'	O
)	O
{	O
while	O
(	O
*	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
==	O
'_'	O
)	O
++	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
;	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
,	O
"__"	*(char)
)	O
;	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
==	O
NULL	O
||	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
==	O
'\0'	O
)	O
{	O
stab_bad_demangle	O
(	O
*	O
pp	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
return	O
stab_demangle_function_name	O
(	O
minfo	O
,	O
pp	O
,	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
)	O
;	O
}	O
else	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
return	O
stab_demangle_function_name	O
(	O
minfo	O
,	O
pp	O
,	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
)	O
;	O
}	O
else	O
{	O
stab_bad_demangle	O
(	O
*	O
pp	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
stab_demangle_function_name	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
*	O
pp	O
;	O
*	O
pp	O
=	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
+	O
2	int
;	O
if	O
(	O
*	O
pp	O
-	O
name	*(char)
>=	O
5	int
&&	O
CONST_STRNEQ	O
(	O
name	*(char)
,	O
"type"	*(char)
)	O
&&	O
(	O
name	*(char)
[	O
4	int
]	O
==	O
'$'	O
||	O
name	*(char)
[	O
4	int
]	O
==	O
'.'	O
)	O
)	O
{	O
const	O
char	O
*	O
tem	O
;	O
tem	O
=	O
name	*(char)
+	O
5	int
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
&	O
tem	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'_'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
'_'	O
&&	O
name	*(char)
[	O
2	int
]	O
==	O
'o'	O
&&	O
name	*(char)
[	O
3	int
]	O
==	O
'p'	O
)	O
{	O
const	O
char	O
*	O
tem	O
;	O
tem	O
=	O
name	*(char)
+	O
4	int
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
&	O
tem	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_signature	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
bfd_boolean	int
expect_func	O
,	O
func_done	O
;	O
const	O
char	O
*	O
hold	O
;	O
orig	O
=	O
*	O
pp	O
;	O
expect_func	O
=	O
FALSE	O
;	O
func_done	O
=	O
FALSE	O
;	O
hold	O
=	O
NULL	O
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'Q'	O
:	O
hold	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_qualified	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	O
(	O
minfo	O
,	O
hold	O
,	O
*	O
pp	O
-	O
hold	O
)	O
)	O
return	O
FALSE	O
;	O
expect_func	O
=	O
TRUE	int
;	O
hold	O
=	O
NULL	O
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
hold	O
==	O
NULL	O
)	O
hold	O
=	O
*	O
pp	O
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
hold	O
==	O
NULL	O
)	O
hold	O
=	O
*	O
pp	O
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
hold	O
==	O
NULL	O
)	O
hold	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_class	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
const	O
char	O
*	O
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	O
(	O
minfo	O
,	O
hold	O
,	O
*	O
pp	O
-	O
hold	O
)	O
)	O
return	O
FALSE	O
;	O
expect_func	O
=	O
TRUE	int
;	O
hold	O
=	O
NULL	O
;	O
break	O
;	O
case	O
'F'	O
:	O
hold	O
=	O
NULL	O
;	O
func_done	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
&	O
minfo	O
->	O
args	O
,	O
&	O
minfo	O
->	O
varargs	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
hold	O
==	O
NULL	O
)	O
hold	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_template	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	O
(	O
minfo	O
,	O
hold	O
,	O
*	O
pp	O
-	O
hold	O
)	O
)	O
return	O
FALSE	O
;	O
hold	O
=	O
NULL	O
;	O
expect_func	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'_'	O
:	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
default	O
:	O
func_done	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
&	O
minfo	O
->	O
args	O
,	O
&	O
minfo	O
->	O
varargs	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
expect_func	O
)	O
{	O
func_done	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
&	O
minfo	O
->	O
args	O
,	O
&	O
minfo	O
->	O
varargs	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
func_done	O
)	O
{	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
&	O
minfo	O
->	O
args	O
,	O
&	O
minfo	O
->	O
varargs	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_qualified	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
ptype	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
const	O
char	O
*	O
p	*(void)
;	O
unsigned	O
int	O
qualifiers	O
;	O
debug_type	O
context	O
;	O
orig	O
=	O
*	O
pp	O
;	O
switch	O
(	O
(	O
*	O
pp	O
)	O
[	O
1	int
]	O
)	O
{	O
case	O
'_'	O
:	O
p	*(void)
=	O
*	O
pp	O
+	O
2	int
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
||	O
*	O
p	*(void)
==	O
'0'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
qualifiers	O
=	O
atoi	(*(char))->(int)
(	O
p	*(void)
)	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
)	O
++	O
p	*(void)
;	O
if	O
(	O
*	O
p	*(void)
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
*	O
pp	O
=	O
p	*(void)
+	O
1	int
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
qualifiers	O
=	O
(	O
*	O
pp	O
)	O
[	O
1	int
]	O
-	O
'0'	O
;	O
if	O
(	O
(	O
*	O
pp	O
)	O
[	O
2	int
]	O
==	O
'_'	O
)	O
++	O
*	O
pp	O
;	O
*	O
pp	O
+=	O
2	int
;	O
break	O
;	O
case	O
'0'	O
:	O
default	O
:	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
while	O
(	O
qualifiers	O
--	O
>	O
0	int
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'_'	O
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
't'	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
!	O
stab_demangle_template	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
!=	O
NULL	O
?	O
&	O
name	*(char)
:	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
context	O
=	O
stab_find_tagged_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
minfo	O
->	O
info	*(void)
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
,	O
DEBUG_KIND_CLASS	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
context	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
len	long
;	O
len	long
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
*	O
pp	O
)	O
<	O
len	long
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
const	O
debug_field	O
*	O
fields	O
;	O
fields	O
=	O
NULL	O
;	O
if	O
(	O
context	O
!=	O
DEBUG_TYPE_NULL	O
)	O
fields	O
=	O
debug_get_fields	O
(	O
minfo	O
->	O
dhandle	O
,	O
context	O
)	O
;	O
context	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
fields	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
len	long
)	O
;	O
for	O
(	O
;	O
*	O
fields	O
!=	O
DEBUG_FIELD_NULL	O
;	O
fields	O
++	O
)	O
{	O
debug_type	O
ft	O
;	O
const	O
char	O
*	O
dn	O
;	O
ft	O
=	O
debug_get_field_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
fields	O
)	O
;	O
if	O
(	O
ft	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
dn	O
=	O
debug_get_type_name	O
(	O
minfo	O
->	O
dhandle	O
,	O
ft	O
)	O
;	O
if	O
(	O
dn	O
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
dn	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
context	O
=	O
ft	O
;	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
context	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
qualifiers	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
savestring	O
(	O
*	O
pp	O
,	O
len	long
)	O
;	O
context	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
context	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
context	O
=	O
stab_find_tagged_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
minfo	O
->	O
info	*(void)
,	O
*	O
pp	O
,	O
len	long
,	O
(	O
qualifiers	O
==	O
0	int
?	O
DEBUG_KIND_ILLEGAL	O
:	O
DEBUG_KIND_CLASS	O
)	O
)	O
;	O
if	O
(	O
context	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
*	O
pp	O
+=	O
len	long
;	O
}	O
}	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
*	O
ptype	O
=	O
context	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_template	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
char	O
*	O
*	O
pname	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
unsigned	O
int	O
r	O
,	O
i	*(struct)
;	O
orig	O
=	O
*	O
pp	O
;	O
++	O
*	O
pp	O
;	O
r	O
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
r	O
==	O
0	int
||	O
strlen	(*(char))->(long)
(	O
*	O
pp	O
)	O
<	O
r	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
*	O
pp	O
+=	O
r	O
;	O
if	O
(	O
stab_demangle_get_count	O
(	O
pp	O
,	O
&	O
r	O
)	O
==	O
0	int
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
r	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'Z'	O
)	O
{	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
old_p	O
;	O
bfd_boolean	int
pointerp	O
,	O
realp	O
,	O
integralp	O
,	O
charp	O
,	O
boolp	O
;	O
bfd_boolean	int
done	O
;	O
old_p	O
=	O
*	O
pp	O
;	O
pointerp	O
=	O
FALSE	O
;	O
realp	O
=	O
FALSE	O
;	O
integralp	O
=	O
FALSE	O
;	O
charp	O
=	O
FALSE	O
;	O
boolp	O
=	O
FALSE	O
;	O
done	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
debug_type	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
while	O
(	O
*	O
old_p	O
!=	O
'\0'	O
&&	O
!	O
done	O
)	O
{	O
switch	O
(	O
*	O
old_p	O
)	O
{	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
case	O
'R'	O
:	O
pointerp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'S'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'F'	O
:	O
case	O
'M'	O
:	O
case	O
'O'	O
:	O
++	O
old_p	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
integralp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'T'	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'v'	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'x'	O
:	O
case	O
'l'	O
:	O
case	O
'i'	O
:	O
case	O
's'	O
:	O
case	O
'w'	O
:	O
integralp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'b'	O
:	O
boolp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
charp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'd'	O
:	O
case	O
'f'	O
:	O
realp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
integralp	O
=	O
TRUE	int
;	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
integralp	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'm'	O
)	O
++	O
*	O
pp	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
++	O
*	O
pp	O
;	O
}	O
else	O
if	O
(	O
charp	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'm'	O
)	O
++	O
*	O
pp	O
;	O
val	array(int)
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
val	array(int)
==	O
0	int
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
boolp	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
val	array(int)
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
val	array(int)
!=	O
0	int
&&	O
val	array(int)
!=	O
1	int
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
realp	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'm'	O
)	O
++	O
*	O
pp	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
++	O
*	O
pp	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'.'	O
)	O
{	O
++	O
*	O
pp	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
++	O
*	O
pp	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
==	O
'e'	O
)	O
{	O
++	O
*	O
pp	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
++	O
*	O
pp	O
;	O
}	O
}	O
else	O
if	O
(	O
pointerp	O
)	O
{	O
unsigned	O
int	O
len	long
;	O
len	long
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
*	O
pp	O
+=	O
len	long
;	O
}	O
}	O
}	O
if	O
(	O
pname	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
s1	O
,	O
*	O
s2	O
,	O
*	O
s3	O
,	O
*	O
s4	O
=	O
NULL	O
;	O
char	O
*	O
from	O
,	O
*	O
to	O
;	O
s1	O
=	O
savestring	O
(	O
orig	O
,	O
*	O
pp	O
-	O
orig	O
)	O
;	O
s2	O
=	O
concat	O
(	O
"NoSuchStrinG__"	*(char)
,	O
s1	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
s1	O
)	O
;	O
s3	O
=	O
cplus_demangle	O
(	O
s2	O
,	O
demangle_flags	O
)	O
;	O
free	(*(void))->(void)
(	O
s2	O
)	O
;	O
if	O
(	O
s3	O
!=	O
NULL	O
)	O
s4	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
s3	O
,	O
"::NoSuchStrinG"	*(char)
)	O
;	O
if	O
(	O
s3	O
==	O
NULL	O
||	O
s4	O
==	O
NULL	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
if	O
(	O
s3	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
s3	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
from	O
=	O
to	O
=	O
s3	O
;	O
from	O
!=	O
s4	O
;	O
++	O
from	O
)	O
if	O
(	O
*	O
from	O
!=	O
' '	O
||	O
(	O
from	O
[	O
1	int
]	O
==	O
'>'	O
&&	O
from	O
>	O
s3	O
&&	O
from	O
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
)	O
*	O
to	O
++	O
=	O
*	O
from	O
;	O
*	O
pname	O
=	O
savestring	O
(	O
s3	O
,	O
to	O
-	O
s3	O
)	O
;	O
free	(*(void))->(void)
(	O
s3	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_class	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
const	O
char	O
*	O
*	O
pstart	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
unsigned	O
int	O
n	O
;	O
orig	O
=	O
*	O
pp	O
;	O
n	O
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
*	O
pp	O
)	O
<	O
n	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
pstart	O
!=	O
NULL	O
)	O
*	O
pstart	O
=	O
*	O
pp	O
;	O
*	O
pp	O
+=	O
n	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_args	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
*	O
pargs	O
,	O
bfd_boolean	int
*	O
pvarargs	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
unsigned	O
int	O
alloc	O
,	O
count	int
;	O
orig	O
=	O
*	O
pp	O
;	O
alloc	O
=	O
10	int
;	O
if	O
(	O
pargs	O
!=	O
NULL	O
)	O
{	O
*	O
pargs	O
=	O
(	O
debug_type	O
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
*	O
pargs	O
)	O
;	O
*	O
pvarargs	O
=	O
FALSE	O
;	O
}	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
'_'	O
&&	O
*	O
*	O
pp	O
!=	O
'\0'	O
&&	O
*	O
*	O
pp	O
!=	O
'e'	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'N'	O
||	O
*	O
*	O
pp	O
==	O
'T'	O
)	O
{	O
char	O
temptype	O
;	O
unsigned	O
int	O
r	O
,	O
t	O
;	O
temptype	O
=	O
*	O
*	O
pp	O
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
temptype	O
==	O
'T'	O
)	O
r	O
=	O
1	int
;	O
else	O
{	O
if	O
(	O
!	O
stab_demangle_get_count	O
(	O
pp	O
,	O
&	O
r	O
)	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
stab_demangle_get_count	O
(	O
pp	O
,	O
&	O
t	O
)	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
t	O
>=	O
minfo	O
->	O
typestring_count	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
r	O
--	O
>	O
0	int
)	O
{	O
const	O
char	O
*	O
tem	O
;	O
tem	O
=	O
minfo	O
->	O
typestrings	O
[	O
t	O
]	O
.	O
typestring	O
;	O
if	O
(	O
!	O
stab_demangle_arg	O
(	O
minfo	O
,	O
&	O
tem	O
,	O
pargs	O
,	O
&	O
count	int
,	O
&	O
alloc	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
stab_demangle_arg	O
(	O
minfo	O
,	O
pp	O
,	O
pargs	O
,	O
&	O
count	int
,	O
&	O
alloc	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
pargs	O
!=	O
NULL	O
)	O
(	O
*	O
pargs	O
)	O
[	O
count	int
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	O
==	O
'e'	O
)	O
{	O
if	O
(	O
pargs	O
!=	O
NULL	O
)	O
*	O
pvarargs	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_arg	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
*	O
pargs	O
,	O
unsigned	O
int	O
*	O
pcount	O
,	O
unsigned	O
int	O
*	O
palloc	O
)	O
{	O
const	O
char	O
*	O
start	O
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
start	O
=	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
pargs	O
==	O
NULL	O
?	O
(	O
debug_type	O
*	O
)	O
NULL	O
:	O
&	O
type	enum(int,int,int,int)
)	O
||	O
!	O
stab_demangle_remember_type	O
(	O
minfo	O
,	O
start	O
,	O
*	O
pp	O
-	O
start	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
pargs	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
pcount	O
+	O
1	int
>=	O
*	O
palloc	O
)	O
{	O
*	O
palloc	O
+=	O
10	int
;	O
*	O
pargs	O
=	O
(	O
(	O
debug_type	O
*	O
)	O
xrealloc	O
(	O
*	O
pargs	O
,	O
*	O
palloc	O
*	O
sizeof	O
*	O
*	O
pargs	O
)	O
)	O
;	O
}	O
(	O
*	O
pargs	O
)	O
[	O
*	O
pcount	O
]	O
=	O
type	enum(int,int,int,int)
;	O
++	O
*	O
pcount	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_type	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
ptype	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
orig	O
=	O
*	O
pp	O
;	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
*	O
ptype	O
=	O
debug_make_pointer_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
*	O
ptype	O
=	O
debug_make_reference_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
{	O
unsigned	O
long	O
high	O
;	O
++	O
*	O
pp	O
;	O
high	O
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	O
!=	O
'\0'	O
&&	O
*	O
*	O
pp	O
!=	O
'_'	O
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
high	O
*=	O
10	int
;	O
high	O
+=	O
*	O
*	O
pp	O
-	O
'0'	O
;	O
++	O
*	O
pp	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
debug_type	O
int_type	O
;	O
int_type	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"int"	*(char)
)	O
;	O
if	O
(	O
int_type	O
==	O
NULL	O
)	O
int_type	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
*	O
ptype	O
=	O
debug_make_array_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
,	O
int_type	O
,	O
0	int
,	O
high	O
,	O
FALSE	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'T'	O
:	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
const	O
char	O
*	O
p	*(void)
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_get_count	O
(	O
pp	O
,	O
&	O
i	*(struct)
)	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
i	*(struct)
>=	O
minfo	O
->	O
typestring_count	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
p	*(void)
=	O
minfo	O
->	O
typestrings	O
[	O
i	*(struct)
]	O
.	O
typestring	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
&	O
p	*(void)
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
{	O
debug_type	O
*	O
args	O
;	O
bfd_boolean	int
varargs	O
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
ptype	O
==	O
NULL	O
?	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
:	O
&	O
args	O
)	O
,	O
(	O
ptype	O
==	O
NULL	O
?	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
:	O
&	O
varargs	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
*	O
ptype	O
=	O
debug_make_function_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
,	O
args	O
,	O
varargs	O
)	O
;	O
}	O
break	O
;	O
case	O
'M'	O
:	O
case	O
'O'	O
:	O
{	O
bfd_boolean	int
memberp	O
;	O
debug_type	O
class_type	O
=	O
DEBUG_TYPE_NULL	O
;	O
debug_type	O
*	O
args	O
;	O
bfd_boolean	int
varargs	O
;	O
unsigned	O
int	O
n	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
memberp	O
=	O
*	O
*	O
pp	O
==	O
'M'	O
;	O
args	O
=	O
NULL	O
;	O
varargs	O
=	O
FALSE	O
;	O
++	O
*	O
pp	O
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
{	O
n	O
=	O
stab_demangle_count	O
(	O
pp	O
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
*	O
pp	O
)	O
<	O
n	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
name	*(char)
=	O
*	O
pp	O
;	O
*	O
pp	O
+=	O
n	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
class_type	O
=	O
stab_find_tagged_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
minfo	O
->	O
info	*(void)
,	O
name	*(char)
,	O
(	O
int	O
)	O
n	O
,	O
DEBUG_KIND_CLASS	O
)	O
;	O
if	O
(	O
class_type	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
*	O
pp	O
==	O
'Q'	O
)	O
{	O
if	O
(	O
!	O
stab_demangle_qualified	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
ptype	O
==	O
NULL	O
?	O
(	O
debug_type	O
*	O
)	O
NULL	O
:	O
&	O
class_type	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
memberp	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	O
==	O
'C'	O
)	O
{	O
++	O
*	O
pp	O
;	O
}	O
else	O
if	O
(	O
*	O
*	O
pp	O
==	O
'V'	O
)	O
{	O
++	O
*	O
pp	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'F'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_args	O
(	O
minfo	O
,	O
pp	O
,	O
(	O
ptype	O
==	O
NULL	O
?	O
(	O
debug_type	O
*	O
*	O
)	O
NULL	O
:	O
&	O
args	O
)	O
,	O
(	O
ptype	O
==	O
NULL	O
?	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
:	O
&	O
varargs	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	O
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
memberp	O
)	O
*	O
ptype	O
=	O
debug_make_offset_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
class_type	O
,	O
*	O
ptype	O
)	O
;	O
else	O
{	O
*	O
ptype	O
=	O
debug_make_method_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
,	O
class_type	O
,	O
args	O
,	O
varargs	O
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'G'	O
:	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'C'	O
:	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
stab_demangle_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
*	O
ptype	O
=	O
debug_make_const_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
{	O
if	O
(	O
!	O
stab_demangle_qualified	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
stab_demangle_fund_type	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_fund_type	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
*	O
pp	O
,	O
debug_type	O
*	O
ptype	O
)	O
{	O
const	O
char	O
*	O
orig	O
;	O
bfd_boolean	int
constp	O
,	O
volatilep	O
,	O
unsignedp	O
,	O
signedp	O
;	O
bfd_boolean	int
done	O
;	O
orig	O
=	O
*	O
pp	O
;	O
constp	O
=	O
FALSE	O
;	O
volatilep	O
=	O
FALSE	O
;	O
unsignedp	O
=	O
FALSE	O
;	O
signedp	O
=	O
FALSE	O
;	O
done	O
=	O
FALSE	O
;	O
while	O
(	O
!	O
done	O
)	O
{	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'C'	O
:	O
constp	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'U'	O
:	O
unsignedp	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'S'	O
:	O
signedp	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'V'	O
:	O
volatilep	O
=	O
TRUE	int
;	O
++	O
*	O
pp	O
;	O
break	O
;	O
default	O
:	O
done	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
*	O
*	O
pp	O
)	O
{	O
case	O
'\0'	O
:	O
case	O
'_'	O
:	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"void"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_void_type	O
(	O
minfo	O
->	O
dhandle	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
(	O
unsignedp	O
?	O
"long long unsigned int"	*(char)
:	O
"long long int"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
8	int
,	O
unsignedp	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
(	O
unsignedp	O
?	O
"long unsigned int"	*(char)
:	O
"long int"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
4	int
,	O
unsignedp	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
(	O
unsignedp	O
?	O
"unsigned int"	*(char)
:	O
"int"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
4	int
,	O
unsignedp	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
(	O
unsignedp	O
?	O
"short unsigned int"	*(char)
:	O
"short int"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
2	int
,	O
unsignedp	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"bool"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_bool_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
4	int
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
(	O
unsignedp	O
?	O
"unsigned char"	*(char)
:	O
(	O
signedp	O
?	O
"signed char"	*(char)
:	O
"char"	*(char)
)	O
)	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
1	int
,	O
unsignedp	O
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"__wchar_t"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_int_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
2	int
,	O
TRUE	int
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"long double"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_float_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
8	int
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"double"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_float_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
8	int
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
"float"	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	O
=	O
debug_make_float_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
4	int
)	O
;	O
}	O
++	O
*	O
pp	O
;	O
break	O
;	O
case	O
'G'	O
:	O
++	O
*	O
pp	O
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	O
)	O
)	O
{	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
const	O
char	O
*	O
hold	O
;	O
if	O
(	O
!	O
stab_demangle_class	O
(	O
minfo	O
,	O
pp	O
,	O
&	O
hold	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
savestring	O
(	O
hold	O
,	O
*	O
pp	O
-	O
hold	O
)	O
;	O
*	O
ptype	O
=	O
debug_find_named_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
*	O
ptype	O
=	O
stab_find_tagged_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
minfo	O
->	O
info	*(void)
,	O
hold	O
,	O
*	O
pp	O
-	O
hold	O
,	O
DEBUG_KIND_ILLEGAL	O
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
't'	O
:	O
{	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
!	O
stab_demangle_template	O
(	O
minfo	O
,	O
pp	O
,	O
ptype	O
!=	O
NULL	O
?	O
&	O
name	*(char)
:	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
*	O
ptype	O
=	O
stab_find_tagged_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
minfo	O
->	O
info	*(void)
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
,	O
DEBUG_KIND_CLASS	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
*	O
ptype	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
stab_bad_demangle	O
(	O
orig	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
ptype	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
constp	O
)	O
*	O
ptype	O
=	O
debug_make_const_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
)	O
;	O
if	O
(	O
volatilep	O
)	O
*	O
ptype	O
=	O
debug_make_volatile_type	O
(	O
minfo	O
->	O
dhandle	O
,	O
*	O
ptype	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_remember_type	O
(	O
struct	O
stab_demangle_info	O
*	O
minfo	O
,	O
const	O
char	O
*	O
p	*(void)
,	O
int	O
len	long
)	O
{	O
if	O
(	O
minfo	O
->	O
typestring_count	O
>=	O
minfo	O
->	O
typestring_alloc	O
)	O
{	O
minfo	O
->	O
typestring_alloc	O
+=	O
10	int
;	O
minfo	O
->	O
typestrings	O
=	O
(	O
(	O
struct	O
stab_demangle_typestring	O
*	O
)	O
xrealloc	O
(	O
minfo	O
->	O
typestrings	O
,	O
(	O
minfo	O
->	O
typestring_alloc	O
*	O
sizeof	O
*	O
minfo	O
->	O
typestrings	O
)	O
)	O
)	O
;	O
}	O
minfo	O
->	O
typestrings	O
[	O
minfo	O
->	O
typestring_count	O
]	O
.	O
typestring	O
=	O
p	*(void)
;	O
minfo	O
->	O
typestrings	O
[	O
minfo	O
->	O
typestring_count	O
]	O
.	O
len	long
=	O
(	O
unsigned	O
int	O
)	O
len	long
;	O
++	O
minfo	O
->	O
typestring_count	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	O
*	O
stab_demangle_v3_argtypes	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
physname	O
,	O
bfd_boolean	int
*	O
pvarargs	O
)	O
{	O
struct	O
demangle_component	O
*	O
dc	O
;	O
void	O
*	O
mem	O
;	O
debug_type	O
*	O
pargs	O
;	O
dc	O
=	O
cplus_demangle_v3_components	O
(	O
physname	O
,	O
DMGL_PARAMS	O
|	O
demangle_flags	O
,	O
&	O
mem	O
)	O
;	O
if	O
(	O
dc	O
==	O
NULL	O
)	O
{	O
stab_bad_demangle	O
(	O
physname	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dc	O
->	O
type	enum(int,int,int,int)
!=	O
DEMANGLE_COMPONENT_TYPED_NAME	O
||	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
->	O
type	enum(int,int,int,int)
!=	O
DEMANGLE_COMPONENT_FUNCTION_TYPE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Demangled name is not a function\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
mem	O
)	O
;	O
return	O
NULL	O
;	O
}	O
pargs	O
=	O
stab_demangle_v3_arglist	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
,	O
pvarargs	O
)	O
;	O
free	(*(void))->(void)
(	O
mem	O
)	O
;	O
return	O
pargs	O
;	O
}	O
static	O
debug_type	O
*	O
stab_demangle_v3_arglist	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
struct	O
demangle_component	O
*	O
arglist	O
,	O
bfd_boolean	int
*	O
pvarargs	O
)	O
{	O
struct	O
demangle_component	O
*	O
dc	O
;	O
unsigned	O
int	O
alloc	O
,	O
count	int
;	O
debug_type	O
*	O
pargs	O
;	O
alloc	O
=	O
10	int
;	O
pargs	O
=	O
(	O
debug_type	O
*	O
)	O
xmalloc	O
(	O
alloc	O
*	O
sizeof	O
*	O
pargs	O
)	O
;	O
*	O
pvarargs	O
=	O
FALSE	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
dc	O
=	O
arglist	O
;	O
dc	O
!=	O
NULL	O
;	O
dc	O
=	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
)	O
{	O
debug_type	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
bfd_boolean	int
varargs	O
;	O
if	O
(	O
dc	O
->	O
type	enum(int,int,int,int)
!=	O
DEMANGLE_COMPONENT_ARGLIST	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Unexpected type in v3 arglist demangling\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
pargs	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
==	O
NULL	O
)	O
break	O
;	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
=	O
stab_demangle_v3_arg	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
,	O
NULL	O
,	O
&	O
varargs	O
)	O
;	O
if	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
==	O
NULL	O
)	O
{	O
if	O
(	O
varargs	O
)	O
{	O
*	O
pvarargs	O
=	O
TRUE	int
;	O
continue	O
;	O
}	O
free	(*(void))->(void)
(	O
pargs	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
count	int
+	O
1	int
>=	O
alloc	O
)	O
{	O
alloc	O
+=	O
10	int
;	O
pargs	O
=	O
(	O
debug_type	O
*	O
)	O
xrealloc	O
(	O
pargs	O
,	O
alloc	O
*	O
sizeof	O
*	O
pargs	O
)	O
;	O
}	O
pargs	O
[	O
count	int
]	O
=	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
++	O
count	int
;	O
}	O
pargs	O
[	O
count	int
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
return	O
pargs	O
;	O
}	O
static	O
debug_type	O
stab_demangle_v3_arg	O
(	O
void	O
*	O
dhandle	O
,	O
struct	O
stab_handle	O
*	O
info	*(void)
,	O
struct	O
demangle_component	O
*	O
dc	O
,	O
debug_type	O
context	O
,	O
bfd_boolean	int
*	O
pvarargs	O
)	O
{	O
debug_type	O
dt	O
;	O
if	O
(	O
pvarargs	O
!=	O
NULL	O
)	O
*	O
pvarargs	O
=	O
FALSE	O
;	O
switch	O
(	O
dc	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DEMANGLE_COMPONENT_LOCAL_NAME	O
:	O
case	O
DEMANGLE_COMPONENT_TYPED_NAME	O
:	O
case	O
DEMANGLE_COMPONENT_TEMPLATE_PARAM	O
:	O
case	O
DEMANGLE_COMPONENT_CTOR	O
:	O
case	O
DEMANGLE_COMPONENT_DTOR	O
:	O
case	O
DEMANGLE_COMPONENT_JAVA_CLASS	O
:	O
case	O
DEMANGLE_COMPONENT_RESTRICT_THIS	O
:	O
case	O
DEMANGLE_COMPONENT_VOLATILE_THIS	O
:	O
case	O
DEMANGLE_COMPONENT_CONST_THIS	O
:	O
case	O
DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL	O
:	O
case	O
DEMANGLE_COMPONENT_COMPLEX	O
:	O
case	O
DEMANGLE_COMPONENT_IMAGINARY	O
:	O
case	O
DEMANGLE_COMPONENT_VENDOR_TYPE	O
:	O
case	O
DEMANGLE_COMPONENT_ARRAY_TYPE	O
:	O
case	O
DEMANGLE_COMPONENT_PTRMEM_TYPE	O
:	O
case	O
DEMANGLE_COMPONENT_ARGLIST	O
:	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Unrecognized demangle component %d\n"	*(char)
)	O
,	O
(	O
int	O
)	O
dc	O
->	O
type	enum(int,int,int,int)
)	O
;	O
return	O
NULL	O
;	O
case	O
DEMANGLE_COMPONENT_NAME	O
:	O
if	O
(	O
context	O
!=	O
NULL	O
)	O
{	O
const	O
debug_field	O
*	O
fields	O
;	O
fields	O
=	O
debug_get_fields	O
(	O
dhandle	O
,	O
context	O
)	O
;	O
if	O
(	O
fields	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
;	O
*	O
fields	O
!=	O
DEBUG_FIELD_NULL	O
;	O
fields	O
++	O
)	O
{	O
debug_type	O
ft	O
;	O
const	O
char	O
*	O
dn	O
;	O
ft	O
=	O
debug_get_field_type	O
(	O
dhandle	O
,	O
*	O
fields	O
)	O
;	O
if	O
(	O
ft	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
dn	O
=	O
debug_get_type_name	O
(	O
dhandle	O
,	O
ft	O
)	O
;	O
if	O
(	O
dn	O
!=	O
NULL	O
&&	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
dn	O
)	O
==	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_name	O
.	O
len	long
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
dn	O
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_name	O
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_name	O
.	O
len	long
)	O
==	O
0	int
)	O
return	O
ft	O
;	O
}	O
}	O
}	O
return	O
stab_find_tagged_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_name	O
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_name	O
.	O
len	long
,	O
DEBUG_KIND_ILLEGAL	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_QUAL_NAME	O
:	O
context	O
=	O
stab_demangle_v3_arg	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
,	O
context	O
,	O
NULL	O
)	O
;	O
if	O
(	O
context	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
stab_demangle_v3_arg	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
,	O
context	O
,	O
NULL	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_TEMPLATE	O
:	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
alc	O
;	O
p	*(void)
=	O
cplus_demangle_print	O
(	O
DMGL_PARAMS	O
|	O
demangle_flags	O
,	O
dc	O
,	O
20	int
,	O
&	O
alc	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Failed to print demangled template\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dt	O
=	O
stab_find_tagged_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
p	*(void)
,	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
,	O
DEBUG_KIND_CLASS	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
dt	O
;	O
}	O
case	O
DEMANGLE_COMPONENT_SUB_STD	O
:	O
return	O
stab_find_tagged_type	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_string	O
.	O
string	*(char)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_string	O
.	O
len	long
,	O
DEBUG_KIND_ILLEGAL	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_RESTRICT	O
:	O
case	O
DEMANGLE_COMPONENT_VOLATILE	O
:	O
case	O
DEMANGLE_COMPONENT_CONST	O
:	O
case	O
DEMANGLE_COMPONENT_POINTER	O
:	O
case	O
DEMANGLE_COMPONENT_REFERENCE	O
:	O
dt	O
=	O
stab_demangle_v3_arg	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dt	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
dc	O
->	O
type	enum(int,int,int,int)
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_RESTRICT	O
:	O
return	O
dt	O
;	O
case	O
DEMANGLE_COMPONENT_VOLATILE	O
:	O
return	O
debug_make_volatile_type	O
(	O
dhandle	O
,	O
dt	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_CONST	O
:	O
return	O
debug_make_const_type	O
(	O
dhandle	O
,	O
dt	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_POINTER	O
:	O
return	O
debug_make_pointer_type	O
(	O
dhandle	O
,	O
dt	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_REFERENCE	O
:	O
return	O
debug_make_reference_type	O
(	O
dhandle	O
,	O
dt	O
)	O
;	O
}	O
case	O
DEMANGLE_COMPONENT_FUNCTION_TYPE	O
:	O
{	O
debug_type	O
*	O
pargs	O
;	O
bfd_boolean	int
varargs	O
;	O
if	O
(	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
==	O
NULL	O
)	O
{	O
dt	O
=	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
}	O
else	O
dt	O
=	O
stab_demangle_v3_arg	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
left	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dt	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
pargs	O
=	O
stab_demangle_v3_arglist	O
(	O
dhandle	O
,	O
info	*(void)
,	O
dc	O
->	O
u	union(long,*(struct))
.	O
s_binary	O
.	O
right	O
,	O
&	O
varargs	O
)	O
;	O
if	O
(	O
pargs	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
debug_make_function_type	O
(	O
dhandle	O
,	O
dt	O
,	O
pargs	O
,	O
varargs	O
)	O
;	O
}	O
case	O
DEMANGLE_COMPONENT_BUILTIN_TYPE	O
:	O
{	O
char	O
*	O
p	*(void)
;	O
size_t	long
alc	O
;	O
debug_type	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
p	*(void)
=	O
cplus_demangle_print	O
(	O
DMGL_PARAMS	O
|	O
demangle_flags	O
,	O
dc	O
,	O
20	int
,	O
&	O
alc	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Couldn't get demangled builtin type\n"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"signed char"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"bool"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_bool_type	O
(	O
dhandle	O
,	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"char"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"double"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"long double"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
8	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"float"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
4	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"__float128"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_float_type	O
(	O
dhandle	O
,	O
16	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned char"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
1	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"int"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned int"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"long"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned long"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"__int128"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
16	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned __int128"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
16	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"short"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned short"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
2	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"void"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_void_type	O
(	O
dhandle	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"wchar_t"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"long long"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"unsigned long long"	*(char)
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_make_int_type	O
(	O
dhandle	O
,	O
8	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"..."	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pvarargs	O
==	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Unexpected demangled varargs\n"	*(char)
)	O
)	O
;	O
else	O
*	O
pvarargs	O
=	O
TRUE	int
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
NULL	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Unrecognized demangled builtin type\n"	*(char)
)	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
}	O
}	O
