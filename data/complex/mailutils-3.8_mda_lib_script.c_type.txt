static	O
mu_script_t	*(struct)
script_handler	*(struct)
;	O
static	O
mu_list_t	*(struct)
script_list	*(struct)
;	O
static	O
char	O
*	O
message_id_header	*(char)
;	O
struct	O
mda_script	struct(*(struct),*(char))
{	O
mu_script_t	*(struct)
scr	*(struct)
;	O
const	O
char	O
*	O
pat	*(char)
;	O
}	O
;	O
static	O
int	O
script_register	(*(char))->(int)
(	O
const	O
char	O
*	O
pattern	*(void)
)	O
{	O
mu_script_t	*(struct)
scr	*(struct)
;	O
struct	O
mda_script	struct(*(struct),*(char))
*	O
p	*(char)
;	O
if	O
(	O
script_handler	*(struct)
)	O
scr	*(struct)
=	O
script_handler	*(struct)
;	O
else	O
{	O
scr	*(struct)
=	O
mu_script_suffix_handler	(*(char))->(*(struct))
(	O
pattern	*(void)
)	O
;	O
if	O
(	O
!	O
scr	*(struct)
)	O
return	O
EINVAL	int
;	O
}	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
MU_ERR_FAILURE	O
;	O
p	*(char)
->	O
scr	*(struct)
=	O
scr	*(struct)
;	O
p	*(char)
->	O
pat	*(char)
=	O
pattern	*(void)
;	O
if	O
(	O
!	O
script_list	*(struct)
)	O
{	O
if	O
(	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
script_list	*(struct)
)	O
)	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
if	O
(	O
mu_list_append	(*(struct),*(void))->(int)
(	O
script_list	*(struct)
,	O
p	*(char)
)	O
)	O
return	O
MU_ERR_FAILURE	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
set_script_lang	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
script_handler	*(struct)
=	O
mu_script_lang_handler	(*(char))->(*(struct))
(	O
arg	*(char)
)	O
;	O
if	O
(	O
!	O
script_handler	*(struct)
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"unknown or unsupported language: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
}	O
static	O
void	O
set_script_pattern	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
switch	O
(	O
script_register	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
{	O
case	O
0	int
:	O
return	O
;	O
case	O
EINVAL	int
:	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"%s has unknown file suffix"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"error registering script"	*(char)
)	O
)	O
;	O
}	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
static	O
void	O
set_debug	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
mu_script_debug_flags	(*(char),*(*(char)))->(int)
(	O
arg	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
&	O
arg	*(char)
)	O
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"%c is not a valid debug flag"	*(char)
)	O
,	O
*	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
}	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
mda_script_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	O
(	O
N_	O
(	O
"Scripting options"	*(char)
)	O
)	O
,	O
{	O
"language"	*(char)
,	O
'l'	O
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"define scripting language for the next --script option"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_script_lang	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"script"	*(char)
,	O
's'	O
,	O
N_	O
(	O
"PATTERN"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set name pattern for user-defined mail filter"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_script_pattern	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"message-id-header"	*(char)
,	O
0	int
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"use this header to identify messages when logging Sieve actions"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
message_id_header	*(char)
}	O
,	O
{	O
"script-debug"	*(char)
,	O
'x'	O
,	O
N_	O
(	O
"FLAGS"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"enable script debugging; FLAGS are:\ng - guile stack traces\nt - sieve trace (MU_SIEVE_DEBUG_TRACE)\ni - sieve instructions trace (MU_SIEVE_DEBUG_INSTR)\nl - sieve action logs"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_debug	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
int	O
cb_script_language	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
script_handler	*(struct)
=	O
mu_script_lang_handler	(*(char))->(*(struct))
(	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
if	O
(	O
!	O
script_handler	*(struct)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unsupported language: %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_script_pattern	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
script_register	(*(char))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
EINVAL	int
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s has unknown file suffix"	*(char)
)	O
,	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"error registering script"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_debug	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_script_debug_flags	(*(char),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
,	O
&	O
p	*(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%c is not a valid debug flag"	*(char)
)	O
,	O
*	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mda_script_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"language"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_script_language	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set script language."	*(char)
)	O
,	O
N_	O
(	O
"arg: python|guile"	*(char)
)	O
}	O
,	O
{	O
"pattern"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_script_pattern	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set script pattern."	*(char)
)	O
,	O
N_	O
(	O
"arg: glob"	*(char)
)	O
}	O
,	O
{	O
"debug"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_debug	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set scripting debug level.  Argument is one or more "	*(char)
"of the following letters:\n"	*(char)
"  g - guile stack traces\n"	*(char)
"  t - sieve trace (MU_SIEVE_DEBUG_TRACE)\n"	*(char)
"  i - sieve instructions trace (MU_SIEVE_DEBUG_INSTR)\n"	*(char)
"  l - sieve action logs\n"	*(char)
)	O
,	O
N_	O
(	O
"arg: string"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
apply_script_closure	struct(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(struct))
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
}	O
;	O
static	O
char	O
const	O
*	O
script_env	array(*(char))
[	O
]	O
=	O
{	O
"location=MDA"	*(char)
,	O
"phase=during"	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
apply_script	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mda_script	struct(*(struct),*(char))
*	O
scr	*(struct)
=	O
item	*(void)
;	O
struct	O
apply_script_closure	struct(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(struct))
*	O
clos	*(void)
=	O
data	*(void)
;	O
char	O
*	O
progfile	*(char)
;	O
int	O
rc	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
mu_script_descr_t	*(struct)
sd	*(struct)
;	O
progfile	*(char)
=	O
mu_expand_path_pattern	(*(char),*(char))->(*(char))
(	O
scr	*(struct)
->	O
pat	*(char)
,	O
clos	*(void)
->	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
progfile	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_NOTICE	O
,	O
"stat"	*(char)
,	O
progfile	*(char)
,	O
errno	O
)	O
;	O
free	(*(void))->(void)
(	O
progfile	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_script_init	(*(struct),*(char),*(*(char)),*(*(struct)))->(int)
(	O
scr	*(struct)
->	O
scr	*(struct)
,	O
progfile	*(char)
,	O
script_env	array(*(char))
,	O
&	O
sd	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"initialization of script %s failed: %s"	*(char)
)	O
,	O
progfile	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
if	O
(	O
mu_script_sieve_log	int
)	O
mu_script_log_enable	(*(struct),*(struct),*(char),*(char))->(void)
(	O
scr	*(struct)
->	O
scr	*(struct)
,	O
sd	*(struct)
,	O
clos	*(void)
->	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
,	O
message_id_header	*(char)
)	O
;	O
rc	int
=	O
mu_script_process_msg	(*(struct),*(struct),*(struct))->(int)
(	O
scr	*(struct)
->	O
scr	*(struct)
,	O
sd	*(struct)
,	O
clos	*(void)
->	O
msg	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"script %s failed: %s"	*(char)
)	O
,	O
progfile	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_script_done	(*(struct),*(struct))->(int)
(	O
scr	*(struct)
->	O
scr	*(struct)
,	O
sd	*(struct)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
progfile	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mda_filter_message	(*(struct),*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
if	O
(	O
script_list	*(struct)
)	O
{	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
struct	O
apply_script_closure	struct(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(struct))
clos	*(void)
;	O
int	O
rc	int
;	O
clos	*(void)
.	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
;	O
clos	*(void)
.	O
msg	*(struct)
=	O
msg	*(struct)
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_unset_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
if	O
(	O
mda_switch_user_id	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),int)->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
1	int
)	O
)	O
return	O
MDA_FILTER_FAILURE	int
;	O
chdir	(*(char))->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
dir	*(char)
)	O
;	O
rc	int
=	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
script_list	*(struct)
,	O
apply_script	(*(void),*(void))->(int)
,	O
&	O
clos	*(void)
)	O
;	O
chdir	(*(char))->(int)
(	O
"/"	*(char)
)	O
;	O
if	O
(	O
mda_switch_user_id	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),int)->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
0	int
)	O
)	O
return	O
MDA_FILTER_FAILURE	int
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
if	O
(	O
mu_attribute_is_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
)	O
return	O
MDA_FILTER_FILTERED	int
;	O
}	O
else	O
return	O
MDA_FILTER_FAILURE	int
;	O
}	O
return	O
MDA_FILTER_OK	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
filter_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"language"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_script_language	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set script language."	*(char)
)	O
,	O
N_	O
(	O
"arg: sieve|python|scheme"	*(char)
)	O
}	O
,	O
{	O
"pattern"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_script_pattern	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set script pattern."	*(char)
)	O
,	O
N_	O
(	O
"arg: glob"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mda_filter_cfg_init	()->(void)
(	O
void	O
)	O
{	O
struct	O
mu_cfg_section	int
*	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
;	O
if	O
(	O
mu_create_canned_section	(*(char),*(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)))))->(int)
(	O
"filter"	*(char)
,	O
&	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
)	O
==	O
0	int
)	O
{	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
->	O
docstring	*(char)
=	O
N_	O
(	O
"Add new message filter."	*(char)
)	O
;	O
mu_cfg_section_add_params	(*(struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct),*(char),*(void))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))))->(int)
(	O
section	struct(*(char),*(char),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*(void),long,*(struct),*(char),*(void))
,	O
filter_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
)	O
;	O
}	O
mu_cli_capa_register	(*(struct(*(char),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_cli_capa_sieve	struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
}	O
