int	O
find_input_ranges	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
ranges	*(struct(long,long,int,*(char)))
,	O
range_count	int
,	O
end_range_start	long
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter_repeat	int
,	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
STRINGTYPE	O
*	O
out_string	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
input_record	*(struct(long,enum(int,int,int),*(char)))
;	O
field_range	struct(long,long,int,*(char))
*	O
ranges	*(struct(long,long,int,*(char)))
;	O
int	O
range_count	int
;	O
size_t	long
end_range_start	long
;	O
STRINGTYPE	O
*	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
;	O
int	O
input_delimiter_repeat	int
;	O
STRINGTYPE	O
*	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
dstrsplit	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(*(struct(long,enum(int,int,int),*`)))),*(int))->(int)
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
input_delimiter_repeat	int
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
field_list_length	int
;	O
j	int
++	O
)	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
-	O
1	int
]	O
=	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
]	O
;	O
field_list_length	int
--	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
=	O
realloc	(*(void),long)->(*(void))
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
field_list_length	int
*	O
sizeof	O
(	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
)	O
)	O
;	O
if	O
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
range_count	int
;	O
i	int
++	O
)	O
{	O
STRINGTYPE	O
*	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
other_string	*(struct(long,enum(int,int,int),*(char)))
;	O
if	O
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
>	O
0	int
&&	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
,	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
<	O
0	int
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
>	O
field_list_length	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"bad field substring -- wanted field %ld from %d fields"	*(char)
)	O
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
,	O
field_list_length	int
)	O
;	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
=	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
;	O
}	O
else	O
{	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrsubstr	(*(struct(long,enum(int,int,int),*(char))),long,long,long,enum(int,int,int))->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
>	O
0	int
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
>	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	*(char)
)	O
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
other_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
other_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
format	*(char)
!=	O
NULL	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
if	O
(	O
end_range_start	long
!=	O
0	int
)	O
{	O
STRINGTYPE	O
*	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
other_string	*(struct(long,enum(int,int,int),*(char)))
;	O
if	O
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
>	O
0	int
&&	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
,	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrsubstr	(*(struct(long,enum(int,int,int),*(char))),long,long,long,enum(int,int,int))->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
end_range_start	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
||	O
end_range_start	long
<	O
0	int
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	*(char)
)	O
,	O
end_range_start	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
other_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
out_string	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
other_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
a_find_input_ranges	(*(*(*(struct(long,enum(int,int,int),*`)))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,enum(int,int,int),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
ranges	*(struct(long,long,int,*(char)))
,	O
range_count	int
,	O
end_range_start	long
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter_repeat	int
,	O
make_copy	enum(int,int,int)
,	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
STRINGTYPE	O
*	O
*	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
;	O
STRINGTYPE	O
*	O
input_record	*(struct(long,enum(int,int,int),*(char)))
;	O
field_range	struct(long,long,int,*(char))
*	O
ranges	*(struct(long,long,int,*(char)))
;	O
int	O
range_count	int
;	O
size_t	long
end_range_start	long
;	O
STRINGTYPE	O
*	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
;	O
int	O
input_delimiter_repeat	int
;	O
DStr_codes	enum(int,int,int)
make_copy	enum(int,int,int)
;	O
STRINGTYPE	O
*	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
dstrsplit	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(*(struct(long,enum(int,int,int),*`)))),*(int))->(int)
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
input_delimiter_repeat	int
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
field_list_length	int
;	O
j	int
++	O
)	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
-	O
1	int
]	O
=	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
]	O
;	O
if	O
(	O
i	int
<	O
field_list_length	int
-	O
1	int
)	O
field_list_length	int
--	O
;	O
else	O
i	int
++	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
=	O
realloc	(*(void),long)->(*(void))
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
field_list_length	int
*	O
sizeof	O
(	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
)	O
)	O
;	O
if	O
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
=	O
malloc	(long)->(*(void))
(	O
(	O
range_count	int
+	O
(	O
end_range_start	long
==	O
0	int
?	O
0	int
:	O
1	int
)	O
)	O
*	O
sizeof	O
(	O
STRINGTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
range_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
<=	O
field_list_length	int
)	O
{	O
if	O
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
&&	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
->	O
length	long
==	O
0	int
)	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
else	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
else	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
""	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrsubstr	(*(struct(long,enum(int,int,int),*(char))),long,long,long,enum(int,int,int))->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
make_copy	enum(int,int,int)
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
<	O
1	int
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
>	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	*(char)
)	O
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
i	int
]	O
.	O
upper_bound	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
end_range_start	long
!=	O
0	int
&&	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
{	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrsubstr	(*(struct(long,enum(int,int,int),*(char))),long,long,long,enum(int,int,int))->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
end_range_start	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
0	int
,	O
make_copy	enum(int,int,int)
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
<	O
1	int
||	O
end_range_start	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	*(char)
)	O
,	O
end_range_start	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
end_range_start	long
!=	O
0	int
&&	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
<=	O
field_list_length	int
)	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
end_range_start	long
-	O
1	int
]	O
)	O
;	O
else	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
""	*(char)
)	O
;	O
j	int
=	O
end_range_start	long
;	O
while	O
(	O
j	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
,	O
output_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
||	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
]	O
->	O
length	long
!=	O
0	int
)	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
,	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	int
]	O
)	O
;	O
else	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
(	O
*	O
out_ranges	*(*(*(struct(long,enum(int,int,int),*(char)))))
)	O
[	O
i	int
]	O
,	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
j	int
++	O
;	O
}	O
}	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
field_id	struct(char,int,char,int)
*	O
parse_field_order_string	(*(struct(long,enum(int,int,int),*(char))),*(int))->(*(struct(char,int,char,int)))
(	O
string	*(char)
,	O
field_count	*(int)
)	O
STRINGTYPE	O
*	O
string	*(char)
;	O
int	O
*	O
field_count	*(int)
;	O
{	O
field_id	struct(char,int,char,int)
*	O
return_array	*(struct(char,int,char,int))
;	O
char	O
*	O
curr_pos	*(char)
;	O
int	O
i	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
field_list_length	int
;	O
int	O
field_list_extra	int
;	O
int	O
return_code	int
;	O
STRINGTYPE	O
delimiter	struct(long,enum(int,int,int),*(char))
;	O
delimiter	struct(long,enum(int,int,int),*(char))
.	O
length	long
=	O
1	int
;	O
delimiter	struct(long,enum(int,int,int),*(char))
.	O
string	*(char)
=	O
","	*(char)
;	O
field_list_extra	int
=	O
0	int
;	O
return_code	int
=	O
dstrsplit	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(*(struct(long,enum(int,int,int),*`)))),*(int))->(int)
(	O
string	*(char)
,	O
&	O
delimiter	struct(long,enum(int,int,int),*(char))
,	O
&	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
field_list_length	int
==	O
0	int
)	O
return	O
NULL	O
;	O
return_array	*(struct(char,int,char,int))
=	O
malloc	(long)->(*(void))
(	O
field_list_length	int
*	O
sizeof	O
(	O
field_id	struct(char,int,char,int)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(char,int,char,int))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
{	O
curr_pos	*(char)
=	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	*(char)
;	O
switch	O
(	O
*	O
curr_pos	*(char)
)	O
{	O
case	O
'r'	O
:	O
case	O
'd'	O
:	O
case	O
'o'	O
:	O
case	O
's'	O
:	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source	char
=	O
*	O
curr_pos	*(char)
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"field order specification starts with %c:  only %s are supported"	*(char)
)	O
,	O
*	O
curr_pos	*(char)
,	O
"r, d, o, s"	*(char)
)	O
;	O
}	O
curr_pos	*(char)
++	O
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source_num	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
curr_pos	*(char)
,	O
&	O
curr_pos	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source_num	int
==	O
LONG_MIN	O
||	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source_num	int
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
curr_pos	*(char)
==	O
'.'	O
)	O
curr_pos	*(char)
++	O
;	O
else	O
FATAL_ERROR2	O
(	O
_	O
(	O
"badly formed field order specification: %.*s"	*(char)
)	O
,	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
length	long
,	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	*(char)
)	O
;	O
switch	O
(	O
*	O
curr_pos	*(char)
)	O
{	O
case	O
'o'	O
:	O
case	O
'k'	O
:	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
case	O
'e'	O
:	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type	char
=	O
*	O
curr_pos	*(char)
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR3	O
(	O
_	O
(	O
"badly formed field order specification: type %c unknown: %.*s"	*(char)
)	O
,	O
*	O
curr_pos	*(char)
,	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
length	long
,	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	*(char)
)	O
;	O
}	O
curr_pos	*(char)
++	O
;	O
if	O
(	O
*	O
curr_pos	*(char)
==	O
'-'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"field number started with -; use a positive number or range 1-n"	*(char)
)	O
)	O
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
curr_pos	*(char)
,	O
&	O
curr_pos	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
==	O
LONG_MIN	O
||	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
curr_pos	*(char)
==	O
'-'	O
)	O
{	O
int	O
upper_bound	long
;	O
int	O
lower_bound	long
;	O
int	O
j	int
;	O
curr_pos	*(char)
++	O
;	O
if	O
(	O
*	O
curr_pos	*(char)
==	O
','	O
||	O
*	O
curr_pos	*(char)
==	O
'\0'	O
)	O
{	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
*=	O
-	O
1	int
;	O
}	O
else	O
{	O
lower_bound	long
=	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
+	O
1	int
;	O
upper_bound	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
curr_pos	*(char)
,	O
&	O
curr_pos	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
upper_bound	long
==	O
LONG_MIN	O
||	O
upper_bound	long
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	*(char)
)	O
)	O
;	O
field_list_length	int
+=	O
upper_bound	long
-	O
lower_bound	long
+	O
1	int
;	O
return_array	*(struct(char,int,char,int))
=	O
realloc	(*(void),long)->(*(void))
(	O
return_array	*(struct(char,int,char,int))
,	O
field_list_length	int
*	O
sizeof	O
(	O
field_id	struct(char,int,char,int)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(char,int,char,int))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
j	int
=	O
lower_bound	long
;	O
j	int
<=	O
upper_bound	long
;	O
j	int
++	O
)	O
{	O
i	int
++	O
;	O
field_list_extra	int
++	O
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source	char
=	O
return_array	*(struct(char,int,char,int))
[	O
i	int
-	O
1	int
]	O
.	O
source	char
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
source_num	int
=	O
return_array	*(struct(char,int,char,int))
[	O
i	int
-	O
1	int
]	O
.	O
source_num	int
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type	char
=	O
return_array	*(struct(char,int,char,int))
[	O
i	int
-	O
1	int
]	O
.	O
type	char
;	O
return_array	*(struct(char,int,char,int))
[	O
i	int
]	O
.	O
type_num	int
=	O
j	int
;	O
}	O
}	O
}	O
}	O
*	O
field_count	*(int)
=	O
field_list_length	int
;	O
return	O
return_array	*(struct(char,int,char,int))
;	O
}	O
field_id	struct(char,int,char,int)
*	O
parse_join_order_string	(*(struct(long,enum(int,int,int),*(char))),*(int))->(*(struct(char,int,char,int)))
(	O
string	*(char)
,	O
field_count	*(int)
)	O
STRINGTYPE	O
*	O
string	*(char)
;	O
int	O
*	O
field_count	*(int)
;	O
{	O
field_id	struct(char,int,char,int)
*	O
return_array	*(struct(char,int,char,int))
;	O
char	O
*	O
curr_pos	*(char)
;	O
int	O
i	int
;	O
int	O
field_list_length	int
;	O
int	O
have_file	int
;	O
return_array	*(struct(char,int,char,int))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
field_id	struct(char,int,char,int)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(char,int,char,int))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
curr_pos	*(char)
=	O
string	*(char)
->	O
string	*(char)
;	O
i	int
=	O
0	int
;	O
field_list_length	int
=	O
0	int
;	O
have_file	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string	*(char)
->	O
length	long
)	O
{	O
if	O
(	O
*	O
curr_pos	*(char)
==	O
','	O
||	O
*	O
curr_pos	*(char)
==	O
' '	O
||	O
*	O
curr_pos	*(char)
==	O
'\t'	O
)	O
{	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
have_file	int
=	O
0	int
;	O
field_list_length	int
++	O
;	O
return_array	*(struct(char,int,char,int))
=	O
realloc	(*(void),long)->(*(void))
(	O
return_array	*(struct(char,int,char,int))
,	O
(	O
field_list_length	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_id	struct(char,int,char,int)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(char,int,char,int))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
have_file	int
==	O
0	int
)	O
{	O
switch	O
(	O
*	O
curr_pos	*(char)
)	O
{	O
case	O
'0'	O
:	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
if	O
(	O
i	int
<	O
string	*(char)
->	O
length	long
&&	O
*	O
curr_pos	*(char)
!=	O
','	O
&&	O
*	O
curr_pos	*(char)
!=	O
' '	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"the join key (file 0) is misspecified"	*(char)
)	O
)	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'r'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
1	int
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
1	int
;	O
field_list_length	int
++	O
;	O
return_array	*(struct(char,int,char,int))
=	O
realloc	(*(void),long)->(*(void))
(	O
return_array	*(struct(char,int,char,int))
,	O
(	O
field_list_length	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_id	struct(char,int,char,int)
)	O
)	O
;	O
if	O
(	O
return_array	*(struct(char,int,char,int))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source	char
=	O
's'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
0	int
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
1	int
;	O
break	O
;	O
case	O
'1'	O
:	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'r'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
1	int
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
0	int
;	O
have_file	int
=	O
-	O
1	int
;	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
if	O
(	O
i	int
>=	O
string	*(char)
->	O
length	long
||	O
*	O
curr_pos	*(char)
!=	O
'.'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"did not find '.' where expected in order"	*(char)
)	O
)	O
;	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
break	O
;	O
case	O
'2'	O
:	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'd'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
0	int
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
0	int
;	O
have_file	int
=	O
-	O
1	int
;	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
if	O
(	O
i	int
>=	O
string	*(char)
->	O
length	long
||	O
*	O
curr_pos	*(char)
!=	O
'.'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"did not find '.' where expected in order"	*(char)
)	O
)	O
;	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"file number must be 1 or 2 -- got %c"	*(char)
)	O
,	O
*	O
curr_pos	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
curr_pos	*(char)
<	O
'0'	O
||	O
*	O
curr_pos	*(char)
>	O
'9'	O
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"non-digit in field number: '%c'"	*(char)
)	O
,	O
*	O
curr_pos	*(char)
)	O
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
*=	O
10	int
;	O
return_array	*(struct(char,int,char,int))
[	O
field_list_length	int
]	O
.	O
type_num	int
+=	O
*	O
curr_pos	*(char)
-	O
'0'	O
;	O
i	int
++	O
;	O
curr_pos	*(char)
++	O
;	O
}	O
}	O
*	O
field_count	*(int)
=	O
field_list_length	int
+	O
1	int
;	O
return	O
return_array	*(struct(char,int,char,int))
;	O
}	O
STRINGTYPE	O
*	O
find_field	(*(struct(long,long,int,*(char))),int,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
ranges	*(struct(long,long,int,*(char)))
,	O
range_count	int
,	O
which_range	int
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
field_range	struct(long,long,int,*(char))
*	O
ranges	*(struct(long,long,int,*(char)))
;	O
int	O
range_count	int
;	O
int	O
which_range	int
;	O
STRINGTYPE	O
*	O
input_record	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
STRINGTYPE	O
*	O
return_string	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
*	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
return_code	int
=	O
dstrsplit	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(*(struct(long,enum(int,int,int),*`)))),*(int))->(int)
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
input_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	*(char)
)	O
)	O
;	O
}	O
return_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
field_list	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
return	O
NULL	O
;	O
return_string	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrsubstr	(*(struct(long,enum(int,int,int),*(char))),long,long,long,enum(int,int,int))->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_record	*(struct(long,enum(int,int,int),*(char)))
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
return_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
0	int
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
upper_bound	long
||	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
upper_bound	long
>	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	*(char)
)	O
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
lower_bound	long
,	O
ranges	*(struct(long,long,int,*(char)))
[	O
which_range	int
]	O
.	O
upper_bound	long
,	O
input_record	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
}	O
return	O
return_string	*(struct(long,enum(int,int,int),*(char)))
;	O
}	O
int	O
fill_empty_fields	(*(*(struct(long,enum(int,int,int),*(char)))),long,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
field_count	*(int)
,	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
STRINGTYPE	O
*	O
*	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
size_t	long
field_count	*(int)
;	O
STRINGTYPE	O
*	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_count	*(int)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
)	O
;	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
=	O
dstrdup	(*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
empty_replacement	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	int
]	O
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
