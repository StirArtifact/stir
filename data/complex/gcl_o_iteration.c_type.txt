static	O
void	O
FFN	(int)->(int)
(	O
Floop	int
)	O
(	O
object	int
form	int
)	O
{	O
object	int
x	O
;	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
object	int
*	O
top	O
;	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
return	O
;	O
}	O
top	O
=	O
vs_top	O
;	O
for	O
(	O
x	O
=	O
form	int
;	O
!	O
endp	()->(int)
(	O
x	O
)	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
}	O
LOOP	O
:	O
for	O
(	O
x	O
=	O
form	int
;	O
x	O
!=	O
Cnil	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
}	O
goto	O
LOOP	O
;	O
}	O
static	O
void	O
do_var_list	(int)->(void)
(	O
object	int
var_list	int
)	O
{	O
object	int
is	O
,	O
x	O
,	O
y	O
;	O
for	O
(	O
is	O
=	O
var_list	int
;	O
!	O
endp	()->(int)
(	O
is	O
)	O
;	O
is	O
=	O
MMcdr	()->(int)
(	O
is	O
)	O
)	O
{	O
x	O
=	O
MMcar	()->(int)
(	O
is	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
==	O
t_symbol	O
)	O
{	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
!=	O
t_cons	O
)	O
FEinvalid_form	()->(int)
(	O
"The index, ~S, is illegal."	*(char)
,	O
x	O
)	O
;	O
y	O
=	O
MMcar	()->(int)
(	O
x	O
)	O
;	O
check_var	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
)	O
{	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
)	O
;	O
}	O
else	O
{	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
)	O
vs_push	()->(int)
(	O
y	O
)	O
;	O
else	O
{	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Too many forms to the index ~S."	*(char)
,	O
1	int
,	O
y	O
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdo	int
)	O
(	O
VOL	O
object	int
arg	O
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
object	int
*	O
old_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
*	O
end	*(struct)
,	O
*	O
bt	*(struct)
;	O
object	int
end_test	O
,	O
body	O
;	O
VOL	O
object	int
result	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	O
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcadr	()->(int)
(	O
arg	O
)	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"The DO end-test, ~S, is illegal."	*(char)
,	O
MMcadr	()->(int)
(	O
arg	O
)	O
)	O
;	O
end_test	O
=	O
MMcaadr	()->(int)
(	O
arg	O
)	O
;	O
result	O
=	O
MMcdadr	()->(int)
(	O
arg	O
)	O
;	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
do_var_list	(int)->(void)
(	O
MMcar	()->(int)
(	O
arg	O
)	O
)	O
;	O
end	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
body	O
=	O
let_bind	()->(int)
(	O
MMcddr	()->(int)
(	O
arg	O
)	O
,	O
start	*(struct)
,	O
end	*(struct)
)	O
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
if	O
(	O
(	O
enum	O
stype	O
)	O
bt	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_stype	O
!=	O
stp_ordinary	O
)	O
bt	*(struct)
->	O
bt_spp	O
=	O
Ct	O
;	O
else	O
if	O
(	O
bt	*(struct)
->	O
bt_spp	O
==	O
Cnil	O
)	O
bt	*(struct)
->	O
bt_spp	O
=	O
assoc_eq	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
old_top	O
=	O
vs_top	O
;	O
LOOP	O
:	O
vs_top	O
=	O
old_top	O
;	O
eval	()->(int)
(	O
end_test	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
!=	O
Cnil	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
result	O
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
old_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
old_top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
result	O
)	O
)	O
;	O
result	O
=	O
MMcdr	()->(int)
(	O
result	O
)	O
;	O
}	O
while	O
(	O
!	O
endp	()->(int)
(	O
result	O
)	O
)	O
;	O
goto	O
END	O
;	O
}	O
vs_top	O
=	O
old_top	O
;	O
Ftagbody	()->(int)
(	O
body	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
if	O
(	O
bt	*(struct)
->	O
bt_aux	O
!=	O
bt	*(struct)
->	O
bt_var	O
)	O
{	O
eval_assign	()->(int)
(	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_aux	O
)	O
;	O
}	O
}	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
if	O
(	O
bt	*(struct)
->	O
bt_aux	O
!=	O
bt	*(struct)
->	O
bt_var	O
)	O
{	O
if	O
(	O
bt	*(struct)
->	O
bt_spp	O
==	O
Ct	O
)	O
bt	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
=	O
bt	*(struct)
->	O
bt_init	O
;	O
else	O
MMcadr	()->(int)
(	O
bt	*(struct)
->	O
bt_spp	O
)	O
=	O
bt	*(struct)
->	O
bt_init	O
;	O
}	O
}	O
goto	O
LOOP	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
FdoA	int
)	O
(	O
VOL	O
object	int
arg	O
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
object	int
*	O
old_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
*	O
end	*(struct)
,	O
*	O
bt	*(struct)
;	O
object	int
end_test	O
,	O
body	O
;	O
VOL	O
object	int
result	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	O
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
MMcadr	()->(int)
(	O
arg	O
)	O
)	O
)	O
FEinvalid_form	()->(int)
(	O
"The DO* end-test, ~S, is illegal."	*(char)
,	O
MMcadr	()->(int)
(	O
arg	O
)	O
)	O
;	O
end_test	O
=	O
MMcaadr	()->(int)
(	O
arg	O
)	O
;	O
result	O
=	O
MMcdadr	()->(int)
(	O
arg	O
)	O
;	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
do_var_list	(int)->(void)
(	O
MMcar	()->(int)
(	O
arg	O
)	O
)	O
;	O
end	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
body	O
=	O
letA_bind	()->(int)
(	O
MMcddr	()->(int)
(	O
arg	O
)	O
,	O
start	*(struct)
,	O
end	*(struct)
)	O
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
if	O
(	O
(	O
enum	O
stype	O
)	O
bt	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_stype	O
!=	O
stp_ordinary	O
)	O
bt	*(struct)
->	O
bt_spp	O
=	O
Ct	O
;	O
else	O
if	O
(	O
bt	*(struct)
->	O
bt_spp	O
==	O
Cnil	O
)	O
bt	*(struct)
->	O
bt_spp	O
=	O
assoc_eq	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
old_top	O
=	O
vs_top	O
;	O
LOOP	O
:	O
eval	()->(int)
(	O
end_test	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
!=	O
Cnil	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
result	O
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
old_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
old_top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
result	O
)	O
)	O
;	O
result	O
=	O
MMcdr	()->(int)
(	O
result	O
)	O
;	O
}	O
while	O
(	O
!	O
endp	()->(int)
(	O
result	O
)	O
)	O
;	O
goto	O
END	O
;	O
}	O
vs_top	O
=	O
old_top	O
;	O
Ftagbody	()->(int)
(	O
body	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
if	O
(	O
bt	*(struct)
->	O
bt_aux	O
!=	O
bt	*(struct)
->	O
bt_var	O
)	O
{	O
if	O
(	O
bt	*(struct)
->	O
bt_spp	O
==	O
Ct	O
)	O
{	O
eval_assign	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
,	O
bt	*(struct)
->	O
bt_aux	O
)	O
;	O
}	O
else	O
{	O
eval_assign	()->(int)
(	O
MMcadr	()->(int)
(	O
bt	*(struct)
->	O
bt_spp	O
)	O
,	O
bt	*(struct)
->	O
bt_aux	O
)	O
;	O
}	O
}	O
goto	O
LOOP	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdolist	int
)	O
(	O
VOL	O
object	int
arg	O
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
object	int
*	O
old_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	int
x	O
,	O
listform	O
,	O
body	O
;	O
VOL	O
object	int
result	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	O
)	O
;	O
x	O
=	O
MMcar	()->(int)
(	O
arg	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
FEerror	()->(int)
(	O
"No variable."	*(char)
,	O
0	int
)	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
FEerror	()->(int)
(	O
"No listform."	*(char)
,	O
0	int
)	O
;	O
listform	O
=	O
MMcar	()->(int)
(	O
x	O
)	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
result	O
=	O
Cnil	O
;	O
else	O
{	O
result	O
=	O
MMcar	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Too many resultforms."	*(char)
,	O
0	int
)	O
;	O
}	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
eval_assign	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
,	O
listform	O
)	O
;	O
body	O
=	O
find_special	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	O
)	O
,	O
start	*(struct)
,	O
start	*(struct)
+	O
1	int
)	O
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
bind_var	()->(int)
(	O
start	*(struct)
->	O
bt_var	O
,	O
Cnil	O
,	O
start	*(struct)
->	O
bt_spp	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_stype	O
!=	O
stp_ordinary	O
)	O
start	*(struct)
->	O
bt_spp	O
=	O
Ct	O
;	O
else	O
if	O
(	O
start	*(struct)
->	O
bt_spp	O
==	O
Cnil	O
)	O
start	*(struct)
->	O
bt_spp	O
=	O
assoc_eq	()->(int)
(	O
start	*(struct)
->	O
bt_var	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
old_top	O
=	O
vs_top	O
;	O
LOOP	O
:	O
if	O
(	O
endp	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
)	O
{	O
if	O
(	O
start	*(struct)
->	O
bt_spp	O
==	O
Ct	O
)	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
=	O
Cnil	O
;	O
else	O
MMcadr	()->(int)
(	O
start	*(struct)
->	O
bt_spp	O
)	O
=	O
Cnil	O
;	O
eval	()->(int)
(	O
result	O
)	O
;	O
goto	O
END	O
;	O
}	O
if	O
(	O
start	*(struct)
->	O
bt_spp	O
==	O
Ct	O
)	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
=	O
MMcar	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
;	O
else	O
MMcadr	()->(int)
(	O
start	*(struct)
->	O
bt_spp	O
)	O
=	O
MMcar	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
;	O
start	*(struct)
->	O
bt_init	O
=	O
MMcdr	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
;	O
vs_top	O
=	O
old_top	O
;	O
Ftagbody	()->(int)
(	O
body	O
)	O
;	O
goto	O
LOOP	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdotimes	int
)	O
(	O
VOL	O
object	int
arg	O
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
object	int
*	O
old_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	int
x	O
,	O
countform	O
,	O
body	O
;	O
VOL	O
object	int
result	O
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	O
)	O
;	O
x	O
=	O
MMcar	()->(int)
(	O
arg	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
FEerror	()->(int)
(	O
"No variable."	*(char)
,	O
0	int
)	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
x	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
FEerror	()->(int)
(	O
"No countform."	*(char)
,	O
0	int
)	O
;	O
countform	O
=	O
MMcar	()->(int)
(	O
x	O
)	O
;	O
x	O
=	O
MMcdr	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
result	O
=	O
Cnil	O
;	O
else	O
{	O
result	O
=	O
MMcar	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
x	O
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Too many resultforms."	*(char)
,	O
0	int
)	O
;	O
}	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
eval_assign	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
,	O
countform	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
!=	O
t_fixnum	O
&&	O
type_of	()->(int)
(	O
start	*(struct)
->	O
bt_init	O
)	O
!=	O
t_bignum	O
)	O
FEwrong_type_argument	()->(int)
(	O
sLinteger	O
,	O
start	*(struct)
->	O
bt_init	O
)	O
;	O
body	O
=	O
find_special	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	O
)	O
,	O
start	*(struct)
,	O
start	*(struct)
+	O
1	int
)	O
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
bind_var	()->(int)
(	O
start	*(struct)
->	O
bt_var	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
start	*(struct)
->	O
bt_spp	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_stype	O
!=	O
stp_ordinary	O
)	O
{	O
start	*(struct)
->	O
bt_spp	O
=	O
Ct	O
;	O
x	O
=	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
;	O
}	O
else	O
if	O
(	O
start	*(struct)
->	O
bt_spp	O
==	O
Cnil	O
)	O
{	O
start	*(struct)
->	O
bt_spp	O
=	O
assoc_eq	()->(int)
(	O
start	*(struct)
->	O
bt_var	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
x	O
=	O
MMcadr	()->(int)
(	O
start	*(struct)
->	O
bt_spp	O
)	O
;	O
}	O
else	O
x	O
=	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
;	O
old_top	O
=	O
vs_top	O
;	O
LOOP	O
:	O
if	O
(	O
number_compare	()->(int)
(	O
x	O
,	O
start	*(struct)
->	O
bt_init	O
)	O
>=	O
0	int
)	O
{	O
eval	()->(int)
(	O
result	O
)	O
;	O
goto	O
END	O
;	O
}	O
vs_top	O
=	O
old_top	O
;	O
Ftagbody	()->(int)
(	O
body	O
)	O
;	O
if	O
(	O
start	*(struct)
->	O
bt_spp	O
==	O
Ct	O
)	O
x	O
=	O
start	*(struct)
->	O
bt_var	O
->	O
s	O
.	O
s_dbind	O
=	O
one_plus	()->(int)
(	O
x	O
)	O
;	O
else	O
x	O
=	O
MMcadr	()->(int)
(	O
start	*(struct)
->	O
bt_spp	O
)	O
=	O
one_plus	()->(int)
(	O
x	O
)	O
;	O
goto	O
LOOP	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
void	O
gcl_init_iteration	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"LOOP"	*(char)
,	O
Floop	int
)	O
;	O
make_special_form	()->(int)
(	O
"DO"	*(char)
,	O
Fdo	int
)	O
;	O
make_special_form	()->(int)
(	O
"DO*"	*(char)
,	O
FdoA	int
)	O
;	O
make_special_form	()->(int)
(	O
"DOLIST"	*(char)
,	O
Fdolist	int
)	O
;	O
make_special_form	()->(int)
(	O
"DOTIMES"	*(char)
,	O
Fdotimes	int
)	O
;	O
}	O
