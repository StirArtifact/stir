char	O
doopt	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
DO	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
dont	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
DONT	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
will	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
WILL	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
wont	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
WONT	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
int	O
not42	int
=	O
1	int
;	O
unsigned	O
char	O
subbuffer	array(char)
[	O
512	int
]	O
,	O
*	O
subpointer	*(char)
=	O
subbuffer	array(char)
,	O
*	O
subend	*(char)
=	O
subbuffer	array(char)
;	O
static	O
void	O
send_eof	()->(void)
(	O
void	O
)	O
{	O
init_termbuf	()->(void)
(	O
)	O
;	O
term_send_eof	()->(void)
(	O
)	O
;	O
pty_output_byte	(int)->(void)
(	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_EOF	int
]	O
.	O
sptr	*(char)
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_EOF	int
]	O
.	O
sptr	*(char)
:	O
'\004'	O
)	O
;	O
}	O
static	O
void	O
recv_ayt	()->(void)
(	O
void	O
)	O
{	O
net_output_data	(*(char))->(int)
(	O
"\r\n[Yes]\r\n"	*(char)
)	O
;	O
}	O
static	O
void	O
send_susp	()->(void)
(	O
void	O
)	O
{	O
ptyflush	()->(void)
(	O
)	O
;	O
pty_output_byte	(int)->(void)
(	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_SUSP	int
]	O
.	O
sptr	*(char)
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_SUSP	int
]	O
.	O
sptr	*(char)
:	O
'\032'	O
)	O
;	O
}	O
static	O
void	O
send_brk	()->(void)
(	O
void	O
)	O
{	O
ptyflush	()->(void)
(	O
)	O
;	O
init_termbuf	()->(void)
(	O
)	O
;	O
pty_output_byte	(int)->(void)
(	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_ABORT	int
]	O
.	O
sptr	*(char)
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_ABORT	int
]	O
.	O
sptr	*(char)
:	O
'\034'	O
)	O
;	O
}	O
static	O
void	O
send_intr	()->(void)
(	O
void	O
)	O
{	O
ptyflush	()->(void)
(	O
)	O
;	O
init_termbuf	()->(void)
(	O
)	O
;	O
pty_output_byte	(int)->(void)
(	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_IP	int
]	O
.	O
sptr	*(char)
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_IP	int
]	O
.	O
sptr	*(char)
:	O
'\177'	O
)	O
;	O
}	O
void	O
telrcv	()->(void)
(	O
void	O
)	O
{	O
register	O
int	O
c	int
;	O
static	O
int	O
state	*(int)
=	O
TS_DATA	int
;	O
while	O
(	O
(	O
net_input_level	()->(int)
(	O
)	O
>	O
0	int
)	O
&	O
!	O
pty_buffer_is_full	()->(int)
(	O
)	O
)	O
{	O
c	int
=	O
net_get_char	(int)->(int)
(	O
0	int
)	O
;	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
TS_CR	int
:	O
state	*(int)
=	O
TS_DATA	int
;	O
if	O
(	O
(	O
c	int
==	O
0	int
)	O
||	O
(	O
c	int
==	O
'\n'	O
)	O
)	O
break	O
;	O
case	O
TS_DATA	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
state	*(int)
=	O
TS_IAC	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
c	int
==	O
'\r'	O
)	O
&&	O
his_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
int	O
nc	int
=	O
net_get_char	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
linemode	int
&&	O
net_input_level	()->(int)
(	O
)	O
>	O
0	int
&&	O
(	O
(	O
'\n'	O
==	O
nc	int
)	O
||	O
(	O
!	O
nc	int
&&	O
tty_iscrnl	()->(int)
(	O
)	O
)	O
)	O
)	O
{	O
net_get_char	(int)->(int)
(	O
0	int
)	O
;	O
c	int
=	O
'\n'	O
;	O
}	O
else	O
{	O
state	*(int)
=	O
TS_CR	int
;	O
}	O
}	O
pty_output_byte	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
case	O
TS_IAC	int
:	O
gotiac	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
IP	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
send_intr	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BREAK	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
send_brk	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
AYT	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
recv_ayt	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
AO	int
:	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
ptyflush	()->(void)
(	O
)	O
;	O
init_termbuf	()->(void)
(	O
)	O
;	O
if	O
(	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_AO	int
]	O
.	O
sptr	*(char)
&&	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_AO	int
]	O
.	O
sptr	*(char)
!=	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
pty_output_byte	(int)->(void)
(	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_AO	int
]	O
.	O
sptr	*(char)
)	O
;	O
netclear	()->(void)
(	O
)	O
;	O
net_output_data	(*(char))->(int)
(	O
"%c%c"	*(char)
,	O
IAC	int
,	O
DM	int
)	O
;	O
set_neturg	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send IAC"	*(char)
,	O
DM	int
)	O
)	O
;	O
break	O
;	O
}	O
case	O
EC	int
:	O
case	O
EL	int
:	O
{	O
cc_t	char
ch	char
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
ptyflush	()->(void)
(	O
)	O
;	O
init_termbuf	()->(void)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EC	int
)	O
ch	char
=	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_EC	int
]	O
.	O
sptr	*(char)
;	O
else	O
ch	char
=	O
*	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_EL	int
]	O
.	O
sptr	*(char)
;	O
if	O
(	O
ch	char
!=	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
pty_output_byte	(int)->(void)
(	O
(	O
unsigned	O
char	O
)	O
ch	char
)	O
;	O
break	O
;	O
}	O
case	O
DM	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv IAC"	*(char)
,	O
c	int
)	O
)	O
;	O
SYNCHing	int
=	O
stilloob	(int)->(int)
(	O
net	int
)	O
;	O
settimer	O
(	O
gotDM	int
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
state	*(int)
=	O
TS_SB	int
;	O
SB_CLEAR	O
(	O
)	O
;	O
continue	O
;	O
case	O
WILL	int
:	O
state	*(int)
=	O
TS_WILL	int
;	O
continue	O
;	O
case	O
WONT	int
:	O
state	*(int)
=	O
TS_WONT	int
;	O
continue	O
;	O
case	O
DO	int
:	O
state	*(int)
=	O
TS_DO	int
;	O
continue	O
;	O
case	O
DONT	int
:	O
state	*(int)
=	O
TS_DONT	int
;	O
continue	O
;	O
case	O
EOR	int
:	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_EOR	int
)	O
)	O
send_eof	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
xEOF	int
:	O
send_eof	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
SUSP	int
:	O
send_susp	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
ABORT	int
:	O
send_brk	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
IAC	int
:	O
pty_output_byte	(int)->(void)
(	O
c	int
)	O
;	O
break	O
;	O
}	O
state	*(int)
=	O
TS_DATA	int
;	O
break	O
;	O
case	O
TS_SB	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
state	*(int)
=	O
TS_SE	int
;	O
else	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
break	O
;	O
case	O
TS_SE	int
:	O
if	O
(	O
c	int
!=	O
SE	int
)	O
{	O
if	O
(	O
c	int
!=	O
IAC	int
)	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
subpointer	*(char)
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	()->(void)
(	O
)	O
;	O
state	*(int)
=	O
TS_IAC	int
;	O
goto	O
gotiac	O
;	O
}	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
state	*(int)
=	O
TS_SB	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
SE	int
)	O
;	O
subpointer	*(char)
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	()->(void)
(	O
)	O
;	O
state	*(int)
=	O
TS_DATA	int
;	O
}	O
break	O
;	O
case	O
TS_WILL	int
:	O
willoption	(int)->(void)
(	O
c	int
)	O
;	O
state	*(int)
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WONT	int
:	O
wontoption	(int)->(void)
(	O
c	int
)	O
;	O
state	*(int)
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DO	int
:	O
dooption	(int)->(void)
(	O
c	int
)	O
;	O
state	*(int)
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DONT	int
:	O
dontoption	(int)->(void)
(	O
c	int
)	O
;	O
state	*(int)
=	O
TS_DATA	int
;	O
continue	O
;	O
default	O
:	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"telnetd: panic state=%d\n"	*(char)
,	O
state	*(int)
)	O
;	O
printf	(*(char))->(int)
(	O
"telnetd: panic state=%d\n"	*(char)
,	O
state	*(int)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
void	O
send_do	(int,int)->(void)
(	O
int	O
option	int
,	O
int	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
&&	O
his_state_is_will	O
(	O
option	int
)	O
)	O
||	O
his_want_state_is_will	O
(	O
option	int
)	O
)	O
return	O
;	O
if	O
(	O
option	int
==	O
TELOPT_TM	int
)	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
else	O
set_his_want_state_will	O
(	O
option	int
)	O
;	O
do_dont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	(*(char))->(int)
(	O
doopt	array(char)
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send do"	*(char)
,	O
option	int
)	O
)	O
;	O
}	O
extern	O
void	O
doclientstat	()->(void)
(	O
void	O
)	O
;	O
void	O
willoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
int	O
changeok	int
=	O
0	int
;	O
void	O
(	O
*	O
func	int
)	O
(	O
)	O
=	O
0	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv will"	*(char)
,	O
option	int
)	O
)	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
do_dont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
&&	O
his_state_is_will	O
(	O
option	int
)	O
)	O
do_dont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
his_want_state_is_wont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_binaryin	(int)->(void)
(	O
1	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
0	int
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
lmodetype	int
<	O
KLUDGE_LINEMODE	int
)	O
{	O
lmodetype	int
=	O
KLUDGE_LINEMODE	int
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
send_wont	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
lmodetype	int
==	O
NO_AUTOKLUDGE	int
)	O
lmodetype	int
=	O
KLUDGE_OK	int
;	O
return	O
;	O
case	O
TELOPT_LFLOW	int
:	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XON	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XON	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
|=	O
SLC_DEFAULT	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XOFF	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XOFF	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
|=	O
SLC_DEFAULT	int
;	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_SGA	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_XDISPLOC	int
:	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
lmodetype	int
=	O
REAL_LINEMODE	int
;	O
func	int
=	O
doclientstat	()->(void)
;	O
changeok	int
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
changeok	int
)	O
{	O
set_his_want_state_will	O
(	O
option	int
)	O
;	O
send_do	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
do_dont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
send_dont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
0	int
;	O
send_dont	(int,int)->(void)
(	O
option	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
lmodetype	int
=	O
REAL_LINEMODE	int
;	O
func	int
=	O
doclientstat	()->(void)
;	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
func	int
=	O
flowstat	()->(void)
;	O
break	O
;	O
}	O
}	O
}	O
set_his_state_will	O
(	O
option	int
)	O
;	O
if	O
(	O
func	int
)	O
(	O
*	O
func	int
)	O
(	O
)	O
;	O
}	O
void	O
send_dont	(int,int)->(void)
(	O
int	O
option	int
,	O
int	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
&&	O
his_state_is_wont	O
(	O
option	int
)	O
)	O
||	O
his_want_state_is_wont	O
(	O
option	int
)	O
)	O
return	O
;	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
do_dont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	(*(char))->(int)
(	O
dont	array(char)
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send dont"	*(char)
,	O
option	int
)	O
)	O
;	O
}	O
void	O
wontoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv wont"	*(char)
,	O
option	int
)	O
)	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
do_dont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
&&	O
his_state_is_wont	O
(	O
option	int
)	O
)	O
do_dont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
his_want_state_is_will	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_binaryin	(int)->(void)
(	O
0	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
if	O
(	O
lmodetype	int
!=	O
REAL_LINEMODE	int
)	O
break	O
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
set_his_want_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LFLOW	int
:	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XON	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XON	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
|=	O
SLC_CANTCHANGE	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XOFF	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array(struct(struct(char,char),struct(char,char),*(char)))
[	O
SLC_XOFF	int
]	O
.	O
defset	struct(char,char)
.	O
flag	char
|=	O
SLC_CANTCHANGE	int
;	O
break	O
;	O
case	O
TELOPT_TTYPE	int
:	O
settimer	O
(	O
ttypesubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
settimer	O
(	O
tspeedsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
settimer	O
(	O
xdisplocsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
settimer	O
(	O
oenvironsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
settimer	O
(	O
environsubopt	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
option	int
)	O
)	O
send_dont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
lmodetype	int
<	O
NO_AUTOKLUDGE	int
)	O
{	O
lmodetype	int
=	O
NO_LINEMODE	int
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
set_his_state_wont	O
(	O
option	int
)	O
;	O
}	O
void	O
send_will	(int,int)->(void)
(	O
int	O
option	int
,	O
int	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
||	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
return	O
;	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
will_wont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	(*(char))->(int)
(	O
will	array(char)
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send will"	*(char)
,	O
option	int
)	O
)	O
;	O
}	O
void	O
dooption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
int	O
changeok	int
=	O
0	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv do"	*(char)
,	O
option	int
)	O
)	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
will_wont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
will_wont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
(	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
if	O
(	O
lmodetype	int
==	O
NO_LINEMODE	int
)	O
{	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_setecho	(int)->(void)
(	O
1	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
}	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_binaryout	(int)->(void)
(	O
1	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
lmodetype	int
==	O
KLUDGE_LINEMODE	int
)	O
{	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
if	O
(	O
linemode	int
)	O
break	O
;	O
}	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_STATUS	int
:	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
send_will	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LOGOUT	int
:	O
set_my_want_state_will	O
(	O
TELOPT_LOGOUT	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_LOGOUT	int
,	O
0	int
)	O
;	O
set_my_state_will	O
(	O
TELOPT_LOGOUT	int
)	O
;	O
netflush	()->(void)
(	O
)	O
;	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
(	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_LFLOW	int
:	O
case	O
TELOPT_XDISPLOC	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
changeok	int
)	O
{	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
send_will	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
will_wont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
send_wont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
set_my_state_will	O
(	O
option	int
)	O
;	O
}	O
void	O
send_wont	(int,int)->(void)
(	O
int	O
option	int
,	O
int	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
init	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))),int)->(int))
)	O
{	O
if	O
(	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
||	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
return	O
;	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
will_wont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	(*(char))->(int)
(	O
wont	array(char)
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: send wont"	*(char)
,	O
option	int
)	O
)	O
;	O
}	O
void	O
dontoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	(*(char),int)->(void)
(	O
"td: recv dont"	*(char)
,	O
option	int
)	O
)	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
will_wont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
will_wont_resp	array(char)
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
(	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_binaryout	(int)->(void)
(	O
0	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
if	O
(	O
(	O
lmodetype	int
!=	O
REAL_LINEMODE	int
)	O
&&	O
(	O
lmodetype	int
!=	O
KLUDGE_LINEMODE	int
)	O
)	O
{	O
init_termbuf	()->(void)
(	O
)	O
;	O
tty_setecho	(int)->(void)
(	O
0	int
)	O
;	O
set_termbuf	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
(	O
lmodetype	int
==	O
KLUDGE_LINEMODE	int
)	O
||	O
(	O
lmodetype	int
==	O
KLUDGE_OK	int
)	O
)	O
{	O
lmodetype	int
=	O
KLUDGE_LINEMODE	int
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_will	O
(	O
option	int
)	O
)	O
send_wont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
}	O
void	O
suboption	()->(void)
(	O
void	O
)	O
{	O
register	O
int	O
subchar	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printsub	*((*(char),int,*(char),int)->(void))
(	O
'<'	O
,	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
+	O
2	int
)	O
)	O
;	O
subchar	int
=	O
SB_GET	O
(	O
)	O
;	O
switch	O
(	O
subchar	int
)	O
{	O
case	O
TELOPT_TSPEED	int
:	O
{	O
register	O
int	O
xspeed	int
,	O
rspeed	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TSPEED	int
)	O
)	O
break	O
;	O
settimer	O
(	O
tspeedsubopt	int
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
xspeed	int
=	O
atoi	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
subpointer	*(char)
)	O
;	O
while	O
(	O
SB_GET	O
(	O
)	O
!=	O
','	O
&&	O
!	O
SB_EOF	O
(	O
)	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
rspeed	int
=	O
atoi	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
subpointer	*(char)
)	O
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_TSPEED	int
,	O
xspeed	int
,	O
rspeed	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_TTYPE	int
:	O
{	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
break	O
;	O
settimer	O
(	O
ttypesubopt	int
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
free	(*(void))->(void)
(	O
terminaltype	*(char)
)	O
;	O
obstack_init	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
int	O
c	int
=	O
tolower	(int)->(int)
(	O
SB_GET	O
(	O
)	O
)	O
;	O
obstack_1grow	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
c	int
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
p	*(void)
=	O
obstack_finish	O
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
terminaltype	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_NAWS	int
:	O
{	O
register	O
int	O
xwinsize	int
,	O
ywinsize	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_NAWS	int
)	O
)	O
break	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
xwinsize	int
=	O
SB_GET	O
(	O
)	O
<<	O
8	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
xwinsize	int
|=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
ywinsize	int
=	O
SB_GET	O
(	O
)	O
<<	O
8	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
ywinsize	int
|=	O
SB_GET	O
(	O
)	O
;	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_NAWS	int
,	O
xwinsize	int
,	O
ywinsize	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_LINEMODE	int
:	O
{	O
register	O
int	O
request	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
break	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
request	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
if	O
(	O
request	int
==	O
LM_SLC	int
)	O
{	O
start_slc	(int)->(void)
(	O
1	int
)	O
;	O
do_opt_slc	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
subend	*(char)
-	O
subpointer	*(char)
)	O
;	O
end_slc	(*(*(char)))->(int)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
request	int
==	O
LM_MODE	int
)	O
{	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
useeditmode	int
=	O
SB_GET	O
(	O
)	O
;	O
clientstat	(int,int,int)->(void)
(	O
LM_MODE	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_STATUS	int
:	O
{	O
int	O
mode	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
mode	int
=	O
SB_GET	O
(	O
)	O
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
TELQUAL_SEND	int
:	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_STATUS	int
)	O
)	O
send_status	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_XDISPLOC	int
:	O
{	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
settimer	O
(	O
xdisplocsubopt	int
)	O
;	O
subpointer	*(char)
[	O
SB_LEN	O
(	O
)	O
]	O
=	O
'\0'	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"DISPLAY"	*(char)
,	O
(	O
char	O
*	O
)	O
subpointer	*(char)
,	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
{	O
register	O
int	O
c	int
;	O
register	O
char	O
*	O
cp	*(char)
,	O
*	O
varp	*(char)
,	O
*	O
valp	*(char)
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
TELQUAL_IS	int
)	O
{	O
if	O
(	O
subchar	int
==	O
TELOPT_OLD_ENVIRON	int
)	O
settimer	O
(	O
oenvironsubopt	int
)	O
;	O
else	O
settimer	O
(	O
environsubopt	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
TELQUAL_INFO	int
)	O
return	O
;	O
if	O
(	O
subchar	int
==	O
TELOPT_NEW_ENVIRON	int
)	O
{	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
(	O
c	int
==	O
NEW_ENV_VAR	int
)	O
||	O
(	O
c	int
==	O
ENV_USERVAR	int
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
(	O
c	int
==	O
env_ovar	O
)	O
||	O
(	O
c	int
==	O
ENV_USERVAR	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
cp	*(char)
=	O
varp	*(char)
=	O
(	O
char	O
*	O
)	O
subpointer	*(char)
;	O
valp	*(char)
=	O
0	int
;	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
subchar	int
==	O
TELOPT_OLD_ENVIRON	int
)	O
{	O
if	O
(	O
c	int
==	O
env_ovar	O
)	O
c	int
=	O
NEW_ENV_VAR	int
;	O
else	O
if	O
(	O
c	int
==	O
env_ovalue	O
)	O
c	int
=	O
NEW_ENV_VALUE	int
;	O
}	O
switch	O
(	O
c	int
)	O
{	O
case	O
NEW_ENV_VALUE	int
:	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
cp	*(char)
=	O
valp	*(char)
=	O
(	O
char	O
*	O
)	O
subpointer	*(char)
;	O
break	O
;	O
case	O
NEW_ENV_VAR	int
:	O
case	O
ENV_USERVAR	int
:	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
valp	*(char)
)	O
setenv	(*(char),*(char),int)->(int)
(	O
varp	*(char)
,	O
valp	*(char)
,	O
1	int
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
varp	*(char)
)	O
;	O
cp	*(char)
=	O
varp	*(char)
=	O
(	O
char	O
*	O
)	O
subpointer	*(char)
;	O
valp	*(char)
=	O
0	int
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
default	O
:	O
*	O
cp	*(char)
++	O
=	O
c	int
;	O
break	O
;	O
}	O
}	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
valp	*(char)
)	O
setenv	(*(char),*(char),int)->(int)
(	O
varp	*(char)
,	O
valp	*(char)
,	O
1	int
)	O
;	O
else	O
unsetenv	(*(char))->(int)
(	O
varp	*(char)
)	O
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
doclientstat	()->(void)
(	O
void	O
)	O
{	O
clientstat	(int,int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
}	O
void	O
send_status	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
char	O
statusbuf	array(char)
[	O
256	int
]	O
;	O
unsigned	O
char	O
*	O
ep	*(char)
;	O
register	O
unsigned	O
char	O
*	O
ncp	*(char)
;	O
register	O
unsigned	O
char	O
i	char
;	O
ncp	*(char)
=	O
statusbuf	array(char)
;	O
ep	*(char)
=	O
statusbuf	array(char)
+	O
sizeof	O
(	O
statusbuf	array(char)
)	O
;	O
netflush	()->(void)
(	O
)	O
;	O
ADD	O
(	O
IAC	int
)	O
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_STATUS	int
)	O
;	O
ADD	O
(	O
TELQUAL_IS	int
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<	O
(	O
unsigned	O
char	O
)	O
NTELOPTS	O
;	O
i	char
++	O
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
i	char
)	O
)	O
{	O
ADD	O
(	O
WILL	int
)	O
;	O
ADD_DATA	O
(	O
i	char
)	O
;	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
i	char
)	O
)	O
{	O
ADD	O
(	O
DO	int
)	O
;	O
ADD_DATA	O
(	O
i	char
)	O
;	O
}	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
)	O
{	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LFLOW	int
)	O
;	O
if	O
(	O
flowmode	int
)	O
ADD	O
(	O
LFLOW_ON	int
)	O
;	O
else	O
ADD	O
(	O
LFLOW_OFF	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
if	O
(	O
restartany	int
>=	O
0	int
)	O
{	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LFLOW	int
)	O
;	O
if	O
(	O
restartany	int
)	O
ADD	O
(	O
LFLOW_RESTART_ANY	int
)	O
;	O
else	O
ADD	O
(	O
LFLOW_RESTART_XON	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
}	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
unsigned	O
char	O
*	O
cp	*(char)
,	O
*	O
cpe	*(char)
;	O
int	O
len	long
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
ADD	O
(	O
LM_MODE	int
)	O
;	O
ADD_DATA	O
(	O
editmode	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
ADD	O
(	O
LM_SLC	int
)	O
;	O
start_slc	(int)->(void)
(	O
0	int
)	O
;	O
send_slc	()->(void)
(	O
)	O
;	O
len	long
=	O
end_slc	(*(*(char)))->(int)
(	O
&	O
cp	*(char)
)	O
;	O
for	O
(	O
cpe	*(char)
=	O
cp	*(char)
+	O
len	long
;	O
cp	*(char)
<	O
cpe	*(char)
;	O
cp	*(char)
++	O
)	O
ADD_DATA	O
(	O
*	O
cp	*(char)
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
}	O
ADD	O
(	O
IAC	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
statusbuf	array(char)
,	O
ncp	*(char)
-	O
statusbuf	array(char)
)	O
;	O
netflush	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printsub	*((*(char),int,*(char),int)->(void))
(	O
'>'	O
,	O
statusbuf	array(char)
,	O
ncp	*(char)
-	O
statusbuf	array(char)
)	O
)	O
;	O
return	O
;	O
trunc	O
:	O
return	O
;	O
}	O
