enum	O
ascend_filter_type	enum(int,int,int)
{	O
ascend_filter_generic	int
,	O
ascend_filter_ip	int
,	O
ascend_filter_ipx	int
}	O
;	O
enum	O
ascend_filter_cmp_op	enum(int,int,int,int,int)
{	O
ascend_cmp_none	int
,	O
ascend_cmp_lt	int
,	O
ascend_cmp_eq	int
,	O
ascend_cmp_gt	int
,	O
ascend_cmp_ne	int
}	O
;	O
typedef	O
struct	O
{	O
grad_uint32_t	int
src_ip	int
;	O
grad_uint32_t	int
dst_ip	int
;	O
u_char	char
src_masklen	char
;	O
u_char	char
dst_masklen	char
;	O
u_char	char
proto	int
;	O
u_char	char
established	char
;	O
u_short	short
src_port	short
;	O
u_short	short
dst_port	short
;	O
u_char	char
src_cmp	char
;	O
u_char	char
dst_cmp	char
;	O
}	O
ASCEND_FILTER_IP	struct(int,int,char,char,char,char,short,short,char,char)
;	O
typedef	O
grad_uint32_t	int
IPXADDR	int
;	O
typedef	O
char	O
IPXNODE	array(char)
[	O
IPX_NODE_ADDR_LEN	int
]	O
;	O
typedef	O
u_short	short
IPXSOCKET	short
;	O
typedef	O
struct	O
{	O
IPXADDR	int
src_addr	int
;	O
IPXNODE	array(char)
src_node	array(char)
;	O
IPXSOCKET	short
src_socket	short
;	O
IPXADDR	int
dst_addr	int
;	O
IPXNODE	array(char)
dst_node	array(char)
;	O
IPXSOCKET	short
dst_socket	short
;	O
u_char	char
src_cmp	char
;	O
u_char	char
dst_cmp	char
;	O
}	O
ASCEND_FILTER_IPX	struct(int,array(char),short,int,array(char),short,char,char)
;	O
typedef	O
struct	O
{	O
u_short	short
offset	long
;	O
u_short	short
len	int
;	O
u_short	short
more	short
;	O
u_char	char
mask	array(char)
[	O
ASCEND_MAX_CMP_LENGTH	int
]	O
;	O
u_char	char
value	*(char)
[	O
ASCEND_MAX_CMP_LENGTH	int
]	O
;	O
u_char	char
neq	char
;	O
}	O
ASCEND_FILTER_GENERIC	struct(short,short,short,array(char),array(char),char)
;	O
typedef	O
struct	O
{	O
u_char	char
type	int
;	O
u_char	char
forward	char
;	O
u_char	char
input	char
;	O
u_char	char
unused	char
;	O
union	O
{	O
ASCEND_FILTER_IP	struct(int,int,char,char,char,char,short,short,char,char)
ip	*(struct)
;	O
ASCEND_FILTER_IPX	struct(int,array(char),short,int,array(char),short,char,char)
ipx	struct(int,array(char),short,int,array(char),short,char,char)
;	O
ASCEND_FILTER_GENERIC	struct(short,short,short,array(char),array(char),char)
generic	struct(short,short,short,array(char),array(char),char)
;	O
u_char	char
fill	array(char)
[	O
26	int
]	O
;	O
}	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
;	O
}	O
ASCEND_FILTER	struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))
;	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
{	O
int	O
tokc	int
;	O
char	O
*	O
*	O
tokv	*(*(char))
;	O
int	O
tokn	int
;	O
ASCEND_FILTER	struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))
*	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
;	O
char	O
*	O
*	O
errmsg	*(*(char))
;	O
}	O
;	O
static	O
void	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
const	O
char	O
*	O
msg	*(char)
,	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
)	O
grad_astrcat	(*(*(char)))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
errmsg	*(*(char))
,	O
msg	*(char)
,	O
": "	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
grad_astrcat	(*(*(char)))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
errmsg	*(*(char))
,	O
msg	*(char)
)	O
;	O
}	O
static	O
void	O
ascend_errprints	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
size_t	long
size	int
=	O
strlen	(*(char))->(long)
(	O
fmt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
+	O
1	int
;	O
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
errmsg	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
errmsg	*(*(char))
)	O
sprintf	(*(char),*(char))->(int)
(	O
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
errmsg	*(*(char))
,	O
fmt	*(char)
,	O
arg	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
int	O
require	int
)	O
{	O
if	O
(	O
!	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
{	O
if	O
(	O
require	int
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Unexpected end of string"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
NULL	O
;	O
}	O
return	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
tokv	*(*(char))
[	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
tokn	int
++	O
]	O
;	O
}	O
static	O
char	O
*	O
_lookahead	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(*(char))
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
if	O
(	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
return	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
tokv	*(*(char))
[	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
tokn	int
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_get_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"ip"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
type	int
=	O
ascend_filter_ip	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"ipx"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
type	int
=	O
ascend_filter_ipx	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"generic"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
type	int
=	O
ascend_filter_generic	int
;	O
else	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Unknown filter type"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_dir	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
tok	int
;	O
if	O
(	O
(	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"in"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
input	char
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"out"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
input	char
=	O
0	int
;	O
else	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Invalid direction"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_action	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
tok	int
;	O
if	O
(	O
(	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"forward"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
forward	char
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"drop"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
forward	char
=	O
0	int
;	O
else	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Unknown action"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_hex_string	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
u_char	char
*	O
buf	*(char)
)	O
{	O
u_char	char
tmp	array(char)
[	O
2	int
*	O
ASCEND_MAX_CMP_LENGTH	int
]	O
,	O
*	O
p	*(struct)
;	O
char	O
*	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
int	O
len	int
,	O
rc	int
,	O
i	int
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
-	O
1	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
tok	int
)	O
;	O
if	O
(	O
len	int
>	O
2	int
*	O
ASCEND_MAX_CMP_LENGTH	int
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Octet string too long"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
len	int
/	O
2	int
;	O
if	O
(	O
len	int
%	O
2	int
)	O
rc	int
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tmp	array(char)
,	O
0	int
,	O
sizeof	O
tmp	array(char)
)	O
;	O
for	O
(	O
p	*(struct)
=	O
tmp	array(char)
;	O
len	int
;	O
len	int
--	O
,	O
p	*(struct)
++	O
,	O
tok	int
++	O
)	O
{	O
if	O
(	O
*	O
tok	int
>=	O
0	int
&&	O
*	O
tok	int
<=	O
9	int
)	O
*	O
p	*(struct)
=	O
*	O
tok	int
-	O
'0'	O
;	O
else	O
if	O
(	O
isxdigit	(int)->(int)
(	O
*	O
tok	int
)	O
)	O
{	O
if	O
(	O
*	O
tok	int
>	O
'Z'	O
)	O
*	O
p	*(struct)
=	O
*	O
tok	int
-	O
'a'	O
+	O
10	int
;	O
else	O
*	O
p	*(struct)
=	O
*	O
tok	int
-	O
'A'	O
+	O
10	int
;	O
}	O
else	O
{	O
ascend_errprints	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Invalid hex character (near %s)"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
*	O
ASCEND_MAX_CMP_LENGTH	int
;	O
i	int
++	O
)	O
*	O
buf	*(char)
++	O
=	O
(	O
tmp	array(char)
[	O
i	int
]	O
<<	O
4	int
)	O
|	O
tmp	array(char)
[	O
i	int
+	O
1	int
]	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_ascend_parse_generic	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
p	*(struct)
;	O
int	O
num	int
;	O
char	O
*	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
int	O
len	int
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
1	int
;	O
num	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
tok	int
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Invalid offset"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
offset	long
=	O
ntohs	(short)->(short)
(	O
num	int
)	O
;	O
if	O
(	O
(	O
len	int
=	O
_get_hex_string	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
mask	array(char)
)	O
)	O
<	O
0	int
)	O
return	O
1	int
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
len	int
=	O
htons	(short)->(short)
(	O
len	int
)	O
;	O
tok	int
=	O
_lookahead	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"=="	*(char)
)	O
==	O
0	int
)	O
{	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
neq	char
=	O
0	int
;	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"!="	*(char)
)	O
==	O
0	int
)	O
{	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
neq	char
=	O
1	int
;	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
num	int
=	O
_get_hex_string	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
value	*(char)
)	O
)	O
<	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
num	int
!=	O
len	int
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Value and mask are not of same size"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
0	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"more"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
generic	struct(short,short,short,array(char),array(char),char)
.	O
more	short
=	O
1	int
;	O
else	O
{	O
ascend_errprints	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Expected `more', but found `%s'"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_protocol	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
char	O
*	O
p	*(struct)
;	O
int	O
num	int
;	O
num	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
tok	int
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
proto	int
=	O
num	int
;	O
else	O
{	O
struct	O
protoent	struct(*(char),*(*(char)),int)
*	O
p	*(struct)
=	O
getprotobyname	(*(char))->(*(struct(*(char),*(*(char)),int)))
(	O
tok	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Unknown protocol"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
proto	int
=	O
p	*(struct)
->	O
p_proto	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
char	O
*	O
suffix	*(char)
,	O
int	O
lookahead	int
)	O
{	O
char	O
*	O
tok	int
=	O
lookahead	int
?	O
_lookahead	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
:	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
tok	int
&&	O
lookahead	int
)	O
return	O
ASCEND_DIR_NONE	O
;	O
if	O
(	O
tok	int
&&	O
strlen	(*(char))->(long)
(	O
tok	int
)	O
>	O
3	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
+	O
3	int
,	O
suffix	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
tok	int
,	O
"dst"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
return	O
ASCEND_DIR_DST	int
;	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
tok	int
,	O
"src"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
return	O
ASCEND_DIR_SRC	int
;	O
}	O
if	O
(	O
!	O
lookahead	int
)	O
ascend_errprints	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Expected `{src|dst}port', but found `%s'"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
ASCEND_DIR_NONE	O
;	O
}	O
static	O
int	O
_get_ip	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
int	O
dir	*(char)
=	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"ip"	*(char)
,	O
0	int
)	O
;	O
char	O
*	O
tok	int
;	O
grad_uint32_t	int
ip	*(struct)
,	O
mask	array(char)
;	O
if	O
(	O
dir	*(char)
==	O
ASCEND_DIR_NONE	O
)	O
return	O
ASCEND_DIR_NONE	O
;	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
ASCEND_DIR_NONE	O
;	O
ip	*(struct)
=	O
grad_ip_strtoip	(*(char))->(int)
(	O
tok	int
)	O
;	O
if	O
(	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
&&	O
_lookahead	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
char	O
*	O
p	*(struct)
;	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
ASCEND_DIR_NONE	O
;	O
mask	array(char)
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
tok	int
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
||	O
mask	array(char)
>	O
32	int
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Invalid netmask length"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
ASCEND_DIR_NONE	O
;	O
}	O
}	O
else	O
mask	array(char)
=	O
32	int
;	O
ip	*(struct)
=	O
htonl	(int)->(int)
(	O
ip	*(struct)
)	O
;	O
switch	O
(	O
dir	*(char)
)	O
{	O
case	O
ASCEND_DIR_SRC	int
:	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
src_ip	int
=	O
ip	*(struct)
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
src_masklen	char
=	O
mask	array(char)
;	O
break	O
;	O
case	O
ASCEND_DIR_DST	int
:	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
dst_ip	int
=	O
ip	*(struct)
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
dst_masklen	char
=	O
mask	array(char)
;	O
break	O
;	O
}	O
return	O
dir	*(char)
;	O
}	O
static	O
int	O
_ascend_parse_ip_clause	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
int	O
n	long
;	O
if	O
(	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"ip"	*(char)
,	O
1	int
)	O
==	O
ASCEND_DIR_NONE	O
)	O
return	O
0	int
;	O
n	long
=	O
_get_ip	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
n	long
==	O
ASCEND_DIR_NONE	O
)	O
return	O
1	int
;	O
if	O
(	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"ip"	*(char)
,	O
1	int
)	O
!=	O
ASCEND_DIR_NONE	O
)	O
{	O
int	O
n1	int
=	O
_get_ip	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
n1	int
==	O
n	long
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Duplicate IP specification"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_op	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
char	O
*	O
s	*(*(char))
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
s	*(*(char))
)	O
return	O
ascend_cmp_none	int
;	O
switch	O
(	O
s	*(*(char))
[	O
0	int
]	O
)	O
{	O
case	O
'>'	O
:	O
return	O
ascend_cmp_gt	int
;	O
case	O
'<'	O
:	O
return	O
ascend_cmp_lt	int
;	O
case	O
'='	O
:	O
return	O
ascend_cmp_eq	int
;	O
case	O
'!'	O
:	O
if	O
(	O
s	*(*(char))
[	O
1	int
]	O
==	O
'='	O
)	O
return	O
ascend_cmp_ne	int
;	O
}	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Invalid operation"	*(char)
)	O
,	O
s	*(*(char))
)	O
;	O
return	O
ascend_cmp_none	int
;	O
}	O
static	O
int	O
_get_port	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
int	O
dir	*(char)
=	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"port"	*(char)
,	O
0	int
)	O
;	O
char	O
*	O
tok	int
;	O
char	O
*	O
p	*(struct)
;	O
int	O
num	int
;	O
int	O
op	enum(int,int,int,int,int,int,int)
;	O
if	O
(	O
dir	*(char)
==	O
ASCEND_DIR_NONE	O
)	O
return	O
ASCEND_DIR_NONE	O
;	O
if	O
(	O
(	O
op	enum(int,int,int,int,int,int,int)
=	O
_get_op	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
==	O
ascend_cmp_none	int
)	O
return	O
ASCEND_DIR_NONE	O
;	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
ASCEND_DIR_NONE	O
;	O
num	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
tok	int
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
==	O
0	int
)	O
num	int
=	O
htons	(short)->(short)
(	O
num	int
)	O
;	O
else	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
;	O
struct	O
protoent	struct(*(char),*(*(char)),int)
*	O
pp	*(struct(*(char),*(*(char)),int))
=	O
getprotobynumber	(int)->(*(struct(*(char),*(*(char)),int)))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
proto	int
)	O
;	O
if	O
(	O
!	O
pp	*(struct(*(char),*(*(char)),int))
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Cannot map back the protocol number"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
ASCEND_DIR_NONE	O
;	O
}	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
tok	int
,	O
pp	*(struct(*(char),*(*(char)),int))
->	O
p_name	*(char)
)	O
;	O
if	O
(	O
!	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Unknown service"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
num	int
=	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
;	O
}	O
switch	O
(	O
dir	*(char)
)	O
{	O
case	O
ASCEND_DIR_SRC	int
:	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
src_port	short
=	O
num	int
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
src_cmp	char
=	O
op	enum(int,int,int,int,int,int,int)
;	O
break	O
;	O
case	O
ASCEND_DIR_DST	int
:	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
dst_port	short
=	O
num	int
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
dst_cmp	char
=	O
op	enum(int,int,int,int,int,int,int)
;	O
break	O
;	O
}	O
return	O
dir	*(char)
;	O
}	O
static	O
int	O
_ascend_parse_port_clause	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
int	O
n	long
;	O
if	O
(	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"port"	*(char)
,	O
1	int
)	O
==	O
ASCEND_DIR_NONE	O
)	O
return	O
0	int
;	O
n	long
=	O
_get_port	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
n	long
==	O
ASCEND_DIR_NONE	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
_get_direction_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),int)->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"port"	*(char)
,	O
1	int
)	O
!=	O
ASCEND_DIR_NONE	O
)	O
{	O
int	O
n1	int
=	O
_get_port	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
n1	int
==	O
ASCEND_DIR_NONE	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n1	int
==	O
n	long
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Duplicate port specification"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
_ascend_parse_ip	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
if	O
(	O
!	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
return	O
0	int
;	O
if	O
(	O
_ascend_parse_ip_clause	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
{	O
if	O
(	O
_get_protocol	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
_moreinput	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
{	O
char	O
*	O
tok	int
;	O
int	O
have_port	int
=	O
_ascend_parse_port_clause	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
if	O
(	O
have_port	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
tok	int
=	O
_get_token	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),int)->(*(char))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
0	int
)	O
;	O
if	O
(	O
!	O
tok	int
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
tok	int
,	O
"est"	*(char)
)	O
==	O
0	int
)	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
v	union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))
.	O
ip	*(struct)
.	O
established	char
=	O
1	int
;	O
else	O
{	O
ascend_errprints	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
have_port	int
?	O
_	O
(	O
"Expected `est' but found `%s'"	*(char)
)	O
:	O
_	O
(	O
"Expected `{src|dst}port' or `est', but found `%s'"	*(char)
)	O
,	O
tok	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_ascend_parse_ipx	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
"IPX filters are not yet supported"	*(char)
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
_ascend_parse	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
*	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
,	O
0	int
,	O
sizeof	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
_get_type	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
||	O
_get_dir	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
||	O
_get_action	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
->	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
->	O
type	int
)	O
{	O
case	O
ascend_filter_generic	int
:	O
return	O
_ascend_parse_generic	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
case	O
ascend_filter_ip	int
:	O
return	O
_ascend_parse_ip	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
case	O
ascend_filter_ipx	int
:	O
return	O
_ascend_parse_ipx	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
_ascend_parse_filter	(*(char),*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))->(int)
(	O
const	O
char	O
*	O
input	char
,	O
ASCEND_FILTER	struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))
*	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
struct	O
ascend_parse_buf	struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
;	O
int	O
rc	int
;	O
*	O
errp	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
grad_argcv_get	(*(char),*(char),*(char),*(int),*(*(*(char))))->(int)
(	O
input	char
,	O
"/"	*(char)
,	O
NULL	O
,	O
&	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokc	int
,	O
&	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokv	*(*(char))
)	O
)	O
{	O
grad_argcv_free	(int,*(*(char)))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokc	int
,	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokv	*(*(char))
)	O
;	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
&	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Failed to tokenize"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokn	int
=	O
0	int
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
=	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
;	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
errmsg	*(*(char))
=	O
errp	*(*(char))
;	O
rc	int
=	O
_ascend_parse	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))))->(int)
(	O
&	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
)	O
;	O
grad_argcv_free	(int,*(*(char)))->(int)
(	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokc	int
,	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
.	O
tokv	*(*(char))
)	O
;	O
if	O
(	O
rc	int
&&	O
!	O
*	O
errp	*(*(char))
)	O
ascend_errprint	(*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union`)),*(*(char)))),*(char),*(char))->(void)
(	O
&	O
pb	*(struct(int,*(*(char)),int,*(struct(char,char,char,char,union(struct`,struct`,struct`,array(char)))),*(*(char))))
,	O
_	O
(	O
"Malformed attribute value"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grad_ascend_parse_filter	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(*(char)))->(int)
(	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
ASCEND_FILTER	struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
;	O
if	O
(	O
_ascend_parse_filter	(*(char),*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char)))),*(*(char)))->(int)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
&	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
,	O
errp	*(*(char))
)	O
)	O
return	O
1	int
;	O
grad_free	(*(void))->(void)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
)	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
=	O
sizeof	O
(	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
)	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
=	O
grad_emalloc	(long)->(*(void))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
&	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
,	O
sizeof	O
(	O
flt	*(struct(char,char,char,char,union(struct(int,int,char,char,char,char,short,short,char,char),struct(int,array(char),short,int,array(char),short,char,char),struct(short,short,short,array(char),array(char),char),array(char))))
)	O
)	O
;	O
return	O
0	int
;	O
}	O
