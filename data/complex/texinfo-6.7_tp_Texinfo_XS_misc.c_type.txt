const	O
char	O
*	O
whitespace_chars	O
=	O
" \t\f\v\r\n"	*(char)
;	O
int	O
xs_abort_empty_line	O
(	O
HV	struct
*	O
self	O
,	O
HV	struct
*	O
current	O
,	O
SV	struct
*	O
additional_spaces_in	O
)	O
{	O
char	O
*	O
additional_spaces	O
;	O
AV	struct
*	O
contents_array	O
;	O
SV	struct
*	O
*	O
svp	O
;	O
int	O
contents_num	O
;	O
HV	struct
*	O
spaces_elt	O
;	O
HV	struct
*	O
test_extra	O
=	O
0	int
;	O
HV	struct
*	O
command_extra	O
=	O
0	int
;	O
HV	struct
*	O
owning_elt	O
=	O
0	int
;	O
char	O
*	O
type	char
;	O
SV	struct
*	O
existing_text_sv	O
;	O
dTHX	O
;	O
if	O
(	O
additional_spaces_in	O
)	O
{	O
STRLEN	long
len	long
;	O
static	O
char	O
*	O
new_string	O
;	O
additional_spaces	O
=	O
SvPV	O
(	O
additional_spaces_in	O
,	O
len	long
)	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
additional_spaces_in	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
new_string	O
)	O
;	O
new_string	O
=	O
bytes_to_utf8	O
(	O
additional_spaces	O
,	O
&	O
len	long
)	O
;	O
additional_spaces	O
=	O
new_string	O
;	O
}	O
}	O
else	O
additional_spaces	O
=	O
""	*(char)
;	O
svp	O
=	O
hv_fetch	O
(	O
current	O
,	O
"contents"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"contents"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
return	O
0	int
;	O
contents_array	O
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
contents_num	O
=	O
av_len	O
(	O
contents_array	O
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	O
==	O
0	int
)	O
return	O
0	int
;	O
spaces_elt	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	O
,	O
contents_num	O
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	O
=	O
hv_fetch	O
(	O
spaces_elt	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
return	O
0	int
;	O
type	char
=	O
SvPV_nolen	O
(	O
*	O
svp	O
)	O
;	O
if	O
(	O
!	O
type	char
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_line"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_line_after_command"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_before_argument"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_after_close_brace"	*(char)
)	O
)	O
{	O
return	O
0	int
;	O
}	O
svp	O
=	O
hv_fetch	O
(	O
spaces_elt	O
,	O
"extra"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"extra"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	O
)	O
{	O
test_extra	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
svp	O
=	O
hv_fetch	O
(	O
test_extra	O
,	O
"command"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"command"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	O
)	O
{	O
owning_elt	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
svp	O
=	O
hv_fetch	O
(	O
owning_elt	O
,	O
"extra"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"extra"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	O
)	O
command_extra	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
}	O
}	O
svp	O
=	O
hv_fetch	O
(	O
spaces_elt	O
,	O
"text"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"text"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
return	O
0	int
;	O
existing_text_sv	O
=	O
*	O
svp	O
;	O
sv_utf8_upgrade	O
(	O
existing_text_sv	O
)	O
;	O
sv_catpv	O
(	O
existing_text_sv	O
,	O
additional_spaces	O
)	O
;	O
if	O
(	O
!	O
*	O
SvPV_nolen	O
(	O
existing_text_sv	O
)	O
)	O
{	O
av_pop	O
(	O
contents_array	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_line"	*(char)
)	O
)	O
{	O
char	O
*	O
current_type	O
;	O
AV	struct
*	O
context_stack	O
;	O
SV	struct
*	O
top_context_sv	O
;	O
char	O
*	O
top_context	O
;	O
int	O
top_index	O
;	O
svp	O
=	O
hv_fetch	O
(	O
current	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
current_type	O
=	O
0	int
;	O
else	O
current_type	O
=	O
SvPV_nolen	O
(	O
*	O
svp	O
)	O
;	O
if	O
(	O
current_type	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_type	O
,	O
"before_item"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_type	O
,	O
"text_root"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_type	O
,	O
"document_root"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_type	O
,	O
"brace_command_context"	*(char)
)	O
)	O
goto	O
delete_type	O
;	O
svp	O
=	O
hv_fetch	O
(	O
self	O
,	O
"context_stack"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"context_stack"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
goto	O
delete_type	O
;	O
context_stack	O
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
top_index	O
=	O
av_len	O
(	O
context_stack	O
)	O
;	O
if	O
(	O
top_index	O
<	O
0	int
)	O
goto	O
delete_type	O
;	O
svp	O
=	O
av_fetch	O
(	O
context_stack	O
,	O
top_index	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
goto	O
delete_type	O
;	O
top_context_sv	O
=	O
*	O
svp	O
;	O
top_context	O
=	O
SvPV_nolen	O
(	O
top_context_sv	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"math"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"menu"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"preformatted"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"rawpreformatted"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"def"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
top_context	O
,	O
"inlineraw"	*(char)
)	O
)	O
{	O
hv_store	O
(	O
spaces_elt	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
newSVpv	O
(	O
"empty_spaces_before_paragraph"	*(char)
,	O
0	int
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
delete_type	O
:	O
hv_delete	O
(	O
spaces_elt	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
G_DISCARD	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_line_after_command"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_before_argument"	*(char)
)	O
)	O
{	O
STRLEN	long
len	long
;	O
char	O
*	O
ptr	O
;	O
if	O
(	O
owning_elt	O
)	O
{	O
av_pop	O
(	O
contents_array	O
)	O
;	O
ptr	O
=	O
SvPV	O
(	O
existing_text_sv	O
,	O
len	long
)	O
;	O
if	O
(	O
!	O
command_extra	O
)	O
{	O
command_extra	O
=	O
newHV	O
(	O
)	O
;	O
hv_store	O
(	O
owning_elt	O
,	O
"extra"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"extra"	*(char)
)	O
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
command_extra	O
)	O
,	O
0	int
)	O
;	O
}	O
hv_store	O
(	O
command_extra	O
,	O
"spaces_before_argument"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"spaces_before_argument"	*(char)
)	O
,	O
newSVpv	O
(	O
ptr	O
,	O
len	long
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
hv_store	O
(	O
spaces_elt	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
newSVpv	O
(	O
"empty_spaces_after_command"	*(char)
,	O
0	int
)	O
,	O
0	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
HV	struct
*	O
xs_merge_text	O
(	O
HV	struct
*	O
self	O
,	O
HV	struct
*	O
current	O
,	O
SV	struct
*	O
text_in	O
)	O
{	O
AV	struct
*	O
contents_array	O
;	O
int	O
no_merge_with_following_text	O
=	O
0	int
;	O
char	O
*	O
text	O
;	O
int	O
leading_spaces	O
;	O
SV	struct
*	O
leading_spaces_sv	O
=	O
0	int
;	O
int	O
call_ret	O
;	O
SV	struct
*	O
returned_sv	O
;	O
SV	struct
*	O
contents_ref	O
;	O
int	O
contents_num	O
;	O
HV	struct
*	O
last_elt	O
;	O
SV	struct
*	O
existing_text_sv	O
;	O
char	O
*	O
existing_text	O
;	O
SV	struct
*	O
*	O
svp	O
;	O
dTHX	O
;	O
dSP	O
;	O
{	O
STRLEN	long
len	long
;	O
static	O
char	O
*	O
new_string	O
;	O
text	O
=	O
SvPV	O
(	O
text_in	O
,	O
len	long
)	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
text_in	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
new_string	O
)	O
;	O
new_string	O
=	O
bytes_to_utf8	O
(	O
text	O
,	O
&	O
len	long
)	O
;	O
text	O
=	O
new_string	O
;	O
}	O
}	O
leading_spaces	O
=	O
strspn	(*(char),*(char))->(long)
(	O
text	O
,	O
whitespace_chars	O
)	O
;	O
if	O
(	O
text	O
[	O
leading_spaces	O
]	O
)	O
{	O
int	O
contents_num	O
;	O
if	O
(	O
leading_spaces	O
>	O
0	int
)	O
{	O
leading_spaces_sv	O
=	O
newSVpv	O
(	O
text	O
,	O
leading_spaces	O
)	O
;	O
}	O
svp	O
=	O
hv_fetch	O
(	O
current	O
,	O
"contents"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"contents"	*(char)
)	O
,	O
0	int
)	O
;	O
contents_array	O
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	O
)	O
;	O
contents_num	O
=	O
av_len	O
(	O
contents_array	O
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	O
>	O
0	int
)	O
{	O
HV	struct
*	O
last_elt	O
;	O
char	O
*	O
type	char
=	O
0	int
;	O
last_elt	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	O
,	O
contents_num	O
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	O
=	O
hv_fetch	O
(	O
last_elt	O
,	O
"type"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"type"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	O
)	O
type	char
=	O
SvPV_nolen	O
(	O
*	O
svp	O
)	O
;	O
if	O
(	O
type	char
&&	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_line_after_command"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_after_command"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_before_argument"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	char
,	O
"empty_spaces_after_close_brace"	*(char)
)	O
)	O
)	O
{	O
no_merge_with_following_text	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
xs_abort_empty_line	O
(	O
self	O
,	O
current	O
,	O
leading_spaces_sv	O
)	O
)	O
{	O
text	O
+=	O
leading_spaces	O
;	O
}	O
ENTER	O
;	O
SAVETMPS	O
;	O
PUSHMARK	O
(	O
SP	O
)	O
;	O
XPUSHs	O
(	O
sv_2mortal	O
(	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
self	O
)	O
)	O
)	O
;	O
XPUSHs	O
(	O
sv_2mortal	O
(	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
current	O
)	O
)	O
)	O
;	O
PUTBACK	O
;	O
call_ret	O
=	O
call_pv	O
(	O
"Texinfo::Parser::_begin_paragraph"	*(char)
,	O
G_SCALAR	O
)	O
;	O
SPAGAIN	O
;	O
returned_sv	O
=	O
POPs	O
;	O
if	O
(	O
returned_sv	O
&&	O
SvRV	O
(	O
returned_sv	O
)	O
)	O
{	O
current	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
returned_sv	O
)	O
;	O
}	O
FREETMPS	O
;	O
LEAVE	O
;	O
}	O
svp	O
=	O
hv_fetch	O
(	O
current	O
,	O
"contents"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"contents"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
{	O
contents_array	O
=	O
newAV	O
(	O
)	O
;	O
contents_ref	O
=	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
contents_array	O
)	O
;	O
hv_store	O
(	O
current	O
,	O
"contents"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"contents"	*(char)
)	O
,	O
contents_ref	O
,	O
0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NEW CONTENTS %p\n"	*(char)
,	O
contents_array	O
)	O
;	O
goto	O
NEW_TEXT	O
;	O
}	O
else	O
{	O
contents_ref	O
=	O
*	O
svp	O
;	O
contents_array	O
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
contents_ref	O
)	O
;	O
}	O
if	O
(	O
no_merge_with_following_text	O
)	O
goto	O
NEW_TEXT	O
;	O
contents_num	O
=	O
av_len	O
(	O
contents_array	O
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	O
==	O
0	int
)	O
goto	O
NEW_TEXT	O
;	O
last_elt	O
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	O
,	O
contents_num	O
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	O
=	O
hv_fetch	O
(	O
last_elt	O
,	O
"text"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"text"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	O
)	O
goto	O
NEW_TEXT	O
;	O
existing_text_sv	O
=	O
*	O
svp	O
;	O
existing_text	O
=	O
SvPV_nolen	O
(	O
existing_text_sv	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
existing_text	O
,	O
'\n'	O
)	O
)	O
goto	O
NEW_TEXT	O
;	O
MERGED_TEXT	O
:	O
sv_catpv	O
(	O
existing_text_sv	O
,	O
text	O
)	O
;	O
if	O
(	O
0	int
)	O
{	O
HV	struct
*	O
hv	struct(*(struct),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
;	O
SV	struct
*	O
sv	struct(*(void),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
;	O
NEW_TEXT	O
:	O
hv	struct(*(struct),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
=	O
newHV	O
(	O
)	O
;	O
sv	struct(*(void),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
=	O
newSVpv	O
(	O
text	O
,	O
0	int
)	O
;	O
hv_store	O
(	O
hv	struct(*(struct),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
,	O
"text"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"text"	*(char)
)	O
,	O
sv	struct(*(void),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
,	O
0	int
)	O
;	O
SvUTF8_on	O
(	O
sv	struct(*(void),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
)	O
;	O
hv_store	O
(	O
hv	struct(*(struct),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
,	O
"parent"	*(char)
,	O
strlen	(*(char))->(long)
(	O
"parent"	*(char)
)	O
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
current	O
)	O
,	O
0	int
)	O
;	O
av_push	O
(	O
contents_array	O
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
hv	struct(*(struct),int,int,union(*(char),long,long,double,*(struct(*(void),int,int,union(*(char),long,long,double,*(struct`),*(*`),*(*`),*(struct`),*(*`)))),*(*(struct(*(void),int,int,union(*`,long,long,double,*`,*`,*`,*`,*`)))),*(*(struct)),*(struct),*(*(struct))))
)	O
)	O
;	O
}	O
return	O
current	O
;	O
}	O
char	O
*	O
xs_process_text	O
(	O
char	O
*	O
text	O
)	O
{	O
static	O
char	O
*	O
new	O
;	O
char	O
*	O
p	O
,	O
*	O
q	O
;	O
dTHX	O
;	O
new	O
=	O
realloc	(*(void),long)->(*(void))
(	O
new	O
,	O
strlen	(*(char))->(long)
(	O
text	O
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
new	O
,	O
text	O
)	O
;	O
p	O
=	O
q	O
=	O
new	O
;	O
while	O
(	O
*	O
p	O
)	O
{	O
if	O
(	O
*	O
p	O
==	O
'-'	O
&&	O
p	O
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
p	O
[	O
2	int
]	O
==	O
'-'	O
)	O
{	O
*	O
q	O
=	O
'-'	O
;	O
q	O
[	O
1	int
]	O
=	O
'-'	O
;	O
p	O
+=	O
3	int
;	O
q	O
+=	O
2	int
;	O
}	O
else	O
{	O
*	O
q	O
=	O
'-'	O
;	O
p	O
+=	O
2	int
;	O
q	O
+=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	O
==	O
'\''	O
&&	O
p	O
[	O
1	int
]	O
==	O
'\''	O
)	O
{	O
*	O
q	O
=	O
'"'	O
;	O
p	O
+=	O
2	int
;	O
q	O
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
*	O
p	O
==	O
'`'	O
)	O
{	O
if	O
(	O
p	O
[	O
1	int
]	O
==	O
'`'	O
)	O
{	O
*	O
q	O
=	O
'"'	O
;	O
p	O
+=	O
2	int
;	O
q	O
+=	O
1	int
;	O
}	O
else	O
{	O
*	O
q	O
=	O
'\''	O
;	O
p	O
+=	O
1	int
;	O
q	O
+=	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
q	O
++	O
=	O
*	O
p	O
++	O
;	O
}	O
}	O
*	O
q	O
=	O
'\0'	O
;	O
return	O
new	O
;	O
}	O
char	O
*	O
xs_unicode_text	O
(	O
char	O
*	O
text	O
,	O
int	O
in_code	O
)	O
{	O
char	O
*	O
p	O
,	O
*	O
q	O
;	O
static	O
char	O
*	O
new	O
;	O
int	O
new_space	O
,	O
new_len	O
;	O
dTHX	O
;	O
if	O
(	O
in_code	O
)	O
return	O
text	O
;	O
p	O
=	O
text	O
;	O
new_space	O
=	O
strlen	(*(char))->(long)
(	O
text	O
)	O
;	O
new	O
=	O
realloc	(*(void),long)->(*(void))
(	O
new	O
,	O
new_space	O
+	O
1	int
)	O
;	O
new_len	O
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
q	O
=	O
p	O
+	O
strcspn	(*(char),*(char))->(long)
(	O
p	O
,	O
"-`'"	*(char)
)	O
;	O
ADDN	O
(	O
p	O
,	O
q	O
-	O
p	O
)	O
;	O
if	O
(	O
!	O
*	O
q	O
)	O
break	O
;	O
switch	O
(	O
*	O
q	O
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
q	O
,	O
"---"	*(char)
,	O
3	int
)	O
)	O
{	O
p	O
=	O
q	O
+	O
3	int
;	O
ADD3	O
(	O
"\xE2\x80\x94"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
q	O
,	O
"--"	*(char)
,	O
2	int
)	O
)	O
{	O
p	O
=	O
q	O
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x93"	*(char)
)	O
;	O
}	O
else	O
{	O
p	O
=	O
q	O
+	O
1	int
;	O
ADD1	O
(	O
*	O
q	O
)	O
;	O
}	O
break	O
;	O
case	O
'`'	O
:	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
q	O
,	O
"``"	*(char)
,	O
2	int
)	O
)	O
{	O
p	O
=	O
q	O
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x9C"	*(char)
)	O
;	O
}	O
else	O
{	O
p	O
=	O
q	O
+	O
1	int
;	O
ADD3	O
(	O
"\xE2\x80\x98"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
q	O
,	O
"''"	*(char)
,	O
2	int
)	O
)	O
{	O
p	O
=	O
q	O
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x9D"	*(char)
)	O
;	O
}	O
else	O
{	O
p	O
=	O
q	O
+	O
1	int
;	O
ADD3	O
(	O
"\xE2\x80\x99"	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
new	O
[	O
new_len	O
]	O
=	O
'\0'	O
;	O
return	O
new	O
;	O
}	O
void	O
xs_parse_texi_regex	O
(	O
SV	struct
*	O
text_in	O
,	O
char	O
*	O
*	O
at_command	O
,	O
char	O
*	O
*	O
open_brace	O
,	O
char	O
*	O
*	O
asterisk	O
,	O
char	O
*	O
*	O
single_letter_command	O
,	O
char	O
*	O
*	O
separator_match	O
,	O
char	O
*	O
*	O
new_text	O
)	O
{	O
char	O
*	O
text	O
;	O
dTHX	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
text_in	O
)	O
)	O
sv_utf8_upgrade	O
(	O
text_in	O
)	O
;	O
text	O
=	O
SvPV_nolen	O
(	O
text_in	O
)	O
;	O
*	O
at_command	O
=	O
*	O
open_brace	O
=	O
*	O
asterisk	O
=	O
*	O
single_letter_command	O
=	O
*	O
separator_match	O
=	O
*	O
new_text	O
=	O
0	int
;	O
if	O
(	O
*	O
text	O
==	O
'@'	O
&&	O
isalnum	(int)->(int)
(	O
text	O
[	O
1	int
]	O
)	O
)	O
{	O
char	O
*	O
p	O
,	O
*	O
q	O
;	O
static	O
char	O
*	O
s	O
;	O
p	O
=	O
text	O
+	O
1	int
;	O
q	O
=	O
text	O
+	O
2	int
;	O
while	O
(	O
isalnum	(int)->(int)
(	O
*	O
q	O
)	O
||	O
*	O
q	O
==	O
'-'	O
||	O
*	O
q	O
==	O
'_'	O
)	O
q	O
++	O
;	O
s	O
=	O
realloc	(*(void),long)->(*(void))
(	O
s	O
,	O
q	O
-	O
p	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	O
,	O
p	O
,	O
q	O
-	O
p	O
)	O
;	O
s	O
[	O
q	O
-	O
p	O
]	O
=	O
'\0'	O
;	O
*	O
at_command	O
=	O
s	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
text	O
==	O
'{'	O
)	O
{	O
*	O
open_brace	O
=	O
"{"	*(char)
;	O
*	O
separator_match	O
=	O
"{"	*(char)
;	O
}	O
else	O
if	O
(	O
*	O
text	O
==	O
'@'	O
&&	O
text	O
[	O
1	int
]	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"([\"'~@&}{,.!?"	*(char)
" \t\n"	*(char)
"*-^`=:|/\\"	*(char)
,	O
text	O
[	O
1	int
]	O
)	O
)	O
{	O
static	O
char	O
a	O
[	O
2	int
]	O
;	O
*	O
single_letter_command	O
=	O
a	O
;	O
a	O
[	O
0	int
]	O
=	O
text	O
[	O
1	int
]	O
;	O
a	O
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"{}@,:\t.\f"	*(char)
,	O
*	O
text	O
)	O
)	O
{	O
static	O
char	O
a	O
[	O
2	int
]	O
;	O
*	O
separator_match	O
=	O
a	O
;	O
a	O
[	O
0	int
]	O
=	O
*	O
text	O
;	O
a	O
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
char	O
*	O
p	O
;	O
if	O
(	O
*	O
text	O
==	O
'*'	O
)	O
*	O
asterisk	O
=	O
"*"	*(char)
;	O
p	O
=	O
text	O
;	O
p	O
+=	O
strcspn	(*(char),*(char))->(long)
(	O
p	O
,	O
"{}@,:\t.\n\f"	*(char)
)	O
;	O
if	O
(	O
p	O
>	O
text	O
)	O
{	O
static	O
char	O
*	O
s	O
;	O
s	O
=	O
realloc	(*(void),long)->(*(void))
(	O
s	O
,	O
p	O
-	O
text	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	O
,	O
text	O
,	O
p	O
-	O
text	O
)	O
;	O
s	O
[	O
p	O
-	O
text	O
]	O
=	O
'\0'	O
;	O
*	O
new_text	O
=	O
s	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
