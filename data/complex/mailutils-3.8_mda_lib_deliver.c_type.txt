static	O
char	O
*	O
default_domain	*(char)
;	O
int	O
multiple_delivery	int
;	O
static	O
char	O
*	O
sender_address	*(char)
=	O
NULL	O
;	O
static	O
void	O
set_sender_address	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
sender_address	*(char)
!=	O
NULL	O
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"multiple --from options"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
errmsg	*(*(char))
;	O
int	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
arg	*(char)
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
->	O
opt_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
->	O
opt_ptr	*(void)
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"can't set sender address: %s"	*(char)
)	O
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
}	O
}	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mda_deliver_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"domain"	*(char)
,	O
mu_c_string	int
,	O
&	O
default_domain	*(char)
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Default email domain"	*(char)
)	O
}	O
,	O
{	O
"exit-multiple-delivery-success"	*(char)
,	O
mu_c_bool	int
,	O
&	O
multiple_delivery	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"In case of multiple delivery, exit with code 0 if at least one "	*(char)
"delivery succeeded."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
mda_deliver_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	O
(	O
N_	O
(	O
"Delivery options"	*(char)
)	O
)	O
,	O
{	O
"from"	*(char)
,	O
'f'	O
,	O
N_	O
(	O
"EMAIL"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"specify the sender's name"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
sender_address	*(char)
,	O
set_sender_address	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
NULL	O
,	O
'r'	O
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
mu_message_t	*(struct)
make_tmp	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
in	*(struct)
,	O
out	*(struct)
;	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	*(long)
;	O
mu_message_t	*(struct)
mesg	*(struct)
;	O
rc	int
=	O
mu_stdio_stream_create	(*(*(struct)),int,int)->(int)
(	O
&	O
in	*(struct)
,	O
MU_STDIN_FD	int
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stdio_stream_create"	*(char)
,	O
"MU_STDIN_FD"	*(char)
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_temp_file_stream_create	(*(*(struct)),*(struct(*(char),*(char))),int)->(int)
(	O
&	O
out	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"unable to open temporary file: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
in	*(struct)
,	O
&	O
buf	*(char)
,	O
&	O
size	long
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"read error: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
in	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
n	*(long)
==	O
0	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"unexpected EOF on input"	*(char)
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
in	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
n	*(long)
>=	O
5	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
buf	*(char)
,	O
"From "	*(char)
,	O
5	int
)	O
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
NULL	O
;	O
if	O
(	O
!	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
mu_get_auth_by_uid	(int)->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
;	O
}	O
if	O
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
time	struct(long,long)
(	O
&	O
t	long
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"From %s "	*(char)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
mu_c_streamftime	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
out	*(struct)
,	O
"%c%n"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot determine sender address"	*(char)
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
in	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
}	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
out	*(struct)
,	O
buf	*(char)
,	O
n	*(long)
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
out	*(struct)
,	O
in	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
in	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"copy error: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_to_message	(*(struct),*(*(struct)))->(int)
(	O
out	*(struct)
,	O
&	O
mesg	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
out	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"error creating temporary message: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
return	O
mesg	*(struct)
;	O
}	O
int	O
mda_run_delivery	(*((*(struct),*(char),*(*(char)))->(int)),int,*(*(char)))->(int)
(	O
mda_delivery_fn	*((*(struct),*(char),*(*(char)))->(int))
delivery_fun	*((*(struct),*(char),*(*(char)))->(int))
,	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
mu_message_t	*(struct)
mesg	*(struct)
=	O
make_tmp	(*(char))->(*(struct))
(	O
sender_address	*(char)
)	O
;	O
if	O
(	O
multiple_delivery	int
)	O
multiple_delivery	int
=	O
argc	long
>	O
1	int
;	O
for	O
(	O
;	O
*	O
argv	*(*(char))
;	O
argv	*(*(char))
++	O
)	O
{	O
delivery_fun	*((*(struct),*(char),*(*(char)))->(int))
(	O
mesg	*(struct)
,	O
*	O
argv	*(*(char))
,	O
NULL	O
)	O
;	O
if	O
(	O
multiple_delivery	int
)	O
exit_code	int
=	O
EX_OK	int
;	O
}	O
return	O
exit_code	int
;	O
}	O
static	O
int	O
deliver_to_mailbox	(*(struct),*(struct),*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(*(char)))->(int)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
int	O
status	int
;	O
char	O
*	O
path	*(char)
;	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
mu_locker_t	*(struct)
lock	*(struct)
;	O
int	O
failed	int
=	O
0	int
;	O
int	O
exit_code	int
=	O
EX_OK	int
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
path	*(char)
=	O
(	O
char	O
*	O
)	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
;	O
status	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot open mailbox %s: %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
mu_mailbox_get_locker	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
lock	*(struct)
)	O
;	O
if	O
(	O
lock	*(struct)
)	O
{	O
status	int
=	O
mu_locker_lock	(*(struct))->(int)
(	O
lock	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot lock mailbox `%s': %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
}	O
if	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
mu_off_t	long
n	*(long)
;	O
size_t	long
msg_size	long
;	O
mu_off_t	long
mbsize	long
;	O
if	O
(	O
(	O
status	int
=	O
mu_mailbox_get_size	(*(struct),*(long))->(int)
(	O
mbox	*(struct)
,	O
&	O
mbsize	long
)	O
)	O
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot get size of mailbox %s: %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
status	int
==	O
ENOSYS	int
)	O
mbsize	long
=	O
0	int
;	O
else	O
return	O
EX_TEMPFAIL	int
;	O
}	O
switch	O
(	O
mda_check_quota	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),long,*(long))->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
mbsize	long
,	O
&	O
n	*(long)
)	O
)	O
{	O
case	O
MQUOTA_EXCEEDED	int
:	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"%s: mailbox quota exceeded for this recipient"	*(char)
)	O
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
errp	*(*(char))
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
errp	*(*(char))
,	O
"%s: mailbox quota exceeded for this recipient"	*(char)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
)	O
;	O
exit_code	int
=	O
EX_QUOTA	O
;	O
failed	int
++	O
;	O
break	O
;	O
case	O
MQUOTA_UNLIMITED	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
status	int
=	O
mu_message_size	(*(struct),*(long))->(int)
(	O
msg	*(struct)
,	O
&	O
msg_size	long
)	O
)	O
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot get message size (input message %s): %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
failed	int
++	O
;	O
}	O
else	O
if	O
(	O
msg_size	long
>	O
n	*(long)
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"%s: message would exceed maximum mailbox size for "	*(char)
"this recipient"	*(char)
)	O
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
errp	*(*(char))
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
errp	*(*(char))
,	O
"%s: message would exceed maximum mailbox size "	*(char)
"for this recipient"	*(char)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
)	O
;	O
exit_code	int
=	O
EX_QUOTA	O
;	O
failed	int
++	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
failed	int
)	O
{	O
status	int
=	O
mu_mailbox_append_message	(*(struct),*(struct))->(int)
(	O
mbox	*(struct)
,	O
msg	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"error writing to mailbox %s: %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
failed	int
++	O
;	O
}	O
else	O
{	O
status	int
=	O
mu_mailbox_sync	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"error flushing mailbox %s: %s"	*(char)
)	O
,	O
path	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
failed	int
++	O
;	O
}	O
}	O
}	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
mu_locker_unlock	(*(struct))->(int)
(	O
lock	*(struct)
)	O
;	O
return	O
failed	int
?	O
exit_code	int
:	O
0	int
;	O
}	O
static	O
int	O
is_remote_url	(*(struct))->(int)
(	O
mu_url_t	*(struct)
url	*(struct)
)	O
{	O
int	O
rc	int
,	O
res	*(int)
;	O
if	O
(	O
!	O
url	*(struct)
)	O
return	O
0	int
;	O
rc	int
=	O
mu_registrar_test_local_url	(*(struct),*(int))->(int)
(	O
url	*(struct)
,	O
&	O
res	*(int)
)	O
;	O
return	O
rc	int
==	O
0	int
&&	O
res	*(int)
==	O
0	int
;	O
}	O
static	O
int	O
do_delivery	(*(struct),*(struct),*(char),*(*(char)))->(int)
(	O
mu_url_t	*(struct)
url	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
NULL	O
;	O
mu_mailbox_t	*(struct)
mbox	*(struct)
;	O
int	O
status	int
;	O
mu_set_user_email_domain	(*(char))->(int)
(	O
default_domain	*(char)
)	O
;	O
if	O
(	O
name	*(char)
&&	O
!	O
is_remote_url	(*(struct))->(int)
(	O
url	*(struct)
)	O
)	O
{	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
mu_get_auth_by_name	(*(char))->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"%s: no such user"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
errp	*(*(char))
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
errp	*(*(char))
,	O
"%s: no such user"	*(char)
,	O
name	*(char)
)	O
;	O
exit_code	int
=	O
EX_NOUSER	int
;	O
return	O
EX_NOUSER	int
;	O
}	O
status	int
=	O
mu_set_user_email	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s: invalid email: %s"	*(char)
)	O
,	O
name	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
getuid	()->(int)
(	O
)	O
)	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
change_uid	int
=	O
0	int
;	O
switch	O
(	O
mda_filter_message	(*(struct),*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(int)
(	O
msg	*(struct)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
)	O
{	O
case	O
MDA_FILTER_OK	int
:	O
break	O
;	O
case	O
MDA_FILTER_FILTERED	int
:	O
exit_code	int
=	O
EX_OK	int
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
0	int
;	O
case	O
MDA_FILTER_FAILURE	int
:	O
return	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
}	O
switch	O
(	O
mda_forward	(*(struct),*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(enum(int,int,int,int))
(	O
msg	*(struct)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
)	O
{	O
case	O
mda_forward_none	int
:	O
case	O
mda_forward_metoo	int
:	O
break	O
;	O
case	O
mda_forward_ok	int
:	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
0	int
;	O
case	O
mda_forward_error	int
:	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
}	O
}	O
else	O
mu_set_user_email	(*(char))->(int)
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
url	*(struct)
)	O
{	O
status	int
=	O
mu_url_create	(*(*(struct)),*(char))->(int)
(	O
&	O
url	*(struct)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
mailbox	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot create URL for %s: %s"	*(char)
)	O
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
mailbox	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
}	O
}	O
status	int
=	O
mu_mailbox_create_from_url	(*(*(struct)),*(struct))->(int)
(	O
&	O
mbox	*(struct)
,	O
url	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"cannot open mailbox %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
mu_url_destroy	(*(*(struct)))->(void)
(	O
&	O
url	*(struct)
)	O
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
status	int
=	O
mu_mailbox_set_notify	(*(struct),*(char))->(int)
(	O
mbox	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to set notification on %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
if	O
(	O
mda_switch_user_id	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),int)->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
1	int
)	O
)	O
return	O
EX_TEMPFAIL	int
;	O
status	int
=	O
deliver_to_mailbox	(*(struct),*(struct),*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),*(*(char)))->(int)
(	O
mbox	*(struct)
,	O
msg	*(struct)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
errp	*(*(char))
)	O
;	O
if	O
(	O
mda_switch_user_id	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)),int)->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
0	int
)	O
)	O
return	O
EX_TEMPFAIL	int
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
return	O
status	int
;	O
}	O
int	O
mda_deliver_to_url	(*(struct),*(char),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
*	O
dest_id	*(char)
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
int	O
status	int
;	O
const	O
char	O
*	O
name	*(char)
;	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
status	int
=	O
mu_url_create	(*(*(struct)),*(char))->(int)
(	O
&	O
url	*(struct)
,	O
dest_id	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"%s: cannot create url: %s"	*(char)
)	O
,	O
dest_id	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
return	O
EX_NOUSER	int
;	O
}	O
status	int
=	O
mu_url_sget_user	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
status	int
==	O
MU_ERR_NOENT	O
)	O
name	*(char)
=	O
NULL	O
;	O
else	O
if	O
(	O
status	int
)	O
{	O
mda_error	(*(char))->(void)
(	O
_	O
(	O
"%s: cannot get user name from url: %s"	*(char)
)	O
,	O
dest_id	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
mu_url_destroy	(*(*(struct)))->(void)
(	O
&	O
url	*(struct)
)	O
;	O
return	O
EX_NOUSER	int
;	O
}	O
return	O
do_delivery	(*(struct),*(struct),*(char),*(*(char)))->(int)
(	O
url	*(struct)
,	O
msg	*(struct)
,	O
name	*(char)
,	O
errp	*(*(char))
)	O
;	O
}	O
int	O
mda_deliver_to_user	(*(struct),*(char),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
*	O
dest_id	*(char)
,	O
char	O
*	O
*	O
errp	*(*(char))
)	O
{	O
return	O
do_delivery	(*(struct),*(struct),*(char),*(*(char)))->(int)
(	O
NULL	O
,	O
msg	*(struct)
,	O
dest_id	*(char)
,	O
errp	*(*(char))
)	O
;	O
}	O
