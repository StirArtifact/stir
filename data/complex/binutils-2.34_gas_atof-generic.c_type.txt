int	O
atof_generic	O
(	O
char	O
*	O
*	O
address_of_string_pointer	O
,	O
const	O
char	O
*	O
string_of_decimal_marks	O
,	O
const	O
char	O
*	O
string_of_decimal_exponent_marks	O
,	O
FLONUM_TYPE	O
*	O
address_of_generic_floating_point_number	O
)	O
{	O
int	O
return_value	O
;	O
char	O
*	O
first_digit	O
;	O
unsigned	O
int	O
number_of_digits_before_decimal	O
;	O
unsigned	O
int	O
number_of_digits_after_decimal	O
;	O
long	O
decimal_exponent	O
;	O
unsigned	O
int	O
number_of_digits_available	O
;	O
char	O
digits_sign_char	O
;	O
char	O
*	O
p	*(void)
;	O
char	O
c	O
;	O
int	O
seen_significant_digit	O
;	O
gas_assert	O
(	O
string_of_decimal_marks	O
[	O
0	int
]	O
==	O
'.'	O
&&	O
string_of_decimal_marks	O
[	O
1	int
]	O
==	O
0	int
)	O
;	O
first_digit	O
=	O
*	O
address_of_string_pointer	O
;	O
c	O
=	O
*	O
first_digit	O
;	O
if	O
(	O
c	O
==	O
'-'	O
||	O
c	O
==	O
'+'	O
)	O
{	O
digits_sign_char	O
=	O
c	O
;	O
first_digit	O
++	O
;	O
}	O
else	O
digits_sign_char	O
=	O
'+'	O
;	O
switch	O
(	O
first_digit	O
[	O
0	int
]	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
"nan"	*(char)
,	O
first_digit	O
,	O
3	int
)	O
)	O
{	O
address_of_generic_floating_point_number	O
->	O
sign	O
=	O
0	int
;	O
address_of_generic_floating_point_number	O
->	O
exponent	O
=	O
0	int
;	O
address_of_generic_floating_point_number	O
->	O
leader	O
=	O
address_of_generic_floating_point_number	O
->	O
low	O
;	O
*	O
address_of_string_pointer	O
=	O
first_digit	O
+	O
3	int
;	O
return	O
0	int
;	O
}	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'I'	O
:	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
"inf"	*(char)
,	O
first_digit	O
,	O
3	int
)	O
)	O
{	O
address_of_generic_floating_point_number	O
->	O
sign	O
=	O
digits_sign_char	O
==	O
'+'	O
?	O
'P'	O
:	O
'N'	O
;	O
address_of_generic_floating_point_number	O
->	O
exponent	O
=	O
0	int
;	O
address_of_generic_floating_point_number	O
->	O
leader	O
=	O
address_of_generic_floating_point_number	O
->	O
low	O
;	O
first_digit	O
+=	O
3	int
;	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
"inity"	*(char)
,	O
first_digit	O
,	O
5	int
)	O
)	O
first_digit	O
+=	O
5	int
;	O
*	O
address_of_string_pointer	O
=	O
first_digit	O
;	O
return	O
0	int
;	O
}	O
break	O
;	O
}	O
number_of_digits_before_decimal	O
=	O
0	int
;	O
number_of_digits_after_decimal	O
=	O
0	int
;	O
decimal_exponent	O
=	O
0	int
;	O
seen_significant_digit	O
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
first_digit	O
;	O
(	O
(	O
(	O
c	O
=	O
*	O
p	*(void)
)	O
!=	O
'\0'	O
)	O
&&	O
(	O
!	O
c	O
||	O
!	O
IS_DECIMAL_MARK	O
(	O
c	O
)	O
)	O
&&	O
(	O
!	O
c	O
||	O
!	O
strchr	(*(char),int)->(*(char))
(	O
string_of_decimal_exponent_marks	O
,	O
c	O
)	O
)	O
)	O
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	O
)	O
)	O
{	O
if	O
(	O
seen_significant_digit	O
||	O
c	O
>	O
'0'	O
)	O
{	O
++	O
number_of_digits_before_decimal	O
;	O
seen_significant_digit	O
=	O
1	int
;	O
}	O
else	O
{	O
first_digit	O
++	O
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
seen_significant_digit	O
=	O
0	int
;	O
signed	O
long	O
subtract_decimal_exponent	O
=	O
0	int
;	O
if	O
(	O
c	O
&&	O
IS_DECIMAL_MARK	O
(	O
c	O
)	O
)	O
{	O
unsigned	O
int	O
zeros	O
=	O
0	int
;	O
if	O
(	O
number_of_digits_before_decimal	O
==	O
0	int
)	O
first_digit	O
++	O
;	O
for	O
(	O
p	*(void)
++	O
;	O
(	O
c	O
=	O
*	O
p	*(void)
)	O
&&	O
ISDIGIT	O
(	O
c	O
)	O
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
c	O
==	O
'0'	O
)	O
{	O
if	O
(	O
number_of_digits_before_decimal	O
==	O
0	int
&&	O
!	O
seen_significant_digit	O
)	O
{	O
first_digit	O
++	O
;	O
subtract_decimal_exponent	O
--	O
;	O
}	O
else	O
zeros	O
++	O
;	O
}	O
else	O
{	O
seen_significant_digit	O
=	O
1	int
;	O
number_of_digits_after_decimal	O
+=	O
1	int
+	O
zeros	O
;	O
zeros	O
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
while	O
(	O
c	O
==	O
'_'	O
)	O
c	O
=	O
*	O
++	O
p	*(void)
;	O
}	O
if	O
(	O
c	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
string_of_decimal_exponent_marks	O
,	O
c	O
)	O
)	O
{	O
char	O
digits_exponent_sign_char	O
;	O
c	O
=	O
*	O
++	O
p	*(void)
;	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
while	O
(	O
c	O
==	O
'_'	O
)	O
c	O
=	O
*	O
++	O
p	*(void)
;	O
}	O
if	O
(	O
c	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"+-"	*(char)
,	O
c	O
)	O
)	O
{	O
digits_exponent_sign_char	O
=	O
c	O
;	O
c	O
=	O
*	O
++	O
p	*(void)
;	O
}	O
else	O
{	O
digits_exponent_sign_char	O
=	O
'+'	O
;	O
}	O
for	O
(	O
;	O
(	O
c	O
)	O
;	O
c	O
=	O
*	O
++	O
p	*(void)
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	O
)	O
)	O
{	O
decimal_exponent	O
=	O
decimal_exponent	O
*	O
10	int
+	O
c	O
-	O
'0'	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
digits_exponent_sign_char	O
==	O
'-'	O
)	O
{	O
decimal_exponent	O
=	O
-	O
decimal_exponent	O
;	O
}	O
}	O
decimal_exponent	O
+=	O
subtract_decimal_exponent	O
;	O
*	O
address_of_string_pointer	O
=	O
p	*(void)
;	O
number_of_digits_available	O
=	O
number_of_digits_before_decimal	O
+	O
number_of_digits_after_decimal	O
;	O
return_value	O
=	O
0	int
;	O
if	O
(	O
number_of_digits_available	O
==	O
0	int
)	O
{	O
address_of_generic_floating_point_number	O
->	O
exponent	O
=	O
0	int
;	O
address_of_generic_floating_point_number	O
->	O
leader	O
=	O
-	O
1	int
+	O
address_of_generic_floating_point_number	O
->	O
low	O
;	O
address_of_generic_floating_point_number	O
->	O
sign	O
=	O
digits_sign_char	O
;	O
}	O
else	O
{	O
int	O
count	int
;	O
LITTLENUM_TYPE	O
*	O
temporary_binary_low	O
=	O
NULL	O
;	O
LITTLENUM_TYPE	O
*	O
power_binary_low	O
=	O
NULL	O
;	O
LITTLENUM_TYPE	O
*	O
digits_binary_low	O
;	O
unsigned	O
int	O
precision	O
;	O
unsigned	O
int	O
maximum_useful_digits	O
;	O
unsigned	O
int	O
number_of_digits_to_use	O
;	O
unsigned	O
int	O
more_than_enough_bits_for_digits	O
;	O
unsigned	O
int	O
more_than_enough_littlenums_for_digits	O
;	O
unsigned	O
int	O
size_of_digits_in_littlenums	O
;	O
unsigned	O
int	O
size_of_digits_in_chars	O
;	O
FLONUM_TYPE	O
power_of_10_flonum	O
;	O
FLONUM_TYPE	O
digits_flonum	O
;	O
precision	O
=	O
(	O
address_of_generic_floating_point_number	O
->	O
high	O
-	O
address_of_generic_floating_point_number	O
->	O
low	O
+	O
1	int
)	O
;	O
maximum_useful_digits	O
=	O
(	O
precision	O
*	O
LITTLENUM_NUMBER_OF_BITS	O
*	O
1000000	int
/	O
3321928	int
+	O
1	int
)	O
;	O
if	O
(	O
number_of_digits_available	O
>	O
maximum_useful_digits	O
)	O
{	O
number_of_digits_to_use	O
=	O
maximum_useful_digits	O
;	O
}	O
else	O
{	O
number_of_digits_to_use	O
=	O
number_of_digits_available	O
;	O
}	O
decimal_exponent	O
+=	O
(	O
(	O
long	O
)	O
number_of_digits_before_decimal	O
-	O
(	O
long	O
)	O
number_of_digits_to_use	O
)	O
;	O
more_than_enough_bits_for_digits	O
=	O
(	O
number_of_digits_to_use	O
*	O
3321928	int
/	O
1000000	int
+	O
1	int
)	O
;	O
more_than_enough_littlenums_for_digits	O
=	O
(	O
more_than_enough_bits_for_digits	O
/	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
+	O
2	int
;	O
size_of_digits_in_littlenums	O
=	O
more_than_enough_littlenums_for_digits	O
;	O
size_of_digits_in_chars	O
=	O
size_of_digits_in_littlenums	O
*	O
sizeof	O
(	O
LITTLENUM_TYPE	O
)	O
;	O
digits_binary_low	O
=	O
(	O
LITTLENUM_TYPE	O
*	O
)	O
xmalloc	O
(	O
size_of_digits_in_chars	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
digits_binary_low	O
,	O
'\0'	O
,	O
size_of_digits_in_chars	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
first_digit	O
,	O
count	int
=	O
number_of_digits_to_use	O
;	O
count	int
;	O
p	*(void)
++	O
,	O
--	O
count	int
)	O
{	O
c	O
=	O
*	O
p	*(void)
;	O
if	O
(	O
ISDIGIT	O
(	O
c	O
)	O
)	O
{	O
long	O
carry	O
;	O
LITTLENUM_TYPE	O
*	O
littlenum_pointer	O
;	O
LITTLENUM_TYPE	O
*	O
littlenum_limit	O
;	O
littlenum_limit	O
=	O
digits_binary_low	O
+	O
more_than_enough_littlenums_for_digits	O
-	O
1	int
;	O
carry	O
=	O
c	O
-	O
'0'	O
;	O
for	O
(	O
littlenum_pointer	O
=	O
digits_binary_low	O
;	O
littlenum_pointer	O
<=	O
littlenum_limit	O
;	O
littlenum_pointer	O
++	O
)	O
{	O
long	O
work	O
;	O
work	O
=	O
carry	O
+	O
10	int
*	O
(	O
long	O
)	O
(	O
*	O
littlenum_pointer	O
)	O
;	O
*	O
littlenum_pointer	O
=	O
work	O
&	O
LITTLENUM_MASK	O
;	O
carry	O
=	O
work	O
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
carry	O
!=	O
0	int
)	O
{	O
as_fatal	O
(	O
_	O
(	O
"failed sanity check"	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
{	O
++	O
count	int
;	O
}	O
}	O
while	O
(	O
digits_binary_low	O
[	O
size_of_digits_in_littlenums	O
-	O
1	int
]	O
==	O
0	int
&&	O
size_of_digits_in_littlenums	O
>=	O
2	int
)	O
size_of_digits_in_littlenums	O
--	O
;	O
digits_flonum	O
.	O
low	O
=	O
digits_binary_low	O
;	O
digits_flonum	O
.	O
high	O
=	O
digits_binary_low	O
+	O
size_of_digits_in_littlenums	O
-	O
1	int
;	O
digits_flonum	O
.	O
leader	O
=	O
digits_flonum	O
.	O
high	O
;	O
digits_flonum	O
.	O
exponent	O
=	O
0	int
;	O
digits_flonum	O
.	O
sign	O
=	O
'+'	O
;	O
{	O
int	O
decimal_exponent_is_negative	O
;	O
FLONUM_TYPE	O
temporary_flonum	O
;	O
unsigned	O
int	O
size_of_power_in_littlenums	O
;	O
unsigned	O
int	O
size_of_power_in_chars	O
;	O
size_of_power_in_littlenums	O
=	O
precision	O
;	O
decimal_exponent_is_negative	O
=	O
decimal_exponent	O
<	O
0	int
;	O
if	O
(	O
decimal_exponent_is_negative	O
)	O
{	O
decimal_exponent	O
=	O
-	O
decimal_exponent	O
;	O
}	O
size_of_power_in_chars	O
=	O
size_of_power_in_littlenums	O
*	O
sizeof	O
(	O
LITTLENUM_TYPE	O
)	O
+	O
2	int
;	O
power_binary_low	O
=	O
(	O
LITTLENUM_TYPE	O
*	O
)	O
xmalloc	O
(	O
size_of_power_in_chars	O
)	O
;	O
temporary_binary_low	O
=	O
(	O
LITTLENUM_TYPE	O
*	O
)	O
xmalloc	O
(	O
size_of_power_in_chars	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
power_binary_low	O
,	O
'\0'	O
,	O
size_of_power_in_chars	O
)	O
;	O
*	O
power_binary_low	O
=	O
1	int
;	O
power_of_10_flonum	O
.	O
exponent	O
=	O
0	int
;	O
power_of_10_flonum	O
.	O
low	O
=	O
power_binary_low	O
;	O
power_of_10_flonum	O
.	O
leader	O
=	O
power_binary_low	O
;	O
power_of_10_flonum	O
.	O
high	O
=	O
power_binary_low	O
+	O
size_of_power_in_littlenums	O
-	O
1	int
;	O
power_of_10_flonum	O
.	O
sign	O
=	O
'+'	O
;	O
temporary_flonum	O
.	O
low	O
=	O
temporary_binary_low	O
;	O
temporary_flonum	O
.	O
high	O
=	O
temporary_binary_low	O
+	O
size_of_power_in_littlenums	O
-	O
1	int
;	O
{	O
int	O
place_number_limit	O
;	O
int	O
place_number	O
;	O
const	O
FLONUM_TYPE	O
*	O
multiplicand	O
;	O
place_number_limit	O
=	O
table_size_of_flonum_powers_of_ten	O
;	O
multiplicand	O
=	O
(	O
decimal_exponent_is_negative	O
?	O
flonum_negative_powers_of_ten	O
:	O
flonum_positive_powers_of_ten	O
)	O
;	O
for	O
(	O
place_number	O
=	O
1	int
;	O
decimal_exponent	O
;	O
decimal_exponent	O
>>=	O
1	int
,	O
place_number	O
++	O
)	O
{	O
if	O
(	O
decimal_exponent	O
&	O
1	int
)	O
{	O
if	O
(	O
place_number	O
>	O
place_number_limit	O
)	O
{	O
return_value	O
=	O
ERROR_EXPONENT_OVERFLOW	O
;	O
decimal_exponent	O
=	O
0	int
;	O
}	O
else	O
{	O
flonum_multip	O
(	O
multiplicand	O
+	O
place_number	O
,	O
&	O
power_of_10_flonum	O
,	O
&	O
temporary_flonum	O
)	O
;	O
flonum_copy	O
(	O
&	O
temporary_flonum	O
,	O
&	O
power_of_10_flonum	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
flonum_multip	O
(	O
&	O
power_of_10_flonum	O
,	O
&	O
digits_flonum	O
,	O
address_of_generic_floating_point_number	O
)	O
;	O
address_of_generic_floating_point_number	O
->	O
sign	O
=	O
digits_sign_char	O
;	O
if	O
(	O
temporary_binary_low	O
)	O
free	(*(void))->(void)
(	O
temporary_binary_low	O
)	O
;	O
if	O
(	O
power_binary_low	O
)	O
free	(*(void))->(void)
(	O
power_binary_low	O
)	O
;	O
free	(*(void))->(void)
(	O
digits_binary_low	O
)	O
;	O
}	O
return	O
return_value	O
;	O
}	O
