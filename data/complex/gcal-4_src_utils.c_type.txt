__BEGIN_DECLARATIONS	O
static	O
void	O
gregorian2julian	(*(int),*(int),*(int))->(void)
__P_	O
(	O
(	O
int	O
*	O
day	int
,	O
int	O
*	O
month	int
,	O
int	O
*	O
year	int
)	O
)	O
;	O
static	O
int	O
raw_week_number	(int,int,int,int,int)->(int)
__P_	O
(	O
(	O
const	O
int	O
day	int
,	O
const	O
int	O
month	int
,	O
const	O
int	O
year	int
,	O
const	O
Bool	int
is_iso_week	int
,	O
const	O
int	O
start_day_of_week	int
)	O
)	O
;	O
static	O
const	O
char	O
*	O
dflt_day_name	(int)->(*(char))
__P_	O
(	O
(	O
const	O
int	O
day	int
)	O
)	O
;	O
static	O
const	O
char	O
*	O
dflt_month_name	(int)->(*(char))
__P_	O
(	O
(	O
const	O
int	O
month	int
)	O
)	O
;	O
__END_DECLARATIONS	O
VOID_PTR	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
const	O
int	O
amount	int
;	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	*(char)
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	*(char)
;	O
const	O
int	O
var_contents	int
;	O
{	O
auto	O
VOID_PTR	O
ptr_memblock	*(void)
;	O
if	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_TABLE_CRASH	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
(	O
int	O
)	O
testval	int
)	O
;	O
ptr_memblock	*(void)
=	O
(	O
VOID_PTR	O
)	O
malloc	(long)->(*(void))
(	O
(	O
int	O
)	O
amount	int
)	O
;	O
if	O
(	O
ptr_memblock	*(void)
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
;	O
return	O
(	O
ptr_memblock	*(void)
)	O
;	O
}	O
VOID_PTR	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
ptr_memblock	*(void)
,	O
amount	int
,	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
VOID_PTR	O
ptr_memblock	*(void)
;	O
const	O
int	O
amount	int
;	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	*(char)
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	*(char)
;	O
const	O
int	O
var_contents	int
;	O
{	O
if	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_TABLE_CRASH	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
(	O
int	O
)	O
testval	int
)	O
;	O
if	O
(	O
ptr_memblock	*(void)
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
return	O
(	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
)	O
;	O
ptr_memblock	*(void)
=	O
(	O
VOID_PTR	O
)	O
realloc	(*(void),long)->(*(void))
(	O
ptr_memblock	*(void)
,	O
(	O
int	O
)	O
amount	int
)	O
;	O
if	O
(	O
ptr_memblock	*(void)
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
;	O
return	O
(	O
ptr_memblock	*(void)
)	O
;	O
}	O
void	O
allocate_all_strings	(int,*(char),long)->(void)
(	O
amount	int
,	O
module_name	*(char)
,	O
module_line	long
)	O
const	O
int	O
amount	int
;	O
const	O
char	O
*	O
module_name	*(char)
;	O
const	O
long	O
module_line	long
;	O
{	O
static	O
Bool	int
all_strings_initialized	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
all_strings_initialized	int
)	O
{	O
s1	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s1"	*(char)
,	O
0	int
)	O
;	O
s2	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s2"	*(char)
,	O
0	int
)	O
;	O
s3	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s3"	*(char)
,	O
0	int
)	O
;	O
s4	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s4"	*(char)
,	O
0	int
)	O
;	O
s5	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s5"	*(char)
,	O
0	int
)	O
;	O
s6	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s6"	*(char)
,	O
0	int
)	O
;	O
s7	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s7"	*(char)
,	O
0	int
)	O
;	O
line_buffer	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"line_buffer"	*(char)
,	O
0	int
)	O
;	O
all_strings_initialized	int
=	O
TRUE	O
;	O
}	O
}	O
void	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
amount	int
,	O
with_line_buffer	int
,	O
module_name	*(char)
,	O
module_line	long
)	O
const	O
int	O
amount	int
;	O
const	O
Bool	int
with_line_buffer	int
;	O
const	O
char	O
*	O
module_name	*(char)
;	O
const	O
long	O
module_line	long
;	O
{	O
if	O
(	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
&&	O
(	O
maxlen_max	int
<	O
testval	int
)	O
)	O
maxlen_max	int
=	O
testval	int
;	O
else	O
maxlen_max	int
=	O
(	O
Uint	int
)	O
amount	int
;	O
s1	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s1	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s1"	*(char)
,	O
maxlen_max	int
)	O
;	O
s2	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s2	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s2"	*(char)
,	O
maxlen_max	int
)	O
;	O
s3	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s3	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s3"	*(char)
,	O
maxlen_max	int
)	O
;	O
s4	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s4	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s4"	*(char)
,	O
maxlen_max	int
)	O
;	O
s5	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s5	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s5"	*(char)
,	O
maxlen_max	int
)	O
;	O
s6	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s6	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s6"	*(char)
,	O
maxlen_max	int
)	O
;	O
s7	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
s7	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"s7"	*(char)
,	O
maxlen_max	int
)	O
;	O
if	O
(	O
with_line_buffer	int
)	O
line_buffer	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
line_buffer	*(char)
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
"line_buffer"	*(char)
,	O
maxlen_max	int
)	O
;	O
}	O
void	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
exit_status	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	*(char)
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	*(char)
;	O
const	O
int	O
var_contents	int
;	O
{	O
S_NEWLINE	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
prgr_name	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
prgr_name	*(char)
=	O
PACKAGE_NAME	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: abort, "	*(char)
)	O
,	O
prgr_name	*(char)
)	O
;	O
switch	O
(	O
exit_status	int
)	O
{	O
case	O
ERR_INVALID_EASTER_DATE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid year for computing Easter Sundays date\nYear must be in range (%d...%d)"	*(char)
)	O
,	O
EASTER_MIN	int
,	O
EASTER_MAX	O
)	O
;	O
break	O
;	O
case	O
ERR_NO_MEMORY_AVAILABLE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"`%s' line %ld: virtual memory exhausted (%s=%d)"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
,	O
var_contents	int
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DATE_FIELD	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid date part in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_MONTH_FIELD	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid month field(%02d) in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
var_contents	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DAY_FIELD	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid day field(%02d) in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
var_contents	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_MALFORMED_INCLUDE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed %s in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
RC_INCL_STMENT	*(char)
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_CYCLIC_INCLUDE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid recursive/cyclic %s in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
RC_INCL_STMENT	*(char)
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_FILE_NOT_FOUND	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"file `%s' not found"	*(char)
)	O
,	O
module_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_NWD_FIELD	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid N'th weekday field(%d) in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
var_contents	int
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_NO_SEPARATOR_CHAR	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"missing `whitespace' character after date part in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_WRITE_FILE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"file `%s' can't be written\nStorage media full!"	*(char)
)	O
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_EMAIL_SEND_FAILURE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"sending eMail to <%s> failed"	*(char)
)	O
,	O
var_name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n`%s' line %ld: "	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
)	O
;	O
perror	(*(char))->(void)
(	O
"perror"	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INTERNAL_C_FUNC_FAILURE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"`%s' line %ld: (`%s') `%s%d' failed"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
var_name	*(char)
,	O
var_contents	int
)	O
;	O
perror	(*(char))->(void)
(	O
"\nperror"	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_READ_FILE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"read error in file `%s'"	*(char)
)	O
,	O
var_name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n`%s' line %ld: "	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
)	O
;	O
perror	(*(char))->(void)
(	O
"perror"	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_ILLEGAL_CHAR_IN_FILE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal character in response file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INTERNAL_TABLE_CRASH	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"`%s' line %ld: (`%s') invalid value for table size `sizeof %s>%d'"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
var_name	*(char)
,	O
var_contents	int
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DATE_FORMAT	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"(`%s') date format `%s' is invalid"	*(char)
)	O
,	O
module_name	*(char)
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_REGEX_PATTERN	int
:	O
if	O
(	O
*	O
module_name	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s in search pattern `%s'"	*(char)
)	O
,	O
module_name	*(char)
,	O
var_name	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid search pattern `%s' specified"	*(char)
)	O
,	O
var_name	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"`%s' line %ld: (`%s') unmanaged error (%d)"	*(char)
)	O
,	O
module_name	*(char)
,	O
module_line	long
,	O
_	O
(	O
"internal"	*(char)
)	O
,	O
exit_status	int
)	O
;	O
}	O
S_NEWLINE	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
my_exit	(int)->(void)
(	O
exit_status	int
)	O
;	O
}	O
RETSIGTYPE	void
handle_signal	(int)->(void)
(	O
the_signal	int
)	O
int	O
the_signal	int
;	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n%s: program aborted by signal %d\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
the_signal	int
)	O
;	O
my_exit	(int)->(void)
(	O
ERR_TERMINATION_BY_SIGNAL	int
)	O
;	O
}	O
void	O
my_exit	(int)->(void)
(	O
exit_status	int
)	O
const	O
int	O
exit_status	int
;	O
{	O
if	O
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
rc_tvar_tfn	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	(*(char))->(int)
(	O
rc_tvar_tfn	*(char)
)	O
;	O
if	O
(	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
rc_here_fn	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	(*(char))->(int)
(	O
rc_here_fn	*(char)
)	O
;	O
if	O
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
tfn	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	(*(char))->(int)
(	O
tfn	*(char)
)	O
;	O
exit	(int)->(void)
(	O
exit_status	int
)	O
;	O
}	O
int	O
my_atoi	(*(char))->(int)
(	O
string	*(char)
)	O
const	O
char	O
*	O
string	*(char)
;	O
{	O
while	O
(	O
*	O
string	*(char)
==	O
'0'	O
)	O
string	*(char)
++	O
;	O
if	O
(	O
*	O
string	*(char)
==	O
'-'	O
||	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
>	O
len_year_max	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
atoi	(*(char))->(int)
(	O
string	*(char)
)	O
)	O
;	O
}	O
int	O
my_system	(*(char))->(int)
(	O
command	*(char)
)	O
const	O
char	O
*	O
command	*(char)
;	O
{	O
return	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
system	(*(char))->(int)
(	O
command	*(char)
)	O
>>	O
8	int
)	O
&	O
0xff	int
)	O
;	O
}	O
Bool	int
get_actual_date	()->(int)
(	O
)	O
{	O
auto	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
auto	O
MY_TIME_T	O
sys_time	long
;	O
static	O
Bool	int
got_time	int
=	O
FALSE	O
;	O
sys_time	long
=	O
time	struct(long,long)
(	O
(	O
MY_TIME_T	O
*	O
)	O
NULL	O
)	O
;	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
sys_time	long
)	O
;	O
true_day	int
=	O
act_day	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mday	int
;	O
true_month	int
=	O
act_month	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mon	int
+	O
1	int
;	O
act_year	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
;	O
if	O
(	O
act_year	int
<	O
CENTURY	int
)	O
act_year	int
+=	O
CENTURY	int
;	O
true_year	int
=	O
act_year	int
;	O
if	O
(	O
!	O
got_time	int
)	O
{	O
act_sec	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_sec	int
;	O
act_min	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_min	int
;	O
act_hour	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_hour	int
;	O
buf_ad	int
=	O
act_day	int
;	O
buf_am	int
=	O
act_month	int
;	O
buf_ay	int
=	O
act_year	int
;	O
}	O
if	O
(	O
rc_adate	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
auto	O
int	O
d	int
=	O
0	int
;	O
auto	O
int	O
m	int
=	O
0	int
;	O
auto	O
int	O
y	int
=	O
0	int
;	O
auto	O
int	O
n	long
=	O
0	int
;	O
auto	O
int	O
hn	int
=	O
0	int
;	O
auto	O
int	O
hwd	int
=	O
0	int
;	O
auto	O
int	O
i_dummy	int
;	O
auto	O
char	O
hc	char
=	O
'\0'	O
;	O
auto	O
char	O
*	O
c_dummy	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
b_dummy	int
;	O
if	O
(	O
!	O
*	O
rc_adate	*(char)
||	O
*	O
rc_adate	*(char)
==	O
RC_HDY_CHAR	char
)	O
return	O
(	O
FALSE	O
)	O
;	O
m	int
=	O
act_month	int
;	O
y	int
=	O
act_year	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
rc_adate	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
rc_adate	*(char)
)	O
<=	O
2	int
)	O
{	O
d	int
=	O
atoi	(*(char))->(int)
(	O
rc_adate	*(char)
)	O
;	O
if	O
(	O
!	O
d	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
(	O
void	O
)	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
rc_adate	*(char)
,	O
lptrs3	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
FALSE	O
,	O
&	O
b_dummy	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
i_dummy	int
,	O
&	O
hc	char
,	O
&	O
hn	int
,	O
&	O
hwd	int
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
-	O
1L	int
,	O
rc_adate	*(char)
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
d	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
rc_adate	*(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
d	int
)	O
{	O
c_dummy	*(char)
=	O
rc_adate	*(char)
;	O
while	O
(	O
isalpha	(int)->(int)
(	O
*	O
c_dummy	*(char)
)	O
)	O
c_dummy	*(char)
++	O
;	O
if	O
(	O
*	O
c_dummy	*(char)
)	O
{	O
n	long
=	O
atoi	(*(char))->(int)
(	O
c_dummy	*(char)
)	O
;	O
if	O
(	O
!	O
n	long
)	O
return	O
(	O
FALSE	O
)	O
;	O
c_dummy	*(char)
++	O
;	O
if	O
(	O
*	O
c_dummy	*(char)
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
hn	int
=	O
act_day	int
;	O
i_dummy	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
;	O
if	O
(	O
d	int
>	O
i_dummy	int
)	O
do	O
{	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
hn	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
}	O
while	O
(	O
d	int
!=	O
weekday_of_date	(int,int,int)->(int)
(	O
hn	int
,	O
m	int
,	O
y	int
)	O
)	O
;	O
else	O
if	O
(	O
d	int
<	O
i_dummy	int
)	O
do	O
{	O
(	O
void	O
)	O
prev_date	(*(int),*(int),*(int))->(int)
(	O
&	O
hn	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
}	O
while	O
(	O
d	int
!=	O
weekday_of_date	(int,int,int)->(int)
(	O
hn	int
,	O
m	int
,	O
y	int
)	O
)	O
;	O
d	int
=	O
hn	int
;	O
}	O
}	O
else	O
{	O
m	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
rc_adate	*(char)
,	O
MOnth	int
)	O
;	O
if	O
(	O
!	O
m	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
c_dummy	*(char)
=	O
rc_adate	*(char)
;	O
while	O
(	O
isupper	(int)->(int)
(	O
*	O
c_dummy	*(char)
)	O
||	O
islower	(int)->(int)
(	O
*	O
c_dummy	*(char)
)	O
)	O
c_dummy	*(char)
++	O
;	O
if	O
(	O
*	O
c_dummy	*(char)
)	O
{	O
d	int
=	O
atoi	(*(char))->(int)
(	O
c_dummy	*(char)
)	O
;	O
if	O
(	O
!	O
d	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
d	int
=	O
act_day	int
;	O
}	O
}	O
if	O
(	O
y	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
act_year	int
;	O
if	O
(	O
!	O
m	int
)	O
m	int
=	O
act_month	int
;	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
d	int
>	O
DAY_MAX	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
act_day	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
m	int
==	O
2	int
)	O
i_dummy	int
=	O
days_of_february	(int)->(int)
(	O
y	int
)	O
;	O
else	O
i_dummy	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
n	long
==	O
9	int
)	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
i_dummy	int
,	O
m	int
,	O
y	int
,	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
(	O
n	long
>=	O
1	int
)	O
&&	O
(	O
n	long
<=	O
5	int
)	O
)	O
{	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
m	int
,	O
y	int
,	O
d	int
,	O
TRUE	O
)	O
;	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
d	int
>	O
i_dummy	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
hc	char
)	O
{	O
switch	O
(	O
hc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
n	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
DVar	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
act_day	int
;	O
else	O
if	O
(	O
d	int
==	O
99	int
)	O
{	O
if	O
(	O
m	int
==	O
2	int
)	O
d	int
=	O
days_of_february	(int)->(int)
(	O
y	int
)	O
;	O
else	O
d	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
valid_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
)	O
{	O
act_day	int
=	O
d	int
;	O
act_month	int
=	O
m	int
;	O
act_year	int
=	O
y	int
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
gregorian2julian	(*(int),*(int),*(int))->(void)
(	O
&	O
act_day	int
,	O
&	O
act_month	int
,	O
&	O
act_year	int
)	O
;	O
if	O
(	O
!	O
got_time	int
)	O
{	O
got_time	int
=	O
TRUE	O
;	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
sys_time	long
)	O
;	O
gmt_min	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_min	int
;	O
gmt_hour	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_hour	int
;	O
buf_gd	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mday	int
;	O
buf_gm	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mon	int
+	O
1	int
;	O
buf_gy	int
=	O
sys_date	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
;	O
if	O
(	O
buf_gy	int
<	O
CENTURY	int
)	O
buf_gy	int
+=	O
CENTURY	int
;	O
gregorian2julian	(*(int),*(int),*(int))->(void)
(	O
&	O
buf_gd	int
,	O
&	O
buf_gm	int
,	O
&	O
buf_gy	int
)	O
;	O
gmt_loc_diff	int
=	O
(	O
int	O
)	O
d_between	(int,int,int,int,int,int)->(long)
(	O
buf_ad	int
,	O
buf_am	int
,	O
buf_ay	int
,	O
buf_gd	int
,	O
buf_gm	int
,	O
buf_gy	int
)	O
;	O
buf_ad	int
=	O
act_day	int
;	O
buf_am	int
=	O
act_month	int
;	O
buf_ay	int
=	O
act_year	int
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
int	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
string	*(char)
,	O
mode	enum(int,int,int,int,int,int,int)
)	O
const	O
char	O
*	O
string	*(char)
;	O
const	O
Cmode_enum	enum(int,int,int,int,int,int,int)
mode	enum(int,int,int,int,int,int,int)
;	O
{	O
register	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
register	O
const	O
int	O
len_min	int
=	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
?	O
TXTLEN_DAY	int
:	O
TXTLEN_MONTH	int
;	O
register	O
int	O
i	int
;	O
register	O
int	O
imax	int
=	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
?	O
DAY_MAX	int
:	O
MONTH_MAX	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
register	O
int	O
checks	int
;	O
auto	O
const	O
char	O
*	O
ptr_char	*(char)
=	O
string	*(char)
;	O
if	O
(	O
is_en	int
)	O
checks	int
=	O
1	int
;	O
else	O
checks	int
=	O
2	int
;	O
if	O
(	O
len	int
>=	O
TXTLEN_DAY	int
)	O
{	O
while	O
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
&&	O
!	O
isdigit	(int)->(int)
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
)	O
&&	O
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
!=	O
RC_REPEAT_CHAR	char
)	O
&&	O
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
j	int
++	O
;	O
if	O
(	O
j	int
>=	O
len_min	int
)	O
do	O
{	O
for	O
(	O
i	int
=	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
?	O
DAY_MIN	int
:	O
MONTH_MIN	int
;	O
i	int
<=	O
imax	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
checks	int
==	O
2	int
)	O
ptr_char	*(char)
=	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
?	O
day_name	(int)->(*(char))
(	O
i	int
)	O
:	O
month_name	(int)->(*(char))
(	O
i	int
)	O
;	O
else	O
ptr_char	*(char)
=	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
?	O
dflt_day_name	(int)->(*(char))
(	O
i	int
)	O
:	O
dflt_month_name	(int)->(*(char))
(	O
i	int
)	O
;	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
&&	O
string	*(char)
[	O
j	int
]	O
)	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
)	O
==	O
tolower	(int)->(int)
(	O
string	*(char)
[	O
j	int
]	O
)	O
)	O
j	int
++	O
;	O
else	O
break	O
;	O
if	O
(	O
j	int
==	O
len	int
||	O
(	O
j	int
&&	O
(	O
isdigit	(int)->(int)
(	O
string	*(char)
[	O
j	int
]	O
)	O
||	O
string	*(char)
[	O
j	int
]	O
==	O
RC_REPEAT_CHAR	char
||	O
string	*(char)
[	O
j	int
]	O
==	O
RC_APPEARS_CHAR	char
)	O
)	O
||	O
!	O
*	O
(	O
ptr_char	*(char)
+	O
j	int
)	O
)	O
return	O
(	O
i	int
)	O
;	O
}	O
}	O
while	O
(	O
--	O
checks	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
asc_sort	(*(*(char)),*(*(char)))->(int)
(	O
a	*(*(char))
,	O
b	*(*(char))
)	O
const	O
char	O
*	O
*	O
a	*(*(char))
;	O
const	O
char	O
*	O
*	O
b	*(*(char))
;	O
{	O
return	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(*(char))
,	O
*	O
b	*(*(char))
)	O
)	O
;	O
}	O
int	O
des_sort	(*(*(char)),*(*(char)))->(int)
(	O
a	*(*(char))
,	O
b	*(*(char))
)	O
const	O
char	O
*	O
*	O
a	*(*(char))
;	O
const	O
char	O
*	O
*	O
b	*(*(char))
;	O
{	O
return	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
b	*(*(char))
,	O
*	O
a	*(*(char))
)	O
)	O
;	O
}	O
Bool	int
is_presorted	(*(*(char)),int)->(int)
(	O
table	*(*(char))
,	O
elems	int
)	O
char	O
*	O
*	O
table	*(*(char))
;	O
int	O
elems	int
;	O
{	O
if	O
(	O
--	O
elems	int
>	O
0	int
)	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
while	O
(	O
elems	int
--	O
)	O
{	O
j	int
++	O
;	O
if	O
(	O
*	O
table	*(*(char))
[	O
i	int
]	O
>=	O
*	O
table	*(*(char))
[	O
j	int
]	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
table	*(*(char))
[	O
i	int
]	O
,	O
table	*(*(char))
[	O
j	int
]	O
)	O
>	O
0	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
++	O
;	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
void	O
reverse_order	(*(*(char)),int)->(void)
(	O
table	*(*(char))
,	O
elems	int
)	O
char	O
*	O
*	O
table	*(*(char))
;	O
const	O
int	O
elems	int
;	O
{	O
register	O
int	O
right	int
=	O
elems	int
-	O
1	int
;	O
if	O
(	O
right	int
>	O
0	int
)	O
{	O
register	O
int	O
left	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_elem	*(char)
;	O
while	O
(	O
left	int
<	O
right	int
)	O
{	O
ptr_elem	*(char)
=	O
table	*(*(char))
[	O
left	int
]	O
;	O
table	*(*(char))
[	O
left	int
++	O
]	O
=	O
table	*(*(char))
[	O
right	int
]	O
;	O
table	*(*(char))
[	O
right	int
--	O
]	O
=	O
ptr_elem	*(char)
;	O
}	O
}	O
}	O
const	O
char	O
*	O
day_suffix	(int)->(*(char))
(	O
day	int
)	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
suffix	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"th"	*(char)
)	O
,	O
N_	O
(	O
"st"	*(char)
)	O
,	O
N_	O
(	O
"nd"	*(char)
)	O
,	O
N_	O
(	O
"rd"	*(char)
)	O
}	O
;	O
register	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
day	int
<	O
0	int
)	O
day	int
=	O
-	O
day	int
;	O
if	O
(	O
day	int
>	O
10000	int
)	O
day	int
%=	O
10000	int
;	O
if	O
(	O
day	int
>	O
1000	int
)	O
day	int
%=	O
1000	int
;	O
if	O
(	O
day	int
>	O
100	int
)	O
day	int
%=	O
100	int
;	O
if	O
(	O
day	int
<	O
11	int
||	O
day	int
>	O
13	int
)	O
i	int
=	O
day	int
%	O
10	int
;	O
if	O
(	O
i	int
>	O
3	int
)	O
i	int
=	O
0	int
;	O
return	O
(	O
_	O
(	O
suffix	array(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short3_day_name	(int)->(*(char))
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	*(char)
)	O
,	O
N_	O
(	O
"Mon"	*(char)
)	O
,	O
N_	O
(	O
"Tue"	*(char)
)	O
,	O
N_	O
(	O
"Wed"	*(char)
)	O
,	O
N_	O
(	O
"Thu"	*(char)
)	O
,	O
N_	O
(	O
"Fri"	*(char)
)	O
,	O
N_	O
(	O
"Sat"	*(char)
)	O
,	O
N_	O
(	O
"Sun"	*(char)
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array(*(char))
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array(*(char))
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short_day_name	(int)->(*(char))
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	*(char)
)	O
,	O
N_	O
(	O
"Mo"	*(char)
)	O
,	O
N_	O
(	O
"Tu"	*(char)
)	O
,	O
N_	O
(	O
"We"	*(char)
)	O
,	O
N_	O
(	O
"Th"	*(char)
)	O
,	O
N_	O
(	O
"Fr"	*(char)
)	O
,	O
N_	O
(	O
"Sa"	*(char)
)	O
,	O
N_	O
(	O
"Su"	*(char)
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array(*(char))
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array(*(char))
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
day_name	(int)->(*(char))
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	*(char)
)	O
,	O
N_	O
(	O
"Monday"	*(char)
)	O
,	O
N_	O
(	O
"Tuesday"	*(char)
)	O
,	O
N_	O
(	O
"Wednesday"	*(char)
)	O
,	O
N_	O
(	O
"Thursday"	*(char)
)	O
,	O
N_	O
(	O
"Friday"	*(char)
)	O
,	O
N_	O
(	O
"Saturday"	*(char)
)	O
,	O
N_	O
(	O
"Sunday"	*(char)
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array(*(char))
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array(*(char))
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short_month_name	(int)->(*(char))
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid month"	*(char)
)	O
,	O
N_	O
(	O
"Jan"	*(char)
)	O
,	O
N_	O
(	O
"Feb"	*(char)
)	O
,	O
N_	O
(	O
"Mar"	*(char)
)	O
,	O
N_	O
(	O
"Apr"	*(char)
)	O
,	O
N_	O
(	O
"May"	*(char)
)	O
,	O
N_	O
(	O
"Jun"	*(char)
)	O
,	O
N_	O
(	O
"Jul"	*(char)
)	O
,	O
N_	O
(	O
"Aug"	*(char)
)	O
,	O
N_	O
(	O
"Sep"	*(char)
)	O
,	O
N_	O
(	O
"Oct"	*(char)
)	O
,	O
N_	O
(	O
"Nov"	*(char)
)	O
,	O
N_	O
(	O
"Dec"	*(char)
)	O
}	O
;	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array(*(char))
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array(*(char))
[	O
month	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
month_name	(int)->(*(char))
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid month"	*(char)
)	O
,	O
N_	O
(	O
"January"	*(char)
)	O
,	O
N_	O
(	O
"February"	*(char)
)	O
,	O
N_	O
(	O
"March"	*(char)
)	O
,	O
N_	O
(	O
"April"	*(char)
)	O
,	O
N_	O
(	O
"May "	*(char)
)	O
,	O
N_	O
(	O
"June"	*(char)
)	O
,	O
N_	O
(	O
"July"	*(char)
)	O
,	O
N_	O
(	O
"August"	*(char)
)	O
,	O
N_	O
(	O
"September"	*(char)
)	O
,	O
N_	O
(	O
"October"	*(char)
)	O
,	O
N_	O
(	O
"November"	*(char)
)	O
,	O
N_	O
(	O
"December"	*(char)
)	O
}	O
;	O
if	O
(	O
month	int
==	O
5	int
)	O
{	O
static	O
char	O
*	O
mayname	*(char)
;	O
static	O
Bool	int
is_initialized	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
is_initialized	int
)	O
{	O
register	O
int	O
len	int
;	O
auto	O
char	O
*	O
s	*(char)
=	O
_	O
(	O
name	array(*(char))
[	O
month	int
]	O
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
-	O
1	int
;	O
mayname	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"mayname"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
mayname	*(char)
,	O
s	*(char)
)	O
;	O
while	O
(	O
*	O
(	O
mayname	*(char)
+	O
len	int
)	O
==	O
' '	O
)	O
*	O
(	O
mayname	*(char)
+	O
len	int
--	O
)	O
=	O
'\0'	O
;	O
is_initialized	int
=	O
TRUE	O
;	O
}	O
return	O
(	O
mayname	*(char)
)	O
;	O
}	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array(*(char))
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array(*(char))
[	O
month	int
]	O
)	O
)	O
;	O
}	O
Ulint	long
date2num	(int,int,int)->(long)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
(	O
Ulint	long
)	O
(	O
(	O
year	int
-	O
1	int
)	O
*	O
(	O
Ulint	long
)	O
(	O
DAY_LAST	int
)	O
+	O
(	O
(	O
year	int
-	O
1	int
)	O
>>	O
2	int
)	O
)	O
;	O
if	O
(	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
||	O
(	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
month	int
>	O
greg	*(struct(int,int,int,int))
->	O
month	int
||	O
(	O
(	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
day	int
>	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
)	O
)	O
)	O
)	O
)	O
mjd	long
-=	O
(	O
Ulint	long
)	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
{	O
mjd	long
+=	O
(	O
(	O
(	O
year	int
-	O
1	int
)	O
/	O
400	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
400	int
)	O
)	O
;	O
mjd	long
-=	O
(	O
(	O
(	O
year	int
-	O
1	int
)	O
/	O
100	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
100	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
%	O
100	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
%	O
400	int
)	O
)	O
mjd	long
--	O
;	O
}	O
mjd	long
+=	O
(	O
Ulint	long
)	O
mvec	array(int)
[	O
month	int
-	O
1	int
]	O
;	O
mjd	long
+=	O
day	int
;	O
if	O
(	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
&&	O
(	O
month	int
>	O
2	int
)	O
)	O
mjd	long
++	O
;	O
return	O
(	O
mjd	long
)	O
;	O
}	O
void	O
num2date	(long,*(int),*(int),*(int))->(void)
(	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
)	O
Ulint	long
mjd	long
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
double	O
x	double
;	O
auto	O
Ulint	long
jdays	long
=	O
date2num	(int,int,int)->(long)
(	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
-	O
1	int
,	O
greg	*(struct(int,int,int,int))
->	O
month	int
,	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
;	O
register	O
int	O
i	int
;	O
if	O
(	O
mjd	long
>	O
jdays	long
)	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
;	O
x	double
=	O
(	O
double	O
)	O
mjd	long
/	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
;	O
i	int
=	O
(	O
int	O
)	O
x	double
;	O
if	O
(	O
(	O
double	O
)	O
i	int
!=	O
x	double
)	O
*	O
year	int
=	O
i	int
+	O
1	int
;	O
else	O
{	O
*	O
year	int
=	O
i	int
;	O
i	int
--	O
;	O
}	O
if	O
(	O
mjd	long
>	O
jdays	long
)	O
{	O
mjd	long
-=	O
(	O
Ulint	long
)	O
(	O
(	O
*	O
year	int
/	O
400	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
400	int
)	O
)	O
;	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
(	O
*	O
year	int
/	O
100	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
100	int
)	O
)	O
;	O
x	double
=	O
(	O
double	O
)	O
mjd	long
/	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
;	O
i	int
=	O
(	O
int	O
)	O
x	double
;	O
if	O
(	O
(	O
double	O
)	O
i	int
!=	O
x	double
)	O
*	O
year	int
=	O
i	int
+	O
1	int
;	O
else	O
{	O
*	O
year	int
=	O
i	int
;	O
i	int
--	O
;	O
}	O
if	O
(	O
(	O
*	O
year	int
%	O
400	int
)	O
&&	O
!	O
(	O
*	O
year	int
%	O
100	int
)	O
)	O
mjd	long
--	O
;	O
}	O
i	int
=	O
(	O
int	O
)	O
(	O
mjd	long
-	O
(	O
Ulint	long
)	O
(	O
i	int
*	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
)	O
)	O
;	O
if	O
(	O
(	O
*	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
*	O
year	int
%	O
400	int
)	O
&&	O
!	O
(	O
*	O
year	int
%	O
100	int
)	O
&&	O
(	O
i	int
<	O
(	O
(	O
*	O
year	int
/	O
100	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
100	int
)	O
)	O
-	O
(	O
(	O
*	O
year	int
/	O
400	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
/	O
400	int
)	O
)	O
)	O
)	O
i	int
++	O
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
,	O
(	O
days_of_february	(int)->(int)
(	O
*	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
;	O
}	O
Bool	int
doy2date	(int,int,*(int),*(int))->(int)
(	O
doy	*(int)
,	O
is_leap_year	int
,	O
day	int
,	O
month	int
)	O
int	O
doy	*(int)
;	O
const	O
int	O
is_leap_year	int
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
{	O
register	O
int	O
i	int
;	O
auto	O
Bool	int
decrement_date	int
;	O
if	O
(	O
doy	*(int)
>	O
DAY_LAST	int
+	O
is_leap_year	int
||	O
doy	*(int)
<	O
DAY_MIN	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
decrement_date	int
=	O
(	O
Bool	int
)	O
(	O
is_leap_year	int
&&	O
(	O
doy	*(int)
>	O
mvec	array(int)
[	O
2	int
]	O
)	O
)	O
;	O
if	O
(	O
decrement_date	int
)	O
doy	*(int)
--	O
;	O
for	O
(	O
i	int
=	O
MONTH_MIN	int
;	O
i	int
<	O
MONTH_MAX	int
;	O
i	int
++	O
)	O
{	O
doy	*(int)
-=	O
dvec	array(int)
[	O
i	int
-	O
1	int
]	O
;	O
if	O
(	O
doy	*(int)
<=	O
0	int
)	O
{	O
doy	*(int)
+=	O
dvec	array(int)
[	O
i	int
-	O
1	int
]	O
;	O
break	O
;	O
}	O
}	O
*	O
month	int
=	O
i	int
;	O
*	O
day	int
=	O
doy	*(int)
;	O
if	O
(	O
decrement_date	int
&&	O
(	O
*	O
month	int
==	O
2	int
)	O
&&	O
(	O
*	O
day	int
==	O
28	int
)	O
)	O
(	O
*	O
day	int
)	O
++	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
int	O
weekday_of_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
date2num	(int,int,int)->(long)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
%	O
DAY_MAX	int
;	O
return	O
(	O
(	O
mjd	long
>	O
2	int
)	O
?	O
(	O
int	O
)	O
mjd	long
-	O
2	int
:	O
(	O
int	O
)	O
mjd	long
+	O
5	int
)	O
;	O
}	O
int	O
day_of_year	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
month	int
<	O
3	int
)	O
i	int
=	O
mvec	array(int)
[	O
month	int
-	O
1	int
]	O
+	O
day	int
;	O
else	O
i	int
=	O
mvec	array(int)
[	O
month	int
-	O
1	int
]	O
+	O
day	int
+	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
days_of_february	(int)->(int)
(	O
year	int
)	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
day	int
;	O
if	O
(	O
(	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
||	O
(	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
==	O
1	int
||	O
(	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
==	O
2	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
>=	O
28	int
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
orthodox_calendar	int
)	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
(	O
(	O
!	O
(	O
year	int
%	O
100	int
)	O
)	O
?	O
(	O
(	O
(	O
year	int
%	O
9	int
)	O
==	O
2	int
||	O
(	O
year	int
%	O
9	int
)	O
==	O
6	int
)	O
?	O
29	int
:	O
28	int
)	O
:	O
29	int
)	O
;	O
else	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
(	O
(	O
!	O
(	O
year	int
%	O
100	int
)	O
&&	O
(	O
year	int
%	O
400	int
)	O
)	O
?	O
28	int
:	O
29	int
)	O
;	O
}	O
else	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
29	int
;	O
if	O
(	O
year	int
==	O
4	int
)	O
day	int
--	O
;	O
return	O
(	O
day	int
)	O
;	O
}	O
Bool	int
valid_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
if	O
(	O
day	int
<	O
0	int
||	O
month	int
<	O
MONTH_MIN	int
||	O
month	int
>	O
MONTH_MAX	int
||	O
(	O
(	O
month	int
!=	O
2	int
)	O
&&	O
(	O
day	int
>	O
dvec	array(int)
[	O
month	int
-	O
1	int
]	O
)	O
)	O
||	O
(	O
(	O
month	int
==	O
2	int
)	O
&&	O
(	O
day	int
>	O
days_of_february	(int)->(int)
(	O
year	int
)	O
)	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
prev_date	(*(int),*(int),*(int))->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
Bool	int
no_missing_date	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
*	O
day	int
<=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
+	O
1	int
)	O
&&	O
(	O
*	O
day	int
>=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
)	O
&&	O
(	O
*	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
*	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
{	O
no_missing_date	int
=	O
FALSE	O
;	O
*	O
day	int
=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
-	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
day	int
)	O
--	O
;	O
if	O
(	O
!	O
*	O
day	int
||	O
!	O
valid_date	(int,int,int)->(int)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
)	O
{	O
(	O
*	O
month	int
)	O
--	O
;	O
if	O
(	O
*	O
month	int
<	O
MONTH_MIN	int
)	O
{	O
*	O
month	int
=	O
MONTH_MAX	int
;	O
(	O
*	O
year	int
)	O
--	O
;	O
}	O
if	O
(	O
*	O
month	int
==	O
2	int
)	O
*	O
day	int
=	O
days_of_february	(int)->(int)
(	O
*	O
year	int
)	O
;	O
else	O
*	O
day	int
=	O
dvec	array(int)
[	O
*	O
month	int
-	O
1	int
]	O
;	O
}	O
}	O
return	O
(	O
no_missing_date	int
)	O
;	O
}	O
Bool	int
next_date	(*(int),*(int),*(int))->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
Bool	int
no_missing_date	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
*	O
day	int
>=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
-	O
1	int
)	O
&&	O
(	O
*	O
day	int
<=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
)	O
&&	O
(	O
*	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
*	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
{	O
no_missing_date	int
=	O
FALSE	O
;	O
*	O
day	int
=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
+	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
day	int
)	O
++	O
;	O
if	O
(	O
!	O
valid_date	(int,int,int)->(int)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
)	O
{	O
*	O
day	int
=	O
DAY_MIN	int
;	O
if	O
(	O
*	O
month	int
==	O
MONTH_MAX	int
)	O
{	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
(	O
*	O
year	int
)	O
++	O
;	O
}	O
else	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
return	O
(	O
no_missing_date	int
)	O
;	O
}	O
int	O
week_number	(int,int,int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
i	int
=	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
j	int
;	O
register	O
int	O
wmax	int
=	O
WEEK_MAX	int
;	O
if	O
(	O
(	O
i	int
>	O
1	int
)	O
&&	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
i	int
>=	O
wmax	int
)	O
{	O
if	O
(	O
month	int
==	O
MONTH_MIN	int
)	O
{	O
j	int
=	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
i	int
==	O
j	int
)	O
i	int
=	O
-	O
i	int
;	O
else	O
i	int
=	O
0	int
;	O
}	O
else	O
{	O
j	int
=	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
+	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
i	int
==	O
j	int
)	O
i	int
=	O
-	O
i	int
;	O
else	O
if	O
(	O
(	O
j	int
==	O
1	int
)	O
&&	O
(	O
i	int
==	O
wmax	int
+	O
1	int
)	O
)	O
i	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
is_iso_week	int
&&	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
<=	O
4	int
)	O
)	O
||	O
(	O
!	O
is_iso_week	int
&&	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
<=	O
start_day_of_week	int
)	O
)	O
)	O
{	O
j	int
=	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
year	int
-	O
1	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
j	int
!=	O
wmax	int
)	O
i	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
i	int
==	O
wmax	int
-	O
1	int
)	O
&&	O
(	O
month	int
==	O
MONTH_MIN	int
)	O
&&	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
+	O
1	int
)	O
)	O
i	int
=	O
-	O
i	int
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
weekno2doy	(int,int,int,int)->(int)
(	O
week	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
int	O
week	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
wd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
;	O
register	O
int	O
ww	int
=	O
week_number	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
wm	int
=	O
week_number	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
wmax	int
=	O
WEEK_MAX	int
;	O
register	O
int	O
i	int
=	O
DAY_MIN	int
;	O
if	O
(	O
wm	int
<	O
0	int
)	O
wm	int
=	O
-	O
wm	int
;	O
if	O
(	O
ww	int
==	O
-	O
(	O
wmax	int
-	O
1	int
)	O
||	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
ww	int
<	O
0	int
)	O
ww	int
=	O
-	O
ww	int
;	O
if	O
(	O
ww	int
>	O
1	int
)	O
i	int
+=	O
SDAY	O
(	O
DAY_MAX	int
-	O
wd	int
+	O
1	int
,	O
start_day_of_week	int
)	O
;	O
else	O
if	O
(	O
!	O
ww	int
)	O
i	int
-=	O
SDAY	O
(	O
wd	int
-	O
1	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
wm	int
&&	O
(	O
wm	int
!=	O
wmax	int
+	O
1	int
)	O
&&	O
(	O
week	int
==	O
wmax	int
+	O
1	int
)	O
)	O
return	O
(	O
-	O
WEEK_MAX	int
)	O
;	O
else	O
if	O
(	O
week	int
==	O
99	int
)	O
{	O
week	int
=	O
wm	int
;	O
if	O
(	O
!	O
wm	int
)	O
week	int
=	O
wmax	int
+	O
1	int
;	O
i	int
+=	O
(	O
(	O
(	O
week	int
-	O
1	int
)	O
*	O
DAY_MAX	int
)	O
)	O
;	O
}	O
else	O
{	O
i	int
+=	O
(	O
(	O
(	O
week	int
-	O
1	int
)	O
*	O
DAY_MAX	int
)	O
)	O
;	O
if	O
(	O
!	O
week	int
&&	O
(	O
i	int
<=	O
-	O
(	O
DAY_MAX	int
-	O
1	int
)	O
)	O
)	O
i	int
+=	O
DAY_MAX	int
;	O
}	O
if	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
if	O
(	O
i	int
+	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
>	O
day_of_year	(int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
,	O
greg	*(struct(int,int,int,int))
->	O
month	int
,	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
i	int
+=	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
i	int
>	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
)	O
return	O
(	O
-	O
WEEK_MAX	int
)	O
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
knuth_easter_formula	(int)->(int)
(	O
year	int
)	O
const	O
int	O
year	int
;	O
{	O
auto	O
long	O
extra_days	long
;	O
register	O
int	O
golden_number	int
=	O
(	O
year	int
%	O
19	int
)	O
+	O
1	int
;	O
register	O
int	O
century	int
;	O
register	O
int	O
gregorian_correction	int
;	O
register	O
int	O
clavian_correction	int
;	O
register	O
int	O
epact	int
;	O
register	O
int	O
day	int
;	O
register	O
int	O
month	int
;	O
register	O
int	O
easter	int
;	O
auto	O
Bool	int
was_julian	int
=	O
FALSE	O
;	O
if	O
(	O
(	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
||	O
(	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
<	O
3	int
||	O
(	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
==	O
3	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
<	O
22	int
)	O
)	O
)	O
)	O
)	O
{	O
LABEL_compute_gregorian	O
:	O
century	int
=	O
year	int
/	O
100	int
+	O
1	int
;	O
gregorian_correction	int
=	O
(	O
3	int
*	O
century	int
/	O
4	int
)	O
-	O
12	int
;	O
clavian_correction	int
=	O
(	O
(	O
8	int
*	O
century	int
+	O
5	int
)	O
/	O
25	int
)	O
-	O
5	int
;	O
extra_days	long
=	O
(	O
5L	int
*	O
year	int
/	O
4	int
)	O
-	O
gregorian_correction	int
-	O
10	int
;	O
epact	int
=	O
(	O
11	int
*	O
golden_number	int
+	O
20	int
+	O
clavian_correction	int
-	O
gregorian_correction	int
)	O
%	O
30	int
;	O
if	O
(	O
epact	int
<=	O
0	int
)	O
epact	int
+=	O
30	int
;	O
if	O
(	O
(	O
(	O
epact	int
==	O
25	int
)	O
&&	O
(	O
golden_number	int
>	O
11	int
)	O
)	O
||	O
epact	int
==	O
24	int
)	O
epact	int
++	O
;	O
}	O
else	O
{	O
was_julian	int
=	O
TRUE	O
;	O
extra_days	long
=	O
(	O
5L	int
*	O
year	int
)	O
/	O
4	int
;	O
epact	int
=	O
(	O
(	O
11	int
*	O
golden_number	int
-	O
4	int
)	O
%	O
30	int
)	O
+	O
1	int
;	O
}	O
day	int
=	O
44	int
-	O
epact	int
;	O
if	O
(	O
day	int
<	O
21	int
)	O
day	int
+=	O
30	int
;	O
day	int
+=	O
DAY_MAX	int
-	O
(	O
int	O
)	O
(	O
(	O
extra_days	long
+	O
day	int
)	O
%	O
DAY_MAX	int
)	O
;	O
if	O
(	O
day	int
>	O
MONTH_LAST	int
)	O
{	O
day	int
-=	O
MONTH_LAST	int
;	O
month	int
=	O
4	int
;	O
}	O
else	O
month	int
=	O
3	int
;	O
easter	int
=	O
day_of_year	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
was_julian	int
&&	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
==	O
3	int
||	O
(	O
(	O
greg	*(struct(int,int,int,int))
->	O
month	int
==	O
4	int
)	O
&&	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
<=	O
25	int
)	O
)	O
)	O
)	O
{	O
was_julian	int
=	O
FALSE	O
;	O
if	O
(	O
(	O
easter	int
>=	O
day_of_year	(int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
,	O
greg	*(struct(int,int,int,int))
->	O
month	int
,	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
&&	O
(	O
easter	int
<=	O
day_of_year	(int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
,	O
greg	*(struct(int,int,int,int))
->	O
month	int
,	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
)	O
)	O
goto	O
LABEL_compute_gregorian	O
;	O
}	O
return	O
(	O
easter	int
)	O
;	O
}	O
int	O
julian_gregorian_diff	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
(	O
Ulint	long
)	O
(	O
(	O
year	int
-	O
1	int
)	O
*	O
(	O
Ulint	long
)	O
(	O
DAY_LAST	int
)	O
+	O
(	O
(	O
year	int
-	O
1	int
)	O
>>	O
2	int
)	O
)	O
;	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
mvec	array(int)
[	O
month	int
-	O
1	int
]	O
+	O
day	int
)	O
;	O
if	O
(	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
&&	O
(	O
month	int
>	O
2	int
)	O
)	O
mjd	long
++	O
;	O
return	O
(	O
(	O
int	O
)	O
(	O
mjd	long
-	O
date2num	(int,int,int)->(long)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
gregorian2julian	(*(int),*(int),*(int))->(void)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
if	O
(	O
*	O
year	int
<	O
greg	*(struct(int,int,int,int))
->	O
year	int
||	O
(	O
(	O
*	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
*	O
month	int
<	O
greg	*(struct(int,int,int,int))
->	O
month	int
||	O
(	O
(	O
*	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
*	O
day	int
<	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
)	O
)	O
)	O
)	O
)	O
{	O
auto	O
Greg_struct	struct(int,int,int,int)
tmp_greg	struct(int,int,int,int)
;	O
auto	O
Ulint	long
mjd	long
;	O
register	O
int	O
diff	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
first_day	int
=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
last_day	int
=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
month	int
=	O
greg	*(struct(int,int,int,int))
->	O
month	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
year	int
=	O
greg	*(struct(int,int,int,int))
->	O
year	int
;	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
=	O
5	int
;	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
=	O
14	int
;	O
greg	*(struct(int,int,int,int))
->	O
month	int
=	O
10	int
;	O
greg	*(struct(int,int,int,int))
->	O
year	int
=	O
1582	int
;	O
mjd	long
=	O
date2num	(int,int,int)->(long)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
;	O
diff	int
=	O
julian_gregorian_diff	(int,int,int)->(int)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
;	O
num2date	(long,*(int),*(int),*(int))->(void)
(	O
mjd	long
-	O
diff	int
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
greg	*(struct(int,int,int,int))
->	O
year	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
year	int
;	O
greg	*(struct(int,int,int,int))
->	O
month	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
month	int
;	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
last_day	int
;	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
first_day	int
;	O
}	O
}	O
static	O
int	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
jd	int
=	O
day_of_year	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
register	O
int	O
sd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
;	O
register	O
int	O
ww	int
;	O
if	O
(	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
month	int
>	O
greg	*(struct(int,int,int,int))
->	O
month	int
||	O
(	O
(	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
day	int
>	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
)	O
)	O
)	O
)	O
jd	int
-=	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
is_iso_week	int
)	O
{	O
if	O
(	O
sd	int
>	O
4	int
)	O
jd	int
-=	O
(	O
(	O
DAY_MAX	int
-	O
sd	int
)	O
+	O
1	int
)	O
;	O
else	O
jd	int
+=	O
(	O
sd	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sd	int
>	O
start_day_of_week	int
)	O
jd	int
-=	O
(	O
DAY_MAX	int
-	O
(	O
sd	int
-	O
start_day_of_week	int
)	O
)	O
;	O
else	O
jd	int
+=	O
(	O
sd	int
-	O
start_day_of_week	int
)	O
;	O
}	O
if	O
(	O
jd	int
>	O
0	int
)	O
ww	int
=	O
(	O
jd	int
-	O
1	int
)	O
/	O
DAY_MAX	int
+	O
1	int
;	O
else	O
ww	int
=	O
raw_week_number	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
return	O
(	O
ww	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dflt_day_name	(int)->(*(char))
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
"invalid day"	*(char)
,	O
"Monday"	*(char)
,	O
"Tuesday"	*(char)
,	O
"Wednesday"	*(char)
,	O
"Thursday"	*(char)
,	O
"Friday"	*(char)
,	O
"Saturday"	*(char)
,	O
"Sunday"	*(char)
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
name	array(*(char))
[	O
0	int
]	O
:	O
name	array(*(char))
[	O
day	int
]	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dflt_month_name	(int)->(*(char))
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array(*(char))
[	O
]	O
=	O
{	O
"invalid month"	*(char)
,	O
"January"	*(char)
,	O
"February"	*(char)
,	O
"March"	*(char)
,	O
"April"	*(char)
,	O
"May"	*(char)
,	O
"June"	*(char)
,	O
"July"	*(char)
,	O
"August"	*(char)
,	O
"September"	*(char)
,	O
"October"	*(char)
,	O
"November"	*(char)
,	O
"December"	*(char)
}	O
;	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
name	array(*(char))
[	O
0	int
]	O
:	O
name	array(*(char))
[	O
month	int
]	O
)	O
;	O
}	O
