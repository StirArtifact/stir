static	O
void	O
set_copypass_perms	(int,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
cpio_file_stat	struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))
header	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
;	O
header	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
.	O
c_name	*(char)
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
stat_to_cpio	(*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
&	O
header	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
set_perms	(int,*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))))->(void)
(	O
fd	int
,	O
&	O
header	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
)	O
;	O
}	O
void	O
process_copy_pass	()->(void)
(	O
)	O
{	O
dynamic_string	struct(int,*(char))
input_name	struct(int,*(char))
;	O
dynamic_string	struct(int,*(char))
output_name	struct(int,*(char))
;	O
size_t	long
dirname_len	long
;	O
int	O
res	int
;	O
char	O
*	O
slash	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
out_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
in_file_des	int
;	O
int	O
out_file_des	int
;	O
int	O
existing_dir	int
;	O
newdir_umask	int
=	O
umask	(int)->(int)
(	O
0	int
)	O
;	O
ds_init	(*(struct(int,*(char))),int)->(void)
(	O
&	O
input_name	struct(int,*(char))
,	O
128	int
)	O
;	O
dirname_len	long
=	O
strlen	(*(char))->(long)
(	O
directory_name	*(char)
)	O
;	O
if	O
(	O
change_directory_option	*(char)
&&	O
!	O
ISSLASH	O
(	O
directory_name	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
pwd	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
dirname_len	long
+=	O
strlen	(*(char))->(long)
(	O
pwd	*(char)
)	O
+	O
1	int
;	O
ds_init	(*(struct(int,*(char))),int)->(void)
(	O
&	O
output_name	struct(int,*(char))
,	O
dirname_len	long
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
pwd	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
directory_name	*(char)
)	O
;	O
}	O
else	O
{	O
ds_init	(*(struct(int,*(char))),int)->(void)
(	O
&	O
output_name	struct(int,*(char))
,	O
dirname_len	long
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
directory_name	*(char)
)	O
;	O
}	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
dirname_len	long
]	O
=	O
'/'	O
;	O
output_is_seekable	char
=	O
true	int
;	O
change_dir	()->(void)
(	O
)	O
;	O
while	O
(	O
ds_fgetstr	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char))),char)->(*(char))
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
input_name	struct(int,*(char))
,	O
name_end	char
)	O
!=	O
NULL	O
)	O
{	O
int	O
link_res	int
=	O
-	O
1	int
;	O
if	O
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"blank line ignored"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
1	int
]	O
==	O
'\0'	O
||	O
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
1	int
]	O
==	O
'/'	O
&&	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
*	O
xstat	*(()->(int))
)	O
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
&	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
stat_error	(*(char))->(void)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
slash	*(char)
=	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
;	O
*	O
slash	*(char)
==	O
'/'	O
;	O
++	O
slash	*(char)
)	O
;	O
ds_resize	(*(struct(int,*(char))),int)->(void)
(	O
&	O
output_name	struct(int,*(char))
,	O
dirname_len	long
+	O
strlen	(*(char))->(long)
(	O
slash	*(char)
)	O
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
+	O
dirname_len	long
+	O
1	int
,	O
slash	*(char)
)	O
;	O
existing_dir	int
=	O
false	int
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
&	O
out_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
out_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
&&	O
S_ISDIR	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
existing_dir	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
!	O
unconditional_flag	int
&&	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
<=	O
out_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s not created: newer or same age version exists"	*(char)
)	O
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
out_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
?	O
rmdir	(*(char))->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
:	O
unlink	(*(char))->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove current %s"	*(char)
)	O
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
S_ISREG	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
link_flag	int
)	O
link_res	int
=	O
link_to_name	(*(char),*(char))->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
if	O
(	O
(	O
link_res	int
<	O
0	int
)	O
&&	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
>	O
1	int
)	O
)	O
link_res	int
=	O
link_to_maj_min_ino	(*(char),int,int,long)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
major	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
,	O
minor	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
)	O
;	O
if	O
(	O
link_res	int
<	O
0	int
)	O
{	O
in_file_des	int
=	O
open	(*(char),int)->(int)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
if	O
(	O
in_file_des	int
<	O
0	int
)	O
{	O
open_error	(*(char))->(void)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
continue	O
;	O
}	O
out_file_des	int
=	O
open	(*(char),int)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
if	O
(	O
out_file_des	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
out_file_des	int
=	O
open	(*(char),int)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
}	O
if	O
(	O
out_file_des	int
<	O
0	int
)	O
{	O
open_error	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
close	(int)->(int)
(	O
in_file_des	int
)	O
;	O
continue	O
;	O
}	O
copy_files_disk_to_disk	(int,int,long,*(char))->(void)
(	O
in_file_des	int
,	O
out_file_des	int
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
disk_empty_output_buffer	(int,bool)->(void)
(	O
out_file_des	int
,	O
true	int
)	O
;	O
set_copypass_perms	(int,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
out_file_des	int
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
&	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
reset_time_flag	int
)	O
{	O
set_file_times	(int,*(char),long,long)->(void)
(	O
in_file_des	int
,	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_atime	O
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
set_file_times	(int,*(char),long,long)->(void)
(	O
out_file_des	int
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_atime	O
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
}	O
if	O
(	O
close	(int)->(int)
(	O
in_file_des	int
)	O
<	O
0	int
)	O
close_error	(*(char))->(void)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
if	O
(	O
close	(int)->(int)
(	O
out_file_des	int
)	O
<	O
0	int
)	O
close_error	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
warn_if_file_changed	(*(char),long,long)->(void)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
struct	O
cpio_file_stat	struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))
file_stat	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
;	O
stat_to_cpio	(*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
&	O
file_stat	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
,	O
&	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
file_stat	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
.	O
c_name	*(char)
=	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
;	O
cpio_create_dir	(*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char))),int)->(int)
(	O
&	O
file_stat	*(struct(short,long,int,int,int,long,long,long,long,long,long,long,long,int,*(char),long,*(char)))
,	O
existing_dir	int
)	O
;	O
}	O
else	O
if	O
(	O
S_ISCHR	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISFIFO	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISSOCK	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
0	int
)	O
{	O
if	O
(	O
link_flag	int
)	O
link_res	int
=	O
link_to_name	(*(char),*(char))->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
if	O
(	O
(	O
link_res	int
<	O
0	int
)	O
&&	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_nlink	long
>	O
1	int
)	O
)	O
link_res	int
=	O
link_to_maj_min_ino	(*(char),int,int,long)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
major	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
,	O
minor	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
)	O
;	O
if	O
(	O
link_res	int
<	O
0	int
)	O
{	O
res	int
=	O
mknod	(*(char),int,long)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_rdev	long
)	O
;	O
if	O
(	O
res	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
res	int
=	O
mknod	(*(char),int,long)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_rdev	long
)	O
;	O
}	O
if	O
(	O
res	int
<	O
0	int
)	O
{	O
mknod_error	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
continue	O
;	O
}	O
set_copypass_perms	(int,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(void)
(	O
-	O
1	int
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
&	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
S_ISLNK	O
(	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
char	O
*	O
link_name	*(char)
;	O
int	O
link_size	int
;	O
link_name	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
(	O
unsigned	O
int	O
)	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
1	int
)	O
;	O
link_size	int
=	O
readlink	(*(char),*(char),long)->(long)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
link_name	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
if	O
(	O
link_size	int
<	O
0	int
)	O
{	O
readlink_error	(*(char))->(void)
(	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
link_name	*(char)
)	O
;	O
continue	O
;	O
}	O
link_name	*(char)
[	O
link_size	int
]	O
=	O
'\0'	O
;	O
res	int
=	O
UMASKED_SYMLINK	O
(	O
link_name	*(char)
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
;	O
if	O
(	O
res	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	(*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
res	int
=	O
UMASKED_SYMLINK	O
(	O
link_name	*(char)
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
;	O
}	O
if	O
(	O
res	int
<	O
0	int
)	O
{	O
symlink_error	(*(char),*(char))->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
link_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
link_name	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
no_chown_flag	int
)	O
{	O
uid_t	int
uid	int
=	O
set_owner_flag	int
?	O
set_owner	int
:	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
;	O
gid_t	int
gid	int
=	O
set_group_flag	int
?	O
set_group	int
:	O
in_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_gid	int
;	O
if	O
(	O
(	O
lchown	(*(char),int,int)->(int)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
uid	int
,	O
gid	int
)	O
<	O
0	int
)	O
&&	O
errno	O
!=	O
EPERM	int
)	O
chown_error_details	(*(char),int,int)->(void)
(	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
,	O
uid	int
,	O
gid	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
link_name	*(char)
)	O
;	O
}	O
else	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: unknown file type"	*(char)
)	O
,	O
input_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
}	O
if	O
(	O
verbose_flag	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
output_name	struct(int,*(char))
.	O
ds_string	*(char)
)	O
;	O
if	O
(	O
dot_flag	int
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'.'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
dot_flag	int
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
apply_delayed_set_stat	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
quiet_flag	int
)	O
{	O
size_t	long
blocks	long
=	O
(	O
output_bytes	long
+	O
io_block_size	int
-	O
1	int
)	O
/	O
io_block_size	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%lu block\n"	*(char)
,	O
"%lu blocks\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
blocks	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
blocks	long
)	O
;	O
}	O
}	O
int	O
link_to_maj_min_ino	(*(char),int,int,long)->(int)
(	O
char	O
*	O
file_name	*(char)
,	O
int	O
st_dev_maj	int
,	O
int	O
st_dev_min	int
,	O
ino_t	long
st_ino	long
)	O
{	O
int	O
link_res	int
;	O
char	O
*	O
link_name	*(char)
;	O
link_res	int
=	O
-	O
1	int
;	O
link_name	*(char)
=	O
find_inode_file	(long,long,long)->(*(char))
(	O
st_ino	long
,	O
st_dev_maj	int
,	O
st_dev_min	int
)	O
;	O
if	O
(	O
link_name	*(char)
==	O
NULL	O
)	O
add_inode	(long,*(char),long,long)->(*(struct))
(	O
st_ino	long
,	O
file_name	*(char)
,	O
st_dev_maj	int
,	O
st_dev_min	int
)	O
;	O
else	O
link_res	int
=	O
link_to_name	(*(char),*(char))->(int)
(	O
file_name	*(char)
,	O
link_name	*(char)
)	O
;	O
return	O
link_res	int
;	O
}	O
int	O
link_to_name	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
link_name	*(char)
,	O
char	O
const	O
*	O
link_target	bool
)	O
{	O
int	O
res	int
=	O
link	(*(char),*(char))->(int)
(	O
link_target	bool
,	O
link_name	*(char)
)	O
;	O
if	O
(	O
res	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	(*(char))->(void)
(	O
link_name	*(char)
)	O
;	O
res	int
=	O
link	(*(char),*(char))->(int)
(	O
link_target	bool
,	O
link_name	*(char)
)	O
;	O
}	O
if	O
(	O
res	int
==	O
0	int
)	O
{	O
if	O
(	O
verbose_flag	int
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s linked to %s"	*(char)
)	O
,	O
link_target	bool
,	O
link_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
link_flag	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot link %s to %s"	*(char)
)	O
,	O
link_target	bool
,	O
link_name	*(char)
)	O
;	O
}	O
return	O
res	int
;	O
}	O
