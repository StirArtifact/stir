extern	O
char	O
*	O
*	O
environ	*(*(char))
;	O
char	O
*	O
rush_config_file	O
=	O
CONFIG_FILE	O
;	O
int	O
lint_option	O
=	O
0	int
;	O
int	O
scanner_test	O
=	O
0	int
;	O
unsigned	O
sleep_time	O
=	O
5	int
;	O
unsigned	O
debug_level	O
;	O
int	O
debug_option	O
;	O
char	O
*	O
dump_option	O
;	O
int	O
parser_traces	O
;	O
struct	O
rush_rule	O
*	O
rule_head	O
,	O
*	O
rule_tail	O
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
rush_pw	O
;	O
struct	O
error_msg	O
{	O
char	O
*	O
text	O
;	O
int	O
custom	O
;	O
}	O
;	O
struct	O
error_msg	O
error_msg	O
[	O
]	O
=	O
{	O
{	O
N_	O
(	O
"You are not permitted to execute this command.\n"	*(char)
"Contact the systems administrator for further assistance.\n"	*(char)
)	O
,	O
}	O
,	O
{	O
N_	O
(	O
"You do not have interactive login access to this machine.\n"	*(char)
"Contact the systems administrator for further assistance.\n"	*(char)
)	O
}	O
,	O
{	O
N_	O
(	O
"Local configuration error occurred.\n"	*(char)
"Contact the systems administrator for further assistance.\n"	*(char)
)	O
}	O
,	O
{	O
N_	O
(	O
"A system error occurred while attempting to execute command.\n"	*(char)
"Contact the systems administrator for further assistance.\n"	*(char)
)	O
}	O
}	O
;	O
void	O
set_error_msg	O
(	O
enum	O
error_type	enum(int,int,int,int)
type	enum(int,int,int,int)
,	O
char	O
*	O
text	O
)	O
{	O
error_msg	O
[	O
type	enum(int,int,int,int)
]	O
.	O
text	O
=	O
text	O
;	O
error_msg	O
[	O
type	enum(int,int,int,int)
]	O
.	O
custom	O
=	O
1	int
;	O
}	O
int	O
string_to_error_index	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
static	O
const	O
char	O
*	O
error_msg_name	O
[	O
]	O
=	O
{	O
[	O
usage_error	int
]	O
=	O
"usage-error"	*(char)
,	O
[	O
nologin_error	int
]	O
=	O
"nologin-error"	*(char)
,	O
[	O
config_error	int
]	O
=	O
"config-error"	*(char)
,	O
[	O
system_error	int
]	O
=	O
"system-error"	*(char)
,	O
NULL	O
}	O
;	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
error_msg_name	O
[	O
i	O
]	O
;	O
i	O
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
error_msg_name	O
[	O
i	O
]	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
i	O
;	O
return	O
-	O
1	int
;	O
}	O
struct	O
rush_error	O
*	O
new_standard_error	O
(	O
int	O
fd	int
,	O
int	O
idx	int
)	O
{	O
struct	O
rush_error	O
*	O
err	long
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
err	long
)	O
)	O
;	O
err	long
->	O
fd	int
=	O
fd	int
;	O
err	long
->	O
idx	int
=	O
idx	int
;	O
return	O
err	long
;	O
}	O
static	O
inline	O
char	O
*	O
error_text_ptr	O
(	O
struct	O
rush_error	O
const	O
*	O
err	long
)	O
{	O
return	O
(	O
char	O
*	O
)	O
(	O
err	long
+	O
1	int
)	O
;	O
}	O
struct	O
rush_error	O
*	O
new_error	O
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
text	O
,	O
int	O
unescape	O
)	O
{	O
struct	O
rush_error	O
*	O
err	long
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
text	O
)	O
;	O
int	O
add_nl	O
=	O
len	long
>	O
0	int
&&	O
text	O
[	O
len	long
-	O
1	int
]	O
!=	O
'\n'	O
;	O
int	O
c	int
;	O
char	O
*	O
p	*(void)
;	O
err	long
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
err	long
)	O
+	O
strlen	(*(char))->(long)
(	O
text	O
)	O
+	O
(	O
add_nl	O
?	O
1	int
:	O
0	int
)	O
+	O
1	int
)	O
;	O
err	long
->	O
fd	int
=	O
fd	int
;	O
err	long
->	O
idx	int
=	O
-	O
1	int
;	O
p	*(void)
=	O
error_text_ptr	O
(	O
err	long
)	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
text	O
++	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
unescape	O
&&	O
c	int
==	O
'\\'	O
&&	O
*	O
text	O
)	O
{	O
int	O
c1	O
=	O
wordsplit_c_unquote_char	(int)->(int)
(	O
*	O
text	O
)	O
;	O
if	O
(	O
c1	O
)	O
c	int
=	O
c1	O
;	O
else	O
c	int
=	O
*	O
text	O
;	O
text	O
++	O
;	O
}	O
*	O
p	*(void)
++	O
=	O
c	int
;	O
}	O
if	O
(	O
add_nl	O
)	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
return	O
err	long
;	O
}	O
char	O
const	O
*	O
rush_error_msg	O
(	O
struct	O
rush_error	O
const	O
*	O
err	long
,	O
struct	O
rush_i18n	O
const	O
*	O
i18n	O
)	O
{	O
const	O
char	O
*	O
msg	*(char)
;	O
if	O
(	O
err	long
->	O
idx	int
>=	O
0	int
)	O
{	O
msg	*(char)
=	O
error_msg	O
[	O
err	long
->	O
idx	int
]	O
.	O
text	O
;	O
if	O
(	O
error_msg	O
[	O
err	long
->	O
idx	int
]	O
.	O
custom	O
)	O
{	O
if	O
(	O
i18n	O
)	O
msg	*(char)
=	O
user_gettext	(*(char),*(char),*(char),*(char))->(*(char))
(	O
i18n	O
->	O
locale	*(char)
,	O
i18n	O
->	O
text_domain	O
,	O
i18n	O
->	O
localedir	O
,	O
msg	*(char)
)	O
;	O
}	O
else	O
msg	*(char)
=	O
gettext	(*(char))->(*(char))
(	O
msg	*(char)
)	O
;	O
}	O
else	O
msg	*(char)
=	O
gettext	(*(char))->(*(char))
(	O
error_text_ptr	O
(	O
err	long
)	O
)	O
;	O
return	O
msg	*(char)
;	O
}	O
void	O
send_msg	O
(	O
const	O
char	O
*	O
msg	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
STDERR_FILENO	O
,	O
msg	*(char)
,	O
len	long
)	O
<	O
0	int
)	O
{	O
logmsg	O
(	O
LOG_ERR	O
,	O
_	O
(	O
"failed to write message to stderr: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
STDOUT_FILENO	O
,	O
msg	*(char)
,	O
len	long
)	O
<	O
0	int
)	O
logmsg	O
(	O
LOG_ERR	O
,	O
_	O
(	O
"failed to write message to stdout: %s"	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
void	O
vlogmsg	O
(	O
int	O
prio	O
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
)	O
{	O
if	O
(	O
lint_option	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
switch	O
(	O
prio	O
)	O
{	O
case	O
LOG_DEBUG	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Debug: "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
LOG_INFO	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Info: "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
LOG_NOTICE	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Notice: "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
LOG_WARNING	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Warning: "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
LOG_ERR	O
:	O
case	O
LOG_CRIT	O
:	O
case	O
LOG_ALERT	O
:	O
case	O
LOG_EMERG	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Error: "	*(char)
)	O
)	O
;	O
}	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
vsyslog	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
prio	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
}	O
void	O
logmsg	O
(	O
int	O
prio	O
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
vlogmsg	O
(	O
prio	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
void	O
die	O
(	O
enum	O
error_type	enum(int,int,int,int)
type	enum(int,int,int,int)
,	O
struct	O
rush_i18n	O
*	O
i18n	O
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
fmt	*(char)
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
vlogmsg	O
(	O
LOG_ERR	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
if	O
(	O
!	O
lint_option	O
)	O
{	O
const	O
char	O
*	O
msg	*(char)
=	O
error_msg	O
[	O
type	enum(int,int,int,int)
]	O
.	O
text	O
;	O
if	O
(	O
error_msg	O
[	O
type	enum(int,int,int,int)
]	O
.	O
custom	O
)	O
{	O
if	O
(	O
i18n	O
)	O
msg	*(char)
=	O
user_gettext	(*(char),*(char),*(char),*(char))->(*(char))
(	O
i18n	O
->	O
locale	*(char)
,	O
i18n	O
->	O
text_domain	O
,	O
i18n	O
->	O
localedir	O
,	O
msg	*(char)
)	O
;	O
}	O
else	O
msg	*(char)
=	O
gettext	(*(char))->(*(char))
(	O
msg	*(char)
)	O
;	O
send_msg	O
(	O
msg	*(char)
,	O
strlen	(*(char))->(long)
(	O
msg	*(char)
)	O
)	O
;	O
sleep	(int)->(int)
(	O
sleep_time	O
)	O
;	O
}	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
die_usage	O
(	O
struct	O
cfloc	O
const	O
*	O
loc	O
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
vcferror	O
(	O
loc	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
die	O
(	O
usage_error	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
xalloc_die	()->(void)
(	O
)	O
{	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"Not enough memory"	*(char)
)	O
)	O
;	O
}	O
static	O
rush_bool_t	O
eval_cmpn	O
(	O
struct	O
test_node	O
*	O
node	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
char	O
*	O
str	*(char)
=	O
rush_expand_string	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
req	O
)	O
;	O
char	O
*	O
p	*(void)
;	O
unsigned	O
long	O
n	long
;	O
errno	O
=	O
0	int
;	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
p	*(void)
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
||	O
*	O
p	*(void)
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"%s: not a number"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
switch	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
cmp_eq	int
:	O
return	O
n	long
==	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
case	O
cmp_ne	int
:	O
return	O
n	long
!=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
case	O
cmp_lt	int
:	O
return	O
n	long
<	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
case	O
cmp_le	int
:	O
return	O
n	long
<=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
case	O
cmp_gt	int
:	O
return	O
n	long
>	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
case	O
cmp_ge	int
:	O
return	O
n	long
>=	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
num	long
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized opcode %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
)	O
;	O
}	O
}	O
static	O
int	O
eval_regex	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
char	O
const	O
*	O
subj	O
)	O
{	O
int	O
rc	O
;	O
struct	O
rush_backref	O
*	O
bref	O
=	O
&	O
req	O
->	O
backref	O
[	O
!	O
req	O
->	O
backref_cur	O
]	O
;	O
size_t	long
n	long
=	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
->	O
re_nsub	long
+	O
1	int
;	O
if	O
(	O
n	long
>	O
bref	O
->	O
maxmatch	O
)	O
{	O
bref	O
->	O
match	O
=	O
xrealloc	(*(void),long)->(*(void))
(	O
bref	O
->	O
match	O
,	O
sizeof	O
(	O
bref	O
->	O
match	O
[	O
0	int
]	O
)	O
*	O
n	long
)	O
;	O
bref	O
->	O
maxmatch	O
=	O
n	long
;	O
}	O
rc	O
=	O
regexec	O
(	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
subj	O
,	O
bref	O
->	O
maxmatch	O
,	O
bref	O
->	O
match	O
,	O
0	int
)	O
;	O
if	O
(	O
rc	O
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
bref	O
->	O
subject	O
)	O
;	O
bref	O
->	O
subject	O
=	O
xstrdup	(*(char))->(*(char))
(	O
subj	O
)	O
;	O
bref	O
->	O
nmatch	O
=	O
n	long
;	O
req	O
->	O
backref_cur	O
=	O
!	O
req	O
->	O
backref_cur	O
;	O
}	O
return	O
rc	O
;	O
}	O
static	O
rush_bool_t	O
eval_cmps	O
(	O
struct	O
test_node	O
*	O
node	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
char	O
*	O
str	*(char)
=	O
rush_expand_string	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
req	O
)	O
;	O
rush_bool_t	O
res	O
=	O
rush_false	O
;	O
switch	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
cmp_eq	int
:	O
res	O
=	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
str	*(char)
)	O
==	O
0	int
;	O
break	O
;	O
case	O
cmp_ne	int
:	O
res	O
=	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
str	*(char)
)	O
!=	O
0	int
;	O
break	O
;	O
case	O
cmp_match	int
:	O
res	O
=	O
!	O
eval_regex	O
(	O
req	O
,	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
rx	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
str	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized opcode %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
op	enum(int,int,int,int,int,int,int,int)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
return	O
res	O
;	O
}	O
static	O
rush_bool_t	O
eval_in	O
(	O
struct	O
test_node	O
*	O
node	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
size_t	long
i	O
;	O
rush_bool_t	O
res	O
=	O
rush_false	O
;	O
char	O
*	O
str	*(char)
=	O
rush_expand_string	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
larg	*(char)
,	O
req	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
cmp	struct(enum(int,int,int,int,int,int,int,int),*(char),union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long))
.	O
rarg	union(*(char),*(*(char)),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),long)
.	O
strv	*(*(char))
[	O
i	O
]	O
)	O
==	O
0	int
)	O
{	O
res	O
=	O
rush_true	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
str	*(char)
)	O
;	O
return	O
res	O
;	O
}	O
static	O
rush_bool_t	O
groupmember	O
(	O
char	O
const	O
*	O
gname	O
,	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
const	O
*	O
pw	O
)	O
{	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grp	O
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
gname	O
)	O
;	O
if	O
(	O
grp	O
)	O
{	O
char	O
*	O
*	O
p	*(void)
;	O
if	O
(	O
pw	O
->	O
pw_gid	int
==	O
grp	O
->	O
gr_gid	int
)	O
return	O
rush_true	O
;	O
for	O
(	O
p	*(void)
=	O
grp	O
->	O
gr_mem	*(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
p	*(void)
,	O
pw	O
->	O
pw_name	*(char)
)	O
==	O
0	int
)	O
return	O
rush_true	O
;	O
}	O
}	O
return	O
rush_false	O
;	O
}	O
static	O
rush_bool_t	O
eval_member	O
(	O
struct	O
test_node	O
*	O
node	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
size_t	long
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
groupmember	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
groups	*(*(char))
[	O
i	O
]	O
,	O
req	O
->	O
pw	O
)	O
)	O
return	O
rush_true	O
;	O
}	O
return	O
rush_false	O
;	O
}	O
rush_bool_t	O
test_eval	O
(	O
struct	O
test_node	O
*	O
node	O
,	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
switch	O
(	O
node	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
test_cmpn	int
:	O
return	O
eval_cmpn	O
(	O
node	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_cmps	int
:	O
return	O
eval_cmps	O
(	O
node	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_in	int
:	O
return	O
eval_in	O
(	O
node	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_group	int
:	O
return	O
eval_member	O
(	O
node	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_and	int
:	O
if	O
(	O
!	O
test_eval	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
,	O
rule	*(char)
,	O
req	O
)	O
)	O
return	O
0	int
;	O
return	O
test_eval	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_or	int
:	O
if	O
(	O
test_eval	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
,	O
rule	*(char)
,	O
req	O
)	O
)	O
return	O
1	int
;	O
return	O
test_eval	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
1	int
]	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
case	O
test_not	int
:	O
return	O
!	O
test_eval	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
[	O
0	int
]	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized node type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	O
->	O
type	enum(int,int,int,int)
)	O
;	O
}	O
}	O
char	O
*	O
make_file_name	O
(	O
const	O
char	O
*	O
dir	enum(int,int)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
size_t	long
dlen	O
=	O
strlen	(*(char))->(long)
(	O
dir	enum(int,int)
)	O
;	O
size_t	long
len	long
=	O
dlen	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
;	O
char	O
*	O
res	O
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
res	O
,	O
dir	enum(int,int)
)	O
;	O
if	O
(	O
dlen	O
>	O
0	int
&&	O
res	O
[	O
dlen	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
res	O
[	O
dlen	O
++	O
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
res	O
+	O
dlen	O
,	O
name	*(char)
)	O
;	O
return	O
res	O
;	O
}	O
char	O
*	O
expand_tilde	O
(	O
const	O
char	O
*	O
dir	enum(int,int)
,	O
const	O
char	O
*	O
home	O
)	O
{	O
char	O
*	O
res	O
;	O
if	O
(	O
dir	enum(int,int)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dir	enum(int,int)
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
size_t	long
hlen	O
=	O
strlen	(*(char))->(long)
(	O
home	O
)	O
;	O
size_t	long
len	long
=	O
hlen	O
+	O
strlen	(*(char))->(long)
(	O
dir	enum(int,int)
+	O
1	int
)	O
;	O
res	O
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
res	O
,	O
home	O
)	O
;	O
if	O
(	O
hlen	O
>	O
0	int
&&	O
res	O
[	O
hlen	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
res	O
[	O
hlen	O
++	O
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
res	O
+	O
hlen	O
,	O
dir	enum(int,int)
+	O
2	int
)	O
;	O
}	O
else	O
res	O
=	O
xstrdup	(*(char))->(*(char))
(	O
home	O
)	O
;	O
}	O
else	O
res	O
=	O
xstrdup	(*(char))->(*(char))
(	O
dir	enum(int,int)
)	O
;	O
return	O
res	O
;	O
}	O
char	O
*	O
expand_dir	O
(	O
const	O
char	O
*	O
dir	enum(int,int)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
char	O
*	O
exp	O
=	O
rush_expand_string	O
(	O
dir	enum(int,int)
,	O
req	O
)	O
;	O
if	O
(	O
exp	O
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
char	O
*	O
t	O
=	O
expand_tilde	O
(	O
exp	O
,	O
req	O
->	O
pw	O
->	O
pw_dir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
exp	O
)	O
;	O
exp	O
=	O
t	O
;	O
}	O
return	O
exp	O
;	O
}	O
void	O
request_set_env	O
(	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
size_t	long
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
environ	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
;	O
req	O
->	O
env_count	O
=	O
i	O
;	O
req	O
->	O
env_max	O
=	O
i	O
+	O
1	int
;	O
req	O
->	O
env	O
=	O
xcalloc	(long,long)->(*(void))
(	O
req	O
->	O
env_max	O
,	O
sizeof	O
(	O
req	O
->	O
env	O
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
req	O
->	O
env_count	O
;	O
i	O
++	O
)	O
req	O
->	O
env	O
[	O
i	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
environ	*(*(char))
[	O
i	O
]	O
)	O
;	O
req	O
->	O
env	O
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
static	O
ssize_t	long
getenvind	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
char	O
const	O
*	O
name	*(char)
,	O
char	O
*	O
*	O
pval	O
)	O
{	O
size_t	long
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
req	O
->	O
env_count	O
;	O
i	O
++	O
)	O
{	O
char	O
const	O
*	O
p	*(void)
;	O
char	O
*	O
q	O
;	O
for	O
(	O
p	*(void)
=	O
name	*(char)
,	O
q	O
=	O
req	O
->	O
env	O
[	O
i	O
]	O
;	O
*	O
p	*(void)
==	O
*	O
q	O
;	O
p	*(void)
++	O
,	O
q	O
++	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
&&	O
*	O
q	O
==	O
'='	O
)	O
{	O
if	O
(	O
pval	O
)	O
*	O
pval	O
=	O
q	O
+	O
1	int
;	O
return	O
i	O
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
enum	O
rush_three_state	O
envarmatch	O
(	O
struct	O
envar	O
*	O
ev	O
,	O
char	O
const	O
*	O
var	*(char)
,	O
int	O
len	long
)	O
{	O
if	O
(	O
ev	O
->	O
value	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
ev	O
->	O
name	*(char)
,	O
var	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
var	*(char)
+	O
len	long
+	O
1	int
,	O
ev	O
->	O
value	O
)	O
==	O
0	int
?	O
rush_true	O
:	O
rush_false	O
;	O
}	O
}	O
else	O
if	O
(	O
wildmatch	(*(char),*(char),long)->(int)
(	O
ev	O
->	O
name	*(char)
,	O
var	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
rush_true	O
;	O
}	O
return	O
rush_undefined	O
;	O
}	O
static	O
rush_bool_t	O
keep_envar	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
var	*(char)
)	O
{	O
struct	O
envar	O
*	O
ev	O
;	O
int	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
var	*(char)
,	O
"="	*(char)
)	O
;	O
for	O
(	O
ev	O
=	O
rule	*(char)
->	O
envar_head	O
;	O
ev	O
;	O
ev	O
=	O
ev	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
if	O
(	O
ev	O
->	O
type	enum(int,int,int,int)
==	O
envar_keep	O
)	O
{	O
enum	O
rush_three_state	O
res	O
=	O
envarmatch	O
(	O
ev	O
,	O
var	*(char)
,	O
len	long
)	O
;	O
switch	O
(	O
res	O
)	O
{	O
case	O
rush_true	O
:	O
case	O
rush_false	O
:	O
return	O
res	O
;	O
case	O
rush_undefined	O
:	O
break	O
;	O
}	O
}	O
}	O
return	O
rush_false	O
;	O
}	O
static	O
void	O
unset_envar	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
struct	O
envar	O
*	O
ev	O
)	O
{	O
size_t	long
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
req	O
->	O
env_count	O
;	O
)	O
{	O
int	O
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
req	O
->	O
env	O
[	O
i	O
]	O
,	O
"="	*(char)
)	O
;	O
if	O
(	O
envarmatch	O
(	O
ev	O
,	O
req	O
->	O
env	O
[	O
i	O
]	O
,	O
len	long
)	O
==	O
rush_true	O
)	O
{	O
free	(*(void))->(void)
(	O
req	O
->	O
env	O
[	O
i	O
]	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
req	O
->	O
env	O
+	O
i	O
,	O
req	O
->	O
env	O
+	O
i	O
+	O
1	int
,	O
(	O
req	O
->	O
env_count	O
-	O
i	O
)	O
*	O
sizeof	O
(	O
req	O
->	O
env	O
[	O
0	int
]	O
)	O
)	O
;	O
req	O
->	O
env_count	O
--	O
;	O
}	O
else	O
i	O
++	O
;	O
}	O
}	O
static	O
void	O
env_setup	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
struct	O
envar	O
*	O
ev	O
;	O
size_t	long
i	O
;	O
if	O
(	O
rule	*(char)
->	O
clrenv	O
)	O
{	O
size_t	long
keep_count	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
req	O
->	O
env_count	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
keep_envar	O
(	O
rule	*(char)
,	O
req	O
->	O
env	O
[	O
i	O
]	O
)	O
)	O
{	O
if	O
(	O
i	O
>	O
keep_count	O
)	O
{	O
req	O
->	O
env	O
[	O
keep_count	O
]	O
=	O
req	O
->	O
env	O
[	O
i	O
]	O
;	O
req	O
->	O
env	O
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
keep_count	O
++	O
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
req	O
->	O
env	O
[	O
i	O
]	O
)	O
;	O
req	O
->	O
env	O
[	O
i	O
]	O
=	O
NULL	O
;	O
}	O
}	O
req	O
->	O
env_count	O
=	O
keep_count	O
;	O
}	O
for	O
(	O
ev	O
=	O
rule	*(char)
->	O
envar_head	O
;	O
ev	O
;	O
ev	O
=	O
ev	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
char	O
*	O
val	array(int)
;	O
ssize_t	long
n	long
;	O
size_t	long
len	long
;	O
switch	O
(	O
ev	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
envar_keep	O
:	O
break	O
;	O
case	O
envar_unset	O
:	O
unset_envar	O
(	O
req	O
,	O
ev	O
)	O
;	O
break	O
;	O
case	O
envar_set	O
:	O
val	array(int)
=	O
rush_expand_string	O
(	O
ev	O
->	O
value	O
,	O
req	O
)	O
;	O
n	long
=	O
getenvind	O
(	O
req	O
,	O
ev	O
->	O
name	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
req	O
->	O
env_count	O
+	O
1	int
>=	O
req	O
->	O
env_max	O
)	O
req	O
->	O
env	O
=	O
x2nrealloc	(*(void),*(long),long)->(*(void))
(	O
req	O
->	O
env	O
,	O
&	O
req	O
->	O
env_max	O
,	O
sizeof	O
(	O
req	O
->	O
env	O
[	O
0	int
]	O
)	O
)	O
;	O
n	long
=	O
req	O
->	O
env_count	O
++	O
;	O
req	O
->	O
env	O
[	O
req	O
->	O
env_count	O
]	O
=	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
req	O
->	O
env	O
[	O
n	long
]	O
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
ev	O
->	O
name	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
val	array(int)
)	O
+	O
2	int
;	O
req	O
->	O
env	O
[	O
n	long
]	O
=	O
xmalloc	(long)->(*(void))
(	O
len	long
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
strcat	(*(char),*(char))->(*(char))
(	O
strcpy	(*(char),*(char))->(*(char))
(	O
req	O
->	O
env	O
[	O
n	long
]	O
,	O
ev	O
->	O
name	*(char)
)	O
,	O
"="	*(char)
)	O
,	O
val	array(int)
)	O
;	O
free	(*(void))->(void)
(	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
envar_eval	O
:	O
free	(*(void))->(void)
(	O
rush_expand_string	O
(	O
ev	O
->	O
value	O
,	O
req	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid envar type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
ev	O
->	O
type	enum(int,int,int,int)
)	O
;	O
}	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
_	O
(	O
"Final environment:"	*(char)
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
req	O
->	O
env	O
[	O
i	O
]	O
;	O
i	O
++	O
)	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
"%4zu: %s"	*(char)
,	O
i	O
,	O
req	O
->	O
env	O
[	O
i	O
]	O
)	O
;	O
}	O
}	O
static	O
void	O
reparse_cmdline	O
(	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
argcv_free	(int,*(*(char)))->(void)
(	O
req	O
->	O
argc	int
,	O
req	O
->	O
argv	*(*(char))
)	O
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_options	int
=	O
WRDSO_NOVARSPLIT	O
|	O
WRDSO_NOCMDSPLIT	O
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
req	O
->	O
cmdline	O
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_OPTIONS	O
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"wordsplit(%s) failed: %s"	*(char)
)	O
,	O
req	O
->	O
cmdline	O
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
wordsplit_get_words	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)),*(long),*(*(*(char))))->(int)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
&	O
req	O
->	O
argc	int
,	O
&	O
req	O
->	O
argv	*(*(char))
)	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
free	(*(void))->(void)
(	O
req	O
->	O
prog	O
)	O
;	O
req	O
->	O
prog	O
=	O
NULL	O
;	O
}	O
static	O
void	O
rebuild_cmdline	O
(	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
free	(*(void))->(void)
(	O
req	O
->	O
cmdline	O
)	O
;	O
req	O
->	O
cmdline	O
=	O
argcv_string	(int,*(*(char)))->(*(char))
(	O
req	O
->	O
argc	int
,	O
req	O
->	O
argv	*(*(char))
)	O
;	O
}	O
static	O
int	O
get_arg_no	O
(	O
int	O
index	(*(char),int)->(*(char))
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
int	O
arg_no	O
=	O
ARG_NO	O
(	O
index	(*(char),int)->(*(char))
,	O
req	O
->	O
argc	int
)	O
;	O
if	O
(	O
arg_no	O
<	O
0	int
||	O
arg_no	O
>	O
req	O
->	O
argc	int
)	O
die	O
(	O
config_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"no argument at index %d in command: %s"	*(char)
)	O
,	O
index	(*(char),int)->(*(char))
,	O
req	O
->	O
cmdline	O
)	O
;	O
return	O
arg_no	O
;	O
}	O
static	O
int	O
remove_optarg	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
struct	O
option_defn	struct(*(char),*(char))
*	O
opt	O
,	O
size_t	long
n	long
,	O
char	O
*	O
tail	O
)	O
{	O
size_t	long
c	int
;	O
if	O
(	O
opt	O
->	O
s_opt	*(char)
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
if	O
(	O
*	O
tail	O
)	O
c	int
=	O
1	int
;	O
else	O
if	O
(	O
opt	O
->	O
s_opt	*(char)
[	O
2	int
]	O
==	O
':'	O
)	O
c	int
=	O
1	int
;	O
else	O
c	int
=	O
2	int
;	O
}	O
else	O
c	int
=	O
1	int
;	O
if	O
(	O
n	long
+	O
c	int
<	O
req	O
->	O
argc	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
&	O
req	O
->	O
argv	*(*(char))
[	O
n	long
]	O
,	O
&	O
req	O
->	O
argv	*(*(char))
[	O
n	long
+	O
c	int
]	O
,	O
(	O
req	O
->	O
argc	int
-	O
n	long
+	O
1	int
-	O
c	int
)	O
*	O
sizeof	O
req	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
req	O
->	O
argc	int
-=	O
c	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
remove_option	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
struct	O
option_defn	struct(*(char),*(char))
*	O
opt	O
)	O
{	O
size_t	long
i	O
;	O
size_t	long
l_len	long
=	O
opt	O
->	O
l_opt	*(char)
?	O
strlen	(*(char))->(long)
(	O
opt	O
->	O
l_opt	*(char)
)	O
:	O
0	int
;	O
int	O
mod	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
req	O
->	O
argc	int
;	O
i	O
++	O
)	O
{	O
char	O
*	O
arg	struct(int,int)
=	O
req	O
->	O
argv	*(*(char))
[	O
i	O
]	O
;	O
if	O
(	O
*	O
arg	struct(int,int)
==	O
'-'	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
++	O
arg	struct(int,int)
;	O
if	O
(	O
*	O
arg	struct(int,int)
==	O
'-'	O
)	O
{	O
size_t	long
a_len	O
;	O
++	O
arg	struct(int,int)
;	O
if	O
(	O
*	O
arg	struct(int,int)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
opt	O
->	O
l_opt	*(char)
==	O
NULL	O
)	O
continue	O
;	O
a_len	O
=	O
strcspn	(*(char),*(char))->(long)
(	O
arg	struct(int,int)
,	O
"="	*(char)
)	O
;	O
if	O
(	O
l_len	long
<	O
a_len	O
)	O
continue	O
;	O
if	O
(	O
arg	struct(int,int)
[	O
a_len	O
]	O
==	O
'='	O
&&	O
opt	O
->	O
s_opt	*(char)
[	O
1	int
]	O
!=	O
':'	O
)	O
continue	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
arg	struct(int,int)
,	O
opt	O
->	O
l_opt	*(char)
,	O
a_len	O
)	O
)	O
continue	O
;	O
p	*(void)
=	O
arg	struct(int,int)
+	O
a_len	O
;	O
}	O
else	O
if	O
(	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
arg	struct(int,int)
,	O
opt	O
->	O
s_opt	*(char)
[	O
0	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
opt	O
->	O
s_opt	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
p	*(void)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
p	*(void)
+	O
1	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
*	O
arg	struct(int,int)
)	O
{	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
p	*(void)
>	O
arg	struct(int,int)
)	O
{	O
if	O
(	O
p	*(void)
[	O
1	int
]	O
||	O
opt	O
->	O
s_opt	*(char)
[	O
2	int
]	O
==	O
':'	O
)	O
*	O
p	*(void)
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
continue	O
;	O
}	O
if	O
(	O
remove_optarg	O
(	O
req	O
,	O
opt	O
,	O
i	O
,	O
p	*(void)
+	O
1	int
)	O
)	O
{	O
i	O
--	O
;	O
mod	O
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
mod	O
)	O
rebuild_cmdline	O
(	O
req	O
)	O
;	O
}	O
static	O
void	O
rush_transform	O
(	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
char	O
*	O
*	O
target_ptr	O
;	O
char	O
*	O
target_src	O
;	O
char	O
*	O
newval	O
=	O
NULL	O
;	O
int	O
arg_no	O
;	O
void	O
(	O
*	O
postprocess	O
)	O
(	O
struct	O
rush_request	O
*	O
)	O
=	O
NULL	O
;	O
if	O
(	O
node	O
->	O
type	enum(int,int,int,int)
==	O
transform_remopt	int
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Removing option %s %s"	*(char)
)	O
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
.	O
s_opt	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
.	O
l_opt	*(char)
?	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
.	O
l_opt	*(char)
:	O
"(null)"	*(char)
)	O
;	O
remove_option	O
(	O
req	O
,	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
remopt	struct(*(char),*(char))
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
target_command	int
:	O
target_ptr	O
=	O
&	O
req	O
->	O
cmdline	O
;	O
target_src	O
=	O
req	O
->	O
cmdline	O
;	O
postprocess	O
=	O
reparse_cmdline	O
;	O
debug	O
(	O
2	int
,	O
"%s"	*(char)
,	O
_	O
(	O
"Transforming command line"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
target_program	int
:	O
target_ptr	O
=	O
&	O
req	O
->	O
prog	O
;	O
target_src	O
=	O
PROGFILE	O
(	O
req	O
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming program name (%s)"	*(char)
)	O
,	O
target_src	O
)	O
;	O
break	O
;	O
case	O
target_arg	int
:	O
arg_no	O
=	O
get_arg_no	O
(	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
,	O
req	O
)	O
;	O
if	O
(	O
arg_no	O
==	O
req	O
->	O
argc	int
||	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
ins	int
)	O
{	O
req	O
->	O
argv	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
req	O
->	O
argv	*(*(char))
,	O
(	O
req	O
->	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
req	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
req	O
->	O
argc	int
++	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
&	O
req	O
->	O
argv	*(*(char))
[	O
arg_no	O
+	O
1	int
]	O
,	O
&	O
req	O
->	O
argv	*(*(char))
[	O
arg_no	O
]	O
,	O
(	O
req	O
->	O
argc	int
-	O
arg_no	O
)	O
*	O
sizeof	O
req	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
req	O
->	O
argv	*(*(char))
[	O
arg_no	O
]	O
=	O
NULL	O
;	O
}	O
target_ptr	O
=	O
&	O
req	O
->	O
argv	*(*(char))
[	O
arg_no	O
]	O
;	O
target_src	O
=	O
req	O
->	O
argv	*(*(char))
[	O
arg_no	O
]	O
;	O
postprocess	O
=	O
rebuild_cmdline	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming argv[%d]"	*(char)
)	O
,	O
arg_no	O
)	O
;	O
break	O
;	O
case	O
target_var	int
:	O
target_ptr	O
=	O
rush_getvarptr	O
(	O
req	O
,	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
)	O
;	O
target_src	O
=	O
*	O
target_ptr	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming variable %s=%s"	*(char)
)	O
,	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
,	O
target_src	O
?	O
target_src	O
:	O
"(null)"	*(char)
)	O
;	O
break	O
;	O
case	O
target_env	int
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"environment transformation is not yet implemented"	*(char)
)	O
)	O
;	O
case	O
target_readonly	int
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: can't modify read-only target"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
switch	O
(	O
node	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
transform_set	int
:	O
if	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
)	O
{	O
newval	O
=	O
rush_expand_string	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
pattern	*(char)
,	O
req	O
)	O
;	O
target_src	O
=	O
newval	O
;	O
}	O
if	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
)	O
{	O
char	O
*	O
p	*(void)
=	O
transform_string	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
xf	struct(*(char),*(struct))
.	O
trans	*(struct)
,	O
target_src	O
)	O
;	O
free	(*(void))->(void)
(	O
newval	O
)	O
;	O
newval	O
=	O
p	*(void)
;	O
}	O
break	O
;	O
case	O
transform_map	int
:	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transformation map: %s, %s, %s, %u, %u, %s"	*(char)
)	O
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
file	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
delim	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key	*(char)
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
key_field	int
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
val_field	int
,	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
.	O
defval	*(char)
)	O
;	O
newval	O
=	O
map_string	O
(	O
&	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
map	struct(*(char),*(char),*(char),int,int,*(char))
,	O
req	O
)	O
;	O
if	O
(	O
!	O
newval	O
)	O
return	O
;	O
break	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid node type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	O
->	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
*	O
target_ptr	O
)	O
;	O
*	O
target_ptr	O
=	O
newval	O
;	O
if	O
(	O
postprocess	O
)	O
postprocess	O
(	O
req	O
)	O
;	O
}	O
static	O
void	O
rush_transform_delete	O
(	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
int	O
arg_no	O
,	O
arg_end	int
,	O
i	O
;	O
switch	O
(	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
target_arg	int
:	O
arg_no	O
=	O
get_arg_no	O
(	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
arg	struct(int,int)
.	O
idx	int
,	O
req	O
)	O
;	O
arg_end	int
=	O
get_arg_no	O
(	O
node	O
->	O
v	union(*(char),struct(int,int))
.	O
arg_end	int
,	O
req	O
)	O
;	O
if	O
(	O
arg_end	int
<	O
arg_no	O
)	O
{	O
int	O
x	O
=	O
arg_end	int
;	O
arg_end	int
=	O
arg_no	O
;	O
arg_no	O
=	O
x	O
;	O
}	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Deleting arguments %d-%d"	*(char)
)	O
,	O
arg_no	O
,	O
arg_end	int
)	O
;	O
if	O
(	O
arg_no	O
==	O
0	int
||	O
arg_end	int
==	O
0	int
)	O
die	O
(	O
config_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"Deleting argv[0] is prohibited"	*(char)
)	O
)	O
;	O
for	O
(	O
i	O
=	O
arg_no	O
;	O
i	O
<=	O
arg_end	int
;	O
i	O
++	O
)	O
free	(*(void))->(void)
(	O
req	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
i	O
=	O
arg_end	int
-	O
arg_no	O
+	O
1	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
req	O
->	O
argv	*(*(char))
+	O
arg_no	O
,	O
req	O
->	O
argv	*(*(char))
+	O
arg_end	int
+	O
1	int
,	O
(	O
req	O
->	O
argc	int
-	O
i	O
)	O
*	O
sizeof	O
(	O
req	O
->	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
req	O
->	O
argc	int
-=	O
i	O
;	O
rebuild_cmdline	O
(	O
req	O
)	O
;	O
break	O
;	O
case	O
target_var	int
:	O
rush_request_delvar	O
(	O
req	O
,	O
node	O
->	O
target	struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int)))
.	O
v	union(*(char),struct(int,int))
.	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
target_env	int
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"environment transformation is not yet implemented"	*(char)
)	O
)	O
;	O
default	O
:	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid target type %d"	*(char)
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	O
->	O
type	enum(int,int,int,int)
)	O
;	O
}	O
}	O
static	O
void	O
run_transforms	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
struct	O
transform_node	struct(*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char))))
*	O
node	O
;	O
for	O
(	O
node	O
=	O
rule	*(char)
->	O
transform_head	O
;	O
node	O
;	O
node	O
=	O
node	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
if	O
(	O
node	O
->	O
type	enum(int,int,int,int)
==	O
transform_delete	int
)	O
rush_transform_delete	O
(	O
node	O
,	O
req	O
)	O
;	O
else	O
rush_transform	O
(	O
node	O
,	O
req	O
)	O
;	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
int	O
i	O
;	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
_	O
(	O
"Program name: %s"	*(char)
)	O
,	O
PROGFILE	O
(	O
req	O
)	O
)	O
;	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
_	O
(	O
"Final arguments:"	*(char)
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
req	O
->	O
argc	int
;	O
i	O
++	O
)	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
"% 4d: %s"	*(char)
,	O
i	O
,	O
req	O
->	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
}	O
}	O
static	O
void	O
acct_on	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
,	O
pid_t	int
pid	int
)	O
{	O
struct	O
rush_wtmp	struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char))
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
;	O
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
.	O
pid	int
=	O
pid	int
;	O
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
.	O
user	*(char)
=	O
req	O
->	O
pw	O
->	O
pw_name	*(char)
;	O
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
.	O
rule	*(char)
=	O
rule	*(char)
->	O
tag	O
;	O
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
.	O
command	*(char)
=	O
req	O
->	O
cmdline	O
;	O
if	O
(	O
rushdb_start	(*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char))))->(int)
(	O
&	O
wtmp	*(struct(long,int,struct(long,long),struct(long,long),*(char),*(char),*(char)))
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"error writing to database %s: %s"	*(char)
)	O
,	O
RUSH_DB	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
void	O
acct_off	O
(	O
void	O
)	O
{	O
if	O
(	O
rushdb_stop	()->(int)
(	O
)	O
)	O
logmsg	O
(	O
LOG_ERR	O
,	O
_	O
(	O
"error writing stop to database file %s: %s"	*(char)
)	O
,	O
RUSH_DB	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
rushdb_close	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
fork_process	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	O
,	O
SIG_DFL	O
)	O
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"%s:%d: %s: cannot fork: %s"	*(char)
)	O
,	O
rule	*(char)
->	O
file	*(char)
,	O
rule	*(char)
->	O
line	O
,	O
rule	*(char)
->	O
tag	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
2	int
)	O
;	O
if	O
(	O
req	O
->	O
acct	(*(char))->(int)
==	O
rush_true	O
)	O
acct_on	O
(	O
rule	*(char)
,	O
req	O
,	O
pid	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Forked process %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"%s: subprocess exited with code %d"	*(char)
)	O
,	O
rule	*(char)
->	O
tag	O
,	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"%s: subprocess terminated on signal %d"	*(char)
)	O
,	O
rule	*(char)
->	O
tag	O
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"%s: subprocess terminated"	*(char)
)	O
,	O
rule	*(char)
->	O
tag	O
)	O
;	O
if	O
(	O
req	O
->	O
acct	(*(char))->(int)
==	O
rush_true	O
)	O
acct_off	O
(	O
)	O
;	O
if	O
(	O
req	O
->	O
post_sockaddr	O
)	O
post_socket_send	O
(	O
req	O
->	O
post_sockaddr	O
,	O
rule	*(char)
,	O
req	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
static	O
int	O
membergid	O
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	O
,	O
gid_t	int
*	O
gv	O
)	O
{	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
gc	O
;	O
i	O
++	O
)	O
if	O
(	O
gv	O
[	O
i	O
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	O
(	O
struct	O
rush_request	O
*	O
req	O
,	O
size_t	long
*	O
pgidc	O
,	O
gid_t	int
*	O
*	O
pgidv	O
)	O
{	O
size_t	long
gidc	O
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	O
=	O
NULL	O
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
gr	O
;	O
n	long
=	O
32	int
;	O
gidv	O
=	O
xcalloc	(long,long)->(*(void))
(	O
n	long
,	O
sizeof	O
(	O
gidv	O
[	O
0	int
]	O
)	O
)	O
;	O
gidv	O
[	O
0	int
]	O
=	O
req	O
->	O
gid	int
==	O
NO_GID	O
?	O
req	O
->	O
pw	O
->	O
pw_gid	int
:	O
req	O
->	O
gid	int
;	O
gidc	O
=	O
1	int
;	O
setgrent	()->(void)
(	O
)	O
;	O
while	O
(	O
(	O
gr	O
=	O
getgrent	()->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
)	O
)	O
)	O
{	O
char	O
*	O
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
gr	O
->	O
gr_mem	*(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
p	*(void)
,	O
req	O
->	O
pw	O
->	O
pw_name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	O
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	O
=	O
xrealloc	(*(void),long)->(*(void))
(	O
gidv	O
,	O
n	long
*	O
sizeof	O
(	O
gidv	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	O
(	O
gr	O
->	O
gr_gid	int
,	O
gidc	O
,	O
gidv	O
)	O
)	O
gidv	O
[	O
gidc	O
++	O
]	O
=	O
gr	O
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	()->(void)
(	O
)	O
;	O
*	O
pgidc	O
=	O
gidc	O
;	O
*	O
pgidv	O
=	O
gidv	O
;	O
}	O
static	O
void	O
setowner	O
(	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
size_t	long
gidc	O
;	O
gid_t	int
*	O
gidv	O
;	O
get_user_groups	O
(	O
req	O
,	O
&	O
gidc	O
,	O
&	O
gidv	O
)	O
;	O
if	O
(	O
setgroups	(long,*(int))->(int)
(	O
gidc	O
,	O
gidv	O
)	O
<	O
0	int
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
"setgroups: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
setgid	(int)->(int)
(	O
gidv	O
[	O
0	int
]	O
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot enforce gid %lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gidv	O
[	O
0	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
gidv	O
)	O
;	O
if	O
(	O
setuid	(int)->(int)
(	O
req	O
->	O
pw	O
->	O
pw_uid	int
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot enforce uid %lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
req	O
->	O
pw	O
->	O
pw_uid	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
req	O
->	O
pw	O
->	O
pw_uid	int
&&	O
setuid	(int)->(int)
(	O
0	int
)	O
==	O
0	int
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"seteuid(0) succeeded when it should not"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
run_rule	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
struct	O
rush_request	O
*	O
req	O
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Rule %s at %s:%d matched"	*(char)
)	O
,	O
rule	*(char)
->	O
tag	O
,	O
rule	*(char)
->	O
file	*(char)
,	O
rule	*(char)
->	O
line	O
)	O
;	O
env_setup	O
(	O
rule	*(char)
,	O
req	O
)	O
;	O
if	O
(	O
rule	*(char)
->	O
i18n	O
.	O
text_domain	O
)	O
req	O
->	O
i18n	O
.	O
text_domain	O
=	O
rule	*(char)
->	O
i18n	O
.	O
text_domain	O
;	O
if	O
(	O
rule	*(char)
->	O
i18n	O
.	O
localedir	O
)	O
req	O
->	O
i18n	O
.	O
localedir	O
=	O
rule	*(char)
->	O
i18n	O
.	O
localedir	O
;	O
if	O
(	O
rule	*(char)
->	O
i18n	O
.	O
locale	*(char)
)	O
req	O
->	O
i18n	O
.	O
locale	*(char)
=	O
rule	*(char)
->	O
i18n	O
.	O
locale	*(char)
;	O
if	O
(	O
rule	*(char)
->	O
error	O
)	O
{	O
const	O
char	O
*	O
msg	*(char)
=	O
rush_error_msg	O
(	O
rule	*(char)
->	O
error	O
,	O
&	O
rule	*(char)
->	O
i18n	O
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Error message: %s"	*(char)
)	O
,	O
msg	*(char)
)	O
;	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
rule	*(char)
->	O
error	O
->	O
fd	int
,	O
msg	*(char)
,	O
strlen	(*(char))->(long)
(	O
msg	*(char)
)	O
)	O
<	O
0	int
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"Error sending diagnostic message to descriptor %d: %s"	*(char)
)	O
,	O
rule	*(char)
->	O
error	O
->	O
fd	int
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
set_user_limits	O
(	O
req	O
->	O
pw	O
->	O
pw_name	*(char)
,	O
rule	*(char)
->	O
limits	O
)	O
)	O
die	O
(	O
usage_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot set limits for %s"	*(char)
)	O
,	O
req	O
->	O
pw	O
->	O
pw_name	*(char)
)	O
;	O
run_transforms	O
(	O
rule	*(char)
,	O
req	O
)	O
;	O
if	O
(	O
rule	*(char)
->	O
chroot_dir	O
)	O
{	O
char	O
*	O
dir	enum(int,int)
=	O
expand_dir	O
(	O
rule	*(char)
->	O
chroot_dir	O
,	O
req	O
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Chroot dir: %s"	*(char)
)	O
,	O
dir	enum(int,int)
)	O
;	O
free	(*(void))->(void)
(	O
req	O
->	O
chroot_dir	O
)	O
;	O
req	O
->	O
chroot_dir	O
=	O
dir	enum(int,int)
;	O
}	O
if	O
(	O
rule	*(char)
->	O
home_dir	O
)	O
{	O
free	(*(void))->(void)
(	O
req	O
->	O
home_dir	O
)	O
;	O
req	O
->	O
home_dir	O
=	O
expand_dir	O
(	O
rule	*(char)
->	O
home_dir	O
,	O
req	O
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Home dir: %s"	*(char)
)	O
,	O
req	O
->	O
home_dir	O
)	O
;	O
}	O
if	O
(	O
rule	*(char)
->	O
gid	int
!=	O
NO_GID	O
)	O
{	O
req	O
->	O
gid	int
=	O
rule	*(char)
->	O
gid	int
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"GID: %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
req	O
->	O
gid	int
)	O
;	O
}	O
if	O
(	O
rule	*(char)
->	O
post_sockaddr	O
.	O
len	long
)	O
req	O
->	O
post_sockaddr	O
=	O
&	O
rule	*(char)
->	O
post_sockaddr	O
;	O
if	O
(	O
rule	*(char)
->	O
acct	(*(char))->(int)
!=	O
rush_undefined	O
)	O
req	O
->	O
acct	(*(char))->(int)
=	O
rule	*(char)
->	O
acct	(*(char))->(int)
;	O
if	O
(	O
req	O
->	O
acct	(*(char))->(int)
==	O
rush_true	O
)	O
req	O
->	O
fork	()->(int)
=	O
rush_true	O
;	O
else	O
if	O
(	O
rule	*(char)
->	O
post_sockaddr	O
.	O
len	long
)	O
req	O
->	O
fork	()->(int)
=	O
rush_true	O
;	O
else	O
if	O
(	O
rule	*(char)
->	O
fork	()->(int)
!=	O
rush_undefined	O
)	O
req	O
->	O
fork	()->(int)
=	O
rule	*(char)
->	O
fork	()->(int)
;	O
if	O
(	O
rule	*(char)
->	O
mask	O
!=	O
NO_UMASK	O
)	O
req	O
->	O
umask	(int)->(int)
=	O
rule	*(char)
->	O
mask	O
;	O
if	O
(	O
rule	*(char)
->	O
fall_through	O
)	O
return	O
;	O
if	O
(	O
req	O
->	O
acct	(*(char))->(int)
==	O
rush_true	O
&&	O
rushdb_open	(*(char),int)->(enum(int,int,int))
(	O
RUSH_DB	O
,	O
1	int
)	O
!=	O
rushdb_result_ok	int
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot open database %s: %s"	*(char)
)	O
,	O
RUSH_DB	O
,	O
rushdb_error_string	*(char)
)	O
;	O
if	O
(	O
req	O
->	O
chroot_dir	O
)	O
{	O
uid_t	int
uid	int
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	O
;	O
if	O
(	O
chroot	(*(char))->(int)
(	O
req	O
->	O
chroot_dir	O
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot chroot to %s: %s"	*(char)
)	O
,	O
req	O
->	O
chroot_dir	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
uid	int
=	O
req	O
->	O
pw	O
->	O
pw_uid	int
;	O
pw	O
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pw	O
)	O
die	O
(	O
req	O
->	O
interactive	O
?	O
nologin_error	int
:	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid uid %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
req	O
->	O
pw	O
=	O
pw	O
;	O
}	O
if	O
(	O
req	O
->	O
home_dir	O
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"chdir %s"	*(char)
)	O
,	O
req	O
->	O
home_dir	O
)	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
req	O
->	O
home_dir	O
)	O
)	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"cannot change to dir %s: %s"	*(char)
)	O
,	O
req	O
->	O
home_dir	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Executing %s, %s"	*(char)
)	O
,	O
PROGFILE	O
(	O
req	O
)	O
,	O
req	O
->	O
cmdline	O
)	O
;	O
if	O
(	O
lint_option	O
)	O
{	O
if	O
(	O
dump_option	O
)	O
dump_request	O
(	O
req	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
req	O
->	O
fork	()->(int)
==	O
rush_true	O
)	O
fork_process	O
(	O
rule	*(char)
,	O
req	O
)	O
;	O
setowner	O
(	O
req	O
)	O
;	O
umask	(int)->(int)
(	O
req	O
->	O
umask	(int)->(int)
)	O
;	O
execve	(*(char),array(*(char)),array(*(char)))->(int)
(	O
PROGFILE	O
(	O
req	O
)	O
,	O
req	O
->	O
argv	*(*(char))
,	O
req	O
->	O
env	O
)	O
;	O
die	O
(	O
system_error	int
,	O
&	O
req	O
->	O
i18n	O
,	O
_	O
(	O
"%s:%d: %s: cannot execute %s: %s"	*(char)
)	O
,	O
rule	*(char)
->	O
file	*(char)
,	O
rule	*(char)
->	O
line	O
,	O
rule	*(char)
->	O
tag	O
,	O
req	O
->	O
cmdline	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
char	O
*	O
command	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
test_user_name	O
=	O
NULL	O
;	O
static	O
int	O
interactive	O
;	O
int	O
main	O
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
uid_t	int
uid	int
;	O
struct	O
rush_rule	O
*	O
rule	*(char)
;	O
struct	O
rush_request	O
req	O
;	O
rush_set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
rush_i18n_init	()->(void)
(	O
)	O
;	O
umask	(int)->(int)
(	O
~	O
(	O
mode_t	int
)	O
0	int
)	O
;	O
openlog	(*(char),int,int)->(void)
(	O
program_name	*(char)
,	O
LOG_NDELAY	O
|	O
LOG_PID	O
,	O
LOG_AUTHPRIV	O
)	O
;	O
get_options	O
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
cfgram_debug	O
(	O
parser_traces	O
>	O
0	int
)	O
;	O
cflex_debug	O
(	O
parser_traces	O
>	O
1	int
)	O
;	O
if	O
(	O
scanner_test	O
)	O
{	O
cfck_keyword	O
(	O
"none"	*(char)
)	O
;	O
if	O
(	O
argc	int
>	O
optind	int
+	O
1	int
)	O
{	O
logmsg	O
(	O
LOG_ERR	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
cflex_test	O
(	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
argc	int
==	O
optind	int
+	O
1	int
)	O
{	O
if	O
(	O
lint_option	O
)	O
rush_config_file	O
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
else	O
die	O
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid command line"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
>	O
optind	int
)	O
die	O
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid command line"	*(char)
)	O
)	O
;	O
if	O
(	O
lint_option	O
)	O
{	O
if	O
(	O
setuid	(int)->(int)
(	O
getuid	()->(int)
(	O
)	O
)	O
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
"setuid: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
test_user_name	O
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	O
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
test_user_name	O
)	O
;	O
if	O
(	O
!	O
pw	O
)	O
die	O
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid user name"	*(char)
)	O
)	O
;	O
if	O
(	O
setreuid	(int,int)->(int)
(	O
pw	O
->	O
pw_uid	int
,	O
0	int
)	O
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
"setreuid: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
if	O
(	O
(	O
rush_pw	O
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
uid	int
)	O
)	O
==	O
NULL	O
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid uid %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"user %s, uid %lu"	*(char)
)	O
,	O
rush_pw	O
->	O
pw_name	*(char)
,	O
(	O
unsigned	O
long	O
)	O
rush_pw	O
->	O
pw_uid	int
)	O
;	O
cfparse	O
(	O
)	O
;	O
if	O
(	O
!	O
command	*(char)
)	O
{	O
if	O
(	O
lint_option	O
&&	O
!	O
interactive	O
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
int	O
i	O
;	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
_	O
(	O
"Command line:"	*(char)
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
argc	int
;	O
i	O
++	O
)	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
"% 4d: %s"	*(char)
,	O
i	O
,	O
argv	*(*(char))
[	O
i	O
]	O
)	O
;	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
_	O
(	O
"Environment:"	*(char)
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
environ	*(*(char))
[	O
i	O
]	O
;	O
i	O
++	O
)	O
logmsg	O
(	O
LOG_DEBUG	O
,	O
"% 4d %s"	*(char)
,	O
i	O
,	O
environ	*(*(char))
[	O
i	O
]	O
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
req	O
,	O
0	int
,	O
sizeof	O
(	O
req	O
)	O
)	O
;	O
if	O
(	O
!	O
command	*(char)
)	O
{	O
req	O
.	O
interactive	O
=	O
1	int
;	O
command	*(char)
=	O
"/bin/sh"	*(char)
;	O
}	O
req	O
.	O
cmdline	O
=	O
xstrdup	(*(char))->(*(char))
(	O
command	*(char)
)	O
;	O
request_set_env	O
(	O
&	O
req	O
)	O
;	O
reparse_cmdline	O
(	O
&	O
req	O
)	O
;	O
req	O
.	O
pw	O
=	O
rush_pw	O
;	O
req	O
.	O
umask	(int)->(int)
=	O
022	int
;	O
req	O
.	O
chroot_dir	O
=	O
NULL	O
;	O
req	O
.	O
home_dir	O
=	O
NULL	O
;	O
req	O
.	O
gid	int
=	O
NO_GID	O
;	O
req	O
.	O
fork	()->(int)
=	O
rush_undefined	O
;	O
req	O
.	O
acct	(*(char))->(int)
=	O
rush_undefined	O
;	O
for	O
(	O
rule	*(char)
=	O
rule_head	O
;	O
rule	*(char)
;	O
rule	*(char)
=	O
rule	*(char)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
if	O
(	O
req	O
.	O
interactive	O
!=	O
rule	*(char)
->	O
interactive	O
)	O
continue	O
;	O
if	O
(	O
rule	*(char)
->	O
test_node	O
&&	O
!	O
test_eval	O
(	O
rule	*(char)
->	O
test_node	O
,	O
rule	*(char)
,	O
&	O
req	O
)	O
)	O
continue	O
;	O
if	O
(	O
debug_level	O
)	O
{	O
if	O
(	O
req	O
.	O
interactive	O
)	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"Serving interactive shell request for %s by rule %s"	*(char)
)	O
,	O
req	O
.	O
pw	O
->	O
pw_name	*(char)
,	O
rule	*(char)
->	O
tag	O
)	O
;	O
else	O
logmsg	O
(	O
LOG_NOTICE	O
,	O
_	O
(	O
"Serving request \"%s\" for %s by rule %s"	*(char)
)	O
,	O
command	*(char)
,	O
req	O
.	O
pw	O
->	O
pw_name	*(char)
,	O
rule	*(char)
->	O
tag	O
)	O
;	O
}	O
run_rule	O
(	O
rule	*(char)
,	O
&	O
req	O
)	O
;	O
}	O
die	O
(	O
req	O
.	O
interactive	O
?	O
nologin_error	int
:	O
usage_error	int
,	O
&	O
req	O
.	O
i18n	O
,	O
_	O
(	O
"no matching rule for \"%s\", user %s"	*(char)
)	O
,	O
req	O
.	O
cmdline	O
,	O
req	O
.	O
pw	O
->	O
pw_name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
