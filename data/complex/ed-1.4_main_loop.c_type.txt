enum	O
Status	enum(int,int,int)
{	O
ERR	int
=	O
-	O
2	int
,	O
EMOD	int
=	O
-	O
3	int
,	O
FATAL	int
=	O
-	O
4	int
}	O
;	O
static	O
char	O
def_filename	array(char)
[	O
1024	int
]	O
=	O
""	*(char)
;	O
static	O
char	O
errmsg	array(char)
[	O
80	int
]	O
=	O
""	*(char)
;	O
static	O
char	O
prompt_str	array(char)
[	O
80	int
]	O
=	O
"*"	*(char)
;	O
static	O
const	O
char	O
*	O
ibufp	*(char)
=	O
0	int
;	O
static	O
char	O
*	O
shcmd	*(char)
=	O
0	int
;	O
static	O
int	O
shcmdsz	int
=	O
0	int
;	O
static	O
int	O
shcmdlen	int
=	O
0	int
;	O
static	O
int	O
first_addr	int
=	O
0	int
,	O
second_addr	int
=	O
0	int
;	O
static	O
char	O
verbose	char
=	O
0	int
;	O
static	O
char	O
prompt_on	char
=	O
0	int
;	O
void	O
set_def_filename	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
def_filename	array(char)
,	O
s	*(char)
,	O
sizeof	O
(	O
def_filename	array(char)
)	O
)	O
;	O
def_filename	array(char)
[	O
sizeof	O
(	O
def_filename	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
void	O
set_prompt	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
prompt_on	char
=	O
1	int
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
prompt_str	array(char)
,	O
s	*(char)
,	O
sizeof	O
(	O
prompt_str	array(char)
)	O
)	O
;	O
prompt_str	array(char)
[	O
sizeof	O
(	O
prompt_str	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
void	O
set_verbose	()->(void)
(	O
void	O
)	O
{	O
verbose	char
=	O
1	int
;	O
}	O
static	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
26	int
]	O
;	O
static	O
int	O
markno	int
;	O
static	O
char	O
mark_line_node	(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),int)->(char)
(	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
,	O
int	O
c	int
)	O
{	O
c	int
-=	O
'a'	O
;	O
if	O
(	O
c	int
<	O
0	int
||	O
c	int
>=	O
26	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid mark character"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
c	int
]	O
)	O
++	O
markno	int
;	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
c	int
]	O
=	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
;	O
return	O
1	int
;	O
}	O
void	O
unmark_line_node	(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))->(void)
(	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
)	O
{	O
int	O
i	*(int)
;	O
for	O
(	O
i	*(int)
=	O
0	int
;	O
markno	int
&&	O
i	*(int)
<	O
26	int
;	O
++	O
i	*(int)
)	O
if	O
(	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
i	*(int)
]	O
==	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
)	O
{	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
i	*(int)
]	O
=	O
0	int
;	O
--	O
markno	int
;	O
}	O
}	O
static	O
int	O
get_marked_node_addr	(int)->(int)
(	O
int	O
c	int
)	O
{	O
c	int
-=	O
'a'	O
;	O
if	O
(	O
c	int
<	O
0	int
||	O
c	int
>=	O
26	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid mark character"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
get_line_node_addr	(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))->(int)
(	O
mark	array(*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int)))
[	O
c	int
]	O
)	O
;	O
}	O
static	O
int	O
get_shell_command	()->(int)
(	O
void	O
)	O
{	O
static	O
char	O
*	O
buf	*(*(char))
=	O
0	int
;	O
static	O
int	O
bufsz	int
=	O
0	int
;	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
i	*(int)
=	O
0	int
,	O
len	int
;	O
if	O
(	O
restricted	()->(char)
(	O
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Shell access restricted"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
s	*(char)
=	O
ibufp	*(char)
=	O
get_extended_line	(*(char),*(int),char)->(*(char))
(	O
ibufp	*(char)
,	O
&	O
len	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
len	int
+	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
'!'	O
;	O
while	O
(	O
*	O
ibufp	*(char)
!=	O
'\n'	O
)	O
{	O
if	O
(	O
*	O
ibufp	*(char)
==	O
'!'	O
)	O
{	O
if	O
(	O
s	*(char)
!=	O
ibufp	*(char)
)	O
{	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
i	*(int)
+	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
*	O
ibufp	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
!	O
shcmd	*(char)
||	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
*	O
(	O
shcmd	*(char)
+	O
1	int
)	O
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No previous command"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
i	*(int)
+	O
shcmdlen	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
s	*(char)
=	O
shcmd	*(char)
+	O
1	int
;	O
s	*(char)
<	O
shcmd	*(char)
+	O
shcmdlen	int
;	O
)	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
*	O
s	*(char)
++	O
;	O
s	*(char)
=	O
ibufp	*(char)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
ibufp	*(char)
==	O
'%'	O
)	O
{	O
if	O
(	O
!	O
def_filename	array(char)
[	O
0	int
]	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No current filename"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
=	O
strip_escapes	(*(char))->(*(char))
(	O
def_filename	array(char)
)	O
)	O
;	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
i	*(int)
+	O
len	int
)	O
)	O
return	O
-	O
1	int
;	O
while	O
(	O
len	int
--	O
)	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
*	O
s	*(char)
++	O
;	O
s	*(char)
=	O
ibufp	*(char)
++	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
i	*(int)
+	O
2	int
)	O
)	O
return	O
-	O
1	int
;	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
*	O
ibufp	*(char)
;	O
if	O
(	O
*	O
ibufp	*(char)
++	O
==	O
'\\'	O
)	O
buf	*(*(char))
[	O
i	*(int)
++	O
]	O
=	O
*	O
ibufp	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
shcmd	*(char)
,	O
&	O
shcmdsz	int
,	O
i	*(int)
+	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
shcmd	*(char)
,	O
buf	*(*(char))
,	O
i	*(int)
)	O
;	O
shcmdlen	int
=	O
i	*(int)
;	O
shcmd	*(char)
[	O
i	*(int)
]	O
=	O
0	int
;	O
return	O
(	O
*	O
s	*(char)
==	O
'!'	O
||	O
*	O
s	*(char)
==	O
'%'	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
skip_blanks	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(char)
)	O
&&	O
*	O
s	*(char)
!=	O
'\n'	O
)	O
++	O
s	*(char)
;	O
return	O
s	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
get_filename	()->(*(char))
(	O
void	O
)	O
{	O
static	O
char	O
*	O
buf	*(*(char))
=	O
0	int
;	O
static	O
int	O
bufsz	int
=	O
0	int
;	O
int	O
size	*(int)
,	O
n	int
;	O
ibufp	*(char)
=	O
skip_blanks	(*(char))->(*(char))
(	O
ibufp	*(char)
)	O
;	O
if	O
(	O
*	O
ibufp	*(char)
!=	O
'\n'	O
)	O
{	O
ibufp	*(char)
=	O
get_extended_line	(*(char),*(int),char)->(*(char))
(	O
ibufp	*(char)
,	O
&	O
size	*(int)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
ibufp	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
*	O
ibufp	*(char)
==	O
'!'	O
)	O
{	O
++	O
ibufp	*(char)
;	O
n	int
=	O
get_shell_command	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
n	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
shcmd	*(char)
+	O
1	int
)	O
;	O
return	O
shcmd	*(char)
;	O
}	O
else	O
if	O
(	O
size	*(int)
>	O
path_max	(*(char))->(int)
(	O
0	int
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Filename too long"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
def_filename	array(char)
[	O
0	int
]	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No current filename"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
path_max	(*(char))->(int)
(	O
0	int
)	O
+	O
1	int
)	O
)	O
return	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
*	O
ibufp	*(char)
!=	O
'\n'	O
;	O
)	O
buf	*(*(char))
[	O
n	int
++	O
]	O
=	O
*	O
ibufp	*(char)
++	O
;	O
buf	*(*(char))
[	O
n	int
]	O
=	O
0	int
;	O
return	O
(	O
may_access_filename	(*(char))->(char)
(	O
buf	*(*(char))
)	O
?	O
buf	*(*(char))
:	O
0	int
)	O
;	O
}	O
static	O
void	O
invalid_address	()->(void)
(	O
void	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid address"	*(char)
)	O
;	O
}	O
static	O
int	O
next_addr	(*(int))->(int)
(	O
int	O
*	O
addr_cnt	*(int)
)	O
{	O
const	O
char	O
*	O
hd	*(char)
=	O
ibufp	*(char)
=	O
skip_blanks	(*(char))->(*(char))
(	O
ibufp	*(char)
)	O
;	O
int	O
addr	int
=	O
current_addr	()->(int)
(	O
)	O
;	O
int	O
first	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
n	int
;	O
const	O
unsigned	O
char	O
ch	char
=	O
*	O
ibufp	*(char)
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
ch	char
)	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
;	O
if	O
(	O
!	O
parse_int	(*(int),*(char),*(*(char)))->(char)
(	O
&	O
addr	int
,	O
ibufp	*(char)
,	O
&	O
ibufp	*(char)
)	O
)	O
return	O
-	O
2	int
;	O
}	O
else	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'+'	O
:	O
case	O
'\t'	O
:	O
case	O
' '	O
:	O
case	O
'-'	O
:	O
ibufp	*(char)
=	O
skip_blanks	(*(char))->(*(char))
(	O
++	O
ibufp	*(char)
)	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
ibufp	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
parse_int	(*(int),*(char),*(*(char)))->(char)
(	O
&	O
n	int
,	O
ibufp	*(char)
,	O
&	O
ibufp	*(char)
)	O
)	O
return	O
-	O
2	int
;	O
addr	int
+=	O
(	O
(	O
ch	char
==	O
'-'	O
)	O
?	O
-	O
n	int
:	O
n	int
)	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'+'	O
)	O
++	O
addr	int
;	O
else	O
if	O
(	O
ch	char
==	O
'-'	O
)	O
--	O
addr	int
;	O
break	O
;	O
case	O
'.'	O
:	O
case	O
'$'	O
:	O
if	O
(	O
!	O
first	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
;	O
++	O
ibufp	*(char)
;	O
addr	int
=	O
(	O
(	O
ch	char
==	O
'.'	O
)	O
?	O
current_addr	()->(int)
(	O
)	O
:	O
last_addr	()->(int)
(	O
)	O
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
case	O
'?'	O
:	O
if	O
(	O
!	O
first	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
;	O
addr	int
=	O
get_matching_node_addr	(*(*(char)),char)->(int)
(	O
&	O
ibufp	*(char)
,	O
ch	char
==	O
'/'	O
)	O
;	O
if	O
(	O
addr	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
if	O
(	O
ch	char
==	O
*	O
ibufp	*(char)
)	O
++	O
ibufp	*(char)
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
first	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
;	O
++	O
ibufp	*(char)
;	O
addr	int
=	O
get_marked_node_addr	(int)->(int)
(	O
*	O
ibufp	*(char)
++	O
)	O
;	O
if	O
(	O
addr	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
break	O
;	O
case	O
'%'	O
:	O
case	O
','	O
:	O
case	O
';'	O
:	O
if	O
(	O
first	int
)	O
{	O
++	O
ibufp	*(char)
;	O
++	O
*	O
addr_cnt	*(int)
;	O
second_addr	int
=	O
(	O
(	O
ch	char
==	O
';'	O
)	O
?	O
current_addr	()->(int)
(	O
)	O
:	O
1	int
)	O
;	O
addr	int
=	O
last_addr	()->(int)
(	O
)	O
;	O
break	O
;	O
}	O
default	O
:	O
if	O
(	O
ibufp	*(char)
==	O
hd	*(char)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
addr	int
<	O
0	int
||	O
addr	int
>	O
last_addr	()->(int)
(	O
)	O
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
++	O
*	O
addr_cnt	*(int)
;	O
return	O
addr	int
;	O
}	O
first	int
=	O
0	int
;	O
}	O
}	O
static	O
int	O
extract_addr_range	()->(int)
(	O
void	O
)	O
{	O
int	O
addr	int
;	O
int	O
addr_cnt	*(int)
=	O
0	int
;	O
first_addr	int
=	O
second_addr	int
=	O
current_addr	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
addr	int
=	O
next_addr	(*(int))->(int)
(	O
&	O
addr_cnt	*(int)
)	O
)	O
>=	O
0	int
)	O
{	O
first_addr	int
=	O
second_addr	int
;	O
second_addr	int
=	O
addr	int
;	O
if	O
(	O
*	O
ibufp	*(char)
!=	O
','	O
&&	O
*	O
ibufp	*(char)
!=	O
';'	O
)	O
break	O
;	O
if	O
(	O
*	O
ibufp	*(char)
++	O
==	O
';'	O
)	O
set_current_addr	(int)->(void)
(	O
addr	int
)	O
;	O
}	O
if	O
(	O
addr_cnt	*(int)
==	O
1	int
||	O
second_addr	int
!=	O
addr	int
)	O
first_addr	int
=	O
second_addr	int
;	O
return	O
(	O
(	O
addr	int
!=	O
-	O
2	int
)	O
?	O
addr_cnt	*(int)
:	O
-	O
1	int
)	O
;	O
}	O
static	O
char	O
get_third_addr	(*(int))->(char)
(	O
int	O
*	O
addr	int
)	O
{	O
int	O
ol1	int
=	O
first_addr	int
;	O
int	O
ol2	int
=	O
second_addr	int
;	O
int	O
addr_cnt	*(int)
=	O
extract_addr_range	()->(int)
(	O
)	O
;	O
if	O
(	O
addr_cnt	*(int)
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
addr_cnt	*(int)
==	O
0	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Destination expected"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
second_addr	int
<	O
0	int
||	O
second_addr	int
>	O
last_addr	()->(int)
(	O
)	O
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
*	O
addr	int
=	O
second_addr	int
;	O
first_addr	int
=	O
ol1	int
;	O
second_addr	int
=	O
ol2	int
;	O
return	O
1	int
;	O
}	O
static	O
char	O
check_addr_range	(int,int,int)->(char)
(	O
const	O
int	O
n	int
,	O
const	O
int	O
m	char
,	O
const	O
int	O
addr_cnt	*(int)
)	O
{	O
if	O
(	O
addr_cnt	*(int)
==	O
0	int
)	O
{	O
first_addr	int
=	O
(	O
(	O
n	int
>=	O
0	int
)	O
?	O
n	int
:	O
current_addr	()->(int)
(	O
)	O
)	O
;	O
second_addr	int
=	O
(	O
(	O
m	char
>=	O
0	int
)	O
?	O
m	char
:	O
current_addr	()->(int)
(	O
)	O
)	O
;	O
}	O
if	O
(	O
first_addr	int
<	O
1	int
||	O
first_addr	int
>	O
second_addr	int
||	O
second_addr	int
>	O
last_addr	()->(int)
(	O
)	O
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
char	O
get_command_suffix	(*(int))->(char)
(	O
int	O
*	O
gflagsp	*(int)
)	O
{	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
ch	char
=	O
*	O
ibufp	*(char)
;	O
if	O
(	O
ch	char
==	O
'l'	O
)	O
*	O
gflagsp	*(int)
|=	O
GLS	int
;	O
else	O
if	O
(	O
ch	char
==	O
'n'	O
)	O
*	O
gflagsp	*(int)
|=	O
GNP	int
;	O
else	O
if	O
(	O
ch	char
==	O
'p'	O
)	O
*	O
gflagsp	*(int)
|=	O
GPR	int
;	O
else	O
break	O
;	O
++	O
ibufp	*(char)
;	O
}	O
if	O
(	O
*	O
ibufp	*(char)
++	O
!=	O
'\n'	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid command suffix"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
char	O
unexpected_address	(int)->(char)
(	O
const	O
int	O
addr_cnt	*(int)
)	O
{	O
if	O
(	O
addr_cnt	*(int)
>	O
0	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Unexpected address"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
unexpected_command_suffix	(char)->(char)
(	O
const	O
unsigned	O
char	O
ch	char
)	O
{	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
ch	char
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Unexpected command suffix"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
command_s	(*(int),int,char)->(char)
(	O
int	O
*	O
gflagsp	*(int)
,	O
const	O
int	O
addr_cnt	*(int)
,	O
const	O
char	O
isglobal	char
)	O
{	O
static	O
int	O
gflags	int
=	O
0	int
;	O
static	O
int	O
snum	int
=	O
0	int
;	O
enum	O
Sflags	enum(int,int,int,int)
{	O
SGG	int
=	O
0x01	int
,	O
SGP	int
=	O
0x02	int
,	O
SGR	int
=	O
0x04	int
,	O
SGF	int
=	O
0x08	int
}	O
sflags	enum(int,int,int,int)
=	O
0	int
;	O
do	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
ibufp	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
parse_int	(*(int),*(char),*(*(char)))->(char)
(	O
&	O
snum	int
,	O
ibufp	*(char)
,	O
&	O
ibufp	*(char)
)	O
)	O
return	O
0	int
;	O
sflags	enum(int,int,int,int)
|=	O
SGF	int
;	O
gflags	int
&=	O
~	O
GSG	int
;	O
}	O
else	O
switch	O
(	O
*	O
ibufp	*(char)
)	O
{	O
case	O
'\n'	O
:	O
sflags	enum(int,int,int,int)
|=	O
SGF	int
;	O
break	O
;	O
case	O
'g'	O
:	O
sflags	enum(int,int,int,int)
|=	O
SGG	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
sflags	enum(int,int,int,int)
|=	O
SGP	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
case	O
'r'	O
:	O
sflags	enum(int,int,int,int)
|=	O
SGR	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
default	O
:	O
if	O
(	O
sflags	enum(int,int,int,int)
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid command suffix"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
while	O
(	O
sflags	enum(int,int,int,int)
&&	O
*	O
ibufp	*(char)
!=	O
'\n'	O
)	O
;	O
if	O
(	O
sflags	enum(int,int,int,int)
&&	O
!	O
prev_pattern	()->(char)
(	O
)	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No previous substitution"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
sflags	enum(int,int,int,int)
&	O
SGG	int
)	O
snum	int
=	O
0	int
;	O
if	O
(	O
*	O
ibufp	*(char)
!=	O
'\n'	O
&&	O
ibufp	*(char)
[	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid pattern delimiter"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
!	O
sflags	enum(int,int,int,int)
||	O
(	O
sflags	enum(int,int,int,int)
&	O
SGR	int
)	O
)	O
&&	O
!	O
new_compiled_pattern	(*(*(char)))->(char)
(	O
&	O
ibufp	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
sflags	enum(int,int,int,int)
&&	O
!	O
extract_subst_tail	(*(*(char)),*(int),*(int),char)->(char)
(	O
&	O
ibufp	*(char)
,	O
&	O
gflags	int
,	O
&	O
snum	int
,	O
isglobal	char
)	O
)	O
return	O
0	int
;	O
if	O
(	O
isglobal	char
)	O
gflags	int
|=	O
GLB	int
;	O
else	O
gflags	int
&=	O
~	O
GLB	int
;	O
if	O
(	O
sflags	enum(int,int,int,int)
&	O
SGG	int
)	O
gflags	int
^=	O
GSG	int
;	O
if	O
(	O
sflags	enum(int,int,int,int)
&	O
SGP	int
)	O
{	O
gflags	int
^=	O
GPR	int
;	O
gflags	int
&=	O
~	O
(	O
GLS	int
|	O
GNP	int
)	O
;	O
}	O
switch	O
(	O
*	O
ibufp	*(char)
)	O
{	O
case	O
'l'	O
:	O
gflags	int
|=	O
GLS	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
case	O
'n'	O
:	O
gflags	int
|=	O
GNP	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
gflags	int
|=	O
GPR	int
;	O
++	O
ibufp	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
gflagsp	*(int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
search_and_replace	(int,int,int,int,char)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
gflags	int
,	O
snum	int
,	O
isglobal	char
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
gflags	int
&	O
(	O
GPR	int
|	O
GLS	int
|	O
GNP	int
)	O
)	O
&&	O
!	O
display_lines	(int,int,int)->(char)
(	O
current_addr	()->(int)
(	O
)	O
,	O
current_addr	()->(int)
(	O
)	O
,	O
gflags	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
char	O
exec_global	(*(char),int,char)->(char)
(	O
const	O
char	O
*	O
ibufp2	*(char)
,	O
int	O
gflags	int
,	O
const	O
char	O
interact	char
)	O
;	O
static	O
int	O
exec_command	(char)->(int)
(	O
const	O
char	O
isglobal	char
)	O
{	O
const	O
char	O
*	O
fnp	*(char)
;	O
int	O
gflags	int
=	O
0	int
;	O
int	O
addr	int
,	O
c	int
,	O
n	int
;	O
const	O
int	O
addr_cnt	*(int)
=	O
extract_addr_range	()->(int)
(	O
)	O
;	O
if	O
(	O
addr_cnt	*(int)
<	O
0	int
)	O
return	O
ERR	int
;	O
ibufp	*(char)
=	O
skip_blanks	(*(char))->(*(char))
(	O
ibufp	*(char)
)	O
;	O
c	int
=	O
*	O
ibufp	*(char)
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'a'	O
:	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
append_lines	(*(char),int,char)->(char)
(	O
ibufp	*(char)
,	O
second_addr	int
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
ibufp	*(char)
=	O
""	*(char)
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
first_addr	int
==	O
0	int
)	O
first_addr	int
=	O
1	int
;	O
if	O
(	O
second_addr	int
==	O
0	int
)	O
second_addr	int
=	O
1	int
;	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
delete_lines	(int,int,char)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
isglobal	char
)	O
||	O
!	O
append_lines	(*(char),int,char)->(char)
(	O
ibufp	*(char)
,	O
current_addr	()->(int)
(	O
)	O
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
ibufp	*(char)
=	O
""	*(char)
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
delete_lines	(int,int,char)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
inc_current_addr	()->(int)
(	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
if	O
(	O
modified	()->(char)
(	O
)	O
&&	O
!	O
scripted	()->(char)
(	O
)	O
)	O
return	O
EMOD	int
;	O
case	O
'E'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
||	O
unexpected_command_suffix	(char)->(char)
(	O
*	O
ibufp	*(char)
)	O
)	O
return	O
ERR	int
;	O
fnp	*(char)
=	O
get_filename	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
fnp	*(char)
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
delete_lines	(int,int,char)->(char)
(	O
1	int
,	O
last_addr	()->(int)
(	O
)	O
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
close_sbuf	()->(char)
(	O
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
open_sbuf	()->(char)
(	O
)	O
)	O
return	O
FATAL	int
;	O
if	O
(	O
fnp	*(char)
[	O
0	int
]	O
&&	O
fnp	*(char)
[	O
0	int
]	O
!=	O
'!'	O
)	O
set_def_filename	(*(char))->(void)
(	O
fnp	*(char)
)	O
;	O
if	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
fnp	*(char)
[	O
0	int
]	O
&&	O
!	O
def_filename	array(char)
[	O
0	int
]	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No current filename"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
read_file	(*(char),int)->(int)
(	O
fnp	*(char)
[	O
0	int
]	O
?	O
fnp	*(char)
:	O
def_filename	array(char)
,	O
0	int
)	O
<	O
0	int
)	O
return	O
ERR	int
;	O
reset_undo_state	()->(void)
(	O
)	O
;	O
set_modified	(char)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
||	O
unexpected_command_suffix	(char)->(char)
(	O
*	O
ibufp	*(char)
)	O
)	O
return	O
ERR	int
;	O
fnp	*(char)
=	O
get_filename	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
fnp	*(char)
)	O
return	O
ERR	int
;	O
if	O
(	O
fnp	*(char)
[	O
0	int
]	O
==	O
'!'	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid redirection"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
fnp	*(char)
[	O
0	int
]	O
)	O
set_def_filename	(*(char))->(void)
(	O
fnp	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
strip_escapes	(*(char))->(*(char))
(	O
def_filename	array(char)
)	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
case	O
'v'	O
:	O
case	O
'G'	O
:	O
case	O
'V'	O
:	O
if	O
(	O
isglobal	char
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Cannot nest global commands"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
n	int
=	O
(	O
c	int
==	O
'g'	O
||	O
c	int
==	O
'G'	O
)	O
;	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
1	int
,	O
last_addr	()->(int)
(	O
)	O
,	O
addr_cnt	*(int)
)	O
||	O
!	O
build_active_list	(*(*(char)),int,int,char)->(char)
(	O
&	O
ibufp	*(char)
,	O
first_addr	int
,	O
second_addr	int
,	O
n	int
)	O
)	O
return	O
ERR	int
;	O
n	int
=	O
(	O
c	int
==	O
'G'	O
||	O
c	int
==	O
'V'	O
)	O
;	O
if	O
(	O
(	O
n	int
&&	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
||	O
!	O
exec_global	(*(char),int,char)->(char)
(	O
ibufp	*(char)
,	O
gflags	int
,	O
n	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
c	int
==	O
'H'	O
)	O
verbose	char
=	O
!	O
verbose	char
;	O
if	O
(	O
(	O
c	int
==	O
'h'	O
||	O
verbose	char
)	O
&&	O
errmsg	array(char)
[	O
0	int
]	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
errmsg	array(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
second_addr	int
==	O
0	int
)	O
second_addr	int
=	O
1	int
;	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
append_lines	(*(char),int,char)->(char)
(	O
ibufp	*(char)
,	O
second_addr	int
-	O
1	int
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
ibufp	*(char)
=	O
""	*(char)
;	O
break	O
;	O
case	O
'j'	O
:	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
current_addr	()->(int)
(	O
)	O
+	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
first_addr	int
!=	O
second_addr	int
&&	O
!	O
join_lines	(int,int,char)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'k'	O
:	O
n	int
=	O
*	O
ibufp	*(char)
++	O
;	O
if	O
(	O
second_addr	int
==	O
0	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
mark_line_node	(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),int)->(char)
(	O
search_line_node	(int)->(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))
(	O
second_addr	int
)	O
,	O
n	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'l'	O
:	O
case	O
'n'	O
:	O
case	O
'p'	O
:	O
if	O
(	O
c	int
==	O
'l'	O
)	O
n	int
=	O
GLS	int
;	O
else	O
if	O
(	O
c	int
==	O
'n'	O
)	O
n	int
=	O
GNP	int
;	O
else	O
n	int
=	O
GPR	int
;	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
display_lines	(int,int,int)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
gflags	int
|	O
n	int
)	O
)	O
return	O
ERR	int
;	O
gflags	int
=	O
0	int
;	O
break	O
;	O
case	O
'm'	O
:	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_third_addr	(*(int))->(char)
(	O
&	O
addr	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
addr	int
>=	O
first_addr	int
&&	O
addr	int
<	O
second_addr	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Invalid destination"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
move_lines	(int,int,int,char)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
addr	int
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'P'	O
:	O
case	O
'q'	O
:	O
case	O
'Q'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
c	int
==	O
'P'	O
)	O
prompt_on	char
=	O
!	O
prompt_on	char
;	O
else	O
return	O
(	O
(	O
modified	()->(char)
(	O
)	O
&&	O
!	O
scripted	()->(char)
(	O
)	O
&&	O
c	int
==	O
'q'	O
)	O
?	O
EMOD	int
:	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
unexpected_command_suffix	(char)->(char)
(	O
*	O
ibufp	*(char)
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
addr_cnt	*(int)
==	O
0	int
)	O
second_addr	int
=	O
last_addr	()->(int)
(	O
)	O
;	O
fnp	*(char)
=	O
get_filename	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
fnp	*(char)
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
def_filename	array(char)
[	O
0	int
]	O
&&	O
fnp	*(char)
[	O
0	int
]	O
!=	O
'!'	O
)	O
set_def_filename	(*(char))->(void)
(	O
fnp	*(char)
)	O
;	O
if	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
fnp	*(char)
[	O
0	int
]	O
&&	O
!	O
def_filename	array(char)
[	O
0	int
]	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No current filename"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
addr	int
=	O
read_file	(*(char),int)->(int)
(	O
fnp	*(char)
[	O
0	int
]	O
?	O
fnp	*(char)
:	O
def_filename	array(char)
,	O
second_addr	int
)	O
;	O
if	O
(	O
addr	int
<	O
0	int
)	O
return	O
ERR	int
;	O
if	O
(	O
addr	int
&&	O
addr	int
!=	O
last_addr	()->(int)
(	O
)	O
)	O
set_modified	(char)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
!	O
command_s	(*(int),int,char)->(char)
(	O
&	O
gflags	int
,	O
addr_cnt	*(int)
,	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_third_addr	(*(int))->(char)
(	O
&	O
addr	int
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
copy_lines	(int,int,int)->(char)
(	O
first_addr	int
,	O
second_addr	int
,	O
addr	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'u'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
undo	(char)->(char)
(	O
isglobal	char
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
n	int
=	O
*	O
ibufp	*(char)
;	O
if	O
(	O
n	int
==	O
'q'	O
||	O
n	int
==	O
'Q'	O
)	O
++	O
ibufp	*(char)
;	O
if	O
(	O
unexpected_command_suffix	(char)->(char)
(	O
*	O
ibufp	*(char)
)	O
)	O
return	O
ERR	int
;	O
fnp	*(char)
=	O
get_filename	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
fnp	*(char)
)	O
return	O
ERR	int
;	O
if	O
(	O
addr_cnt	*(int)
==	O
0	int
&&	O
!	O
last_addr	()->(int)
(	O
)	O
)	O
first_addr	int
=	O
second_addr	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
1	int
,	O
last_addr	()->(int)
(	O
)	O
,	O
addr_cnt	*(int)
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
def_filename	array(char)
[	O
0	int
]	O
&&	O
fnp	*(char)
[	O
0	int
]	O
!=	O
'!'	O
)	O
set_def_filename	(*(char))->(void)
(	O
fnp	*(char)
)	O
;	O
if	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
fnp	*(char)
[	O
0	int
]	O
&&	O
!	O
def_filename	array(char)
[	O
0	int
]	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No current filename"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
addr	int
=	O
write_file	(*(char),*(char),int,int)->(int)
(	O
fnp	*(char)
[	O
0	int
]	O
?	O
fnp	*(char)
:	O
def_filename	array(char)
,	O
(	O
c	int
==	O
'W'	O
)	O
?	O
"a"	*(char)
:	O
"w"	*(char)
,	O
first_addr	int
,	O
second_addr	int
)	O
;	O
if	O
(	O
addr	int
<	O
0	int
)	O
return	O
ERR	int
;	O
if	O
(	O
addr	int
==	O
last_addr	()->(int)
(	O
)	O
)	O
set_modified	(char)->(void)
(	O
0	int
)	O
;	O
else	O
if	O
(	O
modified	()->(char)
(	O
)	O
&&	O
!	O
scripted	()->(char)
(	O
)	O
&&	O
n	int
==	O
'q'	O
)	O
return	O
EMOD	int
;	O
if	O
(	O
n	int
==	O
'q'	O
||	O
n	int
==	O
'Q'	O
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
second_addr	int
<	O
0	int
||	O
last_addr	()->(int)
(	O
)	O
<	O
second_addr	int
)	O
{	O
invalid_address	()->(void)
(	O
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
!	O
isglobal	char
)	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
put_lines	(int)->(char)
(	O
second_addr	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'y'	O
:	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
addr_cnt	*(int)
)	O
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
yank_lines	(int,int)->(char)
(	O
first_addr	int
,	O
second_addr	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'z'	O
:	O
first_addr	int
=	O
1	int
;	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
first_addr	int
,	O
current_addr	()->(int)
(	O
)	O
+	O
(	O
traditional	()->(char)
(	O
)	O
||	O
!	O
isglobal	char
)	O
,	O
addr_cnt	*(int)
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
*	O
ibufp	*(char)
>	O
'0'	O
&&	O
*	O
ibufp	*(char)
<=	O
'9'	O
)	O
{	O
if	O
(	O
parse_int	(*(int),*(char),*(*(char)))->(char)
(	O
&	O
n	int
,	O
ibufp	*(char)
,	O
&	O
ibufp	*(char)
)	O
)	O
set_window_lines	(int)->(void)
(	O
n	int
)	O
;	O
else	O
return	O
ERR	int
;	O
}	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
||	O
!	O
display_lines	(int,int,int)->(char)
(	O
second_addr	int
,	O
min	O
(	O
last_addr	()->(int)
(	O
)	O
,	O
second_addr	int
+	O
window_lines	()->(int)
(	O
)	O
)	O
,	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
gflags	int
=	O
0	int
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
addr_cnt	*(int)
?	O
second_addr	int
:	O
last_addr	()->(int)
(	O
)	O
)	O
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
unexpected_address	(int)->(char)
(	O
addr_cnt	*(int)
)	O
)	O
return	O
ERR	int
;	O
n	int
=	O
get_shell_command	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
!	O
get_command_suffix	(*(int))->(char)
(	O
&	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
if	O
(	O
n	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
shcmd	*(char)
+	O
1	int
)	O
;	O
system	(*(char))->(int)
(	O
shcmd	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
scripted	()->(char)
(	O
)	O
)	O
printf	(*(char))->(int)
(	O
"!\n"	*(char)
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
first_addr	int
=	O
1	int
;	O
if	O
(	O
!	O
check_addr_range	(int,int,int)->(char)
(	O
first_addr	int
,	O
current_addr	()->(int)
(	O
)	O
+	O
(	O
traditional	()->(char)
(	O
)	O
||	O
!	O
isglobal	char
)	O
,	O
addr_cnt	*(int)
)	O
||	O
!	O
display_lines	(int,int,int)->(char)
(	O
second_addr	int
,	O
second_addr	int
,	O
0	int
)	O
)	O
return	O
ERR	int
;	O
break	O
;	O
case	O
'#'	O
:	O
while	O
(	O
*	O
ibufp	*(char)
++	O
!=	O
'\n'	O
)	O
;	O
break	O
;	O
default	O
:	O
set_error_msg	(*(char))->(void)
(	O
"Unknown command"	*(char)
)	O
;	O
return	O
ERR	int
;	O
}	O
if	O
(	O
gflags	int
&&	O
!	O
display_lines	(int,int,int)->(char)
(	O
current_addr	()->(int)
(	O
)	O
,	O
current_addr	()->(int)
(	O
)	O
,	O
gflags	int
)	O
)	O
return	O
ERR	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
exec_global	(*(char),int,char)->(char)
(	O
const	O
char	O
*	O
ibufp2	*(char)
,	O
int	O
gflags	int
,	O
const	O
char	O
interact	char
)	O
{	O
static	O
char	O
*	O
buf	*(*(char))
=	O
0	int
;	O
static	O
int	O
bufsz	int
=	O
0	int
;	O
const	O
line_t	struct(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)),long,int)
*	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
=	O
0	int
;	O
const	O
char	O
*	O
cmd	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
interact	char
)	O
{	O
if	O
(	O
traditional	()->(char)
(	O
)	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ibufp2	*(char)
,	O
"\n"	*(char)
)	O
)	O
cmd	*(char)
=	O
"p\n"	*(char)
;	O
else	O
if	O
(	O
!	O
(	O
cmd	*(char)
=	O
get_extended_line	(*(char),*(int),char)->(*(char))
(	O
ibufp2	*(char)
,	O
0	int
,	O
0	int
)	O
)	O
)	O
return	O
0	int
;	O
}	O
clear_undo_stack	()->(void)
(	O
)	O
;	O
while	O
(	O
(	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
=	O
next_active_node	()->(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))
(	O
)	O
)	O
)	O
{	O
set_current_addr	(int)->(void)
(	O
get_line_node_addr	(*(struct(*(struct(*`,*`,long,int)),*(struct(*`,*`,long,int)),long,int)))->(int)
(	O
lp	*(struct(*(struct(*(struct`),*(struct`),long,int)),*(struct(*(struct`),*(struct`),long,int)),long,int))
)	O
)	O
;	O
if	O
(	O
current_addr	()->(int)
(	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
interact	char
)	O
{	O
int	O
len	int
;	O
if	O
(	O
!	O
display_lines	(int,int,int)->(char)
(	O
current_addr	()->(int)
(	O
)	O
,	O
current_addr	()->(int)
(	O
)	O
,	O
gflags	int
)	O
)	O
return	O
0	int
;	O
do	O
{	O
ibufp2	*(char)
=	O
get_tty_line	(*(int))->(*(char))
(	O
&	O
len	int
)	O
;	O
}	O
while	O
(	O
ibufp2	*(char)
&&	O
len	int
>	O
0	int
&&	O
ibufp2	*(char)
[	O
len	int
-	O
1	int
]	O
!=	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
ibufp2	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Unexpected end-of-file"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
len	int
==	O
1	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ibufp2	*(char)
,	O
"\n"	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
len	int
==	O
2	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ibufp2	*(char)
,	O
"&\n"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
cmd	*(char)
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"No previous command"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
cmd	*(char)
=	O
get_extended_line	(*(char),*(int),char)->(*(char))
(	O
ibufp2	*(char)
,	O
&	O
len	int
,	O
0	int
)	O
)	O
)	O
return	O
0	int
;	O
else	O
{	O
if	O
(	O
!	O
resize_buffer	(*(*(char)),*(int),int)->(char)
(	O
&	O
buf	*(*(char))
,	O
&	O
bufsz	int
,	O
len	int
+	O
1	int
)	O
)	O
return	O
0	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(*(char))
,	O
cmd	*(char)
,	O
len	int
+	O
1	int
)	O
;	O
cmd	*(char)
=	O
buf	*(*(char))
;	O
}	O
}	O
ibufp	*(char)
=	O
cmd	*(char)
;	O
while	O
(	O
*	O
ibufp	*(char)
)	O
if	O
(	O
exec_command	(char)->(int)
(	O
1	int
)	O
<	O
0	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
main_loop	(char)->(int)
(	O
const	O
char	O
loose	char
)	O
{	O
extern	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
jmp_state	array(struct(array(long),int,struct(array(long))))
;	O
volatile	O
int	O
err_status	int
=	O
0	int
;	O
volatile	O
int	O
linenum	int
=	O
0	int
;	O
int	O
len	int
,	O
status	int
,	O
old_status	int
;	O
disable_interrupts	()->(void)
(	O
)	O
;	O
set_signals	()->(void)
(	O
)	O
;	O
status	int
=	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
jmp_state	array(struct(array(long),int,struct(array(long))))
)	O
;	O
if	O
(	O
!	O
status	int
)	O
enable_interrupts	()->(void)
(	O
)	O
;	O
else	O
{	O
status	int
=	O
-	O
1	int
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n?\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Interrupt"	*(char)
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
status	int
<	O
0	int
&&	O
verbose	char
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
errmsg	array(char)
)	O
;	O
if	O
(	O
prompt_on	char
)	O
{	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
prompt_str	array(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
ibufp	*(char)
=	O
get_tty_line	(*(int))->(*(char))
(	O
&	O
len	int
)	O
;	O
if	O
(	O
!	O
ibufp	*(char)
)	O
return	O
err_status	int
;	O
if	O
(	O
!	O
len	int
)	O
{	O
if	O
(	O
!	O
modified	()->(char)
(	O
)	O
||	O
scripted	()->(char)
(	O
)	O
)	O
return	O
err_status	int
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"?\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Warning: file modified"	*(char)
)	O
;	O
if	O
(	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
{	O
if	O
(	O
verbose	char
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"script, line %d: %s\n"	*(char)
,	O
linenum	int
,	O
errmsg	array(char)
)	O
;	O
return	O
2	int
;	O
}	O
set_modified	(char)->(void)
(	O
0	int
)	O
;	O
status	int
=	O
EMOD	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
ibufp	*(char)
[	O
len	int
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
set_error_msg	(*(char))->(void)
(	O
"Unexpected end-of-file"	*(char)
)	O
;	O
status	int
=	O
ERR	int
;	O
continue	O
;	O
}	O
else	O
++	O
linenum	int
;	O
old_status	int
=	O
status	int
;	O
status	int
=	O
exec_command	(char)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
return	O
err_status	int
;	O
if	O
(	O
status	int
==	O
EMOD	int
)	O
{	O
if	O
(	O
old_status	int
==	O
EMOD	int
)	O
return	O
err_status	int
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"?\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
set_error_msg	(*(char))->(void)
(	O
"Warning: file modified"	*(char)
)	O
;	O
if	O
(	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
{	O
if	O
(	O
verbose	char
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"script, line %d: %s\n"	*(char)
,	O
linenum	int
,	O
errmsg	array(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
status	int
==	O
FATAL	int
)	O
{	O
if	O
(	O
verbose	char
)	O
{	O
if	O
(	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"script, line %d: %s\n"	*(char)
,	O
linenum	int
,	O
errmsg	array(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
errmsg	array(char)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"?\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
is_regular_file	(int)->(char)
(	O
0	int
)	O
)	O
{	O
if	O
(	O
verbose	char
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"script, line %d: %s\n"	*(char)
,	O
linenum	int
,	O
errmsg	array(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
loose	char
)	O
err_status	int
=	O
1	int
;	O
}	O
}	O
void	O
set_error_msg	(*(char))->(void)
(	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
if	O
(	O
!	O
msg	*(char)
)	O
msg	*(char)
=	O
""	*(char)
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
errmsg	array(char)
,	O
msg	*(char)
,	O
sizeof	O
(	O
errmsg	array(char)
)	O
)	O
;	O
errmsg	array(char)
[	O
sizeof	O
(	O
errmsg	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
