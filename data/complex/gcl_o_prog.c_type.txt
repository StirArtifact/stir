FFD	(int)->(int)
(	O
Ftagbody	int
)	O
(	O
object	int
body	int
)	O
{	O
object	int
*	O
old_top	O
=	O
vs_top	O
;	O
object	int
*	O
VOL	O
new_top	O
;	O
object	int
*	O
tinf	O
;	O
object	int
*	O
VOL	O
tinf_base	O
;	O
object	int
*	O
env	O
=	O
lex_env	O
;	O
object	int
id	O
=	O
alloc_frame_id	O
(	O
)	O
;	O
VOL	O
object	int
bodysv	O
=	O
body	int
;	O
object	int
label	O
;	O
enum	O
type	O
item_type	enum
;	O
vs_push	()->(int)
(	O
id	O
)	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
tinf_base	O
=	O
vs_top	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
body	int
)	O
)	O
{	O
label	O
=	O
MMcar	()->(int)
(	O
body	int
)	O
;	O
item_type	enum
=	O
type_of	()->(int)
(	O
label	O
)	O
;	O
if	O
(	O
item_type	enum
==	O
t_symbol	O
||	O
item_type	enum
==	O
t_fixnum	O
||	O
item_type	enum
==	O
t_bignum	O
)	O
{	O
lex_tag_bind	()->(int)
(	O
label	O
,	O
id	O
)	O
;	O
vs_push	()->(int)
(	O
label	O
)	O
;	O
vs_push	()->(int)
(	O
MMcdr	()->(int)
(	O
body	int
)	O
)	O
;	O
}	O
body	int
=	O
MMcdr	()->(int)
(	O
body	int
)	O
;	O
}	O
new_top	O
=	O
vs_top	O
;	O
frs_push	()->(int)
(	O
FRS_CATCH	O
,	O
id	O
)	O
;	O
body	int
=	O
bodysv	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
label	O
=	O
cdr	()->(int)
(	O
nlj_tag	O
)	O
;	O
nlj_active	O
=	O
FALSE	O
;	O
for	O
(	O
tinf	O
=	O
tinf_base	O
;	O
tinf	O
<	O
new_top	O
&&	O
!	O
eql	()->(int)
(	O
tinf	O
[	O
0	int
]	O
,	O
label	O
)	O
;	O
tinf	O
+=	O
2	int
)	O
;	O
if	O
(	O
tinf	O
>=	O
new_top	O
)	O
FEerror	()->(int)
(	O
"Someone tried to RETURN-FROM a TAGBODY."	*(char)
,	O
0	int
)	O
;	O
body	int
=	O
tinf	O
[	O
1	int
]	O
;	O
}	O
while	O
(	O
body	int
!=	O
Cnil	O
)	O
{	O
vs_top	O
=	O
new_top	O
;	O
item_type	enum
=	O
type_of	()->(int)
(	O
MMcar	()->(int)
(	O
body	int
)	O
)	O
;	O
if	O
(	O
item_type	enum
!=	O
t_symbol	O
&&	O
item_type	enum
!=	O
t_fixnum	O
&&	O
item_type	enum
!=	O
t_bignum	O
)	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
body	int
)	O
)	O
;	O
body	int
=	O
MMcdr	()->(int)
(	O
body	int
)	O
;	O
}	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
env	O
;	O
vs_base	O
=	O
old_top	O
;	O
vs_top	O
=	O
old_top	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fprog	int
)	O
(	O
VOL	O
object	int
arg	int
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	int
body	int
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	()->(int)
(	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	int
=	O
let_bind	()->(int)
(	O
arg	int
->	O
c	O
.	O
c_cdr	O
,	O
start	*(struct)
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	int
*	O
)	O
start	*(struct)
;	O
vs_push	()->(int)
(	O
body	int
)	O
;	O
Ftagbody	int
(	O
body	int
)	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
FprogA	int
)	O
(	O
VOL	O
object	int
arg	int
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	int
body	int
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
make_nil_block	()->(int)
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	()->(int)
(	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	int
=	O
letA_bind	()->(int)
(	O
arg	int
->	O
c	O
.	O
c_cdr	O
,	O
start	*(struct)
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	int
*	O
)	O
start	*(struct)
;	O
vs_push	()->(int)
(	O
body	int
)	O
;	O
Ftagbody	int
(	O
body	int
)	O
;	O
END	O
:	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fgo	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
lex_tag	O
;	O
frame_ptr	O
fr	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
args	int
)	O
;	O
lex_tag	O
=	O
lex_tag_sch	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
if	O
(	O
MMnull	()->(int)
(	O
lex_tag	O
)	O
)	O
FEerror	()->(int)
(	O
"~S is an undefined tag."	*(char)
,	O
1	int
,	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
fr	O
=	O
frs_sch	()->(int)
(	O
MMcaddr	()->(int)
(	O
lex_tag	O
)	O
)	O
;	O
if	O
(	O
fr	O
==	O
NULL	O
)	O
FEerror	()->(int)
(	O
"The tag ~S is missing."	*(char)
,	O
1	int
,	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
MMcons	()->(int)
(	O
MMcaddr	()->(int)
(	O
lex_tag	O
)	O
,	O
MMcar	()->(int)
(	O
lex_tag	O
)	O
)	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
unwind	()->(int)
(	O
fr	O
,	O
vs_top	O
[	O
-	O
1	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fprogv	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
;	O
object	int
symbols	O
;	O
object	int
values	O
;	O
bds_ptr	O
old_bds_top	O
;	O
object	int
var	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
top	O
=	O
vs_top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
symbols	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_push	()->(int)
(	O
symbols	O
)	O
;	O
eval	()->(int)
(	O
MMcadr	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
values	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_push	()->(int)
(	O
values	O
)	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
symbols	O
)	O
)	O
{	O
var	O
=	O
MMcar	()->(int)
(	O
symbols	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
var	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
var	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
var	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEerror	()->(int)
(	O
"Cannot bind the constant ~S."	*(char)
,	O
1	int
,	O
var	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
values	O
)	O
)	O
{	O
bds_bind	()->(int)
(	O
var	O
,	O
OBJNULL	O
)	O
;	O
}	O
else	O
{	O
bds_bind	()->(int)
(	O
var	O
,	O
MMcar	()->(int)
(	O
values	O
)	O
)	O
;	O
values	O
=	O
MMcdr	()->(int)
(	O
values	O
)	O
;	O
}	O
symbols	O
=	O
MMcdr	()->(int)
(	O
symbols	O
)	O
;	O
}	O
Fprogn	()->(int)
(	O
MMcddr	()->(int)
(	O
args	int
)	O
)	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
FFD	(int)->(int)
(	O
Fprogn	()->(int)
)	O
(	O
object	int
body	int
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
body	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
body	int
)	O
)	O
;	O
body	int
=	O
MMcdr	()->(int)
(	O
body	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	()->(int)
(	O
body	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fprog1	int
)	O
(	O
object	int
arg	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
arg	int
=	O
MMcdr	()->(int)
(	O
arg	int
)	O
;	O
!	O
endp	()->(int)
(	O
arg	int
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
,	O
arg	int
=	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fprog2	int
)	O
(	O
object	int
arg	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
arg	int
=	O
MMcdr	()->(int)
(	O
arg	int
)	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
arg	int
=	O
MMcdr	()->(int)
(	O
arg	int
)	O
;	O
!	O
endp	()->(int)
(	O
arg	int
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
,	O
arg	int
=	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
void	O
gcl_init_prog	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"TAGBODY"	*(char)
,	O
Ftagbody	int
)	O
;	O
make_special_form	()->(int)
(	O
"PROG"	*(char)
,	O
Fprog	int
)	O
;	O
make_special_form	()->(int)
(	O
"PROG*"	*(char)
,	O
FprogA	int
)	O
;	O
make_special_form	()->(int)
(	O
"GO"	*(char)
,	O
Fgo	int
)	O
;	O
make_special_form	()->(int)
(	O
"PROGV"	*(char)
,	O
Fprogv	int
)	O
;	O
sLprogn	O
=	O
make_special_form	()->(int)
(	O
"PROGN"	*(char)
,	O
Fprogn	()->(int)
)	O
;	O
make_special_form	()->(int)
(	O
"PROG1"	*(char)
,	O
Fprog1	int
)	O
;	O
make_special_form	()->(int)
(	O
"PROG2"	*(char)
,	O
Fprog2	int
)	O
;	O
}	O
