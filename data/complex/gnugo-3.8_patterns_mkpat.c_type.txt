static	O
const	O
char	O
VALID_PATTERN_CHARS	O
[	O
]	O
=	O
".XOxo,a!*?QY"	*(char)
;	O
static	O
const	O
char	O
VALID_EDGE_CHARS	O
[	O
]	O
=	O
"+-|"	*(char)
;	O
static	O
const	O
char	O
VALID_CONSTRAINT_LABELS	O
[	O
]	O
=	O
"abcdefghijklmnpqrstuvwyzABCDEFGHIJKLMNPRSTUVWZ"	*(char)
;	O
static	O
int	O
nongoal	O
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
int	O
callback_unneeded	O
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
int	O
maxi	int
,	O
maxj	int
;	O
static	O
int	O
mini	int
,	O
minj	int
;	O
static	O
int	O
movei	O
,	O
movej	O
;	O
static	O
unsigned	O
int	O
where	O
;	O
static	O
int	O
el	O
;	O
static	O
struct	O
patval_b	struct(int,int,int)
elements	*(struct(int,int,int))
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
num_stars	O
;	O
static	O
int	O
ci	int
=	O
-	O
1	int
,	O
cj	int
=	O
-	O
1	int
;	O
static	O
int	O
patno	O
;	O
static	O
int	O
discard_pattern	O
=	O
0	int
;	O
static	O
int	O
pats_with_constraints	O
=	O
0	int
;	O
static	O
int	O
label_coords	O
[	O
256	int
]	O
[	O
2	int
]	O
;	O
static	O
int	O
current_c_i	O
;	O
static	O
char	O
constraint	O
[	O
MAXCONSTRAINT	O
]	O
;	O
static	O
char	O
action	int
[	O
MAXCONSTRAINT	O
]	O
;	O
static	O
char	O
diagram	O
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
3	int
]	O
;	O
static	O
char	O
constraint_diagram	O
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
3	int
]	O
;	O
static	O
char	O
*	O
prefix	O
;	O
static	O
struct	O
pattern	*(struct)
pattern	*(struct)
[	O
MAXPATNO	O
]	O
;	O
static	O
char	O
pattern_names	O
[	O
MAXPATNO	O
]	O
[	O
MAXNAME	O
]	O
;	O
static	O
int	O
num_attributes	O
;	O
static	O
struct	O
pattern_attribute	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
MAXPATNO	O
*	O
NUM_ATTRIBUTES	int
]	O
;	O
static	O
char	O
helper_fn_names	O
[	O
MAXPATNO	O
]	O
[	O
MAXNAME	O
]	O
;	O
static	O
char	O
autohelper_code	O
[	O
MAXPATNO	O
*	O
300	int
]	O
;	O
static	O
char	O
*	O
code_pos	O
;	O
struct	O
autohelper_func	O
{	O
const	O
char	O
*	O
name	short
;	O
int	O
params	array(int)
;	O
int	O
type	char
;	O
float	O
cost	O
;	O
const	O
char	O
*	O
code	int
;	O
}	O
;	O
static	O
const	O
char	O
*	O
current_file	O
=	O
NULL	O
;	O
static	O
int	O
current_line_number	O
=	O
0	int
;	O
struct	O
attribute_description	O
{	O
const	O
char	O
*	O
input_name	O
;	O
enum	O
attribute_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int)
type	char
;	O
}	O
;	O
static	O
const	O
char	O
*	O
attribute_name	O
[	O
NUM_ATTRIBUTES	int
+	O
1	int
]	O
=	O
{	O
"MIN_VALUE"	*(char)
,	O
"MAX_VALUE"	*(char)
,	O
"MIN_TERRITORY"	*(char)
,	O
"MAX_TERRITORY"	*(char)
,	O
"SHAPE"	*(char)
,	O
"FOLLOWUP"	*(char)
,	O
"REVERSE_FOLLOWUP"	*(char)
,	O
"THREATENS_TO_CAPTURE"	*(char)
,	O
"THREATENS_EYE"	*(char)
,	O
"REVERSE_SENTE"	*(char)
,	O
"LAST_ATTRIBUTE"	*(char)
}	O
;	O
static	O
struct	O
attribute_description	O
general_attribute_map	O
[	O
]	O
=	O
{	O
{	O
"value"	*(char)
,	O
MIN_VALUE	int
}	O
,	O
{	O
"minvalue"	*(char)
,	O
MIN_VALUE	int
}	O
,	O
{	O
"maxvalue"	*(char)
,	O
MAX_VALUE	int
}	O
,	O
{	O
"terri"	*(char)
,	O
MIN_TERRITORY	int
}	O
,	O
{	O
"minterri"	*(char)
,	O
MIN_TERRITORY	int
}	O
,	O
{	O
"maxterri"	*(char)
,	O
MAX_TERRITORY	int
}	O
,	O
{	O
"shape"	*(char)
,	O
SHAPE	int
}	O
,	O
{	O
"followup"	*(char)
,	O
FOLLOWUP	int
}	O
,	O
{	O
"followup_value"	*(char)
,	O
FOLLOWUP	int
}	O
,	O
{	O
"reverse_followup"	*(char)
,	O
REVERSE_FOLLOWUP	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	O
value_only_attribute_map	O
[	O
]	O
=	O
{	O
{	O
"value"	*(char)
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	O
owl_attack_attribute_map	O
[	O
]	O
=	O
{	O
{	O
"value"	*(char)
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
"threatens_to_capture"	*(char)
,	O
THREATENS_TO_CAPTURE	int
}	O
,	O
{	O
"threatens_eye"	*(char)
,	O
THREATENS_EYE	int
}	O
,	O
{	O
"reverse_sente"	*(char)
,	O
REVERSE_SENTE	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	O
owl_defense_attribute_map	O
[	O
]	O
=	O
{	O
{	O
"value"	*(char)
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
"threatens_to_capture"	*(char)
,	O
THREATENS_TO_CAPTURE	int
}	O
,	O
{	O
"threatens_eye"	*(char)
,	O
THREATENS_EYE	int
}	O
,	O
{	O
"reverse_sente"	*(char)
,	O
REVERSE_SENTE	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	O
*	O
attribute_map	O
=	O
NULL	O
;	O
static	O
int	O
attributes_needed	O
=	O
0	int
;	O
static	O
struct	O
autohelper_func	O
autohelper_functions	O
[	O
]	O
=	O
{	O
{	O
"lib2"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties2"	*(char)
}	O
,	O
{	O
"lib3"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties3"	*(char)
}	O
,	O
{	O
"lib4"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties4"	*(char)
}	O
,	O
{	O
"lib"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"countlib(%s)"	*(char)
}	O
,	O
{	O
"alive"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == ALIVE)"	*(char)
}	O
,	O
{	O
"unknown"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == UNKNOWN)"	*(char)
}	O
,	O
{	O
"critical"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == CRITICAL)"	*(char)
}	O
,	O
{	O
"dead"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == DEAD)"	*(char)
}	O
,	O
{	O
"status"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].status"	*(char)
}	O
,	O
{	O
"ko"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_ko_point(%s)"	*(char)
}	O
,	O
{	O
"xdefend_against"	*(char)
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against(%s, OTHER_COLOR(color), %s)"	*(char)
}	O
,	O
{	O
"odefend_against"	*(char)
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against(%s, color, %s)"	*(char)
}	O
,	O
{	O
"defend_against_atari"	*(char)
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against_atari_helper(move, %s)"	*(char)
}	O
,	O
{	O
"does_defend"	*(char)
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_defend(%s, %s)"	*(char)
}	O
,	O
{	O
"does_attack"	*(char)
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_attack(%s, %s)"	*(char)
}	O
,	O
{	O
"attack"	*(char)
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"ATTACK_MACRO(%s)"	*(char)
}	O
,	O
{	O
"defend"	*(char)
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"DEFEND_MACRO(%s)"	*(char)
}	O
,	O
{	O
"weakness"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon_weakness(%s, 0)"	*(char)
}	O
,	O
{	O
"weak"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon_weak(%s)"	*(char)
}	O
,	O
{	O
"safe_xmove"	*(char)
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"safe_move(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"safe_omove"	*(char)
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"safe_move(%s, color)"	*(char)
}	O
,	O
{	O
"legal_xmove"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_legal(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"legal_omove"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_legal(%s, color)"	*(char)
}	O
,	O
{	O
"x_suicide"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_suicide(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"o_suicide"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_suicide(%s, color)"	*(char)
}	O
,	O
{	O
"x_alive_somewhere"	*(char)
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(OTHER_COLOR(color), 1, %d"	*(char)
}	O
,	O
{	O
"o_alive_somewhere"	*(char)
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(color, 1, %d"	*(char)
}	O
,	O
{	O
"x_somewhere"	*(char)
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(OTHER_COLOR(color), 0, %d"	*(char)
}	O
,	O
{	O
"o_somewhere"	*(char)
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(color, 0, %d"	*(char)
}	O
,	O
{	O
"xmoyo_opposite"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(INITIAL_INFLUENCE(color), %s) == OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"omoyo_opposite"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(INITIAL_INFLUENCE(color), %s) == color)"	*(char)
}	O
,	O
{	O
"xmoyo"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"omoyo"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(OPPOSITE_INFLUENCE(color), %s) == color)"	*(char)
}	O
,	O
{	O
"xarea"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_area(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"oarea"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_area(OPPOSITE_INFLUENCE(color), %s) == color)"	*(char)
}	O
,	O
{	O
"xterri"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_territory(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"oterri"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_territory(OPPOSITE_INFLUENCE(color), %s) == color)"	*(char)
}	O
,	O
{	O
"genus"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].genus"	*(char)
}	O
,	O
{	O
"approx_xlib"	*(char)
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"approxlib(%s, OTHER_COLOR(color), MAX_LIBERTIES, NULL)"	*(char)
}	O
,	O
{	O
"approx_olib"	*(char)
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"approxlib(%s, color, MAX_LIBERTIES, NULL)"	*(char)
}	O
,	O
{	O
"xlib"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"accuratelib(%s, OTHER_COLOR(color), MAX_LIBERTIES, NULL)"	*(char)
}	O
,	O
{	O
"olib"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"accuratelib(%s, color, MAX_LIBERTIES, NULL)"	*(char)
}	O
,	O
{	O
"xcut"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"cut_possible(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"ocut"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"cut_possible(%s, color)"	*(char)
}	O
,	O
{	O
"edge_double_sente"	*(char)
,	O
4	int
,	O
1	int
,	O
3.00	int
,	O
"edge_double_sente_helper(%s, %s, %s, %s)"	*(char)
}	O
,	O
{	O
"xplay_defend_both"	*(char)
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(OTHER_COLOR(color), 0, %d"	*(char)
}	O
,	O
{	O
"oplay_defend_both"	*(char)
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(color, 0, %d"	*(char)
}	O
,	O
{	O
"xplay_attack_either"	*(char)
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(OTHER_COLOR(color), 1, %d"	*(char)
}	O
,	O
{	O
"oplay_attack_either"	*(char)
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(color, 1, %d"	*(char)
}	O
,	O
{	O
"xplay_defend"	*(char)
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(OTHER_COLOR(color), 0, %d"	*(char)
}	O
,	O
{	O
"oplay_defend"	*(char)
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(color, 0, %d"	*(char)
}	O
,	O
{	O
"xplay_attack"	*(char)
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(OTHER_COLOR(color), 1, %d"	*(char)
}	O
,	O
{	O
"oplay_attack"	*(char)
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(color, 1, %d"	*(char)
}	O
,	O
{	O
"xplay_break_through"	*(char)
,	O
3	int
,	O
1	int
,	O
5.00	int
,	O
"play_break_through_n(OTHER_COLOR(color), %d"	*(char)
}	O
,	O
{	O
"oplay_break_through"	*(char)
,	O
3	int
,	O
1	int
,	O
5.00	int
,	O
"play_break_through_n(color, %d"	*(char)
}	O
,	O
{	O
"oplay_connect"	*(char)
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(color, 1, %d"	*(char)
}	O
,	O
{	O
"xplay_connect"	*(char)
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(OTHER_COLOR(color), 1, %d"	*(char)
}	O
,	O
{	O
"oplay_disconnect"	*(char)
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(color, 0, %d"	*(char)
}	O
,	O
{	O
"xplay_disconnect"	*(char)
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(OTHER_COLOR(color), 0, %d"	*(char)
}	O
,	O
{	O
"oplay_lib"	*(char)
,	O
1	int
,	O
1	int
,	O
0.06	int
,	O
"play_lib_n(color, %d"	*(char)
}	O
,	O
{	O
"xplay_lib"	*(char)
,	O
1	int
,	O
1	int
,	O
0.06	int
,	O
"play_lib_n(OTHER_COLOR(color), %d"	*(char)
}	O
,	O
{	O
"seki_helper"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"seki_helper(%s)"	*(char)
}	O
,	O
{	O
"threaten_to_save"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"threaten_to_save_helper(move,%s)"	*(char)
}	O
,	O
{	O
"threaten_to_capture"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"threaten_to_capture_helper(move,%s)"	*(char)
}	O
,	O
{	O
"prevent_attack_threat"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"prevent_attack_threat_helper(move, %s)"	*(char)
}	O
,	O
{	O
"eye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_eye_space(%s)"	*(char)
}	O
,	O
{	O
"proper_eye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_proper_eye_space(%s)"	*(char)
}	O
,	O
{	O
"marginal_eye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_marginal_eye_space(%s)"	*(char)
}	O
,	O
{	O
"halfeye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_halfeye(half_eye,%s)"	*(char)
}	O
,	O
{	O
"max_eye_value"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"max_eye_value(%s)"	*(char)
}	O
,	O
{	O
"owl_topological_eye"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"owl_topological_eye(%s, board[%s])"	*(char)
}	O
,	O
{	O
"obvious_false_oeye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"obvious_false_eye(%s, color)"	*(char)
}	O
,	O
{	O
"obvious_false_xeye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"obvious_false_eye(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"antisuji"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"add_antisuji_move(%s)"	*(char)
}	O
,	O
{	O
"add_connect_move"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_connection_move(move,%s, %s)"	*(char)
}	O
,	O
{	O
"add_cut_move"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_cut_move(move, %s, %s)"	*(char)
}	O
,	O
{	O
"test_attack_either_move"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"test_attack_either_move(move, color, %s, %s)"	*(char)
}	O
,	O
{	O
"add_defend_both_move"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_all_move(move, DEFEND_STRING, %s, DEFEND_STRING, %s)"	*(char)
}	O
,	O
{	O
"same_dragon"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"is_same_dragon(%s, %s)"	*(char)
}	O
,	O
{	O
"same_string"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"same_string(%s, %s)"	*(char)
}	O
,	O
{	O
"dragonsize"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].size"	*(char)
}	O
,	O
{	O
"wormsize"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"countstones(%s)"	*(char)
}	O
,	O
{	O
"effective_size"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].effective_size"	*(char)
}	O
,	O
{	O
"vital_chain"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"vital_chain(%s)"	*(char)
}	O
,	O
{	O
"potential_cutstone"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].cutstone2 > 1"	*(char)
}	O
,	O
{	O
"amalgamate_most_valuable_helper"	*(char)
,	O
3	int
,	O
0	int
,	O
0.0	int
,	O
"amalgamate_most_valuable_helper(%s, %s, %s)"	*(char)
}	O
,	O
{	O
"amalgamate"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"join_dragons(%s, %s)"	*(char)
}	O
,	O
{	O
"owl_escape_value"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_escape_value(%s)"	*(char)
}	O
,	O
{	O
"owl_goal_dragon"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_goal_dragon(%s)"	*(char)
}	O
,	O
{	O
"owl_eyespace"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_eyespace(%s)"	*(char)
}	O
,	O
{	O
"owl_big_eyespace"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_big_eyespace(%s)"	*(char)
}	O
,	O
{	O
"owl_mineye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_mineye(%s)"	*(char)
}	O
,	O
{	O
"owl_maxeye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_maxeye(%s)"	*(char)
}	O
,	O
{	O
"owl_proper_eye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_proper_eye(%s)"	*(char)
}	O
,	O
{	O
"owl_eye_size"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_eye_size(%s)"	*(char)
}	O
,	O
{	O
"owl_lunch"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_lunch(%s)"	*(char)
}	O
,	O
{	O
"owl_strong_dragon"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_strong_dragon(%s)"	*(char)
}	O
,	O
{	O
"has_aji"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].owl_threat_status == CAN_THREATEN_DEFENSE)"	*(char)
}	O
,	O
{	O
"finish_ko_helper"	*(char)
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"finish_ko_helper(%s)"	*(char)
}	O
,	O
{	O
"squeeze_ko_helper"	*(char)
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"squeeze_ko_helper(%s)"	*(char)
}	O
,	O
{	O
"backfill_helper"	*(char)
,	O
3	int
,	O
0	int
,	O
1.50	int
,	O
"backfill_helper(%s, %s, %s)"	*(char)
}	O
,	O
{	O
"connect_and_cut_helper2"	*(char)
,	O
3	int
,	O
0	int
,	O
3.00	int
,	O
"connect_and_cut_helper2(%s, %s, %s, color)"	*(char)
}	O
,	O
{	O
"connect_and_cut_helper"	*(char)
,	O
3	int
,	O
0	int
,	O
3.00	int
,	O
"connect_and_cut_helper(%s, %s, %s)"	*(char)
}	O
,	O
{	O
"owl_threatens"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"owl_threatens_attack(%s, %s)"	*(char)
}	O
,	O
{	O
"replace"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_replacement_move(%s, %s, color)"	*(char)
}	O
,	O
{	O
"backfill_replace"	*(char)
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"backfill_replace(%s, %s)"	*(char)
}	O
,	O
{	O
"non_oterritory"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"influence_mark_non_territory(%s, color)"	*(char)
}	O
,	O
{	O
"non_xterritory"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"influence_mark_non_territory(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"remaining_handicap_stones"	*(char)
,	O
0	int
,	O
0	int
,	O
0.0	int
,	O
"free_handicap_remaining_stones()"	*(char)
}	O
,	O
{	O
"total_handicap_stones"	*(char)
,	O
0	int
,	O
0	int
,	O
0.0	int
,	O
"free_handicap_total_stones()"	*(char)
}	O
,	O
{	O
"o_captures_something"	*(char)
,	O
1	int
,	O
0	int
,	O
0.02	int
,	O
"does_capture_something(%s, color)"	*(char)
}	O
,	O
{	O
"x_captures_something"	*(char)
,	O
1	int
,	O
0	int
,	O
0.02	int
,	O
"does_capture_something(%s, OTHER_COLOR(color))"	*(char)
}	O
,	O
{	O
"false_eye_territory"	*(char)
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"false_eye_territory[%s]"	*(char)
}	O
,	O
{	O
"false_eye"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_false_eye(half_eye, %s)"	*(char)
}	O
,	O
{	O
"o_visible_along_edge"	*(char)
,	O
2	int
,	O
0	int
,	O
0.05	int
,	O
"visible_along_edge(color,%s,%s)"	*(char)
}	O
,	O
{	O
"x_visible_along_edge"	*(char)
,	O
2	int
,	O
0	int
,	O
0.05	int
,	O
"visible_along_edge(OTHER_COLOR(color),%s,%s)"	*(char)
}	O
,	O
{	O
"is_surrounded"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_surrounded(%s)"	*(char)
}	O
,	O
{	O
"does_surround"	*(char)
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_surround(%s, %s)"	*(char)
}	O
,	O
{	O
"surround_map"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"surround_map(%s, %s)"	*(char)
}	O
,	O
{	O
"oracle_threatens"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"oracle_threatens(%s, %s)"	*(char)
}	O
,	O
{	O
"value"	*(char)
,	O
0	int
,	O
2	int
,	O
0.0	int
,	O
"(%s->value)"	*(char)
}	O
,	O
{	O
"adjacent_to_stone_in_atari"	*(char)
,	O
1	int
,	O
0	int
,	O
1.0	int
,	O
"adjacent_to_stone_in_atari(%s)"	*(char)
}	O
,	O
{	O
"adjacent_to_defendable_stone_in_atari"	*(char)
,	O
1	int
,	O
0	int
,	O
1.0	int
,	O
"adjacent_to_defendable_stone_in_atari(%s)"	*(char)
}	O
,	O
{	O
"good_attack_threat"	*(char)
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"register_good_attack_threat(%s, %s)"	*(char)
}	O
,	O
{	O
"known_safe_move"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"register_known_safe_move(%s)"	*(char)
}	O
,	O
{	O
"break_mirror_helper"	*(char)
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"break_mirror_helper(%s, color)"	*(char)
}	O
}	O
;	O
static	O
int	O
dummyhelper	O
(	O
int	O
transformation	array(array(int))
,	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
action	int
)	O
{	O
UNUSED	O
(	O
transformation	array(array(int))
)	O
;	O
UNUSED	O
(	O
move	*(int)
)	O
;	O
UNUSED	O
(	O
color	int
)	O
;	O
UNUSED	O
(	O
action	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
fatal_errors	O
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
static	O
int	O
database_type	O
=	O
0	int
;	O
static	O
int	O
anchor	int
=	O
0	int
;	O
static	O
int	O
choose_best_anchor	O
=	O
0	int
;	O
static	O
int	O
fixed_anchor	int
=	O
0	int
;	O
static	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
;	O
static	O
dfa_patterns	O
dfa_pats	O
;	O
static	O
int	O
transformation_hint	O
;	O
static	O
int	O
labels_transformation	O
=	O
0	int
;	O
struct	O
hint_data	O
{	O
char	O
name	short
[	O
MAXNAME	O
]	O
;	O
int	O
transformation_hint	O
;	O
struct	O
hint_data	O
*	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
;	O
static	O
struct	O
hint_data	O
*	O
first_hint	O
=	O
NULL	O
;	O
static	O
void	O
parse_transformations_file	O
(	O
FILE	struct
*	O
file	*(char)
)	O
{	O
struct	O
hint_data	O
*	O
*	O
link	O
=	O
&	O
first_hint	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
)	O
{	O
int	O
n	int
;	O
struct	O
hint_data	O
*	O
hint	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
hint	O
)	O
)	O
;	O
n	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"%s %d"	*(char)
,	O
hint	O
->	O
name	short
,	O
&	O
hint	O
->	O
transformation_hint	O
)	O
;	O
if	O
(	O
n	int
==	O
2	int
)	O
{	O
hint	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
NULL	O
;	O
*	O
link	O
=	O
hint	O
;	O
link	O
=	O
&	O
hint	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
else	O
free	(*(void))->(void)
(	O
hint	O
)	O
;	O
}	O
}	O
static	O
int	O
find_transformation_hint	O
(	O
const	O
char	O
*	O
pattern_name	O
)	O
{	O
struct	O
hint_data	O
*	O
hint	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
||	O
database_type	O
==	O
OPTIMIZE_DFA	O
)	O
{	O
for	O
(	O
hint	O
=	O
first_hint	O
;	O
hint	O
;	O
hint	O
=	O
hint	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
hint	O
->	O
name	short
,	O
pattern_name	O
)	O
)	O
return	O
hint	O
->	O
transformation_hint	O
;	O
}	O
}	O
return	O
database_type	O
==	O
OPTIMIZE_DFA	O
?	O
-	O
1	int
:	O
0	int
;	O
}	O
static	O
void	O
check_constraint_diagram	O
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
,	O
ino	O
=	O
0	int
,	O
iso	O
=	O
0	int
,	O
jwo	O
=	O
0	int
;	O
int	O
have_constraint	O
=	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	O
)	O
;	O
if	O
(	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"patno: %d\n"	*(char)
,	O
patno	O
)	O
;	O
if	O
(	O
where	O
&	O
NORTH_EDGE	O
)	O
ino	O
=	O
1	int
;	O
if	O
(	O
where	O
&	O
SOUTH_EDGE	O
)	O
iso	O
=	O
1	int
;	O
if	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
jwo	O
=	O
1	int
;	O
if	O
(	O
verbose	int
)	O
{	O
for	O
(	O
i	int
=	O
ino	O
;	O
i	int
<=	O
maxi	int
+	O
ino	O
+	O
iso	O
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%02d %s\n"	*(char)
,	O
i	int
,	O
diagram	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
ino	O
;	O
i	int
<=	O
maxi	int
+	O
ino	O
+	O
iso	O
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%02d %s\n"	*(char)
,	O
i	int
,	O
constraint_diagram	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"have_constraint: %d\n"	*(char)
,	O
have_constraint	O
)	O
;	O
if	O
(	O
have_constraint	O
&&	O
el	O
)	O
{	O
for	O
(	O
i	int
=	O
ino	O
;	O
i	int
<=	O
maxi	int
+	O
ino	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
jwo	O
;	O
j	int
<=	O
maxj	int
+	O
jwo	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%2d %2d %c %c\n"	*(char)
,	O
i	int
,	O
j	int
,	O
constraint_diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
,	O
diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
CHECK_CHARS	O
,	O
constraint_diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
)	O
&&	O
constraint_diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
!=	O
diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : "	*(char)
"xXoO not matched in constraint diagram of pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
reset_pattern	O
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
maxi	int
=	O
0	int
;	O
maxj	int
=	O
0	int
;	O
ci	int
=	O
-	O
1	int
;	O
cj	int
=	O
-	O
1	int
;	O
where	O
=	O
0	int
;	O
el	O
=	O
0	int
;	O
num_stars	O
=	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
helper_fn_names	O
[	O
patno	O
]	O
,	O
"NULL"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
label_coords	O
[	O
i	int
]	O
[	O
0	int
]	O
=	O
-	O
1	int
;	O
current_c_i	O
=	O
0	int
;	O
constraint	O
[	O
0	int
]	O
=	O
0	int
;	O
action	int
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_BOARD	int
+	O
2	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX_BOARD	int
+	O
3	int
;	O
j	int
++	O
)	O
{	O
diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'\0'	O
;	O
constraint_diagram	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
pattern	*(struct)
[	O
patno	O
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
pattern	*(struct)
)	O
)	O
;	O
}	O
static	O
void	O
find_extents	O
(	O
void	O
)	O
{	O
--	O
maxi	int
;	O
--	O
maxj	int
;	O
if	O
(	O
where	O
&	O
(	O
NORTH_EDGE	O
|	O
SOUTH_EDGE	O
|	O
EAST_EDGE	O
|	O
WEST_EDGE	O
)	O
)	O
++	O
pats_with_constraints	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Pattern %s has constraints 0x%x\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
,	O
where	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
edge_constraints	int
=	O
where	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
mini	int
=	O
mini	int
-	O
ci	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
minj	int
=	O
minj	int
-	O
cj	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
maxi	int
=	O
maxi	int
-	O
ci	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
maxj	int
=	O
maxj	int
-	O
cj	int
;	O
}	O
static	O
void	O
write_to_dfa	O
(	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
char	O
str	int
[	O
DFA_MAX_ORDER	O
+	O
1	int
]	O
;	O
char	O
strrot	*(char)
[	O
DFA_MAX_ORDER	O
+	O
1	int
]	O
;	O
assert	O
(	O
ci	int
!=	O
-	O
1	int
&&	O
cj	int
!=	O
-	O
1	int
)	O
;	O
pattern	*(struct)
[	O
index	(*(char),int)->(*(char))
]	O
.	O
name	short
=	O
&	O
(	O
pattern_names	O
[	O
index	(*(char),int)->(*(char))
]	O
[	O
0	int
]	O
)	O
;	O
pattern_2_string	(*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct(int,int,int)),*(char),int,int)->(void)
(	O
pattern	*(struct)
+	O
index	(*(char),int)->(*(char))
,	O
elements	*(struct(int,int,int))
,	O
str	int
,	O
ci	int
,	O
cj	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Add   :%s\n"	*(char)
,	O
pattern	*(struct)
[	O
index	(*(char),int)->(*(char))
]	O
.	O
name	short
)	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
{	O
float	O
ratio	O
;	O
dfa_rotate_string	(*(char),*(char),int)->(void)
(	O
strrot	*(char)
,	O
str	int
,	O
transformation_hint	O
)	O
;	O
ratio	O
=	O
(	O
(	O
dfa_add_string	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char),int,int)->(float)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
,	O
strrot	*(char)
,	O
index	(*(char),int)->(*(char))
,	O
transformation_hint	O
)	O
-	O
1.0	int
)	O
*	O
100	int
)	O
;	O
if	O
(	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
>	O
100	int
&&	O
ratio	O
>	O
10.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Pattern %s => %3.1f%% increase: "	*(char)
,	O
pattern	*(struct)
[	O
index	(*(char),int)->(*(char))
]	O
.	O
name	short
,	O
ratio	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"another orientation may save memory.\n"	*(char)
)	O
;	O
}	O
if	O
(	O
dfa_verbose	int
>	O
2	int
)	O
dump_dfa	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
;	O
labels_transformation	O
=	O
transformation_hint	O
;	O
}	O
else	O
{	O
int	O
ll	int
;	O
int	O
rot_start	O
=	O
0	int
;	O
int	O
rot_stop	O
=	O
pattern	*(struct)
[	O
index	(*(char),int)->(*(char))
]	O
.	O
trfno	int
;	O
assert	O
(	O
database_type	O
==	O
OPTIMIZE_DFA	O
)	O
;	O
if	O
(	O
rot_stop	O
==	O
5	int
)	O
{	O
rot_start	O
=	O
2	int
;	O
rot_stop	O
=	O
6	int
;	O
}	O
for	O
(	O
ll	int
=	O
rot_start	O
;	O
ll	int
<	O
rot_stop	O
;	O
ll	int
++	O
)	O
{	O
dfa_rotate_string	(*(char),*(char),int)->(void)
(	O
strrot	*(char)
,	O
str	int
,	O
ll	int
)	O
;	O
dfa_patterns_add_pattern	O
(	O
&	O
dfa_pats	O
,	O
strrot	*(char)
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
if	O
(	O
transformation_hint	O
==	O
-	O
1	int
)	O
dfa_patterns_select_shortest_variation	O
(	O
&	O
dfa_pats	O
)	O
;	O
else	O
{	O
dfa_patterns_set_last_pattern_variation	O
(	O
&	O
dfa_pats	O
,	O
(	O
transformation_hint	O
-	O
rot_start	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
compute_grids	O
(	O
void	O
)	O
{	O
static	O
const	O
unsigned	O
int	O
and_mask	array(int)
[	O
]	O
=	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
static	O
const	O
unsigned	O
int	O
val_mask	array(int)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
ll	int
;	O
int	O
k	int
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
el	O
;	O
++	O
k	int
)	O
{	O
int	O
ti	O
,	O
tj	O
;	O
int	O
di	O
,	O
dj	O
;	O
TRANSFORM2	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
,	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
,	O
&	O
ti	O
,	O
&	O
tj	O
,	O
transformation_hint	O
)	O
;	O
TRANSFORM2	O
(	O
ti	O
,	O
tj	O
,	O
&	O
di	O
,	O
&	O
dj	O
,	O
ll	int
)	O
;	O
++	O
di	O
;	O
++	O
dj	O
;	O
if	O
(	O
di	O
>=	O
0	int
&&	O
di	O
<	O
4	int
&&	O
dj	O
>=	O
0	int
&&	O
dj	O
<	O
4	int
)	O
{	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
and_mask	array(int)
[	O
ll	int
]	O
|=	O
and_mask	array(int)
[	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
]	O
<<	O
(	O
30	int
-	O
di	O
*	O
8	int
-	O
dj	O
*	O
2	int
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
val_mask	array(int)
[	O
ll	int
]	O
|=	O
val_mask	array(int)
[	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
]	O
<<	O
(	O
30	int
-	O
di	O
*	O
8	int
-	O
dj	O
*	O
2	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
read_pattern_line	O
(	O
char	O
*	O
p	O
)	O
{	O
const	O
char	O
*	O
char_offset	O
;	O
char	O
*	O
pcopy	O
=	O
p	O
;	O
int	O
j	int
;	O
int	O
width	int
;	O
int	O
jwo	O
=	O
0	int
,	O
jeo	O
=	O
0	int
;	O
if	O
(	O
where	O
&	O
SOUTH_EDGE	O
)	O
goto	O
fatal	O
;	O
if	O
(	O
*	O
p	O
==	O
'+'	O
||	O
*	O
p	O
==	O
'-'	O
)	O
{	O
if	O
(	O
maxi	int
==	O
0	int
)	O
where	O
|=	O
NORTH_EDGE	O
;	O
else	O
where	O
|=	O
SOUTH_EDGE	O
;	O
if	O
(	O
*	O
p	O
==	O
'+'	O
)	O
{	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
!	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
)	O
goto	O
fatal	O
;	O
where	O
|=	O
WEST_EDGE	O
;	O
++	O
p	O
;	O
}	O
for	O
(	O
width	int
=	O
0	int
;	O
*	O
p	O
==	O
'-'	O
;	O
++	O
p	O
,	O
++	O
width	int
)	O
;	O
if	O
(	O
width	int
==	O
0	int
)	O
goto	O
fatal	O
;	O
if	O
(	O
*	O
p	O
==	O
'+'	O
)	O
{	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
!	O
(	O
where	O
&	O
EAST_EDGE	O
)	O
)	O
goto	O
fatal	O
;	O
where	O
|=	O
EAST_EDGE	O
;	O
}	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
width	int
!=	O
maxj	int
)	O
goto	O
notrectangle	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
p	O
==	O
'|'	O
)	O
{	O
if	O
(	O
!	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
&&	O
(	O
(	O
where	O
&	O
NORTH_EDGE	O
)	O
||	O
maxi	int
>	O
0	int
)	O
)	O
goto	O
fatal	O
;	O
where	O
|=	O
WEST_EDGE	O
;	O
++	O
p	O
;	O
}	O
else	O
if	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
goto	O
fatal	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
char_offset	O
=	O
strchr	(*(char),int)->(*(char))
(	O
VALID_PATTERN_CHARS	O
,	O
*	O
p	O
)	O
)	O
!=	O
NULL	O
;	O
++	O
j	int
,	O
++	O
p	O
)	O
{	O
int	O
off	O
=	O
char_offset	O
-	O
VALID_PATTERN_CHARS	O
;	O
if	O
(	O
off	O
==	O
ATT_wild	O
)	O
continue	O
;	O
if	O
(	O
off	O
==	O
ATT_a	O
)	O
goto	O
fatal	O
;	O
if	O
(	O
off	O
==	O
ATT_star	O
)	O
{	O
movei	O
=	O
maxi	int
;	O
movej	O
=	O
j	int
;	O
++	O
num_stars	O
;	O
off	O
=	O
ATT_dot	O
;	O
}	O
if	O
(	O
off	O
==	O
ATT_Q	O
)	O
{	O
off	O
=	O
ATT_O	O
;	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
anchored_at_X	int
=	O
(	O
off	O
==	O
ATT_X	O
)	O
?	O
3	int
:	O
0	int
;	O
}	O
if	O
(	O
off	O
==	O
ATT_Y	O
)	O
{	O
off	O
=	O
ATT_X	O
;	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
anchored_at_X	int
=	O
(	O
off	O
==	O
ATT_X	O
)	O
?	O
3	int
:	O
0	int
;	O
}	O
assert	O
(	O
off	O
<=	O
ATT_not	O
)	O
;	O
if	O
(	O
(	O
ci	int
==	O
-	O
1	int
)	O
&&	O
(	O
off	O
<	O
3	int
)	O
&&	O
(	O
(	O
off	O
&	O
anchor	int
)	O
!=	O
0	int
)	O
&&	O
!	O
fixed_anchor	int
)	O
{	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
anchored_at_X	int
=	O
(	O
off	O
==	O
ATT_X	O
)	O
?	O
3	int
:	O
0	int
;	O
}	O
if	O
(	O
el	O
>=	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
elements	*(struct(int,int,int))
)	O
/	O
sizeof	O
(	O
elements	*(struct(int,int,int))
[	O
0	int
]	O
)	O
)	O
)	O
return	O
0	int
;	O
elements	*(struct(int,int,int))
[	O
el	O
]	O
.	O
x	int
=	O
maxi	int
;	O
elements	*(struct(int,int,int))
[	O
el	O
]	O
.	O
y	int
=	O
j	int
;	O
elements	*(struct(int,int,int))
[	O
el	O
]	O
.	O
att	char
=	O
off	O
;	O
++	O
el	O
;	O
}	O
if	O
(	O
*	O
p	O
==	O
'|'	O
)	O
{	O
if	O
(	O
!	O
(	O
where	O
&	O
EAST_EDGE	O
)	O
&&	O
(	O
(	O
where	O
&	O
NORTH_EDGE	O
)	O
||	O
maxi	int
>	O
0	int
)	O
)	O
goto	O
fatal	O
;	O
where	O
|=	O
EAST_EDGE	O
;	O
}	O
else	O
if	O
(	O
where	O
&	O
EAST_EDGE	O
)	O
goto	O
fatal	O
;	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
j	int
!=	O
maxj	int
)	O
goto	O
notrectangle	O
;	O
if	O
(	O
j	int
>	O
maxj	int
)	O
maxj	int
=	O
j	int
;	O
if	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
jwo	O
=	O
1	int
;	O
if	O
(	O
where	O
&	O
EAST_EDGE	O
)	O
jeo	O
=	O
1	int
;	O
if	O
(	O
maxi	int
<=	O
MAX_BOARD	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
diagram	O
[	O
maxi	int
]	O
,	O
pcopy	O
,	O
maxj	int
+	O
jwo	O
+	O
jeo	O
)	O
;	O
maxi	int
++	O
;	O
return	O
maxi	int
<=	O
MAX_BOARD	int
&&	O
maxj	int
<=	O
MAX_BOARD	int
;	O
fatal	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Illegal pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
=	O
1	int
;	O
return	O
0	int
;	O
notrectangle	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Pattern %s not rectangular\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
read_constraint_diagram_line	O
(	O
char	O
*	O
p	O
)	O
{	O
int	O
j	int
;	O
int	O
jwo	O
=	O
0	int
,	O
jeo	O
=	O
0	int
;	O
const	O
char	O
*	O
pcopy	O
=	O
p	O
;	O
if	O
(	O
*	O
p	O
==	O
'+'	O
||	O
*	O
p	O
==	O
'-'	O
)	O
return	O
;	O
if	O
(	O
*	O
p	O
==	O
'|'	O
)	O
p	O
++	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
strchr	(*(char),int)->(*(char))
(	O
VALID_PATTERN_CHARS	O
,	O
*	O
p	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
VALID_CONSTRAINT_LABELS	O
,	O
*	O
p	O
)	O
;	O
++	O
j	int
,	O
++	O
p	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
VALID_CONSTRAINT_LABELS	O
,	O
*	O
p	O
)	O
&&	O
label_coords	O
[	O
(	O
int	O
)	O
*	O
p	O
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
label_coords	O
[	O
(	O
int	O
)	O
*	O
p	O
]	O
[	O
0	int
]	O
=	O
current_c_i	O
;	O
label_coords	O
[	O
(	O
int	O
)	O
*	O
p	O
]	O
[	O
1	int
]	O
=	O
j	int
;	O
}	O
}	O
if	O
(	O
j	int
!=	O
maxj	int
+	O
1	int
&&	O
!	O
discard_pattern	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Mismatching width of constraint line in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
if	O
(	O
where	O
&	O
WEST_EDGE	O
)	O
jwo	O
=	O
1	int
;	O
if	O
(	O
where	O
&	O
EAST_EDGE	O
)	O
jeo	O
=	O
1	int
;	O
if	O
(	O
el	O
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
constraint_diagram	O
[	O
current_c_i	O
]	O
,	O
pcopy	O
,	O
maxj	int
+	O
jwo	O
+	O
jeo	O
+	O
1	int
)	O
;	O
current_c_i	O
++	O
;	O
return	O
;	O
}	O
static	O
void	O
check_constraint_diagram_size	O
(	O
void	O
)	O
{	O
if	O
(	O
current_c_i	O
!=	O
maxi	int
+	O
1	int
&&	O
!	O
discard_pattern	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Mismatching height of constraint diagram in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
static	O
void	O
convert_attribute_labels_to_offsets	O
(	O
void	O
)	O
{	O
struct	O
pattern_attribute	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))
*	O
attribute	O
;	O
if	O
(	O
patno	O
<	O
0	int
||	O
!	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
return	O
;	O
for	O
(	O
attribute	O
=	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
;	O
attribute	O
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	O
++	O
)	O
{	O
if	O
(	O
attribute	O
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
{	O
int	O
label	*(char)
=	O
attribute	O
->	O
offset	short
;	O
int	O
x	int
;	O
int	O
y	int
;	O
if	O
(	O
label_coords	O
[	O
label	*(char)
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Pattern attribute uses label '%c' that wasn't specified in the diagram\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
label	*(char)
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
TRANSFORM2	O
(	O
label_coords	O
[	O
label	*(char)
]	O
[	O
0	int
]	O
-	O
ci	int
-	O
movei	O
,	O
label_coords	O
[	O
label	*(char)
]	O
[	O
1	int
]	O
-	O
cj	int
-	O
movej	O
,	O
&	O
x	int
,	O
&	O
y	int
,	O
labels_transformation	O
)	O
;	O
attribute	O
->	O
offset	short
=	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
finish_pattern	O
(	O
char	O
*	O
line	int
)	O
{	O
int	O
x	int
;	O
int	O
y	int
;	O
char	O
symmetry	O
;	O
mini	int
=	O
minj	int
=	O
0	int
;	O
if	O
(	O
num_stars	O
>	O
1	int
||	O
(	O
database_type	O
!=	O
DB_CONNECTIONS	O
&&	O
num_stars	O
==	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : No or too many *'s in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
=	O
1	int
;	O
}	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
{	O
ci	int
=	O
0	int
;	O
cj	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
choose_best_anchor	O
&&	O
!	O
discard_pattern	O
)	O
{	O
int	O
mi	O
,	O
mj	O
;	O
int	O
d	int
,	O
min_d	O
=	O
36100	int
;	O
int	O
k	int
,	O
min_k	O
=	O
-	O
1	int
;	O
mi	O
=	O
(	O
maxi	int
-	O
1	int
)	O
*	O
50	int
;	O
mj	O
=	O
(	O
maxj	int
-	O
1	int
)	O
*	O
50	int
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
!=	O
el	O
;	O
k	int
++	O
)	O
if	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
<	O
3	int
&&	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
&	O
anchor	int
)	O
!=	O
0	int
)	O
{	O
d	int
=	O
gg_abs	O
(	O
100	int
*	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
x	int
-	O
mi	O
)	O
+	O
gg_abs	O
(	O
100	int
*	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
y	int
-	O
mj	O
)	O
;	O
if	O
(	O
d	int
<	O
min_d	O
)	O
{	O
min_k	O
=	O
k	int
;	O
min_d	O
=	O
d	int
;	O
}	O
}	O
assert	O
(	O
min_k	O
!=	O
-	O
1	int
)	O
;	O
ci	int
=	O
elements	*(struct(int,int,int))
[	O
min_k	O
]	O
.	O
x	int
;	O
cj	int
=	O
elements	*(struct(int,int,int))
[	O
min_k	O
]	O
.	O
y	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
anchored_at_X	int
=	O
(	O
elements	*(struct(int,int,int))
[	O
min_k	O
]	O
.	O
att	char
==	O
ATT_X	O
)	O
?	O
3	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
ci	int
==	O
-	O
1	int
||	O
cj	int
==	O
-	O
1	int
)	O
&&	O
!	O
discard_pattern	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : No origin for pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
=	O
1	int
;	O
ci	int
=	O
0	int
;	O
cj	int
=	O
0	int
;	O
}	O
if	O
(	O
num_stars	O
==	O
1	int
)	O
{	O
movei	O
-=	O
ci	int
;	O
movej	O
-=	O
cj	int
;	O
}	O
else	O
if	O
(	O
num_stars	O
==	O
0	int
)	O
{	O
movei	O
=	O
ci	int
;	O
movej	O
=	O
cj	int
;	O
}	O
TRANSFORM2	O
(	O
movei	O
,	O
movej	O
,	O
&	O
x	int
,	O
&	O
y	int
,	O
transformation_hint	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
move_offset	int
=	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
;	O
find_extents	O
(	O
)	O
;	O
compute_grids	O
(	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
patlen	int
=	O
el	O
;	O
{	O
int	O
s	O
;	O
char	O
class	int
[	O
80	int
]	O
;	O
char	O
entry	O
[	O
80	int
]	O
;	O
char	O
*	O
p	O
=	O
line	int
;	O
char	O
*	O
p2	O
;	O
int	O
n	int
;	O
class	int
[	O
0	int
]	O
=	O
0	int
;	O
s	O
=	O
sscanf	(*(char),*(char))->(int)
(	O
p	O
,	O
":%c,%[^,]%n"	*(char)
,	O
&	O
symmetry	O
,	O
class	int
,	O
&	O
n	int
)	O
;	O
p	O
+=	O
n	int
;	O
if	O
(	O
s	O
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": line must contain symmetry character and class\n"	*(char)
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
=	O
NULL	O
;	O
while	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
p	O
,	O
"%*[, ]%[^,]%n"	*(char)
,	O
entry	O
,	O
&	O
n	int
)	O
>	O
0	int
)	O
{	O
const	O
char	O
*	O
paren	O
;	O
p	O
+=	O
n	int
;	O
paren	O
=	O
strchr	(*(char),int)->(*(char))
(	O
entry	O
,	O
'('	O
)	O
;	O
if	O
(	O
paren	O
)	O
{	O
struct	O
attribute_description	O
*	O
description	O
=	O
NULL	O
;	O
if	O
(	O
attribute_map	O
)	O
{	O
for	O
(	O
description	O
=	O
attribute_map	O
;	O
description	O
->	O
input_name	O
;	O
description	O
++	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
entry	O
,	O
description	O
->	O
input_name	O
,	O
paren	O
-	O
entry	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
description	O
->	O
type	char
!=	O
IN_PATTERN_VALUE	O
)	O
{	O
if	O
(	O
!	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
=	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
+	O
num_attributes	O
;	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
num_attributes	O
]	O
.	O
type	char
=	O
description	O
->	O
type	char
;	O
if	O
(	O
description	O
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
{	O
if	O
(	O
*	O
(	O
paren	O
+	O
1	int
)	O
!=	O
'*'	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
VALID_CONSTRAINT_LABELS	O
,	O
*	O
(	O
paren	O
+	O
1	int
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : '%c' is not a valid label.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
*	O
(	O
paren	O
+	O
1	int
)	O
)	O
;	O
fatal_errors	O
++	O
;	O
continue	O
;	O
}	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
num_attributes	O
]	O
.	O
offset	short
=	O
*	O
(	O
paren	O
+	O
1	int
)	O
;	O
}	O
else	O
sscanf	(*(char),*(char))->(int)
(	O
paren	O
+	O
1	int
,	O
"%f"	*(char)
,	O
&	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
num_attributes	O
]	O
.	O
value	*(char)
)	O
;	O
num_attributes	O
++	O
;	O
}	O
else	O
sscanf	(*(char),*(char))->(int)
(	O
paren	O
+	O
1	int
,	O
"%f"	*(char)
,	O
&	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
paren	O
+	O
1	int
,	O
')'	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : ')' missed\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
attribute_map	O
==	O
NULL	O
||	O
description	O
->	O
input_name	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Unknown value field: %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
entry	O
)	O
;	O
fatal_errors	O
++	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
helper_fn_names	O
[	O
patno	O
]	O
,	O
entry	O
,	O
79	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
!=	O
NULL	O
)	O
{	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
num_attributes	O
]	O
.	O
type	char
=	O
LAST_ATTRIBUTE	int
;	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
num_attributes	O
]	O
.	O
value	*(char)
=	O
0.0	int
;	O
num_attributes	O
++	O
;	O
}	O
for	O
(	O
p2	O
=	O
class	int
;	O
*	O
p2	O
;	O
p2	O
++	O
)	O
{	O
switch	O
(	O
*	O
p2	O
)	O
{	O
case	O
's'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_s	O
;	O
break	O
;	O
case	O
'O'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_O	O
;	O
break	O
;	O
case	O
'o'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_o	O
;	O
break	O
;	O
case	O
'X'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_X	O
;	O
break	O
;	O
case	O
'x'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_x	O
;	O
break	O
;	O
case	O
'D'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_D	O
;	O
break	O
;	O
case	O
'C'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_C	O
;	O
break	O
;	O
case	O
'c'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_c	O
;	O
break	O
;	O
case	O
'n'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_n	O
;	O
break	O
;	O
case	O
'B'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_B	O
;	O
break	O
;	O
case	O
'A'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_A	O
;	O
break	O
;	O
case	O
'b'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_b	O
;	O
break	O
;	O
case	O
'e'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_e	O
;	O
break	O
;	O
case	O
'E'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_E	O
;	O
break	O
;	O
case	O
'a'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_a	O
;	O
break	O
;	O
case	O
'd'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_d	O
;	O
break	O
;	O
case	O
'I'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_I	O
;	O
break	O
;	O
case	O
'J'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_J	O
;	O
break	O
;	O
case	O
'j'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_j	O
;	O
break	O
;	O
case	O
't'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_t	O
;	O
break	O
;	O
case	O
'T'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_T	O
;	O
break	O
;	O
case	O
'U'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_U	O
;	O
break	O
;	O
case	O
'W'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_W	O
;	O
break	O
;	O
case	O
'F'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_F	O
;	O
break	O
;	O
case	O
'N'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_N	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
|=	O
CLASS_Y	O
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
isgraph	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p2	O
)	O
)	O
break	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Unknown classification letter %c. (pattern %s).\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
*	O
p2	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
break	O
;	O
}	O
}	O
}	O
switch	O
(	O
symmetry	O
)	O
{	O
case	O
'+'	O
:	O
if	O
(	O
where	O
&	O
(	O
NORTH_EDGE	O
|	O
EAST_EDGE	O
|	O
SOUTH_EDGE	O
|	O
WEST_EDGE	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
2	int
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
where	O
&	O
(	O
NORTH_EDGE	O
|	O
EAST_EDGE	O
|	O
SOUTH_EDGE	O
|	O
WEST_EDGE	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : X symmetry inconsistent with edge constraints (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
if	O
(	O
maxi	int
!=	O
maxj	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : X symmetry requires a square pattern (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
2	int
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
where	O
&	O
(	O
NORTH_EDGE	O
|	O
SOUTH_EDGE	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'|'	O
:	O
if	O
(	O
where	O
&	O
(	O
EAST_EDGE	O
|	O
WEST_EDGE	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'/'	O
:	O
if	O
(	O
maxi	int
!=	O
maxj	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : \\ or / symmetry requires a square pattern (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'O'	O
:	O
if	O
(	O
where	O
&	O
(	O
NORTH_EDGE	O
|	O
EAST_EDGE	O
|	O
SOUTH_EDGE	O
|	O
WEST_EDGE	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
5	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : symmetry character '%c' not implemented - using '8' (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
symmetry	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
case	O
'8'	O
:	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
trfno	int
=	O
8	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
read_constraint_line	O
(	O
char	O
*	O
line	int
)	O
{	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
constraint	O
)	O
+	O
strlen	(*(char))->(long)
(	O
line	int
)	O
<	O
MAXCONSTRAINT	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
constraint	O
,	O
line	int
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper_flag	int
|=	O
HAVE_CONSTRAINT	O
;	O
}	O
static	O
void	O
read_action_line	O
(	O
char	O
*	O
line	int
)	O
{	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
action	int
)	O
+	O
strlen	(*(char))->(long)
(	O
line	int
)	O
<	O
MAXACTION	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
action	int
,	O
line	int
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper_flag	int
|=	O
HAVE_ACTION	O
;	O
}	O
static	O
void	O
generate_autohelper_code	O
(	O
int	O
funcno	O
,	O
int	O
number_of_params	O
,	O
int	O
*	O
labels	O
)	O
{	O
int	O
i	int
;	O
char	O
varnames	O
[	O
MAXPARAMS	O
]	O
[	O
8	int
]	O
;	O
char	O
pattern_id	O
[	O
MAXLINE	O
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number_of_params	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
labels	O
[	O
i	int
]	O
==	O
(	O
int	O
)	O
'*'	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
varnames	O
[	O
i	int
]	O
,	O
"move"	*(char)
)	O
;	O
else	O
if	O
(	O
labels	O
[	O
i	int
]	O
==	O
(	O
int	O
)	O
'?'	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
varnames	O
[	O
i	int
]	O
,	O
"NO_MOVE"	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
varnames	O
[	O
i	int
]	O
,	O
"%c"	*(char)
,	O
labels	O
[	O
i	int
]	O
)	O
;	O
}	O
switch	O
(	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
type	char
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
number_of_params	O
)	O
{	O
case	O
0	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
varnames	O
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
varnames	O
[	O
0	int
]	O
,	O
varnames	O
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
varnames	O
[	O
0	int
]	O
,	O
varnames	O
[	O
1	int
]	O
,	O
varnames	O
[	O
2	int
]	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
varnames	O
[	O
0	int
]	O
,	O
varnames	O
[	O
1	int
]	O
,	O
varnames	O
[	O
2	int
]	O
,	O
varnames	O
[	O
3	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : unknown number of parameters (pattern %s)"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
number_of_params	O
<	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
params	array(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : too few parameters (pattern %s)"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
number_of_params	O
-	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
params	array(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number_of_params	O
;	O
i	int
++	O
)	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
", %s"	*(char)
,	O
varnames	O
[	O
i	int
]	O
)	O
;	O
*	O
code_pos	O
++	O
=	O
')'	O
;	O
break	O
;	O
default	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
pattern_id	O
,	O
"(%s + %d)"	*(char)
,	O
prefix	O
,	O
patno	O
)	O
;	O
switch	O
(	O
number_of_params	O
)	O
{	O
case	O
0	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
pattern_id	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
pattern_id	O
,	O
varnames	O
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
pattern_id	O
,	O
varnames	O
[	O
0	int
]	O
,	O
varnames	O
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
autohelper_functions	O
[	O
funcno	O
]	O
.	O
code	int
,	O
pattern_id	O
,	O
varnames	O
[	O
0	int
]	O
,	O
varnames	O
[	O
1	int
]	O
,	O
varnames	O
[	O
2	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : unknown number of parameters (pattern %s)"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
}	O
static	O
void	O
parse_constraint_or_action	O
(	O
char	O
*	O
line	int
,	O
float	O
*	O
cost	O
)	O
{	O
int	O
state	*(int)
=	O
0	int
;	O
char	O
*	O
p	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
label	*(char)
=	O
0	int
;	O
int	O
labels	O
[	O
MAXLABELS	O
]	O
;	O
int	O
N	O
=	O
sizeof	O
(	O
autohelper_functions	O
)	O
/	O
sizeof	O
(	O
struct	O
autohelper_func	O
)	O
;	O
int	O
number_of_params	O
=	O
0	int
;	O
float	O
cost_factor	O
=	O
1.0	int
;	O
*	O
cost	O
=	O
0.0	int
;	O
for	O
(	O
p	O
=	O
line	int
;	O
*	O
p	O
;	O
p	O
++	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
0	int
:	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
N	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	O
,	O
autohelper_functions	O
[	O
n	int
]	O
.	O
name	short
,	O
strlen	(*(char))->(long)
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
name	short
)	O
)	O
==	O
0	int
)	O
{	O
state	*(int)
=	O
1	int
;	O
p	O
+=	O
strlen	(*(char))->(long)
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
name	short
)	O
-	O
1	int
;	O
*	O
cost	O
+=	O
autohelper_functions	O
[	O
n	int
]	O
.	O
cost	O
*	O
cost_factor	O
;	O
cost_factor	O
*=	O
0.6	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
state	*(int)
==	O
0	int
&&	O
*	O
p	O
!=	O
'\n'	O
)	O
*	O
(	O
code_pos	O
++	O
)	O
=	O
*	O
p	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
*	O
p	O
!=	O
'('	O
)	O
{	O
if	O
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
==	O
0	int
)	O
{	O
generate_autohelper_code	O
(	O
n	int
,	O
0	int
,	O
NULL	O
)	O
;	O
p	O
--	O
;	O
state	*(int)
=	O
0	int
;	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Syntax error in constraint or action, '(' expected (pattern %s, autohelper %s).\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
,	O
autohelper_functions	O
[	O
n	int
]	O
.	O
name	short
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
else	O
{	O
assert	O
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
<=	O
MAXPARAMS	O
)	O
;	O
number_of_params	O
=	O
0	int
;	O
if	O
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
!=	O
0	int
||	O
autohelper_functions	O
[	O
n	int
]	O
.	O
type	char
==	O
1	int
)	O
state	*(int)
=	O
2	int
;	O
else	O
state	*(int)
=	O
3	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
*	O
p	O
!=	O
'*'	O
)	O
&&	O
(	O
*	O
p	O
!=	O
'?'	O
)	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
VALID_CONSTRAINT_LABELS	O
,	O
*	O
p	O
)	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"XxOo"	*(char)
,	O
*	O
p	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : '%c' is not allowed as a constraint label.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
*	O
p	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Syntax error in constraint or action, label expected, found '%c'.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
*	O
p	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
p	O
==	O
'?'	O
)	O
&&	O
(	O
number_of_params	O
==	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"mkpat: tenuki (?) cannot be the first label (pattern %s)\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
label	*(char)
=	O
(	O
int	O
)	O
*	O
p	O
;	O
if	O
(	O
*	O
p	O
!=	O
'*'	O
&&	O
*	O
p	O
!=	O
'?'	O
&&	O
label_coords	O
[	O
label	*(char)
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : The constraint or action uses a label (%c) that wasn't specified in the diagram (pattern %s).\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
label	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
labels	O
[	O
number_of_params	O
]	O
=	O
label	*(char)
;	O
number_of_params	O
++	O
;	O
state	*(int)
=	O
3	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
*	O
p	O
==	O
','	O
)	O
{	O
if	O
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
type	char
!=	O
1	int
&&	O
number_of_params	O
==	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Syntax error in constraint or action, ')' expected (pattern %s).\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
number_of_params	O
==	O
MAXPARAMS	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error in constraint or action, too many parameters. (pattern %s).\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
state	*(int)
=	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
p	O
!=	O
')'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Syntax error in constraint or action, ',' or ')' expected (pattern %s).\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
autohelper_functions	O
[	O
n	int
]	O
.	O
type	char
!=	O
1	int
)	O
&&	O
(	O
number_of_params	O
<	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Syntax error in constraint or action, %s() requires %d parameters.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
autohelper_functions	O
[	O
n	int
]	O
.	O
name	short
,	O
autohelper_functions	O
[	O
n	int
]	O
.	O
params	array(int)
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
generate_autohelper_code	O
(	O
n	int
,	O
number_of_params	O
,	O
labels	O
)	O
;	O
state	*(int)
=	O
0	int
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Internal error in parse_constraint_or_action(), unknown state.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
)	O
;	O
fatal_errors	O
++	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
finish_constraint_and_action	O
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	int
;	O
float	O
cost	O
;	O
int	O
have_constraint	O
=	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	O
)	O
;	O
int	O
have_action	O
=	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper_flag	int
&	O
HAVE_ACTION	O
)	O
;	O
int	O
no_labels	O
=	O
1	int
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
autohelper	*((int,int,int,int)->(int))
=	O
dummyhelper	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"static int\nautohelper%s%d(int trans, int move, int color, int action)\n{\n  int"	*(char)
,	O
prefix	O
,	O
patno	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
VALID_CONSTRAINT_LABELS	O
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	char
=	O
(	O
int	O
)	O
VALID_CONSTRAINT_LABELS	O
[	O
i	int
]	O
;	O
if	O
(	O
label_coords	O
[	O
c	char
]	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
" %c,"	*(char)
,	O
c	char
)	O
;	O
}	O
if	O
(	O
*	O
(	O
code_pos	O
-	O
1	int
)	O
==	O
','	O
)	O
*	O
(	O
code_pos	O
-	O
1	int
)	O
=	O
';'	O
;	O
else	O
{	O
code_pos	O
-=	O
3	int
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"UNUSED(trans);"	*(char)
)	O
;	O
}	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"\n  UNUSED(color);\n"	*(char)
)	O
;	O
if	O
(	O
!	O
have_constraint	O
||	O
!	O
have_action	O
)	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"  UNUSED(action);\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
VALID_CONSTRAINT_LABELS	O
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	char
=	O
(	O
int	O
)	O
VALID_CONSTRAINT_LABELS	O
[	O
i	int
]	O
;	O
if	O
(	O
label_coords	O
[	O
c	char
]	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
int	O
x	int
;	O
int	O
y	int
;	O
TRANSFORM2	O
(	O
label_coords	O
[	O
c	char
]	O
[	O
0	int
]	O
-	O
ci	int
-	O
movei	O
,	O
label_coords	O
[	O
c	char
]	O
[	O
1	int
]	O
-	O
cj	int
-	O
movej	O
,	O
&	O
x	int
,	O
&	O
y	int
,	O
labels_transformation	O
)	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"\n  %c = AFFINE_TRANSFORM(%d, trans, move);"	*(char)
,	O
c	char
,	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
)	O
;	O
no_labels	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
no_labels	O
)	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"\n  UNUSED(move);"	*(char)
)	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"\n\n"	*(char)
)	O
;	O
if	O
(	O
have_constraint	O
&&	O
have_action	O
)	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"  if (!action)\n  "	*(char)
)	O
;	O
if	O
(	O
have_constraint	O
)	O
{	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"  return "	*(char)
)	O
;	O
parse_constraint_or_action	O
(	O
constraint	O
,	O
&	O
cost	O
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
constraint_cost	float
=	O
cost	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
";\n"	*(char)
)	O
;	O
}	O
if	O
(	O
have_action	O
)	O
{	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"  "	*(char)
)	O
;	O
parse_constraint_or_action	O
(	O
action	int
,	O
&	O
cost	O
)	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
";\n"	*(char)
)	O
;	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"\n  return 0;\n"	*(char)
)	O
;	O
}	O
code_pos	O
+=	O
sprintf	(*(char),*(char))->(int)
(	O
code_pos	O
,	O
"}\n\n"	*(char)
)	O
;	O
assert	O
(	O
code_pos	O
<=	O
autohelper_code	O
+	O
sizeof	O
(	O
autohelper_code	O
)	O
)	O
;	O
}	O
static	O
int	O
compare_elements	O
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
static	O
int	O
order	O
[	O
]	O
=	O
{	O
7	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
4	int
,	O
1	int
}	O
;	O
return	O
order	O
[	O
(	O
(	O
const	O
struct	O
patval_b	struct(int,int,int)
*	O
)	O
a	char
)	O
->	O
att	char
]	O
-	O
order	O
[	O
(	O
(	O
const	O
struct	O
patval_b	struct(int,int,int)
*	O
)	O
b	char
)	O
->	O
att	char
]	O
;	O
}	O
struct	O
element_node	O
{	O
struct	O
patval_b	struct(int,int,int)
e	*(struct(char,char,char,char))
;	O
struct	O
element_node	O
*	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
;	O
static	O
void	O
write_elements	O
(	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
used_nodes	O
=	O
0	int
;	O
assert	O
(	O
ci	int
!=	O
-	O
1	int
&&	O
cj	int
!=	O
-	O
1	int
)	O
;	O
assert	O
(	O
database_type	O
==	O
DB_DFA	O
||	O
transformation_hint	O
==	O
0	int
)	O
;	O
gg_sort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
elements	*(struct(int,int,int))
,	O
el	O
,	O
sizeof	O
(	O
struct	O
patval_b	struct(int,int,int)
)	O
,	O
compare_elements	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static struct patval %s%d[] = {"	*(char)
,	O
prefix	O
,	O
patno	O
)	O
;	O
for	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
<	O
el	O
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
)	O
{	O
int	O
x	int
=	O
elements	*(struct(int,int,int))
[	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
.	O
x	int
;	O
int	O
y	int
=	O
elements	*(struct(int,int,int))
[	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
.	O
y	int
;	O
int	O
att	char
=	O
elements	*(struct(int,int,int))
[	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
.	O
att	char
;	O
int	O
dx	O
;	O
int	O
dy	O
;	O
assert	O
(	O
x	int
>=	O
mini	int
&&	O
y	int
>=	O
minj	int
)	O
;	O
if	O
(	O
!	O
(	O
x	int
<=	O
maxi	int
&&	O
y	int
<=	O
maxj	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Maximum number of elements exceeded in %s.\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
prefix	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
if	O
(	O
(	O
fixed_anchor	int
||	O
nongoal	O
[	O
att	char
]	O
)	O
&&	O
callback_unneeded	O
[	O
att	char
]	O
&&	O
(	O
(	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
&	O
(	O
CLASS_X	O
|	O
CLASS_x	O
)	O
)	O
==	O
0	int
)	O
||	O
(	O
att	char
!=	O
ATT_X	O
&&	O
att	char
!=	O
ATT_x	O
)	O
)	O
&&	O
(	O
(	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
class	int
&	O
(	O
CLASS_O	O
|	O
CLASS_o	O
)	O
)	O
==	O
0	int
)	O
||	O
(	O
att	char
!=	O
ATT_O	O
&&	O
att	char
!=	O
ATT_o	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
database_type	O
==	O
DB_GENERAL	O
||	O
database_type	O
==	O
DB_CONNECTIONS	O
)	O
&&	O
ci	int
-	O
1	int
<=	O
x	int
&&	O
x	int
<=	O
ci	int
+	O
1	int
&&	O
cj	int
-	O
1	int
<=	O
y	int
&&	O
y	int
<=	O
cj	int
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
continue	O
;	O
}	O
if	O
(	O
used_nodes	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
","	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
used_nodes	O
%	O
4	int
?	O
"\t"	*(char)
:	O
"\n  "	*(char)
)	O
;	O
used_nodes	O
++	O
;	O
TRANSFORM2	O
(	O
x	int
-	O
ci	int
,	O
y	int
-	O
cj	int
,	O
&	O
dx	O
,	O
&	O
dy	O
,	O
transformation_hint	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{%d,%d}"	*(char)
,	O
OFFSET	O
(	O
dx	O
,	O
dy	O
)	O
,	O
att	char
)	O
;	O
}	O
if	O
(	O
!	O
used_nodes	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{0,-1}}; /* Dummy element, not used. */\n\n"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n};\n\n"	*(char)
)	O
;	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
patlen	int
=	O
used_nodes	O
;	O
}	O
static	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
corner_root	O
;	O
static	O
int	O
second_corner_offset	int
[	O
MAXPATNO	O
]	O
;	O
static	O
int	O
total_variations	O
=	O
0	int
;	O
static	O
int	O
variations_written	O
=	O
0	int
;	O
static	O
int	O
corner_max_width	O
=	O
0	int
;	O
static	O
int	O
corner_max_height	O
=	O
0	int
;	O
struct	O
corner_element	O
{	O
int	O
x	int
;	O
int	O
y	int
;	O
int	O
color	int
;	O
}	O
;	O
static	O
void	O
corner_init	O
(	O
void	O
)	O
{	O
corner_root	O
.	O
num_variations	char
=	O
0	int
;	O
corner_root	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
static	O
int	O
corner_best_element	O
(	O
struct	O
corner_element	O
*	O
el	O
,	O
int	O
n	int
,	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variations	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct)))
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
i	int
;	O
int	O
best	O
=	O
0	int
;	O
int	O
best_value	O
=	O
0	int
;	O
int	O
candidate	O
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
candidates	O
=	O
0	int
;	O
int	O
existing_variation	O
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
have_existing_variation	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
k	int
)	O
continue	O
;	O
if	O
(	O
el	O
[	O
k	int
]	O
.	O
x	int
>=	O
el	O
[	O
i	int
]	O
.	O
x	int
&&	O
el	O
[	O
k	int
]	O
.	O
y	int
>=	O
el	O
[	O
i	int
]	O
.	O
y	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
n	int
)	O
{	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
v	O
;	O
int	O
move_offset	int
=	O
OFFSET	O
(	O
el	O
[	O
k	int
]	O
.	O
x	int
,	O
el	O
[	O
k	int
]	O
.	O
y	int
)	O
;	O
int	O
xor_att	char
=	O
(	O
el	O
[	O
k	int
]	O
.	O
color	int
==	O
color	int
?	O
ATT_O	O
^	O
ATT_O	O
:	O
ATT_O	O
^	O
ATT_X	O
)	O
;	O
candidate	O
[	O
candidates	O
]	O
=	O
k	int
;	O
existing_variation	O
[	O
candidates	O
]	O
=	O
0	int
;	O
for	O
(	O
v	O
=	O
variations	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct)))
;	O
v	O
!=	O
NULL	O
;	O
v	O
=	O
v	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
if	O
(	O
v	O
->	O
move_offset	int
==	O
move_offset	int
&&	O
(	O
v	O
->	O
xor_att	char
==	O
xor_att	char
||	O
color	int
==	O
0	int
)	O
)	O
{	O
existing_variation	O
[	O
candidates	O
]	O
=	O
1	int
;	O
have_existing_variation	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
candidates	O
++	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
candidates	O
;	O
k	int
++	O
)	O
{	O
int	O
m	int
=	O
candidate	O
[	O
k	int
]	O
;	O
int	O
value	*(char)
=	O
2	int
*	O
MAX_BOARD	int
*	O
(	O
el	O
[	O
m	int
]	O
.	O
x	int
+	O
1	int
)	O
*	O
(	O
el	O
[	O
m	int
]	O
.	O
y	int
+	O
1	int
)	O
-	O
2	int
*	O
gg_abs	O
(	O
el	O
[	O
m	int
]	O
.	O
x	int
-	O
el	O
[	O
m	int
]	O
.	O
y	int
)	O
+	O
(	O
el	O
[	O
m	int
]	O
.	O
x	int
<	O
el	O
[	O
m	int
]	O
.	O
y	int
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
existing_variation	O
[	O
k	int
]	O
==	O
have_existing_variation	O
&&	O
value	*(char)
>	O
best_value	O
)	O
{	O
best	O
=	O
k	int
;	O
best_value	O
=	O
value	*(char)
;	O
}	O
}	O
return	O
candidate	O
[	O
best	O
]	O
;	O
}	O
static	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
corner_variation_new	O
(	O
int	O
move_offset	int
,	O
signed	O
char	O
xor_att	char
,	O
unsigned	O
char	O
num_stones	int
)	O
{	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variation	O
;	O
variation	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
variation	O
)	O
)	O
;	O
variation	O
->	O
move_offset	int
=	O
move_offset	int
;	O
variation	O
->	O
xor_att	char
=	O
xor_att	char
;	O
variation	O
->	O
num_stones	int
=	O
num_stones	int
;	O
variation	O
->	O
num_variations	char
=	O
0	int
;	O
variation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
NULL	O
;	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
variation	O
->	O
child_num	int
=	O
-	O
1	int
;	O
variation	O
->	O
pattern_num	int
=	O
-	O
1	int
;	O
total_variations	O
++	O
;	O
return	O
variation	O
;	O
}	O
static	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
corner_follow_variation	O
(	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variation	O
,	O
int	O
offset	short
,	O
int	O
color	int
,	O
unsigned	O
char	O
num_stones	int
)	O
{	O
signed	O
char	O
xor_att	char
=	O
color	int
?	O
ATT_O	O
^	O
ATT_O	O
:	O
ATT_O	O
^	O
ATT_X	O
;	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
subvariation	O
=	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
*	O
link	O
=	O
&	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
while	O
(	O
subvariation	O
)	O
{	O
if	O
(	O
subvariation	O
->	O
move_offset	int
==	O
offset	short
&&	O
subvariation	O
->	O
xor_att	char
==	O
xor_att	char
)	O
{	O
assert	O
(	O
subvariation	O
->	O
num_stones	int
==	O
num_stones	int
)	O
;	O
return	O
subvariation	O
;	O
}	O
link	O
=	O
&	O
(	O
subvariation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
subvariation	O
=	O
subvariation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
variation	O
->	O
num_variations	char
++	O
;	O
*	O
link	O
=	O
corner_variation_new	O
(	O
offset	short
,	O
xor_att	char
,	O
num_stones	int
)	O
;	O
return	O
*	O
link	O
;	O
}	O
static	O
void	O
corner_add_pattern	O
(	O
void	O
)	O
{	O
int	O
k	int
;	O
struct	O
corner_element	O
stone	O
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
stones	*(int)
=	O
0	int
;	O
int	O
trans	int
;	O
int	O
corner_x	O
=	O
0	int
;	O
int	O
corner_y	O
=	O
0	int
;	O
int	O
color	int
=	O
0	int
;	O
int	O
move_pos	int
;	O
int	O
move_x	O
;	O
int	O
move_y	O
;	O
unsigned	O
char	O
num_stones	int
;	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variation	O
=	O
&	O
corner_root	O
;	O
switch	O
(	O
where	O
)	O
{	O
case	O
SOUTH_EDGE	O
|	O
WEST_EDGE	O
:	O
trans	int
=	O
5	int
;	O
corner_x	O
=	O
maxi	int
;	O
break	O
;	O
case	O
WEST_EDGE	O
|	O
NORTH_EDGE	O
:	O
trans	int
=	O
0	int
;	O
break	O
;	O
case	O
NORTH_EDGE	O
|	O
EAST_EDGE	O
:	O
trans	int
=	O
7	int
;	O
corner_y	O
=	O
maxj	int
;	O
break	O
;	O
case	O
EAST_EDGE	O
|	O
SOUTH_EDGE	O
:	O
trans	int
=	O
2	int
;	O
corner_x	O
=	O
maxi	int
;	O
corner_y	O
=	O
maxj	int
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Illegal edge constraint in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
move_pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
move_offset	int
-	O
OFFSET_DELTA	O
(	O
corner_x	O
,	O
corner_y	O
)	O
,	O
trans	int
,	O
POS	O
(	O
0	int
,	O
0	int
)	O
)	O
;	O
move_x	O
=	O
I	O
(	O
move_pos	int
)	O
;	O
move_y	O
=	O
J	O
(	O
move_pos	int
)	O
;	O
labels_transformation	O
=	O
trans	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
el	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	O
||	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
==	O
ATT_O	O
)	O
{	O
TRANSFORM2	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
x	int
,	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
y	int
,	O
&	O
stone	O
[	O
stones	*(int)
]	O
.	O
x	int
,	O
&	O
stone	O
[	O
stones	*(int)
]	O
.	O
y	int
,	O
trans	int
)	O
;	O
stone	O
[	O
stones	*(int)
]	O
.	O
x	int
+=	O
corner_x	O
;	O
stone	O
[	O
stones	*(int)
]	O
.	O
y	int
+=	O
corner_y	O
;	O
stone	O
[	O
stones	*(int)
]	O
.	O
color	int
=	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
;	O
stones	*(int)
++	O
;	O
}	O
else	O
if	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
!=	O
ATT_dot	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Illegal element in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
return	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
stones	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
int	O
best	O
;	O
struct	O
corner_element	O
stone_t	O
;	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
best	O
=	O
k	int
+	O
corner_best_element	O
(	O
stone	O
+	O
k	int
,	O
stones	*(int)
-	O
k	int
,	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
)	O
;	O
stone_t	O
=	O
stone	O
[	O
k	int
]	O
;	O
stone	O
[	O
k	int
]	O
=	O
stone	O
[	O
best	O
]	O
;	O
stone	O
[	O
best	O
]	O
=	O
stone_t	O
;	O
}	O
else	O
{	O
best	O
=	O
corner_best_element	O
(	O
stone	O
,	O
stones	*(int)
,	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
)	O
;	O
stone_t	O
=	O
stone	O
[	O
0	int
]	O
;	O
stone	O
[	O
0	int
]	O
=	O
stone	O
[	O
best	O
]	O
;	O
stone	O
[	O
best	O
]	O
=	O
stone_t	O
;	O
color	int
=	O
stone	O
[	O
0	int
]	O
.	O
color	int
;	O
if	O
(	O
stone	O
[	O
0	int
]	O
.	O
x	int
>	O
stone	O
[	O
0	int
]	O
.	O
y	int
)	O
{	O
int	O
t	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
stone	O
[	O
i	int
]	O
.	O
x	int
==	O
stone	O
[	O
0	int
]	O
.	O
y	int
&&	O
stone	O
[	O
i	int
]	O
.	O
y	int
==	O
stone	O
[	O
0	int
]	O
.	O
x	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
k	int
)	O
{	O
t	O
=	O
maxi	int
;	O
maxi	int
=	O
maxj	int
;	O
maxj	int
=	O
t	O
;	O
t	O
=	O
move_x	O
;	O
move_x	O
=	O
move_y	O
;	O
move_y	O
=	O
t	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
stones	*(int)
;	O
i	int
++	O
)	O
{	O
t	O
=	O
stone	O
[	O
i	int
]	O
.	O
x	int
;	O
stone	O
[	O
i	int
]	O
.	O
x	int
=	O
stone	O
[	O
i	int
]	O
.	O
y	int
;	O
stone	O
[	O
i	int
]	O
.	O
y	int
=	O
t	O
;	O
}	O
}	O
}	O
}	O
num_stones	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
stone	O
[	O
i	int
]	O
.	O
x	int
<=	O
stone	O
[	O
k	int
]	O
.	O
x	int
&&	O
stone	O
[	O
i	int
]	O
.	O
y	int
<=	O
stone	O
[	O
k	int
]	O
.	O
y	int
)	O
num_stones	int
++	O
;	O
}	O
variation	O
=	O
corner_follow_variation	O
(	O
variation	O
,	O
OFFSET	O
(	O
stone	O
[	O
k	int
]	O
.	O
x	int
,	O
stone	O
[	O
k	int
]	O
.	O
y	int
)	O
,	O
stone	O
[	O
k	int
]	O
.	O
color	int
==	O
color	int
,	O
num_stones	int
)	O
;	O
}	O
num_stones	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
stones	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
stone	O
[	O
k	int
]	O
.	O
x	int
<=	O
move_x	O
&&	O
stone	O
[	O
k	int
]	O
.	O
y	int
<=	O
move_y	O
)	O
num_stones	int
++	O
;	O
}	O
variation	O
=	O
corner_follow_variation	O
(	O
variation	O
,	O
OFFSET	O
(	O
move_x	O
,	O
move_y	O
)	O
,	O
ATT_O	O
==	O
color	int
,	O
num_stones	int
)	O
;	O
if	O
(	O
variation	O
->	O
pattern_num	int
==	O
-	O
1	int
)	O
{	O
variation	O
->	O
pattern_num	int
=	O
patno	O
;	O
second_corner_offset	int
[	O
patno	O
]	O
=	O
OFFSET	O
(	O
maxi	int
,	O
maxj	int
)	O
;	O
if	O
(	O
maxi	int
>	O
corner_max_height	O
)	O
corner_max_height	O
=	O
maxi	int
;	O
if	O
(	O
maxj	int
>	O
corner_max_width	O
)	O
corner_max_width	O
=	O
maxj	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : warning : duplicated patterns encountered (%s and %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
variation	O
->	O
pattern_num	int
]	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
discard_pattern	O
=	O
1	int
;	O
}	O
}	O
static	O
int	O
corner_pack_variations	O
(	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variation	O
,	O
int	O
counter	O
)	O
{	O
counter	O
++	O
;	O
if	O
(	O
variation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
counter	O
=	O
corner_pack_variations	O
(	O
variation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
counter	O
)	O
;	O
if	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
variation	O
->	O
child_num	int
=	O
counter	O
;	O
counter	O
=	O
corner_pack_variations	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
counter	O
)	O
;	O
}	O
return	O
counter	O
;	O
}	O
static	O
void	O
corner_write_variations	O
(	O
struct	O
corner_variation_b	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),*(struct(int,char,char,char,*(struct`),*(struct`),int,int)),int,int)),int,int)
*	O
variation	O
,	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {%d,%d,%d,%d,"	*(char)
,	O
variation	O
->	O
move_offset	int
,	O
variation	O
->	O
xor_att	char
,	O
variation	O
->	O
num_stones	int
,	O
variation	O
->	O
num_variations	char
)	O
;	O
if	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"&%s_variations[%d],"	*(char)
,	O
prefix	O
,	O
variation	O
->	O
child_num	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL,"	*(char)
)	O
;	O
if	O
(	O
variation	O
->	O
pattern_num	int
!=	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"&%s[%d]"	*(char)
,	O
prefix	O
,	O
variation	O
->	O
pattern_num	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL"	*(char)
)	O
;	O
variations_written	O
++	O
;	O
if	O
(	O
variations_written	O
!=	O
total_variations	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"},\n"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"}\n};\n\n\n"	*(char)
)	O
;	O
if	O
(	O
variation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
corner_write_variations	O
(	O
variation	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
corner_write_variations	O
(	O
variation	O
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
write_attributes	O
(	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
k	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static struct pattern_attribute attributes[] = {\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#ifdef HAVE_TRANSPARENT_UNIONS\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attributes	O
;	O
k	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {%s,"	*(char)
,	O
attribute_name	O
[	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
type	char
]	O
)	O
;	O
if	O
(	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{.offset=%d}}"	*(char)
,	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
offset	short
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{.value=%f}}"	*(char)
,	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
k	int
!=	O
num_attributes	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n#else\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attributes	O
;	O
k	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {%s,"	*(char)
,	O
attribute_name	O
[	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
type	char
]	O
)	O
;	O
if	O
(	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"0.0,%d}"	*(char)
,	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
offset	short
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%f,0}"	*(char)
,	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
k	int
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
k	int
!=	O
num_attributes	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n#endif\n};\n\n"	*(char)
)	O
;	O
}	O
static	O
void	O
write_patterns	O
(	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
j	int
;	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static struct corner_pattern %s[] = {\n"	*(char)
,	O
prefix	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static struct pattern %s[] = {\n"	*(char)
,	O
prefix	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
patno	O
;	O
++	O
j	int
)	O
{	O
struct	O
pattern	*(struct)
*	O
p	O
=	O
pattern	*(struct)
+	O
j	int
;	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {%d,%d,0x%x,\"%s\","	*(char)
,	O
second_corner_offset	int
[	O
j	int
]	O
,	O
(	O
p	O
->	O
trfno	int
==	O
4	int
)	O
,	O
p	O
->	O
class	int
,	O
pattern_names	O
[	O
j	int
]	O
)	O
;	O
if	O
(	O
attributes_needed	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"attributes+%d,"	*(char)
,	O
(	O
int	O
)	O
(	O
p	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
?	O
p	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
-	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
:	O
0	int
)	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL,"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d,"	*(char)
,	O
p	O
->	O
autohelper_flag	int
)	O
;	O
if	O
(	O
p	O
->	O
autohelper	*((int,int,int,int)->(int))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"autohelper%s%d}"	*(char)
,	O
prefix	O
,	O
j	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL}"	*(char)
)	O
;	O
if	O
(	O
j	int
!=	O
patno	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",\n"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n};\n\n\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {%s%d,%d,%d, \"%s\",%d,%d,%d,%d,%d,%d,0x%x,%d"	*(char)
,	O
prefix	O
,	O
j	int
,	O
p	O
->	O
patlen	int
,	O
p	O
->	O
trfno	int
,	O
pattern_names	O
[	O
j	int
]	O
,	O
p	O
->	O
mini	int
,	O
p	O
->	O
minj	int
,	O
p	O
->	O
maxi	int
,	O
p	O
->	O
maxj	int
,	O
p	O
->	O
maxi	int
-	O
p	O
->	O
mini	int
,	O
p	O
->	O
maxj	int
-	O
p	O
->	O
minj	int
,	O
p	O
->	O
edge_constraints	int
,	O
p	O
->	O
move_offset	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",\n    {"	*(char)
)	O
;	O
{	O
int	O
ll	int
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" 0x%08x%s"	*(char)
,	O
p	O
->	O
and_mask	array(int)
[	O
ll	int
]	O
,	O
ll	int
<	O
7	int
?	O
","	*(char)
:	O
""	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"},\n    {"	*(char)
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" 0x%08x%s"	*(char)
,	O
p	O
->	O
val_mask	array(int)
[	O
ll	int
]	O
,	O
ll	int
<	O
7	int
?	O
","	*(char)
:	O
""	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"}\n   "	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
", 0x%x,%f,"	*(char)
,	O
p	O
->	O
class	int
,	O
p	O
->	O
value	*(char)
)	O
;	O
if	O
(	O
attributes_needed	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"attributes+%d,"	*(char)
,	O
(	O
int	O
)	O
(	O
p	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
?	O
p	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
-	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
:	O
0	int
)	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL,"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d,%s,"	*(char)
,	O
p	O
->	O
autohelper_flag	int
,	O
helper_fn_names	O
[	O
j	int
]	O
)	O
;	O
if	O
(	O
p	O
->	O
autohelper	*((int,int,int,int)->(int))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"autohelper%s%d"	*(char)
,	O
prefix	O
,	O
j	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"NULL"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",%d"	*(char)
,	O
p	O
->	O
anchored_at_X	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",%f"	*(char)
,	O
p	O
->	O
constraint_cost	float
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"},\n"	*(char)
)	O
;	O
}	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
return	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  {NULL, 0,0,NULL,0,0,0,0,0,0,0,0"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
",0,0.0,NULL,0,NULL,NULL,0,0.0"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"}\n};\n"	*(char)
)	O
;	O
}	O
static	O
void	O
write_pattern_db	O
(	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"struct corner_db %s_db = {\n"	*(char)
,	O
prefix	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %d,\n"	*(char)
,	O
corner_max_width	O
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %d,\n"	*(char)
,	O
corner_max_height	O
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %d,\n"	*(char)
,	O
corner_root	O
.	O
num_variations	char
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %s_variations\n"	*(char)
,	O
prefix	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"};\n"	*(char)
)	O
;	O
return	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"struct pattern_db %s_db = {\n"	*(char)
,	O
prefix	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  -1,\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %d,\n"	*(char)
,	O
fixed_anchor	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %s\n"	*(char)
,	O
prefix	O
)	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" ,& dfa_%s\n"	*(char)
,	O
prefix	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" , NULL\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"};\n"	*(char)
)	O
;	O
}	O
int	O
main	O
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
static	O
char	O
stdin_name	O
[	O
]	O
=	O
"<stdin>"	*(char)
;	O
int	O
input_files	O
=	O
0	int
;	O
int	O
ifc	O
;	O
char	O
*	O
input_file_names	O
[	O
MAX_INPUT_FILE_NAMES	O
]	O
;	O
char	O
*	O
output_file_name	O
=	O
NULL	O
;	O
char	O
*	O
transformations_file_name	O
=	O
NULL	O
;	O
FILE	struct
*	O
input_FILE	O
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
output_FILE	O
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
transformations_FILE	O
=	O
NULL	O
;	O
int	O
state	*(int)
=	O
0	int
;	O
char	O
*	O
save_code_pos	O
=	O
autohelper_code	O
;	O
int	O
iterations	O
=	O
0	int
;	O
transformation_init	()->(void)
(	O
)	O
;	O
{	O
int	O
i	int
;	O
int	O
multiple_anchor_options	O
=	O
0	int
;	O
while	O
(	O
(	O
i	int
=	O
gg_getopt	(int,*(*(char)),*(char))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"i:o:t:vV:pcfCDd:A:OXbma"	*(char)
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
'i'	O
:	O
if	O
(	O
input_files	O
==	O
MAX_INPUT_FILE_NAMES	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error : Too many input files (maximum %d supported)\n"	*(char)
,	O
MAX_INPUT_FILE_NAMES	O
)	O
;	O
return	O
EXIT_FAILURE	O
;	O
}	O
input_file_names	O
[	O
input_files	O
++	O
]	O
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file_name	O
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
't'	O
:	O
transformations_file_name	O
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
'V'	O
:	O
dfa_verbose	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
gg_optarg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'c'	O
:	O
case	O
'f'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
if	O
(	O
database_type	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error : More than one database type specified (-%c and -%c)\n"	*(char)
,	O
database_type	O
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
database_type	O
=	O
i	int
;	O
if	O
(	O
i	int
==	O
'd'	O
)	O
{	O
iterations	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
gg_optarg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
iterations	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error : Expected a non-negative number of iterations\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
'O'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	O
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_O	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	O
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_X	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	O
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_BOTH	O
;	O
break	O
;	O
case	O
'm'	O
:	O
choose_best_anchor	O
=	O
1	int
;	O
if	O
(	O
fixed_anchor	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning : -m and -a are mutually exclusive.\n"	*(char)
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
fixed_anchor	int
=	O
1	int
;	O
if	O
(	O
choose_best_anchor	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning : -m and -a are mutually exclusive.\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\b ; ignored\n"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
database_type	O
)	O
database_type	O
=	O
DB_GENERAL	O
;	O
if	O
(	O
!	O
anchor	int
)	O
anchor	int
=	O
ANCHOR_O	O
;	O
if	O
(	O
!	O
input_files	O
)	O
input_file_names	O
[	O
input_files	O
++	O
]	O
=	O
stdin_name	O
;	O
if	O
(	O
output_file_name	O
&&	O
database_type	O
!=	O
OPTIMIZE_DFA	O
)	O
{	O
output_FILE	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
output_file_name	O
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
output_FILE	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error : Cannot write to file %s\n"	*(char)
,	O
output_file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
transformations_file_name	O
&&	O
(	O
database_type	O
==	O
DB_DFA	O
||	O
database_type	O
==	O
OPTIMIZE_DFA	O
)	O
)	O
{	O
transformations_FILE	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
transformations_file_name	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
transformations_FILE	O
)	O
{	O
parse_transformations_file	O
(	O
transformations_FILE	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
transformations_FILE	O
)	O
;	O
}	O
else	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error : Cannot read file %s\n"	*(char)
,	O
transformations_file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
multiple_anchor_options	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning : Multiple anchor options encountered. The last took precedence\n"	*(char)
)	O
;	O
}	O
if	O
(	O
gg_optind	int
>=	O
argc	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
USAGE	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
prefix	O
=	O
argv	*(*(char))
[	O
gg_optind	int
]	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
{	O
dfa_init	()->(void)
(	O
)	O
;	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
,	O
"mkpat's dfa"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
corner_init	O
(	O
)	O
;	O
if	O
(	O
database_type	O
==	O
OPTIMIZE_DFA	O
)	O
{	O
if	O
(	O
transformations_file_name	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error : transformation file required (use -t option)\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
dfa_patterns_reset	O
(	O
&	O
dfa_pats	O
)	O
;	O
dfa_init	()->(void)
(	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
PREAMBLE	O
)	O
;	O
patno	O
=	O
-	O
1	int
;	O
autohelper_code	O
[	O
0	int
]	O
=	O
0	int
;	O
code_pos	O
=	O
autohelper_code	O
;	O
num_attributes	O
=	O
1	int
;	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
[	O
0	int
]	O
.	O
type	char
=	O
LAST_ATTRIBUTE	int
;	O
for	O
(	O
ifc	O
=	O
0	int
;	O
ifc	O
<	O
input_files	O
&&	O
!	O
fatal_errors	O
;	O
ifc	O
++	O
)	O
{	O
char	O
line	int
[	O
MAXLINE	O
]	O
;	O
if	O
(	O
input_file_names	O
[	O
ifc	O
]	O
!=	O
stdin_name	O
)	O
{	O
input_FILE	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
input_file_names	O
[	O
ifc	O
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
input_FILE	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error: Cannot open file %s\n"	*(char)
,	O
input_file_names	O
[	O
ifc	O
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
current_file	O
=	O
input_file_names	O
[	O
ifc	O
]	O
;	O
current_line_number	O
=	O
0	int
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	int
,	O
MAXLINE	O
,	O
input_FILE	O
)	O
)	O
{	O
int	O
command	O
=	O
0	int
;	O
char	O
command_data	O
[	O
MAXLINE	O
]	O
;	O
current_line_number	O
++	O
;	O
if	O
(	O
line	int
[	O
strlen	(*(char))->(long)
(	O
line	int
)	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : line truncated (longer than %d characters)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
MAXLINE	O
-	O
1	int
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
{	O
int	O
i	int
=	O
strlen	(*(char))->(long)
(	O
line	int
)	O
-	O
2	int
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
line	int
[	O
i	int
]	O
)	O
)	O
i	int
--	O
;	O
line	int
[	O
i	int
+	O
1	int
]	O
=	O
'\n'	O
;	O
line	int
[	O
i	int
+	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
line	int
,	O
"Pattern %s"	*(char)
,	O
command_data	O
)	O
==	O
1	int
)	O
command	O
=	O
1	int
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
line	int
,	O
"goal_elements %s"	*(char)
,	O
command_data	O
)	O
==	O
1	int
)	O
command	O
=	O
2	int
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
line	int
,	O
"callback_data %s"	*(char)
,	O
command_data	O
)	O
==	O
1	int
)	O
command	O
=	O
3	int
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
line	int
,	O
"attribute_map %s"	*(char)
,	O
command_data	O
)	O
==	O
1	int
)	O
command	O
=	O
4	int
;	O
if	O
(	O
command	O
)	O
{	O
char	O
*	O
p	O
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
command_data	O
,	O
" \t"	*(char)
)	O
;	O
if	O
(	O
p	O
)	O
*	O
p	O
=	O
0	int
;	O
if	O
(	O
patno	O
>=	O
0	int
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
1	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning: empty pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : No entry line for pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
break	O
;	O
case	O
5	int
:	O
case	O
6	int
:	O
{	O
struct	O
pattern_attribute	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))
*	O
attribute	O
=	O
NULL	O
;	O
if	O
(	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
{	O
for	O
(	O
attribute	O
=	O
pattern	*(struct)
[	O
patno	O
]	O
.	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
;	O
attribute	O
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	O
++	O
)	O
{	O
if	O
(	O
attribute	O
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
attribute	O
==	O
NULL	O
||	O
attribute	O
->	O
type	char
==	O
LAST_ATTRIBUTE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning: constraint diagram but no constraint line or offset attributes for pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
7	int
:	O
case	O
8	int
:	O
finish_constraint_and_action	O
(	O
)	O
;	O
case	O
0	int
:	O
case	O
4	int
:	O
check_constraint_diagram	O
(	O
)	O
;	O
}	O
}	O
state	*(int)
=	O
0	int
;	O
if	O
(	O
command	O
==	O
1	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
!	O
discard_pattern	O
)	O
{	O
convert_attribute_labels_to_offsets	O
(	O
)	O
;	O
patno	O
++	O
;	O
}	O
else	O
code_pos	O
=	O
save_code_pos	O
;	O
reset_pattern	O
(	O
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
command_data	O
)	O
>	O
MAXNAME	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : pattern name is too long, truncated\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
)	O
;	O
command_data	O
[	O
MAXNAME	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
patno	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pattern_names	O
[	O
k	int
]	O
,	O
command_data	O
)	O
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning : duplicate pattern name `%s'\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
command_data	O
)	O
;	O
break	O
;	O
}	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
pattern_names	O
[	O
patno	O
]	O
,	O
command_data	O
)	O
;	O
transformation_hint	O
=	O
find_transformation_hint	O
(	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
state	*(int)
=	O
1	int
;	O
discard_pattern	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
command	O
==	O
2	int
||	O
command	O
==	O
3	int
)	O
{	O
int	O
*	O
sort_out	O
=	O
(	O
command	O
==	O
2	int
?	O
nongoal	O
:	O
callback_unneeded	O
)	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
sort_out	O
[	O
k	int
]	O
=	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"none"	*(char)
)	O
)	O
{	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
command_data	O
;	O
*	O
c	char
;	O
c	char
++	O
)	O
{	O
switch	O
(	O
*	O
c	char
)	O
{	O
case	O
'.'	O
:	O
sort_out	O
[	O
ATT_dot	O
]	O
=	O
0	int
;	O
if	O
(	O
command	O
==	O
2	int
)	O
{	O
sort_out	O
[	O
ATT_comma	O
]	O
=	O
0	int
;	O
sort_out	O
[	O
ATT_not	O
]	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
sort_out	O
[	O
ATT_X	O
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'O'	O
:	O
sort_out	O
[	O
ATT_O	O
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
sort_out	O
[	O
ATT_x	O
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
sort_out	O
[	O
ATT_o	O
]	O
=	O
0	int
;	O
break	O
;	O
case	O
','	O
:	O
sort_out	O
[	O
ATT_comma	O
]	O
=	O
0	int
;	O
if	O
(	O
command	O
!=	O
2	int
)	O
break	O
;	O
case	O
'!'	O
:	O
sort_out	O
[	O
ATT_not	O
]	O
=	O
0	int
;	O
if	O
(	O
command	O
!=	O
2	int
)	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : illegal character `%c'\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
*	O
c	char
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
struct	O
attribute_description	O
*	O
old_map	O
=	O
attribute_map	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"general"	*(char)
)	O
==	O
0	int
)	O
{	O
attribute_map	O
=	O
general_attribute_map	O
;	O
attributes_needed	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"value_only"	*(char)
)	O
==	O
0	int
)	O
{	O
attribute_map	O
=	O
value_only_attribute_map	O
;	O
attributes_needed	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"owl_attack"	*(char)
)	O
==	O
0	int
)	O
{	O
attribute_map	O
=	O
owl_attack_attribute_map	O
;	O
attributes_needed	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"owl_defense"	*(char)
)	O
==	O
0	int
)	O
{	O
attribute_map	O
=	O
owl_defense_attribute_map	O
;	O
attributes_needed	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command_data	O
,	O
"none"	*(char)
)	O
==	O
0	int
)	O
{	O
attribute_map	O
=	O
NULL	O
;	O
attributes_needed	O
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : unknown attribute map `%s'"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
command_data	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
if	O
(	O
patno	O
!=	O
-	O
1	int
&&	O
attribute_map	O
!=	O
old_map	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : attribute map can only be set before the first pattern\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
)	O
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
'\n'	O
||	O
line	int
[	O
0	int
]	O
==	O
'#'	O
)	O
{	O
if	O
(	O
state	*(int)
==	O
2	int
||	O
state	*(int)
==	O
5	int
)	O
{	O
if	O
(	O
state	*(int)
==	O
5	int
)	O
check_constraint_diagram_size	O
(	O
)	O
;	O
state	*(int)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
VALID_PATTERN_CHARS	O
,	O
line	int
[	O
0	int
]	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
VALID_EDGE_CHARS	O
,	O
line	int
[	O
0	int
]	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
VALID_CONSTRAINT_LABELS	O
,	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
0	int
:	O
case	O
3	int
:	O
case	O
6	int
:	O
case	O
7	int
:	O
case	O
8	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : What, another diagram here? (pattern %s)\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
break	O
;	O
case	O
1	int
:	O
state	*(int)
++	O
;	O
case	O
2	int
:	O
if	O
(	O
!	O
read_pattern_line	O
(	O
line	int
)	O
)	O
{	O
discard_pattern	O
=	O
1	int
;	O
el	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
4	int
:	O
state	*(int)
++	O
;	O
case	O
5	int
:	O
read_constraint_diagram_line	O
(	O
line	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
if	O
(	O
state	*(int)
==	O
2	int
||	O
state	*(int)
==	O
3	int
)	O
{	O
finish_pattern	O
(	O
line	int
)	O
;	O
if	O
(	O
!	O
discard_pattern	O
)	O
{	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
||	O
database_type	O
==	O
OPTIMIZE_DFA	O
)	O
write_to_dfa	O
(	O
patno	O
)	O
;	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
corner_add_pattern	O
(	O
)	O
;	O
else	O
if	O
(	O
database_type	O
!=	O
OPTIMIZE_DFA	O
)	O
write_elements	O
(	O
output_FILE	O
)	O
;	O
}	O
state	*(int)
=	O
4	int
;	O
save_code_pos	O
=	O
code_pos	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : warning : Unexpected entry line in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
';'	O
)	O
{	O
if	O
(	O
state	*(int)
==	O
5	int
)	O
check_constraint_diagram_size	O
(	O
)	O
;	O
if	O
(	O
state	*(int)
==	O
5	int
||	O
state	*(int)
==	O
6	int
||	O
state	*(int)
==	O
7	int
)	O
{	O
read_constraint_line	O
(	O
line	int
+	O
1	int
)	O
;	O
state	*(int)
=	O
7	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Warning: unexpected constraint line in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
'>'	O
)	O
{	O
if	O
(	O
state	*(int)
==	O
4	int
||	O
state	*(int)
==	O
5	int
||	O
state	*(int)
==	O
6	int
||	O
state	*(int)
==	O
7	int
||	O
state	*(int)
==	O
8	int
)	O
{	O
if	O
(	O
state	*(int)
==	O
5	int
)	O
check_constraint_diagram_size	O
(	O
)	O
;	O
read_action_line	O
(	O
line	int
+	O
1	int
)	O
;	O
state	*(int)
=	O
8	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: unexpected action line in pattern %s\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
=	O
strlen	(*(char))->(long)
(	O
line	int
)	O
;	O
char	O
c	char
=	O
line	int
[	O
i	int
-	O
1	int
]	O
;	O
line	int
[	O
i	int
-	O
1	int
]	O
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : error : Malformed line \"%s\" in pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
line	int
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
line	int
[	O
i	int
-	O
1	int
]	O
=	O
c	char
;	O
fatal_errors	O
++	O
;	O
}	O
}	O
}	O
convert_attribute_labels_to_offsets	O
(	O
)	O
;	O
if	O
(	O
patno	O
>=	O
0	int
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
1	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: empty pattern %s\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s(%d) : Error : no entry line for pattern %s\n"	*(char)
,	O
current_file	O
,	O
current_line_number	O
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
fatal_errors	O
++	O
;	O
break	O
;	O
case	O
5	int
:	O
case	O
6	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: constraint diagram but no constraint line for pattern %s\n"	*(char)
,	O
pattern_names	O
[	O
patno	O
]	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
case	O
8	int
:	O
finish_constraint_and_action	O
(	O
)	O
;	O
case	O
0	int
:	O
case	O
4	int
:	O
check_constraint_diagram	O
(	O
)	O
;	O
patno	O
++	O
;	O
reset_pattern	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
discard_pattern	O
)	O
{	O
patno	O
--	O
;	O
code_pos	O
=	O
save_code_pos	O
;	O
}	O
*	O
code_pos	O
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d / %d patterns have edge-constraints\n"	*(char)
,	O
pats_with_constraints	O
,	O
patno	O
)	O
;	O
if	O
(	O
database_type	O
!=	O
OPTIMIZE_DFA	O
)	O
{	O
if	O
(	O
database_type	O
!=	O
DB_CORNER	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
"static struct pattern %s[%d];\n\n"	*(char)
,	O
prefix	O
,	O
patno	O
+	O
1	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
"static struct corner_pattern %s[%d];\n\n"	*(char)
,	O
prefix	O
,	O
patno	O
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
"%s"	*(char)
,	O
autohelper_code	O
)	O
;	O
if	O
(	O
attributes_needed	O
)	O
write_attributes	O
(	O
output_FILE	O
)	O
;	O
else	O
assert	O
(	O
num_attributes	O
==	O
1	int
)	O
;	O
write_patterns	O
(	O
output_FILE	O
)	O
;	O
if	O
(	O
database_type	O
==	O
DB_DFA	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---------------------------\n"	*(char)
)	O
;	O
dfa_finalize	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
;	O
dfa_shuffle	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"DFA for %s\n"	*(char)
,	O
prefix	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"size: %d kB for "	*(char)
,	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d patterns"	*(char)
,	O
patno	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" (%d states)\n"	*(char)
,	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
.	O
last_state	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
.	O
name	short
,	O
prefix	O
)	O
;	O
print_c_dfa	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
output_FILE	O
,	O
prefix	O
,	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---------------------------\n"	*(char)
)	O
;	O
if	O
(	O
DFA_MAX_MATCHED	O
/	O
8	int
<	O
dfa_calculate_max_matched_patterns	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: Increase DFA_MAX_MATCHED in 'dfa.h'.\n"	*(char)
)	O
;	O
kill_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
dfa	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
;	O
dfa_end	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
database_type	O
==	O
DB_CORNER	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---------------------------\n"	*(char)
)	O
;	O
corner_pack_variations	O
(	O
corner_root	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
"static struct corner_variation %s_variations[] = {\n"	*(char)
,	O
prefix	O
)	O
;	O
corner_write_variations	O
(	O
corner_root	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
output_FILE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"corner database for %s\n"	*(char)
,	O
prefix	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"size: %d kB for %d patterns (%d variations)\n"	*(char)
,	O
CORNER_DB_SIZE	O
(	O
patno	O
,	O
total_variations	O
)	O
,	O
patno	O
,	O
total_variations	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"---------------------------\n"	*(char)
)	O
;	O
}	O
write_pattern_db	O
(	O
output_FILE	O
)	O
;	O
if	O
(	O
fatal_errors	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output_FILE	O
,	O
"\n#error: One or more fatal errors compiling %s\n"	*(char)
,	O
current_file	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
k	int
;	O
int	O
*	O
optimized_variations	O
;	O
transformations_FILE	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
transformations_file_name	O
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
transformations_FILE	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error : cannot write to file %s\n"	*(char)
,	O
transformations_file_name	O
)	O
;	O
}	O
optimized_variations	O
=	O
dfa_patterns_optimize_variations	O
(	O
&	O
dfa_pats	O
,	O
iterations	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
patno	O
;	O
k	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
transformations_FILE	O
,	O
"%s\t%d\n"	*(char)
,	O
pattern_names	O
[	O
k	int
]	O
,	O
optimized_variations	O
[	O
k	int
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
optimized_variations	O
)	O
;	O
dfa_end	()->(void)
(	O
)	O
;	O
}	O
return	O
fatal_errors	O
?	O
1	int
:	O
0	int
;	O
}	O
