static	O
size_t	long
compare_count	long
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
{	O
char	O
*	O
word	*(char)
;	O
size_t	long
length	long
;	O
size_t	long
wordlen	long
;	O
off_t	long
offset	long
;	O
size_t	long
size	long
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
peer	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
}	O
;	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
{	O
char	O
*	O
name	*(char)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
size_t	long
count	long
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
index	*(int)
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
info_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
*	O
descr_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
*	O
lang_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
*	O
mime_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
}	O
;	O
static	O
size_t	long
trimnl	(*(char))->(long)
(	O
char	O
*	O
buf	*(void)
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
buf	*(void)
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	*(void)
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
len	int
;	O
}	O
static	O
size_t	long
trimws	(*(char))->(long)
(	O
char	O
*	O
buf	*(void)
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
while	O
(	O
len	int
>	O
0	int
&&	O
isspace	(int)->(int)
(	O
buf	*(void)
[	O
len	int
-	O
1	int
]	O
)	O
)	O
buf	*(void)
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
len	int
;	O
}	O
static	O
int	O
find_header	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),long,*(long))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
char	O
*	O
buf	*(void)
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pread	*(long)
)	O
{	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(void)
,	O
size	long
,	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
size_t	long
rdbytes	long
=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
size_t	long
len	int
=	O
trimnl	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
int	O
level	int
;	O
for	O
(	O
level	int
=	O
0	int
;	O
buf	*(void)
[	O
level	int
]	O
==	O
'*'	O
&&	O
level	int
<	O
len	int
;	O
level	int
++	O
)	O
;	O
if	O
(	O
level	int
)	O
{	O
*	O
pread	*(long)
=	O
rdbytes	long
;	O
return	O
level	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
off_t	long
skipws	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),long)->(long)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
char	O
*	O
buf	*(void)
,	O
size_t	long
size	long
)	O
{	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(void)
,	O
size	long
,	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
!	O
(	O
len	int
==	O
1	int
&&	O
buf	*(void)
[	O
0	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
-	O
(	O
off_t	long
)	O
len	int
,	O
SEEK_CUR	int
)	O
;	O
break	O
;	O
}	O
}	O
return	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
alloc_entry	(*(char),long)->(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
(	O
const	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	int
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
)	O
;	O
if	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
0	int
,	O
sizeof	O
(	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
text	*(char)
,	O
len	int
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
length	long
=	O
len	int
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
)	O
;	O
}	O
return	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
}	O
static	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
read_entry	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(int))->(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
int	O
*	O
plevel	*(int)
)	O
{	O
char	O
buf	*(void)
[	O
128	int
]	O
,	O
*	O
p	*(char)
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
int	O
level	int
;	O
size_t	long
rdbytes	long
,	O
len	int
;	O
level	int
=	O
find_header	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),long,*(long))->(int)
(	O
file	*(char)
,	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
,	O
&	O
rdbytes	long
)	O
;	O
if	O
(	O
level	int
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
plevel	*(int)
=	O
level	int
;	O
for	O
(	O
p	*(char)
=	O
buf	*(void)
+	O
level	int
;	O
*	O
p	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
p	*(char)
)	O
;	O
p	*(char)
++	O
)	O
;	O
len	int
=	O
trimws	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
alloc_entry	(*(char),long)->(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
(	O
p	*(char)
,	O
len	int
)	O
;	O
if	O
(	O
!	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
return	O
NULL	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
offset	long
=	O
skipws	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),long)->(long)
(	O
file	*(char)
,	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
;	O
find_header	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),long,*(long))->(int)
(	O
file	*(char)
,	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
,	O
&	O
rdbytes	long
)	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
-	O
(	O
off_t	long
)	O
rdbytes	long
,	O
SEEK_CUR	int
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
size	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
-	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
offset	long
;	O
return	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
}	O
enum	O
result_type	enum(int,int,int)
{	O
result_match	int
,	O
result_match_list	int
,	O
result_define	int
}	O
;	O
struct	O
result	*(int)
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
;	O
enum	O
result_type	enum(int,int,int)
type	enum(int,int,int)
;	O
size_t	long
count	long
;	O
size_t	long
compare_count	long
;	O
union	O
{	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
}	O
v	union(long,*(*(char)))
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
entry_match_t	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
)	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
;	O
struct	O
strategy_def	struct(struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int)))
{	O
struct	O
dico_strategy	struct(*(char),*(char),*((int,*(struct),*(char))->(int)),*(void),int,*(struct))
strat	*(struct)
;	O
entry_match_t	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
;	O
}	O
;	O
static	O
int	O
exact_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	*(int)
*	O
)	O
;	O
static	O
int	O
prefix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	*(int)
*	O
)	O
;	O
static	O
int	O
suffix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
;	O
static	O
struct	O
strategy_def	struct(struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int)))
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	*(char)
,	O
"Match words exactly"	*(char)
}	O
,	O
exact_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
}	O
,	O
{	O
{	O
"prefix"	*(char)
,	O
"Match word prefixes"	*(char)
}	O
,	O
prefix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
}	O
,	O
{	O
{	O
"suffix"	*(char)
,	O
"Match word suffixes"	*(char)
}	O
,	O
suffix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
}	O
}	O
;	O
static	O
entry_match_t	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
find_matcher	(*(char))->(*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int)))
(	O
const	O
char	O
*	O
strat	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
strat	*(struct)
,	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
[	O
i	int
]	O
.	O
strat	*(struct)
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
[	O
i	int
]	O
.	O
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
outline_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
)	O
;	O
i	int
++	O
)	O
dico_strategy_add	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
&	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int))))
[	O
i	int
]	O
.	O
strat	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_entry	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
)	O
{	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
epa	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
a	*(struct)
;	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
epb	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
b	*(struct)
;	O
compare_count	long
++	O
;	O
return	O
utf8_strcasecmp	(*(char),*(char))->(int)
(	O
epa	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
epb	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
)	O
;	O
}	O
static	O
void	O
revert_word	(*(char),*(char),long)->(void)
(	O
char	O
*	O
dst	*(char)
,	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
len	int
)	O
{	O
struct	O
utf8_iterator	struct(*(char),*(char),int,long,int,int)
itr	*((*(void),*(void))->(int))
;	O
char	O
*	O
p	*(char)
=	O
dst	*(char)
+	O
len	int
;	O
*	O
p	*(char)
=	O
0	int
;	O
for	O
(	O
utf8_iter_init	(*(struct(*(char),*(char),int,long,int,int)),*(char),long)->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
,	O
(	O
char	O
*	O
)	O
src	*(char)
,	O
len	int
)	O
;	O
!	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
utf8_iter_next	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
p	*(char)
-=	O
itr	*((*(void),*(void))->(int))
.	O
curwidth	int
;	O
if	O
(	O
p	*(char)
<	O
dst	*(char)
)	O
break	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
,	O
itr	*((*(void),*(void))->(int))
.	O
curwidth	int
)	O
;	O
}	O
}	O
static	O
int	O
init_suffix_index	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
)	O
{	O
if	O
(	O
!	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
size_t	long
i	int
;	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
calloc	(long,long)->(*(void))
(	O
file	*(char)
->	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	*(char)
->	O
count	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
while	O
(	O
i	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
--	O
i	int
]	O
.	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
return	O
1	int
;	O
}	O
revert_word	(*(char),*(char),long)->(void)
(	O
p	*(char)
,	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
.	O
word	*(char)
,	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
.	O
length	long
)	O
;	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
i	int
]	O
=	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
;	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
i	int
]	O
.	O
word	*(char)
=	O
p	*(char)
;	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
i	int
]	O
.	O
peer	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
&	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
;	O
}	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
file	*(char)
->	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
0	int
]	O
)	O
,	O
compare_entry	(*(void),*(void))->(int)
)	O
;	O
compare_count	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
exact_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
word	*(char)
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
file	*(char)
->	O
index	*(int)
,	O
file	*(char)
->	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_entry	(*(void),*(void))->(int)
)	O
;	O
if	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
count	long
=	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
compare_prefix	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
)	O
{	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
pkey	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
a	*(struct)
;	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
pelt	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
b	*(struct)
;	O
size_t	long
wordlen	long
=	O
pkey	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
wordlen	long
;	O
if	O
(	O
pelt	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
wordlen	long
<	O
wordlen	long
)	O
wordlen	long
=	O
pelt	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
return	O
utf8_strncasecmp	(*(char),*(char),long)->(int)
(	O
pkey	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
pelt	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
prefix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
word	*(char)
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
file	*(char)
->	O
index	*(int)
,	O
file	*(char)
->	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_prefix	(*(void),*(void))->(int)
)	O
;	O
if	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
size_t	long
count	long
=	O
1	int
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
-	O
1	int
;	O
p	*(char)
>	O
file	*(char)
->	O
index	*(int)
&&	O
compare_prefix	(*(void),*(void))->(int)
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
p	*(char)
)	O
==	O
0	int
;	O
p	*(char)
--	O
)	O
count	long
++	O
;	O
for	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
++	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
<	O
file	*(char)
->	O
index	*(int)
+	O
file	*(char)
->	O
count	long
&&	O
compare_prefix	(*(void),*(void))->(int)
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
==	O
0	int
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
++	O
)	O
count	long
++	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
p	*(char)
+	O
1	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
count	long
=	O
count	long
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
compare_entry_ptr	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
const	O
*	O
epa	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
a	*(struct)
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
const	O
*	O
epb	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
b	*(struct)
;	O
compare_count	long
++	O
;	O
return	O
utf8_strcasecmp	(*(char),*(char))->(int)
(	O
(	O
*	O
epa	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
->	O
word	*(char)
,	O
(	O
*	O
epb	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
->	O
word	*(char)
)	O
;	O
}	O
static	O
int	O
suffix_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
int	O
rc	int
;	O
if	O
(	O
init_suffix_index	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))))->(int)
(	O
file	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
=	O
malloc	(long)->(*(void))
(	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
revert_word	(*(char),*(char),long)->(void)
(	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
,	O
word	*(char)
,	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
length	long
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
file	*(char)
->	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
0	int
]	O
)	O
,	O
compare_prefix	(*(void),*(void))->(int)
)	O
;	O
if	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
p	*(char)
,	O
*	O
*	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
;	O
size_t	long
count	long
=	O
1	int
;	O
for	O
(	O
p	*(char)
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
-	O
1	int
;	O
p	*(char)
>	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
&&	O
compare_prefix	(*(void),*(void))->(int)
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
p	*(char)
)	O
==	O
0	int
;	O
p	*(char)
--	O
)	O
count	long
++	O
;	O
for	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
++	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
<	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
+	O
file	*(char)
->	O
count	long
&&	O
compare_prefix	(*(void),*(void))->(int)
(	O
&	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
==	O
0	int
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
++	O
)	O
count	long
++	O
;	O
p	*(char)
++	O
;	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
=	O
calloc	(long,long)->(*(void))
(	O
count	long
,	O
sizeof	O
(	O
*	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
)	O
)	O
;	O
if	O
(	O
!	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
=	O
result_match_list	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
[	O
i	int
]	O
=	O
p	*(char)
[	O
i	int
]	O
.	O
peer	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
,	O
count	long
,	O
sizeof	O
(	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
[	O
0	int
]	O
)	O
,	O
compare_entry_ptr	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
,	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
[	O
i	int
]	O
)	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
count	long
=	O
dico_list_count	(*(struct))->(long)
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
free	(*(void))->(void)
(	O
epp	*(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
)	O
;	O
}	O
}	O
else	O
rc	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
x	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
.	O
word	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
outline_free_db	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
size_t	long
i	int
;	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
info_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
descr_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
lang_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
mime_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	*(char)
->	O
count	long
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
.	O
word	*(char)
)	O
;	O
if	O
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
[	O
i	int
]	O
.	O
word	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
index	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
->	O
suf_index	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
dico_handle_t	*(struct)
outline_init_db	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
dbname	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
int	O
level	int
;	O
int	O
state	*(int)
;	O
size_t	long
i	int
,	O
count	long
;	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_open: wrong number of arguments"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot open file %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
file	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
file	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
NULL	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
file	*(char)
,	O
0	int
,	O
sizeof	O
(	O
*	O
file	*(char)
)	O
)	O
;	O
file	*(char)
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
state	*(int)
=	O
STATE_INITIAL	int
;	O
while	O
(	O
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
read_entry	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(int))->(*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))
(	O
file	*(char)
,	O
&	O
level	int
)	O
)	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
STATE_DICT	int
:	O
if	O
(	O
level	int
==	O
2	int
)	O
{	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
state	*(int)
=	O
STATE_INITIAL	int
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
break	O
;	O
}	O
case	O
STATE_INITIAL	int
:	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
"info"	*(char)
)	O
==	O
0	int
)	O
{	O
file	*(char)
->	O
info_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
"description"	*(char)
)	O
==	O
0	int
)	O
{	O
file	*(char)
->	O
descr_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
"languages"	*(char)
)	O
==	O
0	int
)	O
{	O
file	*(char)
->	O
lang_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
"mime"	*(char)
)	O
==	O
0	int
)	O
{	O
file	*(char)
->	O
mime_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
"dictionary"	*(char)
)	O
==	O
0	int
)	O
state	*(int)
=	O
STATE_DICT	int
;	O
}	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
break	O
;	O
}	O
}	O
file	*(char)
->	O
count	long
=	O
count	long
=	O
dico_list_count	(*(struct))->(long)
(	O
list	array(*(struct))
)	O
;	O
file	*(char)
->	O
index	*(int)
=	O
calloc	(long,long)->(*(void))
(	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	*(char)
->	O
index	*(int)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
outline_free_db	(*(struct))->(int)
(	O
(	O
dico_handle_t	*(struct)
)	O
file	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
itr	*((*(void),*(void))->(int))
=	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
list	array(*(struct))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
i	int
++	O
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
=	O
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	array(*(struct))
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
file	*(char)
->	O
index	*(int)
,	O
count	long
,	O
sizeof	O
(	O
file	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_entry	(*(void),*(void))->(int)
)	O
;	O
return	O
(	O
dico_handle_t	*(struct)
)	O
file	*(char)
;	O
}	O
static	O
inline	O
int	O
isws	(int)->(int)
(	O
int	O
c	int
)	O
{	O
return	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
'\r'	O
||	O
c	int
==	O
'\f'	O
;	O
}	O
static	O
char	O
*	O
read_buf	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))),int)->(*(char))
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
int	O
trim	int
)	O
{	O
size_t	long
size	long
;	O
char	O
*	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
return	O
NULL	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
size	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(void)
,	O
1	int
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
size	long
,	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
trim	int
&&	O
size	long
>	O
0	int
&&	O
buf	*(void)
[	O
size	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
while	O
(	O
size	long
>	O
0	int
&&	O
buf	*(void)
[	O
size	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
--	O
size	long
;	O
while	O
(	O
size	long
>	O
0	int
&&	O
isws	(int)->(int)
(	O
buf	*(void)
[	O
size	long
-	O
1	int
]	O
)	O
)	O
--	O
size	long
;	O
}	O
buf	*(void)
[	O
size	long
++	O
]	O
=	O
'\n'	O
;	O
}	O
buf	*(void)
[	O
size	long
]	O
=	O
0	int
;	O
return	O
buf	*(void)
;	O
}	O
static	O
char	O
*	O
outline_info	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
if	O
(	O
file	*(char)
->	O
info_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
return	O
read_buf	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))),int)->(*(char))
(	O
file	*(char)
,	O
file	*(char)
->	O
info_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
outline_descr	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
if	O
(	O
file	*(char)
->	O
descr_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
char	O
*	O
buf	*(void)
=	O
read_buf	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))),int)->(*(char))
(	O
file	*(char)
,	O
file	*(char)
->	O
descr_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
0	int
)	O
;	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(void)
,	O
'\n'	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
*	O
p	*(char)
=	O
0	int
;	O
return	O
buf	*(void)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
outline_lang	(*(struct),array(*(struct)))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
dico_list_t	*(struct)
list	array(*(struct))
[	O
2	int
]	O
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
list	array(*(struct))
[	O
0	int
]	O
=	O
list	array(*(struct))
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
file	*(char)
->	O
lang_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
int	O
n	long
=	O
0	int
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(int)
;	O
char	O
*	O
buf	*(void)
=	O
read_buf	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))),int)->(*(char))
(	O
file	*(char)
,	O
file	*(char)
->	O
lang_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
0	int
)	O
;	O
ws	*(int)
.	O
ws_delim	*(char)
=	O
"\n"	*(char)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
buf	*(void)
,	O
&	O
ws	*(int)
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_DELIM	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ws	*(int)
.	O
ws_wordc	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ws	*(int)
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
n	long
==	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
,	O
":"	*(char)
)	O
==	O
0	int
)	O
{	O
n	long
=	O
1	int
;	O
free	(*(void))->(void)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
list	array(*(struct))
[	O
n	long
]	O
)	O
list	array(*(struct))
[	O
n	long
]	O
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
[	O
n	long
]	O
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
ws	*(int)
.	O
ws_wordc	long
=	O
0	int
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(int)
)	O
;	O
}	O
else	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_lang: not enough memory"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
dico_result_t	*(struct)
outline_match0	(*(struct),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int)),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
entry_match_t	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
compare_count	long
=	O
0	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
return	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
file	*(char)
=	O
file	*(char)
;	O
if	O
(	O
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
(	O
file	*(char)
,	O
word	*(char)
,	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
NULL	O
;	O
}	O
else	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
}	O
static	O
dico_result_t	*(struct)
outline_match_all	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
size_t	long
count	long
,	O
i	int
;	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
key	*(char)
;	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_match_all: not enough memory"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
&	O
key	*(char)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_match_all: key initialization failed"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	*(char)
->	O
count	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dico_key_match	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
&	O
key	*(char)
,	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
.	O
word	*(char)
)	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
&	O
file	*(char)
->	O
index	*(int)
[	O
i	int
]	O
)	O
;	O
}	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
&	O
key	*(char)
)	O
;	O
compare_count	long
=	O
file	*(char)
->	O
count	long
;	O
count	long
=	O
dico_list_count	(*(struct))->(long)
(	O
list	array(*(struct))
)	O
;	O
if	O
(	O
count	long
==	O
0	int
)	O
{	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	array(*(struct))
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
return	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
file	*(char)
=	O
file	*(char)
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
=	O
result_match_list	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
count	long
=	O
count	long
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
=	O
list	array(*(struct))
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
}	O
static	O
dico_result_t	*(struct)
outline_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
entry_match_t	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
=	O
find_matcher	(*(char))->(*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int)))
(	O
strat	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
)	O
return	O
outline_match0	(*(struct),*((*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,enum(int,int,int),long,long,union`)))->(int)),*(char))->(*(struct))
(	O
hp	*(struct)
,	O
match	*((*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),*(char),*(struct(*(struct`),enum(int,int,int),long,long,union(*`,*`))))->(int))
,	O
word	*(char)
)	O
;	O
else	O
if	O
(	O
strat	*(struct)
->	O
sel	*((*(char),*(void))->(int))
)	O
return	O
outline_match_all	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
hp	*(struct)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	*(struct)
outline_define	(*(struct),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
compare_count	long
=	O
0	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
return	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
file	*(char)
=	O
file	*(char)
;	O
if	O
(	O
exact_match	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(char),*(struct(*(struct(*`,*`,long,*`,*`,*`,*`,*`,*`)),enum(int,int,int),long,long,union(*(struct`),*(struct`)))))->(int)
(	O
file	*(char)
,	O
word	*(char)
,	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
)	O
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
NULL	O
;	O
}	O
else	O
{	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
=	O
result_define	int
;	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
compare_count	long
=	O
compare_count	long
;	O
}	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
;	O
}	O
static	O
void	O
printdef	(*(struct),*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))->(void)
(	O
dico_stream_t	*(struct)
str	*(struct)
,	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
,	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(char)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
size_t	long
size	long
=	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
size	long
;	O
char	O
buf	*(void)
[	O
128	int
]	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
size	long
)	O
{	O
size_t	long
rdsize	long
=	O
size	long
;	O
if	O
(	O
rdsize	long
>	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
rdsize	long
=	O
sizeof	O
(	O
buf	*(void)
)	O
;	O
rdsize	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(void)
,	O
1	int
,	O
rdsize	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
rdsize	long
==	O
0	int
)	O
break	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
buf	*(void)
,	O
rdsize	long
)	O
;	O
size	long
-=	O
rdsize	long
;	O
}	O
}	O
static	O
int	O
outline_output_result	(*(struct),long,*(struct))->(int)
(	O
dico_result_t	*(struct)
rp	*(struct)
,	O
size_t	long
n	long
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
const	O
struct	O
entry	struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
;	O
switch	O
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
result_match	int
:	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
+	O
n	long
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
strlen	(*(char))->(long)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
result_match_list	int
:	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
dico_list_item	(*(struct),long)->(*(void))
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
,	O
n	long
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
,	O
strlen	(*(char))->(long)
(	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
->	O
word	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
result_define	int
:	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
=	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
+	O
n	long
;	O
printdef	(*(struct),*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))))->(void)
(	O
str	*(struct)
,	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
file	*(char)
,	O
ep	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
outline_result_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
return	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
count	long
;	O
}	O
static	O
size_t	long
outline_compare_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
return	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
compare_count	long
;	O
}	O
static	O
void	O
outline_free_result	(*(struct))->(void)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
if	O
(	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
type	enum(int,int,int)
==	O
result_match_list	int
)	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct(*(struct(*(char),*(struct`),long,*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`))),enum(int,int,int),long,long,union(*(struct(*`,long,long,long,long,*`)),*(struct))))
->	O
v	union(long,*(*(char)))
.	O
list	array(*(struct))
)	O
;	O
free	(*(void))->(void)
(	O
rp	*(struct)
)	O
;	O
}	O
static	O
char	O
*	O
outline_db_mime_header	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
file	*(char)
=	O
(	O
struct	O
outline_file	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long,*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))),*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`))))))
*	O
)	O
hp	*(struct)
;	O
if	O
(	O
file	*(char)
->	O
mime_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
)	O
return	O
read_buf	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long,*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)),*(struct(*`,long,long,long,long,*`)))),*(struct(*(char),long,long,long,long,*(struct(*`,long,long,long,long,*`)))),int)->(*(char))
(	O
file	*(char)
,	O
file	*(char)
->	O
mime_entry	*(struct(*(char),long,long,long,long,*(struct(*(char),long,long,long,long,*(struct`)))))
,	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
outline	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	*((int,*(*(char)))->(int))
=	O
outline_init	(int,*(*(char)))->(int)
,	O
.	O
dico_init_db	*((*(char),int,*(*(char)))->(*(struct)))
=	O
outline_init_db	(*(char),int,*(*(char)))->(*(struct))
,	O
.	O
dico_free_db	*((*(struct))->(int))
=	O
outline_free_db	(*(struct))->(int)
,	O
.	O
dico_db_info	*((*(struct))->(*(char)))
=	O
outline_info	(*(struct))->(*(char))
,	O
.	O
dico_db_descr	*((*(struct))->(*(char)))
=	O
outline_descr	(*(struct))->(*(char))
,	O
.	O
dico_db_lang	*((*(struct),array(*(struct)))->(int))
=	O
outline_lang	(*(struct),array(*(struct)))->(int)
,	O
.	O
dico_match	*((*(struct),*(struct),*(char))->(*(struct)))
=	O
outline_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
,	O
.	O
dico_define	*((*(struct),*(char))->(*(struct)))
=	O
outline_define	(*(struct),*(char))->(*(struct))
,	O
.	O
dico_output_result	*((*(struct),long,*(struct))->(int))
=	O
outline_output_result	(*(struct),long,*(struct))->(int)
,	O
.	O
dico_result_count	*((*(struct))->(long))
=	O
outline_result_count	(*(struct))->(long)
,	O
.	O
dico_compare_count	*((*(struct))->(long))
=	O
outline_compare_count	(*(struct))->(long)
,	O
.	O
dico_free_result	*((*(struct))->(void))
=	O
outline_free_result	(*(struct))->(void)
,	O
.	O
dico_db_mime_header	*((*(struct))->(*(char)))
=	O
outline_db_mime_header	(*(struct))->(*(char))
}	O
;	O
