struct	O
decode_closure	struct(int)
{	O
int	O
select_hdr	int
;	O
}	O
;	O
static	O
int	O
print_stream	(*(struct),*(struct))->(int)
(	O
mu_stream_t	*(struct)
,	O
mu_stream_t	*(struct)
)	O
;	O
static	O
int	O
display_message	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(void))->(int)
(	O
mu_message_t	*(struct)
,	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
void	O
*	O
closure	*(void)
)	O
;	O
static	O
int	O
display_submessage	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*(void))->(int)
(	O
struct	O
mime_descend_closure	struct(int,*(struct(*(struct(*(struct`),int,*(long))),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*(struct`),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))))))
*	O
closure	*(void)
,	O
void	O
*	O
data	*(void)
)	O
;	O
static	O
int	O
get_content_encoding	(*(struct),*(*(char)))->(int)
(	O
mu_header_t	*(struct)
hdr	*(struct)
,	O
char	O
*	O
*	O
value	*(void)
)	O
;	O
static	O
void	O
run_metamail	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
mailcap	*(char)
,	O
mu_message_t	*(struct)
mesg	*(struct)
)	O
;	O
int	O
mail_decode	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
;	O
struct	O
decode_closure	struct(int)
decode_closure	struct(int)
;	O
if	O
(	O
msgset_parse	(int,*(*(char)),int,*(*(struct(*(struct`),int,*(long)))))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
MSG_NODELETED	int
|	O
MSG_SILENT	int
,	O
&	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
)	O
)	O
return	O
1	int
;	O
decode_closure	struct(int)
.	O
select_hdr	int
=	O
mu_islower	O
(	O
argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
;	O
util_msgset_iterate	(*(struct(*(struct(*`,int,*`)),int,*(long))),*((*(struct),*(struct(*`,int,*`)),*(void))->(int)),*(void))->(void)
(	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
display_message	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
&	O
decode_closure	struct(int)
)	O
;	O
msgset_free	(*(struct(*(struct(*`,int,*`)),int,*(long))))->(void)
(	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
display_message	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(void))->(int)
(	O
mu_message_t	*(struct)
mesg	*(struct)
,	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
void	O
*	O
arg	*(char)
)	O
{	O
struct	O
decode_closure	struct(int)
*	O
closure	*(void)
=	O
arg	*(char)
;	O
mu_attribute_t	*(struct)
attr	*(struct)
=	O
NULL	O
;	O
struct	O
mime_descend_closure	struct(int,*(struct(*(struct(*(struct`),int,*(long))),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*(struct`),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))))))
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
if	O
(	O
mu_attribute_is_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
)	O
return	O
1	int
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
hints	*(struct(*(char),*(char)))
=	O
closure	*(void)
->	O
select_hdr	int
?	O
MDHINT_SELECTED_HEADERS	int
:	O
0	int
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
=	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
message	*(struct)
=	O
mesg	*(struct)
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
type	*(char)
=	O
NULL	O
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
encoding	*(char)
=	O
NULL	O
;	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
mime_descend	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*((*(struct(int,*`,*`,*`,*`,*`)),*(void))->(int)),*(void))->(int)
(	O
&	O
mclos	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
,	O
display_submessage	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*(void))->(int)
,	O
NULL	O
)	O
;	O
if	O
(	O
mu_mailbox_get_message	(*(struct),long,*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
msg_part	*(long)
[	O
0	int
]	O
,	O
&	O
mesg	*(struct)
)	O
==	O
0	int
)	O
util_mark_read	(*(struct))->(void)
(	O
mesg	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
display_headers	(*(struct),*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),int)->(void)
(	O
mu_stream_t	*(struct)
out	*(struct)
,	O
mu_message_t	*(struct)
mesg	*(struct)
,	O
const	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
MU_ARG_UNUSED	O
,	O
int	O
select_hdr	int
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
if	O
(	O
select_hdr	int
)	O
{	O
size_t	long
num	long
=	O
0	int
;	O
size_t	long
i	int
=	O
0	int
;	O
const	O
char	O
*	O
sptr	*(*(char))
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_get_field_count	(*(struct),*(long))->(int)
(	O
hdr	*(struct)
,	O
&	O
num	long
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
num	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mu_header_sget_field_name	(*(struct),long,*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
i	int
,	O
&	O
sptr	*(*(char))
)	O
)	O
continue	O
;	O
if	O
(	O
mail_header_is_visible	(*(char))->(int)
(	O
sptr	*(*(char))
)	O
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s: "	*(char)
,	O
sptr	*(*(char))
)	O
;	O
if	O
(	O
mu_header_sget_field_value	(*(struct),long,*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
i	int
,	O
&	O
sptr	*(*(char))
)	O
)	O
sptr	*(*(char))
=	O
""	*(char)
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s\n"	*(char)
,	O
sptr	*(*(char))
)	O
;	O
}	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
mu_stream_t	*(struct)
stream	*(struct)
=	O
NULL	O
;	O
if	O
(	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
==	O
0	int
&&	O
mu_header_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
hdr	*(struct)
,	O
&	O
stream	*(struct)
)	O
==	O
0	int
)	O
{	O
print_stream	(*(struct),*(struct))->(int)
(	O
stream	*(struct)
,	O
out	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
}	O
}	O
}	O
void	O
format_msgset	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(long))->(void)
(	O
mu_stream_t	*(struct)
str	*(struct)
,	O
const	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
size_t	long
*	O
count	*(long)
)	O
{	O
int	O
i	int
;	O
mu_stream_stat_buffer	array(long)
stat	*(int)
;	O
if	O
(	O
count	*(long)
)	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
str	*(struct)
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	*(int)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
msg_part	*(long)
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
npart	int
;	O
i	int
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"[%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
msg_part	*(long)
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
npart	int
;	O
i	int
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"]"	*(char)
)	O
;	O
if	O
(	O
count	*(long)
)	O
{	O
*	O
count	*(long)
=	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
str	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
display_part_header	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(char),*(char))->(void)
(	O
mu_stream_t	*(struct)
str	*(struct)
,	O
const	O
msgset_t	struct
*	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
const	O
char	O
*	O
type	*(char)
,	O
const	O
char	O
*	O
encoding	*(char)
)	O
{	O
int	O
size	long
=	O
util_screen_columns	()->(int)
(	O
)	O
-	O
3	int
;	O
unsigned	O
int	O
i	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"+"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
int	O
)	O
i	int
<=	O
size	long
;	O
i	int
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"-"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"+"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"%s"	*(char)
,	O
_	O
(	O
"| Message="	*(char)
)	O
)	O
;	O
format_msgset	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(long))->(void)
(	O
str	*(struct)
,	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
NULL	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
_	O
(	O
"| Type=%s\n"	*(char)
)	O
,	O
type	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
_	O
(	O
"| Encoding=%s\n"	*(char)
)	O
,	O
encoding	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"+"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
size	long
;	O
i	int
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"-"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"+"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
)	O
;	O
}	O
int	O
mime_descend	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*((*(struct(int,*`,*`,*`,*`,*`)),*(void))->(int)),*(void))->(int)
(	O
struct	O
mime_descend_closure	struct(int,*(struct(*(struct(*(struct`),int,*(long))),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*(struct`),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))))))
*	O
closure	*(void)
,	O
mime_descend_fn	*((*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))),*(void))->(int))
fun	*((*(char),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
status	int
=	O
0	int
;	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
char	O
*	O
type	*(char)
;	O
char	O
*	O
encoding	*(char)
;	O
int	O
ismime	int
=	O
0	int
;	O
struct	O
mime_descend_closure	struct(int,*(struct(*(struct(*(struct`),int,*(long))),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*(struct`),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))))))
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
util_get_hdr_value	(*(struct),*(char),*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
MU_HEADER_CONTENT_TYPE	*(char)
,	O
&	O
type	*(char)
)	O
;	O
if	O
(	O
type	*(char)
==	O
NULL	O
)	O
type	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
"text/plain"	*(char)
)	O
;	O
get_content_encoding	(*(struct),*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
&	O
encoding	*(char)
)	O
;	O
closure	*(void)
->	O
type	*(char)
=	O
type	*(char)
;	O
closure	*(void)
->	O
encoding	*(char)
=	O
encoding	*(char)
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
hints	*(struct(*(char),*(char)))
=	O
0	int
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
parent	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
closure	*(void)
;	O
mu_message_is_multipart	(*(struct),*(int))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
ismime	int
)	O
;	O
if	O
(	O
ismime	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
size_t	long
nparts	*(long)
;	O
status	int
=	O
mu_message_get_num_parts	(*(struct),*(long))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
nparts	*(long)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERR	O
,	O
"mu_message_get_num_parts"	*(char)
,	O
NULL	O
,	O
status	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
nparts	*(long)
;	O
j	int
++	O
)	O
{	O
mu_message_t	*(struct)
message	*(struct)
=	O
NULL	O
;	O
if	O
(	O
mu_message_get_part	(*(struct),long,*(*(struct)))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
j	int
,	O
&	O
message	*(struct)
)	O
==	O
0	int
)	O
{	O
msgset_t	struct
*	O
set	int
=	O
msgset_expand	(*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct(*(struct(*`,int,*`)),int,*(long))))->(*(struct(*(struct(*`,int,*`)),int,*(long))))
(	O
msgset_dup	(*(struct(*(struct(*`,int,*`)),int,*(long))))->(*(struct(*(struct(*`,int,*`)),int,*(long))))
(	O
closure	*(void)
->	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
)	O
,	O
msgset_make_1	(long)->(*(struct(*(struct(*`,int,*`)),int,*(long))))
(	O
j	int
)	O
)	O
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
=	O
set	int
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
message	*(struct)
=	O
message	*(struct)
;	O
status	int
=	O
mime_descend	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*((*(struct(int,*`,*`,*`,*`,*`)),*(void))->(int)),*(void))->(int)
(	O
&	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
,	O
fun	*((*(char),*(void))->(int))
,	O
data	*(void)
)	O
;	O
msgset_free	(*(struct(*(struct(*`,int,*`)),int,*(long))))->(void)
(	O
set	int
)	O
;	O
if	O
(	O
status	int
)	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
mu_c_strncasecmp	(*(char),*(char),long)->(int)
(	O
type	*(char)
,	O
"message/rfc822"	*(char)
,	O
14	int
)	O
==	O
0	int
)	O
{	O
mu_message_t	*(struct)
submsg	*(struct)
=	O
NULL	O
;	O
if	O
(	O
mu_message_unencapsulate	(*(struct),*(*(struct)),*(struct))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
submsg	*(struct)
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
hints	*(struct(*(char),*(char)))
=	O
MDHINT_SELECTED_HEADERS	int
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
=	O
closure	*(void)
->	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
;	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
.	O
message	*(struct)
=	O
submsg	*(struct)
;	O
status	int
=	O
mime_descend	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*((*(struct(int,*`,*`,*`,*`,*`)),*(void))->(int)),*(void))->(int)
(	O
&	O
subclosure	struct(int,*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))))
,	O
fun	*((*(char),*(void))->(int))
,	O
data	*(void)
)	O
;	O
}	O
}	O
else	O
status	int
=	O
fun	*((*(char),*(void))->(int))
(	O
closure	*(void)
,	O
data	*(void)
)	O
;	O
closure	*(void)
->	O
type	*(char)
=	O
NULL	O
;	O
closure	*(void)
->	O
encoding	*(char)
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
type	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
encoding	*(char)
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
display_submessage	(*(struct(int,*(struct(*`,int,*`)),*(struct),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)))),*(void))->(int)
(	O
struct	O
mime_descend_closure	struct(int,*(struct(*(struct(*(struct`),int,*(long))),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct(*(struct`),int,*(long))),*(struct),*(char),*(char),*(struct(int,*(struct`),*(struct`),*(char),*(char),*(struct`))))))
*	O
closure	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
if	O
(	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
tmp	*(char)
,	O
mailvar_name_metamail	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
==	O
0	int
)	O
{	O
run_metamail	(*(char),*(struct))->(void)
(	O
tmp	*(char)
,	O
closure	*(void)
->	O
message	*(struct)
)	O
;	O
}	O
else	O
{	O
int	O
builtin_display	int
=	O
1	int
;	O
mu_body_t	*(struct)
body	*(struct)
=	O
NULL	O
;	O
mu_stream_t	*(struct)
b_stream	*(struct)
=	O
NULL	O
;	O
mu_stream_t	*(struct)
d_stream	*(struct)
=	O
NULL	O
;	O
mu_stream_t	*(struct)
stream	*(struct)
=	O
NULL	O
;	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
body	*(struct)
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
b_stream	*(struct)
)	O
;	O
if	O
(	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
d_stream	*(struct)
,	O
b_stream	*(struct)
,	O
closure	*(void)
->	O
encoding	*(char)
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
==	O
0	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
b_stream	*(struct)
)	O
;	O
stream	*(struct)
=	O
d_stream	*(struct)
;	O
}	O
else	O
stream	*(struct)
=	O
b_stream	*(struct)
;	O
display_part_header	(*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),*(char),*(char))->(void)
(	O
mu_strout	*(struct)
,	O
closure	*(void)
->	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
closure	*(void)
->	O
type	*(char)
,	O
closure	*(void)
->	O
encoding	*(char)
)	O
;	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_metamail	*(char)
)	O
)	O
{	O
char	O
*	O
no_ask	*(char)
=	O
NULL	O
;	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
no_ask	*(char)
,	O
mailvar_name_mimenoask	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
builtin_display	int
=	O
display_stream_mailcap	(*(char),*(struct),*(struct),*(char),int,int,int)->(int)
(	O
NULL	O
,	O
stream	*(struct)
,	O
hdr	*(struct)
,	O
no_ask	*(char)
,	O
interactive	int
,	O
0	int
,	O
MU_DEBCAT_APP	int
)	O
;	O
}	O
if	O
(	O
builtin_display	int
)	O
{	O
size_t	long
lines	long
=	O
0	int
;	O
mu_stream_t	*(struct)
str	*(struct)
;	O
mu_message_lines	(*(struct),*(long))->(int)
(	O
closure	*(void)
->	O
message	*(struct)
,	O
&	O
lines	long
)	O
;	O
str	*(struct)
=	O
open_pager	(long)->(*(struct))
(	O
lines	long
)	O
;	O
display_headers	(*(struct),*(struct),*(struct(*(struct(*`,int,*`)),int,*(long))),int)->(void)
(	O
str	*(struct)
,	O
closure	*(void)
->	O
message	*(struct)
,	O
closure	*(void)
->	O
msgset	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
closure	*(void)
->	O
hints	*(struct(*(char),*(char)))
&	O
MDHINT_SELECTED_HEADERS	int
)	O
;	O
print_stream	(*(struct),*(struct))->(int)
(	O
stream	*(struct)
,	O
str	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
str	*(struct)
)	O
;	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
print_stream	(*(struct),*(struct))->(int)
(	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
mu_stream_t	*(struct)
out	*(struct)
)	O
{	O
char	O
buffer	*(char)
[	O
512	int
]	O
;	O
size_t	long
n	*(long)
=	O
0	int
;	O
while	O
(	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
stream	*(struct)
,	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
-	O
1	int
,	O
&	O
n	*(long)
)	O
==	O
0	int
&&	O
n	*(long)
!=	O
0	int
)	O
{	O
if	O
(	O
ml_got_interrupt	()->(int)
(	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"\nInterrupt"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
buffer	*(char)
[	O
n	*(long)
]	O
=	O
'\0'	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
buffer	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
get_content_encoding	(*(struct),*(*(char)))->(int)
(	O
mu_header_t	*(struct)
hdr	*(struct)
,	O
char	O
*	O
*	O
value	*(void)
)	O
{	O
char	O
*	O
encoding	*(char)
=	O
NULL	O
;	O
util_get_hdr_value	(*(struct),*(char),*(*(char)))->(int)
(	O
hdr	*(struct)
,	O
MU_HEADER_CONTENT_TRANSFER_ENCODING	*(char)
,	O
&	O
encoding	*(char)
)	O
;	O
if	O
(	O
encoding	*(char)
==	O
NULL	O
||	O
*	O
encoding	*(char)
==	O
'\0'	O
)	O
{	O
if	O
(	O
encoding	*(char)
)	O
free	(*(void))->(void)
(	O
encoding	*(char)
)	O
;	O
encoding	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
"7bit"	*(char)
)	O
;	O
}	O
*	O
value	*(void)
=	O
encoding	*(char)
;	O
return	O
0	int
;	O
}	O
static	O
void	O
run_metamail	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
mailcap_cmd	*(char)
,	O
mu_message_t	*(struct)
mesg	*(struct)
)	O
{	O
pid_t	int
pid	int
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
saveintr	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
savequit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
sigset_t	struct(array(long))
chldmask	struct(array(long))
;	O
sigset_t	struct(array(long))
savemask	struct(array(long))
;	O
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
SIG_IGN	O
;	O
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
if	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
saveintr	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
<	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"sigaction: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGQUIT	int
,	O
&	O
ignore	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
savequit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
<	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"sigaction: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
saveintr	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
chldmask	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
chldmask	struct(array(long))
,	O
SIGCHLD	int
)	O
;	O
if	O
(	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
chldmask	struct(array(long))
,	O
&	O
savemask	struct(array(long))
)	O
<	O
0	int
)	O
{	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
saveintr	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGQUIT	int
,	O
&	O
savequit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"fork: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
int	O
status	int
;	O
mu_stream_t	*(struct)
stream	*(struct)
=	O
NULL	O
;	O
do	O
{	O
mu_stream_t	*(struct)
pstr	*(*(char))
;	O
char	O
*	O
no_ask	*(char)
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"METAMAIL_PAGER"	*(char)
,	O
getenv	(*(char))->(*(char))
(	O
"PAGER"	*(char)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
no_ask	*(char)
,	O
mailvar_name_mimenoask	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
)	O
setenv	(*(char),*(char),int)->(int)
(	O
"MM_NOASK"	*(char)
,	O
no_ask	*(char)
,	O
1	int
)	O
;	O
status	int
=	O
mu_message_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"mu_message_get_streamref: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
break	O
;	O
}	O
status	int
=	O
mu_command_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
pstr	*(*(char))
,	O
mailcap_cmd	*(char)
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"mu_command_stream_create: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
break	O
;	O
}	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
pstr	*(*(char))
,	O
stream	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_close	(*(struct))->(int)
(	O
pstr	*(*(char))
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
pstr	*(*(char))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
int	O
status	int
;	O
while	O
(	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
<	O
0	int
)	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
break	O
;	O
}	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
saveintr	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGQUIT	int
,	O
&	O
savequit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
savemask	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
