extern	O
FILE	struct
*	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
size_t	long
separator_str_len	long
=	O
6	int
;	O
extern	O
void	O
init_unshar	()->(void)
(	O
void	O
)	O
;	O
char	O
const	O
*	O
const	O
program_name	*(char)
=	O
"unshar"	*(char)
;	O
static	O
char	O
const	O
unshar_opt_strs	array(char)
[	O
3901	int
]	O
=	O
"unshar (GNU sharutils) 4.15\n"	*(char)
"Copyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\n"	*(char)
"This is free software. It is licensed for use, modification and\n"	*(char)
"redistribution under the terms of the GNU General Public License,\n"	*(char)
"version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"	*(char)
"unshar is free software: you can redistribute it and/or modify it under the\n"	*(char)
"terms of the GNU General Public License as published by the Free Software\n"	*(char)
"Foundation, either version 3 of the License, or (at your option) any later\n"	*(char)
"version.\n\n"	*(char)
"unshar is distributed in the hope that it will be useful, but WITHOUT ANY\n"	*(char)
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"	*(char)
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"	*(char)
"details.\n\n"	*(char)
"You should have received a copy of the GNU General Public License along\n"	*(char)
"with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"	*(char)
"unpack into the directory dir\0"	*(char)
"DIRECTORY\0"	*(char)
"directory\0"	*(char)
"overwrite any pre-existing files\0"	*(char)
"OVERWRITE\0"	*(char)
"overwrite\0"	*(char)
"an alias for the 'overwrite' option\0"	*(char)
"force\0"	*(char)
"split input on split-mark lines\0"	*(char)
"SPLIT_AT\0"	*(char)
"split-at\0"	*(char)
"exit 0\0"	*(char)
"split input on \"exit 0\" lines\0"	*(char)
"EXIT_0\0"	*(char)
"exit-0\0"	*(char)
"debug the shell code\0"	*(char)
"DEBUG\0"	*(char)
"debug\0"	*(char)
"display extended usage information and exit\0"	*(char)
"help\0"	*(char)
"extended usage information passed thru pager\0"	*(char)
"more-help\0"	*(char)
"output version information and exit\0"	*(char)
"version\0"	*(char)
"save the option state to a config file\0"	*(char)
"save-opts\0"	*(char)
"load options from a config file\0"	*(char)
"LOAD_OPTS\0"	*(char)
"no-load-opts\0"	*(char)
"no\0"	*(char)
"UNSHAR\0"	*(char)
"unshar (GNU sharutils) - unpack a shar archive\n"	*(char)
"Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\0"	*(char)
"$HOME\0"	*(char)
".sharrc\0"	*(char)
"bug-gnu-utils@gnu.org\0"	*(char)
"\n"	*(char)
"If no arguments are provided, input arguments are read from stdin,\n"	*(char)
"one per line; blank and '#'-prefixed lines are comments.\n"	*(char)
"'stdin' may not be a terminal (tty).\n\0"	*(char)
"Unshar scans the input files (typically email messages) looking for the\n"	*(char)
"start of a shell archive.  If no files are given, then standard input is\n"	*(char)
"processed instead.  It then passes each archive discovered through an\n"	*(char)
"invocation of the shell program to unpack it.\n\0"	*(char)
"unshar (GNU sharutils) 4.15\0"	*(char)
"unshar (GNU sharutils) - unpack a shar archive\n"	*(char)
"Usage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\n"	*(char)
"   -d, --directory=DIR        unpack into the directory DIR\n"	*(char)
"   -c, --overwrite            overwrite any pre-existing files\n"	*(char)
"   -f, --force                an alias for the 'overwrite' option\n"	*(char)
"   -E, --split-at=SPLIT-PAT   split input on SPLIT-PAT lines\n"	*(char)
"   -e, --exit-0               split input on \"exit 0\" lines\n"	*(char)
"                                - prohibits the option 'split-at'\n"	*(char)
"   -D, --debug                debug the shell code\n"	*(char)
"   -v, --version[=MODE]       output version information and exit\n"	*(char)
"   -h, --help                 display extended usage information and exit\n"	*(char)
"   -!, --more-help            extended usage information passed thru pager\n"	*(char)
"   -R, --save-opts[=FILE]     save the option state to the config file FILE\n"	*(char)
"   -r, --load-opts=FILE       load options from the config file FILE\n"	*(char)
"                                - disabled as '--no-load-opts'\n"	*(char)
"                                - may appear multiple times\n\n"	*(char)
"Options are specified by doubled hyphens and their name or by a single\n"	*(char)
"hyphen and the flag character.\n\n"	*(char)
"If no arguments are provided, input arguments are read from stdin,\n"	*(char)
"one per line; blank and '#'-prefixed lines are comments.\n"	*(char)
"'stdin' may not be a terminal (tty).\n\n"	*(char)
"The following option preset mechanisms are supported:\n"	*(char)
" - reading file $HOME/.sharrc\n\n"	*(char)
"'unshar' scans the input files (typically email messages) looking for the\n"	*(char)
"start of a shell archive.  If no files are given, then standard input is\n"	*(char)
"processed instead.  It then passes each archive discovered through an\n"	*(char)
"invocation of the shell program to unpack it.\n\n"	*(char)
"Please send bug reports to:  <bug-gnu-utils@gnu.org>\n\0"	*(char)
"unshar (GNU sharutils) - unpack a shar archive\n"	*(char)
"Usage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n"	*(char)
"Try 'unshar --help' for more information.\n"	*(char)
;	O
static	O
int	O
const	O
aExit_0CantList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_SPLIT_AT	int
,	O
NO_EQUIVALENT	O
}	O
;	O
extern	O
tOptProc	(*(struct),*(struct))->(void)
optionBooleanVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNestedVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPrintVersion	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionResetOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionStackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeDate	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionUnstackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionVendorOption	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptProc	(*(struct),*(struct))->(void)
doOptExit_0	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptForce	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptSplit_At	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptDesc	struct
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
[	O
OPTION_CT	int
]	O
=	O
{	O
{	O
0	int
,	O
VALUE_OPT_DIRECTORY	char
,	O
0	int
,	O
VALUE_OPT_DIRECTORY	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
DIRECTORY_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
DIRECTORY_DESC	O
,	O
DIRECTORY_NAME	O
,	O
DIRECTORY_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
1	int
,	O
VALUE_OPT_OVERWRITE	char
,	O
1	int
,	O
VALUE_OPT_OVERWRITE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OVERWRITE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
OVERWRITE_DESC	O
,	O
OVERWRITE_NAME	O
,	O
OVERWRITE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
2	int
,	O
VALUE_OPT_FORCE	char
,	O
2	int
,	O
VALUE_OPT_FORCE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
FORCE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptForce	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
FORCE_DESC	O
,	O
FORCE_NAME	O
,	O
FORCE_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
3	int
,	O
VALUE_OPT_SPLIT_AT	char
,	O
3	int
,	O
VALUE_OPT_SPLIT_AT	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SPLIT_AT_FLAGS	O
,	O
0	int
,	O
{	O
SPLIT_AT_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptSplit_At	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
SPLIT_AT_DESC	O
,	O
SPLIT_AT_NAME	O
,	O
SPLIT_AT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
4	int
,	O
VALUE_OPT_EXIT_0	char
,	O
4	int
,	O
VALUE_OPT_EXIT_0	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
EXIT_0_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aExit_0CantList	array(int)
,	O
doOptExit_0	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
EXIT_0_DESC	O
,	O
EXIT_0_NAME	O
,	O
EXIT_0_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
VALUE_OPT_DEBUG	char
,	O
5	int
,	O
VALUE_OPT_DEBUG	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
DEBUG_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
DEBUG_DESC	O
,	O
DEBUG_NAME	O
,	O
DEBUG_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_VERSION	int
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VER_FLAGS	O
,	O
AOUSE_VERSION	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
VER_PROC	O
,	O
VER_DESC	O
,	O
NULL	O
,	O
VER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_HELP	int
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_IMM	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
HELP_DESC	O
,	O
NULL	O
,	O
HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MORE_HELP_FLAGS	O
,	O
AOUSE_MORE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
MORE_HELP_DESC	O
,	O
NULL	O
,	O
MORE_HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_SAVE_OPTS	int
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_ARG_OPTIONAL	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_SAVE_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SAVE_OPTS_DESC	O
,	O
NULL	O
,	O
SAVE_OPTS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_LOAD_OPTS	int
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_DISABLE_IMM	int
,	O
AOUSE_LOAD_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionLoadOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
LOAD_OPTS_DESC	O
,	O
LOAD_OPTS_NAME	O
,	O
LOAD_OPTS_name	O
,	O
NO_LOAD_OPTS_name	O
,	O
LOAD_OPTS_pfx	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
apzHomeList	array(*(char))
[	O
2	int
]	O
=	O
{	O
unshar_opt_strs	array(char)
+	O
1549	int
,	O
NULL	O
}	O
;	O
static	O
tOptionXlateProc	()->(void)
translate_option_strings	()->(void)
;	O
static	O
void	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
int	O
ex_code	int
;	O
ex_code	int
=	O
UNSHAR_EXIT_SUCCESS	int
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
unsharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
ex_code	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptForce	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
int	O
res	int
=	O
optionAlias	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),int)->(int)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
INDEX_OPT_OVERWRITE	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
UNSHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
static	O
void	O
doOptSplit_At	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
separator_str_len	long
=	O
strlen	(*(char))->(long)
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
)	O
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptExit_0	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
SET_OPT_SPLIT_AT	O
(	O
"exit 0"	*(char)
)	O
;	O
(	O
void	O
)	O
pOptDesc	*(struct)
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
extern	O
int	O
unshar_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
char	O
const	O
*	O
pz_fname	*(char)
,	O
FILE	struct
*	O
entry_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
static	O
unshar_exit_code_t	enum(int,int,int,int,int,int,int,int,int,int)
validate_fname	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
char	O
const	O
*	O
pz_fname	*(char)
)	O
{	O
static	O
char	O
const	O
*	O
pz_fs_err	*(char)
=	O
NULL	O
;	O
if	O
(	O
pz_fs_err	*(char)
==	O
NULL	O
)	O
pz_fs_err	*(char)
=	O
_	O
(	O
"fs error %d (%s) %s-ing %s\n"	*(char)
)	O
;	O
if	O
(	O
(	O
pz_fname	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
&&	O
(	O
pz_fname	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
return	O
unshar_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"standard input"	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pz_fname	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pz_fs_err	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
"stat"	*(char)
,	O
pz_fname	*(char)
)	O
;	O
return	O
UNSHAR_EXIT_NO_CONFIG_INPUT	int
;	O
}	O
}	O
{	O
int	O
res	int
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pz_fname	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pz_fs_err	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
"fopen"	*(char)
,	O
pz_fname	*(char)
)	O
;	O
return	O
UNSHAR_EXIT_NO_CONFIG_INPUT	int
;	O
}	O
res	int
=	O
unshar_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pz_fname	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
res	int
;	O
}	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
res	int
=	O
0	int
;	O
int	O
proc_ct	int
=	O
0	int
;	O
int	O
arg_ix	int
=	O
optionProcess	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int,*(*(char)))->(int)
(	O
&	O
unsharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
init_unshar	()->(void)
(	O
)	O
;	O
if	O
(	O
arg_ix	int
<	O
argc	int
)	O
{	O
for	O
(	O
;	O
arg_ix	int
<	O
argc	int
;	O
arg_ix	int
++	O
)	O
{	O
char	O
*	O
arg	*(char)
=	O
argv	*(*(char))
[	O
arg_ix	int
]	O
;	O
res	int
|=	O
validate_fname	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
arg	*(char)
)	O
;	O
proc_ct	int
++	O
;	O
}	O
}	O
else	O
res	int
=	O
unshar_file	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"standard input"	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
res	int
;	O
}	O
void	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
er_leader	*(char)
=	O
_	O
(	O
"unshar usage error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
er_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
unsharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
UNSHAR_EXIT_USAGE_ERROR	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
usage_message	(*(char))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
die_leader	*(char)
=	O
_	O
(	O
"unshar fatal error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
die_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
void	O
die	(int,*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
exit_code	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
fserr	(int,*(char),*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
op	*(char)
,	O
char	O
const	O
*	O
fname	*(char)
)	O
{	O
char	O
const	O
*	O
fserr_fmt	*(char)
=	O
_	O
(	O
"fserr %d (%s) performing '%s' on %s\n"	*(char)
)	O
;	O
die	(int,*(char))->(void)
(	O
exit_code	int
,	O
fserr_fmt	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
op	*(char)
,	O
fname	*(char)
)	O
;	O
}	O
tOptions	struct
unsharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
=	O
{	O
OPTIONS_STRUCT_VERSION	int
,	O
0	int
,	O
NULL	O
,	O
(	O
OPTPROC_BASE	O
+	O
OPTPROC_ERRSTOP	int
+	O
OPTPROC_SHORTOPT	int
+	O
OPTPROC_LONGOPT	int
+	O
OPTPROC_NO_REQ_OPT	int
+	O
OPTPROC_GNUUSAGE	int
+	O
OPTPROC_MISUSE	int
)	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
zPROGNAME	O
,	O
zRcName	O
,	O
zCopyright	O
,	O
zLicenseDescrip	O
,	O
zFullVersion	O
,	O
apzHomeList	array(*(char))
,	O
zUsageTitle	O
,	O
zExplain	O
,	O
zDetail	O
,	O
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
,	O
zBugsAddr	O
,	O
NULL	O
,	O
NULL	O
,	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
,	O
translate_option_strings	()->(void)
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
INDEX_OPT_SAVE_OPTS	int
,	O
NO_EQUIVALENT	O
,	O
NO_EQUIVALENT	O
}	O
,	O
11	int
,	O
6	int
,	O
unshar_full_usage	O
,	O
unshar_short_usage	O
,	O
NULL	O
,	O
NULL	O
,	O
PKGDATADIR	*(char)
,	O
unshar_packager_info	O
}	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
;	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
{	O
char	O
*	O
res	int
;	O
if	O
(	O
pz	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
res	int
=	O
dgettext	(*(char),*(char))->(*(char))
(	O
"libopts"	*(char)
,	O
pz	*(char)
)	O
;	O
if	O
(	O
res	int
==	O
pz	*(char)
)	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
}	O
else	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
if	O
(	O
res	int
==	O
pz	*(char)
)	O
return	O
res	int
;	O
res	int
=	O
strdup	(*(char))->(*(char))
(	O
res	int
)	O
;	O
if	O
(	O
res	int
==	O
NULL	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"No memory for duping translated strings\n"	*(char)
)	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
UNSHAR_EXIT_NOMEM	int
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
static	O
void	O
translate_option_strings	()->(void)
(	O
void	O
)	O
{	O
tOptions	struct
*	O
const	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
=	O
&	O
unsharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
ppz	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
VOIDP	O
(	O
&	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
)	O
)	O
;	O
int	O
ix	int
=	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
;	O
do	O
{	O
ppz	*(*(char))
++	O
;	O
*	O
ppz	*(*(char))
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
ppz	*(*(char))
)	O
;	O
}	O
while	O
(	O
--	O
ix	int
>	O
0	int
)	O
;	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
=	O
0	int
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyright	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyNotice	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzFullVersion	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
