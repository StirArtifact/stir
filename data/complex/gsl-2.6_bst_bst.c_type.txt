static	O
void	O
*	O
bst_malloc	O
(	O
size_t	long
size	long
,	O
void	O
*	O
params	*(void)
)	O
;	O
static	O
void	O
bst_free	O
(	O
void	O
*	O
block	*(void)
,	O
void	O
*	O
params	*(void)
)	O
;	O
static	O
const	O
gsl_bst_allocator	struct(*((long,*(void))->(*(void))),*((*(void),*(void))->(void)))
bst_default_allocator	O
=	O
{	O
bst_malloc	O
,	O
bst_free	O
}	O
;	O
gsl_bst_workspace	O
*	O
gsl_bst_alloc	O
(	O
const	O
gsl_bst_type	O
*	O
T	O
,	O
const	O
gsl_bst_allocator	struct(*((long,*(void))->(*(void))),*((*(void),*(void))->(void)))
*	O
allocator	O
,	O
gsl_bst_cmp_function	(*(void),*(void),*(void))->(int)
*	O
compare	O
,	O
void	O
*	O
params	*(void)
)	O
{	O
int	O
status	O
;	O
gsl_bst_workspace	O
*	O
w	O
;	O
w	O
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
gsl_bst_workspace	O
)	O
)	O
;	O
if	O
(	O
w	O
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate bst workspace"	*(char)
,	O
GSL_ENOMEM	O
)	O
;	O
}	O
w	O
->	O
type	O
=	O
T	O
;	O
status	O
=	O
(	O
w	O
->	O
type	O
->	O
init	O
)	O
(	O
allocator	O
!=	O
NULL	O
?	O
allocator	O
:	O
&	O
bst_default_allocator	O
,	O
compare	O
,	O
params	*(void)
,	O
(	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
if	O
(	O
status	O
)	O
{	O
gsl_bst_free	O
(	O
w	O
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to initialize bst"	*(char)
,	O
GSL_EFAILED	O
)	O
;	O
}	O
return	O
w	O
;	O
}	O
void	O
gsl_bst_free	O
(	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
gsl_bst_empty	O
(	O
w	O
)	O
;	O
free	(*(void))->(void)
(	O
w	O
)	O
;	O
}	O
int	O
gsl_bst_empty	O
(	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
(	O
w	O
->	O
type	O
->	O
empty	O
)	O
(	O
(	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
}	O
void	O
*	O
gsl_bst_insert	O
(	O
void	O
*	O
item	O
,	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
(	O
w	O
->	O
type	O
->	O
insert	O
)	O
(	O
item	O
,	O
(	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
}	O
void	O
*	O
gsl_bst_find	O
(	O
const	O
void	O
*	O
item	O
,	O
const	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
(	O
w	O
->	O
type	O
->	O
find	O
)	O
(	O
item	O
,	O
(	O
const	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
}	O
void	O
*	O
gsl_bst_remove	O
(	O
const	O
void	O
*	O
item	O
,	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
(	O
w	O
->	O
type	O
->	O
remove	O
)	O
(	O
item	O
,	O
(	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
}	O
size_t	long
gsl_bst_nodes	O
(	O
const	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
(	O
w	O
->	O
type	O
->	O
nodes	O
)	O
(	O
(	O
const	O
void	O
*	O
)	O
&	O
w	O
->	O
table	O
)	O
;	O
}	O
size_t	long
gsl_bst_node_size	O
(	O
const	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
w	O
->	O
type	O
->	O
node_size	O
;	O
}	O
const	O
char	O
*	O
gsl_bst_name	O
(	O
const	O
gsl_bst_workspace	O
*	O
w	O
)	O
{	O
return	O
w	O
->	O
type	O
->	O
name	O
;	O
}	O
static	O
void	O
*	O
bst_malloc	O
(	O
size_t	long
size	long
,	O
void	O
*	O
params	*(void)
)	O
{	O
(	O
void	O
)	O
params	*(void)
;	O
return	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
}	O
static	O
void	O
bst_free	O
(	O
void	O
*	O
block	*(void)
,	O
void	O
*	O
params	*(void)
)	O
{	O
(	O
void	O
)	O
params	*(void)
;	O
free	(*(void))->(void)
(	O
block	*(void)
)	O
;	O
}	O
