__BEGIN_DECLARATIONS	O
static	O
Bool	int
date_matches_period	(*(int),int,int,int)->(int)
__P_	O
(	O
(	O
int	O
*	O
print_twice	int
,	O
int	O
day	int
,	O
int	O
ed	int
,	O
const	O
int	O
wd	int
)	O
)	O
;	O
static	O
int	O
get_number	(*(*(char)))->(int)
__P_	O
(	O
(	O
char	O
*	O
*	O
string	*(char)
)	O
)	O
;	O
__END_DECLARATIONS	O
static	O
Bool	int
is_weekday_mode	*(int)
=	O
FALSE	O
;	O
static	O
Bool	int
changed_month	int
=	O
FALSE	O
;	O
void	O
rc_check	(*(char),*(char),long,int,*(int),int,int,int)->(void)
(	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
,	O
line_length	int
,	O
rc_elems	int
,	O
day	int
,	O
ed	int
,	O
wd	int
)	O
char	O
*	O
line_buffer	*(char)
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
const	O
int	O
line_length	int
;	O
int	O
*	O
rc_elems	int
;	O
const	O
int	O
day	int
;	O
const	O
int	O
ed	int
;	O
const	O
int	O
wd	int
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
buf_d	int
=	O
0	int
;	O
register	O
int	O
buf_m	int
;	O
register	O
int	O
buf_y	int
;	O
register	O
int	O
dvar_base_day	int
=	O
0	int
;	O
register	O
int	O
dvar_base_month	int
=	O
0	int
;	O
register	O
int	O
repeat	int
=	O
0	int
;	O
register	O
int	O
appears	int
=	O
0	int
;	O
register	O
int	O
productions	int
=	O
2	int
;	O
register	O
int	O
tmp_month	int
=	O
month	int
;	O
auto	O
int	O
print_twice	int
;	O
auto	O
int	O
len_date	int
;	O
auto	O
int	O
n	long
;	O
auto	O
int	O
tmp_d	int
;	O
auto	O
int	O
tmp_m	int
;	O
auto	O
int	O
tmp_y	int
;	O
auto	O
int	O
tmp_n	int
;	O
auto	O
int	O
tmp_hn	int
;	O
auto	O
int	O
tmp_hwd	int
=	O
0	int
;	O
auto	O
Bool	int
is_valid_date	int
;	O
auto	O
Bool	int
is_day_given	int
;	O
auto	O
Bool	int
is_month_given	int
;	O
auto	O
Bool	int
is_coded_month	int
;	O
auto	O
Bool	int
is_first	int
=	O
TRUE	O
;	O
auto	O
Bool	int
is_range	int
=	O
FALSE	O
;	O
auto	O
Bool	int
date_unset	int
=	O
FALSE	O
;	O
auto	O
Bool	int
must_ignore_feb_29	int
=	O
FALSE	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
=	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
line_buffer	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
TRUE	O
,	O
&	O
is_weekday_mode	*(int)
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
len_date	int
,	O
&	O
hc	char
,	O
&	O
hn	int
,	O
&	O
hwd	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
TRUE	O
)	O
;	O
if	O
(	O
len_date	int
<	O
1	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
(	O
len_date	int
<	O
line_length	int
)	O
&&	O
!	O
*	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
text_part	*(char)
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
month	int
)	O
{	O
month	int
=	O
act_month	int
;	O
changed_month	int
=	O
TRUE	O
;	O
}	O
else	O
changed_month	int
=	O
FALSE	O
;	O
buf_m	int
=	O
m	int
;	O
buf_y	int
=	O
y	int
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
;	O
do	O
{	O
if	O
(	O
!	O
is_range	int
&&	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
auto	O
char	O
*	O
ptr2_char	*(char)
;	O
auto	O
char	O
ch	char
;	O
repeat	int
=	O
appears	int
=	O
hwd	int
=	O
tmp_hn	int
=	O
hn	int
=	O
tmp_n	int
=	O
n	long
=	O
i	int
=	O
0	int
;	O
is_range	int
=	O
is_coded_month	int
=	O
is_month_given	int
=	O
is_day_given	int
=	O
is_weekday_mode	*(int)
=	O
FALSE	O
;	O
if	O
(	O
is_first	int
&&	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
y	int
==	O
SPECIAL_VALUE	O
)	O
break	O
;	O
dvar_base_day	int
=	O
d	int
;	O
dvar_base_month	int
=	O
m	int
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
)	O
{	O
productions	int
=	O
2	int
;	O
while	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
RC_DLIST_CHAR	char
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
RC_REPEAT_CHAR	char
)	O
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
)	O
s6	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
++	O
)	O
;	O
s6	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
i	int
&&	O
(	O
!	O
is_first	int
||	O
!	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
is_first	int
=	O
FALSE	O
;	O
ptr2_char	*(char)
=	O
s6	*(char)
;	O
if	O
(	O
hc	char
&&	O
*	O
ptr2_char	*(char)
)	O
{	O
hn	int
=	O
atoi	(*(char))->(int)
(	O
s6	*(char)
)	O
;	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
ptr2_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
||	O
isalpha	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
ptr2_char	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
hc	char
||	O
*	O
ptr2_char	*(char)
)	O
{	O
if	O
(	O
!	O
hc	char
&&	O
i	int
)	O
{	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
{	O
ch	char
=	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
;	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
=	O
'\0'	O
;	O
m	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
MOnth	int
)	O
;	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
=	O
ch	char
;	O
if	O
(	O
!	O
m	int
)	O
{	O
if	O
(	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
DAy	int
)	O
)	O
goto	O
LABEL_list_day_name_given	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
ptr2_char	*(char)
++	O
;	O
}	O
else	O
{	O
ch	char
=	O
s6	*(char)
[	O
2	int
]	O
;	O
s6	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
m	int
=	O
atoi	(*(char))->(int)
(	O
ptr2_char	*(char)
)	O
;	O
if	O
(	O
m	int
==	O
99	int
)	O
m	int
=	O
MONTH_MAX	int
;	O
if	O
(	O
m	int
>	O
MONTH_MAX	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
s6	*(char)
[	O
2	int
]	O
=	O
ch	char
;	O
}	O
ptr2_char	*(char)
+=	O
2	int
;	O
if	O
(	O
m	int
)	O
is_month_given	int
=	O
TRUE	O
;	O
else	O
is_coded_month	int
=	O
TRUE	O
;	O
}	O
LABEL_list_day_name_given	O
:	O
d	int
=	O
atoi	(*(char))->(int)
(	O
ptr2_char	*(char)
)	O
;	O
if	O
(	O
d	int
)	O
is_day_given	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
{	O
d	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
d	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
is_month_given	int
&&	O
!	O
is_coded_month	int
)	O
m	int
=	O
buf_m	int
;	O
y	int
=	O
buf_y	int
;	O
if	O
(	O
!	O
is_day_given	int
)	O
{	O
if	O
(	O
!	O
hc	char
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
2	int
]	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
n	long
=	O
CHR2DIG	O
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
n	long
>	O
5	int
)	O
&&	O
(	O
n	long
<	O
9	int
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_NWD_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
n	long
)	O
;	O
}	O
if	O
(	O
!	O
n	long
)	O
is_weekday_mode	*(int)
=	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr2_char	*(char)
)	O
hwd	int
=	O
d	int
;	O
if	O
(	O
!	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
d	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
d	int
=	O
dvar_base_day	int
;	O
m	int
=	O
dvar_base_month	int
;	O
}	O
if	O
(	O
hc	char
&&	O
y	int
)	O
{	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
(	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
hn	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
!	O
y	int
&&	O
!	O
is_coded_month	int
)	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
if	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
RC_REPEAT_CHAR	char
||	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
RC_APPEARS_CHAR	char
)	O
{	O
if	O
(	O
is_weekday_mode	*(int)
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
else	O
{	O
register	O
int	O
num_repeat	int
=	O
0	int
;	O
register	O
int	O
num_appears	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
RC_REPEAT_CHAR	char
)	O
{	O
repeat	int
=	O
get_number	(*(*(char)))->(int)
(	O
&	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
;	O
num_repeat	int
++	O
;	O
}	O
if	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
RC_APPEARS_CHAR	char
)	O
{	O
appears	int
=	O
get_number	(*(*(char)))->(int)
(	O
&	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
;	O
num_appears	int
++	O
;	O
}	O
}	O
while	O
(	O
--	O
productions	int
)	O
;	O
if	O
(	O
num_repeat	int
>	O
1	int
||	O
num_appears	int
>	O
1	int
||	O
(	O
!	O
repeat	int
&&	O
!	O
appears	int
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
appears	int
)	O
appears	int
--	O
;	O
productions	int
=	O
repeat	int
;	O
}	O
}	O
if	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
RC_DLIST_CHAR	char
)	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
++	O
;	O
else	O
if	O
(	O
!	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
while	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
RC_DRANGE_CHAR	char
)	O
s6	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
++	O
)	O
;	O
s6	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s6	*(char)
,	O
RC_APPEARS_CHAR	char
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
ptr2_char	*(char)
=	O
s6	*(char)
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
++	O
;	O
if	O
(	O
hc	char
&&	O
*	O
ptr2_char	*(char)
)	O
{	O
hn	int
=	O
atoi	(*(char))->(int)
(	O
s6	*(char)
)	O
;	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
ptr2_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
||	O
isalpha	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
ptr2_char	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
hc	char
||	O
*	O
ptr2_char	*(char)
)	O
{	O
if	O
(	O
!	O
hc	char
)	O
{	O
d	int
=	O
atoi	(*(char))->(int)
(	O
ptr2_char	*(char)
)	O
;	O
if	O
(	O
d	int
)	O
is_day_given	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
{	O
buf_d	int
=	O
d	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
d	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
is_day_given	int
)	O
{	O
if	O
(	O
!	O
hc	char
&&	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
2	int
]	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
n	long
=	O
CHR2DIG	O
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
n	long
>	O
5	int
)	O
&&	O
(	O
n	long
<	O
9	int
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_NWD_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
n	long
)	O
;	O
if	O
(	O
n	long
)	O
{	O
is_range	int
=	O
TRUE	O
;	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
is_weekday_mode	*(int)
)	O
;	O
if	O
(	O
!	O
m	int
||	O
y	int
==	O
SPECIAL_VALUE	O
)	O
break	O
;	O
}	O
else	O
is_weekday_mode	*(int)
=	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
hc	char
)	O
is_weekday_mode	*(int)
=	O
TRUE	O
;	O
else	O
{	O
is_range	int
=	O
TRUE	O
;	O
hwd	int
=	O
d	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
m	int
&&	O
(	O
rc_year_flag	int
||	O
rc_period_list	int
||	O
is_3month_mode	int
||	O
is_3month_mode2	int
||	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
break	O
;	O
is_range	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
year	int
;	O
if	O
(	O
!	O
m	int
)	O
m	int
=	O
month	int
;	O
}	O
}	O
else	O
{	O
is_range	int
=	O
TRUE	O
;	O
hwd	int
=	O
0	int
;	O
}	O
if	O
(	O
hc	char
)	O
{	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
year	int
;	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
d	int
=	O
dvar_base_day	int
;	O
m	int
=	O
dvar_base_month	int
;	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
(	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
)	O
date_unset	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
hn	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
date_unset	int
=	O
TRUE	O
;	O
if	O
(	O
date_unset	int
)	O
{	O
if	O
(	O
!	O
hn	int
||	O
hwd	int
)	O
break	O
;	O
date_unset	int
=	O
FALSE	O
;	O
if	O
(	O
hn	int
<	O
0	int
)	O
{	O
m	int
=	O
MONTH_MIN	int
;	O
d	int
=	O
DAY_MIN	int
;	O
}	O
else	O
{	O
m	int
=	O
MONTH_MAX	int
;	O
d	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
}	O
}	O
}	O
is_day_given	int
=	O
FALSE	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
s6	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
++	O
)	O
;	O
s6	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
ptr2_char	*(char)
=	O
s6	*(char)
;	O
free	(*(void))->(void)
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
)	O
;	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
hc	char
&&	O
*	O
ptr2_char	*(char)
)	O
{	O
tmp_hn	int
=	O
atoi	(*(char))->(int)
(	O
s6	*(char)
)	O
;	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
ptr2_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
||	O
isalpha	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr2_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
ptr2_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
RC_APPEARS_CHAR	char
)	O
{	O
ptr2_char	*(char)
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
ptr2_char	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
!	O
hc	char
||	O
*	O
ptr2_char	*(char)
)	O
{	O
if	O
(	O
!	O
hc	char
&&	O
i	int
)	O
{	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
{	O
ch	char
=	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
;	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
=	O
'\0'	O
;	O
tmp_m	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
MOnth	int
)	O
;	O
s6	*(char)
[	O
TXTLEN_MONTH	int
]	O
=	O
ch	char
;	O
if	O
(	O
!	O
tmp_m	int
)	O
{	O
if	O
(	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
DAy	int
)	O
)	O
goto	O
LABEL_range_day_name_given	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
s6	*(char)
[	O
3	int
]	O
=	O
ch	char
;	O
ptr2_char	*(char)
++	O
;	O
}	O
else	O
{	O
ch	char
=	O
s6	*(char)
[	O
2	int
]	O
;	O
s6	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
tmp_m	int
=	O
atoi	(*(char))->(int)
(	O
ptr2_char	*(char)
)	O
;	O
if	O
(	O
tmp_m	int
==	O
99	int
)	O
tmp_m	int
=	O
MONTH_MAX	int
;	O
if	O
(	O
tmp_m	int
>	O
MONTH_MAX	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
s6	*(char)
[	O
2	int
]	O
=	O
ch	char
;	O
}	O
ptr2_char	*(char)
+=	O
2	int
;	O
if	O
(	O
tmp_m	int
)	O
is_month_given	int
=	O
TRUE	O
;	O
else	O
is_coded_month	int
=	O
TRUE	O
;	O
}	O
LABEL_range_day_name_given	O
:	O
tmp_d	int
=	O
atoi	(*(char))->(int)
(	O
ptr2_char	*(char)
)	O
;	O
if	O
(	O
tmp_d	int
)	O
is_day_given	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
ptr2_char	*(char)
)	O
)	O
{	O
buf_d	int
=	O
tmp_d	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr2_char	*(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
tmp_d	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
is_day_given	int
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
s6	*(char)
[	O
i	int
-	O
2	int
]	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
tmp_n	int
=	O
CHR2DIG	O
(	O
s6	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
hc	char
&&	O
tmp_n	int
&&	O
is_range	int
)	O
{	O
if	O
(	O
(	O
tmp_n	int
>	O
5	int
)	O
&&	O
(	O
tmp_n	int
<	O
9	int
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_NWD_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
tmp_n	int
)	O
;	O
if	O
(	O
!	O
is_month_given	int
)	O
tmp_m	int
=	O
buf_m	int
;	O
tmp_y	int
=	O
buf_y	int
;	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
&	O
tmp_d	int
,	O
&	O
tmp_m	int
,	O
&	O
tmp_y	int
,	O
&	O
tmp_n	int
,	O
&	O
is_weekday_mode	*(int)
)	O
;	O
if	O
(	O
!	O
tmp_m	int
||	O
tmp_y	int
==	O
SPECIAL_VALUE	O
)	O
break	O
;	O
if	O
(	O
y	int
!=	O
tmp_y	int
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
hc	char
&&	O
(	O
tmp_n	int
||	O
is_range	int
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
tmp_hn	int
&&	O
is_range	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
else	O
tmp_hwd	int
=	O
tmp_d	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_day_given	int
&&	O
!	O
is_range	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
tmp_m	int
&&	O
is_coded_month	int
&&	O
(	O
rc_year_flag	int
||	O
rc_period_list	int
||	O
is_3month_mode	int
||	O
is_3month_mode2	int
||	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
is_month_given	int
)	O
tmp_m	int
=	O
m	int
;	O
tmp_y	int
=	O
y	int
;	O
}	O
}	O
else	O
tmp_hwd	int
=	O
0	int
;	O
if	O
(	O
!	O
buf_m	int
&&	O
is_month_given	int
&&	O
(	O
m	int
!=	O
tmp_m	int
)	O
)	O
break	O
;	O
if	O
(	O
hc	char
)	O
{	O
tmp_y	int
=	O
y	int
;	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
tmp_d	int
=	O
dvar_base_day	int
;	O
tmp_m	int
=	O
dvar_base_month	int
;	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
tmp_hn	int
,	O
tmp_hwd	int
,	O
&	O
tmp_d	int
,	O
&	O
tmp_m	int
,	O
tmp_y	int
,	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
(	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
)	O
date_unset	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
tmp_hn	int
,	O
tmp_hwd	int
,	O
&	O
tmp_hn	int
,	O
&	O
tmp_d	int
,	O
&	O
tmp_m	int
,	O
&	O
tmp_y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
date_unset	int
=	O
TRUE	O
;	O
if	O
(	O
date_unset	int
)	O
{	O
if	O
(	O
!	O
tmp_hn	int
||	O
tmp_hwd	int
)	O
break	O
;	O
if	O
(	O
tmp_hn	int
<	O
0	int
)	O
{	O
tmp_m	int
=	O
MONTH_MIN	int
;	O
tmp_d	int
=	O
DAY_MIN	int
;	O
}	O
else	O
{	O
tmp_m	int
=	O
MONTH_MAX	int
;	O
tmp_d	int
=	O
dvec	array(int)
[	O
tmp_m	int
-	O
1	int
]	O
;	O
}	O
}	O
hc	char
=	O
'\0'	O
;	O
}	O
n	long
=	O
0	int
;	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
appears	int
=	O
get_number	(*(*(char)))->(int)
(	O
&	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
)	O
;	O
if	O
(	O
!	O
appears	int
||	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
)	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
appears	int
--	O
;	O
}	O
if	O
(	O
is_range	int
)	O
{	O
if	O
(	O
d	int
==	O
99	int
)	O
{	O
if	O
(	O
m	int
==	O
2	int
)	O
d	int
=	O
days_of_february	(int)->(int)
(	O
y	int
)	O
;	O
else	O
d	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
tmp_d	int
==	O
99	int
)	O
{	O
if	O
(	O
tmp_m	int
==	O
2	int
)	O
tmp_d	int
=	O
days_of_february	(int)->(int)
(	O
tmp_y	int
)	O
;	O
else	O
tmp_d	int
=	O
dvec	array(int)
[	O
tmp_m	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
d	int
>	O
MONTH_LAST	int
||	O
tmp_d	int
>	O
MONTH_LAST	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
buf_y	int
)	O
{	O
if	O
(	O
buf_m	int
)	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
if	O
(	O
is_month_given	int
||	O
(	O
buf_m	int
&&	O
!	O
is_month_given	int
)	O
)	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
&	O
tmp_d	int
,	O
&	O
tmp_m	int
,	O
tmp_y	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
if	O
(	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
28	int
)	O
&&	O
(	O
(	O
(	O
d	int
==	O
29	int
)	O
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
m	int
==	O
buf_m	int
)	O
)	O
||	O
(	O
(	O
tmp_d	int
==	O
29	int
)	O
&&	O
(	O
tmp_m	int
==	O
2	int
)	O
&&	O
(	O
tmp_m	int
==	O
buf_m	int
||	O
is_month_given	int
)	O
)	O
)	O
)	O
must_ignore_feb_29	int
=	O
TRUE	O
;	O
}	O
while	O
(	O
!	O
valid_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
)	O
{	O
if	O
(	O
!	O
buf_m	int
||	O
must_ignore_feb_29	int
)	O
d	int
--	O
;	O
else	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
while	O
(	O
!	O
valid_date	(int,int,int)->(int)
(	O
tmp_d	int
,	O
tmp_m	int
,	O
tmp_y	int
)	O
)	O
{	O
if	O
(	O
(	O
!	O
buf_m	int
&&	O
!	O
is_month_given	int
)	O
||	O
must_ignore_feb_29	int
)	O
tmp_d	int
--	O
;	O
else	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
tmp_d	int
,	O
tmp_m	int
,	O
tmp_y	int
)	O
;	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
int	O
tmp	int
=	O
i	int
;	O
i	int
=	O
j	int
;	O
j	int
=	O
tmp	int
;	O
d	int
=	O
tmp_d	int
;	O
m	int
=	O
tmp_m	int
;	O
y	int
=	O
tmp_y	int
;	O
}	O
productions	int
=	O
j	int
-	O
i	int
;	O
if	O
(	O
productions	int
)	O
{	O
if	O
(	O
i	int
<	O
day	int
)	O
{	O
if	O
(	O
appears	int
)	O
{	O
register	O
int	O
k	int
;	O
do	O
{	O
k	int
=	O
i	int
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
+	O
appears	int
+	O
1	int
,	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
,	O
&	O
d	int
,	O
&	O
m	int
)	O
;	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
i	int
==	O
k	int
)	O
i	int
=	O
day	int
;	O
}	O
while	O
(	O
i	int
<	O
day	int
)	O
;	O
}	O
else	O
i	int
=	O
day	int
;	O
}	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
,	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
,	O
&	O
d	int
,	O
&	O
m	int
)	O
;	O
if	O
(	O
j	int
>	O
ed	int
-	O
1	int
)	O
j	int
=	O
ed	int
-	O
1	int
;	O
productions	int
=	O
j	int
-	O
i	int
;	O
if	O
(	O
productions	int
<	O
0	int
)	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_month_given	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
d	int
>	O
tmp_d	int
)	O
productions	int
=	O
DAY_MAX	int
-	O
d	int
+	O
tmp_d	int
;	O
else	O
productions	int
=	O
tmp_d	int
-	O
d	int
;	O
buf_d	int
=	O
d	int
;	O
}	O
productions	int
++	O
;	O
is_first	int
=	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
is_first	int
)	O
{	O
if	O
(	O
!	O
y	int
)	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
is_weekday_mode	*(int)
&&	O
!	O
n	long
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
repeat	int
=	O
get_number	(*(*(char)))->(int)
(	O
&	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
)	O
;	O
if	O
(	O
!	O
repeat	int
||	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
)	O
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
appears	int
=	O
get_number	(*(*(char)))->(int)
(	O
&	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
)	O
;	O
if	O
(	O
!	O
appears	int
||	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
)	O
&&	O
(	O
*	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
RC_REPEAT_CHAR	char
)	O
)	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
repeat	int
)	O
productions	int
=	O
1	int
;	O
else	O
{	O
is_first	int
=	O
FALSE	O
;	O
if	O
(	O
appears	int
)	O
appears	int
--	O
;	O
productions	int
=	O
repeat	int
;	O
}	O
}	O
if	O
(	O
y	int
>=	O
0	int
)	O
{	O
is_valid_date	int
=	O
TRUE	O
;	O
is_2dvar	int
=	O
is_2easter	int
=	O
FALSE	O
;	O
incr_year	int
=	O
decr_year	int
=	O
d_buf	int
=	O
m_buf	int
=	O
0	int
;	O
print_twice	int
=	O
1	int
;	O
if	O
(	O
!	O
is_range	int
)	O
{	O
if	O
(	O
d	int
)	O
{	O
if	O
(	O
d	int
==	O
99	int
)	O
{	O
if	O
(	O
m	int
)	O
{	O
if	O
(	O
m	int
==	O
2	int
)	O
d	int
=	O
days_of_february	(int)->(int)
(	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
)	O
;	O
else	O
d	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
month	int
==	O
2	int
)	O
d	int
=	O
days_of_february	(int)->(int)
(	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
)	O
;	O
else	O
d	int
=	O
dvec	array(int)
[	O
month	int
-	O
1	int
]	O
;	O
}	O
}	O
is_valid_date	int
=	O
valid_date	(int,int,int)->(int)
(	O
d	int
,	O
(	O
m	int
)	O
?	O
m	int
:	O
month	int
,	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
)	O
;	O
}	O
if	O
(	O
!	O
is_valid_date	int
)	O
{	O
if	O
(	O
(	O
!	O
y	int
&&	O
(	O
(	O
(	O
m	int
==	O
2	int
||	O
(	O
!	O
m	int
&&	O
(	O
month	int
==	O
2	int
)	O
)	O
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
||	O
(	O
!	O
m	int
&&	O
(	O
d	int
<=	O
MONTH_LAST	int
)	O
)	O
)	O
)	O
||	O
(	O
y	int
&&	O
!	O
m	int
&&	O
(	O
d	int
<=	O
MONTH_LAST	int
)	O
)	O
)	O
;	O
else	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
n	long
)	O
{	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
is_weekday_mode	*(int)
)	O
;	O
if	O
(	O
!	O
m	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
y	int
)	O
{	O
if	O
(	O
hwd	int
&&	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
||	O
(	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
||	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
else	O
{	O
if	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
{	O
register	O
int	O
epy	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
-	O
1	int
)	O
;	O
register	O
int	O
eay	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
)	O
;	O
register	O
int	O
eny	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
if	O
(	O
fiscal_month	int
-	O
1	int
==	O
2	int
)	O
i	int
=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
;	O
else	O
i	int
=	O
dvec	array(int)
[	O
fiscal_month	int
-	O
2	int
]	O
;	O
if	O
(	O
year	int
==	O
EASTER_MIN	int
-	O
1	int
)	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
hn	int
+	O
eny	int
<=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
fiscal_month	int
,	O
year	int
)	O
;	O
if	O
(	O
hn	int
+	O
eay	int
>=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
is_3month_mode	int
&&	O
!	O
is_3month_mode2	int
&&	O
(	O
hn	int
+	O
eny	int
<=	O
j	int
)	O
)	O
{	O
print_twice	int
++	O
;	O
is_2easter	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
if	O
(	O
fiscal_month	int
>=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
j	int
=	O
dvec	array(int)
[	O
MONTH_MIN	int
-	O
1	int
]	O
;	O
if	O
(	O
fiscal_month	int
==	O
MONTH_MAX	int
)	O
j	int
+=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
+	O
is_leap_year	int
;	O
if	O
(	O
hn	int
+	O
eny	int
<=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
hn	int
+	O
eny	int
<=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
day	int
<	O
DAY_MIN	int
)	O
{	O
j	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
year	int
-	O
1	int
)	O
==	O
29	int
)	O
;	O
if	O
(	O
(	O
hn	int
+	O
epy	int
>=	O
j	int
+	O
day	int
)	O
&&	O
(	O
hn	int
+	O
epy	int
<=	O
j	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
-	O
1	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
if	O
(	O
hn	int
+	O
eay	int
<	O
ed	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
{	O
j	int
=	O
DAY_LAST	int
+	O
is_leap_year	int
;	O
if	O
(	O
(	O
hn	int
+	O
eay	int
>=	O
day	int
)	O
&&	O
(	O
hn	int
+	O
eay	int
<=	O
j	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
if	O
(	O
hn	int
+	O
eny	int
<	O
ed	int
-	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
EAster	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
hc	char
)	O
)	O
{	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
register	O
int	O
date_dvar	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
)	O
;	O
if	O
(	O
fiscal_month	int
-	O
1	int
==	O
2	int
)	O
i	int
=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
;	O
else	O
i	int
=	O
dvec	array(int)
[	O
fiscal_month	int
-	O
2	int
]	O
;	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
fiscal_month	int
,	O
year	int
)	O
;	O
d_buf	int
=	O
d	int
;	O
m_buf	int
=	O
m	int
;	O
if	O
(	O
hn	int
+	O
date_dvar	int
>=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
is_3month_mode	int
&&	O
!	O
is_3month_mode2	int
&&	O
(	O
hn	int
+	O
date_dvar	int
<=	O
j	int
)	O
)	O
{	O
print_twice	int
++	O
;	O
is_2dvar	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
if	O
(	O
fiscal_month	int
>=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
j	int
=	O
dvec	array(int)
[	O
MONTH_MIN	int
-	O
1	int
]	O
;	O
if	O
(	O
fiscal_month	int
==	O
MONTH_MAX	int
)	O
j	int
+=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
+	O
is_leap_year	int
;	O
if	O
(	O
hn	int
+	O
date_dvar	int
<=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
hn	int
+	O
date_dvar	int
<=	O
j	int
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
+	O
1	int
,	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
(	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
?	O
TOday	int
:	O
DVar	int
)	O
)	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
hc	char
==	O
'D'	O
||	O
hc	char
==	O
'W'	O
)	O
{	O
y	int
=	O
year	int
;	O
if	O
(	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
hn	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
{	O
register	O
int	O
date_dvar	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
if	O
(	O
fiscal_month	int
-	O
1	int
==	O
2	int
)	O
i	int
=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
;	O
else	O
i	int
=	O
dvec	array(int)
[	O
fiscal_month	int
-	O
2	int
]	O
;	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
fiscal_month	int
,	O
year	int
)	O
;	O
if	O
(	O
date_dvar	int
>=	O
j	int
)	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
is_3month_mode	int
&&	O
!	O
is_3month_mode2	int
&&	O
(	O
date_dvar	int
<=	O
j	int
)	O
)	O
{	O
d_buf	int
=	O
d	int
;	O
m_buf	int
=	O
m	int
;	O
print_twice	int
++	O
;	O
is_2dvar	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
if	O
(	O
fiscal_month	int
>=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
j	int
=	O
dvec	array(int)
[	O
MONTH_MIN	int
-	O
1	int
]	O
;	O
if	O
(	O
fiscal_month	int
==	O
MONTH_MAX	int
)	O
j	int
+=	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
+	O
is_leap_year	int
;	O
if	O
(	O
date_dvar	int
<=	O
j	int
)	O
{	O
y	int
++	O
;	O
(	O
void	O
)	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
hn	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
{	O
j	int
=	O
day_of_year	(int,int,int)->(int)
(	O
i	int
,	O
fiscal_month	int
-	O
1	int
,	O
year	int
+	O
1	int
)	O
;	O
if	O
(	O
date_dvar	int
<=	O
j	int
)	O
{	O
y	int
++	O
;	O
(	O
void	O
)	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hn	int
,	O
hwd	int
,	O
&	O
hn	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
y	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
is_range	int
&&	O
(	O
repeat	int
>	O
1	int
)	O
)	O
is_range	int
=	O
TRUE	O
;	O
if	O
(	O
date_matches_period	(*(int),int,int,int)->(int)
(	O
&	O
print_twice	int
,	O
day	int
,	O
ed	int
,	O
wd	int
)	O
)	O
insert_line_into_table	(*(char),*(char),long,*(int),int,int)->(void)
(	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
,	O
rc_elems	int
,	O
len_date	int
,	O
print_twice	int
)	O
;	O
}	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
||	O
repeat	int
)	O
{	O
if	O
(	O
is_range	int
)	O
{	O
if	O
(	O
m	int
)	O
{	O
if	O
(	O
y	int
<=	O
0	int
)	O
y	int
=	O
year	int
;	O
if	O
(	O
appears	int
)	O
{	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
+	O
appears	int
+	O
1	int
,	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
,	O
&	O
d	int
,	O
&	O
m	int
)	O
;	O
productions	int
-=	O
appears	int
;	O
}	O
else	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
&&	O
(	O
productions	int
<=	O
1	int
)	O
&&	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
productions	int
=	O
2	int
;	O
is_range	int
=	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
)	O
{	O
if	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
productions	int
=	O
2	int
;	O
is_range	int
=	O
FALSE	O
;	O
}	O
else	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
appears	int
)	O
{	O
productions	int
-=	O
appears	int
;	O
if	O
(	O
productions	int
>	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
appears	int
;	O
i	int
++	O
)	O
if	O
(	O
++	O
buf_d	int
>	O
DAY_MAX	int
)	O
buf_d	int
=	O
DAY_MIN	int
;	O
}	O
else	O
if	O
(	O
++	O
buf_d	int
>	O
DAY_MAX	int
)	O
buf_d	int
=	O
DAY_MIN	int
;	O
d	int
=	O
buf_d	int
;	O
m	int
=	O
buf_m	int
;	O
y	int
=	O
buf_y	int
;	O
}	O
}	O
else	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
&&	O
(	O
lptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
break	O
;	O
}	O
while	O
(	O
--	O
productions	int
>	O
0	int
)	O
;	O
month	int
=	O
tmp_month	int
;	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
free	(*(void))->(void)
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
)	O
;	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
free	(*(void))->(void)
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
)	O
;	O
}	O
static	O
Bool	int
date_matches_period	(*(int),int,int,int)->(int)
(	O
print_twice	int
,	O
day	int
,	O
ed	int
,	O
wd	int
)	O
int	O
*	O
print_twice	int
;	O
int	O
day	int
;	O
int	O
ed	int
;	O
const	O
int	O
wd	int
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
auto	O
int	O
dd	int
;	O
auto	O
int	O
mm	int
;	O
auto	O
int	O
yy	int
;	O
auto	O
Bool	int
print_line	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_valid_date	int
=	O
TRUE	O
;	O
if	O
(	O
is_date_given	int
||	O
(	O
(	O
year	int
!=	O
act_year	int
)	O
&&	O
(	O
day	int
>	O
0	int
)	O
)	O
||	O
(	O
(	O
month	int
&&	O
(	O
month	int
!=	O
act_month	int
)	O
)	O
&&	O
(	O
year	int
==	O
act_year	int
)	O
)	O
)	O
{	O
if	O
(	O
d	int
&&	O
!	O
is_weekday_mode	*(int)
)	O
{	O
incr_year	int
=	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
&&	O
(	O
m	int
<	O
fiscal_month	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
is_date_given	int
&&	O
month	int
&&	O
!	O
changed_month	int
&&	O
!	O
m	int
)	O
{	O
m	int
=	O
month	int
;	O
is_valid_date	int
=	O
valid_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
)	O
;	O
}	O
if	O
(	O
is_valid_date	int
&&	O
(	O
!	O
y	int
||	O
y	int
-	O
incr_year	int
==	O
year	int
)	O
&&	O
m	int
&&	O
d	int
)	O
{	O
if	O
(	O
month	int
&&	O
!	O
changed_month	int
)	O
{	O
if	O
(	O
m	int
==	O
month	int
)	O
{	O
if	O
(	O
!	O
is_leap_year	int
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
;	O
else	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
if	O
(	O
(	O
incr_year	int
&&	O
(	O
year	int
<	O
YEAR_MAX	int
)	O
)	O
||	O
(	O
(	O
m	int
>=	O
fiscal_month	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
days_of_february	(int)->(int)
(	O
year	int
+	O
incr_year	int
)	O
==	O
28	int
)	O
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
;	O
else	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
is_leap_year	int
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
;	O
else	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
rc_period_flag	int
||	O
rc_week_flag	int
||	O
rc_month_flag	int
||	O
rc_year_flag	int
)	O
&&	O
!	O
is_date_given	int
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
||	O
(	O
rc_week_flag	int
&&	O
(	O
(	O
(	O
year	int
+	O
1	int
<=	O
YEAR_MAX	int
)	O
&&	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
||	O
(	O
(	O
year	int
-	O
1	int
>=	O
YEAR_MIN	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
)	O
)	O
)	O
)	O
)	O
)	O
{	O
register	O
int	O
td	int
;	O
if	O
(	O
m	int
&&	O
d	int
)	O
{	O
if	O
(	O
rc_week_flag	int
&&	O
!	O
y	int
&&	O
(	O
m	int
!=	O
month	int
)	O
)	O
{	O
if	O
(	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
!	O
adate_set	int
&&	O
(	O
rc_forwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
)	O
y	int
=	O
year	int
+	O
1	int
;	O
else	O
if	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
&&	O
!	O
adate_set	int
&&	O
(	O
rc_backwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
)	O
y	int
=	O
year	int
-	O
1	int
;	O
}	O
if	O
(	O
y	int
<	O
YEAR_MIN	int
||	O
y	int
>	O
YEAR_MAX	int
)	O
{	O
if	O
(	O
adate_set	int
)	O
{	O
if	O
(	O
m	int
==	O
month	int
)	O
{	O
if	O
(	O
day	int
<	O
DAY_MIN	int
)	O
y	int
=	O
year	int
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
y	int
=	O
year	int
+	O
1	int
;	O
}	O
if	O
(	O
y	int
<	O
YEAR_MIN	int
||	O
y	int
>	O
YEAR_MAX	int
)	O
y	int
=	O
year	int
;	O
}	O
else	O
y	int
=	O
year	int
;	O
}	O
}	O
if	O
(	O
(	O
rc_week_flag	int
&&	O
is_weekday_mode	*(int)
)	O
||	O
(	O
!	O
is_weekday_mode	*(int)
&&	O
(	O
y	int
||	O
m	int
||	O
d	int
)	O
)	O
)	O
{	O
if	O
(	O
rc_week_flag	int
&&	O
is_weekday_mode	*(int)
)	O
{	O
static	O
struct	O
{	O
char	O
day	int
[	O
DAY_MAX	int
]	O
;	O
char	O
dst	array(char)
[	O
DAY_MAX	int
]	O
;	O
}	O
wday_list	struct(array(char),array(char))
;	O
static	O
Bool	int
fill_wday_list	int
=	O
FALSE	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
!	O
fill_wday_list	int
)	O
{	O
if	O
(	O
rc_forwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
{	O
i	int
=	O
wd	int
;	O
LOOP	O
{	O
wday_list	struct(array(char),array(char))
.	O
day	int
[	O
i	int
-	O
1	int
]	O
=	O
(	O
char	O
)	O
i	int
;	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
i	int
-	O
1	int
]	O
=	O
(	O
char	O
)	O
j	int
++	O
;	O
i	int
++	O
;	O
if	O
(	O
i	int
>	O
DAY_MAX	int
)	O
i	int
=	O
DAY_MIN	int
;	O
if	O
(	O
i	int
==	O
start_day	int
)	O
break	O
;	O
}	O
}	O
j	int
=	O
0	int
;	O
if	O
(	O
rc_backwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
{	O
i	int
=	O
wd	int
;	O
LOOP	O
{	O
if	O
(	O
i	int
<	O
DAY_MIN	int
)	O
i	int
=	O
DAY_MAX	int
;	O
wday_list	struct(array(char),array(char))
.	O
day	int
[	O
i	int
-	O
1	int
]	O
=	O
(	O
char	O
)	O
i	int
;	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
i	int
-	O
1	int
]	O
=	O
(	O
char	O
)	O
++	O
j	int
;	O
if	O
(	O
i	int
==	O
start_day	int
)	O
break	O
;	O
i	int
--	O
;	O
}	O
}	O
fill_wday_list	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
wday_list	struct(array(char),array(char))
.	O
day	int
[	O
d	int
-	O
1	int
]	O
)	O
{	O
yy	int
=	O
year	int
;	O
if	O
(	O
rc_week_year_flag	int
)	O
{	O
j	int
=	O
day	int
;	O
if	O
(	O
day	int
<	O
1	int
)	O
{	O
yy	int
=	O
year	int
-	O
1	int
;	O
j	int
+=	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
yy	int
)	O
==	O
29	int
)	O
)	O
;	O
}	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
j	int
,	O
(	O
days_of_february	(int)->(int)
(	O
yy	int
)	O
==	O
29	int
)	O
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
}	O
else	O
{	O
dd	int
=	O
act_day	int
;	O
mm	int
=	O
month	int
;	O
}	O
if	O
(	O
rc_forwards_flag	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
d	int
-	O
1	int
]	O
;	O
i	int
++	O
)	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
)	O
;	O
else	O
if	O
(	O
rc_backwards_flag	int
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
d	int
-	O
1	int
]	O
;	O
i	int
++	O
)	O
(	O
void	O
)	O
prev_date	(*(int),*(int),*(int))->(int)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
)	O
;	O
else	O
{	O
i	int
=	O
SYEAR	O
(	O
d	int
,	O
start_day	int
)	O
;	O
j	int
=	O
SYEAR	O
(	O
wd	int
,	O
start_day	int
)	O
;	O
if	O
(	O
i	int
-	O
j	int
<=	O
0	int
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
d	int
-	O
1	int
]	O
;	O
i	int
++	O
)	O
(	O
void	O
)	O
prev_date	(*(int),*(int),*(int))->(int)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wday_list	struct(array(char),array(char))
.	O
dst	array(char)
[	O
d	int
-	O
1	int
]	O
;	O
i	int
++	O
)	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
)	O
;	O
}	O
if	O
(	O
(	O
!	O
m	int
||	O
m	int
==	O
mm	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
yy	int
)	O
)	O
{	O
d	int
=	O
dd	int
;	O
m	int
=	O
mm	int
;	O
y	int
=	O
yy	int
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
rc_week_flag	int
&&	O
(	O
y	int
>=	O
0	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
||	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
{	O
if	O
(	O
(	O
rc_backwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
&&	O
(	O
y	int
==	O
year	int
-	O
1	int
)	O
&&	O
m	int
&&	O
d	int
)	O
{	O
ed	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
;	O
day	int
=	O
ed	int
+	O
day	int
;	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
(	O
td	int
<=	O
ed	int
)	O
&&	O
(	O
td	int
>=	O
day	int
)	O
)	O
{	O
decr_year	int
=	O
1	int
;	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
rc_forwards_flag	int
||	O
(	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
&&	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
&&	O
m	int
&&	O
d	int
)	O
{	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
+	O
DAY_LAST	int
+	O
is_leap_year	int
;	O
if	O
(	O
(	O
td	int
<	O
ed	int
)	O
&&	O
(	O
td	int
>=	O
day	int
)	O
)	O
{	O
incr_year	int
=	O
1	int
;	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
y	int
==	O
year	int
||	O
(	O
(	O
y	int
==	O
year	int
-	O
1	int
)	O
&&	O
!	O
rc_forwards_flag	int
)	O
||	O
(	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
&&	O
m	int
&&	O
d	int
)	O
{	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
(	O
td	int
<	O
ed	int
)	O
&&	O
(	O
td	int
>=	O
day	int
)	O
)	O
print_line	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
d	int
)	O
{	O
td	int
=	O
0	int
;	O
m	int
=	O
month	int
;	O
if	O
(	O
day	int
<	O
DAY_MIN	int
)	O
{	O
if	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
||	O
y	int
==	O
year	int
-	O
1	int
)	O
{	O
if	O
(	O
adate_set	int
)	O
i	int
=	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
+	O
day	int
-	O
1	int
;	O
else	O
i	int
=	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
+	O
act_day	int
-	O
(	O
SYEAR	O
(	O
wd	int
,	O
start_day	int
)	O
)	O
;	O
if	O
(	O
d	int
>	O
i	int
)	O
{	O
m	int
=	O
MONTH_MAX	int
;	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
year	int
-	O
1	int
;	O
if	O
(	O
y	int
==	O
year	int
)	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
)	O
;	O
else	O
{	O
ed	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
;	O
day	int
=	O
ed	int
+	O
day	int
;	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
decr_year	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
{	O
if	O
(	O
adate_set	int
)	O
{	O
m	int
=	O
MONTH_MIN	int
;	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
)	O
+	O
1	int
;	O
}	O
else	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
)	O
+	O
1	int
;	O
}	O
else	O
td	int
=	O
ed	int
+	O
1	int
;	O
if	O
(	O
(	O
td	int
<=	O
ed	int
)	O
&&	O
(	O
td	int
>=	O
day	int
)	O
)	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
||	O
y	int
==	O
year	int
+	O
1	int
)	O
{	O
i	int
=	O
act_day	int
-	O
(	O
SYEAR	O
(	O
wd	int
,	O
start_day	int
)	O
)	O
;	O
if	O
(	O
d	int
<	O
i	int
)	O
{	O
m	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
year	int
+	O
1	int
;	O
if	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
{	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
+	O
DAY_LAST	int
+	O
is_leap_year	int
;	O
incr_year	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
)	O
;	O
if	O
(	O
(	O
td	int
<	O
ed	int
)	O
&&	O
(	O
td	int
>=	O
day	int
)	O
)	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
y	int
>=	O
0	int
||	O
y	int
==	O
year	int
)	O
{	O
if	O
(	O
(	O
(	O
rc_month_flag	int
||	O
rc_week_flag	int
||	O
rc_period_flag	int
)	O
&&	O
m	int
&&	O
!	O
d	int
)	O
||	O
(	O
(	O
rc_month_flag	int
||	O
rc_week_flag	int
)	O
&&	O
!	O
m	int
&&	O
!	O
d	int
)	O
||	O
(	O
(	O
rc_year_flag	int
||	O
rc_period_list	int
)	O
&&	O
(	O
!	O
m	int
||	O
!	O
d	int
)	O
)	O
)	O
;	O
else	O
{	O
register	O
int	O
mmm	int
=	O
m	int
;	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
year	int
;	O
if	O
(	O
!	O
m	int
)	O
{	O
mmm	int
=	O
m	int
=	O
month	int
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
day	int
,	O
is_leap_year	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
if	O
(	O
(	O
dd	int
>	O
d	int
)	O
&&	O
(	O
mm	int
==	O
m	int
)	O
)	O
m	int
++	O
;	O
else	O
if	O
(	O
(	O
dd	int
<	O
d	int
)	O
&&	O
(	O
mm	int
<	O
m	int
)	O
)	O
m	int
--	O
;	O
}	O
if	O
(	O
valid_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
)	O
{	O
td	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
(	O
td	int
>=	O
day	int
)	O
&&	O
(	O
td	int
<	O
ed	int
)	O
)	O
print_line	int
=	O
TRUE	O
;	O
else	O
m	int
=	O
mmm	int
;	O
}	O
else	O
m	int
=	O
mmm	int
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
rc_period_flag	int
&&	O
!	O
rc_week_flag	int
&&	O
!	O
rc_month_flag	int
&&	O
!	O
rc_year_flag	int
)	O
{	O
dd	int
=	O
act_day	int
;	O
mm	int
=	O
month	int
;	O
yy	int
=	O
year	int
;	O
if	O
(	O
rc_tomorrow_flag	int
)	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
)	O
;	O
if	O
(	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
||	O
(	O
rc_tomorrow_flag	int
&&	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
mm	int
)	O
)	O
)	O
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
month	int
||	O
(	O
rc_tomorrow_flag	int
&&	O
(	O
m	int
==	O
mm	int
)	O
&&	O
(	O
!	O
y	int
||	O
(	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
)	O
||	O
(	O
(	O
ed	int
<=	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
y	int
==	O
year	int
)	O
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
is_weekday_mode	*(int)
)	O
{	O
i	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
act_day	int
,	O
month	int
,	O
year	int
)	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
rc_tomorrow_flag	int
)	O
j	int
=	O
(	O
d	int
==	O
weekday_of_date	(int,int,int)->(int)
(	O
dd	int
,	O
mm	int
,	O
yy	int
)	O
)	O
;	O
if	O
(	O
(	O
(	O
d	int
==	O
i	int
)	O
&&	O
(	O
ed	int
<=	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
month	int
)	O
)	O
||	O
(	O
(	O
d	int
==	O
i	int
)	O
&&	O
(	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
(	O
!	O
y	int
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
month	int
)	O
)	O
||	O
y	int
==	O
year	int
)	O
)	O
)	O
||	O
(	O
j	int
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
month	int
+	O
1	int
||	O
m	int
==	O
mm	int
)	O
&&	O
(	O
!	O
y	int
||	O
(	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
y	int
==	O
year	int
+	O
1	int
)	O
)	O
||	O
(	O
(	O
ed	int
<=	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
y	int
==	O
year	int
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
j	int
)	O
{	O
m	int
=	O
mm	int
;	O
d	int
=	O
dd	int
;	O
if	O
(	O
rc_tomorrow_flag	int
&&	O
(	O
yy	int
!=	O
year	int
)	O
)	O
incr_year	int
=	O
1	int
;	O
}	O
else	O
{	O
m	int
=	O
month	int
;	O
d	int
=	O
act_day	int
;	O
}	O
if	O
(	O
rc_tomorrow_flag	int
&&	O
!	O
rc_have_today_in_list	int
&&	O
(	O
d	int
!=	O
dd	int
)	O
)	O
;	O
else	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
d	int
||	O
(	O
(	O
d	int
==	O
act_day	int
)	O
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
month	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
)	O
||	O
(	O
(	O
d	int
==	O
dd	int
)	O
&&	O
(	O
mm	int
==	O
month	int
||	O
(	O
rc_tomorrow_flag	int
&&	O
(	O
(	O
!	O
m	int
&&	O
(	O
ed	int
<=	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
)	O
||	O
m	int
==	O
month	int
+	O
1	int
||	O
m	int
==	O
mm	int
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
rc_tomorrow_flag	int
)	O
{	O
if	O
(	O
!	O
d	int
&&	O
(	O
!	O
m	int
||	O
(	O
mm	int
==	O
month	int
||	O
m	int
==	O
month	int
+	O
1	int
||	O
m	int
==	O
mm	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
yy	int
>	O
year	int
)	O
&&	O
(	O
d	int
||	O
m	int
||	O
y	int
)	O
)	O
{	O
if	O
(	O
!	O
y	int
||	O
y	int
==	O
yy	int
)	O
{	O
m	int
=	O
mm	int
;	O
d	int
=	O
dd	int
;	O
incr_year	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
m	int
||	O
y	int
!=	O
year	int
||	O
ed	int
<=	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
{	O
if	O
(	O
!	O
d	int
&&	O
m	int
&&	O
(	O
mm	int
!=	O
month	int
)	O
&&	O
(	O
!	O
y	int
||	O
y	int
==	O
year	int
)	O
)	O
{	O
m	int
=	O
mm	int
;	O
d	int
=	O
dd	int
;	O
}	O
else	O
{	O
if	O
(	O
rc_have_today_in_list	int
)	O
(	O
*	O
print_twice	int
)	O
++	O
;	O
else	O
{	O
m	int
=	O
mm	int
;	O
d	int
=	O
dd	int
;	O
if	O
(	O
yy	int
!=	O
year	int
)	O
incr_year	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
d	int
==	O
dd	int
)	O
&&	O
(	O
!	O
m	int
||	O
m	int
==	O
mm	int
)	O
)	O
{	O
m	int
=	O
mm	int
;	O
if	O
(	O
ed	int
>	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
incr_year	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
m	int
)	O
m	int
=	O
month	int
;	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
act_day	int
;	O
if	O
(	O
rc_tomorrow_flag	int
&&	O
!	O
rc_have_today_in_list	int
&&	O
(	O
d	int
!=	O
dd	int
)	O
)	O
;	O
else	O
print_line	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
print_line	int
&&	O
(	O
year	int
+	O
incr_year	int
-	O
decr_year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
m	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
(	O
d	int
>=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
)	O
&&	O
(	O
d	int
<=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
)	O
)	O
)	O
print_line	int
=	O
FALSE	O
;	O
if	O
(	O
print_line	int
&&	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
)	O
{	O
register	O
int	O
m2	int
=	O
fiscal_month	int
+	O
1	int
;	O
register	O
int	O
m3	int
=	O
fiscal_month	int
+	O
2	int
;	O
if	O
(	O
fiscal_month	int
>=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
m3	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
fiscal_month	int
==	O
MONTH_MAX	int
)	O
{	O
m2	int
=	O
MONTH_MIN	int
;	O
m3	int
++	O
;	O
}	O
}	O
if	O
(	O
(	O
m	int
!=	O
fiscal_month	int
)	O
&&	O
(	O
m	int
!=	O
m2	int
)	O
&&	O
(	O
m	int
!=	O
m3	int
)	O
)	O
print_line	int
=	O
FALSE	O
;	O
}	O
return	O
(	O
print_line	int
)	O
;	O
}	O
static	O
int	O
get_number	(*(*(char)))->(int)
(	O
string	*(char)
)	O
char	O
*	O
*	O
string	*(char)
;	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
(	O
*	O
string	*(char)
)	O
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
*	O
string	*(char)
)	O
)	O
s6	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
(	O
(	O
*	O
string	*(char)
)	O
++	O
)	O
;	O
s6	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	int
>	O
3	int
)	O
return	O
(	O
0	int
)	O
;	O
i	int
=	O
atoi	(*(char))->(int)
(	O
s6	*(char)
)	O
;	O
if	O
(	O
i	int
>	O
DAY_LAST	int
+	O
1	int
)	O
i	int
=	O
DAY_LAST	int
+	O
1	int
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
