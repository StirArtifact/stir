static	O
struct	O
net_hash_header	O
filter_hash_header	struct
[	O
N_NET_HASH	O
]	O
;	O
int	O
bpf_do_filter	(int,*(char),int,*(char),int,*(*(int)),*(int))->(int)
(	O
net_rcv_port_t	O
infp	int
,	O
char	O
*	O
p	*(char)
,	O
unsigned	O
int	O
wirelen	int
,	O
char	O
*	O
header	*(char)
,	O
unsigned	O
int	O
hlen	int
,	O
net_hash_entry_t	O
*	O
*	O
hash_headpp	*(*(int))
,	O
net_hash_entry_t	O
*	O
entpp	*(int)
)	O
{	O
register	O
bpf_insn_t	O
pc	int
,	O
pc_end	O
;	O
register	O
unsigned	O
int	O
buflen	int
;	O
register	O
unsigned	O
long	O
A	long
,	O
X	long
;	O
register	O
int	O
k	int
;	O
unsigned	O
int	O
mem	int
[	O
BPF_MEMWORDS	O
]	O
;	O
char	O
*	O
data	*(char)
=	O
NULL	O
;	O
pc	int
=	O
(	O
(	O
bpf_insn_t	O
)	O
infp	int
->	O
filter	*(int)
)	O
+	O
1	int
;	O
pc_end	O
=	O
(	O
bpf_insn_t	O
)	O
infp	int
->	O
filter_end	O
;	O
buflen	int
=	O
NET_RCV_MAX	O
;	O
*	O
entpp	*(int)
=	O
0	int
;	O
A	long
=	O
0	int
;	O
X	long
=	O
0	int
;	O
for	O
(	O
;	O
pc	int
<	O
pc_end	O
;	O
++	O
pc	int
)	O
{	O
switch	O
(	O
pc	int
->	O
code	O
)	O
{	O
default	O
:	O
abort	O
(	O
)	O
;	O
case	O
BPF_RET	O
|	O
BPF_K	O
:	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
MACH_PORT_NULL	O
&&	O
*	O
entpp	*(int)
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
return	O
(	O
(	O
u_int	int
)	O
pc	int
->	O
k	int
<=	O
wirelen	int
)	O
?	O
pc	int
->	O
k	int
:	O
wirelen	int
;	O
case	O
BPF_RET	O
|	O
BPF_A	O
:	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
MACH_PORT_NULL	O
&&	O
*	O
entpp	*(int)
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
return	O
(	O
(	O
u_int	int
)	O
A	long
<=	O
wirelen	int
)	O
?	O
A	long
:	O
wirelen	int
;	O
case	O
BPF_RET	O
|	O
BPF_MATCH_IMM	O
:	O
if	O
(	O
bpf_match	()->(int)
(	O
(	O
net_hash_header_t	O
)	O
infp	int
,	O
pc	int
->	O
jt	O
,	O
mem	int
,	O
hash_headpp	*(*(int))
,	O
entpp	*(int)
)	O
)	O
{	O
return	O
(	O
(	O
u_int	int
)	O
pc	int
->	O
k	int
<=	O
wirelen	int
)	O
?	O
pc	int
->	O
k	int
:	O
wirelen	int
;	O
}	O
return	O
0	int
;	O
case	O
BPF_LD	O
|	O
BPF_W	O
|	O
BPF_ABS	O
:	O
k	int
=	O
pc	int
->	O
k	int
;	O
load_word	O
:	O
if	O
(	O
(	O
u_int	int
)	O
k	int
+	O
sizeof	O
(	O
long	O
)	O
<=	O
hlen	int
)	O
data	*(char)
=	O
header	*(char)
;	O
else	O
if	O
(	O
(	O
u_int	int
)	O
k	int
+	O
sizeof	O
(	O
long	O
)	O
<=	O
buflen	int
)	O
{	O
k	int
-=	O
hlen	int
;	O
data	*(char)
=	O
p	*(char)
;	O
}	O
else	O
return	O
0	int
;	O
A	long
=	O
ntohl	(int)->(int)
(	O
*	O
(	O
long	O
*	O
)	O
(	O
data	*(char)
+	O
k	int
)	O
)	O
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_H	O
|	O
BPF_ABS	O
:	O
k	int
=	O
pc	int
->	O
k	int
;	O
load_half	O
:	O
if	O
(	O
(	O
u_int	int
)	O
k	int
+	O
sizeof	O
(	O
short	O
)	O
<=	O
hlen	int
)	O
data	*(char)
=	O
header	*(char)
;	O
else	O
if	O
(	O
(	O
u_int	int
)	O
k	int
+	O
sizeof	O
(	O
short	O
)	O
<=	O
buflen	int
)	O
{	O
k	int
-=	O
hlen	int
;	O
data	*(char)
=	O
p	*(char)
;	O
}	O
else	O
return	O
0	int
;	O
A	long
=	O
EXTRACT_SHORT	()->(int)
(	O
&	O
data	*(char)
[	O
k	int
]	O
)	O
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_B	O
|	O
BPF_ABS	O
:	O
k	int
=	O
pc	int
->	O
k	int
;	O
load_byte	O
:	O
if	O
(	O
(	O
u_int	int
)	O
k	int
<	O
hlen	int
)	O
data	*(char)
=	O
header	*(char)
;	O
else	O
if	O
(	O
(	O
u_int	int
)	O
k	int
<	O
buflen	int
)	O
{	O
data	*(char)
=	O
p	*(char)
;	O
k	int
-=	O
hlen	int
;	O
}	O
else	O
return	O
0	int
;	O
A	long
=	O
data	*(char)
[	O
k	int
]	O
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_W	O
|	O
BPF_LEN	O
:	O
A	long
=	O
wirelen	int
;	O
continue	O
;	O
case	O
BPF_LDX	O
|	O
BPF_W	O
|	O
BPF_LEN	O
:	O
X	long
=	O
wirelen	int
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_W	O
|	O
BPF_IND	O
:	O
k	int
=	O
X	long
+	O
pc	int
->	O
k	int
;	O
goto	O
load_word	O
;	O
case	O
BPF_LD	O
|	O
BPF_H	O
|	O
BPF_IND	O
:	O
k	int
=	O
X	long
+	O
pc	int
->	O
k	int
;	O
goto	O
load_half	O
;	O
case	O
BPF_LD	O
|	O
BPF_B	O
|	O
BPF_IND	O
:	O
k	int
=	O
X	long
+	O
pc	int
->	O
k	int
;	O
goto	O
load_byte	O
;	O
case	O
BPF_LDX	O
|	O
BPF_MSH	O
|	O
BPF_B	O
:	O
k	int
=	O
pc	int
->	O
k	int
;	O
if	O
(	O
k	int
<	O
hlen	int
)	O
data	*(char)
=	O
header	*(char)
;	O
else	O
if	O
(	O
k	int
<	O
buflen	int
)	O
{	O
data	*(char)
=	O
p	*(char)
;	O
k	int
-=	O
hlen	int
;	O
}	O
else	O
return	O
0	int
;	O
X	long
=	O
(	O
data	*(char)
[	O
k	int
]	O
&	O
0xf	int
)	O
<<	O
2	int
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_IMM	O
:	O
A	long
=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_LDX	O
|	O
BPF_IMM	O
:	O
X	long
=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_LD	O
|	O
BPF_MEM	O
:	O
A	long
=	O
mem	int
[	O
pc	int
->	O
k	int
]	O
;	O
continue	O
;	O
case	O
BPF_LDX	O
|	O
BPF_MEM	O
:	O
X	long
=	O
mem	int
[	O
pc	int
->	O
k	int
]	O
;	O
continue	O
;	O
case	O
BPF_ST	O
:	O
mem	int
[	O
pc	int
->	O
k	int
]	O
=	O
A	long
;	O
continue	O
;	O
case	O
BPF_STX	O
:	O
mem	int
[	O
pc	int
->	O
k	int
]	O
=	O
X	long
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JA	O
:	O
pc	int
+=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JGT	O
|	O
BPF_K	O
:	O
pc	int
+=	O
(	O
A	long
>	O
pc	int
->	O
k	int
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JGE	O
|	O
BPF_K	O
:	O
pc	int
+=	O
(	O
A	long
>=	O
pc	int
->	O
k	int
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JEQ	O
|	O
BPF_K	O
:	O
pc	int
+=	O
(	O
A	long
==	O
pc	int
->	O
k	int
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JSET	O
|	O
BPF_K	O
:	O
pc	int
+=	O
(	O
A	long
&	O
pc	int
->	O
k	int
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JGT	O
|	O
BPF_X	O
:	O
pc	int
+=	O
(	O
A	long
>	O
X	long
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JGE	O
|	O
BPF_X	O
:	O
pc	int
+=	O
(	O
A	long
>=	O
X	long
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JEQ	O
|	O
BPF_X	O
:	O
pc	int
+=	O
(	O
A	long
==	O
X	long
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_JMP	O
|	O
BPF_JSET	O
|	O
BPF_X	O
:	O
pc	int
+=	O
(	O
A	long
&	O
X	long
)	O
?	O
pc	int
->	O
jt	O
:	O
pc	int
->	O
jf	O
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_ADD	O
|	O
BPF_X	O
:	O
A	long
+=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_SUB	O
|	O
BPF_X	O
:	O
A	long
-=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_MUL	O
|	O
BPF_X	O
:	O
A	long
*=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_DIV	O
|	O
BPF_X	O
:	O
if	O
(	O
X	long
==	O
0	int
)	O
return	O
0	int
;	O
A	long
/=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_AND	O
|	O
BPF_X	O
:	O
A	long
&=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_OR	O
|	O
BPF_X	O
:	O
A	long
|=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_LSH	O
|	O
BPF_X	O
:	O
A	long
<<=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_RSH	O
|	O
BPF_X	O
:	O
A	long
>>=	O
X	long
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_ADD	O
|	O
BPF_K	O
:	O
A	long
+=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_SUB	O
|	O
BPF_K	O
:	O
A	long
-=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_MUL	O
|	O
BPF_K	O
:	O
A	long
*=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_DIV	O
|	O
BPF_K	O
:	O
A	long
/=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_AND	O
|	O
BPF_K	O
:	O
A	long
&=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_OR	O
|	O
BPF_K	O
:	O
A	long
|=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_LSH	O
|	O
BPF_K	O
:	O
A	long
<<=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_RSH	O
|	O
BPF_K	O
:	O
A	long
>>=	O
pc	int
->	O
k	int
;	O
continue	O
;	O
case	O
BPF_ALU	O
|	O
BPF_NEG	O
:	O
A	long
=	O
-	O
A	long
;	O
continue	O
;	O
case	O
BPF_MISC	O
|	O
BPF_TAX	O
:	O
X	long
=	O
A	long
;	O
continue	O
;	O
case	O
BPF_MISC	O
|	O
BPF_TXA	O
:	O
A	long
=	O
X	long
;	O
continue	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
bpf_validate	(int,int,*(int))->(int)
(	O
bpf_insn_t	O
f	int
,	O
int	O
bytes	int
,	O
bpf_insn_t	O
*	O
match	*(int)
)	O
{	O
register	O
int	O
i	int
,	O
j	int
,	O
len	int
;	O
register	O
bpf_insn_t	O
p	*(char)
;	O
len	int
=	O
BPF_BYTES2LEN	()->(int)
(	O
bytes	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
++	O
i	int
)	O
{	O
p	*(char)
=	O
&	O
f	int
[	O
i	int
]	O
;	O
if	O
(	O
BPF_CLASS	()->(int)
(	O
p	*(char)
->	O
code	O
)	O
==	O
BPF_JMP	O
)	O
{	O
register	O
int	O
from	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
BPF_OP	()->(int)
(	O
p	*(char)
->	O
code	O
)	O
==	O
BPF_JA	O
)	O
{	O
if	O
(	O
from	int
+	O
p	*(char)
->	O
k	int
>=	O
len	int
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
from	int
+	O
p	*(char)
->	O
jt	O
>=	O
len	int
||	O
from	int
+	O
p	*(char)
->	O
jf	O
>=	O
len	int
)	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
BPF_CLASS	()->(int)
(	O
p	*(char)
->	O
code	O
)	O
==	O
BPF_ST	O
||	O
(	O
BPF_CLASS	()->(int)
(	O
p	*(char)
->	O
code	O
)	O
==	O
BPF_LD	O
&&	O
(	O
p	*(char)
->	O
code	O
&	O
0xe0	int
)	O
==	O
BPF_MEM	O
)	O
)	O
&&	O
(	O
p	*(char)
->	O
k	int
>=	O
BPF_MEMWORDS	O
||	O
p	*(char)
->	O
k	int
<	O
0	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
p	*(char)
->	O
code	O
==	O
(	O
BPF_ALU	O
|	O
BPF_DIV	O
|	O
BPF_K	O
)	O
&&	O
p	*(char)
->	O
k	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
p	*(char)
->	O
code	O
==	O
(	O
BPF_RET	O
|	O
BPF_MATCH_IMM	O
)	O
)	O
{	O
if	O
(	O
*	O
match	*(int)
!=	O
0	int
||	O
p	*(char)
->	O
jt	O
==	O
0	int
||	O
p	*(char)
->	O
jt	O
>	O
N_NET_HASH_KEYS	O
)	O
return	O
0	int
;	O
i	int
+=	O
p	*(char)
->	O
jt	O
;	O
if	O
(	O
i	int
+	O
1	int
>	O
len	int
)	O
return	O
0	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
p	*(char)
->	O
jt	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
p	*(char)
[	O
j	int
]	O
.	O
code	O
!=	O
(	O
BPF_MISC	O
|	O
BPF_KEY	O
)	O
)	O
return	O
0	int
;	O
}	O
*	O
match	*(int)
=	O
p	*(char)
;	O
}	O
}	O
if	O
(	O
BPF_CLASS	()->(int)
(	O
f	int
[	O
len	int
-	O
1	int
]	O
.	O
code	O
)	O
==	O
BPF_RET	O
)	O
return	O
(	O
(	O
*	O
match	*(int)
==	O
0	int
)	O
?	O
1	int
:	O
2	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
int	O
bpf_eq	(int,int,int)->(int)
(	O
bpf_insn_t	O
f1	int
,	O
bpf_insn_t	O
f2	int
,	O
int	O
bytes	int
)	O
{	O
register	O
int	O
count	int
;	O
count	int
=	O
BPF_BYTES2LEN	()->(int)
(	O
bytes	int
)	O
;	O
for	O
(	O
;	O
count	int
--	O
;	O
f1	int
++	O
,	O
f2	int
++	O
)	O
{	O
if	O
(	O
!	O
BPF_INSN_EQ	()->(int)
(	O
f1	int
,	O
f2	int
)	O
)	O
{	O
if	O
(	O
f1	int
->	O
code	O
==	O
(	O
BPF_MISC	O
|	O
BPF_KEY	O
)	O
&&	O
f2	int
->	O
code	O
==	O
(	O
BPF_MISC	O
|	O
BPF_KEY	O
)	O
)	O
continue	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
;	O
return	O
TRUE	O
;	O
}	O
unsigned	O
int	O
bpf_hash	(int,*(int))->(int)
(	O
int	O
n	int
,	O
unsigned	O
int	O
*	O
keys	*(int)
)	O
{	O
register	O
unsigned	O
int	O
hval	int
=	O
0	int
;	O
while	O
(	O
n	int
--	O
)	O
{	O
hval	int
+=	O
*	O
keys	*(int)
++	O
;	O
}	O
return	O
(	O
hval	int
%	O
NET_HASH_SIZE	O
)	O
;	O
}	O
int	O
bpf_match	()->(int)
(	O
net_hash_header_t	O
hash	int
,	O
int	O
n_keys	int
,	O
unsigned	O
int	O
*	O
keys	*(int)
,	O
net_hash_entry_t	O
*	O
*	O
hash_headpp	*(*(int))
,	O
net_hash_entry_t	O
*	O
entpp	*(int)
)	O
{	O
register	O
net_hash_entry_t	O
head	int
,	O
entp	int
;	O
register	O
int	O
i	int
;	O
if	O
(	O
n_keys	int
!=	O
hash	int
->	O
n_keys	int
)	O
return	O
FALSE	O
;	O
*	O
hash_headpp	*(*(int))
=	O
&	O
hash	int
->	O
table	O
[	O
bpf_hash	(int,*(int))->(int)
(	O
n_keys	int
,	O
keys	*(int)
)	O
]	O
;	O
head	int
=	O
*	O
*	O
hash_headpp	*(*(int))
;	O
if	O
(	O
head	int
==	O
0	int
)	O
return	O
FALSE	O
;	O
HASH_ITERATE	()->(int)
(	O
head	int
,	O
entp	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_keys	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
keys	*(int)
[	O
i	int
]	O
!=	O
entp	int
->	O
keys	*(int)
[	O
i	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
n_keys	int
)	O
{	O
*	O
entpp	*(int)
=	O
entp	int
;	O
return	O
TRUE	O
;	O
}	O
}	O
HASH_ITERATE_END	O
(	O
head	int
,	O
entp	int
)	O
return	O
FALSE	O
;	O
}	O
int	O
hash_ent_remove	(*(int),int,int,*(int),int,*(int))->(int)
(	O
if_filter_list_t	O
*	O
ifp	*(int)
,	O
net_hash_header_t	O
hp	int
,	O
int	O
used	int
,	O
net_hash_entry_t	O
*	O
head	int
,	O
net_hash_entry_t	O
entp	int
,	O
queue_entry_t	O
*	O
dead_p	*(int)
)	O
{	O
hp	int
->	O
ref_count	O
--	O
;	O
if	O
(	O
*	O
head	int
==	O
entp	int
)	O
{	O
if	O
(	O
queue_empty	()->(int)
(	O
(	O
queue_t	O
)	O
entp	int
)	O
)	O
{	O
*	O
head	int
=	O
0	int
;	O
ENQUEUE_DEAD	()->(int)
(	O
*	O
dead_p	*(int)
,	O
entp	int
,	O
chain	O
)	O
;	O
if	O
(	O
hp	int
->	O
ref_count	O
==	O
0	int
&&	O
!	O
used	int
)	O
{	O
if	O
(	O
(	O
(	O
net_rcv_port_t	O
)	O
hp	int
)	O
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_IN	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
,	O
(	O
net_rcv_port_t	O
)	O
hp	int
,	O
net_rcv_port_t	O
,	O
input	O
)	O
;	O
if	O
(	O
(	O
(	O
net_rcv_port_t	O
)	O
hp	int
)	O
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_OUT	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
,	O
(	O
net_rcv_port_t	O
)	O
hp	int
,	O
net_rcv_port_t	O
,	O
output	O
)	O
;	O
hp	int
->	O
n_keys	int
=	O
0	int
;	O
return	O
TRUE	O
;	O
}	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
*	O
head	int
=	O
(	O
net_hash_entry_t	O
)	O
queue_next	O
(	O
(	O
queue_t	O
)	O
entp	int
)	O
;	O
}	O
}	O
remqueue	()->(int)
(	O
(	O
queue_t	O
)	O
*	O
head	int
,	O
(	O
queue_entry_t	O
)	O
entp	int
)	O
;	O
ENQUEUE_DEAD	()->(int)
(	O
*	O
dead_p	*(int)
,	O
entp	int
,	O
chain	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
void	O
net_free_dead_infp	(int)->(void)
(	O
queue_entry_t	O
dead_infp	int
)	O
{	O
register	O
net_rcv_port_t	O
infp	int
,	O
nextfp	O
;	O
for	O
(	O
infp	int
=	O
(	O
net_rcv_port_t	O
)	O
dead_infp	int
;	O
infp	int
!=	O
0	int
;	O
infp	int
=	O
nextfp	O
)	O
{	O
nextfp	O
=	O
(	O
net_rcv_port_t	O
)	O
queue_next	O
(	O
&	O
infp	int
->	O
input	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
infp	int
->	O
rcv_port	int
)	O
;	O
free	()->(int)
(	O
infp	int
)	O
;	O
debug	()->(int)
(	O
"a dead infp is freed\n"	*(char)
)	O
;	O
}	O
}	O
void	O
net_free_dead_entp	(int)->(void)
(	O
queue_entry_t	O
dead_entp	int
)	O
{	O
register	O
net_hash_entry_t	O
entp	int
,	O
nextentp	O
;	O
for	O
(	O
entp	int
=	O
(	O
net_hash_entry_t	O
)	O
dead_entp	int
;	O
entp	int
!=	O
0	int
;	O
entp	int
=	O
nextentp	O
)	O
{	O
nextentp	O
=	O
(	O
net_hash_entry_t	O
)	O
queue_next	O
(	O
&	O
entp	int
->	O
chain	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
entp	int
->	O
rcv_port	int
)	O
;	O
free	()->(int)
(	O
entp	int
)	O
;	O
debug	()->(int)
(	O
"a dead entp is freed\n"	*(char)
)	O
;	O
}	O
}	O
io_return_t	O
net_set_filter	(*(int),int,int,*(int),int)->(int)
(	O
if_filter_list_t	O
*	O
ifp	*(int)
,	O
mach_port_t	O
rcv_port	int
,	O
int	O
priority	int
,	O
filter_t	O
*	O
filter	*(int)
,	O
unsigned	O
int	O
filter_count	int
)	O
{	O
int	O
filter_bytes	int
;	O
bpf_insn_t	O
match	*(int)
;	O
register	O
net_rcv_port_t	O
infp	int
,	O
my_infp	O
;	O
net_rcv_port_t	O
nextfp	O
;	O
net_hash_header_t	O
hhp	O
;	O
register	O
net_hash_entry_t	O
entp	int
,	O
hash_entp	O
=	O
NULL	O
;	O
net_hash_entry_t	O
*	O
head	int
,	O
nextentp	O
;	O
queue_entry_t	O
dead_infp	int
,	O
dead_entp	int
;	O
int	O
i	int
;	O
int	O
ret	int
,	O
is_new_infp	int
;	O
io_return_t	O
rval	O
;	O
boolean_t	O
in	O
,	O
out	O
;	O
debug	()->(int)
(	O
"filter_count: %d, filter[0]: %d\n"	*(char)
,	O
filter_count	int
,	O
filter	*(int)
[	O
0	int
]	O
)	O
;	O
filter_bytes	int
=	O
CSPF_BYTES	()->(int)
(	O
filter_count	int
)	O
;	O
match	*(int)
=	O
(	O
bpf_insn_t	O
)	O
0	int
;	O
if	O
(	O
filter_count	int
==	O
0	int
)	O
{	O
return	O
(	O
D_INVALID_OPERATION	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_IN	O
)	O
||	O
(	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_OUT	O
)	O
)	O
)	O
{	O
return	O
(	O
D_INVALID_OPERATION	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_TYPE_MASK	O
)	O
==	O
NETF_BPF	O
)	O
{	O
ret	int
=	O
bpf_validate	(int,int,*(int))->(int)
(	O
(	O
bpf_insn_t	O
)	O
filter	*(int)
,	O
filter_bytes	int
,	O
&	O
match	*(int)
)	O
;	O
if	O
(	O
!	O
ret	int
)	O
return	O
(	O
D_INVALID_OPERATION	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
D_INVALID_OPERATION	O
)	O
;	O
}	O
debug	()->(int)
(	O
"net_set_filter: check over\n"	*(char)
)	O
;	O
rval	O
=	O
D_SUCCESS	O
;	O
dead_infp	int
=	O
dead_entp	int
=	O
0	int
;	O
if	O
(	O
match	*(int)
==	O
(	O
bpf_insn_t	O
)	O
0	int
)	O
{	O
my_infp	O
=	O
(	O
net_rcv_port_t	O
)	O
calloc	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
net_rcv_port	O
)	O
)	O
;	O
my_infp	O
->	O
rcv_port	int
=	O
rcv_port	int
;	O
is_new_infp	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
my_infp	O
=	O
0	int
;	O
hash_entp	O
=	O
(	O
net_hash_entry_t	O
)	O
calloc	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
net_hash_entry	O
)	O
)	O
;	O
is_new_infp	int
=	O
FALSE	O
;	O
}	O
void	O
check_filter_list	()->(int)
(	O
queue_head_t	O
*	O
if_port_list	*(int)
)	O
{	O
FILTER_ITERATE	()->(int)
(	O
if_port_list	*(int)
,	O
infp	int
,	O
nextfp	O
,	O
(	O
if_port_list	*(int)
==	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
)	O
?	O
&	O
infp	int
->	O
input	O
:	O
&	O
infp	int
->	O
output	O
)	O
{	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
MACH_PORT_NULL	O
)	O
{	O
if	O
(	O
match	*(int)
!=	O
0	int
&&	O
infp	int
->	O
priority	int
==	O
priority	int
&&	O
my_infp	O
==	O
0	int
&&	O
(	O
infp	int
->	O
filter_end	O
-	O
infp	int
->	O
filter	*(int)
)	O
==	O
filter_count	int
&&	O
bpf_eq	(int,int,int)->(int)
(	O
(	O
bpf_insn_t	O
)	O
infp	int
->	O
filter	*(int)
,	O
(	O
bpf_insn_t	O
)	O
filter	*(int)
,	O
filter_bytes	int
)	O
)	O
my_infp	O
=	O
infp	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NET_HASH_SIZE	O
;	O
i	int
++	O
)	O
{	O
head	int
=	O
&	O
(	O
(	O
net_hash_header_t	O
)	O
infp	int
)	O
->	O
table	O
[	O
i	int
]	O
;	O
if	O
(	O
*	O
head	int
==	O
0	int
)	O
continue	O
;	O
entp	int
=	O
*	O
head	int
;	O
do	O
{	O
nextentp	O
=	O
(	O
net_hash_entry_t	O
)	O
entp	int
->	O
he_next	O
;	O
if	O
(	O
entp	int
->	O
rcv_port	int
==	O
rcv_port	int
)	O
{	O
ret	int
=	O
hash_ent_remove	(*(int),int,int,*(int),int,*(int))->(int)
(	O
ifp	*(int)
,	O
(	O
net_hash_header_t	O
)	O
infp	int
,	O
(	O
my_infp	O
==	O
infp	int
)	O
,	O
head	int
,	O
entp	int
,	O
&	O
dead_entp	int
)	O
;	O
if	O
(	O
ret	int
)	O
goto	O
hash_loop_end	O
;	O
}	O
entp	int
=	O
nextentp	O
;	O
}	O
while	O
(	O
*	O
head	int
!=	O
0	int
&&	O
entp	int
!=	O
*	O
head	int
)	O
;	O
}	O
hash_loop_end	O
:	O
;	O
}	O
else	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
rcv_port	int
)	O
{	O
if	O
(	O
infp	int
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_IN	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
input	O
)	O
;	O
if	O
(	O
infp	int
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_OUT	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
output	O
)	O
;	O
ENQUEUE_DEAD	()->(int)
(	O
dead_infp	int
,	O
infp	int
,	O
input	O
)	O
;	O
}	O
}	O
FILTER_ITERATE_END	O
}	O
in	O
=	O
(	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_IN	O
)	O
!=	O
0	int
;	O
out	O
=	O
(	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_OUT	O
)	O
!=	O
0	int
;	O
if	O
(	O
in	O
)	O
check_filter_list	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
)	O
;	O
if	O
(	O
out	O
)	O
check_filter_list	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
)	O
;	O
if	O
(	O
my_infp	O
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
N_NET_HASH	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
filter_hash_header	struct
[	O
i	int
]	O
.	O
n_keys	int
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
N_NET_HASH	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
rcv_port	int
)	O
;	O
if	O
(	O
match	*(int)
!=	O
0	int
)	O
free	()->(int)
(	O
hash_entp	O
)	O
;	O
rval	O
=	O
D_NO_MEMORY	O
;	O
goto	O
clean_and_return	O
;	O
}	O
hhp	O
=	O
&	O
filter_hash_header	struct
[	O
i	int
]	O
;	O
hhp	O
->	O
n_keys	int
=	O
match	*(int)
->	O
jt	O
;	O
hhp	O
->	O
ref_count	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NET_HASH_SIZE	O
;	O
i	int
++	O
)	O
hhp	O
->	O
table	O
[	O
i	int
]	O
=	O
0	int
;	O
my_infp	O
=	O
(	O
net_rcv_port_t	O
)	O
hhp	O
;	O
my_infp	O
->	O
rcv_port	int
=	O
MACH_PORT_NULL	O
;	O
is_new_infp	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
is_new_infp	int
)	O
{	O
my_infp	O
->	O
priority	int
=	O
priority	int
;	O
my_infp	O
->	O
rcv_count	O
=	O
0	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
my_infp	O
->	O
filter	*(int)
,	O
filter	*(int)
,	O
filter_bytes	int
)	O
;	O
my_infp	O
->	O
filter_end	O
=	O
(	O
filter_t	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
my_infp	O
->	O
filter	*(int)
+	O
filter_bytes	int
)	O
;	O
if	O
(	O
in	O
)	O
{	O
queue_iterate	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
input	O
)	O
if	O
(	O
priority	int
>	O
infp	int
->	O
priority	int
)	O
break	O
;	O
queue_enter	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
,	O
my_infp	O
,	O
net_rcv_port_t	O
,	O
input	O
)	O
;	O
}	O
if	O
(	O
out	O
)	O
{	O
queue_iterate	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
output	O
)	O
if	O
(	O
priority	int
>	O
infp	int
->	O
priority	int
)	O
break	O
;	O
queue_enter	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
,	O
my_infp	O
,	O
net_rcv_port_t	O
,	O
output	O
)	O
;	O
}	O
}	O
if	O
(	O
match	*(int)
!=	O
0	int
)	O
{	O
net_hash_entry_t	O
*	O
p	*(char)
;	O
hash_entp	O
->	O
rcv_port	int
=	O
rcv_port	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
match	*(int)
->	O
jt	O
;	O
i	int
++	O
)	O
hash_entp	O
->	O
keys	*(int)
[	O
i	int
]	O
=	O
match	*(int)
[	O
i	int
+	O
1	int
]	O
.	O
k	int
;	O
p	*(char)
=	O
&	O
(	O
(	O
net_hash_header_t	O
)	O
my_infp	O
)	O
->	O
table	O
[	O
bpf_hash	(int,*(int))->(int)
(	O
match	*(int)
->	O
jt	O
,	O
hash_entp	O
->	O
keys	*(int)
)	O
]	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
{	O
queue_init	()->(int)
(	O
(	O
queue_t	O
)	O
hash_entp	O
)	O
;	O
*	O
p	*(char)
=	O
hash_entp	O
;	O
}	O
else	O
{	O
enqueue_tail	()->(int)
(	O
(	O
queue_t	O
)	O
*	O
p	*(char)
,	O
(	O
queue_entry_t	O
)	O
hash_entp	O
)	O
;	O
}	O
(	O
(	O
net_hash_header_t	O
)	O
my_infp	O
)	O
->	O
ref_count	O
++	O
;	O
}	O
clean_and_return	O
:	O
if	O
(	O
dead_infp	int
!=	O
0	int
)	O
net_free_dead_infp	(int)->(void)
(	O
dead_infp	int
)	O
;	O
if	O
(	O
dead_entp	int
!=	O
0	int
)	O
net_free_dead_entp	(int)->(void)
(	O
dead_entp	int
)	O
;	O
return	O
(	O
rval	O
)	O
;	O
}	O
void	O
destroy_filters	(*(int))->(void)
(	O
if_filter_list_t	O
*	O
ifp	*(int)
)	O
{	O
}	O
void	O
remove_dead_filter	(*(int),*(int),int)->(void)
(	O
if_filter_list_t	O
*	O
ifp	*(int)
,	O
queue_head_t	O
*	O
if_port_list	*(int)
,	O
mach_port_t	O
dead_port	int
)	O
{	O
net_rcv_port_t	O
infp	int
;	O
net_rcv_port_t	O
nextfp	O
;	O
net_hash_entry_t	O
*	O
head	int
,	O
nextentp	O
;	O
queue_entry_t	O
dead_infp	int
,	O
dead_entp	int
;	O
net_hash_entry_t	O
entp	int
=	O
NULL	O
;	O
int	O
i	int
,	O
ret	int
;	O
dead_infp	int
=	O
dead_entp	int
=	O
0	int
;	O
FILTER_ITERATE	()->(int)
(	O
if_port_list	*(int)
,	O
infp	int
,	O
nextfp	O
,	O
(	O
if_port_list	*(int)
==	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
)	O
?	O
&	O
infp	int
->	O
input	O
:	O
&	O
infp	int
->	O
output	O
)	O
{	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
MACH_PORT_NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NET_HASH_SIZE	O
;	O
i	int
++	O
)	O
{	O
head	int
=	O
&	O
(	O
(	O
net_hash_header_t	O
)	O
infp	int
)	O
->	O
table	O
[	O
i	int
]	O
;	O
if	O
(	O
*	O
head	int
==	O
0	int
)	O
continue	O
;	O
entp	int
=	O
*	O
head	int
;	O
do	O
{	O
nextentp	O
=	O
(	O
net_hash_entry_t	O
)	O
entp	int
->	O
he_next	O
;	O
if	O
(	O
entp	int
->	O
rcv_port	int
==	O
dead_port	int
)	O
{	O
ret	int
=	O
hash_ent_remove	(*(int),int,int,*(int),int,*(int))->(int)
(	O
ifp	*(int)
,	O
(	O
net_hash_header_t	O
)	O
infp	int
,	O
0	int
,	O
head	int
,	O
entp	int
,	O
&	O
dead_entp	int
)	O
;	O
if	O
(	O
ret	int
)	O
goto	O
hash_loop_end	O
;	O
}	O
entp	int
=	O
nextentp	O
;	O
}	O
while	O
(	O
*	O
head	int
!=	O
0	int
&&	O
entp	int
!=	O
*	O
head	int
)	O
;	O
}	O
hash_loop_end	O
:	O
;	O
}	O
else	O
if	O
(	O
infp	int
->	O
rcv_port	int
==	O
dead_port	int
)	O
{	O
if	O
(	O
infp	int
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_IN	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_rcv_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
input	O
)	O
;	O
if	O
(	O
infp	int
->	O
filter	*(int)
[	O
0	int
]	O
&	O
NETF_OUT	O
)	O
queue_remove	()->(int)
(	O
&	O
ifp	*(int)
->	O
if_snd_port_list	O
,	O
infp	int
,	O
net_rcv_port_t	O
,	O
output	O
)	O
;	O
ENQUEUE_DEAD	()->(int)
(	O
dead_infp	int
,	O
infp	int
,	O
input	O
)	O
;	O
}	O
}	O
FILTER_ITERATE_END	O
if	O
(	O
dead_infp	int
!=	O
0	int
)	O
net_free_dead_infp	(int)->(void)
(	O
dead_infp	int
)	O
;	O
if	O
(	O
dead_entp	int
!=	O
0	int
)	O
net_free_dead_entp	(int)->(void)
(	O
dead_entp	int
)	O
;	O
}	O
