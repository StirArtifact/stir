static	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
read_variable_name	(*(char),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
char	O
*	O
prompt	*(char)
,	O
WINDOW	struct(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,long,struct(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*(struct`),long,long))),long,long)
*	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
)	O
;	O
static	O
char	O
*	O
on_off_choices	array(*(char))
[	O
]	O
=	O
{	O
"Off"	*(char)
,	O
"On"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
mouse_choices	array(*(char))
[	O
]	O
=	O
{	O
"Off"	*(char)
,	O
"normal-tracking"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
follow_strategy_choices	array(*(char))
[	O
]	O
=	O
{	O
"remain"	*(char)
,	O
"path"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
nodeline_choices	array(*(char))
[	O
]	O
=	O
{	O
"no"	*(char)
,	O
"print"	*(char)
,	O
"pointers"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
info_scroll_choices	array(*(char))
[	O
]	O
=	O
{	O
"Continuous"	*(char)
,	O
"Next Only"	*(char)
,	O
"Page Only"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
scroll_last_node_choices	array(*(char))
[	O
]	O
=	O
{	O
"Stop"	*(char)
,	O
"Top"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
rendition_choices	array(*(char))
[	O
]	O
=	O
{	O
"black"	*(char)
,	O
"red"	*(char)
,	O
"green"	*(char)
,	O
"yellow"	*(char)
,	O
"blue"	*(char)
,	O
"magenta"	*(char)
,	O
"cyan"	*(char)
,	O
"white"	*(char)
,	O
"nocolour"	*(char)
,	O
"bgblack"	*(char)
,	O
"bgred"	*(char)
,	O
"bggreen"	*(char)
,	O
"bgyellow"	*(char)
,	O
"bgblue"	*(char)
,	O
"bgmagenta"	*(char)
,	O
"bgcyan"	*(char)
,	O
"bgwhite"	*(char)
,	O
"nobgcolour"	*(char)
,	O
"underline"	*(char)
,	O
"nounderline"	*(char)
,	O
"standout"	*(char)
,	O
"nostandout"	*(char)
,	O
"bold"	*(char)
,	O
"regular"	*(char)
,	O
"blink"	*(char)
,	O
"noblink"	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
*	O
highlight_searches	*(int)
;	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
]	O
=	O
{	O
{	O
"automatic-footnotes"	*(char)
,	O
N_	O
(	O
"When \"On\", footnotes appear and disappear automatically"	*(char)
)	O
,	O
&	O
auto_footnotes_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"automatic-tiling"	*(char)
,	O
N_	O
(	O
"When \"On\", creating or deleting a window resizes other windows"	*(char)
)	O
,	O
&	O
auto_tiling_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"visible-bell"	*(char)
,	O
N_	O
(	O
"When \"On\", flash the screen instead of ringing the bell"	*(char)
)	O
,	O
&	O
terminal_use_visible_bell_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"errors-ring-bell"	*(char)
,	O
N_	O
(	O
"When \"On\", errors cause the bell to ring"	*(char)
)	O
,	O
&	O
info_error_rings_bell_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"gc-compressed-files"	*(char)
,	O
N_	O
(	O
"When \"On\", Info garbage collects files which had to be uncompressed"	*(char)
)	O
,	O
&	O
gc_compressed_files	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"show-index-match"	*(char)
,	O
N_	O
(	O
"When \"On\", the portion of the matched search string is highlighted"	*(char)
)	O
,	O
&	O
show_index_match	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"scroll-behaviour"	*(char)
,	O
N_	O
(	O
"Controls what happens when scrolling is requested at the end of a node"	*(char)
)	O
,	O
&	O
info_scroll_behaviour	int
,	O
(	O
char	O
*	O
*	O
)	O
info_scroll_choices	array(*(char))
}	O
,	O
{	O
"scroll-behavior"	*(char)
,	O
N_	O
(	O
"Same as scroll-behaviour"	*(char)
)	O
,	O
&	O
info_scroll_behaviour	int
,	O
(	O
char	O
*	O
*	O
)	O
info_scroll_choices	array(*(char))
}	O
,	O
{	O
"scroll-step"	*(char)
,	O
N_	O
(	O
"The number lines to scroll when the cursor moves out of the window"	*(char)
)	O
,	O
&	O
window_scroll_step	int
,	O
NULL	O
}	O
,	O
{	O
"cursor-movement-scrolls"	*(char)
,	O
N_	O
(	O
"Controls whether scroll-behavior affects cursor movement commands"	*(char)
)	O
,	O
&	O
cursor_movement_scrolls_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"ISO-Latin"	*(char)
,	O
N_	O
(	O
"When \"On\", Info accepts and displays ISO Latin characters"	*(char)
)	O
,	O
&	O
ISO_Latin_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"scroll-last-node"	*(char)
,	O
N_	O
(	O
"What to do when a scrolling command is issued at the end of the "	*(char)
"last node"	*(char)
)	O
,	O
&	O
scroll_last_node	int
,	O
(	O
char	O
*	O
*	O
)	O
scroll_last_node_choices	array(*(char))
}	O
,	O
{	O
"min-search-length"	*(char)
,	O
N_	O
(	O
"Minimal length of a search string"	*(char)
)	O
,	O
&	O
min_search_length	int
,	O
NULL	O
}	O
,	O
{	O
"search-skip-screen"	*(char)
,	O
N_	O
(	O
"Skip current window when searching"	*(char)
)	O
,	O
&	O
search_skip_screen_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"infopath-no-defaults"	*(char)
,	O
N_	O
(	O
"Exclude default directories from file search path"	*(char)
)	O
,	O
&	O
infopath_no_defaults_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"hide-note-references"	*(char)
,	O
N_	O
(	O
"Hide some Info file syntax in the text of nodes"	*(char)
)	O
,	O
&	O
preprocess_nodes_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"key-time"	*(char)
,	O
N_	O
(	O
"Length of time in milliseconds to wait for the next byte in a sequence indicating that a key has been pressed"	*(char)
)	O
,	O
&	O
key_time	int
,	O
NULL	O
}	O
,	O
{	O
"mouse"	*(char)
,	O
N_	O
(	O
"Method to use to track mouse events"	*(char)
)	O
,	O
&	O
mouse_protocol	int
,	O
(	O
char	O
*	O
*	O
)	O
mouse_choices	array(*(char))
}	O
,	O
{	O
"follow-strategy"	*(char)
,	O
N_	O
(	O
"How to follow a cross-reference"	*(char)
)	O
,	O
&	O
follow_strategy	int
,	O
(	O
char	O
*	O
*	O
)	O
follow_strategy_choices	array(*(char))
}	O
,	O
{	O
"highlight-searches"	*(char)
,	O
N_	O
(	O
"Highlight search matches"	*(char)
)	O
,	O
&	O
highlight_searches	*(int)
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array(*(char))
}	O
,	O
{	O
"link-style"	*(char)
,	O
N_	O
(	O
"Styles for links"	*(char)
)	O
,	O
&	O
ref_rendition	struct(long,long)
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array(*(char))
}	O
,	O
{	O
"active-link-style"	*(char)
,	O
N_	O
(	O
"Styles for active links"	*(char)
)	O
,	O
&	O
hl_ref_rendition	struct(long,long)
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array(*(char))
}	O
,	O
{	O
"match-style"	*(char)
,	O
N_	O
(	O
"Styles for search matches"	*(char)
)	O
,	O
&	O
match_rendition	struct(long,long)
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array(*(char))
}	O
,	O
{	O
"nodeline"	*(char)
,	O
N_	O
(	O
"How to print the information line at the start of a node"	*(char)
)	O
,	O
&	O
nodeline_print	int
,	O
(	O
char	O
*	O
*	O
)	O
nodeline_choices	array(*(char))
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
rendition_to_string	(*(struct(long,long)))->(*(char))
(	O
RENDITION	struct(long,long)
*	O
rendition	*(struct(long,long))
)	O
{	O
static	O
char	O
string	*(char)
[	O
8	int
+	O
1	int
+	O
10	int
+	O
1	int
+	O
11	int
+	O
1	int
+	O
10	int
+	O
1	int
+	O
7	int
+	O
1	int
+	O
7	int
+	O
1	int
]	O
;	O
unsigned	O
long	O
style	int
;	O
static	O
const	O
char	O
*	O
fg	array(*(char))
[	O
]	O
=	O
{	O
"black"	*(char)
,	O
"red"	*(char)
,	O
"green"	*(char)
,	O
"yellow"	*(char)
,	O
"blue"	*(char)
,	O
"magenta"	*(char)
,	O
"cyan"	*(char)
,	O
"white"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
bg	array(*(char))
[	O
]	O
=	O
{	O
"bgblack"	*(char)
,	O
"bgred"	*(char)
,	O
"bggreen"	*(char)
,	O
"bgyellow"	*(char)
,	O
"bgblue"	*(char)
,	O
"bgmagenta"	*(char)
,	O
"bgcyan"	*(char)
,	O
"bgwhite"	*(char)
}	O
;	O
*	O
string	*(char)
=	O
'\0'	O
;	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
BLINK_MASK	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
BLINK_MASK	int
?	O
"blink"	*(char)
:	O
"noblink"	*(char)
)	O
;	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
BOLD_MASK	int
)	O
{	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
","	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
BOLD_MASK	int
?	O
"bold"	*(char)
:	O
"nobold"	*(char)
)	O
;	O
}	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
STANDOUT_MASK	int
)	O
{	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
","	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
STANDOUT_MASK	int
?	O
"standout"	*(char)
:	O
"nostandout"	*(char)
)	O
;	O
}	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
UNDERLINE_MASK	int
)	O
{	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
","	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
UNDERLINE_MASK	int
?	O
"underline"	*(char)
:	O
"nounderline"	*(char)
)	O
;	O
}	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
COLOUR_MASK	int
)	O
{	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
","	*(char)
)	O
;	O
style	int
=	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
COLOUR_MASK	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
style	int
>=	O
8	int
?	O
fg	array(*(char))
[	O
style	int
-	O
8	int
]	O
:	O
"nocolour"	*(char)
)	O
;	O
}	O
if	O
(	O
rendition	*(struct(long,long))
->	O
mask	long
&	O
BGCOLOUR_MASK	int
)	O
{	O
if	O
(	O
*	O
string	*(char)
!=	O
'\0'	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
","	*(char)
)	O
;	O
style	int
=	O
(	O
rendition	*(struct(long,long))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
style	int
>=	O
8	int
?	O
bg	array(*(char))
[	O
style	int
-	O
8	int
]	O
:	O
"nobgcolour"	*(char)
)	O
;	O
}	O
return	O
string	*(char)
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
describe_variable	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
,	O
_	O
(	O
"Explain the use of a variable"	*(char)
)	O
)	O
{	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
;	O
char	O
*	O
description	*(char)
;	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
=	O
read_variable_name	(*(char),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
_	O
(	O
"Describe variable: "	*(char)
)	O
,	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
)	O
;	O
if	O
(	O
!	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
)	O
return	O
;	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
)	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
description	*(char)
,	O
"%s (%s): %s."	*(char)
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
name	*(char)
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
==	O
&	O
highlight_searches	*(int)
?	O
on_off_choices	array(*(char))
[	O
match_rendition	struct(long,long)
.	O
mask	long
!=	O
0	int
]	O
:	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array(*(char))
?	O
rendition_to_string	(*(struct(long,long)))->(*(char))
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
:	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
*	O
(	O
int	O
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
]	O
,	O
_	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
doc	*(char)
)	O
)	O
;	O
else	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
description	*(char)
,	O
"%s (%d): %s."	*(char)
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
name	*(char)
,	O
*	O
(	O
int	O
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
,	O
_	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
doc	*(char)
)	O
)	O
;	O
window_message_in_echo_area	(*(char))->(void)
(	O
"%s"	*(char)
,	O
description	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
description	*(char)
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
set_variable	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
,	O
_	O
(	O
"Set the value of an Info variable"	*(char)
)	O
)	O
{	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
;	O
char	O
*	O
line	*(char)
;	O
char	O
prompt	*(char)
[	O
100	int
]	O
;	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
=	O
read_variable_name	(*(char),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
_	O
(	O
"Set variable: "	*(char)
)	O
,	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
)	O
;	O
if	O
(	O
!	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
)	O
return	O
;	O
if	O
(	O
!	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
)	O
{	O
int	O
potential_value	int
;	O
if	O
(	O
info_explicit_arg	int
||	O
count	*(int)
!=	O
1	int
)	O
potential_value	int
=	O
count	*(int)
;	O
else	O
potential_value	int
=	O
*	O
(	O
int	O
*	O
)	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
prompt	*(char)
,	O
_	O
(	O
"Set %s to value (%d): "	*(char)
)	O
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
name	*(char)
,	O
potential_value	int
)	O
;	O
line	*(char)
=	O
info_read_in_echo_area	(*(char))->(*(char))
(	O
prompt	*(char)
)	O
;	O
if	O
(	O
!	O
line	*(char)
)	O
return	O
;	O
canonicalize_whitespace	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
set_variable_to_value	(*(struct(*(char),*(char),*(void),*(*(char)),int)),*(char),int)->(int)
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
,	O
line	*(char)
,	O
SET_IN_SESSION	int
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
else	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
NULL	O
;	O
size_t	long
array_index	long
=	O
0	int
;	O
size_t	long
array_slots	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
)	O
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
i	int
]	O
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
NULL	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
NULL	O
;	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
array_index	long
,	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
array_slots	long
,	O
10	int
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
prompt	*(char)
,	O
_	O
(	O
"Set %s to value (%s): "	*(char)
)	O
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
name	*(char)
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
==	O
&	O
highlight_searches	*(int)
?	O
on_off_choices	array(*(char))
[	O
match_rendition	struct(long,long)
.	O
mask	long
!=	O
0	int
]	O
:	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array(*(char))
?	O
rendition_to_string	(*(struct(long,long)))->(*(char))
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
:	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
*	O
(	O
int	O
*	O
)	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
]	O
)	O
;	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array(*(char))
)	O
line	*(char)
=	O
info_read_maybe_completing	(*(char),*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(*(char))
(	O
prompt	*(char)
,	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
else	O
line	*(char)
=	O
info_read_completing_in_echo_area	(*(char),*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(*(char))
(	O
prompt	*(char)
,	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
info_free_references	(*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(void)
(	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
if	O
(	O
!	O
line	*(char)
)	O
{	O
info_abort_key	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
(	O
active_window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
line	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
return	O
;	O
}	O
set_variable_to_value	(*(struct(*(char),*(char),*(void),*(*(char)),int)),*(char),int)->(int)
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
,	O
line	*(char)
,	O
SET_IN_SESSION	int
)	O
;	O
}	O
}	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
variable_by_name	(*(char))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
.	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
return	O
NULL	O
;	O
else	O
return	O
&	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
;	O
}	O
static	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
read_variable_name	(*(char),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
char	O
*	O
prompt	*(char)
,	O
WINDOW	struct(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),long,long,struct(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*(struct`),long,long))),long,long)
*	O
window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
)	O
{	O
char	O
*	O
line	*(char)
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
variables	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
variables	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
make_variable_completions_array	()->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
)	O
;	O
line	*(char)
=	O
info_read_completing_in_echo_area	(*(char),*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(*(char))
(	O
prompt	*(char)
,	O
variables	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
info_free_references	(*(*(struct(*(char),*(char),*(char),int,int,long,int))))->(void)
(	O
variables	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
;	O
if	O
(	O
!	O
line	*(char)
)	O
{	O
info_abort_key	(*(struct(*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),*(struct(*`,*`,long,long,long,long,*`,long,long,struct`,*`,*`,*`,long,long,int,*`,int,struct`,*`,long,long)),long,long,long,long,*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,struct(*(struct`),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct`),long,long,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),*(char),long),*(*(struct`)),long,long)),int)->(void)
(	O
active_window	*(struct(*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),*(struct(*(struct`),*(struct`),long,long,long,long,*(struct`),long,long,struct(*`,long,long,long,*`),*(char),*(long),*(long),long,long,int,*(char),int,struct(*`,long,long,int,struct`,*`,long),*(*`),long,long)),long,long,long,long,*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int)),long,long,struct(*(struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)),long,long,long,*(long)),*(char),*(long),*(long),long,long,int,*(char),int,struct(*(struct(long,long)),long,long,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char),long),*(*(struct(*`,long,long))),long,long))
,	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
*	O
line	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
variable_by_name	(*(char))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
line	*(char)
)	O
;	O
}	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
make_variable_completions_array	()->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
void	O
)	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
NULL	O
;	O
size_t	long
array_index	long
=	O
0	int
,	O
array_slots	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
)	O
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
info_variables	array(struct(*(char),*(char),*(void),*(*(char)),int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
NULL	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
NULL	O
;	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
array_index	long
,	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
array_slots	long
,	O
200	int
)	O
;	O
}	O
return	O
array	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
}	O
int	O
set_variable_to_value	(*(struct(*(char),*(char),*(void),*(*(char)),int)),*(char),int)->(int)
(	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
,	O
char	O
*	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
,	O
int	O
where	int
)	O
{	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
where_set	int
>	O
where	int
)	O
return	O
1	int
;	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
)	O
{	O
register	O
int	O
j	int
;	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
==	O
&	O
highlight_searches	*(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
on_off_choices	array(*(char))
[	O
0	int
]	O
,	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
==	O
0	int
)	O
{	O
match_rendition	struct(long,long)
.	O
mask	long
=	O
0	int
;	O
match_rendition	struct(long,long)
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
=	O
0	int
;	O
}	O
else	O
{	O
match_rendition	struct(long,long)
.	O
mask	long
=	O
STANDOUT_MASK	int
;	O
match_rendition	struct(long,long)
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
=	O
STANDOUT_MASK	int
;	O
}	O
}	O
else	O
if	O
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
!=	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array(*(char))
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
j	int
]	O
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
choices	*(*(char))
[	O
j	int
]	O
,	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
==	O
0	int
)	O
{	O
*	O
(	O
int	O
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
=	O
j	int
;	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
where_set	int
=	O
where	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
static	O
struct	O
{	O
unsigned	O
long	O
mask	long
;	O
unsigned	O
long	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
;	O
char	O
*	O
name	*(char)
;	O
}	O
styles	array(struct(long,long,*(char)))
[	O
]	O
=	O
{	O
COLOUR_MASK	int
,	O
COLOUR_BLACK	O
,	O
"black"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_RED	O
,	O
"red"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_GREEN	O
,	O
"green"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_YELLOW	O
,	O
"yellow"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_BLUE	O
,	O
"blue"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_MAGENTA	O
,	O
"magenta"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_CYAN	O
,	O
"cyan"	*(char)
,	O
COLOUR_MASK	int
,	O
COLOUR_WHITE	O
,	O
"white"	*(char)
,	O
COLOUR_MASK	int
,	O
0	int
,	O
"nocolour"	*(char)
,	O
COLOUR_MASK	int
,	O
0	int
,	O
"nocolor"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_BLACK	O
,	O
"bgblack"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_RED	O
,	O
"bgred"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_GREEN	O
,	O
"bggreen"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_YELLOW	O
,	O
"bgyellow"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_BLUE	O
,	O
"bgblue"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_MAGENTA	O
,	O
"bgmagenta"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_CYAN	O
,	O
"bgcyan"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_WHITE	O
,	O
"bgwhite"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
0	int
,	O
"nobgcolour"	*(char)
,	O
BGCOLOUR_MASK	int
,	O
0	int
,	O
"nobgcolor"	*(char)
,	O
UNDERLINE_MASK	int
,	O
UNDERLINE_MASK	int
,	O
"underline"	*(char)
,	O
UNDERLINE_MASK	int
,	O
0	int
,	O
"nounderline"	*(char)
,	O
STANDOUT_MASK	int
,	O
STANDOUT_MASK	int
,	O
"standout"	*(char)
,	O
STANDOUT_MASK	int
,	O
0	int
,	O
"nostandout"	*(char)
,	O
BOLD_MASK	int
,	O
BOLD_MASK	int
,	O
"bold"	*(char)
,	O
BOLD_MASK	int
,	O
0	int
,	O
"regular"	*(char)
,	O
BOLD_MASK	int
,	O
0	int
,	O
"nobold"	*(char)
,	O
BLINK_MASK	int
,	O
BLINK_MASK	int
,	O
"blink"	*(char)
,	O
BLINK_MASK	int
,	O
0	int
,	O
"noblink"	*(char)
,	O
}	O
;	O
int	O
i	int
;	O
char	O
*	O
component	*(char)
;	O
unsigned	O
long	O
rendition_mask	long
=	O
0	int
;	O
unsigned	O
long	O
rendition_value	long
=	O
0	int
;	O
component	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
,	O
","	*(char)
)	O
;	O
while	O
(	O
component	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
,	O
component	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
{	O
rendition_mask	long
|=	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
mask	long
;	O
rendition_value	long
&=	O
~	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
mask	long
;	O
rendition_value	long
|=	O
styles	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
;	O
}	O
component	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
0	int
,	O
","	*(char)
)	O
;	O
}	O
(	O
(	O
RENDITION	struct(long,long)
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
->	O
mask	long
=	O
rendition_mask	long
;	O
(	O
(	O
RENDITION	struct(long,long)
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
)	O
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
=	O
rendition_value	long
;	O
}	O
return	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
long	O
n	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
&&	O
INT_MIN	O
<=	O
n	long
&&	O
n	long
<=	O
INT_MAX	O
)	O
{	O
*	O
(	O
int	O
*	O
)	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
->	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
=	O
n	long
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
