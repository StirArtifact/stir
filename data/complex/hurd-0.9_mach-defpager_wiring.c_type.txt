mach_port_t	O
this_task	int
;	O
mach_port_t	O
priv_host_port	int
=	O
MACH_PORT_NULL	O
;	O
void	O
wire_setup	O
(	O
host_priv	O
)	O
mach_port_t	O
host_priv	O
;	O
{	O
priv_host_port	int
=	O
host_priv	O
;	O
this_task	int
=	O
mach_task_self	O
(	O
)	O
;	O
}	O
void	O
wire_memory	()->(int)
(	O
start	O
,	O
size	int
,	O
prot	int
)	O
vm_address_t	O
start	O
;	O
vm_size_t	O
size	int
;	O
vm_prot_t	O
prot	int
;	O
{	O
kern_return_t	O
kr	O
;	O
if	O
(	O
priv_host_port	int
==	O
MACH_PORT_NULL	O
)	O
return	O
;	O
kr	O
=	O
vm_wire	O
(	O
priv_host_port	int
,	O
this_task	int
,	O
start	O
,	O
size	int
,	O
prot	int
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"mem_wire: %d"	*(char)
,	O
kr	O
)	O
;	O
}	O
void	O
wire_thread	()->(void)
(	O
)	O
{	O
kern_return_t	O
kr	O
;	O
if	O
(	O
priv_host_port	int
==	O
MACH_PORT_NULL	O
)	O
return	O
;	O
kr	O
=	O
thread_wire	()->(int)
(	O
priv_host_port	int
,	O
mach_thread_self	()->(int)
(	O
)	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
panic	()->(int)
(	O
"wire_thread: %d"	*(char)
,	O
kr	O
)	O
;	O
}	O
void	O
wire_all_memory	()->(void)
(	O
)	O
{	O
kern_return_t	O
kr	O
;	O
vm_offset_t	O
address	*(int)
;	O
vm_size_t	O
size	int
;	O
vm_prot_t	O
protection	O
;	O
vm_prot_t	O
max_protection	O
;	O
vm_inherit_t	O
inheritance	O
;	O
boolean_t	O
is_shared	O
;	O
memory_object_name_t	O
object	O
;	O
vm_offset_t	O
offset	O
;	O
if	O
(	O
priv_host_port	int
==	O
MACH_PORT_NULL	O
)	O
return	O
;	O
address	*(int)
=	O
0	int
;	O
while	O
(	O
(	O
kr	O
=	O
vm_region	()->(int)
(	O
this_task	int
,	O
&	O
address	*(int)
,	O
&	O
size	int
,	O
&	O
protection	O
,	O
&	O
max_protection	O
,	O
&	O
inheritance	O
,	O
&	O
is_shared	O
,	O
&	O
object	O
,	O
&	O
offset	O
)	O
)	O
==	O
KERN_SUCCESS	O
)	O
{	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
object	O
)	O
)	O
(	O
void	O
)	O
mach_port_deallocate	()->(int)
(	O
this_task	int
,	O
object	O
)	O
;	O
if	O
(	O
protection	O
!=	O
VM_PROT_NONE	O
)	O
{	O
void	O
*	O
page	*(void)
;	O
if	O
(	O
!	O
(	O
protection	O
&	O
VM_PROT_WRITE	O
)	O
)	O
{	O
kr	O
=	O
vm_protect	()->(int)
(	O
this_task	int
,	O
address	*(int)
,	O
size	int
,	O
0	int
,	O
max_protection	O
)	O
;	O
}	O
for	O
(	O
page	*(void)
=	O
(	O
void	O
*	O
)	O
address	*(int)
;	O
page	*(void)
<	O
(	O
void	O
*	O
)	O
(	O
address	*(int)
+	O
size	int
)	O
;	O
page	*(void)
+=	O
vm_page_size	O
)	O
*	O
(	O
volatile	O
int	O
*	O
)	O
page	*(void)
=	O
*	O
(	O
int	O
*	O
)	O
page	*(void)
;	O
wire_memory	()->(int)
(	O
address	*(int)
,	O
size	int
,	O
protection	O
)	O
;	O
if	O
(	O
!	O
(	O
protection	O
&	O
VM_PROT_WRITE	O
)	O
)	O
{	O
kr	O
=	O
vm_protect	()->(int)
(	O
this_task	int
,	O
address	*(int)
,	O
size	int
,	O
0	int
,	O
protection	O
)	O
;	O
}	O
}	O
address	*(int)
+=	O
size	int
;	O
}	O
}	O
kern_return_t	O
vm_allocate	O
(	O
task	O
,	O
address	*(int)
,	O
size	int
,	O
anywhere	int
)	O
task_t	O
task	O
;	O
vm_address_t	O
*	O
address	*(int)
;	O
vm_size_t	O
size	int
;	O
boolean_t	O
anywhere	int
;	O
{	O
kern_return_t	O
kr	O
;	O
if	O
(	O
anywhere	int
)	O
*	O
address	*(int)
=	O
VM_MIN_ADDRESS	O
;	O
kr	O
=	O
vm_map	O
(	O
task	O
,	O
address	*(int)
,	O
size	int
,	O
(	O
vm_offset_t	O
)	O
0	int
,	O
anywhere	int
,	O
MEMORY_OBJECT_NULL	O
,	O
(	O
vm_offset_t	O
)	O
0	int
,	O
FALSE	O
,	O
VM_PROT_DEFAULT	O
,	O
VM_PROT_ALL	O
,	O
VM_INHERIT_DEFAULT	O
)	O
;	O
if	O
(	O
kr	O
!=	O
KERN_SUCCESS	O
)	O
return	O
kr	O
;	O
if	O
(	O
task	O
==	O
this_task	int
)	O
(	O
void	O
)	O
vm_wire	O
(	O
priv_host_port	int
,	O
task	O
,	O
*	O
address	*(int)
,	O
size	int
,	O
VM_PROT_DEFAULT	O
)	O
;	O
return	O
KERN_SUCCESS	O
;	O
}	O
kern_return_t	O
__vm_allocate	O
(	O
task	O
,	O
address	*(int)
,	O
size	int
,	O
anywhere	int
)	O
task_t	O
task	O
;	O
vm_address_t	O
*	O
address	*(int)
;	O
vm_size_t	O
size	int
;	O
boolean_t	O
anywhere	int
;	O
{	O
return	O
vm_allocate	O
(	O
task	O
,	O
address	*(int)
,	O
size	int
,	O
anywhere	int
)	O
;	O
}	O
