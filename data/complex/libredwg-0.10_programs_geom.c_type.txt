void	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
BITCODE_3DPOINT	struct(double,double,double)
*	O
out	*(struct(double,double,double))
,	O
BITCODE_3DPOINT	struct(double,double,double)
pt	array(double)
)	O
{	O
double	O
l	double
=	O
sqrt	(double)->(double)
(	O
(	O
pt	array(double)
.	O
x	double
*	O
pt	array(double)
.	O
x	double
)	O
+	O
(	O
pt	array(double)
.	O
y	double
*	O
pt	array(double)
.	O
y	double
)	O
+	O
(	O
pt	array(double)
.	O
z	double
*	O
pt	array(double)
.	O
z	double
)	O
)	O
;	O
*	O
out	*(struct(double,double,double))
=	O
pt	array(double)
;	O
if	O
(	O
l	double
!=	O
1.0	int
&&	O
l	double
!=	O
0.0	int
)	O
{	O
out	*(struct(double,double,double))
->	O
x	double
=	O
pt	array(double)
.	O
x	double
/	O
l	double
;	O
out	*(struct(double,double,double))
->	O
y	double
=	O
pt	array(double)
.	O
y	double
/	O
l	double
;	O
out	*(struct(double,double,double))
->	O
z	double
=	O
pt	array(double)
.	O
z	double
/	O
l	double
;	O
}	O
}	O
void	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
BITCODE_3DPOINT	struct(double,double,double)
*	O
out	*(struct(double,double,double))
,	O
BITCODE_3DPOINT	struct(double,double,double)
pt1	struct(double,double,double)
,	O
BITCODE_3DPOINT	struct(double,double,double)
pt2	struct(double,double,double)
)	O
{	O
out	*(struct(double,double,double))
->	O
x	double
=	O
pt1	struct(double,double,double)
.	O
y	double
*	O
pt2	struct(double,double,double)
.	O
z	double
-	O
pt1	struct(double,double,double)
.	O
z	double
*	O
pt2	struct(double,double,double)
.	O
y	double
;	O
out	*(struct(double,double,double))
->	O
y	double
=	O
pt1	struct(double,double,double)
.	O
z	double
*	O
pt2	struct(double,double,double)
.	O
x	double
-	O
pt1	struct(double,double,double)
.	O
x	double
*	O
pt2	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(double,double,double))
->	O
z	double
=	O
pt1	struct(double,double,double)
.	O
x	double
*	O
pt2	struct(double,double,double)
.	O
y	double
-	O
pt1	struct(double,double,double)
.	O
y	double
*	O
pt2	struct(double,double,double)
.	O
x	double
;	O
}	O
void	O
transform_OCS_2d	(*(struct(double,double)),struct(double,double),struct(double,double,double))->(void)
(	O
BITCODE_2DPOINT	struct(double,double)
*	O
out	*(struct(double,double,double))
,	O
BITCODE_2DPOINT	struct(double,double)
pt	array(double)
,	O
BITCODE_BE	struct(double,double,double)
ext	struct(double,double,double)
)	O
{	O
if	O
(	O
ext	struct(double,double,double)
.	O
x	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
y	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
z	double
==	O
1.0	int
)	O
{	O
*	O
out	*(struct(double,double,double))
=	O
pt	array(double)
;	O
}	O
else	O
if	O
(	O
ext	struct(double,double,double)
.	O
x	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
y	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
z	double
==	O
-	O
1.0	int
)	O
{	O
*	O
out	*(struct(double,double,double))
=	O
pt	array(double)
;	O
out	*(struct(double,double,double))
->	O
x	double
=	O
-	O
out	*(struct(double,double,double))
->	O
x	double
;	O
}	O
else	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
ax	struct(double,double,double)
,	O
ay	struct(double,double,double)
,	O
az	struct(double,double,double)
,	O
be	struct(double,double,double)
;	O
be	struct(double,double,double)
=	O
(	O
BITCODE_3DPOINT	struct(double,double,double)
)	O
ext	struct(double,double,double)
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
az	struct(double,double,double)
,	O
be	struct(double,double,double)
)	O
;	O
if	O
(	O
(	O
fabs	(double)->(double)
(	O
az	struct(double,double,double)
.	O
x	double
)	O
<	O
1	int
/	O
64.0	int
)	O
&&	O
(	O
fabs	(double)->(double)
(	O
az	struct(double,double,double)
.	O
y	double
)	O
<	O
1	int
/	O
64.0	int
)	O
)	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
tmp	struct(double,double,double)
=	O
{	O
0.0	int
,	O
1.0	int
,	O
0.0	int
}	O
;	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
tmp	struct(double,double,double)
,	O
tmp	struct(double,double,double)
,	O
az	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ax	struct(double,double,double)
,	O
tmp	struct(double,double,double)
)	O
;	O
}	O
else	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
tmp	struct(double,double,double)
=	O
{	O
0.0	int
,	O
0.0	int
,	O
1.0	int
}	O
;	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
tmp	struct(double,double,double)
,	O
tmp	struct(double,double,double)
,	O
az	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ax	struct(double,double,double)
,	O
tmp	struct(double,double,double)
)	O
;	O
}	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
ay	struct(double,double,double)
,	O
az	struct(double,double,double)
,	O
ax	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ay	struct(double,double,double)
,	O
ay	struct(double,double,double)
)	O
;	O
out	*(struct(double,double,double))
->	O
x	double
=	O
pt	array(double)
.	O
x	double
*	O
ax	struct(double,double,double)
.	O
x	double
+	O
pt	array(double)
.	O
y	double
*	O
ax	struct(double,double,double)
.	O
y	double
;	O
out	*(struct(double,double,double))
->	O
y	double
=	O
pt	array(double)
.	O
x	double
*	O
ay	struct(double,double,double)
.	O
x	double
+	O
pt	array(double)
.	O
y	double
*	O
ay	struct(double,double,double)
.	O
y	double
;	O
}	O
return	O
;	O
}	O
void	O
transform_OCS	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
BITCODE_3DPOINT	struct(double,double,double)
*	O
out	*(struct(double,double,double))
,	O
BITCODE_3DPOINT	struct(double,double,double)
pt	array(double)
,	O
BITCODE_BE	struct(double,double,double)
ext	struct(double,double,double)
)	O
{	O
if	O
(	O
ext	struct(double,double,double)
.	O
x	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
y	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
z	double
==	O
1.0	int
)	O
{	O
*	O
out	*(struct(double,double,double))
=	O
pt	array(double)
;	O
}	O
else	O
if	O
(	O
ext	struct(double,double,double)
.	O
x	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
y	double
==	O
0.0	int
&&	O
ext	struct(double,double,double)
.	O
z	double
==	O
-	O
1.0	int
)	O
{	O
*	O
out	*(struct(double,double,double))
=	O
pt	array(double)
;	O
out	*(struct(double,double,double))
->	O
x	double
=	O
-	O
out	*(struct(double,double,double))
->	O
x	double
;	O
}	O
else	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
ax	struct(double,double,double)
,	O
ay	struct(double,double,double)
,	O
az	struct(double,double,double)
,	O
be	struct(double,double,double)
;	O
be	struct(double,double,double)
=	O
(	O
BITCODE_3DPOINT	struct(double,double,double)
)	O
ext	struct(double,double,double)
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
az	struct(double,double,double)
,	O
be	struct(double,double,double)
)	O
;	O
if	O
(	O
(	O
fabs	(double)->(double)
(	O
az	struct(double,double,double)
.	O
x	double
)	O
<	O
1	int
/	O
64.0	int
)	O
&&	O
(	O
fabs	(double)->(double)
(	O
az	struct(double,double,double)
.	O
y	double
)	O
<	O
1	int
/	O
64.0	int
)	O
)	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
tmp	struct(double,double,double)
=	O
{	O
0.0	int
,	O
1.0	int
,	O
0.0	int
}	O
;	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
tmp	struct(double,double,double)
,	O
tmp	struct(double,double,double)
,	O
az	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ax	struct(double,double,double)
,	O
tmp	struct(double,double,double)
)	O
;	O
}	O
else	O
{	O
BITCODE_3DPOINT	struct(double,double,double)
tmp	struct(double,double,double)
=	O
{	O
0.0	int
,	O
0.0	int
,	O
1.0	int
}	O
;	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
tmp	struct(double,double,double)
,	O
tmp	struct(double,double,double)
,	O
az	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ax	struct(double,double,double)
,	O
tmp	struct(double,double,double)
)	O
;	O
}	O
cross	(*(struct(double,double,double)),struct(double,double,double),struct(double,double,double))->(void)
(	O
&	O
ay	struct(double,double,double)
,	O
az	struct(double,double,double)
,	O
ax	struct(double,double,double)
)	O
;	O
normalize	(*(struct(double,double,double)),struct(double,double,double))->(void)
(	O
&	O
ay	struct(double,double,double)
,	O
ay	struct(double,double,double)
)	O
;	O
out	*(struct(double,double,double))
->	O
x	double
=	O
pt	array(double)
.	O
x	double
*	O
ax	struct(double,double,double)
.	O
x	double
+	O
pt	array(double)
.	O
y	double
*	O
ax	struct(double,double,double)
.	O
y	double
+	O
pt	array(double)
.	O
z	double
*	O
ax	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(double,double,double))
->	O
y	double
=	O
pt	array(double)
.	O
x	double
*	O
ay	struct(double,double,double)
.	O
x	double
+	O
pt	array(double)
.	O
y	double
*	O
ay	struct(double,double,double)
.	O
y	double
+	O
pt	array(double)
.	O
z	double
*	O
ay	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(double,double,double))
->	O
z	double
=	O
pt	array(double)
.	O
x	double
*	O
az	struct(double,double,double)
.	O
x	double
+	O
pt	array(double)
.	O
y	double
*	O
az	struct(double,double,double)
.	O
y	double
+	O
pt	array(double)
.	O
z	double
*	O
az	struct(double,double,double)
.	O
z	double
;	O
}	O
return	O
;	O
}	O
