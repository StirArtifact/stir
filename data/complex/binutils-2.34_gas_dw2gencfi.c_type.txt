struct	O
dwcfi_seg_list	O
{	O
segT	O
seg	O
;	O
int	O
subseg	O
;	O
char	O
*	O
seg_name	O
;	O
}	O
;	O
static	O
bfd_boolean	int
compact_eh	O
;	O
static	O
struct	O
hash_control	O
*	O
dwcfi_hash	O
;	O
static	O
inline	O
void	O
out_one	O
(	O
int	O
byte	O
)	O
{	O
FRAG_APPEND_1_CHAR	O
(	O
byte	O
)	O
;	O
}	O
static	O
inline	O
void	O
out_two	O
(	O
int	O
data	*(void)
)	O
{	O
md_number_to_chars	O
(	O
frag_more	O
(	O
2	int
)	O
,	O
data	*(void)
,	O
2	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_four	O
(	O
int	O
data	*(void)
)	O
{	O
md_number_to_chars	O
(	O
frag_more	O
(	O
4	int
)	O
,	O
data	*(void)
,	O
4	int
)	O
;	O
}	O
static	O
void	O
out_uleb128	O
(	O
addressT	O
value	long
)	O
{	O
output_leb128	O
(	O
frag_more	O
(	O
sizeof_leb128	O
(	O
value	long
,	O
0	int
)	O
)	O
,	O
value	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
out_sleb128	O
(	O
offsetT	O
value	long
)	O
{	O
output_leb128	O
(	O
frag_more	O
(	O
sizeof_leb128	O
(	O
value	long
,	O
1	int
)	O
)	O
,	O
value	long
,	O
1	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
encoding_size	O
(	O
unsigned	O
char	O
encoding	O
)	O
{	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
return	O
0	int
;	O
switch	O
(	O
encoding	O
&	O
0x7	int
)	O
{	O
case	O
0	int
:	O
return	O
bfd_get_arch_size	(*(struct(*(char),*(struct),*(void),*(struct),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),long,long,struct(*(*`),*((*`,*`,*`)->(*`)),*(void),int,int,int,int),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,long,*(*(struct`)),int,int,*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*`,*`,int,int,*`,*`,*`,*`,int)),*(void),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(void)),*(void),*(void),*(struct(long,array(char))))))->(int)
(	O
stdoutput	O
)	O
==	O
64	int
?	O
8	int
:	O
4	int
;	O
case	O
DW_EH_PE_udata2	O
:	O
return	O
2	int
;	O
case	O
DW_EH_PE_udata4	O
:	O
return	O
4	int
;	O
case	O
DW_EH_PE_udata8	O
:	O
return	O
8	int
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
emit_expr_encoded	O
(	O
expressionS	O
*	O
exp	O
,	O
int	O
encoding	O
,	O
bfd_boolean	int
emit_encoding	O
)	O
{	O
unsigned	O
int	O
size	int
=	O
encoding_size	O
(	O
encoding	O
)	O
;	O
bfd_reloc_code_real_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
code	int
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
return	O
;	O
if	O
(	O
emit_encoding	O
)	O
out_one	O
(	O
encoding	O
)	O
;	O
code	int
=	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	O
)	O
;	O
if	O
(	O
code	int
!=	O
BFD_RELOC_NONE	int
)	O
{	O
reloc_howto_type	struct
*	O
howto	*(struct)
=	O
bfd_reloc_type_lookup	(*(struct),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(struct(int,int,int,int,int,enum(int,int,int,int),int,int,int,int,long,long,*((*`,*`,*`,*`,*`,*`,*`)->(enum(int,int,int,int,int,int,int,int))),*(char))))
(	O
stdoutput	O
,	O
code	int
)	O
;	O
char	O
*	O
p	*(void)
=	O
frag_more	O
(	O
size	int
)	O
;	O
gas_assert	O
(	O
size	int
==	O
(	O
unsigned	O
)	O
howto	*(struct)
->	O
bitsize	int
/	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
,	O
0	int
,	O
size	int
)	O
;	O
fix_new	O
(	O
frag_now	O
,	O
p	*(void)
-	O
frag_now	O
->	O
fr_literal	O
,	O
size	int
,	O
exp	O
->	O
X_add_symbol	O
,	O
exp	O
->	O
X_add_number	O
,	O
howto	*(struct)
->	O
pc_relative	int
,	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	O
)	O
{	O
expressionS	O
tmp	O
=	O
*	O
exp	O
;	O
tmp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
tmp	O
.	O
X_op_symbol	O
=	O
symbol_temp_new_now	O
(	O
)	O
;	O
emit_expr	O
(	O
&	O
tmp	O
,	O
size	int
)	O
;	O
}	O
else	O
emit_expr	O
(	O
exp	O
,	O
size	int
)	O
;	O
}	O
static	O
char	O
*	O
get_debugseg_name	O
(	O
segT	O
seg	O
,	O
const	O
char	O
*	O
base_name	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
dollar	O
;	O
const	O
char	O
*	O
dot	O
;	O
if	O
(	O
!	O
seg	O
)	O
return	O
concat	O
(	O
base_name	O
,	O
NULL	O
)	O
;	O
name	*(char)
=	O
bfd_section_name	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(*(char))
(	O
seg	O
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
*	O
name	*(char)
==	O
0	int
)	O
return	O
concat	O
(	O
base_name	O
,	O
NULL	O
)	O
;	O
dollar	O
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'$'	O
)	O
;	O
dot	O
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
+	O
1	int
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
dollar	O
&&	O
!	O
dot	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
base_name	O
,	O
".eh_frame_entry"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
".text"	*(char)
)	O
!=	O
0	int
)	O
return	O
concat	O
(	O
base_name	O
,	O
"."	*(char)
,	O
name	*(char)
,	O
NULL	O
)	O
;	O
name	*(char)
=	O
""	*(char)
;	O
}	O
else	O
if	O
(	O
!	O
dollar	O
)	O
name	*(char)
=	O
dot	O
;	O
else	O
if	O
(	O
!	O
dot	O
)	O
name	*(char)
=	O
dollar	O
;	O
else	O
if	O
(	O
dot	O
<	O
dollar	O
)	O
name	*(char)
=	O
dot	O
;	O
else	O
name	*(char)
=	O
dollar	O
;	O
return	O
concat	O
(	O
base_name	O
,	O
name	*(char)
,	O
NULL	O
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	O
*	O
alloc_debugseg_item	O
(	O
segT	O
seg	O
,	O
int	O
subseg	O
,	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
dwcfi_seg_list	O
*	O
r	O
;	O
r	O
=	O
(	O
struct	O
dwcfi_seg_list	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
struct	O
dwcfi_seg_list	O
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
)	O
;	O
r	O
->	O
seg	O
=	O
seg	O
;	O
r	O
->	O
subseg	O
=	O
subseg	O
;	O
r	O
->	O
seg_name	O
=	O
name	*(char)
;	O
return	O
r	O
;	O
}	O
static	O
segT	O
is_now_linkonce_segment	O
(	O
void	O
)	O
{	O
if	O
(	O
compact_eh	O
)	O
return	O
now_seg	O
;	O
if	O
(	O
(	O
bfd_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(int)
(	O
now_seg	O
)	O
&	O
(	O
SEC_LINK_ONCE	O
|	O
SEC_LINK_DUPLICATES_DISCARD	O
|	O
SEC_LINK_DUPLICATES_ONE_ONLY	O
|	O
SEC_LINK_DUPLICATES_SAME_SIZE	O
|	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
)	O
)	O
!=	O
0	int
)	O
return	O
now_seg	O
;	O
return	O
NULL	O
;	O
}	O
static	O
segT	O
make_debug_seg	O
(	O
segT	O
cseg	O
,	O
char	O
*	O
name	*(char)
,	O
int	O
sflags	O
)	O
{	O
segT	O
save_seg	O
=	O
now_seg	O
;	O
int	O
save_subseg	O
=	O
now_subseg	O
;	O
segT	O
r	O
;	O
flagword	int
flags	int
;	O
r	O
=	O
subseg_new	O
(	O
name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
cseg	O
)	O
flags	int
=	O
0	int
;	O
else	O
flags	int
=	O
(	O
bfd_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(int)
(	O
cseg	O
)	O
&	O
(	O
SEC_LINK_ONCE	O
|	O
SEC_LINK_DUPLICATES_DISCARD	O
|	O
SEC_LINK_DUPLICATES_ONE_ONLY	O
|	O
SEC_LINK_DUPLICATES_SAME_SIZE	O
|	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
)	O
)	O
;	O
flags	int
|=	O
sflags	O
;	O
if	O
(	O
!	O
bfd_set_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
r	O
,	O
flags	int
)	O
)	O
as_bad	O
(	O
_	O
(	O
"bfd_set_section_flags: %s"	*(char)
)	O
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
if	O
(	O
save_seg	O
!=	O
NULL	O
)	O
subseg_set	O
(	O
save_seg	O
,	O
save_subseg	O
)	O
;	O
return	O
r	O
;	O
}	O
static	O
void	O
dwcfi_hash_insert	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
dwcfi_seg_list	O
*	O
item	O
)	O
{	O
const	O
char	O
*	O
error_string	O
;	O
if	O
(	O
(	O
error_string	O
=	O
hash_jam	O
(	O
dwcfi_hash	O
,	O
name	*(char)
,	O
(	O
char	O
*	O
)	O
item	O
)	O
)	O
)	O
as_fatal	O
(	O
_	O
(	O
"Inserting \"%s\" into structure table failed: %s"	*(char)
)	O
,	O
name	*(char)
,	O
error_string	O
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	O
*	O
dwcfi_hash_find	O
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
struct	O
dwcfi_seg_list	O
*	O
)	O
hash_find	O
(	O
dwcfi_hash	O
,	O
name	*(char)
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	O
*	O
dwcfi_hash_find_or_make	O
(	O
segT	O
cseg	O
,	O
const	O
char	O
*	O
base_name	O
,	O
int	O
flags	int
)	O
{	O
struct	O
dwcfi_seg_list	O
*	O
item	O
;	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
!	O
dwcfi_hash	O
)	O
dwcfi_hash	O
=	O
hash_new	O
(	O
)	O
;	O
name	*(char)
=	O
get_debugseg_name	O
(	O
cseg	O
,	O
base_name	O
)	O
;	O
item	O
=	O
dwcfi_hash_find	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
item	O
)	O
{	O
item	O
=	O
alloc_debugseg_item	O
(	O
make_debug_seg	O
(	O
cseg	O
,	O
name	*(char)
,	O
flags	int
)	O
,	O
0	int
,	O
name	*(char)
)	O
;	O
dwcfi_hash_insert	O
(	O
item	O
->	O
seg_name	O
,	O
item	O
)	O
;	O
}	O
else	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
item	O
;	O
}	O
static	O
void	O
generic_dwarf2_emit_offset	O
(	O
symbolS	O
*	O
symbol	*(struct)
,	O
unsigned	O
int	O
size	int
)	O
{	O
expressionS	O
exp	O
;	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
symbol	*(struct)
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
size	int
)	O
;	O
}	O
struct	O
cfi_escape_data	O
{	O
struct	O
cfi_escape_data	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
expressionS	O
exp	O
;	O
}	O
;	O
struct	O
cie_entry	O
{	O
struct	O
cie_entry	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
symbolS	O
*	O
start_address	long
;	O
unsigned	O
int	O
return_column	O
;	O
unsigned	O
int	O
signal_frame	O
;	O
unsigned	O
char	O
fde_encoding	O
;	O
unsigned	O
char	O
per_encoding	O
;	O
unsigned	O
char	O
lsda_encoding	O
;	O
expressionS	O
personality	O
;	O
struct	O
cfi_insn_data	O
*	O
first	O
,	O
*	O
last	O
;	O
}	O
;	O
struct	O
fde_entry	O
*	O
all_fde_data	O
;	O
static	O
struct	O
fde_entry	O
*	O
*	O
last_fde_data	O
=	O
&	O
all_fde_data	O
;	O
static	O
struct	O
cie_entry	O
*	O
cie_root	O
;	O
static	O
struct	O
fde_entry	O
*	O
alloc_fde_entry	O
(	O
void	O
)	O
{	O
struct	O
fde_entry	O
*	O
fde	O
=	O
XCNEW	O
(	O
struct	O
fde_entry	O
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
=	O
XCNEW	O
(	O
struct	O
frch_cfi_data	O
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
=	O
fde	O
;	O
*	O
last_fde_data	O
=	O
fde	O
;	O
last_fde_data	O
=	O
&	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
SET_CUR_SEG	O
(	O
fde	O
,	O
is_now_linkonce_segment	O
(	O
)	O
)	O
;	O
SET_HANDLED	O
(	O
fde	O
,	O
0	int
)	O
;	O
fde	O
->	O
last	O
=	O
&	O
fde	O
->	O
data	*(void)
;	O
fde	O
->	O
return_column	O
=	O
DWARF2_DEFAULT_RETURN_COLUMN	O
;	O
fde	O
->	O
per_encoding	O
=	O
DW_EH_PE_omit	O
;	O
fde	O
->	O
lsda_encoding	O
=	O
DW_EH_PE_omit	O
;	O
fde	O
->	O
eh_header_type	O
=	O
EH_COMPACT_UNKNOWN	O
;	O
return	O
fde	O
;	O
}	O
static	O
bfd_boolean	int
cfi_sections_set	O
=	O
FALSE	O
;	O
static	O
int	O
cfi_sections	O
=	O
CFI_EMIT_eh_frame	O
;	O
int	O
all_cfi_sections	O
=	O
0	int
;	O
static	O
struct	O
fde_entry	O
*	O
last_fde	O
;	O
static	O
struct	O
cfi_insn_data	O
*	O
alloc_cfi_insn_data	O
(	O
void	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn	O
=	O
XCNEW	O
(	O
struct	O
cfi_insn_data	O
)	O
;	O
struct	O
fde_entry	O
*	O
cur_fde_data	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
;	O
*	O
cur_fde_data	O
->	O
last	O
=	O
insn	O
;	O
cur_fde_data	O
->	O
last	O
=	O
&	O
insn	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
SET_CUR_SEG	O
(	O
insn	O
,	O
is_now_linkonce_segment	O
(	O
)	O
)	O
;	O
return	O
insn	O
;	O
}	O
void	O
cfi_new_fde	O
(	O
symbolS	O
*	O
label	O
)	O
{	O
struct	O
fde_entry	O
*	O
fde	O
=	O
alloc_fde_entry	O
(	O
)	O
;	O
fde	O
->	O
start_address	long
=	O
label	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
=	O
label	O
;	O
}	O
void	O
cfi_end_fde	O
(	O
symbolS	O
*	O
label	O
)	O
{	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
->	O
end_address	O
=	O
label	O
;	O
free	(*(void))->(void)
(	O
frchain_now	O
->	O
frch_cfi_data	O
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
=	O
NULL	O
;	O
}	O
void	O
cfi_set_return_column	O
(	O
unsigned	O
regno	O
)	O
{	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
->	O
return_column	O
=	O
regno	O
;	O
}	O
void	O
cfi_set_sections	O
(	O
void	O
)	O
{	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
all_cfi_sections	O
;	O
cfi_sections_set	O
=	O
TRUE	int
;	O
}	O
static	O
void	O
cfi_add_CFA_insn	O
(	O
int	O
insn	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
insn	O
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg	O
(	O
int	O
insn	O
,	O
unsigned	O
regno	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
insn	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
r	O
=	O
regno	O
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_offset	O
(	O
int	O
insn	O
,	O
offsetT	O
offset	long
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
insn	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
i	*(struct)
=	O
offset	long
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg_reg	O
(	O
int	O
insn	O
,	O
unsigned	O
reg1	O
,	O
unsigned	O
reg2	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
insn	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg1	O
=	O
reg1	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg2	O
=	O
reg2	O
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg_offset	O
(	O
int	O
insn	O
,	O
unsigned	O
regno	O
,	O
offsetT	O
offset	long
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
insn	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
=	O
regno	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
=	O
offset	long
;	O
}	O
void	O
cfi_add_advance_loc	O
(	O
symbolS	O
*	O
label	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn	O
->	O
insn	O
=	O
DW_CFA_advance_loc	O
;	O
insn	O
->	O
u	union(long,*(struct))
.	O
ll	O
.	O
lab1	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
;	O
insn	O
->	O
u	union(long,*(struct))
.	O
ll	O
.	O
lab2	O
=	O
label	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
=	O
label	O
;	O
}	O
void	O
cfi_add_label	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
;	O
struct	O
cfi_insn_data	O
*	O
insn	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn	O
->	O
insn	O
=	O
CFI_label	O
;	O
obstack_grow	O
(	O
&	O
notes	O
,	O
name	*(char)
,	O
len	long
)	O
;	O
insn	O
->	O
u	union(long,*(struct))
.	O
sym_name	O
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	O
)	O
;	O
}	O
void	O
cfi_add_CFA_offset	O
(	O
unsigned	O
regno	O
,	O
offsetT	O
offset	long
)	O
{	O
unsigned	O
int	O
abs_data_align	O
;	O
gas_assert	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
!=	O
0	int
)	O
;	O
cfi_add_CFA_insn_reg_offset	O
(	O
DW_CFA_offset	O
,	O
regno	O
,	O
offset	long
)	O
;	O
abs_data_align	O
=	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
<	O
0	int
?	O
-	O
DWARF2_CIE_DATA_ALIGNMENT	O
:	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
offset	long
%	O
abs_data_align	O
)	O
as_bad	O
(	O
_	O
(	O
"register save offset not a multiple of %u"	*(char)
)	O
,	O
abs_data_align	O
)	O
;	O
}	O
void	O
cfi_add_CFA_val_offset	O
(	O
unsigned	O
regno	O
,	O
offsetT	O
offset	long
)	O
{	O
unsigned	O
int	O
abs_data_align	O
;	O
gas_assert	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
!=	O
0	int
)	O
;	O
cfi_add_CFA_insn_reg_offset	O
(	O
DW_CFA_val_offset	O
,	O
regno	O
,	O
offset	long
)	O
;	O
abs_data_align	O
=	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
<	O
0	int
?	O
-	O
DWARF2_CIE_DATA_ALIGNMENT	O
:	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
offset	long
%	O
abs_data_align	O
)	O
as_bad	O
(	O
_	O
(	O
"register save offset not a multiple of %u"	*(char)
)	O
,	O
abs_data_align	O
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa	O
(	O
unsigned	O
regno	O
,	O
offsetT	O
offset	long
)	O
{	O
cfi_add_CFA_insn_reg_offset	O
(	O
DW_CFA_def_cfa	O
,	O
regno	O
,	O
offset	long
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
=	O
offset	long
;	O
}	O
void	O
cfi_add_CFA_register	O
(	O
unsigned	O
reg1	O
,	O
unsigned	O
reg2	O
)	O
{	O
cfi_add_CFA_insn_reg_reg	O
(	O
DW_CFA_register	O
,	O
reg1	O
,	O
reg2	O
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa_register	O
(	O
unsigned	O
regno	O
)	O
{	O
cfi_add_CFA_insn_reg	O
(	O
DW_CFA_def_cfa_register	O
,	O
regno	O
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa_offset	O
(	O
offsetT	O
offset	long
)	O
{	O
cfi_add_CFA_insn_offset	O
(	O
DW_CFA_def_cfa_offset	O
,	O
offset	long
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
=	O
offset	long
;	O
}	O
void	O
cfi_add_CFA_restore	O
(	O
unsigned	O
regno	O
)	O
{	O
cfi_add_CFA_insn_reg	O
(	O
DW_CFA_restore	O
,	O
regno	O
)	O
;	O
}	O
void	O
cfi_add_CFA_undefined	O
(	O
unsigned	O
regno	O
)	O
{	O
cfi_add_CFA_insn_reg	O
(	O
DW_CFA_undefined	O
,	O
regno	O
)	O
;	O
}	O
void	O
cfi_add_CFA_same_value	O
(	O
unsigned	O
regno	O
)	O
{	O
cfi_add_CFA_insn_reg	O
(	O
DW_CFA_same_value	O
,	O
regno	O
)	O
;	O
}	O
void	O
cfi_add_CFA_remember_state	O
(	O
void	O
)	O
{	O
struct	O
cfa_save_data	O
*	O
p	*(void)
;	O
cfi_add_CFA_insn	O
(	O
DW_CFA_remember_state	O
)	O
;	O
p	*(void)
=	O
XNEW	O
(	O
struct	O
cfa_save_data	O
)	O
;	O
p	*(void)
->	O
cfa_offset	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
;	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cfa_save_stack	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cfa_save_stack	O
=	O
p	*(void)
;	O
}	O
void	O
cfi_add_CFA_restore_state	O
(	O
void	O
)	O
{	O
struct	O
cfa_save_data	O
*	O
p	*(void)
;	O
cfi_add_CFA_insn	O
(	O
DW_CFA_restore_state	O
)	O
;	O
p	*(void)
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cfa_save_stack	O
;	O
if	O
(	O
p	*(void)
)	O
{	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
=	O
p	*(void)
->	O
cfa_offset	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cfa_save_stack	O
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
else	O
as_bad	O
(	O
_	O
(	O
"CFI state restore without previous remember"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
dot_cfi	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_escape	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_sections	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_startproc	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_endproc	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_fde_data	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_personality	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_personality_id	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_lsda	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_val_encoded_addr	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_inline_lsda	O
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_label	O
(	O
int	O
)	O
;	O
const	O
pseudo_typeS	O
cfi_pseudo_table	O
[	O
]	O
=	O
{	O
{	O
"cfi_sections"	*(char)
,	O
dot_cfi_sections	O
,	O
0	int
}	O
,	O
{	O
"cfi_startproc"	*(char)
,	O
dot_cfi_startproc	O
,	O
0	int
}	O
,	O
{	O
"cfi_endproc"	*(char)
,	O
dot_cfi_endproc	O
,	O
0	int
}	O
,	O
{	O
"cfi_fde_data"	*(char)
,	O
dot_cfi_fde_data	O
,	O
0	int
}	O
,	O
{	O
"cfi_def_cfa"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_def_cfa	O
}	O
,	O
{	O
"cfi_def_cfa_register"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_def_cfa_register	O
}	O
,	O
{	O
"cfi_def_cfa_offset"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_def_cfa_offset	O
}	O
,	O
{	O
"cfi_adjust_cfa_offset"	*(char)
,	O
dot_cfi	O
,	O
CFI_adjust_cfa_offset	O
}	O
,	O
{	O
"cfi_offset"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_offset	O
}	O
,	O
{	O
"cfi_rel_offset"	*(char)
,	O
dot_cfi	O
,	O
CFI_rel_offset	O
}	O
,	O
{	O
"cfi_register"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_register	O
}	O
,	O
{	O
"cfi_return_column"	*(char)
,	O
dot_cfi	O
,	O
CFI_return_column	O
}	O
,	O
{	O
"cfi_restore"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_restore	O
}	O
,	O
{	O
"cfi_undefined"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_undefined	O
}	O
,	O
{	O
"cfi_same_value"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_same_value	O
}	O
,	O
{	O
"cfi_remember_state"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_remember_state	O
}	O
,	O
{	O
"cfi_restore_state"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_restore_state	O
}	O
,	O
{	O
"cfi_window_save"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_GNU_window_save	O
}	O
,	O
{	O
"cfi_negate_ra_state"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_AARCH64_negate_ra_state	O
}	O
,	O
{	O
"cfi_escape"	*(char)
,	O
dot_cfi_escape	O
,	O
0	int
}	O
,	O
{	O
"cfi_signal_frame"	*(char)
,	O
dot_cfi	O
,	O
CFI_signal_frame	O
}	O
,	O
{	O
"cfi_personality"	*(char)
,	O
dot_cfi_personality	O
,	O
0	int
}	O
,	O
{	O
"cfi_personality_id"	*(char)
,	O
dot_cfi_personality_id	O
,	O
0	int
}	O
,	O
{	O
"cfi_lsda"	*(char)
,	O
dot_cfi_lsda	O
,	O
0	int
}	O
,	O
{	O
"cfi_val_encoded_addr"	*(char)
,	O
dot_cfi_val_encoded_addr	O
,	O
0	int
}	O
,	O
{	O
"cfi_inline_lsda"	*(char)
,	O
dot_cfi_inline_lsda	O
,	O
0	int
}	O
,	O
{	O
"cfi_label"	*(char)
,	O
dot_cfi_label	O
,	O
0	int
}	O
,	O
{	O
"cfi_val_offset"	*(char)
,	O
dot_cfi	O
,	O
DW_CFA_val_offset	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
cfi_parse_separator	O
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
++	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"missing separator"	*(char)
)	O
)	O
;	O
}	O
static	O
unsigned	O
cfi_parse_reg	O
(	O
void	O
)	O
{	O
int	O
regno	O
;	O
expressionS	O
exp	O
;	O
tc_parse_to_dw2regnum	O
(	O
&	O
exp	O
)	O
;	O
switch	O
(	O
exp	O
.	O
X_op	O
)	O
{	O
case	O
O_register	O
:	O
case	O
O_constant	O
:	O
regno	O
=	O
exp	O
.	O
X_add_number	O
;	O
break	O
;	O
default	O
:	O
regno	O
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
regno	O
<	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"bad register expression"	*(char)
)	O
)	O
;	O
regno	O
=	O
0	int
;	O
}	O
return	O
regno	O
;	O
}	O
static	O
offsetT	O
cfi_parse_const	O
(	O
void	O
)	O
{	O
return	O
get_absolute_expression	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
offsetT	O
offset	long
;	O
unsigned	O
reg1	O
,	O
reg2	O
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now	O
||	O
(	O
S_GET_VALUE	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now_fix	O
(	O
)	O
)	O
)	O
cfi_add_advance_loc	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
switch	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
case	O
DW_CFA_offset	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_offset	O
(	O
reg1	O
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_val_offset	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_val_offset	O
(	O
reg1	O
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
CFI_rel_offset	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_offset	O
(	O
reg1	O
,	O
offset	long
-	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_def_cfa	O
(	O
reg1	O
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_register	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
reg2	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_add_CFA_register	O
(	O
reg1	O
,	O
reg2	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_add_CFA_def_cfa_register	O
(	O
reg1	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	O
:	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_def_cfa_offset	O
(	O
offset	long
)	O
;	O
break	O
;	O
case	O
CFI_adjust_cfa_offset	O
:	O
offset	long
=	O
cfi_parse_const	O
(	O
)	O
;	O
cfi_add_CFA_def_cfa_offset	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
+	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_restore	O
:	O
for	O
(	O
;	O
;	O
)	O
{	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_add_CFA_restore	O
(	O
reg1	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
break	O
;	O
++	O
input_line_pointer	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_undefined	O
:	O
for	O
(	O
;	O
;	O
)	O
{	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_add_CFA_undefined	O
(	O
reg1	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
break	O
;	O
++	O
input_line_pointer	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_same_value	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_add_CFA_same_value	O
(	O
reg1	O
)	O
;	O
break	O
;	O
case	O
CFI_return_column	O
:	O
reg1	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_set_return_column	O
(	O
reg1	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_remember_state	O
:	O
cfi_add_CFA_remember_state	O
(	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_restore_state	O
:	O
cfi_add_CFA_restore_state	O
(	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_window_save	O
:	O
cfi_add_CFA_insn	O
(	O
DW_CFA_GNU_window_save	O
)	O
;	O
break	O
;	O
case	O
CFI_signal_frame	O
:	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
->	O
signal_frame	O
=	O
1	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_escape	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
cfi_escape_data	O
*	O
head	O
,	O
*	O
*	O
tail	O
,	O
*	O
e	O
;	O
struct	O
cfi_insn_data	O
*	O
insn	O
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now	O
||	O
(	O
S_GET_VALUE	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now_fix	O
(	O
)	O
)	O
)	O
cfi_add_advance_loc	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
tail	O
=	O
&	O
head	O
;	O
do	O
{	O
e	O
=	O
XNEW	O
(	O
struct	O
cfi_escape_data	O
)	O
;	O
do_parse_cons_expression	O
(	O
&	O
e	O
->	O
exp	O
,	O
1	int
)	O
;	O
*	O
tail	O
=	O
e	O
;	O
tail	O
=	O
&	O
e	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
while	O
(	O
*	O
input_line_pointer	O
++	O
==	O
','	O
)	O
;	O
*	O
tail	O
=	O
NULL	O
;	O
insn	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn	O
->	O
insn	O
=	O
CFI_escape	O
;	O
insn	O
->	O
u	union(long,*(struct))
.	O
esc	O
=	O
head	O
;	O
--	O
input_line_pointer	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_personality	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
fde_entry	O
*	O
fde	O
;	O
offsetT	O
encoding	O
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
fde	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
;	O
encoding	O
=	O
cfi_parse_const	O
(	O
)	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
fde	O
->	O
per_encoding	O
=	O
encoding	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
encoding	O
&	O
0xff	int
)	O
!=	O
encoding	O
||	O
(	O
(	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	O
)	O
||	O
(	O
encoding	O
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	O
||	O
(	O
encoding	O
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	O
)	O
&&	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	O
)	O
==	O
BFD_RELOC_NONE	int
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_personality"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
++	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_personality requires encoding and symbol arguments"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
expression_and_evaluate	O
(	O
&	O
fde	O
->	O
personality	O
)	O
;	O
switch	O
(	O
fde	O
->	O
personality	O
.	O
X_op	O
)	O
{	O
case	O
O_symbol	O
:	O
break	O
;	O
case	O
O_constant	O
:	O
if	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	O
)	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
break	O
;	O
default	O
:	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
break	O
;	O
}	O
fde	O
->	O
per_encoding	O
=	O
encoding	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"wrong second argument to .cfi_personality"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_lsda	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
fde_entry	O
*	O
fde	O
;	O
offsetT	O
encoding	O
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
fde	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
;	O
encoding	O
=	O
cfi_parse_const	O
(	O
)	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
fde	O
->	O
lsda_encoding	O
=	O
encoding	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
encoding	O
&	O
0xff	int
)	O
!=	O
encoding	O
||	O
(	O
(	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	O
)	O
||	O
(	O
encoding	O
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	O
||	O
(	O
encoding	O
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	O
)	O
&&	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	O
)	O
==	O
BFD_RELOC_NONE	int
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_lsda"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
++	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_lsda requires encoding and symbol arguments"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
fde	O
->	O
lsda_encoding	O
=	O
encoding	O
;	O
expression_and_evaluate	O
(	O
&	O
fde	O
->	O
lsda	O
)	O
;	O
switch	O
(	O
fde	O
->	O
lsda	O
.	O
X_op	O
)	O
{	O
case	O
O_symbol	O
:	O
break	O
;	O
case	O
O_constant	O
:	O
if	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	O
)	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
break	O
;	O
default	O
:	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
break	O
;	O
}	O
fde	O
->	O
lsda_encoding	O
=	O
encoding	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"wrong second argument to .cfi_lsda"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_val_encoded_addr	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
insn_ptr	O
;	O
offsetT	O
encoding	O
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now	O
||	O
(	O
S_GET_VALUE	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now_fix	O
(	O
)	O
)	O
)	O
cfi_add_advance_loc	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
insn_ptr	O
=	O
alloc_cfi_insn_data	O
(	O
)	O
;	O
insn_ptr	O
->	O
insn	O
=	O
CFI_val_encoded_addr	O
;	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
reg	O
=	O
cfi_parse_reg	O
(	O
)	O
;	O
cfi_parse_separator	O
(	O
)	O
;	O
encoding	O
=	O
cfi_parse_const	O
(	O
)	O
;	O
if	O
(	O
(	O
encoding	O
&	O
0xff	int
)	O
!=	O
encoding	O
||	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	O
)	O
||	O
(	O
encoding	O
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	O
||	O
(	O
encoding	O
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_lsda"	*(char)
)	O
)	O
;	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
}	O
cfi_parse_separator	O
(	O
)	O
;	O
expression_and_evaluate	O
(	O
&	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
exp	O
)	O
;	O
switch	O
(	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
exp	O
.	O
X_op	O
)	O
{	O
case	O
O_symbol	O
:	O
break	O
;	O
case	O
O_constant	O
:	O
if	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	O
)	O
break	O
;	O
default	O
:	O
encoding	O
=	O
DW_EH_PE_omit	O
;	O
break	O
;	O
}	O
insn_ptr	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
encoding	O
=	O
encoding	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"wrong third argument to .cfi_val_encoded_addr"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_label	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
symbol_get_frag	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now	O
||	O
(	O
S_GET_VALUE	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
last_address	O
)	O
!=	O
frag_now_fix	O
(	O
)	O
)	O
)	O
cfi_add_advance_loc	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
cfi_add_label	O
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_sections	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	O
)	O
||	O
*	O
input_line_pointer	O
==	O
'"'	O
)	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
saved_ilp	O
;	O
char	O
*	O
name	*(char)
,	O
c	O
;	O
saved_ilp	O
=	O
input_line_pointer	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
".eh_frame"	*(char)
,	O
sizeof	O
".eh_frame"	*(char)
)	O
==	O
0	int
&&	O
name	*(char)
[	O
9	int
]	O
!=	O
'_'	O
)	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
|=	O
CFI_EMIT_eh_frame	O
;	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
".debug_frame"	*(char)
,	O
sizeof	O
".debug_frame"	*(char)
)	O
==	O
0	int
)	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
|=	O
CFI_EMIT_debug_frame	O
;	O
else	O
{	O
*	O
input_line_pointer	O
=	O
c	O
;	O
input_line_pointer	O
=	O
saved_ilp	O
;	O
break	O
;	O
}	O
*	O
input_line_pointer	O
=	O
c	O
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
name	*(char)
=	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
!	O
is_name_beginner	O
(	O
*	O
input_line_pointer	O
)	O
&&	O
*	O
input_line_pointer	O
!=	O
'"'	O
)	O
{	O
input_line_pointer	O
=	O
name	*(char)
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	O
)	O
||	O
*	O
input_line_pointer	O
==	O
'"'	O
)	O
break	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
cfi_sections_set	O
&&	O
(	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
&&	O
(	O
(	O
cfi_sections	O
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
!=	O
(	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"inconsistent uses of .cfi_sections"	*(char)
)	O
)	O
;	O
cfi_sections	O
=	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
static	O
void	O
dot_cfi_startproc	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
simple	O
=	O
0	int
;	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
!=	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"previous CFI entry not closed (missing .cfi_endproc)"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
cfi_new_fde	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	O
)	O
||	O
*	O
input_line_pointer	O
==	O
'"'	O
)	O
{	O
char	O
*	O
saved_ilp	O
=	O
input_line_pointer	O
;	O
char	O
*	O
name	*(char)
,	O
c	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"simple"	*(char)
)	O
==	O
0	int
)	O
{	O
simple	O
=	O
1	int
;	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
}	O
else	O
input_line_pointer	O
=	O
saved_ilp	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
cfi_sections_set	O
=	O
TRUE	int
;	O
all_cfi_sections	O
|=	O
cfi_sections	O
;	O
cfi_set_sections	O
(	O
)	O
;	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_cfa_offset	O
=	O
0	int
;	O
if	O
(	O
!	O
simple	O
)	O
tc_cfi_frame_initial_instructions	O
(	O
)	O
;	O
if	O
(	O
(	O
cfi_sections	O
&	O
CFI_EMIT_target	O
)	O
!=	O
0	int
)	O
tc_cfi_startproc	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_endproc	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
frchain_now	O
->	O
frch_cfi_data	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_endproc without corresponding .cfi_startproc"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
last_fde	O
=	O
frchain_now	O
->	O
frch_cfi_data	O
->	O
cur_fde_data	O
;	O
cfi_end_fde	O
(	O
symbol_temp_new_now	O
(	O
)	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
cfi_sections_set	O
=	O
TRUE	int
;	O
if	O
(	O
(	O
cfi_sections	O
&	O
CFI_EMIT_target	O
)	O
!=	O
0	int
)	O
tc_cfi_endproc	O
(	O
last_fde	O
)	O
;	O
}	O
static	O
segT	O
get_cfi_seg	O
(	O
segT	O
cseg	O
,	O
const	O
char	O
*	O
base	int
,	O
flagword	int
flags	int
,	O
int	O
align	O
)	O
{	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
||	O
(	O
(	O
flags	int
&	O
SEC_DEBUGGING	O
)	O
==	O
0	int
&&	O
compact_eh	O
)	O
)	O
{	O
struct	O
dwcfi_seg_list	O
*	O
l	O
;	O
l	O
=	O
dwcfi_hash_find_or_make	O
(	O
cseg	O
,	O
base	int
,	O
flags	int
)	O
;	O
cseg	O
=	O
l	O
->	O
seg	O
;	O
subseg_set	O
(	O
cseg	O
,	O
l	O
->	O
subseg	O
)	O
;	O
}	O
else	O
{	O
cseg	O
=	O
subseg_new	O
(	O
base	int
,	O
0	int
)	O
;	O
bfd_set_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
cseg	O
,	O
flags	int
)	O
;	O
}	O
record_alignment	O
(	O
cseg	O
,	O
align	O
)	O
;	O
return	O
cseg	O
;	O
}	O
static	O
void	O
dot_cfi_inline_lsda	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_inline_lsda is not supported for this target"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_fde_data	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_fde_data is not supported for this target"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_personality_id	O
(	O
int	O
ignored	O
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".cfi_personality_id is not supported for this target"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
output_cfi_insn	O
(	O
struct	O
cfi_insn_data	O
*	O
insn	O
)	O
{	O
offsetT	O
offset	long
;	O
unsigned	O
int	O
regno	O
;	O
switch	O
(	O
insn	O
->	O
insn	O
)	O
{	O
case	O
DW_CFA_advance_loc	O
:	O
{	O
symbolS	O
*	O
from	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ll	O
.	O
lab1	O
;	O
symbolS	O
*	O
to	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ll	O
.	O
lab2	O
;	O
if	O
(	O
symbol_get_frag	O
(	O
to	O
)	O
==	O
symbol_get_frag	O
(	O
from	O
)	O
)	O
{	O
addressT	O
delta	O
=	O
S_GET_VALUE	O
(	O
to	O
)	O
-	O
S_GET_VALUE	O
(	O
from	O
)	O
;	O
addressT	O
scaled	O
=	O
delta	O
/	O
DWARF2_LINE_MIN_INSN_LENGTH	O
;	O
if	O
(	O
scaled	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
scaled	O
<=	O
0x3F	int
)	O
out_one	O
(	O
DW_CFA_advance_loc	O
+	O
scaled	O
)	O
;	O
else	O
if	O
(	O
scaled	O
<=	O
0xFF	int
)	O
{	O
out_one	O
(	O
DW_CFA_advance_loc1	O
)	O
;	O
out_one	O
(	O
scaled	O
)	O
;	O
}	O
else	O
if	O
(	O
scaled	O
<=	O
0xFFFF	int
)	O
{	O
out_one	O
(	O
DW_CFA_advance_loc2	O
)	O
;	O
out_two	O
(	O
scaled	O
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_advance_loc4	O
)	O
;	O
out_four	O
(	O
scaled	O
)	O
;	O
}	O
}	O
else	O
{	O
expressionS	O
exp	O
;	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
to	O
;	O
exp	O
.	O
X_op_symbol	O
=	O
from	O
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
frag_grow	O
(	O
5	int
)	O
;	O
*	O
frag_more	O
(	O
1	int
)	O
=	O
DW_CFA_advance_loc4	O
;	O
frag_var	O
(	O
rs_cfa	O
,	O
4	int
,	O
0	int
,	O
DWARF2_LINE_MIN_INSN_LENGTH	O
<<	O
3	int
,	O
make_expr_symbol	O
(	O
&	O
exp	O
)	O
,	O
frag_now_fix	O
(	O
)	O
-	O
1	int
,	O
(	O
char	O
*	O
)	O
frag_now	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DW_CFA_def_cfa	O
:	O
offset	long
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	O
(	O
DW_CFA_def_cfa_sf	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
)	O
;	O
out_sleb128	O
(	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_def_cfa	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
)	O
;	O
out_uleb128	O
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	O
:	O
case	O
DW_CFA_undefined	O
:	O
case	O
DW_CFA_same_value	O
:	O
out_one	O
(	O
insn	O
->	O
insn	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
r	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	O
:	O
offset	long
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
i	*(struct)
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	O
(	O
DW_CFA_def_cfa_offset_sf	O
)	O
;	O
out_sleb128	O
(	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_def_cfa_offset	O
)	O
;	O
out_uleb128	O
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_restore	O
:	O
regno	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
r	O
;	O
if	O
(	O
regno	O
<=	O
0x3F	int
)	O
{	O
out_one	O
(	O
DW_CFA_restore	O
+	O
regno	O
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_restore_extended	O
)	O
;	O
out_uleb128	O
(	O
regno	O
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_offset	O
:	O
regno	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
;	O
offset	long
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	O
(	O
DW_CFA_offset_extended_sf	O
)	O
;	O
out_uleb128	O
(	O
regno	O
)	O
;	O
out_sleb128	O
(	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
regno	O
<=	O
0x3F	int
)	O
{	O
out_one	O
(	O
DW_CFA_offset	O
+	O
regno	O
)	O
;	O
out_uleb128	O
(	O
offset	long
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_offset_extended	O
)	O
;	O
out_uleb128	O
(	O
regno	O
)	O
;	O
out_uleb128	O
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_val_offset	O
:	O
regno	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
;	O
offset	long
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	O
(	O
DW_CFA_val_offset_sf	O
)	O
;	O
out_uleb128	O
(	O
regno	O
)	O
;	O
out_sleb128	O
(	O
offset	long
)	O
;	O
}	O
else	O
{	O
out_one	O
(	O
DW_CFA_val_offset	O
)	O
;	O
out_uleb128	O
(	O
regno	O
)	O
;	O
out_uleb128	O
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_register	O
:	O
out_one	O
(	O
DW_CFA_register	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg1	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg2	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_remember_state	O
:	O
case	O
DW_CFA_restore_state	O
:	O
out_one	O
(	O
insn	O
->	O
insn	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_window_save	O
:	O
out_one	O
(	O
DW_CFA_GNU_window_save	O
)	O
;	O
break	O
;	O
case	O
CFI_escape	O
:	O
{	O
struct	O
cfi_escape_data	O
*	O
e	O
;	O
for	O
(	O
e	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
esc	O
;	O
e	O
;	O
e	O
=	O
e	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
emit_expr	O
(	O
&	O
e	O
->	O
exp	O
,	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
CFI_val_encoded_addr	O
:	O
{	O
unsigned	O
encoding	O
=	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
encoding	O
;	O
offsetT	O
enc_size	O
;	O
if	O
(	O
encoding	O
==	O
DW_EH_PE_omit	O
)	O
break	O
;	O
out_one	O
(	O
DW_CFA_val_expression	O
)	O
;	O
out_uleb128	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
reg	O
)	O
;	O
switch	O
(	O
encoding	O
&	O
0x7	int
)	O
{	O
case	O
DW_EH_PE_absptr	O
:	O
enc_size	O
=	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	O
)	O
;	O
break	O
;	O
case	O
DW_EH_PE_udata2	O
:	O
enc_size	O
=	O
2	int
;	O
break	O
;	O
case	O
DW_EH_PE_udata4	O
:	O
enc_size	O
=	O
4	int
;	O
break	O
;	O
case	O
DW_EH_PE_udata8	O
:	O
enc_size	O
=	O
8	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
encoding	O
==	O
DW_EH_PE_absptr	O
)	O
{	O
out_uleb128	O
(	O
1	int
+	O
enc_size	O
)	O
;	O
out_one	O
(	O
DW_OP_addr	O
)	O
;	O
}	O
else	O
{	O
out_uleb128	O
(	O
1	int
+	O
1	int
+	O
enc_size	O
)	O
;	O
out_one	O
(	O
DW_OP_GNU_encoded_addr	O
)	O
;	O
out_one	O
(	O
encoding	O
)	O
;	O
if	O
(	O
(	O
encoding	O
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	O
)	O
{	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
exp	O
.	O
X_op_symbol	O
=	O
symbol_temp_new_now	O
(	O
)	O
;	O
}	O
}	O
emit_expr	O
(	O
&	O
insn	O
->	O
u	union(long,*(struct))
.	O
ea	O
.	O
exp	O
,	O
enc_size	O
)	O
;	O
}	O
break	O
;	O
case	O
CFI_label	O
:	O
colon	O
(	O
insn	O
->	O
u	union(long,*(struct))
.	O
sym_name	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
output_cie	O
(	O
struct	O
cie_entry	O
*	O
cie	O
,	O
bfd_boolean	int
eh_frame	O
,	O
int	O
align	O
)	O
{	O
symbolS	O
*	O
after_size_address	O
,	O
*	O
end_address	O
;	O
expressionS	O
exp	O
;	O
struct	O
cfi_insn_data	O
*	O
i	*(struct)
;	O
offsetT	O
augmentation_size	O
;	O
int	O
enc	O
;	O
enum	O
dwarf2_format	O
fmt	*(char)
=	O
DWARF2_FORMAT	O
(	O
now_seg	O
)	O
;	O
cie	O
->	O
start_address	long
=	O
symbol_temp_new_now	O
(	O
)	O
;	O
after_size_address	O
=	O
symbol_temp_make	O
(	O
)	O
;	O
end_address	O
=	O
symbol_temp_make	O
(	O
)	O
;	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
end_address	O
;	O
exp	O
.	O
X_op_symbol	O
=	O
after_size_address	O
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
if	O
(	O
eh_frame	O
||	O
fmt	*(char)
==	O
dwarf2_format_32bit	O
)	O
emit_expr	O
(	O
&	O
exp	O
,	O
4	int
)	O
;	O
else	O
{	O
if	O
(	O
fmt	*(char)
==	O
dwarf2_format_64bit	O
)	O
out_four	O
(	O
-	O
1	int
)	O
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
8	int
)	O
;	O
}	O
symbol_set_value_now	O
(	O
after_size_address	O
)	O
;	O
if	O
(	O
eh_frame	O
)	O
out_four	O
(	O
0	int
)	O
;	O
else	O
{	O
out_four	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
fmt	*(char)
!=	O
dwarf2_format_32bit	O
)	O
out_four	O
(	O
-	O
1	int
)	O
;	O
}	O
out_one	O
(	O
flag_dwarf_cie_version	O
)	O
;	O
if	O
(	O
eh_frame	O
)	O
{	O
out_one	O
(	O
'z'	O
)	O
;	O
if	O
(	O
cie	O
->	O
per_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
out_one	O
(	O
'P'	O
)	O
;	O
if	O
(	O
cie	O
->	O
lsda_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
out_one	O
(	O
'L'	O
)	O
;	O
out_one	O
(	O
'R'	O
)	O
;	O
}	O
if	O
(	O
cie	O
->	O
signal_frame	O
)	O
out_one	O
(	O
'S'	O
)	O
;	O
out_one	O
(	O
0	int
)	O
;	O
if	O
(	O
flag_dwarf_cie_version	O
>=	O
4	int
)	O
{	O
int	O
address_size	O
=	O
dwarf2_format_32bit	O
?	O
4	int
:	O
8	int
;	O
out_one	O
(	O
address_size	O
)	O
;	O
out_one	O
(	O
0	int
)	O
;	O
}	O
out_uleb128	O
(	O
DWARF2_LINE_MIN_INSN_LENGTH	O
)	O
;	O
out_sleb128	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
flag_dwarf_cie_version	O
==	O
1	int
)	O
{	O
if	O
(	O
(	O
cie	O
->	O
return_column	O
&	O
0xff	int
)	O
!=	O
cie	O
->	O
return_column	O
)	O
as_bad	O
(	O
_	O
(	O
"return column number %d overflows in CIE version 1"	*(char)
)	O
,	O
cie	O
->	O
return_column	O
)	O
;	O
out_one	O
(	O
cie	O
->	O
return_column	O
)	O
;	O
}	O
else	O
out_uleb128	O
(	O
cie	O
->	O
return_column	O
)	O
;	O
if	O
(	O
eh_frame	O
)	O
{	O
augmentation_size	O
=	O
1	int
+	O
(	O
cie	O
->	O
lsda_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
;	O
if	O
(	O
cie	O
->	O
per_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
augmentation_size	O
+=	O
1	int
+	O
encoding_size	O
(	O
cie	O
->	O
per_encoding	O
)	O
;	O
out_uleb128	O
(	O
augmentation_size	O
)	O
;	O
emit_expr_encoded	O
(	O
&	O
cie	O
->	O
personality	O
,	O
cie	O
->	O
per_encoding	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
cie	O
->	O
lsda_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
out_one	O
(	O
cie	O
->	O
lsda_encoding	O
)	O
;	O
}	O
switch	O
(	O
DWARF2_FDE_RELOC_SIZE	O
)	O
{	O
case	O
2	int
:	O
enc	O
=	O
DW_EH_PE_sdata2	O
;	O
break	O
;	O
case	O
4	int
:	O
enc	O
=	O
DW_EH_PE_sdata4	O
;	O
break	O
;	O
case	O
8	int
:	O
enc	O
=	O
DW_EH_PE_sdata8	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
enc	O
|=	O
DW_EH_PE_pcrel	O
;	O
cie	O
->	O
fde_encoding	O
=	O
enc	O
;	O
if	O
(	O
eh_frame	O
)	O
out_one	O
(	O
enc	O
)	O
;	O
if	O
(	O
cie	O
->	O
first	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
cie	O
->	O
first	O
;	O
i	*(struct)
!=	O
cie	O
->	O
last	O
;	O
i	*(struct)
=	O
i	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
CUR_SEG	O
(	O
i	*(struct)
)	O
!=	O
CUR_SEG	O
(	O
cie	O
)	O
)	O
continue	O
;	O
output_cfi_insn	O
(	O
i	*(struct)
)	O
;	O
}	O
}	O
frag_align	O
(	O
align	O
,	O
DW_CFA_nop	O
,	O
0	int
)	O
;	O
symbol_set_value_now	O
(	O
end_address	O
)	O
;	O
}	O
static	O
void	O
output_fde	O
(	O
struct	O
fde_entry	O
*	O
fde	O
,	O
struct	O
cie_entry	O
*	O
cie	O
,	O
bfd_boolean	int
eh_frame	O
,	O
struct	O
cfi_insn_data	O
*	O
first	O
,	O
int	O
align	O
)	O
{	O
symbolS	O
*	O
after_size_address	O
,	O
*	O
end_address	O
;	O
expressionS	O
exp	O
;	O
offsetT	O
augmentation_size	O
;	O
enum	O
dwarf2_format	O
fmt	*(char)
=	O
DWARF2_FORMAT	O
(	O
now_seg	O
)	O
;	O
unsigned	O
int	O
offset_size	O
;	O
unsigned	O
int	O
addr_size	O
;	O
after_size_address	O
=	O
symbol_temp_make	O
(	O
)	O
;	O
end_address	O
=	O
symbol_temp_make	O
(	O
)	O
;	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
end_address	O
;	O
exp	O
.	O
X_op_symbol	O
=	O
after_size_address	O
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
if	O
(	O
eh_frame	O
||	O
fmt	*(char)
==	O
dwarf2_format_32bit	O
)	O
offset_size	O
=	O
4	int
;	O
else	O
{	O
if	O
(	O
fmt	*(char)
==	O
dwarf2_format_64bit	O
)	O
out_four	O
(	O
-	O
1	int
)	O
;	O
offset_size	O
=	O
8	int
;	O
}	O
emit_expr	O
(	O
&	O
exp	O
,	O
offset_size	O
)	O
;	O
symbol_set_value_now	O
(	O
after_size_address	O
)	O
;	O
if	O
(	O
eh_frame	O
)	O
{	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
after_size_address	O
;	O
exp	O
.	O
X_op_symbol	O
=	O
cie	O
->	O
start_address	long
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
offset_size	O
)	O
;	O
}	O
else	O
{	O
TC_DWARF2_EMIT_OFFSET	O
(	O
cie	O
->	O
start_address	long
,	O
offset_size	O
)	O
;	O
}	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
if	O
(	O
eh_frame	O
)	O
{	O
bfd_reloc_code_real_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
code	int
=	O
tc_cfi_reloc_for_encoding	O
(	O
cie	O
->	O
fde_encoding	O
)	O
;	O
addr_size	O
=	O
DWARF2_FDE_RELOC_SIZE	O
;	O
if	O
(	O
code	int
!=	O
BFD_RELOC_NONE	int
)	O
{	O
reloc_howto_type	struct
*	O
howto	*(struct)
=	O
bfd_reloc_type_lookup	(*(struct),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(struct(int,int,int,int,int,enum(int,int,int,int),int,int,int,int,long,long,*((*`,*`,*`,*`,*`,*`,*`)->(enum(int,int,int,int,int,int,int,int))),*(char))))
(	O
stdoutput	O
,	O
code	int
)	O
;	O
char	O
*	O
p	*(void)
=	O
frag_more	O
(	O
addr_size	O
)	O
;	O
gas_assert	O
(	O
addr_size	O
==	O
(	O
unsigned	O
)	O
howto	*(struct)
->	O
bitsize	int
/	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
,	O
0	int
,	O
addr_size	O
)	O
;	O
fix_new	O
(	O
frag_now	O
,	O
p	*(void)
-	O
frag_now	O
->	O
fr_literal	O
,	O
addr_size	O
,	O
fde	O
->	O
start_address	long
,	O
0	int
,	O
howto	*(struct)
->	O
pc_relative	int
,	O
code	int
)	O
;	O
}	O
else	O
{	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
exp	O
.	O
X_add_symbol	O
=	O
fde	O
->	O
start_address	long
;	O
exp	O
.	O
X_op_symbol	O
=	O
symbol_temp_new_now	O
(	O
)	O
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
addr_size	O
)	O
;	O
}	O
}	O
else	O
{	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
exp	O
.	O
X_add_symbol	O
=	O
fde	O
->	O
start_address	long
;	O
addr_size	O
=	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	O
)	O
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
addr_size	O
)	O
;	O
}	O
exp	O
.	O
X_op	O
=	O
O_subtract	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
fde	O
->	O
end_address	O
;	O
exp	O
.	O
X_op_symbol	O
=	O
fde	O
->	O
start_address	long
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
addr_size	O
)	O
;	O
augmentation_size	O
=	O
encoding_size	O
(	O
fde	O
->	O
lsda_encoding	O
)	O
;	O
if	O
(	O
eh_frame	O
)	O
out_uleb128	O
(	O
augmentation_size	O
)	O
;	O
emit_expr_encoded	O
(	O
&	O
fde	O
->	O
lsda	O
,	O
cie	O
->	O
lsda_encoding	O
,	O
FALSE	O
)	O
;	O
for	O
(	O
;	O
first	O
;	O
first	O
=	O
first	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
CUR_SEG	O
(	O
first	O
)	O
==	O
CUR_SEG	O
(	O
fde	O
)	O
)	O
output_cfi_insn	O
(	O
first	O
)	O
;	O
frag_align	O
(	O
align	O
,	O
DW_CFA_nop	O
,	O
0	int
)	O
;	O
symbol_set_value_now	O
(	O
end_address	O
)	O
;	O
}	O
static	O
struct	O
cie_entry	O
*	O
select_cie_for_fde	O
(	O
struct	O
fde_entry	O
*	O
fde	O
,	O
bfd_boolean	int
eh_frame	O
,	O
struct	O
cfi_insn_data	O
*	O
*	O
pfirst	O
,	O
int	O
align	O
)	O
{	O
struct	O
cfi_insn_data	O
*	O
i	*(struct)
,	O
*	O
j	O
;	O
struct	O
cie_entry	O
*	O
cie	O
;	O
for	O
(	O
cie	O
=	O
cie_root	O
;	O
cie	O
;	O
cie	O
=	O
cie	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
CUR_SEG	O
(	O
cie	O
)	O
!=	O
CUR_SEG	O
(	O
fde	O
)	O
)	O
continue	O
;	O
if	O
(	O
cie	O
->	O
return_column	O
!=	O
fde	O
->	O
return_column	O
||	O
cie	O
->	O
signal_frame	O
!=	O
fde	O
->	O
signal_frame	O
||	O
cie	O
->	O
per_encoding	O
!=	O
fde	O
->	O
per_encoding	O
||	O
cie	O
->	O
lsda_encoding	O
!=	O
fde	O
->	O
lsda_encoding	O
)	O
continue	O
;	O
if	O
(	O
cie	O
->	O
per_encoding	O
!=	O
DW_EH_PE_omit	O
)	O
{	O
if	O
(	O
cie	O
->	O
personality	O
.	O
X_op	O
!=	O
fde	O
->	O
personality	O
.	O
X_op	O
||	O
(	O
cie	O
->	O
personality	O
.	O
X_add_number	O
!=	O
fde	O
->	O
personality	O
.	O
X_add_number	O
)	O
)	O
continue	O
;	O
switch	O
(	O
cie	O
->	O
personality	O
.	O
X_op	O
)	O
{	O
case	O
O_constant	O
:	O
if	O
(	O
cie	O
->	O
personality	O
.	O
X_unsigned	O
!=	O
fde	O
->	O
personality	O
.	O
X_unsigned	O
)	O
continue	O
;	O
break	O
;	O
case	O
O_symbol	O
:	O
if	O
(	O
cie	O
->	O
personality	O
.	O
X_add_symbol	O
!=	O
fde	O
->	O
personality	O
.	O
X_add_symbol	O
)	O
continue	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
for	O
(	O
i	*(struct)
=	O
cie	O
->	O
first	O
,	O
j	O
=	O
fde	O
->	O
data	*(void)
;	O
i	*(struct)
!=	O
cie	O
->	O
last	O
&&	O
j	O
!=	O
NULL	O
;	O
i	*(struct)
=	O
i	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
,	O
j	O
=	O
j	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
i	*(struct)
->	O
insn	O
!=	O
j	O
->	O
insn	O
)	O
goto	O
fail	O
;	O
switch	O
(	O
i	*(struct)
->	O
insn	O
)	O
{	O
case	O
DW_CFA_advance_loc	O
:	O
case	O
DW_CFA_remember_state	O
:	O
goto	O
fail	O
;	O
case	O
DW_CFA_offset	O
:	O
case	O
DW_CFA_def_cfa	O
:	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
reg	O
)	O
goto	O
fail	O
;	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
ri	O
.	O
offset	long
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_register	O
:	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg1	O
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg1	O
)	O
goto	O
fail	O
;	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg2	O
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
rr	O
.	O
reg2	O
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	O
:	O
case	O
DW_CFA_restore	O
:	O
case	O
DW_CFA_undefined	O
:	O
case	O
DW_CFA_same_value	O
:	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
r	O
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
r	O
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	O
:	O
if	O
(	O
i	*(struct)
->	O
u	union(long,*(struct))
.	O
i	*(struct)
!=	O
j	O
->	O
u	union(long,*(struct))
.	O
i	*(struct)
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
CFI_escape	O
:	O
case	O
CFI_val_encoded_addr	O
:	O
case	O
CFI_label	O
:	O
goto	O
fail	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
i	*(struct)
==	O
cie	O
->	O
last	O
&&	O
(	O
!	O
j	O
||	O
j	O
->	O
insn	O
==	O
DW_CFA_advance_loc	O
||	O
j	O
->	O
insn	O
==	O
DW_CFA_remember_state	O
||	O
j	O
->	O
insn	O
==	O
CFI_escape	O
||	O
j	O
->	O
insn	O
==	O
CFI_val_encoded_addr	O
||	O
j	O
->	O
insn	O
==	O
CFI_label	O
)	O
)	O
{	O
*	O
pfirst	O
=	O
j	O
;	O
return	O
cie	O
;	O
}	O
fail	O
:	O
;	O
}	O
cie	O
=	O
XNEW	O
(	O
struct	O
cie_entry	O
)	O
;	O
cie	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
cie_root	O
;	O
cie_root	O
=	O
cie	O
;	O
SET_CUR_SEG	O
(	O
cie	O
,	O
CUR_SEG	O
(	O
fde	O
)	O
)	O
;	O
cie	O
->	O
return_column	O
=	O
fde	O
->	O
return_column	O
;	O
cie	O
->	O
signal_frame	O
=	O
fde	O
->	O
signal_frame	O
;	O
cie	O
->	O
per_encoding	O
=	O
fde	O
->	O
per_encoding	O
;	O
cie	O
->	O
lsda_encoding	O
=	O
fde	O
->	O
lsda_encoding	O
;	O
cie	O
->	O
personality	O
=	O
fde	O
->	O
personality	O
;	O
cie	O
->	O
first	O
=	O
fde	O
->	O
data	*(void)
;	O
for	O
(	O
i	*(struct)
=	O
cie	O
->	O
first	O
;	O
i	*(struct)
;	O
i	*(struct)
=	O
i	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
i	*(struct)
->	O
insn	O
==	O
DW_CFA_advance_loc	O
||	O
i	*(struct)
->	O
insn	O
==	O
DW_CFA_remember_state	O
||	O
i	*(struct)
->	O
insn	O
==	O
CFI_escape	O
||	O
i	*(struct)
->	O
insn	O
==	O
CFI_val_encoded_addr	O
||	O
i	*(struct)
->	O
insn	O
==	O
CFI_label	O
)	O
break	O
;	O
cie	O
->	O
last	O
=	O
i	*(struct)
;	O
*	O
pfirst	O
=	O
i	*(struct)
;	O
output_cie	O
(	O
cie	O
,	O
eh_frame	O
,	O
align	O
)	O
;	O
return	O
cie	O
;	O
}	O
void	O
cfi_finish	O
(	O
void	O
)	O
{	O
struct	O
cie_entry	O
*	O
cie	O
,	O
*	O
cie_next	O
;	O
segT	O
cfi_seg	O
,	O
ccseg	O
;	O
struct	O
fde_entry	O
*	O
fde	O
;	O
struct	O
cfi_insn_data	O
*	O
first	O
;	O
int	O
save_flag_traditional_format	O
,	O
seek_next_seg	O
;	O
if	O
(	O
all_fde_data	O
==	O
0	int
)	O
return	O
;	O
cfi_sections_set	O
=	O
TRUE	int
;	O
if	O
(	O
(	O
all_cfi_sections	O
&	O
CFI_EMIT_eh_frame	O
)	O
!=	O
0	int
||	O
(	O
all_cfi_sections	O
&	O
CFI_EMIT_eh_frame_compact	O
)	O
!=	O
0	int
)	O
{	O
save_flag_traditional_format	O
=	O
flag_traditional_format	O
;	O
flag_traditional_format	O
=	O
1	int
;	O
if	O
(	O
!	O
EH_FRAME_LINKONCE	O
)	O
{	O
cfi_seg	O
=	O
get_cfi_seg	O
(	O
NULL	O
,	O
".eh_frame"	*(char)
,	O
(	O
SEC_ALLOC	O
|	O
SEC_LOAD	O
|	O
SEC_DATA	O
|	O
DWARF2_EH_FRAME_READ_ONLY	O
)	O
,	O
EH_FRAME_ALIGNMENT	O
)	O
;	O
(	O
void	O
)	O
cfi_seg	O
;	O
}	O
do	O
{	O
ccseg	O
=	O
NULL	O
;	O
seek_next_seg	O
=	O
0	int
;	O
for	O
(	O
cie	O
=	O
cie_root	O
;	O
cie	O
;	O
cie	O
=	O
cie_next	O
)	O
{	O
cie_next	O
=	O
cie	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
cie	O
)	O
;	O
}	O
cie_root	O
=	O
NULL	O
;	O
for	O
(	O
fde	O
=	O
all_fde_data	O
;	O
fde	O
;	O
fde	O
=	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
(	O
fde	O
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
&	O
CFI_EMIT_eh_frame	O
)	O
==	O
0	int
&&	O
(	O
fde	O
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
&	O
CFI_EMIT_eh_frame_compact	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
EH_FRAME_LINKONCE	O
)	O
{	O
if	O
(	O
HANDLED	O
(	O
fde	O
)	O
)	O
continue	O
;	O
if	O
(	O
seek_next_seg	O
&&	O
CUR_SEG	O
(	O
fde	O
)	O
!=	O
ccseg	O
)	O
{	O
seek_next_seg	O
=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
seek_next_seg	O
)	O
{	O
ccseg	O
=	O
CUR_SEG	O
(	O
fde	O
)	O
;	O
cfi_seg	O
=	O
get_cfi_seg	O
(	O
ccseg	O
,	O
".eh_frame"	*(char)
,	O
(	O
SEC_ALLOC	O
|	O
SEC_LOAD	O
|	O
SEC_DATA	O
|	O
DWARF2_EH_FRAME_READ_ONLY	O
)	O
,	O
EH_FRAME_ALIGNMENT	O
)	O
;	O
(	O
void	O
)	O
cfi_seg	O
;	O
seek_next_seg	O
=	O
1	int
;	O
}	O
SET_HANDLED	O
(	O
fde	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
fde	O
->	O
end_address	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"open CFI at the end of file; "	*(char)
"missing .cfi_endproc directive"	*(char)
)	O
)	O
;	O
fde	O
->	O
end_address	O
=	O
fde	O
->	O
start_address	long
;	O
}	O
cie	O
=	O
select_cie_for_fde	O
(	O
fde	O
,	O
TRUE	int
,	O
&	O
first	O
,	O
2	int
)	O
;	O
fde	O
->	O
eh_loc	O
=	O
symbol_temp_new_now	O
(	O
)	O
;	O
output_fde	O
(	O
fde	O
,	O
cie	O
,	O
TRUE	int
,	O
first	O
,	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
==	O
NULL	O
?	O
EH_FRAME_ALIGNMENT	O
:	O
2	int
)	O
;	O
}	O
}	O
while	O
(	O
EH_FRAME_LINKONCE	O
&&	O
seek_next_seg	O
==	O
2	int
)	O
;	O
if	O
(	O
EH_FRAME_LINKONCE	O
)	O
for	O
(	O
fde	O
=	O
all_fde_data	O
;	O
fde	O
;	O
fde	O
=	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
SET_HANDLED	O
(	O
fde	O
,	O
0	int
)	O
;	O
flag_traditional_format	O
=	O
save_flag_traditional_format	O
;	O
}	O
cfi_sections_set	O
=	O
TRUE	int
;	O
if	O
(	O
(	O
all_cfi_sections	O
&	O
CFI_EMIT_debug_frame	O
)	O
!=	O
0	int
)	O
{	O
int	O
alignment	O
=	O
ffs	(int)->(int)
(	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	O
)	O
)	O
-	O
1	int
;	O
if	O
(	O
!	O
SUPPORT_FRAME_LINKONCE	int
)	O
get_cfi_seg	O
(	O
NULL	O
,	O
".debug_frame"	*(char)
,	O
SEC_READONLY	O
|	O
SEC_DEBUGGING	O
,	O
alignment	O
)	O
;	O
do	O
{	O
ccseg	O
=	O
NULL	O
;	O
seek_next_seg	O
=	O
0	int
;	O
for	O
(	O
cie	O
=	O
cie_root	O
;	O
cie	O
;	O
cie	O
=	O
cie_next	O
)	O
{	O
cie_next	O
=	O
cie	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
cie	O
)	O
;	O
}	O
cie_root	O
=	O
NULL	O
;	O
for	O
(	O
fde	O
=	O
all_fde_data	O
;	O
fde	O
;	O
fde	O
=	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
(	O
fde	O
->	O
sections	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
&	O
CFI_EMIT_debug_frame	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
)	O
{	O
if	O
(	O
HANDLED	O
(	O
fde	O
)	O
)	O
continue	O
;	O
if	O
(	O
seek_next_seg	O
&&	O
CUR_SEG	O
(	O
fde	O
)	O
!=	O
ccseg	O
)	O
{	O
seek_next_seg	O
=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
seek_next_seg	O
)	O
{	O
ccseg	O
=	O
CUR_SEG	O
(	O
fde	O
)	O
;	O
get_cfi_seg	O
(	O
ccseg	O
,	O
".debug_frame"	*(char)
,	O
SEC_READONLY	O
|	O
SEC_DEBUGGING	O
,	O
alignment	O
)	O
;	O
seek_next_seg	O
=	O
1	int
;	O
}	O
SET_HANDLED	O
(	O
fde	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
fde	O
->	O
end_address	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"open CFI at the end of file; "	*(char)
"missing .cfi_endproc directive"	*(char)
)	O
)	O
;	O
fde	O
->	O
end_address	O
=	O
fde	O
->	O
start_address	long
;	O
}	O
fde	O
->	O
per_encoding	O
=	O
DW_EH_PE_omit	O
;	O
fde	O
->	O
lsda_encoding	O
=	O
DW_EH_PE_omit	O
;	O
cfi_change_reg_numbers	O
(	O
fde	O
->	O
data	*(void)
,	O
ccseg	O
)	O
;	O
cie	O
=	O
select_cie_for_fde	O
(	O
fde	O
,	O
FALSE	O
,	O
&	O
first	O
,	O
alignment	O
)	O
;	O
output_fde	O
(	O
fde	O
,	O
cie	O
,	O
FALSE	O
,	O
first	O
,	O
alignment	O
)	O
;	O
}	O
}	O
while	O
(	O
SUPPORT_FRAME_LINKONCE	int
&&	O
seek_next_seg	O
==	O
2	int
)	O
;	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
)	O
for	O
(	O
fde	O
=	O
all_fde_data	O
;	O
fde	O
;	O
fde	O
=	O
fde	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
SET_HANDLED	O
(	O
fde	O
,	O
0	int
)	O
;	O
}	O
}	O
