mp_limb_t	long
mpn_mu_divappr_q	O
(	O
mp_ptr	*(long)
qp	*(long)
,	O
mp_srcptr	*(long)
np	*(long)
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	*(long)
dp	*(long)
,	O
mp_size_t	long
dn	long
,	O
mp_ptr	*(long)
scratch	*(long)
)	O
{	O
mp_size_t	long
qn	long
,	O
in	long
;	O
mp_limb_t	long
cy	long
,	O
qh	long
;	O
mp_ptr	*(long)
ip	*(long)
,	O
tp	*(long)
;	O
ASSERT	O
(	O
dn	long
>	O
1	int
)	O
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
if	O
(	O
qn	long
+	O
1	int
<	O
dn	long
)	O
{	O
np	*(long)
+=	O
dn	long
-	O
(	O
qn	long
+	O
1	int
)	O
;	O
nn	long
-=	O
dn	long
-	O
(	O
qn	long
+	O
1	int
)	O
;	O
dp	*(long)
+=	O
dn	long
-	O
(	O
qn	long
+	O
1	int
)	O
;	O
dn	long
=	O
qn	long
+	O
1	int
;	O
}	O
in	long
=	O
mpn_mu_divappr_q_choose_in	O
(	O
qn	long
,	O
dn	long
,	O
0	int
)	O
;	O
ASSERT	O
(	O
in	long
<=	O
dn	long
)	O
;	O
ip	*(long)
=	O
scratch	*(long)
;	O
tp	*(long)
=	O
scratch	*(long)
+	O
in	long
+	O
1	int
;	O
if	O
(	O
dn	long
==	O
in	long
)	O
{	O
MPN_COPY	O
(	O
tp	*(long)
+	O
1	int
,	O
dp	*(long)
,	O
in	long
)	O
;	O
tp	*(long)
[	O
0	int
]	O
=	O
1	int
;	O
mpn_invertappr	O
(	O
ip	*(long)
,	O
tp	*(long)
,	O
in	long
+	O
1	int
,	O
NULL	O
)	O
;	O
MPN_COPY_INCR	O
(	O
ip	*(long)
,	O
ip	*(long)
+	O
1	int
,	O
in	long
)	O
;	O
}	O
else	O
{	O
cy	long
=	O
mpn_add_1	O
(	O
tp	*(long)
,	O
dp	*(long)
+	O
dn	long
-	O
(	O
in	long
+	O
1	int
)	O
,	O
in	long
+	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
cy	long
!=	O
0	int
)	O
)	O
MPN_ZERO	O
(	O
ip	*(long)
,	O
in	long
)	O
;	O
else	O
{	O
mpn_invertappr	O
(	O
ip	*(long)
,	O
tp	*(long)
,	O
in	long
+	O
1	int
,	O
NULL	O
)	O
;	O
MPN_COPY_INCR	O
(	O
ip	*(long)
,	O
ip	*(long)
+	O
1	int
,	O
in	long
)	O
;	O
}	O
}	O
qh	long
=	O
mpn_preinv_mu_divappr_q	O
(	O
qp	*(long)
,	O
np	*(long)
,	O
nn	long
,	O
dp	*(long)
,	O
dn	long
,	O
ip	*(long)
,	O
in	long
,	O
scratch	*(long)
+	O
in	long
)	O
;	O
return	O
qh	long
;	O
}	O
mp_limb_t	long
mpn_preinv_mu_divappr_q	O
(	O
mp_ptr	*(long)
qp	*(long)
,	O
mp_srcptr	*(long)
np	*(long)
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	*(long)
dp	*(long)
,	O
mp_size_t	long
dn	long
,	O
mp_srcptr	*(long)
ip	*(long)
,	O
mp_size_t	long
in	long
,	O
mp_ptr	*(long)
scratch	*(long)
)	O
{	O
mp_size_t	long
qn	long
;	O
mp_limb_t	long
cy	long
,	O
cx	long
,	O
qh	long
;	O
mp_limb_t	long
r	long
;	O
mp_size_t	long
tn	long
,	O
wn	long
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
np	*(long)
+=	O
qn	long
;	O
qp	*(long)
+=	O
qn	long
;	O
qh	long
=	O
mpn_cmp	O
(	O
np	*(long)
,	O
dp	*(long)
,	O
dn	long
)	O
>=	O
0	int
;	O
if	O
(	O
qh	long
!=	O
0	int
)	O
mpn_sub_n	O
(	O
rp	O
,	O
np	*(long)
,	O
dp	*(long)
,	O
dn	long
)	O
;	O
else	O
MPN_COPY	O
(	O
rp	O
,	O
np	*(long)
,	O
dn	long
)	O
;	O
if	O
(	O
qn	long
==	O
0	int
)	O
return	O
qh	long
;	O
while	O
(	O
qn	long
>	O
0	int
)	O
{	O
if	O
(	O
qn	long
<	O
in	long
)	O
{	O
ip	*(long)
+=	O
in	long
-	O
qn	long
;	O
in	long
=	O
qn	long
;	O
}	O
np	*(long)
-=	O
in	long
;	O
qp	*(long)
-=	O
in	long
;	O
mpn_mul_n	O
(	O
tp	*(long)
,	O
rp	O
+	O
dn	long
-	O
in	long
,	O
ip	*(long)
,	O
in	long
)	O
;	O
cy	long
=	O
mpn_add_n	O
(	O
qp	*(long)
,	O
tp	*(long)
+	O
in	long
,	O
rp	O
+	O
dn	long
-	O
in	long
,	O
in	long
)	O
;	O
ASSERT_ALWAYS	O
(	O
cy	long
==	O
0	int
)	O
;	O
qn	long
-=	O
in	long
;	O
if	O
(	O
qn	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	long
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	O
)	O
)	O
mpn_mul	O
(	O
tp	*(long)
,	O
dp	*(long)
,	O
dn	long
,	O
qp	*(long)
,	O
in	long
)	O
;	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
dn	long
+	O
1	int
)	O
;	O
mpn_mulmod_bnm1	O
(	O
tp	*(long)
,	O
tn	long
,	O
dp	*(long)
,	O
dn	long
,	O
qp	*(long)
,	O
in	long
,	O
scratch_out	O
)	O
;	O
wn	long
=	O
dn	long
+	O
in	long
-	O
tn	long
;	O
if	O
(	O
wn	long
>	O
0	int
)	O
{	O
cy	long
=	O
mpn_sub_n	O
(	O
tp	*(long)
,	O
tp	*(long)
,	O
rp	O
+	O
dn	long
-	O
wn	long
,	O
wn	long
)	O
;	O
cy	long
=	O
mpn_sub_1	O
(	O
tp	*(long)
+	O
wn	long
,	O
tp	*(long)
+	O
wn	long
,	O
tn	long
-	O
wn	long
,	O
cy	long
)	O
;	O
cx	long
=	O
mpn_cmp	O
(	O
rp	O
+	O
dn	long
-	O
in	long
,	O
tp	*(long)
+	O
dn	long
,	O
tn	long
-	O
dn	long
)	O
<	O
0	int
;	O
ASSERT_ALWAYS	O
(	O
cx	long
>=	O
cy	long
)	O
;	O
mpn_incr_u	O
(	O
tp	*(long)
,	O
cx	long
-	O
cy	long
)	O
;	O
}	O
}	O
r	long
=	O
rp	O
[	O
dn	long
-	O
in	long
]	O
-	O
tp	*(long)
[	O
dn	long
]	O
;	O
if	O
(	O
dn	long
!=	O
in	long
)	O
{	O
cy	long
=	O
mpn_sub_n	O
(	O
tp	*(long)
,	O
np	*(long)
,	O
tp	*(long)
,	O
in	long
)	O
;	O
cy	long
=	O
mpn_sub_nc	O
(	O
tp	*(long)
+	O
in	long
,	O
rp	O
,	O
tp	*(long)
+	O
in	long
,	O
dn	long
-	O
in	long
,	O
cy	long
)	O
;	O
MPN_COPY	O
(	O
rp	O
,	O
tp	*(long)
,	O
dn	long
)	O
;	O
}	O
else	O
{	O
cy	long
=	O
mpn_sub_n	O
(	O
rp	O
,	O
np	*(long)
,	O
tp	*(long)
,	O
in	long
)	O
;	O
}	O
STAT	O
(	O
int	O
i	long
;	O
int	O
err	O
=	O
0	int
;	O
static	O
int	O
errarr	O
[	O
5	int
]	O
;	O
static	O
int	O
err_rec	O
;	O
static	O
int	O
tot	O
)	O
;	O
r	long
-=	O
cy	long
;	O
while	O
(	O
r	long
!=	O
0	int
)	O
{	O
mpn_incr_u	O
(	O
qp	*(long)
,	O
1	int
)	O
;	O
cy	long
=	O
mpn_sub_n	O
(	O
rp	O
,	O
rp	O
,	O
dp	*(long)
,	O
dn	long
)	O
;	O
r	long
-=	O
cy	long
;	O
STAT	O
(	O
err	O
++	O
)	O
;	O
}	O
if	O
(	O
mpn_cmp	O
(	O
rp	O
,	O
dp	*(long)
,	O
dn	long
)	O
>=	O
0	int
)	O
{	O
mpn_incr_u	O
(	O
qp	*(long)
,	O
1	int
)	O
;	O
cy	long
=	O
mpn_sub_n	O
(	O
rp	O
,	O
rp	O
,	O
dp	*(long)
,	O
dn	long
)	O
;	O
STAT	O
(	O
err	O
++	O
)	O
;	O
}	O
STAT	O
(	O
tot	O
++	O
;	O
errarr	O
[	O
err	O
]	O
++	O
;	O
if	O
(	O
err	O
>	O
err_rec	O
)	O
err_rec	O
=	O
err	O
;	O
if	O
(	O
tot	O
%	O
0x10000	int
==	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
err_rec	O
;	O
i	long
++	O
)	O
printf	O
(	O
"  %d(%.1f%%)"	*(char)
,	O
errarr	O
[	O
i	long
]	O
,	O
100.0	int
*	O
errarr	O
[	O
i	long
]	O
/	O
tot	O
)	O
;	O
printf	O
(	O
"\n"	*(char)
)	O
;	O
}	O
)	O
;	O
}	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
cy	long
+=	O
mpn_add_1	O
(	O
qp	*(long)
,	O
qp	*(long)
,	O
qn	long
,	O
3	int
)	O
;	O
if	O
(	O
cy	long
!=	O
0	int
)	O
{	O
if	O
(	O
qh	long
!=	O
0	int
)	O
{	O
mp_size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
qn	long
;	O
i	long
++	O
)	O
qp	*(long)
[	O
i	long
]	O
=	O
GMP_NUMB_MAX	O
;	O
}	O
else	O
{	O
qh	long
=	O
1	int
;	O
}	O
}	O
return	O
qh	long
;	O
}	O
mp_size_t	long
mpn_mu_divappr_q_choose_in	O
(	O
mp_size_t	long
qn	long
,	O
mp_size_t	long
dn	long
,	O
int	O
k	int
)	O
{	O
mp_size_t	long
in	long
;	O
if	O
(	O
k	int
==	O
0	int
)	O
{	O
mp_size_t	long
b	int
;	O
if	O
(	O
qn	long
>	O
dn	long
)	O
{	O
b	int
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
dn	long
+	O
1	int
;	O
in	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
b	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
3	int
*	O
qn	long
>	O
dn	long
)	O
{	O
in	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
2	int
+	O
1	int
;	O
}	O
else	O
{	O
in	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
1	int
+	O
1	int
;	O
}	O
}	O
else	O
{	O
mp_size_t	long
xn	long
;	O
xn	long
=	O
MIN	O
(	O
dn	long
,	O
qn	long
)	O
;	O
in	long
=	O
(	O
xn	long
-	O
1	int
)	O
/	O
k	int
+	O
1	int
;	O
}	O
return	O
in	long
;	O
}	O
mp_size_t	long
mpn_mu_divappr_q_itch	O
(	O
mp_size_t	long
nn	long
,	O
mp_size_t	long
dn	long
,	O
int	O
mua_k	int
)	O
{	O
mp_size_t	long
qn	long
,	O
in	long
,	O
itch_local	long
,	O
itch_out	long
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
if	O
(	O
qn	long
+	O
1	int
<	O
dn	long
)	O
{	O
dn	long
=	O
qn	long
+	O
1	int
;	O
}	O
in	long
=	O
mpn_mu_divappr_q_choose_in	O
(	O
qn	long
,	O
dn	long
,	O
mua_k	int
)	O
;	O
itch_local	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
dn	long
+	O
1	int
)	O
;	O
itch_out	long
=	O
mpn_mulmod_bnm1_itch	(long,long,long)->(long)
(	O
itch_local	long
,	O
dn	long
,	O
in	long
)	O
;	O
return	O
in	long
+	O
dn	long
+	O
itch_local	long
+	O
itch_out	long
;	O
}	O
