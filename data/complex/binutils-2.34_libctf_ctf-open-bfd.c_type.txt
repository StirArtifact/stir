static	O
struct	O
ctf_archive_internal	O
*	O
ctf_new_archive_internal	O
(	O
int	O
is_archive	O
,	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
struct	O
ctf_archive_internal	O
*	O
arci	O
;	O
if	O
(	O
(	O
arci	O
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ctf_archive_internal	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
is_archive	O
)	O
ctf_arc_close_internal	O
(	O
arc	O
)	O
;	O
else	O
ctf_file_close	(*(struct))->(void)
(	O
fp	*(struct)
)	O
;	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
errno	O
)	O
)	O
;	O
}	O
arci	O
->	O
ctfi_is_archive	O
=	O
is_archive	O
;	O
if	O
(	O
is_archive	O
)	O
arci	O
->	O
ctfi_archive	O
=	O
arc	O
;	O
else	O
arci	O
->	O
ctfi_file	O
=	O
fp	*(struct)
;	O
if	O
(	O
symsect	O
)	O
memcpy	O
(	O
&	O
arci	O
->	O
ctfi_symsect	O
,	O
symsect	O
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct(*(char),*(void),long,long)
)	O
)	O
;	O
if	O
(	O
strsect	O
)	O
memcpy	O
(	O
&	O
arci	O
->	O
ctfi_strsect	O
,	O
strsect	O
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct(*(char),*(void),long,long)
)	O
)	O
;	O
return	O
arci	O
;	O
}	O
static	O
void	O
ctf_bfdclose	O
(	O
struct	O
ctf_archive_internal	O
*	O
arci	O
)	O
{	O
if	O
(	O
arci	O
->	O
ctfi_abfd	O
!=	O
NULL	O
)	O
if	O
(	O
!	O
bfd_close_all_done	(*(struct))->(int)
(	O
arci	O
->	O
ctfi_abfd	O
)	O
)	O
ctf_dprintf	O
(	O
"Cannot close BFD: %s\n"	*(char)
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_bfdopen	(*(struct),*(int))->(*(struct))
(	O
struct	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
ctf_archive_t	struct
*	O
arc	O
;	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
ctf_asect	O
;	O
bfd_byte	char
*	O
contents	*(char)
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
ctfsect	O
;	O
libctf_init_debug	O
(	O
)	O
;	O
if	O
(	O
(	O
ctf_asect	O
=	O
bfd_get_section_by_name	(*(struct),*(char))->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
_CTF_SECTION	O
)	O
)	O
==	O
NULL	O
)	O
{	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_NOCTFDATA	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
bfd_malloc_and_get_section	(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(*(char)))->(int)
(	O
abfd	*(struct)
,	O
ctf_asect	O
,	O
&	O
contents	*(char)
)	O
)	O
{	O
ctf_dprintf	O
(	O
"ctf_bfdopen(): cannot malloc CTF section: %s\n"	*(char)
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
ctfsect	O
.	O
cts_name	*(char)
=	O
_CTF_SECTION	O
;	O
ctfsect	O
.	O
cts_entsize	long
=	O
1	int
;	O
ctfsect	O
.	O
cts_size	long
=	O
bfd_section_size	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(long)
(	O
ctf_asect	O
)	O
;	O
ctfsect	O
.	O
cts_data	*(void)
=	O
contents	*(char)
;	O
if	O
(	O
(	O
arc	O
=	O
ctf_bfdopen_ctfsect	(*(struct),*(struct(*(char),*(void),long,long)),*(int))->(*(struct))
(	O
abfd	*(struct)
,	O
&	O
ctfsect	O
,	O
errp	*(int)
)	O
)	O
!=	O
NULL	O
)	O
{	O
arc	O
->	O
ctfi_data	O
=	O
(	O
void	O
*	O
)	O
ctfsect	O
.	O
cts_data	*(void)
;	O
return	O
arc	O
;	O
}	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_bfdopen_ctfsect	(*(struct),*(struct(*(char),*(void),long,long)),*(int))->(*(struct))
(	O
struct	O
bfd	struct
*	O
abfd	*(struct)
_libctf_unused_	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
ctfsect	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
=	O
NULL	O
;	O
ctf_archive_t	struct
*	O
arci	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
NULL	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsectp	O
=	O
NULL	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsectp	O
=	O
NULL	O
;	O
const	O
char	O
*	O
bfderrstr	O
=	O
NULL	O
;	O
int	O
is_archive	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
symsect	O
,	O
strsect	O
;	O
Elf_Internal_Shdr	O
*	O
strhdr	O
;	O
Elf_Internal_Shdr	O
*	O
symhdr	O
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	*(struct)
)	O
;	O
size_t	long
symcount	int
=	O
symhdr	O
->	O
sh_size	array(char)
/	O
symhdr	O
->	O
sh_entsize	array(char)
;	O
Elf_Internal_Sym	O
*	O
isymbuf	O
;	O
bfd_byte	char
*	O
symtab	O
;	O
const	O
char	O
*	O
strtab	O
=	O
NULL	O
;	O
if	O
(	O
(	O
symtab	O
=	O
malloc	(long)->(*(void))
(	O
symhdr	O
->	O
sh_size	array(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
bfderrstr	O
=	O
"Cannot malloc symbol table"	*(char)
;	O
goto	O
err	long
;	O
}	O
isymbuf	O
=	O
bfd_elf_get_elf_syms	O
(	O
abfd	*(struct)
,	O
symhdr	O
,	O
symcount	int
,	O
0	int
,	O
NULL	O
,	O
symtab	O
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
isymbuf	O
)	O
;	O
if	O
(	O
isymbuf	O
==	O
NULL	O
)	O
{	O
bfderrstr	O
=	O
"Cannot read symbol table"	*(char)
;	O
goto	O
err_free_sym	O
;	O
}	O
if	O
(	O
elf_elfsections	O
(	O
abfd	*(struct)
)	O
!=	O
NULL	O
&&	O
symhdr	O
->	O
sh_link	array(char)
<	O
elf_numsections	O
(	O
abfd	*(struct)
)	O
)	O
{	O
strhdr	O
=	O
elf_elfsections	O
(	O
abfd	*(struct)
)	O
[	O
symhdr	O
->	O
sh_link	array(char)
]	O
;	O
if	O
(	O
strhdr	O
->	O
contents	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
strtab	O
=	O
bfd_elf_get_str_section	O
(	O
abfd	*(struct)
,	O
symhdr	O
->	O
sh_link	array(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
bfderrstr	O
=	O
"Cannot read string table"	*(char)
;	O
goto	O
err_free_sym	O
;	O
}	O
}	O
else	O
strtab	O
=	O
(	O
const	O
char	O
*	O
)	O
strhdr	O
->	O
contents	*(char)
;	O
}	O
if	O
(	O
strtab	O
)	O
{	O
strsect	O
.	O
cts_data	*(void)
=	O
strtab	O
;	O
strsect	O
.	O
cts_name	*(char)
=	O
".strtab"	*(char)
;	O
strsect	O
.	O
cts_size	long
=	O
strhdr	O
->	O
sh_size	array(char)
;	O
strsectp	O
=	O
&	O
strsect	O
;	O
assert	O
(	O
symhdr	O
->	O
sh_entsize	array(char)
==	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
s	*(char)
->	O
sizeof_sym	O
)	O
;	O
symsect	O
.	O
cts_name	*(char)
=	O
".symtab"	*(char)
;	O
symsect	O
.	O
cts_entsize	long
=	O
symhdr	O
->	O
sh_entsize	array(char)
;	O
symsect	O
.	O
cts_size	long
=	O
symhdr	O
->	O
sh_size	array(char)
;	O
symsect	O
.	O
cts_data	*(void)
=	O
symtab	O
;	O
symsectp	O
=	O
&	O
symsect	O
;	O
}	O
if	O
(	O
ctfsect	O
->	O
cts_size	long
>	O
sizeof	O
(	O
uint64_t	long
)	O
&&	O
(	O
(	O
*	O
(	O
uint64_t	long
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
)	O
==	O
CTFA_MAGIC	O
)	O
)	O
{	O
is_archive	O
=	O
1	int
;	O
if	O
(	O
(	O
arc	O
=	O
ctf_arc_bufopen	O
(	O
(	O
void	O
*	O
)	O
ctfsect	O
->	O
cts_data	*(void)
,	O
ctfsect	O
->	O
cts_size	long
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
goto	O
err_free_str	O
;	O
}	O
else	O
{	O
is_archive	O
=	O
0	int
;	O
if	O
(	O
(	O
fp	*(struct)
=	O
ctf_bufopen	(*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(int))->(*(struct))
(	O
ctfsect	O
,	O
symsectp	O
,	O
strsectp	O
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	O
(	O
"ctf_internal_open(): cannot open CTF: %s\n"	*(char)
,	O
ctf_errmsg	(int)->(*(char))
(	O
*	O
errp	*(int)
)	O
)	O
;	O
goto	O
err_free_str	O
;	O
}	O
}	O
arci	O
=	O
ctf_new_archive_internal	O
(	O
is_archive	O
,	O
arc	O
,	O
fp	*(struct)
,	O
symsectp	O
,	O
strsectp	O
,	O
errp	*(int)
)	O
;	O
if	O
(	O
arci	O
)	O
return	O
arci	O
;	O
err_free_str	O
:	O
;	O
err_free_sym	O
:	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
err	long
:	O
_libctf_unused_	O
;	O
if	O
(	O
bfderrstr	O
)	O
{	O
ctf_dprintf	O
(	O
"ctf_bfdopen(): %s: %s\n"	*(char)
,	O
bfderrstr	O
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_FMT	int
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_fdopen	(int,*(char),*(char),*(int))->(*(struct))
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
target	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
ctf_archive_t	struct
*	O
arci	O
;	O
bfd	struct
*	O
abfd	*(struct)
;	O
int	O
nfd	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	O
;	O
ssize_t	long
nbytes	long
;	O
ctf_preamble_t	struct(short,char,char)
ctfhdr	O
;	O
uint64_t	long
arc_magic	O
;	O
memset	O
(	O
&	O
ctfhdr	O
,	O
0	int
,	O
sizeof	O
(	O
ctfhdr	O
)	O
)	O
;	O
libctf_init_debug	O
(	O
)	O
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
nbytes	long
=	O
ctf_pread	O
(	O
fd	int
,	O
&	O
ctfhdr	O
,	O
sizeof	O
(	O
ctfhdr	O
)	O
,	O
0	int
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
nbytes	long
<	O
0	int
?	O
errno	O
:	O
ECTF_FMT	int
)	O
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
nbytes	long
>=	O
sizeof	O
(	O
ctf_preamble_t	struct(short,char,char)
)	O
&&	O
(	O
ctfhdr	O
.	O
ctp_magic	short
==	O
CTF_MAGIC	O
||	O
ctfhdr	O
.	O
ctp_magic	short
==	O
bswap_16	O
(	O
CTF_MAGIC	O
)	O
)	O
)	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
NULL	O
;	O
void	O
*	O
data	*(void)
;	O
if	O
(	O
(	O
data	*(void)
=	O
ctf_mmap	O
(	O
st	O
.	O
st_size	array(char)
,	O
0	int
,	O
fd	int
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
fp	*(struct)
=	O
ctf_simple_open	(*(char),long,*(char),long,long,*(char),long,*(int))->(*(struct))
(	O
data	*(void)
,	O
(	O
size_t	long
)	O
st	O
.	O
st_size	array(char)
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_munmap	O
(	O
data	*(void)
,	O
(	O
size_t	long
)	O
st	O
.	O
st_size	array(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
fp	*(struct)
->	O
ctf_data_mmapped	O
=	O
data	*(void)
;	O
fp	*(struct)
->	O
ctf_data_mmapped_len	O
=	O
(	O
size_t	long
)	O
st	O
.	O
st_size	array(char)
;	O
return	O
ctf_new_archive_internal	O
(	O
0	int
,	O
NULL	O
,	O
fp	*(struct)
,	O
NULL	O
,	O
NULL	O
,	O
errp	*(int)
)	O
;	O
}	O
if	O
(	O
(	O
nbytes	long
=	O
ctf_pread	O
(	O
fd	int
,	O
&	O
arc_magic	O
,	O
sizeof	O
(	O
arc_magic	O
)	O
,	O
0	int
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
nbytes	long
<	O
0	int
?	O
errno	O
:	O
ECTF_FMT	int
)	O
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
nbytes	long
>=	O
sizeof	O
(	O
uint64_t	long
)	O
&&	O
le64toh	O
(	O
arc_magic	O
)	O
==	O
CTFA_MAGIC	O
)	O
{	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
;	O
if	O
(	O
(	O
arc	O
=	O
ctf_arc_open_internal	O
(	O
filename	*(char)
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
ctf_new_archive_internal	O
(	O
1	int
,	O
arc	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
errp	*(int)
)	O
;	O
}	O
if	O
(	O
(	O
nfd	O
=	O
dup	(int)->(int)
(	O
fd	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
abfd	*(struct)
=	O
bfd_fdopenr	(*(char),*(char),int)->(*(struct))
(	O
filename	*(char)
,	O
target	*(char)
,	O
nfd	O
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	O
(	O
"Cannot open BFD from %s: %s\n"	*(char)
,	O
filename	*(char)
?	O
filename	*(char)
:	O
"(unknown file)"	*(char)
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
bfd_set_cacheable	(*(struct(*(char),*(struct),*(void),*(struct),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),long,long,struct(*(*`),*((*`,*`,*`)->(*`)),*(void),int,int,int,int),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,long,*(*(struct`)),int,int,*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*`,*`,int,int,*`,*`,*`,*`,int)),*(void),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(void)),*(void),*(void),*(struct(long,array(char))))),int)->(int)
(	O
abfd	*(struct)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
bfd_check_format	O
(	O
abfd	*(struct)
,	O
bfd_object	int
)	O
)	O
{	O
ctf_dprintf	O
(	O
"BFD format problem in %s: %s\n"	*(char)
,	O
filename	*(char)
?	O
filename	*(char)
:	O
"(unknown file)"	*(char)
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
if	O
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_BFD_AMBIGUOUS	int
)	O
)	O
;	O
else	O
return	O
(	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
arci	O
=	O
ctf_bfdopen	(*(struct),*(int))->(*(struct))
(	O
abfd	*(struct)
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bfd_close_all_done	(*(struct))->(int)
(	O
abfd	*(struct)
)	O
)	O
ctf_dprintf	O
(	O
"Cannot close BFD: %s\n"	*(char)
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
arci	O
->	O
ctfi_bfd_close	O
=	O
ctf_bfdclose	O
;	O
arci	O
->	O
ctfi_abfd	O
=	O
abfd	*(struct)
;	O
return	O
arci	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_open	(*(char),*(char),*(int))->(*(struct))
(	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
target	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
ctf_archive_t	struct
*	O
arc	O
;	O
int	O
fd	int
;	O
if	O
(	O
(	O
fd	int
=	O
open	O
(	O
filename	*(char)
,	O
O_RDONLY	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errp	*(int)
!=	O
NULL	O
)	O
*	O
errp	*(int)
=	O
errno	O
;	O
return	O
NULL	O
;	O
}	O
arc	O
=	O
ctf_fdopen	(int,*(char),*(char),*(int))->(*(struct))
(	O
fd	int
,	O
filename	*(char)
,	O
target	*(char)
,	O
errp	*(int)
)	O
;	O
(	O
void	O
)	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
arc	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_arc_open	(*(char),*(int))->(*(struct))
(	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
return	O
ctf_open	(*(char),*(char),*(int))->(*(struct))
(	O
filename	*(char)
,	O
NULL	O
,	O
errp	*(int)
)	O
;	O
}	O
