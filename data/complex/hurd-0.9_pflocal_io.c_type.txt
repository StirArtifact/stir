error_t	O
S_io_read	(*(struct),*(*(char)),*(int),long,int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
char	O
*	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
*	O
data_len	*(int)
,	O
off_t	long
offset	long
,	O
mach_msg_type_number_t	O
amount	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
pipe	(array(int))->(int)
*	O
pipe	(array(int))->(int)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_acquire_read_pipe	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
&	O
pipe	(array(int))->(int)
)	O
;	O
if	O
(	O
err	O
==	O
EPIPE	O
)	O
{	O
err	O
=	O
0	int
;	O
*	O
data_len	*(int)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
err	O
=	O
pipe_read	()->(int)
(	O
pipe	(array(int))->(int)
,	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	O
,	O
NULL	O
,	O
data	*(*(char))
,	O
data_len	*(int)
,	O
amount	int
)	O
;	O
pipe_release_reader	()->(int)
(	O
pipe	(array(int))->(int)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_io_write	(*(struct),*(char),int,long,*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
char	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
data_len	*(int)
,	O
off_t	long
offset	long
,	O
mach_msg_type_number_t	O
*	O
amount	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
pipe	(array(int))->(int)
*	O
pipe	(array(int))->(int)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_acquire_write_pipe	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
&	O
pipe	(array(int))->(int)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
addr	O
*	O
source_addr	*(struct)
;	O
if	O
(	O
pipe	(array(int))->(int)
->	O
class	O
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_get_addr	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
&	O
source_addr	*(struct)
)	O
;	O
else	O
source_addr	*(struct)
=	O
NULL	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
err	O
=	O
pipe_write	()->(int)
(	O
pipe	(array(int))->(int)
,	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	O
,	O
source_addr	*(struct)
,	O
data	*(*(char))
,	O
data_len	*(int)
,	O
amount	int
)	O
;	O
if	O
(	O
err	O
&&	O
source_addr	*(struct)
)	O
ports_port_deref	()->(int)
(	O
source_addr	*(struct)
)	O
;	O
}	O
pipe_release_writer	()->(int)
(	O
pipe	(array(int))->(int)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_io_readable	(*(struct),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_msg_type_number_t	O
*	O
amount	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
pipe	(array(int))->(int)
*	O
pipe	(array(int))->(int)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_acquire_read_pipe	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
&	O
pipe	(array(int))->(int)
)	O
;	O
if	O
(	O
err	O
==	O
EPIPE	O
)	O
{	O
err	O
=	O
0	int
;	O
*	O
amount	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
amount	int
=	O
pipe_readable	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
->	O
read_pipe	*(struct)
,	O
1	int
)	O
;	O
pipe_release_reader	()->(int)
(	O
pipe	(array(int))->(int)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_io_seek	(*(struct),long,int,*(long))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
off_t	long
offset	long
,	O
int	O
whence	int
,	O
off_t	long
*	O
new_offset	*(long)
)	O
{	O
return	O
user	*(struct)
?	O
ESPIPE	O
:	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_duplicate	(*(struct),*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
new_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
new_port_type	*(int)
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_create_port	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
new_port	*(int)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
new_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct(long,long)
*	O
tsp	*(struct(long,long))
,	O
int	O
*	O
select_type	*(int)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
select_type	*(int)
&=	O
SELECT_READ	int
|	O
SELECT_WRITE	int
;	O
sock	*(struct)
=	O
user	*(struct)
->	O
sock	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
sock	*(struct)
->	O
listen_queue	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
*	O
select_type	*(int)
&=	O
SELECT_READ	int
;	O
if	O
(	O
*	O
select_type	*(int)
&	O
SELECT_READ	int
)	O
{	O
struct	O
timespec	struct(long,long)
noblock	struct(long,long)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
connq_listen	()->(int)
(	O
sock	*(struct)
->	O
listen_queue	O
,	O
&	O
noblock	struct(long,long)
,	O
NULL	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
else	O
{	O
ports_interrupt_self_on_port_death	()->(int)
(	O
user	*(struct)
,	O
reply	int
)	O
;	O
err	O
=	O
connq_listen	()->(int)
(	O
sock	*(struct)
->	O
listen_queue	O
,	O
tsp	*(struct(long,long))
,	O
NULL	O
)	O
;	O
if	O
(	O
err	O
==	O
ETIMEDOUT	O
)	O
{	O
*	O
select_type	*(int)
=	O
0	int
;	O
err	O
=	O
0	int
;	O
}	O
return	O
err	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
valid	int
;	O
int	O
ready	int
=	O
0	int
;	O
struct	O
pipe	(array(int))->(int)
*	O
read_pipe	*(struct)
=	O
sock	*(struct)
->	O
read_pipe	*(struct)
;	O
struct	O
pipe	(array(int))->(int)
*	O
write_pipe	*(struct)
=	O
sock	*(struct)
->	O
write_pipe	*(struct)
;	O
if	O
(	O
!	O
write_pipe	*(struct)
)	O
ready	int
|=	O
SELECT_WRITE	int
;	O
if	O
(	O
!	O
read_pipe	*(struct)
)	O
ready	int
|=	O
SELECT_READ	int
;	O
ready	int
&=	O
*	O
select_type	*(int)
;	O
*	O
select_type	*(int)
&=	O
~	O
ready	int
;	O
valid	int
=	O
*	O
select_type	*(int)
;	O
if	O
(	O
valid	int
&	O
SELECT_READ	int
)	O
{	O
pipe_acquire_reader	()->(int)
(	O
read_pipe	*(struct)
)	O
;	O
err	O
=	O
pipe_wait_readable	()->(int)
(	O
read_pipe	*(struct)
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
err	O
==	O
EWOULDBLOCK	O
)	O
err	O
=	O
0	int
;	O
else	O
ready	int
|=	O
SELECT_READ	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
read_pipe	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
err	O
)	O
valid	int
&=	O
~	O
SELECT_WRITE	int
;	O
}	O
if	O
(	O
valid	int
&	O
SELECT_WRITE	int
)	O
{	O
pipe_acquire_writer	()->(int)
(	O
write_pipe	*(struct)
)	O
;	O
err	O
=	O
pipe_wait_writable	()->(int)
(	O
write_pipe	*(struct)
,	O
1	int
)	O
;	O
if	O
(	O
err	O
==	O
EWOULDBLOCK	O
)	O
err	O
=	O
0	int
;	O
else	O
ready	int
|=	O
SELECT_WRITE	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
write_pipe	*(struct)
->	O
lock	O
)	O
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
ready	int
)	O
*	O
select_type	*(int)
=	O
ready	int
;	O
else	O
{	O
ports_interrupt_self_on_port_death	()->(int)
(	O
user	*(struct)
,	O
reply	int
)	O
;	O
err	O
=	O
pipe_pair_select	()->(int)
(	O
read_pipe	*(struct)
,	O
write_pipe	*(struct)
,	O
tsp	*(struct(long,long))
,	O
select_type	*(int)
,	O
1	int
)	O
;	O
}	O
if	O
(	O
valid	int
&	O
SELECT_READ	int
)	O
pipe_remove_reader	()->(int)
(	O
read_pipe	*(struct)
)	O
;	O
if	O
(	O
valid	int
&	O
SELECT_WRITE	int
)	O
pipe_remove_writer	()->(int)
(	O
write_pipe	*(struct)
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_io_select	(*(struct),int,int,*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
*	O
select_type	*(int)
)	O
{	O
return	O
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
user	*(struct)
,	O
reply	int
,	O
reply_type	int
,	O
NULL	O
,	O
select_type	*(int)
)	O
;	O
}	O
error_t	O
S_io_select_timeout	(*(struct),int,int,struct(long,long),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct(long,long)
ts	struct(long,long)
,	O
int	O
*	O
select_type	*(int)
)	O
{	O
return	O
io_select_common	(*(struct),int,int,*(struct(long,long)),*(int))->(int)
(	O
user	*(struct)
,	O
reply	int
,	O
reply_type	int
,	O
&	O
ts	struct(long,long)
,	O
select_type	*(int)
)	O
;	O
}	O
static	O
inline	O
void	O
copy_time	(*(int),*(long),*(long))->(void)
(	O
time_value_t	O
*	O
from	*(int)
,	O
time_t	long
*	O
to_sec	*(long)
,	O
long	O
*	O
to_nsec	*(long)
)	O
{	O
*	O
to_sec	*(long)
=	O
from	*(int)
->	O
seconds	O
;	O
*	O
to_nsec	*(long)
=	O
from	*(int)
->	O
microseconds	O
*	O
1000	int
;	O
}	O
error_t	O
S_io_stat	(*(struct),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
struct	O
pipe	(array(int))->(int)
*	O
rpipe	*(struct)
,	O
*	O
wpipe	*(struct)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
sock	*(struct)
=	O
user	*(struct)
->	O
sock	*(struct)
;	O
memset	(*(void),int,long)->(*(void))
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
0	int
,	O
sizeof	O
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_fstype	O
=	O
FSTYPE_SOCKET	int
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
=	O
sock	*(struct)
->	O
mode	O
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
=	O
sock	*(struct)
->	O
id	*(int)
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_blksize	long
=	O
vm_page_size	O
*	O
16	int
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
rpipe	*(struct)
=	O
sock	*(struct)
->	O
read_pipe	*(struct)
;	O
wpipe	*(struct)
=	O
sock	*(struct)
->	O
write_pipe	*(struct)
;	O
if	O
(	O
rpipe	*(struct)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
rpipe	*(struct)
->	O
lock	O
)	O
;	O
copy_time	(*(int),*(long),*(long))->(void)
(	O
&	O
rpipe	*(struct)
->	O
read_time	O
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_atim	struct(long,long)
.	O
tv_sec	long
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_atim	struct(long,long)
.	O
tv_nsec	long
)	O
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
=	O
pipe_readable	()->(int)
(	O
rpipe	*(struct)
,	O
1	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
rpipe	*(struct)
->	O
lock	O
)	O
;	O
}	O
if	O
(	O
wpipe	*(struct)
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
wpipe	*(struct)
->	O
lock	O
)	O
;	O
copy_time	(*(int),*(long),*(long))->(void)
(	O
&	O
wpipe	*(struct)
->	O
write_time	O
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mtim	struct(long,long)
.	O
tv_sec	long
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mtim	struct(long,long)
.	O
tv_nsec	long
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
wpipe	*(struct)
->	O
lock	O
)	O
;	O
}	O
copy_time	(*(int),*(long),*(long))->(void)
(	O
&	O
sock	*(struct)
->	O
change_time	O
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ctim	struct(long,long)
.	O
tv_sec	long
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ctim	struct(long,long)
.	O
tv_nsec	long
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_get_openmodes	(*(struct),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
int	O
*	O
bits	*(int)
)	O
{	O
unsigned	O
flags	int
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
flags	int
=	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
;	O
*	O
bits	*(int)
=	O
O_APPEND	int
|	O
(	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	O
?	O
O_NONBLOCK	int
:	O
0	int
)	O
|	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	O
?	O
0	int
:	O
O_READ	O
)	O
|	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	O
?	O
0	int
:	O
O_WRITE	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_set_all_openmodes	(*(struct),int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
int	O
bits	*(int)
)	O
{	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
bits	*(int)
&	O
O_NONBLOCK	int
)	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
|=	O
PFLOCAL_SOCK_NONBLOCK	O
;	O
else	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
&=	O
~	O
PFLOCAL_SOCK_NONBLOCK	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_set_some_openmodes	(*(struct),int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
int	O
bits	*(int)
)	O
{	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
bits	*(int)
&	O
O_NONBLOCK	int
)	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
|=	O
PFLOCAL_SOCK_NONBLOCK	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_clear_some_openmodes	(*(struct),int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
int	O
bits	*(int)
)	O
{	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
bits	*(int)
&	O
O_NONBLOCK	int
)	O
user	*(struct)
->	O
sock	*(struct)
->	O
flags	int
&=	O
~	O
PFLOCAL_SOCK_NONBLOCK	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_reauthenticate	(*(struct),int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
rendezvous	int
)	O
{	O
error_t	O
err	O
;	O
mach_port_t	O
auth_server	O
;	O
mach_port_t	O
new_user_port	O
;	O
uid_t	int
uids_buf	array(int)
[	O
NIDS	int
]	O
,	O
aux_uids_buf	array(int)
[	O
NIDS	int
]	O
;	O
uid_t	int
*	O
uids	*(int)
=	O
uids_buf	array(int)
,	O
*	O
aux_uids	*(int)
=	O
aux_uids_buf	array(int)
;	O
gid_t	int
gids_buf	array(int)
[	O
NIDS	int
]	O
,	O
aux_gids_buf	array(int)
[	O
NIDS	int
]	O
;	O
gid_t	int
*	O
gids	*(int)
=	O
gids_buf	array(int)
,	O
*	O
aux_gids	*(int)
=	O
aux_gids_buf	array(int)
;	O
size_t	long
num_uids	long
=	O
NIDS	int
,	O
num_aux_uids	long
=	O
NIDS	int
;	O
size_t	long
num_gids	long
=	O
NIDS	int
,	O
num_aux_gids	long
=	O
NIDS	int
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
do	O
err	O
=	O
sock_create_port	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
&	O
new_user_port	O
)	O
;	O
while	O
(	O
err	O
==	O
EINTR	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
auth_server	O
=	O
getauth	()->(int)
(	O
)	O
;	O
err	O
=	O
mach_port_insert_right	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
new_user_port	O
,	O
new_user_port	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
assert_perror	()->(int)
(	O
err	O
)	O
;	O
do	O
err	O
=	O
auth_server_authenticate	()->(int)
(	O
auth_server	O
,	O
rendezvous	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
new_user_port	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
&	O
uids	*(int)
,	O
&	O
num_uids	long
,	O
&	O
aux_uids	*(int)
,	O
&	O
num_aux_uids	long
,	O
&	O
gids	*(int)
,	O
&	O
num_gids	long
,	O
&	O
aux_gids	*(int)
,	O
&	O
num_aux_gids	long
)	O
;	O
while	O
(	O
err	O
==	O
EINTR	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
rendezvous	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
auth_server	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
new_user_port	O
)	O
;	O
TRASH_IDS	O
(	O
uids	*(int)
,	O
uids_buf	array(int)
,	O
num_uids	long
)	O
;	O
TRASH_IDS	O
(	O
gids	*(int)
,	O
gids_buf	array(int)
,	O
num_gids	long
)	O
;	O
TRASH_IDS	O
(	O
aux_uids	*(int)
,	O
aux_uids_buf	array(int)
,	O
num_aux_uids	long
)	O
;	O
TRASH_IDS	O
(	O
aux_gids	*(int)
,	O
aux_gids_buf	array(int)
,	O
num_aux_gids	long
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_io_restrict_auth	(*(struct),*(int),*(int),*(int),long,*(int),long)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
new_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
new_port_type	*(int)
,	O
uid_t	int
*	O
uids	*(int)
,	O
size_t	long
num_uids	long
,	O
uid_t	int
*	O
gids	*(int)
,	O
size_t	long
num_gids	long
)	O
{	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
new_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
return	O
sock_create_port	()->(int)
(	O
user	*(struct)
->	O
sock	*(struct)
,	O
new_port	*(int)
)	O
;	O
}	O
error_t	O
S_io_pathconf	(*(struct),int,*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
int	O
name	int
,	O
int	O
*	O
value	*(int)
)	O
{	O
if	O
(	O
user	*(struct)
==	O
NULL	O
)	O
return	O
EOPNOTSUPP	O
;	O
else	O
if	O
(	O
name	int
==	O
_PC_PIPE_BUF	int
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
user	*(struct)
->	O
sock	*(struct)
->	O
write_pipe	*(struct)
==	O
NULL	O
)	O
*	O
value	*(int)
=	O
0	int
;	O
else	O
*	O
value	*(int)
=	O
user	*(struct)
->	O
sock	*(struct)
->	O
write_pipe	*(struct)
->	O
write_atomic	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
user	*(struct)
->	O
sock	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
EINVAL	O
;	O
}	O
error_t	O
S_io_identity	(*(struct),*(int),*(int),*(int),*(int),*(long))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
id	*(int)
,	O
mach_msg_type_name_t	O
*	O
id_type	*(int)
,	O
mach_port_t	O
*	O
fsys_id	*(int)
,	O
mach_msg_type_name_t	O
*	O
fsys_id_type	*(int)
,	O
ino_t	long
*	O
fileno	*(long)
)	O
{	O
static	O
mach_port_t	O
server_id	int
=	O
MACH_PORT_NULL	O
;	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
sock	*(struct)
*	O
sock	*(struct)
;	O
if	O
(	O
!	O
user	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
server_id	int
==	O
MACH_PORT_NULL	O
)	O
{	O
static	O
pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
server_id_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
server_id_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
server_id	int
==	O
MACH_PORT_NULL	O
)	O
err	O
=	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
server_id	int
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
server_id_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
sock	*(struct)
=	O
user	*(struct)
->	O
sock	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
sock	*(struct)
->	O
id	*(int)
==	O
MACH_PORT_NULL	O
)	O
err	O
=	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
sock	*(struct)
->	O
id	*(int)
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
sock	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
id	*(int)
=	O
sock	*(struct)
->	O
id	*(int)
;	O
*	O
id_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
fsys_id	*(int)
=	O
server_id	int
;	O
*	O
fsys_id_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
fileno	*(long)
=	O
sock	*(struct)
->	O
id	*(int)
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_io_revoke	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_async	(*(struct),int,*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
notify_port	int
,	O
mach_port_t	O
*	O
async_id_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
async_id_port_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_mod_owner	(*(struct),int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
pid_t	int
owner	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_get_owner	(*(struct),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
pid_t	int
*	O
owner	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_get_icky_async_id	(*(struct),*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
icky_async_id_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
icky_async_id_port_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_map	(*(struct),*(int),*(int),*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
memobj_rd	*(int)
,	O
mach_msg_type_name_t	O
*	O
memobj_rd_type	*(int)
,	O
mach_port_t	O
*	O
memobj_wt	*(int)
,	O
mach_msg_type_name_t	O
*	O
memobj_wt_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_map_cntl	(*(struct),*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
mach_port_t	O
*	O
mem	*(int)
,	O
mach_msg_type_name_t	O
*	O
mem_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_get_conch	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_release_conch	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_eofnotify	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_prenotify	(*(struct),int,int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
vm_offset_t	O
start	int
,	O
vm_offset_t	O
end	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_postnotify	(*(struct),int,int)->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
vm_offset_t	O
start	int
,	O
vm_offset_t	O
end	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_readsleep	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_readnotify	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_sigio	(*(struct))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_io_server_version	(*(struct),*(char),*(int),*(int),*(int))->(int)
(	O
struct	O
sock_user	O
*	O
user	*(struct)
,	O
char	O
*	O
name	int
,	O
int	O
*	O
maj	*(int)
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
edit	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
