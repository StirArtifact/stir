error_t	int
netfs_attempt_readlink	(*(struct),*(struct),*(char))->(int)
(	O
struct	O
iouser	O
*	O
user	*(struct)
,	O
struct	O
node	*(struct)
*	O
node	*(struct)
,	O
char	O
*	O
buf	*(char)
)	O
{	O
assert	()->(int)
(	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
name	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
)	O
;	O
fshelp_touch	()->(int)
(	O
&	O
node	*(struct)
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_get_translator	(*(struct),*(*(char)),*(long))->(int)
(	O
struct	O
node	*(struct)
*	O
node	*(struct)
,	O
char	O
*	O
*	O
trans	*(char)
,	O
size_t	long
*	O
trans_len	long
)	O
{	O
if	O
(	O
!	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
name	*(char)
)	O
return	O
EINVAL	int
;	O
else	O
{	O
fshelp_touch	()->(int)
(	O
&	O
node	*(struct)
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	*(struct)
)	O
;	O
*	O
trans	*(char)
=	O
0	int
;	O
*	O
trans_len	long
=	O
0	int
;	O
if	O
(	O
S_ISLNK	()->(int)
(	O
node	*(struct)
->	O
nn_stat	O
.	O
st_mode	O
)	O
)	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
trans	*(char)
,	O
trans_len	long
,	O
_HURD_SYMLINK	O
)	O
;	O
return	O
argz_append	(*(*(char)),*(long),*(char),long)->(int)
(	O
trans	*(char)
,	O
trans_len	long
,	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
node	*(struct)
->	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
)	O
;	O
}	O
}	O
error_t	int
create_user_node	(*(struct(*(struct(*`,*`,*`)),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*`,*`,*`)))),*(struct(*(char),*(char),int,int,*(char),*(char),*(char))),*(*(struct)))->(int)
(	O
struct	O
usermux	struct(*(struct),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int)
*	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
,	O
struct	O
usermux_name	struct(*(char),*(struct),*(struct(*(char),*(struct),*(struct(*(char),*(struct`),*(struct`))))))
*	O
name	*(char)
,	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
,	O
struct	O
node	*(struct)
*	O
*	O
node	*(struct)
)	O
{	O
error_t	int
err	int
;	O
struct	O
node	*(struct)
*	O
new	*(struct)
;	O
struct	O
netnode	struct(*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*(char),*(struct`),*(struct`))))),*(char),long)
*	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
netnode	struct(*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*(char),*(struct`),*(struct`))))),*(char),long)
)	O
)	O
;	O
if	O
(	O
!	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
)	O
return	O
ENOMEM	int
;	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
=	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
;	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
name	*(char)
=	O
name	*(char)
;	O
new	*(struct)
=	O
netfs_make_node	()->(int)
(	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
)	O
;	O
if	O
(	O
!	O
new	*(struct)
)	O
{	O
free	()->(int)
(	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
new	*(struct)
->	O
nn_stat	O
=	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
stat_template	struct
;	O
new	*(struct)
->	O
nn_stat	O
.	O
st_ino	O
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
+	O
USERMUX_FILENO_UID_OFFSET	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
trans_template	*(char)
,	O
_HURD_SYMLINK	O
)	O
==	O
0	int
&&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
trans_template_len	long
==	O
sizeof	O
_HURD_SYMLINK	O
)	O
{	O
err	int
=	O
argz_create_sep	(*(char),int,*(*(char)),*(long))->(int)
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
,	O
0	int
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
)	O
;	O
new	*(struct)
->	O
nn_stat	O
.	O
st_mode	O
=	O
(	O
S_IFLNK	O
|	O
0666	int
)	O
;	O
new	*(struct)
->	O
nn_stat	O
.	O
st_size	O
=	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
;	O
}	O
else	O
{	O
unsigned	O
replace_count	int
=	O
0	int
;	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
=	O
0	int
;	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
=	O
0	int
;	O
err	int
=	O
argz_append	(*(*(char)),*(long),*(char),long)->(int)
(	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
,	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
trans_template	*(char)
,	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
trans_template_len	long
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
user_pat	*(char)
&&	O
*	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
user_pat	*(char)
)	O
err	int
=	O
argz_replace	(*(*(char)),*(long),*(char),*(char),*(int))->(int)
(	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
,	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
user_pat	*(char)
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
,	O
&	O
replace_count	int
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
home_pat	*(char)
&&	O
*	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
home_pat	*(char)
)	O
err	int
=	O
argz_replace	(*(*(char)),*(long),*(char),*(char),*(int))->(int)
(	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
,	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
home_pat	*(char)
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
,	O
&	O
replace_count	int
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
uid_pat	*(char)
&&	O
*	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
uid_pat	*(char)
)	O
{	O
char	O
uid_buf	array(char)
[	O
10	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
uid_buf	array(char)
,	O
sizeof	O
uid_buf	array(char)
,	O
"%d"	*(char)
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
)	O
;	O
err	int
=	O
argz_replace	(*(*(char)),*(long),*(char),*(char),*(int))->(int)
(	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
,	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long),*(char),long,*(char),*(char),*(char),struct,int))
->	O
uid_pat	*(char)
,	O
uid_buf	array(char)
,	O
&	O
replace_count	int
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
replace_count	int
==	O
0	int
)	O
err	int
=	O
argz_add	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
,	O
&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
,	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
)	O
;	O
if	O
(	O
err	int
&&	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans_len	long
>	O
0	int
)	O
free	()->(int)
(	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
->	O
trans	*(char)
)	O
;	O
new	*(struct)
->	O
nn_stat	O
.	O
st_mode	O
=	O
(	O
S_IFREG	O
|	O
S_IPTRANS	O
|	O
0666	int
)	O
;	O
new	*(struct)
->	O
nn_stat	O
.	O
st_size	O
=	O
0	int
;	O
}	O
new	*(struct)
->	O
nn_translated	O
=	O
new	*(struct)
->	O
nn_stat	O
.	O
st_mode	O
;	O
if	O
(	O
err	int
)	O
{	O
free	()->(int)
(	O
nn	*(struct(*(struct(*(struct`),union(struct`,array(char),long),*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct`),*(struct`))),*(char),long))
)	O
;	O
free	()->(int)
(	O
new	*(struct)
)	O
;	O
return	O
err	int
;	O
}	O
fshelp_touch	()->(int)
(	O
&	O
new	*(struct)
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
|	O
TOUCH_MTIME	O
|	O
TOUCH_CTIME	O
,	O
usermux_maptime	*(struct)
)	O
;	O
name	*(char)
->	O
node	*(struct)
=	O
new	*(struct)
;	O
*	O
node	*(struct)
=	O
new	*(struct)
;	O
return	O
0	int
;	O
}	O
