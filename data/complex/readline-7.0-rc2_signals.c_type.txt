typedef	O
RETSIGTYPE	void
SigHandler	()->(void)
(	O
)	O
;	O
typedef	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
static	O
SigHandler	()->(void)
*	O
rl_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(*(()->(void)))
PARAMS	O
(	O
(	O
int	O
,	O
SigHandler	()->(void)
*	O
,	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
)	O
;	O
static	O
void	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
PARAMS	O
(	O
(	O
int	O
,	O
SigHandler	()->(void)
*	O
,	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
)	O
;	O
static	O
void	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
PARAMS	O
(	O
(	O
int	O
,	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
)	O
)	O
;	O
static	O
RETSIGTYPE	void
rl_signal_handler	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
RETSIGTYPE	void
_rl_handle_signal	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
int	O
rl_catch_signals	int
=	O
1	int
;	O
int	O
rl_catch_sigwinch	int
=	O
1	int
;	O
int	O
_rl_interrupt_immediately	int
=	O
0	int
;	O
int	O
volatile	O
_rl_caught_signal	int
=	O
0	int
;	O
int	O
_rl_echoctl	int
=	O
0	int
;	O
int	O
_rl_intr_char	int
=	O
0	int
;	O
int	O
_rl_quit_char	int
=	O
0	int
;	O
int	O
_rl_susp_char	int
=	O
0	int
;	O
static	O
int	O
signals_set_flag	int
;	O
static	O
int	O
sigwinch_set_flag	int
;	O
static	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
old_int	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_term	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_hup	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_quit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
static	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
old_tstp	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_ttou	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
old_ttin	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
static	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
old_winch	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
_rl_sigcleanup_func_t	(int,*(void))->(void)
*	O
_rl_sigcleanup	*((int,*(void))->(void))
;	O
void	O
*	O
_rl_sigcleanarg	*(void)
;	O
RETSIGTYPE	void
_rl_signal_handler	(int)->(void)
(	O
sig	int
)	O
int	O
sig	int
;	O
{	O
_rl_caught_signal	int
=	O
0	int
;	O
if	O
(	O
sig	int
==	O
SIGWINCH	int
)	O
{	O
rl_resize_terminal	()->(void)
(	O
)	O
;	O
if	O
(	O
rl_signal_event_hook	*(()->(int))
)	O
(	O
*	O
rl_signal_event_hook	*(()->(int))
)	O
(	O
)	O
;	O
}	O
else	O
_rl_handle_signal	(int)->(void)
(	O
sig	int
)	O
;	O
SIGHANDLER_RETURN	O
;	O
}	O
static	O
RETSIGTYPE	void
rl_signal_handler	(int)->(void)
(	O
sig	int
)	O
int	O
sig	int
;	O
{	O
if	O
(	O
_rl_interrupt_immediately	int
)	O
{	O
_rl_interrupt_immediately	int
=	O
0	int
;	O
_rl_handle_signal	(int)->(void)
(	O
sig	int
)	O
;	O
}	O
else	O
_rl_caught_signal	int
=	O
sig	int
;	O
SIGHANDLER_RETURN	O
;	O
}	O
static	O
RETSIGTYPE	void
_rl_handle_signal	(int)->(void)
(	O
sig	int
)	O
int	O
sig	int
;	O
{	O
sigset_t	struct(array(long))
set	struct(array(long))
;	O
RL_SETSTATE	O
(	O
RL_STATE_SIGHANDLER	int
)	O
;	O
if	O
(	O
_rl_sigcleanup	*((int,*(void))->(void))
)	O
{	O
(	O
*	O
_rl_sigcleanup	*((int,*(void))->(void))
)	O
(	O
sig	int
,	O
_rl_sigcleanarg	*(void)
)	O
;	O
_rl_sigcleanup	*((int,*(void))->(void))
=	O
0	int
;	O
_rl_sigcleanarg	*(void)
=	O
0	int
;	O
}	O
switch	O
(	O
sig	int
)	O
{	O
case	O
SIGINT	int
:	O
_rl_reset_completion_state	()->(void)
(	O
)	O
;	O
rl_free_line_state	()->(void)
(	O
)	O
;	O
rl_callback_sigcleanup	()->(void)
(	O
)	O
;	O
case	O
SIGTSTP	int
:	O
case	O
SIGTTIN	int
:	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
set	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	struct(array(long))
,	O
SIGTTOU	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
set	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
)	O
;	O
case	O
SIGTTOU	int
:	O
case	O
SIGTERM	int
:	O
case	O
SIGHUP	int
:	O
case	O
SIGALRM	int
:	O
case	O
SIGQUIT	int
:	O
rl_echo_signal_char	(int)->(void)
(	O
sig	int
)	O
;	O
rl_cleanup_after_signal	()->(void)
(	O
)	O
;	O
if	O
(	O
sig	int
==	O
SIGTTIN	int
||	O
sig	int
==	O
SIGTSTP	int
)	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_UNBLOCK	int
,	O
&	O
set	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
set	struct(array(long))
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
,	O
&	O
set	struct(array(long))
)	O
;	O
sigdelset	(*(struct(array(long))),int)->(int)
(	O
&	O
set	struct(array(long))
,	O
sig	int
)	O
;	O
kill	(int,int)->(int)
(	O
getpid	()->(int)
(	O
)	O
,	O
sig	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
set	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
)	O
;	O
rl_reset_after_signal	()->(void)
(	O
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_SIGHANDLER	int
)	O
;	O
SIGHANDLER_RETURN	O
;	O
}	O
static	O
RETSIGTYPE	void
rl_sigwinch_handler	(int)->(void)
(	O
sig	int
)	O
int	O
sig	int
;	O
{	O
SigHandler	()->(void)
*	O
oh	*(()->(void))
;	O
RL_SETSTATE	O
(	O
RL_STATE_SIGHANDLER	int
)	O
;	O
_rl_caught_signal	int
=	O
sig	int
;	O
oh	*(()->(void))
=	O
(	O
SigHandler	()->(void)
*	O
)	O
old_winch	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
;	O
if	O
(	O
oh	*(()->(void))
&&	O
oh	*(()->(void))
!=	O
(	O
SigHandler	()->(void)
*	O
)	O
SIG_IGN	O
&&	O
oh	*(()->(void))
!=	O
(	O
SigHandler	()->(void)
*	O
)	O
SIG_DFL	O
)	O
(	O
*	O
oh	*(()->(void))
)	O
(	O
sig	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_SIGHANDLER	int
)	O
;	O
SIGHANDLER_RETURN	O
;	O
}	O
static	O
SigHandler	()->(void)
*	O
rl_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(*(()->(void)))
(	O
sig	int
,	O
handler	*(()->(void))
,	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
)	O
int	O
sig	int
;	O
SigHandler	()->(void)
*	O
handler	*(()->(void))
;	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
;	O
{	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
old_handler	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
handler	*(()->(void))
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
(	O
sig	int
==	O
SIGWINCH	int
)	O
?	O
SA_RESTART	int
:	O
0	int
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
->	O
sa_mask	struct(array(long))
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
old_handler	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
if	O
(	O
handler	*(()->(void))
!=	O
rl_signal_handler	(int)->(void)
||	O
old_handler	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
!=	O
rl_signal_handler	(int)->(void)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
,	O
&	O
old_handler	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
sizeof	O
(	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
)	O
;	O
return	O
(	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
->	O
sa_handler	*((int)->(void))
)	O
;	O
}	O
static	O
void	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
sig	int
,	O
handler	*(()->(void))
,	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
)	O
int	O
sig	int
;	O
SigHandler	()->(void)
*	O
handler	*(()->(void))
;	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
;	O
{	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
SigHandler	()->(void)
*	O
oh	*(()->(void))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
oh	*(()->(void))
=	O
rl_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(*(()->(void)))
(	O
sig	int
,	O
handler	*(()->(void))
,	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
)	O
;	O
if	O
(	O
oh	*(()->(void))
==	O
(	O
SigHandler	()->(void)
*	O
)	O
SIG_IGN	O
)	O
rl_sigaction	O
(	O
sig	int
,	O
ohandler	*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void))))
,	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
}	O
static	O
void	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
sig	int
,	O
handler	*(()->(void))
)	O
int	O
sig	int
;	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
*	O
handler	*(()->(void))
;	O
{	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
handler	*(()->(void))
->	O
sa_handler	*((int)->(void))
!=	O
SIG_IGN	O
)	O
rl_sigaction	O
(	O
sig	int
,	O
handler	*(()->(void))
,	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
}	O
int	O
rl_set_signals	()->(int)
(	O
)	O
{	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
SigHandler	()->(void)
*	O
oh	*(()->(void))
;	O
static	O
int	O
sigmask_set	int
=	O
0	int
;	O
static	O
sigset_t	struct(array(long))
bset	struct(array(long))
,	O
oset	struct(array(long))
;	O
if	O
(	O
rl_catch_signals	int
&&	O
sigmask_set	int
==	O
0	int
)	O
{	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
bset	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGINT	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGTERM	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGHUP	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGQUIT	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGALRM	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGTSTP	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGTTIN	int
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
bset	struct(array(long))
,	O
SIGTTOU	int
)	O
;	O
sigmask_set	int
=	O
1	int
;	O
}	O
if	O
(	O
rl_catch_signals	int
&&	O
signals_set_flag	int
==	O
0	int
)	O
{	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
oset	struct(array(long))
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
bset	struct(array(long))
,	O
&	O
oset	struct(array(long))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGINT	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_int	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTERM	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_term	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGHUP	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_hup	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGQUIT	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_quit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
oh	*(()->(void))
=	O
rl_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(*(()->(void)))
(	O
SIGALRM	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
if	O
(	O
oh	*(()->(void))
==	O
(	O
SigHandler	()->(void)
*	O
)	O
SIG_IGN	O
)	O
rl_sigaction	O
(	O
SIGALRM	int
,	O
&	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
if	O
(	O
oh	*(()->(void))
!=	O
(	O
SigHandler	()->(void)
*	O
)	O
SIG_DFL	O
&&	O
(	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
&	O
SA_RESTART	int
)	O
)	O
rl_sigaction	O
(	O
SIGALRM	int
,	O
&	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTSTP	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_tstp	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTTOU	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_ttou	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTTIN	int
,	O
rl_signal_handler	(int)->(void)
,	O
&	O
old_ttin	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
signals_set_flag	int
=	O
1	int
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
oset	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
rl_catch_sigwinch	int
&&	O
sigwinch_set_flag	int
==	O
0	int
)	O
{	O
rl_maybe_set_sighandler	(int,*(()->(void)),*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGWINCH	int
,	O
rl_sigwinch_handler	(int)->(void)
,	O
&	O
old_winch	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
sigwinch_set_flag	int
=	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_clear_signals	()->(int)
(	O
)	O
{	O
sighandler_cxt	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
if	O
(	O
rl_catch_signals	int
&&	O
signals_set_flag	int
==	O
1	int
)	O
{	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGINT	int
,	O
&	O
old_int	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTERM	int
,	O
&	O
old_term	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGHUP	int
,	O
&	O
old_hup	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGQUIT	int
,	O
&	O
old_quit	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGALRM	int
,	O
&	O
old_alrm	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTSTP	int
,	O
&	O
old_tstp	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTTOU	int
,	O
&	O
old_ttou	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
rl_maybe_restore_sighandler	(int,*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(void)
(	O
SIGTTIN	int
,	O
&	O
old_ttin	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
signals_set_flag	int
=	O
0	int
;	O
}	O
if	O
(	O
rl_catch_sigwinch	int
&&	O
sigwinch_set_flag	int
==	O
1	int
)	O
{	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
rl_sigaction	O
(	O
SIGWINCH	int
,	O
&	O
old_winch	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
dummy	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
sigwinch_set_flag	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
rl_cleanup_after_signal	()->(void)
(	O
)	O
{	O
_rl_clean_up_for_exit	()->(void)
(	O
)	O
;	O
if	O
(	O
rl_deprep_term_function	*(()->(void))
)	O
(	O
*	O
rl_deprep_term_function	*(()->(void))
)	O
(	O
)	O
;	O
rl_clear_pending_input	()->(int)
(	O
)	O
;	O
rl_clear_signals	()->(int)
(	O
)	O
;	O
}	O
void	O
rl_reset_after_signal	()->(void)
(	O
)	O
{	O
if	O
(	O
rl_prep_term_function	*((int)->(void))
)	O
(	O
*	O
rl_prep_term_function	*((int)->(void))
)	O
(	O
_rl_meta_flag	int
)	O
;	O
rl_set_signals	()->(int)
(	O
)	O
;	O
}	O
void	O
rl_free_line_state	()->(void)
(	O
)	O
{	O
register	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
entry	*(struct(*(char),*(char),*(void)))
;	O
rl_free_undo_list	()->(void)
(	O
)	O
;	O
entry	*(struct(*(char),*(char),*(void)))
=	O
current_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
if	O
(	O
entry	*(struct(*(char),*(char),*(void)))
)	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
_rl_kill_kbd_macro	()->(void)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
_rl_reset_argument	()->(void)
(	O
)	O
;	O
}	O
int	O
rl_pending_signal	()->(int)
(	O
)	O
{	O
return	O
(	O
_rl_caught_signal	int
)	O
;	O
}	O
static	O
sigset_t	struct(array(long))
sigint_set	struct(array(long))
,	O
sigint_oset	struct(array(long))
;	O
static	O
sigset_t	struct(array(long))
sigwinch_set	struct(array(long))
,	O
sigwinch_oset	struct(array(long))
;	O
static	O
int	O
sigint_blocked	int
;	O
static	O
int	O
sigwinch_blocked	int
;	O
void	O
_rl_block_sigint	()->(void)
(	O
)	O
{	O
if	O
(	O
sigint_blocked	int
)	O
return	O
;	O
sigint_blocked	int
=	O
1	int
;	O
}	O
void	O
_rl_release_sigint	()->(void)
(	O
)	O
{	O
if	O
(	O
sigint_blocked	int
==	O
0	int
)	O
return	O
;	O
sigint_blocked	int
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
void	O
_rl_block_sigwinch	()->(void)
(	O
)	O
{	O
if	O
(	O
sigwinch_blocked	int
)	O
return	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigwinch_set	struct(array(long))
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
sigwinch_oset	struct(array(long))
)	O
;	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
sigwinch_set	struct(array(long))
,	O
SIGWINCH	int
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
sigwinch_set	struct(array(long))
,	O
&	O
sigwinch_oset	struct(array(long))
)	O
;	O
sigwinch_blocked	int
=	O
1	int
;	O
}	O
void	O
_rl_release_sigwinch	()->(void)
(	O
)	O
{	O
if	O
(	O
sigwinch_blocked	int
==	O
0	int
)	O
return	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
sigwinch_oset	struct(array(long))
,	O
(	O
sigset_t	struct(array(long))
*	O
)	O
NULL	O
)	O
;	O
sigwinch_blocked	int
=	O
0	int
;	O
}	O
void	O
rl_echo_signal_char	(int)->(void)
(	O
sig	int
)	O
int	O
sig	int
;	O
{	O
char	O
cstr	array(char)
[	O
3	int
]	O
;	O
int	O
cslen	int
,	O
c	int
;	O
if	O
(	O
_rl_echoctl	int
==	O
0	int
||	O
_rl_echo_control_chars	int
==	O
0	int
)	O
return	O
;	O
switch	O
(	O
sig	int
)	O
{	O
case	O
SIGINT	int
:	O
c	int
=	O
_rl_intr_char	int
;	O
break	O
;	O
case	O
SIGQUIT	int
:	O
c	int
=	O
_rl_quit_char	int
;	O
break	O
;	O
case	O
SIGTSTP	int
:	O
c	int
=	O
_rl_susp_char	int
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
||	O
c	int
==	O
RUBOUT	int
)	O
{	O
cstr	array(char)
[	O
0	int
]	O
=	O
'^'	O
;	O
cstr	array(char)
[	O
1	int
]	O
=	O
CTRL_CHAR	O
(	O
c	int
)	O
?	O
UNCTRL	O
(	O
c	int
)	O
:	O
'?'	O
;	O
cstr	array(char)
[	O
cslen	int
=	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
cstr	array(char)
[	O
0	int
]	O
=	O
c	int
;	O
cstr	array(char)
[	O
cslen	int
=	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
cstr	array(char)
,	O
cslen	int
)	O
;	O
}	O
