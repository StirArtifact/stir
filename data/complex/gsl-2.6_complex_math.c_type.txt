gsl_complex	struct(array(double))
gsl_complex_polar	(double,double)->(struct(array(double)))
(	O
double	O
r	double
,	O
double	O
theta	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
r	double
*	O
cos	(double)->(double)
(	O
theta	double
)	O
,	O
r	double
*	O
sin	(double)->(double)
(	O
theta	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
double	O
gsl_complex_arg	(struct(array(double)))->(double)
(	O
gsl_complex	struct(array(double))
z	double
)	O
{	O
double	O
x	double
=	O
GSL_REAL	O
(	O
z	double
)	O
;	O
double	O
y	double
=	O
GSL_IMAG	O
(	O
z	double
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
&&	O
y	double
==	O
0.0	int
)	O
{	O
return	O
0	int
;	O
}	O
return	O
atan2	(double,double)->(double)
(	O
y	double
,	O
x	double
)	O
;	O
}	O
double	O
gsl_complex_abs	(struct(array(double)))->(double)
(	O
gsl_complex	struct(array(double))
z	double
)	O
{	O
return	O
hypot	(double,double)->(double)
(	O
GSL_REAL	O
(	O
z	double
)	O
,	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
}	O
double	O
gsl_complex_abs2	(struct(array(double)))->(double)
(	O
gsl_complex	struct(array(double))
z	double
)	O
{	O
double	O
x	double
=	O
GSL_REAL	O
(	O
z	double
)	O
;	O
double	O
y	double
=	O
GSL_IMAG	O
(	O
z	double
)	O
;	O
return	O
(	O
x	double
*	O
x	double
+	O
y	double
*	O
y	double
)	O
;	O
}	O
double	O
gsl_complex_logabs	(struct(array(double)))->(double)
(	O
gsl_complex	struct(array(double))
z	double
)	O
{	O
double	O
xabs	double
=	O
fabs	(double)->(double)
(	O
GSL_REAL	O
(	O
z	double
)	O
)	O
;	O
double	O
yabs	double
=	O
fabs	(double)->(double)
(	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
double	O
max	double
,	O
u	double
;	O
if	O
(	O
xabs	double
>=	O
yabs	double
)	O
{	O
max	double
=	O
xabs	double
;	O
u	double
=	O
yabs	double
/	O
xabs	double
;	O
}	O
else	O
{	O
max	double
=	O
yabs	double
;	O
u	double
=	O
xabs	double
/	O
yabs	double
;	O
}	O
return	O
log	(double)->(double)
(	O
max	double
)	O
+	O
0.5	int
*	O
log1p	(double)->(double)
(	O
u	double
*	O
u	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_add	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
+	O
br	double
,	O
ai	double
+	O
bi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
+	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_add_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
GSL_IMAG	O
(	O
a	double
)	O
+	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sub	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
-	O
br	double
,	O
ai	double
-	O
bi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sub_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
-	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sub_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
GSL_IMAG	O
(	O
a	double
)	O
-	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_mul	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
*	O
br	double
-	O
ai	double
*	O
bi	double
,	O
ar	double
*	O
bi	double
+	O
ai	double
*	O
br	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
x	double
*	O
GSL_REAL	O
(	O
a	double
)	O
,	O
x	double
*	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
y	double
*	O
GSL_IMAG	O
(	O
a	double
)	O
,	O
y	double
*	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_div	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
double	O
s	double
=	O
1.0	int
/	O
gsl_complex_abs	(struct(array(double)))->(double)
(	O
b	double
)	O
;	O
double	O
sbr	double
=	O
s	double
*	O
br	double
;	O
double	O
sbi	double
=	O
s	double
*	O
bi	double
;	O
double	O
zr	double
=	O
(	O
ar	double
*	O
sbr	double
+	O
ai	double
*	O
sbi	double
)	O
*	O
s	double
;	O
double	O
zi	double
=	O
(	O
ai	double
*	O
sbr	double
-	O
ar	double
*	O
sbi	double
)	O
*	O
s	double
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
zr	double
,	O
zi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_div_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
/	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
/	O
x	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_div_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
/	O
y	double
,	O
-	O
GSL_REAL	O
(	O
a	double
)	O
/	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_conjugate	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
-	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_negative	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
GSL_REAL	O
(	O
a	double
)	O
,	O
-	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
s	double
=	O
1.0	int
/	O
gsl_complex_abs	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
GSL_REAL	O
(	O
a	double
)	O
*	O
s	double
)	O
*	O
s	double
,	O
-	O
(	O
GSL_IMAG	O
(	O
a	double
)	O
*	O
s	double
)	O
*	O
s	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sqrt	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0.0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	(double)->(double)
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
double	O
y	double
=	O
fabs	(double)->(double)
(	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
double	O
w	double
;	O
if	O
(	O
x	double
>=	O
y	double
)	O
{	O
double	O
t	double
=	O
y	double
/	O
x	double
;	O
w	double
=	O
sqrt	(double)->(double)
(	O
x	double
)	O
*	O
sqrt	(double)->(double)
(	O
0.5	int
*	O
(	O
1.0	int
+	O
sqrt	(double)->(double)
(	O
1.0	int
+	O
t	double
*	O
t	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
double	O
t	double
=	O
x	double
/	O
y	double
;	O
w	double
=	O
sqrt	(double)->(double)
(	O
y	double
)	O
*	O
sqrt	(double)->(double)
(	O
0.5	int
*	O
(	O
t	double
+	O
sqrt	(double)->(double)
(	O
1.0	int
+	O
t	double
*	O
t	double
)	O
)	O
)	O
;	O
}	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
>=	O
0.0	int
)	O
{	O
double	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
w	double
,	O
ai	double
/	O
(	O
2.0	int
*	O
w	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
vi	double
=	O
(	O
ai	double
>=	O
0	int
)	O
?	O
w	double
:	O
-	O
w	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ai	double
/	O
(	O
2.0	int
*	O
vi	double
)	O
,	O
vi	double
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sqrt_real	(double)->(struct(array(double)))
(	O
double	O
x	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
x	double
>=	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sqrt	(double)->(double)
(	O
x	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.0	int
,	O
sqrt	(double)->(double)
(	O
-	O
x	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_exp	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
rho	double
=	O
exp	(double)->(double)
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
double	O
theta	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	(double)->(double)
(	O
theta	double
)	O
,	O
rho	double
*	O
sin	(double)->(double)
(	O
theta	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_pow	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1.0	int
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.0	int
,	O
0.0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
1.0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
return	O
a	double
;	O
}	O
else	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
-	O
1.0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
}	O
else	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
double	O
rho	double
=	O
exp	(double)->(double)
(	O
logr	double
*	O
br	double
-	O
bi	double
*	O
theta	double
)	O
;	O
double	O
beta	double
=	O
theta	double
*	O
br	double
+	O
bi	double
*	O
logr	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	(double)->(double)
(	O
beta	double
)	O
,	O
rho	double
*	O
sin	(double)->(double)
(	O
beta	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_pow_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
double	O
b	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0	int
)	O
{	O
if	O
(	O
b	double
==	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
double	O
rho	double
=	O
exp	(double)->(double)
(	O
logr	double
*	O
b	double
)	O
;	O
double	O
beta	double
=	O
theta	double
*	O
b	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	(double)->(double)
(	O
beta	double
)	O
,	O
rho	double
*	O
sin	(double)->(double)
(	O
beta	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_log	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	(struct(array(double)))->(double)
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
logr	double
,	O
theta	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_log10	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
return	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
gsl_complex_log	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
,	O
1	int
/	O
log	(double)->(double)
(	O
10.	int
)	O
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_log_b	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
,	O
gsl_complex	struct(array(double))
b	double
)	O
{	O
return	O
gsl_complex_div	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex_log	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
,	O
gsl_complex_log	(struct(array(double)))->(struct(array(double)))
(	O
b	double
)	O
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sin	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
I	double
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sin	(double)->(double)
(	O
R	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sin	(double)->(double)
(	O
R	double
)	O
*	O
cosh	(double)->(double)
(	O
I	double
)	O
,	O
cos	(double)->(double)
(	O
R	double
)	O
*	O
sinh	(double)->(double)
(	O
I	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_cos	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
I	double
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cos	(double)->(double)
(	O
R	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cos	(double)->(double)
(	O
R	double
)	O
*	O
cosh	(double)->(double)
(	O
I	double
)	O
,	O
sin	(double)->(double)
(	O
R	double
)	O
*	O
sinh	(double)->(double)
(	O
-	O
I	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_tan	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
I	double
)	O
<	O
1	int
)	O
{	O
double	O
D	double
=	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
R	double
)	O
,	O
2.0	int
)	O
+	O
pow	(double,double)->(double)
(	O
sinh	(double)->(double)
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
sin	(double)->(double)
(	O
2	int
*	O
R	double
)	O
/	O
D	double
,	O
0.5	int
*	O
sinh	(double)->(double)
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
else	O
{	O
double	O
D	double
=	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
R	double
)	O
,	O
2.0	int
)	O
+	O
pow	(double,double)->(double)
(	O
sinh	(double)->(double)
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
double	O
F	double
=	O
1	int
+	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
R	double
)	O
/	O
sinh	(double)->(double)
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
sin	(double)->(double)
(	O
2	int
*	O
R	double
)	O
/	O
D	double
,	O
1	int
/	O
(	O
tanh	(double)->(double)
(	O
I	double
)	O
*	O
F	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sec	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_cos	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_csc	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_sin	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_cot	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_tan	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsin	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
z	double
=	O
gsl_complex_arcsin_real	(double)->(struct(array(double)))
(	O
R	double
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	(double)->(double)
(	O
R	double
)	O
,	O
y	double
=	O
fabs	(double)->(double)
(	O
I	double
)	O
;	O
double	O
r	double
=	O
hypot	(double,double)->(double)
(	O
x	double
+	O
1	int
,	O
y	double
)	O
,	O
s	double
=	O
hypot	(double,double)->(double)
(	O
x	double
-	O
1	int
,	O
y	double
)	O
;	O
double	O
A	double
=	O
0.5	int
*	O
(	O
r	double
+	O
s	double
)	O
;	O
double	O
B	double
=	O
x	double
/	O
A	double
;	O
double	O
y2	double
=	O
y	double
*	O
y	double
;	O
double	O
real	double
,	O
imag	double
;	O
const	O
double	O
A_crossover	double
=	O
1.5	int
,	O
B_crossover	double
=	O
0.6417	int
;	O
if	O
(	O
B	double
<=	O
B_crossover	double
)	O
{	O
real	double
=	O
asin	(double)->(double)
(	O
B	double
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<=	O
1	int
)	O
{	O
double	O
D	double
=	O
0.5	int
*	O
(	O
A	double
+	O
x	double
)	O
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
real	double
=	O
atan	(double)->(double)
(	O
x	double
/	O
sqrt	(double)->(double)
(	O
D	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
Apx	double
=	O
A	double
+	O
x	double
;	O
double	O
D	double
=	O
0.5	int
*	O
(	O
Apx	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
Apx	double
/	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
real	double
=	O
atan	(double)->(double)
(	O
x	double
/	O
(	O
y	double
*	O
sqrt	(double)->(double)
(	O
D	double
)	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
A	double
<=	O
A_crossover	double
)	O
{	O
double	O
Am1	double
;	O
if	O
(	O
x	double
<	O
1	int
)	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
y2	double
/	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
}	O
imag	double
=	O
log1p	(double)->(double)
(	O
Am1	double
+	O
sqrt	(double)->(double)
(	O
Am1	double
*	O
(	O
A	double
+	O
1	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
imag	double
=	O
log	(double)->(double)
(	O
A	double
+	O
sqrt	(double)->(double)
(	O
A	double
*	O
A	double
-	O
1	int
)	O
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
R	double
>=	O
0	int
)	O
?	O
real	double
:	O
-	O
real	double
,	O
(	O
I	double
>=	O
0	int
)	O
?	O
imag	double
:	O
-	O
imag	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsin_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
asin	(double)->(double)
(	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
acosh	(double)->(double)
(	O
-	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
-	O
acosh	(double)->(double)
(	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccos	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
z	double
=	O
gsl_complex_arccos_real	(double)->(struct(array(double)))
(	O
R	double
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	(double)->(double)
(	O
R	double
)	O
,	O
y	double
=	O
fabs	(double)->(double)
(	O
I	double
)	O
;	O
double	O
r	double
=	O
hypot	(double,double)->(double)
(	O
x	double
+	O
1	int
,	O
y	double
)	O
,	O
s	double
=	O
hypot	(double,double)->(double)
(	O
x	double
-	O
1	int
,	O
y	double
)	O
;	O
double	O
A	double
=	O
0.5	int
*	O
(	O
r	double
+	O
s	double
)	O
;	O
double	O
B	double
=	O
x	double
/	O
A	double
;	O
double	O
y2	double
=	O
y	double
*	O
y	double
;	O
double	O
real	double
,	O
imag	double
;	O
const	O
double	O
A_crossover	double
=	O
1.5	int
,	O
B_crossover	double
=	O
0.6417	int
;	O
if	O
(	O
B	double
<=	O
B_crossover	double
)	O
{	O
real	double
=	O
acos	(double)->(double)
(	O
B	double
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<=	O
1	int
)	O
{	O
double	O
D	double
=	O
0.5	int
*	O
(	O
A	double
+	O
x	double
)	O
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
real	double
=	O
atan	(double)->(double)
(	O
sqrt	(double)->(double)
(	O
D	double
)	O
/	O
x	double
)	O
;	O
}	O
else	O
{	O
double	O
Apx	double
=	O
A	double
+	O
x	double
;	O
double	O
D	double
=	O
0.5	int
*	O
(	O
Apx	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
Apx	double
/	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
real	double
=	O
atan	(double)->(double)
(	O
(	O
y	double
*	O
sqrt	(double)->(double)
(	O
D	double
)	O
)	O
/	O
x	double
)	O
;	O
}	O
}	O
if	O
(	O
A	double
<=	O
A_crossover	double
)	O
{	O
double	O
Am1	double
;	O
if	O
(	O
x	double
<	O
1	int
)	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
y2	double
/	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
}	O
imag	double
=	O
log1p	(double)->(double)
(	O
Am1	double
+	O
sqrt	(double)->(double)
(	O
Am1	double
*	O
(	O
A	double
+	O
1	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
imag	double
=	O
log	(double)->(double)
(	O
A	double
+	O
sqrt	(double)->(double)
(	O
A	double
*	O
A	double
-	O
1	int
)	O
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
R	double
>=	O
0	int
)	O
?	O
real	double
:	O
M_PI	int
-	O
real	double
,	O
(	O
I	double
>=	O
0	int
)	O
?	O
-	O
imag	double
:	O
imag	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccos_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acos	(double)->(double)
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI	int
,	O
-	O
acosh	(double)->(double)
(	O
-	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acosh	(double)->(double)
(	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arctan	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atan	(double)->(double)
(	O
R	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
double	O
r	double
=	O
hypot	(double,double)->(double)
(	O
R	double
,	O
I	double
)	O
;	O
double	O
imag	double
;	O
double	O
u	double
=	O
2	int
*	O
I	double
/	O
(	O
1	int
+	O
r	double
*	O
r	double
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
u	double
)	O
<	O
0.1	int
)	O
{	O
imag	double
=	O
0.25	int
*	O
(	O
log1p	(double)->(double)
(	O
u	double
)	O
-	O
log1p	(double)->(double)
(	O
-	O
u	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
A	double
=	O
hypot	(double,double)->(double)
(	O
R	double
,	O
I	double
+	O
1	int
)	O
;	O
double	O
B	double
=	O
hypot	(double,double)->(double)
(	O
R	double
,	O
I	double
-	O
1	int
)	O
;	O
imag	double
=	O
0.5	int
*	O
log	(double)->(double)
(	O
A	double
/	O
B	double
)	O
;	O
}	O
if	O
(	O
R	double
==	O
0	int
)	O
{	O
if	O
(	O
I	double
>	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
imag	double
)	O
;	O
}	O
else	O
if	O
(	O
I	double
<	O
-	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
imag	double
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
imag	double
)	O
;	O
}	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
atan2	(double,double)->(double)
(	O
2	int
*	O
R	double
,	O
(	O
(	O
1	int
+	O
r	double
)	O
*	O
(	O
1	int
-	O
r	double
)	O
)	O
)	O
,	O
imag	double
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsec	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_arccos	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsec_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
a	double
<=	O
-	O
1.0	int
||	O
a	double
>=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acos	(double)->(double)
(	O
1	int
/	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acosh	(double)->(double)
(	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI	int
,	O
-	O
acosh	(double)->(double)
(	O
-	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccsc	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_arcsin	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccsc_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
a	double
<=	O
-	O
1.0	int
||	O
a	double
>=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
asin	(double)->(double)
(	O
1	int
/	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
-	O
acosh	(double)->(double)
(	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
acosh	(double)->(double)
(	O
-	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccot	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0.0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
z	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
z	double
=	O
gsl_complex_arctan	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sinh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sinh	(double)->(double)
(	O
R	double
)	O
*	O
cos	(double)->(double)
(	O
I	double
)	O
,	O
cosh	(double)->(double)
(	O
R	double
)	O
*	O
sin	(double)->(double)
(	O
I	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_cosh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cosh	(double)->(double)
(	O
R	double
)	O
*	O
cos	(double)->(double)
(	O
I	double
)	O
,	O
sinh	(double)->(double)
(	O
R	double
)	O
*	O
sin	(double)->(double)
(	O
I	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_tanh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
R	double
)	O
<	O
1.0	int
)	O
{	O
double	O
D	double
=	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
I	double
)	O
,	O
2.0	int
)	O
+	O
pow	(double,double)->(double)
(	O
sinh	(double)->(double)
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sinh	(double)->(double)
(	O
R	double
)	O
*	O
cosh	(double)->(double)
(	O
R	double
)	O
/	O
D	double
,	O
0.5	int
*	O
sin	(double)->(double)
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
else	O
{	O
double	O
D	double
=	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
I	double
)	O
,	O
2.0	int
)	O
+	O
pow	(double,double)->(double)
(	O
sinh	(double)->(double)
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
double	O
F	double
=	O
1	int
+	O
pow	(double,double)->(double)
(	O
cos	(double)->(double)
(	O
I	double
)	O
/	O
sinh	(double)->(double)
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1.0	int
/	O
(	O
tanh	(double)->(double)
(	O
R	double
)	O
*	O
F	double
)	O
,	O
0.5	int
*	O
sin	(double)->(double)
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_sech	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_cosh	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_csch	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_sinh	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_coth	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_tanh	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsinh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
a	double
,	O
1.0	int
)	O
;	O
z	double
=	O
gsl_complex_arcsin	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
-	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccosh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_arccos	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
GSL_IMAG	O
(	O
z	double
)	O
>	O
0	int
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccosh_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
a	double
>=	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acosh	(double)->(double)
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
-	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acos	(double)->(double)
(	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acosh	(double)->(double)
(	O
-	O
a	double
)	O
,	O
M_PI	int
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arctanh	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
if	O
(	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
return	O
gsl_complex_arctanh_real	(double)->(struct(array(double)))
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
a	double
,	O
1.0	int
)	O
;	O
z	double
=	O
gsl_complex_arctan	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
-	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arctanh_real	(double)->(struct(array(double)))
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct(array(double))
z	double
;	O
if	O
(	O
a	double
>	O
-	O
1.0	int
&&	O
a	double
<	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atanh	(double)->(double)
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atanh	(double)->(double)
(	O
1	int
/	O
a	double
)	O
,	O
(	O
a	double
<	O
0	int
)	O
?	O
M_PI_2	int
:	O
-	O
M_PI_2	int
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arcsech	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
t	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_arccosh	(struct(array(double)))->(struct(array(double)))
(	O
t	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccsch	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
t	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_arcsinh	(struct(array(double)))->(struct(array(double)))
(	O
t	double
)	O
;	O
}	O
gsl_complex	struct(array(double))
gsl_complex_arccoth	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
a	double
)	O
{	O
gsl_complex	struct(array(double))
t	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
a	double
)	O
;	O
return	O
gsl_complex_arctanh	(struct(array(double)))->(struct(array(double)))
(	O
t	double
)	O
;	O
}	O
