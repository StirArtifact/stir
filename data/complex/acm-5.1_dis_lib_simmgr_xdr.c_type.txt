bool_t	int
xdr_simx_stat	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(enum(int,int,int,int,int)))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_stat	enum(int,int,int,int,int)
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_enum	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(int))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
(	O
enum_t	int
*	O
)	O
objp	*(enum(int,int,int,int,int))
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_register_app_args	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(*(char),short)))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_register_app_args	struct(*(char),short)
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
site_name	*(char)
,	O
64	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_u_short	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(short))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
application_id	short
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_register_app_result	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(enum(int,int,int,int,int),struct(short,short))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_register_app_result	struct(enum(int,int,int,int,int),struct(short,short))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_simx_stat	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(enum(int,int,int,int,int)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
status_code	enum(int,int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_dis_simulation_addr	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(short,short)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
result	char
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_entity_type_attr	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(*(struct(char,char,short,char,char,char,char)),*(char))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_entity_type_attr	struct(*(struct(char,char,short,char,char,char,char)),*(char))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_pointer	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int,*((*(struct(enum(int,int,int),*`,*`,*`,*`,int)),*(void))->(int)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
(	O
char	O
*	O
*	O
)	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
type	int
,	O
sizeof	O
(	O
dis_entity_type	struct(char,char,short,char,char,char,char)
)	O
,	O
(	O
xdrproc_t	*((*(struct(enum(int,int,int),*(struct`),*(char),*(char),*(char),int)),*(void))->(int))
)	O
xdr_dis_entity_type	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(char,char,short,char,char,char,char)))->(int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
attr	*(char)
,	O
256	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_lookup_entity_type_result	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(enum(int,int,int,int,int),*(char))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_lookup_entity_type_result	struct(enum(int,int,int,int,int),*(char))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_simx_stat	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(enum(int,int,int,int,int)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
status_code	enum(int,int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
value	int
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_lookup_complete_entity_type_result	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(enum(int,int,int,int,int),*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_lookup_complete_entity_type_result	struct(enum(int,int,int,int,int),*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_simx_stat	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(enum(int,int,int,int,int)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
status_code	enum(int,int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
kind_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
domain_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
country_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
category_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
subcategory_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
specific_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
extra_value	*(char)
,	O
~	O
0	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_string	*(char)
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_string	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(*(char)),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
objp	*(enum(int,int,int,int,int))
,	O
256	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_session_handle	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(array(char),struct(short,short))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_session_handle	struct(array(char),struct(short,short))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
int	O
i	int
;	O
if	O
(	O
!	O
xdr_opaque	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(char),int)->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
objp	*(enum(int,int,int,int,int))
->	O
data	struct(struct(char,char,char,char,struct(int,int),short,short),struct(struct(short,short),short),struct(struct(short,short),short),long,struct(long,long,*(struct(long,long)),*(struct(long,long,union(double,struct`,*`)))))
,	O
4	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
xdr_dis_simulation_addr	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(short,short)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
address	struct(short,short)
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
bool_t	int
xdr_simx_startres	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(enum(int,int,int,int,int),union(struct(array(char),struct`)))))->(int)
(	O
XDR	struct
*	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
simx_startres	struct(enum(int,int,int,int,int),union(struct(array(char),struct(short,short))))
*	O
objp	*(enum(int,int,int,int,int))
)	O
{	O
register	O
int32_t	int
*	O
buf	*(char)
;	O
if	O
(	O
!	O
xdr_simx_stat	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(enum(int,int,int,int,int)))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
result	char
)	O
)	O
return	O
FALSE	O
;	O
switch	O
(	O
objp	*(enum(int,int,int,int,int))
->	O
result	char
)	O
{	O
case	O
SIMx_SUCCESS	int
:	O
if	O
(	O
!	O
xdr_simx_session_handle	(*(struct(enum(int,int,int),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(char),*(char),int)),*(struct(array(char),struct(short,short))))->(int)
(	O
xdrs	*(struct(enum(int,int,int),*(struct(*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`,int)->(int)),*((*`)->(int)),*((*`,int)->(int)),*((*`,int)->(*`)),*((*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(char),int))
,	O
&	O
objp	*(enum(int,int,int,int,int))
->	O
simx_startres_u	union(struct(array(char),struct(short,short)))
.	O
handle	struct(array(char),struct(short,short))
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
