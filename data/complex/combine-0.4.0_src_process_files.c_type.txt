int	O
process_reference_files	()->(int)
(	O
)	O
{	O
STRINGTYPE	O
*	O
key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
*	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
STRINGTYPE	O
*	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
;	O
HASHTYPE	O
hash_index	long
;	O
long	O
int	O
i	long
;	O
long	O
int	O
j	long
;	O
COUNTTYPE	O
temp_number	long
;	O
int	O
return_code	int
;	O
FILE	struct
*	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
=	O
calloc	(long,long)->(*(void))
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
==	O
NULL	O
)	O
{	O
FATAL_ERROR3	O
(	O
_	O
(	O
"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
)	O
)	O
;	O
}	O
if	O
(	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_direction	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
=	O
calloc	(long,long)->(*(void))
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
==	O
NULL	O
)	O
{	O
FATAL_ERROR3	O
(	O
_	O
(	O
"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
)	O
)	O
;	O
}	O
}	O
else	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
=	O
NULL	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
)	O
;	O
}	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
=	O
df_get_next_record	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),long)->(*(struct(long,enum(int,int,int),*(char))))
(	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_length	int
)	O
;	O
while	O
(	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
keep_record	int
;	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
++	O
;	O
keep_record	int
=	O
1	int
;	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
&&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
%	O
1000	int
)	O
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\rReading from reference file (%ld) %s: %12d records"	*(char)
)	O
,	O
i	long
+	O
1	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrnew	()->(*(struct(long,enum(int,int,int),*(char))))
(	O
)	O
;	O
find_input_ranges	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_ranges	*(struct(long,long,int,*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
{	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrnew	()->(*(struct(long,enum(int,int,int),*(char))))
(	O
)	O
;	O
find_input_ranges	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_ranges	*(struct(long,long,int,*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
return_code	int
=	O
a_find_input_ranges	(*(*(*(struct(long,enum(int,int,int),*`)))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,enum(int,int,int),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
&	O
(	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
DStr_own	int
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fill_empty_fields	(*(*(struct(long,enum(int,int,int),*(char)))),long,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
keep_record	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
unique_ind	int
==	O
0	int
||	O
find_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
==	O
-	O
1	int
)	O
{	O
hash_index	long
=	O
create_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
hash_index	long
==	O
-	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to insert new hash entry"	*(char)
)	O
)	O
;	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
=	O
malloc	(long)->(*(void))
(	O
NUM_COUNTERS	O
*	O
sizeof	O
(	O
temp_number	long
)	O
+	O
sizeof	O
(	O
&	O
temp_number	long
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
NUM_COUNTERS	O
;	O
j	long
++	O
)	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
j	long
]	O
=	O
0	int
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
=	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
=	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
}	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
!=	O
NULL	O
)	O
{	O
hash_index	long
=	O
create_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
hash_index	long
==	O
-	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to insert new hash entry"	*(char)
)	O
)	O
;	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
=	O
NULL	O
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
=	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
=	O
key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
}	O
}	O
key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
=	O
NULL	O
;	O
}	O
else	O
{	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
hrchy_key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
ref_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
=	O
NULL	O
;	O
}	O
if	O
(	O
gi_data_is_reference	int
!=	O
0	int
)	O
{	O
int	O
write_dummy	int
;	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
NULL	O
,	O
0	int
,	O
&	O
write_dummy	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
}	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
records_dropped_filter	int
++	O
;	O
}	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
=	O
df_get_next_record	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),long)->(*(struct(long,enum(int,int,int),*(char))))
(	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_length	int
)	O
;	O
}	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\rReading from reference file (%ld) %s: %12d records"	*(char)
)	O
,	O
i	long
+	O
1	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
reference_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
)	O
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
process_data_file	(*(char))->(int)
(	O
input_filename	*(char)
)	O
char	O
*	O
input_filename	*(char)
;	O
{	O
STRINGTYPE	O
*	O
value	*(struct(long,enum(int,int,int),*(char)))
;	O
int	O
write_record	int
;	O
STRINGTYPE	O
*	O
new_value	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
tmp_buf_ptr	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
;	O
STRINGTYPE	O
*	O
*	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
i	long
;	O
int	O
return_code	int
;	O
value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
new_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
tmp_buf_ptr	*(struct(long,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
gi_file_records_read	int
=	O
0	int
;	O
gi_file_records_dropped_filter	int
=	O
0	int
;	O
gi_file_records_matched	int
=	O
0	int
;	O
gi_file_output_records_written	int
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
input_filename	*(char)
,	O
"-"	*(char)
)	O
)	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
input_filename	*(char)
,	O
"r"	*(char)
)	O
;	O
else	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
input_filename	*(char)
)	O
;	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
=	O
df_get_next_record	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),long)->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_input_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_input_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_input_buffer_size	long
)	O
,	O
gs_data_input_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
gi_data_input_record_length	int
)	O
;	O
while	O
(	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
keep_record	int
;	O
gi_data_records_read	int
++	O
;	O
gi_file_records_read	int
++	O
;	O
keep_record	int
=	O
1	int
;	O
write_record	int
=	O
1	int
;	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
&&	O
(	O
gi_file_records_read	int
%	O
1000	int
)	O
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\rReading from data file %s: %12d records"	*(char)
)	O
,	O
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
?	O
"stdin"	*(char)
:	O
input_filename	*(char)
)	O
,	O
gi_file_records_read	int
)	O
;	O
return_code	int
=	O
a_find_input_ranges	(*(*(*(struct(long,enum(int,int,int),*`)))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,enum(int,int,int),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
&	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
,	O
gi_data_out_range_count	int
,	O
gi_data_out_end_start	int
,	O
gs_data_input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
gi_data_input_field_delimiter_repeat	int
,	O
DStr_not_own	int
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_data_empty_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
if	O
(	O
gs_data_empty_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fill_empty_fields	(*(*(struct(long,enum(int,int,int),*(char)))),long,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
gi_data_out_range_count	int
,	O
gs_data_empty_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
keep_record	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
0	int
,	O
&	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
write_record	int
!=	O
0	int
)	O
{	O
gi_data_records_matched	int
++	O
;	O
gi_file_records_matched	int
++	O
;	O
}	O
}	O
else	O
{	O
gi_file_records_dropped_filter	int
++	O
;	O
gi_data_records_dropped_filter	int
++	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_data_out_range_count	int
;	O
i	long
++	O
)	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
=	O
df_get_next_record	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),long)->(*(struct(long,enum(int,int,int),*(char))))
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_input_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_input_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_input_buffer_size	long
)	O
,	O
gs_data_input_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
gi_data_input_record_length	int
)	O
;	O
}	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\rReading from data file %s: %12d records"	*(char)
)	O
,	O
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
?	O
"stdin"	*(char)
:	O
input_filename	*(char)
)	O
,	O
gi_file_records_read	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
FATAL_PERROR	O
(	O
input_filename	*(char)
)	O
;	O
if	O
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
input_filename	*(char)
)	O
;	O
}	O
if	O
(	O
gi_data_optional_ind	int
!=	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_reference_file_count	int
;	O
j	long
++	O
)	O
{	O
REFINFO	O
[	O
j	long
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
&&	O
*	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
==	O
0	int
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
=	O
j	long
;	O
write_match_record	()->(int)
(	O
NULL	O
)	O
;	O
}	O
}	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
gs_data_input_buffer	*(char)
)	O
;	O
gs_data_input_buffer	*(char)
=	O
NULL	O
;	O
gi_data_input_buffer_size	long
=	O
0	int
;	O
gi_data_input_buffer_pos	long
=	O
0	int
;	O
if	O
(	O
gi_statistics_ind	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Statistics for data file %s\n"	*(char)
)	O
,	O
input_filename	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records read:              %15d\n"	*(char)
)	O
,	O
gi_file_records_read	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records dropped by filter: %15d\n"	*(char)
)	O
,	O
gi_file_records_dropped_filter	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records matched on key:    %15d\n"	*(char)
)	O
,	O
gi_file_records_matched	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records written:           %15d\n"	*(char)
)	O
,	O
gi_file_output_records_written	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
reference_file_number	int
;	O
int	O
*	O
write_record	int
;	O
STRINGTYPE	O
*	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
STRINGTYPE	O
*	O
key_value	*(struct(long,enum(int,int,int),*(char)))
;	O
int	O
j	long
;	O
int	O
k	int
;	O
HASHTYPE	O
hash_index	long
;	O
int	O
first_written	int
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
)	O
{	O
key_value	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrnew	()->(*(struct(long,enum(int,int,int),*(char))))
(	O
)	O
;	O
if	O
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
find_input_ranges	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(struct(long,long,int,*(char))),int,long,*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_ranges	*(struct(long,long,int,*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_range_count	int
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_end_start	int
,	O
gs_data_input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
gi_data_input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
hash_index	long
=	O
find_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
}	O
do	O
{	O
int	O
keep_match	int
;	O
keep_match	int
=	O
1	int
;	O
if	O
(	O
(	O
hash_index	long
==	O
-	O
1	int
||	O
keep_match	int
!=	O
1	int
)	O
&&	O
gi_reference_file_count	int
!=	O
0	int
)	O
{	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
optional_ind	int
==	O
0	int
)	O
*	O
write_record	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
&&	O
keep_match	int
==	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
{	O
traverse_hierarchy	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))),long,long)->(long)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
hash_index	long
,	O
0	int
)	O
;	O
}	O
else	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_index	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
if	O
(	O
keep_match	int
!=	O
1	int
||	O
gi_reference_file_count	int
==	O
0	int
||	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_range_count	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_end_start	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
keep_match	int
==	O
1	int
&&	O
gi_reference_file_count	int
!=	O
0	int
)	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_index	long
;	O
else	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
)	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
if	O
(	O
*	O
write_record	int
==	O
0	int
&&	O
gi_checkallref_ind	int
==	O
0	int
)	O
{	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
key_value	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
gi_reference_file_count	int
>	O
0	int
&&	O
hash_index	long
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
another_for_key	int
!=	O
0	int
)	O
{	O
do	O
{	O
hash_index	long
=	O
(	O
hash_index	long
+	O
1	int
)	O
%	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
;	O
}	O
while	O
(	O
dstrcmp	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
,	O
key_value	*(struct(long,enum(int,int,int),*(char)))
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
hash_index	long
=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
;	O
}	O
while	O
(	O
gi_reference_file_count	int
>	O
0	int
&&	O
hash_index	long
!=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
write_output	()->(int)
(	O
)	O
{	O
int	O
i	long
;	O
int	O
j	long
;	O
int	O
k	int
;	O
char	O
counterformat	array(char)
[	O
10	int
]	O
;	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
return_code	int
;	O
int	O
first_written	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
counterformat	array(char)
,	O
"%%%dd"	*(char)
,	O
gi_output_counter_size	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
!=	O
NULL	O
)	O
{	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
else	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
records_stored	int
++	O
;	O
first_written	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
FLAG_INDEX	O
]	O
!=	O
0	int
)	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched_key	int
++	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
FLAG_INDEX	O
]	O
==	O
1	int
)	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched	int
++	O
;	O
REFINFO	O
[	O
i	long
]	O
.	O
data_records_matched	int
+=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
write_ind	int
==	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
==	O
NULL	O
)	O
{	O
if	O
(	O
TOTAL_REF_OUT_RANGES	O
(	O
i	long
)	O
>	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
;	O
k	int
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
k	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
return_code	int
=	O
df_write_output	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
first_written	int
=	O
1	int
;	O
}	O
for	O
(	O
k	int
=	O
SKIP_COUNTERS	O
;	O
k	int
<	O
NUM_COUNTERS	O
;	O
k	int
++	O
)	O
{	O
char	O
temp_value	array(char)
[	O
100	int
]	O
;	O
STRINGTYPE	O
*	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
;	O
if	O
(	O
k	int
<	O
2	int
||	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
STRINGTYPE	O
*	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
;	O
COUNTTYPE	O
temp_scale	long
;	O
COUNTTYPE	O
temp_remainder	long
;	O
temp_scale	long
=	O
pow	(double,double)->(double)
(	O
10	int
,	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"precision causes fixed decimal overflow in sum field number %d"	*(char)
)	O
,	O
k	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
<	O
0	int
&&	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
>	O
-	O
1	int
*	O
temp_scale	long
)	O
{	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
"-"	*(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
-	O
2	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
-	O
1	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
}	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
"."	*(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
temp_remainder	long
=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
k	int
]	O
%	O
temp_scale	long
;	O
if	O
(	O
temp_remainder	long
<	O
0	int
)	O
temp_remainder	long
*=	O
-	O
1	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFRACTFORMAT	*(char)
,	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
,	O
temp_remainder	long
)	O
;	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
}	O
else	O
{	O
char	O
temp_value	array(char)
[	O
100	int
]	O
;	O
STRINGTYPE	O
*	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order_count	int
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
!=	O
i	long
+	O
1	int
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"reference file order requests another reference file"	*(char)
)	O
)	O
;	O
switch	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
FLAG_INDEX	O
]	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
STRINGTYPE	O
*	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
;	O
COUNTTYPE	O
temp_scale	long
;	O
COUNTTYPE	O
temp_remainder	long
;	O
temp_scale	long
=	O
pow	(double,double)->(double)
(	O
10	int
,	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"precision causes fixed decimal overflow in sum field number %d"	*(char)
)	O
,	O
k	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
<	O
0	int
&&	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
>	O
-	O
1	int
*	O
temp_scale	long
)	O
{	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
"-"	*(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
-	O
2	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFORMAT	*(char)
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
-	O
1	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
}	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
"."	*(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
temp_remainder	long
=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
j	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
%	O
temp_scale	long
;	O
if	O
(	O
temp_remainder	long
<	O
0	int
)	O
temp_remainder	long
*=	O
-	O
1	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp_value	array(char)
,	O
COUNTFRACTFORMAT	*(char)
,	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
,	O
temp_remainder	long
)	O
;	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrdupstr	(*(char))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_value	array(char)
)	O
;	O
if	O
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
=	O
dstrcat	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_period	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_dstring	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown reference order field type: %c.%c"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown reference order field source: %c"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),int,int)->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	*(char)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
0	int
,	O
1	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
gi_statistics_ind	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Statistics for reference file %s\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records read:              %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records dropped by filter: %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_dropped_filter	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records stored:            %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_stored	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records matched on key:    %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched_key	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of records matched fully:     %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Number of reference-data matches:    %15d\n"	*(char)
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
data_records_matched	int
)	O
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
HASHTYPE	O
traverse_hierarchy	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))),long,long)->(long)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
start	long
,	O
depth	long
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
int	O
reference_file_number	int
;	O
int	O
*	O
write_record	int
;	O
STRINGTYPE	O
*	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
;	O
HASHTYPE	O
start	long
;	O
HASHTYPE	O
depth	long
;	O
{	O
HASHTYPE	O
hash_entry	long
;	O
HASHTYPE	O
next_hash_entry	long
;	O
HASHTYPE	O
other_hash_entry	long
;	O
hash_entry	long
=	O
start	long
;	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
==	O
NULL	O
)	O
{	O
while	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
!=	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
}	O
}	O
next_hash_entry	long
=	O
find_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
next_hash_entry	long
==	O
-	O
1	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"referential integrity problem: cannot find key %.*s"	*(char)
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
->	O
string	*(char)
)	O
;	O
hash_entry	long
=	O
next_hash_entry	long
;	O
}	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
}	O
return	O
hash_entry	long
;	O
}	O
else	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_curr_depth	long
=	O
depth	long
+	O
1	int
;	O
hrchy_add_path	(long,long,*(*(long)),*(long),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
depth	long
,	O
hash_entry	long
,	O
&	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_path	*(long)
)	O
,	O
&	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_path_size	long
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
}	O
}	O
next_hash_entry	long
=	O
find_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
next_hash_entry	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
!=	O
0	int
||	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
!=	O
0	int
)	O
{	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
;	O
}	O
}	O
}	O
}	O
else	O
do	O
{	O
other_hash_entry	long
=	O
find_table_entry	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,int,*(struct(long,enum(int,int,int),*`)),*(struct(long,enum(int,int,int),*`)),*(*(struct`)),*(*(long)),*(void))),long)->(long)
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
next_hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
other_hash_entry	long
==	O
-	O
1	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"referential integrity problem: cannot find key %.*s"	*(char)
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
next_hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
next_hash_entry	long
]	O
.	O
chain_key	*(struct(long,enum(int,int,int),*(char)))
->	O
string	*(char)
)	O
;	O
if	O
(	O
other_hash_entry	long
!=	O
-	O
1	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
other_hash_entry	long
;	O
traverse_hierarchy	(*(*(struct(long,enum(int,int,int),*(char)))),int,*(int),*(struct(long,enum(int,int,int),*(char))),long,long)->(long)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
other_hash_entry	long
,	O
depth	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
next_hash_entry	long
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
next_hash_entry	long
]	O
.	O
another_for_key	int
!=	O
0	int
)	O
{	O
do	O
{	O
next_hash_entry	long
=	O
(	O
next_hash_entry	long
+	O
1	int
)	O
%	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
;	O
}	O
while	O
(	O
dstrcmp	(*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
next_hash_entry	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_entry	long
]	O
.	O
value	*(struct(long,enum(int,int,int),*(char)))
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
next_hash_entry	long
=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
;	O
}	O
while	O
(	O
next_hash_entry	long
!=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
)	O
;	O
}	O
return	O
start	long
;	O
}	O
int	O
write_match_record	()->(int)
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
{	O
int	O
first_written	int
;	O
int	O
return_code	int
;	O
int	O
i	long
;	O
int	O
j	long
;	O
int	O
k	int
;	O
if	O
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
&&	O
gi_data_exclude_match_ind	int
)	O
return	O
EXIT_SUCCESS	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
exclude_match_ind	int
)	O
return	O
EXIT_SUCCESS	int
;	O
}	O
gi_output_records_written	int
++	O
;	O
gi_file_output_records_written	int
++	O
;	O
first_written	int
=	O
0	int
;	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
==	O
NULL	O
)	O
{	O
if	O
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	long
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
gi_data_out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gi_data_out_range_count	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
;	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_reference_file_count	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_flatten_levels	int
!=	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_flatten_levels	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
i	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_curr_depth	long
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_path	*(long)
[	O
i	long
]	O
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	long
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_path	*(long)
[	O
i	long
]	O
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
;	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
j	long
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
;	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_data_output_field_order_count	int
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
)	O
{	O
case	O
's'	O
:	O
break	O
;	O
case	O
'r'	O
:	O
switch	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
int	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
>	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_pos	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
;	O
i	long
<	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
i	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_pos	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
wrote_something	int
;	O
wrote_something	int
=	O
0	int
;	O
while	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
hash_pos	int
;	O
k	int
++	O
;	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
==	O
0	int
&&	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
{	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
hash_pos	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_pos	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
wrote_something	int
==	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
!=	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
!=	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
constant_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown data output order field type: %c.%c"	*(char)
)	O
,	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
,	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
switch	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
if	O
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
>	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
;	O
i	long
<	O
gi_data_out_range_count	int
+	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
i	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
i	long
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
wrote_something	int
;	O
wrote_something	int
=	O
0	int
;	O
while	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
hash_pos	int
;	O
k	int
++	O
;	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
==	O
0	int
&&	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
{	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
hash_pos	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_pos	int
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
wrote_something	int
==	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
&&	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
!=	O
gi_data_out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
!=	O
gi_data_out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	*(struct(long,long,int,*(char)))
[	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
else	O
{	O
return_code	int
=	O
df_write_field	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(int),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
&	O
first_written	int
,	O
gs_data_constant_string	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown data output order field type: %c.%c"	*(char)
)	O
,	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
,	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown output order field source: %c"	*(char)
)	O
,	O
gra_data_output_field_order	*(struct(char,int,char,int))
[	O
k	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(long),*(long),*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),int,int)->(int)
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
(	O
gs_data_output_buffer	*(char)
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	*(struct(long,enum(int,int,int),*(char)))
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	*(char)
)	O
;	O
}	O
int	O
update_counters	(int,long,*(*(struct(long,enum(int,int,int),*(char)))),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
reference_file_number	int
,	O
hash_index	long
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
)	O
int	O
reference_file_number	int
;	O
HASHTYPE	O
hash_index	long
;	O
STRINGTYPE	O
*	O
*	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
;	O
STRINGTYPE	O
*	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
int	O
j	long
;	O
int	O
k	int
;	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
FLAG_INDEX	O
]	O
|=	O
1	int
;	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
+=	O
1	int
;	O
j	long
=	O
2	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_data_sum_range_count	int
;	O
k	int
++	O
)	O
{	O
DStr_string_descriptor	struct(long,enum(int,int,int),*(char))
*	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
;	O
char	O
*	O
temp_value	array(char)
;	O
if	O
(	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
]	O
.	O
format	*(char)
!=	O
NULL	O
)	O
{	O
int	O
ifield	int
;	O
for	O
(	O
ifield	int
=	O
0	int
;	O
ifield	int
<	O
gi_data_out_range_count	int
+	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ifield	int
++	O
)	O
{	O
create_scheme_string_variable	(*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
&	O
df_name_data_field	struct(long,enum(int,int,int),*(char))
,	O
ifield	int
+	O
1	int
,	O
data_output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ifield	int
]	O
)	O
;	O
}	O
for	O
(	O
ifield	int
=	O
0	int
;	O
ifield	int
<	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
out_range_count	int
+	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ifield	int
++	O
)	O
{	O
create_scheme_string_variable	(*(struct(long,enum(int,int,int),*(char))),int,*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
&	O
df_name_reference_field	struct(long,enum(int,int,int),*(char))
,	O
ifield	int
+	O
1	int
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
output_fields	*(*(struct(long,enum(int,int,int),*(char))))
[	O
ifield	int
]	O
)	O
;	O
}	O
}	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
=	O
find_field	(*(struct(long,long,int,*(char))),int,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))))->(*(struct(long,enum(int,int,int),*(char))))
(	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
,	O
gi_data_sum_range_count	int
,	O
k	int
,	O
input_record_desc	*(struct(long,enum(int,int,int),*(char)))
,	O
gs_data_input_field_delimiter	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
temp_value	array(char)
=	O
strdupdstr	(*(struct(long,enum(int,int,int),*(char))))->(*(char))
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
if	O
(	O
temp_value	array(char)
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
if	O
(	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
]	O
.	O
precision	int
==	O
0	int
)	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
j	long
+	O
k	int
]	O
+=	O
CONVERT_SUM	O
(	O
temp_value	array(char)
)	O
;	O
else	O
CONVERT_SUM_PRECISION	O
(	O
temp_value	array(char)
,	O
gra_data_sum_ranges	*(struct(long,long,int,*(char)))
[	O
k	int
]	O
.	O
precision	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	*(struct(long,int,*(struct(long,enum(int,int,int),*(char))),*(struct(long,enum(int,int,int),*(char))),*(*(struct(long,enum(int,int,int),*`))),*(*(long)),*(void)))
[	O
hash_index	long
]	O
.	O
info	*(void)
)	O
)	O
[	O
j	long
+	O
k	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
temp_value	array(char)
)	O
;	O
dstrfree	(*(struct(long,enum(int,int,int),*(char))))->(void)
(	O
temp_string	*(struct(long,enum(int,int,int),*(char)))
)	O
;	O
}	O
}	O
int	O
hrchy_add_path	(long,long,*(*(long)),*(long),*(struct(long,enum(int,int,int),*(char))))->(int)
(	O
depth	long
,	O
new_entry	long
,	O
path	*(*(long))
,	O
path_size	*(long)
,	O
key	*(struct(long,enum(int,int,int),*(char)))
)	O
HASHTYPE	O
depth	long
;	O
HASHTYPE	O
new_entry	long
;	O
HASHTYPE	O
*	O
*	O
path	*(*(long))
;	O
HASHTYPE	O
*	O
path_size	*(long)
;	O
STRINGTYPE	O
*	O
key	*(struct(long,enum(int,int,int),*(char)))
;	O
{	O
int	O
i	long
;	O
if	O
(	O
*	O
path	*(*(long))
==	O
NULL	O
)	O
{	O
*	O
path	*(*(long))
=	O
malloc	(long)->(*(void))
(	O
DF_HRCHY_INCREMENT	int
*	O
sizeof	O
(	O
HASHTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
path	*(*(long))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
*	O
path_size	*(long)
=	O
DF_HRCHY_INCREMENT	int
;	O
}	O
else	O
if	O
(	O
*	O
path_size	*(long)
<=	O
depth	long
)	O
{	O
*	O
path	*(*(long))
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
path	*(*(long))
,	O
(	O
*	O
path_size	*(long)
+	O
DF_HRCHY_INCREMENT	int
)	O
*	O
sizeof	O
(	O
HASHTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
path	*(*(long))
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	*(char)
)	O
)	O
;	O
*	O
path_size	*(long)
+=	O
DF_HRCHY_INCREMENT	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
depth	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
(	O
*	O
path	*(*(long))
)	O
[	O
i	long
]	O
==	O
new_entry	long
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"loop in hierarchy: %.*s"	*(char)
)	O
,	O
key	*(struct(long,enum(int,int,int),*(char)))
->	O
length	long
,	O
key	*(struct(long,enum(int,int,int),*(char)))
->	O
string	*(char)
)	O
;	O
}	O
(	O
*	O
path	*(*(long))
)	O
[	O
depth	long
]	O
=	O
new_entry	long
;	O
}	O
