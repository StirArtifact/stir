struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
firstUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
*	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
*	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
char	O
undoBuf	array(char)
[	O
4096	int
]	O
;	O
int	O
undoBufIndex	int
=	O
0	int
;	O
int	O
undoBufChars	int
=	O
0	int
;	O
char	O
undoBufRep	array(char)
[	O
4096	int
]	O
;	O
int	O
undoBufRepIndex	int
=	O
0	int
;	O
int	O
undoBufRepChars	int
=	O
0	int
;	O
int	O
clipboardSize	int
=	O
0	int
;	O
point	struct(int,int)
find_result_pos	array(struct(int,int))
[	O
1024	int
]	O
;	O
int	O
total_find_results	int
;	O
void	O
deleteUndoList	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
first	int
)	O
{	O
while	O
(	O
first	int
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
first	int
->	O
prev	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
if	O
(	O
first	int
->	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
first	int
->	O
text	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
first	int
)	O
;	O
first	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
}	O
}	O
void	O
deleteRedoList	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
first	int
)	O
{	O
while	O
(	O
first	int
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
first	int
->	O
next	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
if	O
(	O
first	int
->	O
text	*(char)
)	O
free	(*(void))->(void)
(	O
first	int
->	O
text	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
first	int
)	O
;	O
first	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
}	O
}	O
void	O
initEdit	()->(void)
(	O
)	O
{	O
firstUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
deleteUndoList	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
deleteRedoList	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
undoBufChars	int
=	O
0	int
;	O
undoBufIndex	int
=	O
0	int
;	O
undoBufRepChars	int
=	O
0	int
;	O
undoBufRepIndex	int
=	O
0	int
;	O
if	O
(	O
clipboardSize	int
==	O
0	int
)	O
{	O
clipboardSize	int
=	O
1024	int
;	O
clipboard	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
clipboardSize	int
)	O
;	O
}	O
}	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
{	O
if	O
(	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
&&	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_NONE	int
)	O
return	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
)	O
)	O
;	O
if	O
(	O
!	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
NULL	O
;	O
}	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
=	O
0	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
=	O
0	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rbyteCount	int
=	O
0	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rlineCount	int
=	O
0	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
=	O
-	O
1	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
=	O
-	O
1	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
=	O
NULL	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
=	O
NULL	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
=	O
UNDO_ACTION_NONE	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
next	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
{	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
prev	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
next	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
}	O
else	O
{	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
prev	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
firstUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
}	O
deleteRedoList	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
return	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
}	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
getLastUndo	(int)->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
int	O
allocIfNull	int
)	O
{	O
if	O
(	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
return	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
if	O
(	O
!	O
allocIfNull	int
)	O
return	O
NULL	O
;	O
return	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
;	O
}	O
void	O
initUndoAction	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))),enum(int,int,int,int),int,int)->(void)
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
undoActionType	enum(int,int,int,int)
utype	enum(int,int,int,int)
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
)	O
{	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
=	O
utype	enum(int,int,int,int)
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
=	O
lwhere	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
=	O
cwhere	int
;	O
}	O
int	O
copyFromBuf	(*(*(char)),*(char),int)->(int)
(	O
char	O
*	O
*	O
dest	*(*(char))
,	O
char	O
*	O
buf	*(char)
,	O
int	O
bcount	int
)	O
{	O
if	O
(	O
bcount	int
==	O
0	int
)	O
return	O
1	int
;	O
*	O
dest	*(*(char))
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
bcount	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
dest	*(*(char))
)	O
return	O
0	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
*	O
dest	*(*(char))
,	O
buf	*(char)
,	O
bcount	int
)	O
;	O
(	O
*	O
dest	*(*(char))
)	O
[	O
bcount	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
void	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
undoBufIndex	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
copyFromBuf	(*(*(char)),*(char),int)->(int)
(	O
&	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
undoBuf	array(char)
,	O
undoBufIndex	int
)	O
)	O
goto	O
memerr	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
=	O
undoBufIndex	int
;	O
if	O
(	O
!	O
copyFromBuf	(*(*(char)),*(char),int)->(int)
(	O
&	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
undoBufRep	array(char)
,	O
undoBufRepIndex	int
)	O
)	O
goto	O
memerr	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rbyteCount	int
=	O
undoBufRepIndex	int
;	O
undoBufIndex	int
=	O
0	int
;	O
undoBufChars	int
=	O
0	int
;	O
undoBufRepChars	int
=	O
0	int
;	O
undoBufRepIndex	int
=	O
0	int
;	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
int	O
isContinuous	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))),int,int)->(int)
(	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
int	O
l2	int
,	O
int	O
c2	int
)	O
{	O
int	O
l1	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
if	O
(	O
l1	int
!=	O
l2	int
)	O
return	O
0	int
;	O
int	O
c1	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
if	O
(	O
c1	int
==	O
c2	int
||	O
c2	int
==	O
c1	int
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
c2	int
==	O
c1	int
+	O
undoBufChars	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
undoAddChar	(enum(int,int,int,int),int,int,char)->(void)
(	O
undoActionType	enum(int,int,int,int)
utype	enum(int,int,int,int)
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
,	O
char	O
what	char
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
getLastUndo	(int)->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
1	int
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
goto	O
memerr	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
!=	O
utype	enum(int,int,int,int)
||	O
!	O
isContinuous	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))),int,int)->(int)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
lwhere	int
,	O
cwhere	int
)	O
)	O
{	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
!=	O
UNDO_ACTION_NONE	int
)	O
{	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
goto	O
memerr	O
;	O
}	O
initUndoAction	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))),enum(int,int,int,int),int,int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
,	O
utype	enum(int,int,int,int)
,	O
lwhere	int
,	O
cwhere	int
)	O
;	O
}	O
if	O
(	O
cwhere	int
==	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
)	O
{	O
for	O
(	O
int	O
i	int
=	O
undoBufIndex	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
undoBuf	array(char)
[	O
undoBufIndex	int
]	O
=	O
undoBuf	array(char)
[	O
undoBufIndex	int
-	O
1	int
]	O
;	O
undoBuf	array(char)
[	O
0	int
]	O
=	O
what	char
;	O
}	O
else	O
undoBuf	array(char)
[	O
undoBufIndex	int
]	O
=	O
what	char
;	O
undoBufIndex	int
++	O
;	O
if	O
(	O
(	O
what	char
&	O
0xc0	int
)	O
!=	O
0x80	int
)	O
undoBufChars	int
++	O
;	O
if	O
(	O
what	char
==	O
'\n'	O
)	O
{	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
;	O
}	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
int	O
undoAddUtfChar	(enum(int,int,int,int),int,int,*(char))->(int)
(	O
undoActionType	enum(int,int,int,int)
utype	enum(int,int,int,int)
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
,	O
char	O
*	O
rwhat	*(char)
)	O
{	O
int	O
save	int
=	O
cwhere	int
;	O
char	O
*	O
what	char
;	O
if	O
(	O
utype	enum(int,int,int,int)
==	O
UNDO_ACTION_INSERT	int
)	O
what	char
=	O
rwhat	*(char)
;	O
else	O
what	char
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
lwhere	int
]	O
->	O
text	*(char)
+	O
cwhere	int
;	O
undoAddChar	(enum(int,int,int,int),int,int,char)->(void)
(	O
utype	enum(int,int,int,int)
,	O
lwhere	int
,	O
cwhere	int
,	O
*	O
what	char
)	O
;	O
while	O
(	O
++	O
cwhere	int
,	O
(	O
*	O
(	O
++	O
what	char
)	O
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
undoAddChar	(enum(int,int,int,int),int,int,char)->(void)
(	O
utype	enum(int,int,int,int)
,	O
lwhere	int
,	O
cwhere	int
,	O
*	O
what	char
)	O
;	O
if	O
(	O
utype	enum(int,int,int,int)
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
char	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
*	O
rwhat	*(char)
++	O
)	O
)	O
undoBufRep	array(char)
[	O
undoBufRepIndex	int
++	O
]	O
=	O
c	char
;	O
}	O
return	O
cwhere	int
-	O
save	int
;	O
}	O
int	O
extendClipboardSize	(int)->(int)
(	O
int	O
newSize	int
)	O
{	O
if	O
(	O
newSize	int
<	O
clipboardSize	int
)	O
return	O
1	int
;	O
clipboardSize	int
=	O
newSize	int
+	O
1	int
;	O
if	O
(	O
clipboard	*(char)
)	O
free	(*(void))->(void)
(	O
clipboard	*(char)
)	O
;	O
clipboard	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
clipboardSize	int
)	O
;	O
if	O
(	O
!	O
clipboard	*(char)
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
}	O
void	O
swap_lines	()->(void)
(	O
)	O
{	O
int	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct(int,int)
.	O
nline	int
;	O
sel_range_end	struct(int,int)
.	O
nline	int
=	O
sel_range_start	struct(int,int)
.	O
nline	int
;	O
sel_range_start	struct(int,int)
.	O
nline	int
=	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct(int,int)
.	O
nchar	int
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
sel_range_start	struct(int,int)
.	O
nchar	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
tmp	int
;	O
}	O
void	O
swap_chars	()->(void)
(	O
)	O
{	O
int	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct(int,int)
.	O
nchar	int
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
sel_range_start	struct(int,int)
.	O
nchar	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
tmp	int
;	O
}	O
void	O
clear_selected_range	()->(void)
(	O
)	O
{	O
}	O
void	O
editMenu_DeleteLine	()->(void)
(	O
)	O
{	O
deleteLine	()->(void)
(	O
)	O
;	O
}	O
void	O
editMenu_ToggleSelectMode	()->(void)
(	O
)	O
{	O
if	O
(	O
X_IS_RUNNING	int
)	O
{	O
SELECTING	int
=	O
!	O
SELECTING	int
;	O
refreshBottomView	()->(void)
(	O
)	O
;	O
if	O
(	O
SELECTING	int
)	O
{	O
sel_range_start	struct(int,int)
.	O
nline	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
selectedChar	int
;	O
sel_range_end	struct(int,int)
.	O
nline	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
selectedChar	int
;	O
}	O
}	O
else	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"The select mode is only available under X.\nUse SHIFT to select text."	*(char)
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
editMenu_Copy	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
SELECTING	int
&&	O
!	O
SELECTED	int
)	O
return	O
;	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
;	O
if	O
(	O
!	O
clipboard	*(char)
)	O
goto	O
memerr	O
;	O
clipboard	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
int	O
swap	int
=	O
0	int
;	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
>	O
sel_range_end	struct(int,int)
.	O
nline	int
)	O
{	O
swap	int
=	O
1	int
;	O
swap_lines	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
==	O
sel_range_end	struct(int,int)
.	O
nline	int
&&	O
sel_range_start	struct(int,int)
.	O
nchar	int
>	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
{	O
swap	int
=	O
2	int
;	O
swap_chars	()->(void)
(	O
)	O
;	O
}	O
total_lines_in_clipboard	int
=	O
sel_range_end	struct(int,int)
.	O
nline	int
-	O
sel_range_start	struct(int,int)
.	O
nline	int
;	O
if	O
(	O
total_lines_in_clipboard	int
==	O
0	int
)	O
{	O
j	int
=	O
charsToBytes	(int,int)->(int)
(	O
sel_range_start	struct(int,int)
.	O
nline	int
,	O
sel_range_start	struct(int,int)
.	O
nchar	int
)	O
;	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
sel_range_end	struct(int,int)
.	O
nline	int
,	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
;	O
i	int
=	O
k	int
-	O
j	int
;	O
if	O
(	O
!	O
extendClipboardSize	(int)->(int)
(	O
i	int
)	O
)	O
goto	O
memerr	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
clipboard	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
sel_range_start	struct(int,int)
.	O
nline	int
]	O
->	O
text	*(char)
+	O
j	int
,	O
i	int
)	O
;	O
clipboard	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
j	int
=	O
charsToBytes	(int,int)->(int)
(	O
sel_range_start	struct(int,int)
.	O
nline	int
,	O
sel_range_start	struct(int,int)
.	O
nchar	int
)	O
;	O
l	int
+=	O
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
sel_range_start	struct(int,int)
.	O
nline	int
]	O
->	O
byteCount	int
-	O
j	int
)	O
;	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
sel_range_end	struct(int,int)
.	O
nline	int
,	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
;	O
l	int
+=	O
k	int
;	O
for	O
(	O
i	int
=	O
sel_range_start	struct(int,int)
.	O
nline	int
+	O
1	int
;	O
i	int
<	O
sel_range_end	struct(int,int)
.	O
nline	int
;	O
i	int
++	O
)	O
l	int
+=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
byteCount	int
;	O
if	O
(	O
!	O
extendClipboardSize	(int)->(int)
(	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
clipboard	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
sel_range_start	struct(int,int)
.	O
nline	int
]	O
->	O
text	*(char)
+	O
j	int
)	O
;	O
for	O
(	O
i	int
=	O
sel_range_start	struct(int,int)
.	O
nline	int
+	O
1	int
;	O
i	int
<	O
sel_range_end	struct(int,int)
.	O
nline	int
;	O
i	int
++	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
clipboard	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
text	*(char)
)	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
clipboard	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
sel_range_end	struct(int,int)
.	O
nline	int
]	O
->	O
text	*(char)
,	O
k	int
)	O
;	O
clipboard	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
}	O
CLIPBOARD_IS_EMPTY	int
=	O
0	int
;	O
if	O
(	O
swap	int
==	O
1	int
)	O
swap_lines	()->(void)
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
2	int
)	O
swap_chars	()->(void)
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
void	O
editMenu_Cut	()->(void)
(	O
)	O
{	O
if	O
(	O
SELECTING	int
||	O
SELECTED	int
)	O
{	O
editMenu_Copy	()->(void)
(	O
)	O
;	O
remove_selected_text	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
void	O
remove_selected_text	(int)->(void)
(	O
int	O
recordAction	int
)	O
{	O
int	O
swap	int
=	O
0	int
;	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
>	O
sel_range_end	struct(int,int)
.	O
nline	int
)	O
{	O
swap	int
=	O
1	int
;	O
swap_lines	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
==	O
sel_range_end	struct(int,int)
.	O
nline	int
&&	O
sel_range_start	struct(int,int)
.	O
nchar	int
>	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
{	O
swap	int
=	O
2	int
;	O
swap_chars	()->(void)
(	O
)	O
;	O
}	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
;	O
int	O
refreshAll	int
=	O
0	int
;	O
int	O
first	int
=	O
sel_range_start	struct(int,int)
.	O
nline	int
;	O
int	O
last	int
=	O
sel_range_end	struct(int,int)
.	O
nline	int
;	O
int	O
diff	int
=	O
last	int
-	O
first	int
;	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
getLastUndo	(int)->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
1	int
)	O
;	O
if	O
(	O
recordAction	int
)	O
{	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
=	O
UNDO_ACTION_DELETE	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
=	O
sel_range_start	struct(int,int)
.	O
nline	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
=	O
sel_range_start	struct(int,int)
.	O
nchar	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
=	O
diff	int
;	O
}	O
if	O
(	O
diff	int
==	O
0	int
)	O
{	O
j	int
=	O
charsToBytes	(int,int)->(int)
(	O
first	int
,	O
sel_range_start	struct(int,int)
.	O
nchar	int
)	O
;	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
last	int
,	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
;	O
i	int
=	O
k	int
-	O
j	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
i	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
)	O
goto	O
memerr	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
j	int
,	O
i	int
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
=	O
i	int
;	O
}	O
if	O
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
sel_range_start	struct(int,int)
.	O
nline	int
]	O
->	O
linkedToNext	int
)	O
refreshAll	int
=	O
1	int
;	O
copyInLine	(int,int,int,int)->(void)
(	O
sel_range_start	struct(int,int)
.	O
nline	int
,	O
j	int
,	O
k	int
,	O
0	int
)	O
;	O
checkLineBounds	(int)->(void)
(	O
sel_range_start	struct(int,int)
.	O
nline	int
)	O
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
j	int
=	O
charsToBytes	(int,int)->(int)
(	O
first	int
,	O
sel_range_start	struct(int,int)
.	O
nchar	int
)	O
;	O
l	int
+=	O
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
-	O
j	int
)	O
;	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
last	int
,	O
sel_range_end	struct(int,int)
.	O
nchar	int
)	O
;	O
l	int
+=	O
k	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
for	O
(	O
i	int
=	O
first	int
+	O
1	int
;	O
i	int
<	O
last	int
;	O
i	int
++	O
)	O
l	int
+=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
byteCount	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
)	O
goto	O
memerr	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
j	int
)	O
;	O
for	O
(	O
i	int
=	O
first	int
+	O
1	int
;	O
i	int
<	O
last	int
;	O
i	int
++	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
text	*(char)
)	O
;	O
strncat	(*(char),*(char),long)->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
last	int
]	O
->	O
text	*(char)
,	O
k	int
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
[	O
l	int
]	O
=	O
'\0'	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
=	O
l	int
;	O
}	O
l	int
=	O
j	int
+	O
k	int
;	O
if	O
(	O
l	int
>=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
,	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
goto	O
memerr	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
=	O
s	*(char)
;	O
}	O
strncat	(*(char),*(char),long)->(*(char))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
j	int
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
last	int
]	O
->	O
text	*(char)
,	O
k	int
)	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
[	O
j	int
+	O
k	int
]	O
=	O
'\0'	O
;	O
calcTotalCharsInLine	(int)->(void)
(	O
first	int
)	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
last	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	(int,int)->(void)
(	O
first	int
+	O
1	int
,	O
last	int
-	O
first	int
)	O
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
refreshAll	int
=	O
1	int
;	O
}	O
SELECTING	int
=	O
0	int
;	O
SELECTED	int
=	O
0	int
;	O
FILE_STATE	enum(int,int,int,int,int)
=	O
MODIFIED	int
;	O
selectedChar	int
=	O
sel_range_start	struct(int,int)
.	O
nchar	int
;	O
refreshAll	int
=	O
fixViewPostUndo	(int)->(int)
(	O
first	int
)	O
;	O
if	O
(	O
refreshAll	int
)	O
refreshView	()->(void)
(	O
)	O
;	O
else	O
refreshSelectedLine	()->(void)
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
1	int
)	O
swap_lines	()->(void)
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
2	int
)	O
swap_chars	()->(void)
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
void	O
_do_paste	(*(char),int,int)->(void)
(	O
char	O
*	O
src	*(char)
,	O
int	O
srcLineCount	int
,	O
int	O
recordAction	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
int	O
k	int
=	O
selectedChar	int
;	O
int	O
l	int
;	O
if	O
(	O
(	O
srcLineCount	int
+	O
totalLines	int
)	O
>=	O
MAX_LINES	int
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Unable to paste text. Line count will exceed the maximum of "	*(char)
tostr	O
(	O
MAX_LINES	int
)	O
"."	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
else	O
l	int
=	O
srcLineCount	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
getLastUndo	(int)->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
1	int
)	O
;	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
allocNewUndo	()->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
)	O
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
=	O
UNDO_ACTION_INSERT	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
=	O
j	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
=	O
k	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
=	O
l	int
;	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
src	*(char)
)	O
;	O
}	O
int	O
tmpLen	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
byteCount	int
-	O
charsToBytes	(int,int)->(int)
(	O
j	int
,	O
k	int
)	O
;	O
char	O
tmp	int
[	O
tmpLen	int
+	O
1	int
]	O
;	O
if	O
(	O
tmpLen	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
tmp	int
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
text	*(char)
+	O
k	int
)	O
;	O
else	O
tmp	int
[	O
0	int
]	O
=	O
'\0'	O
;	O
int	O
n	int
=	O
l	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
totalLines	int
+	O
l	int
;	O
i	int
>	O
j	int
+	O
l	int
;	O
i	int
--	O
)	O
copyLineStruct	(int,int)->(void)
(	O
i	int
,	O
i	int
-	O
l	int
)	O
;	O
for	O
(	O
;	O
i	int
>	O
j	int
;	O
i	int
--	O
)	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
=	O
allocLineStructB	(int)->(*(struct(*(char),int,int,int,int)))
(	O
maxLen	int
)	O
;	O
i	int
=	O
0	int
;	O
l	int
+=	O
j	int
+	O
1	int
;	O
char	O
*	O
line	*(struct(*(char),int,int,int,int))
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
text	*(char)
;	O
char	O
*	O
clip	*(char)
=	O
src	*(char)
;	O
while	O
(	O
j	int
<=	O
l	int
)	O
{	O
if	O
(	O
k	int
>=	O
MAX_CHARS_PER_LINE	int
)	O
{	O
move_lines_down	(int,int)->(void)
(	O
totalLines	int
,	O
j	int
+	O
1	int
)	O
;	O
n	int
++	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
linkedToNext	int
=	O
1	int
;	O
*	O
line	*(struct(*(char),int,int,int,int))
=	O
'\0'	O
;	O
k	int
=	O
0	int
;	O
calcTotalCharsInLine	(int)->(void)
(	O
j	int
)	O
;	O
line	*(struct(*(char),int,int,int,int))
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
++	O
j	int
]	O
->	O
text	*(char)
;	O
selectedLine	int
++	O
;	O
}	O
if	O
(	O
*	O
clip	*(char)
==	O
'\0'	O
)	O
{	O
*	O
line	*(struct(*(char),int,int,int,int))
=	O
'\0'	O
;	O
calcTotalCharsInLine	(int)->(void)
(	O
j	int
)	O
;	O
selectedLine	int
++	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
clip	*(char)
==	O
'\n'	O
)	O
{	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
linkedToNext	int
=	O
0	int
;	O
*	O
line	*(struct(*(char),int,int,int,int))
++	O
=	O
'\n'	O
;	O
*	O
line	*(struct(*(char),int,int,int,int))
=	O
'\0'	O
;	O
k	int
=	O
0	int
;	O
calcTotalCharsInLine	(int)->(void)
(	O
j	int
)	O
;	O
line	*(struct(*(char),int,int,int,int))
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
++	O
j	int
]	O
->	O
text	*(char)
;	O
clip	*(char)
++	O
;	O
selectedLine	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
clip	*(char)
==	O
'\t'	O
)	O
{	O
i	int
=	O
TABSPACES	O
(	O
k	int
+	O
1	int
)	O
;	O
k	int
+=	O
i	int
;	O
}	O
else	O
k	int
++	O
;	O
*	O
line	*(struct(*(char),int,int,int,int))
++	O
=	O
*	O
clip	*(char)
++	O
;	O
}	O
}	O
totalLines	int
+=	O
n	int
;	O
if	O
(	O
tmpLen	int
)	O
{	O
i	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
byteCount	int
+	O
tmpLen	int
;	O
if	O
(	O
i	int
>=	O
maxLen	int
)	O
{	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
j	int
,	O
i	int
)	O
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
j	int
]	O
->	O
text	*(char)
,	O
tmp	int
)	O
;	O
checkLineBounds	(int)->(void)
(	O
j	int
)	O
;	O
}	O
if	O
(	O
selectedLine	int
>=	O
totalVisLines	int
)	O
{	O
int	O
diff	int
=	O
selectedLine	int
-	O
totalVisLines	int
+	O
1	int
;	O
firstVisLine	int
+=	O
diff	int
;	O
selectedLine	int
-=	O
diff	int
;	O
}	O
if	O
(	O
totalLines	int
<=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
0	int
;	O
selectedLine	int
=	O
totalLines	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
totalLines	int
-	O
j	int
)	O
<	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
(	O
totalLines	int
-	O
j	int
)	O
-	O
1	int
;	O
}	O
selectedChar	int
=	O
k	int
;	O
}	O
void	O
editMenu_Paste	()->(void)
(	O
)	O
{	O
if	O
(	O
CLIPBOARD_IS_EMPTY	int
)	O
return	O
;	O
_do_paste	(*(char),int,int)->(void)
(	O
clipboard	*(char)
,	O
total_lines_in_clipboard	int
,	O
1	int
)	O
;	O
SELECTED	int
=	O
0	int
;	O
SELECTING	int
=	O
0	int
;	O
FILE_STATE	enum(int,int,int,int,int)
=	O
MODIFIED	int
;	O
refreshView	()->(void)
(	O
)	O
;	O
}	O
void	O
editMenu_SelectAll	()->(void)
(	O
)	O
{	O
SELECTING	int
=	O
1	int
;	O
sel_range_start	struct(int,int)
.	O
nline	int
=	O
0	int
;	O
sel_range_end	struct(int,int)
.	O
nline	int
=	O
totalLines	int
-	O
1	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
0	int
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
totalLines	int
-	O
1	int
]	O
->	O
charCount	int
;	O
if	O
(	O
sel_range_end	struct(int,int)
.	O
nchar	int
<	O
0	int
)	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
0	int
;	O
if	O
(	O
totalLines	int
<=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
0	int
;	O
selectedLine	int
=	O
totalLines	int
-	O
1	int
;	O
selectedChar	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
selectedLine	int
]	O
->	O
charCount	int
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
selectedChar	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
firstVisLine	int
+	O
selectedLine	int
]	O
->	O
charCount	int
;	O
}	O
calcCharCarry	(int)->(void)
(	O
firstVisLine	int
+	O
selectedLine	int
)	O
;	O
SELECTING	int
=	O
0	int
;	O
SELECTED	int
=	O
1	int
;	O
refreshView	()->(void)
(	O
)	O
;	O
}	O
int	O
fixViewPostUndo	(int)->(int)
(	O
int	O
first	int
)	O
{	O
int	O
refreshAll	int
=	O
0	int
;	O
if	O
(	O
first	int
<	O
firstVisLine	int
)	O
{	O
selectedLine	int
=	O
0	int
;	O
firstVisLine	int
=	O
first	int
;	O
refreshAll	int
=	O
1	int
;	O
}	O
else	O
{	O
selectedLine	int
=	O
first	int
-	O
firstVisLine	int
;	O
if	O
(	O
selectedLine	int
>=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
+=	O
(	O
selectedLine	int
-	O
totalVisLines	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
}	O
if	O
(	O
firstVisLine	int
+	O
totalVisLines	int
>	O
totalLines	int
)	O
{	O
int	O
i	int
=	O
firstVisLine	int
;	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
+=	O
(	O
firstVisLine	int
-	O
i	int
)	O
;	O
refreshAll	int
=	O
1	int
;	O
}	O
return	O
refreshAll	int
;	O
}	O
void	O
editMenu_Undo	()->(void)
(	O
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
getLastUndo	(int)->(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))
(	O
0	int
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
flushUndoBuffer	(*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*`,*`,*`,*`)))))->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
)	O
;	O
int	O
first	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
int	O
i	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
;	O
int	O
j	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rbyteCount	int
;	O
int	O
k	int
,	O
l	int
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
first	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
l	int
=	O
i	int
-	O
j	int
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
+	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
<	O
j	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
i	int
)	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
i	int
)	O
;	O
}	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
calcCharCarry	(int)->(void)
(	O
first	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
;	O
k	int
+=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
k	int
+	O
1	int
)	O
)	O
goto	O
memerr	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
,	O
s	*(char)
+	O
1	int
)	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
+	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	(int,int)->(void)
(	O
first	int
+	O
1	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
)	O
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
firstVisLine	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
_do_paste	(*(char),int,int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_INSERT	int
)	O
{	O
sel_range_start	struct(int,int)
.	O
nline	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
sel_range_end	struct(int,int)
.	O
nline	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
+	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
char	O
*	O
s	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
s	*(char)
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
-	O
1	int
;	O
i	int
=	O
utfstrlen	(*(char))->(int)
(	O
s	*(char)
+	O
1	int
)	O
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
i	int
;	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
==	O
sel_range_end	struct(int,int)
.	O
nline	int
)	O
sel_range_end	struct(int,int)
.	O
nchar	int
+=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
remove_selected_text	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_DELETE	int
)	O
{	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
==	O
0	int
)	O
{	O
k	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
+	O
i	int
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
k	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
+	O
i	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
,	O
0	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
i	int
)	O
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
calcCharCarry	(int)->(void)
(	O
first	int
)	O
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
_do_paste	(*(char),int,int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
fixViewPostUndo	(int)->(int)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
)	O
;	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
prev	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
calcCharCarry	(int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
void	O
editMenu_Redo	()->(void)
(	O
)	O
{	O
struct	O
undostruct	struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))))))
*	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
int	O
first	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
int	O
i	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rbyteCount	int
;	O
int	O
j	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
byteCount	int
;	O
int	O
k	int
,	O
l	int
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
first	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
)	O
;	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
l	int
=	O
i	int
-	O
j	int
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
+	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
<	O
j	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
i	int
)	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
i	int
)	O
;	O
}	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
calcCharCarry	(int)->(void)
(	O
first	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
;	O
k	int
+=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
k	int
+	O
1	int
)	O
)	O
goto	O
memerr	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
,	O
s	*(char)
+	O
1	int
)	O
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
+	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	(int,int)->(void)
(	O
first	int
+	O
1	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
)	O
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
firstVisLine	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
_do_paste	(*(char),int,int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_INSERT	int
)	O
{	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
==	O
0	int
)	O
{	O
k	int
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
byteCount	int
+	O
j	int
;	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
first	int
,	O
k	int
)	O
)	O
goto	O
memerr	O
;	O
i	int
=	O
charsToBytes	(int,int)->(int)
(	O
first	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
)	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
first	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
+	O
j	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
,	O
0	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
first	int
]	O
->	O
text	*(char)
+	O
i	int
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
j	int
)	O
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
checkLineBounds	(int)->(void)
(	O
first	int
)	O
;	O
calcCharCarry	(int)->(void)
(	O
first	int
)	O
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
_do_paste	(*(char),int,int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
rtext	*(char)
,	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int,int)
==	O
UNDO_ACTION_DELETE	int
)	O
{	O
sel_range_start	struct(int,int)
.	O
nline	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
;	O
sel_range_end	struct(int,int)
.	O
nline	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
+	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineCount	int
;	O
sel_range_start	struct(int,int)
.	O
nchar	int
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
char	O
*	O
s	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
s	*(char)
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
text	*(char)
-	O
1	int
;	O
i	int
=	O
utfstrlen	(*(char))->(int)
(	O
s	*(char)
+	O
1	int
)	O
;	O
sel_range_end	struct(int,int)
.	O
nchar	int
=	O
i	int
;	O
if	O
(	O
sel_range_start	struct(int,int)
.	O
nline	int
==	O
sel_range_end	struct(int,int)
.	O
nline	int
)	O
sel_range_end	struct(int,int)
.	O
nchar	int
+=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
charStart	int
;	O
remove_selected_text	(int)->(void)
(	O
0	int
)	O
;	O
}	O
fixViewPostUndo	(int)->(int)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
)	O
;	O
firstRedo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
next	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
lastUndo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
=	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
;	O
calcCharCarry	(int)->(void)
(	O
undo	*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`))),*(struct(enum(int,int,int,int),int,int,int,int,int,int,*(char),*(char),*(struct`),*(struct`)))))
->	O
lineStart	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
void	O
editMenu_Find	()->(void)
(	O
)	O
{	O
char	O
*	O
f	*(char)
=	O
getUserInput	(*(char),*(char))->(*(char))
(	O
"Enter text to find:  "	*(char)
,	O
" Find "	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(char)
)	O
{	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
int	O
i	int
;	O
_find	(*(char))->(void)
(	O
f	*(char)
)	O
;	O
if	O
(	O
!	O
total_find_results	int
)	O
{	O
free	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"No matches were found."	*(char)
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
i	int
=	O
0	int
;	O
char	O
*	O
c	char
;	O
while	O
(	O
1	int
)	O
{	O
int	O
x	int
=	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nline	int
-	O
firstVisLine	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
firstVisLine	int
+=	O
x	int
;	O
selectedLine	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
x	int
>=	O
totalVisLines	int
)	O
{	O
x	int
-=	O
totalVisLines	int
;	O
firstVisLine	int
+=	O
(	O
x	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
else	O
selectedLine	int
=	O
x	int
;	O
}	O
selectedChar	int
=	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nchar	int
;	O
calcCharCarry	(int)->(void)
(	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nline	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
setScreenColorsI	(int)->(void)
(	O
COLOR_STATUS_BAR	int
)	O
;	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [C-g] Cancel"	*(char)
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [ESC] Cancel"	*(char)
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;1HFind(%d/%d): [Up] Prev [Down] Next [ESC] Cancel"	*(char)
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;%dH"	*(char)
,	O
selectedLine	int
+	O
3	int
,	O
selectedChar	int
+	O
2	int
+	O
selectedCharCarry	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
get_key	O
:	O
c	char
=	O
getKey	()->(*(char))
(	O
)	O
;	O
switch	O
(	O
c	char
[	O
0	int
]	O
)	O
{	O
case	O
(	O
'p'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_up	O
;	O
case	O
(	O
UP_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_up	O
:	O
if	O
(	O
i	int
<=	O
0	int
)	O
i	int
=	O
total_find_results	int
-	O
1	int
;	O
else	O
i	int
--	O
;	O
break	O
;	O
case	O
(	O
'n'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_down	O
;	O
case	O
(	O
DOWN_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_down	O
:	O
case	O
(	O
ENTER_KEY	int
)	O
:	O
case	O
(	O
SPACE_KEY	int
)	O
:	O
if	O
(	O
i	int
>=	O
total_find_results	int
-	O
1	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
'g'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
3	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_esc	O
;	O
case	O
(	O
ESC_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
break	O
;	O
do_esc	O
:	O
refreshView	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
return	O
;	O
default	O
:	O
goto	O
get_key	O
;	O
break	O
;	O
}	O
}	O
return	O
;	O
}	O
void	O
editMenu_Replace	()->(void)
(	O
)	O
{	O
char	O
*	O
f	*(char)
=	O
getUserInput	(*(char),*(char))->(*(char))
(	O
"Enter text to find:  "	*(char)
,	O
" Find "	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(char)
)	O
{	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
char	O
*	O
r	*(char)
=	O
getUserInput	(*(char),*(char))->(*(char))
(	O
"Enter replacement text: "	*(char)
,	O
" Replace "	*(char)
)	O
;	O
if	O
(	O
!	O
r	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
int	O
i	int
;	O
_find	(*(char))->(void)
(	O
f	*(char)
)	O
;	O
if	O
(	O
!	O
total_find_results	int
)	O
{	O
free	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
r	*(char)
)	O
;	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"No matches were found."	*(char)
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
i	int
=	O
0	int
;	O
char	O
*	O
c	char
;	O
while	O
(	O
1	int
)	O
{	O
int	O
x	int
=	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nline	int
-	O
firstVisLine	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
firstVisLine	int
+=	O
x	int
;	O
selectedLine	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
x	int
>=	O
totalVisLines	int
)	O
{	O
x	int
-=	O
totalVisLines	int
;	O
firstVisLine	int
+=	O
(	O
x	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
else	O
selectedLine	int
=	O
x	int
;	O
}	O
selectedChar	int
=	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nchar	int
;	O
calcCharCarry	(int)->(void)
(	O
find_result_pos	array(struct(int,int))
[	O
i	int
]	O
.	O
nline	int
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
setScreenColorsI	(int)->(void)
(	O
COLOR_STATUS_BAR	int
)	O
;	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [C-g] Cancel"	*(char)
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [ESC] Cancel"	*(char)
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\e[%d;%dH"	*(char)
,	O
selectedLine	int
+	O
3	int
,	O
selectedChar	int
+	O
2	int
+	O
selectedCharCarry	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
get_key	O
:	O
c	char
=	O
getKey	()->(*(char))
(	O
)	O
;	O
switch	O
(	O
c	char
[	O
0	int
]	O
)	O
{	O
case	O
(	O
'p'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_up	O
;	O
case	O
(	O
UP_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_up	O
:	O
if	O
(	O
i	int
<=	O
0	int
)	O
i	int
=	O
total_find_results	int
-	O
1	int
;	O
else	O
i	int
--	O
;	O
break	O
;	O
case	O
(	O
'n'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_down	O
;	O
case	O
(	O
DOWN_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_down	O
:	O
if	O
(	O
i	int
>=	O
total_find_results	int
-	O
1	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
'g'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
3	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_esc	O
;	O
case	O
(	O
ESC_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
break	O
;	O
do_esc	O
:	O
goto	O
finish	O
;	O
break	O
;	O
case	O
(	O
SPACE_KEY	int
)	O
:	O
case	O
(	O
ENTER_KEY	int
)	O
:	O
_replace	(int,*(char),*(char))->(void)
(	O
i	int
,	O
f	*(char)
,	O
r	*(char)
)	O
;	O
if	O
(	O
i	int
>=	O
total_find_results	int
)	O
i	int
--	O
;	O
if	O
(	O
total_find_results	int
<=	O
0	int
)	O
goto	O
finish	O
;	O
break	O
;	O
case	O
(	O
'a'	O
)	O
:	O
_replace	(int,*(char),*(char))->(void)
(	O
-	O
1	int
,	O
f	*(char)
,	O
r	*(char)
)	O
;	O
total_find_results	int
=	O
0	int
;	O
goto	O
finish	O
;	O
break	O
;	O
default	O
:	O
goto	O
get_key	O
;	O
break	O
;	O
}	O
}	O
finish	O
:	O
free	(*(void))->(void)
(	O
f	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
r	*(char)
)	O
;	O
refreshView	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
void	O
_replace	(int,*(char),*(char))->(void)
(	O
int	O
pos	int
,	O
char	O
*	O
f	*(char)
,	O
char	O
*	O
r	*(char)
)	O
{	O
int	O
i	int
=	O
strlen	(*(char))->(long)
(	O
f	*(char)
)	O
;	O
int	O
j	int
=	O
strlen	(*(char))->(long)
(	O
r	*(char)
)	O
;	O
int	O
old_firstVisLine	int
=	O
firstVisLine	int
;	O
int	O
old_selectedLine	int
=	O
selectedLine	int
;	O
int	O
old_selectedChar	int
=	O
selectedChar	int
;	O
int	O
old_selectedCharCarry	int
=	O
selectedCharCarry	int
;	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
_do_replace	(int,*(char),*(char))->(void)
(	O
pos	int
,	O
f	*(char)
,	O
r	*(char)
)	O
;	O
FILE_STATE	enum(int,int,int,int,int)
=	O
MODIFIED	int
;	O
}	O
else	O
{	O
if	O
(	O
i	int
==	O
j	int
)	O
{	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
total_find_results	int
;	O
pos	int
++	O
)	O
{	O
_do_replace	(int,*(char),*(char))->(void)
(	O
pos	int
,	O
f	*(char)
,	O
r	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
total_find_results	int
)	O
{	O
_do_replace	(int,*(char),*(char))->(void)
(	O
0	int
,	O
f	*(char)
,	O
r	*(char)
)	O
;	O
}	O
}	O
}	O
firstVisLine	int
=	O
old_firstVisLine	int
;	O
selectedLine	int
=	O
old_selectedLine	int
;	O
selectedChar	int
=	O
old_selectedChar	int
;	O
selectedCharCarry	int
=	O
old_selectedCharCarry	int
;	O
}	O
void	O
_find	(*(char))->(void)
(	O
char	O
*	O
f	*(char)
)	O
{	O
int	O
i	int
,	O
k	int
=	O
0	int
;	O
char	O
*	O
j	int
;	O
int	O
flen	int
=	O
strlen	(*(char))->(long)
(	O
f	*(char)
)	O
;	O
total_find_results	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
totalLines	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
line	*(struct(*(char),int,int,int,int))
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
text	*(char)
;	O
while	O
(	O
(	O
j	int
=	O
strcasestr	(*(char),*(char))->(*(char))
(	O
line	*(struct(*(char),int,int,int,int))
,	O
f	*(char)
)	O
)	O
)	O
{	O
find_result_pos	array(struct(int,int))
[	O
k	int
]	O
.	O
nline	int
=	O
i	int
;	O
find_result_pos	array(struct(int,int))
[	O
k	int
++	O
]	O
.	O
nchar	int
=	O
(	O
j	int
-	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
i	int
]	O
->	O
text	*(char)
)	O
;	O
total_find_results	int
++	O
;	O
line	*(struct(*(char),int,int,int,int))
=	O
j	int
+	O
flen	int
;	O
}	O
}	O
}	O
void	O
_do_replace	(int,*(char),*(char))->(void)
(	O
int	O
pos	int
,	O
char	O
*	O
f	*(char)
,	O
char	O
*	O
r	*(char)
)	O
{	O
int	O
i	int
=	O
strlen	(*(char))->(long)
(	O
f	*(char)
)	O
;	O
int	O
j	int
=	O
strlen	(*(char))->(long)
(	O
r	*(char)
)	O
;	O
int	O
k	int
,	O
l	int
,	O
n	int
,	O
m	int
;	O
k	int
=	O
find_result_pos	array(struct(int,int))
[	O
pos	int
]	O
.	O
nchar	int
;	O
l	int
=	O
find_result_pos	array(struct(int,int))
[	O
pos	int
]	O
.	O
nline	int
;	O
n	int
=	O
0	int
;	O
firstVisLine	int
=	O
l	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
k	int
;	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
l	int
,	O
selectedChar	int
)	O
;	O
char	O
*	O
f2	*(char)
=	O
f	*(char)
;	O
while	O
(	O
*	O
f2	*(char)
)	O
{	O
undoAddChar	(enum(int,int,int,int),int,int,char)->(void)
(	O
UNDO_ACTION_REPLACE	int
,	O
l	int
,	O
k	int
,	O
*	O
f2	*(char)
)	O
;	O
while	O
(	O
++	O
k	int
,	O
(	O
*	O
(	O
++	O
f2	*(char)
)	O
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
undoAddChar	(enum(int,int,int,int),int,int,char)->(void)
(	O
UNDO_ACTION_REPLACE	int
,	O
l	int
,	O
k	int
,	O
*	O
f2	*(char)
)	O
;	O
}	O
k	int
=	O
charsToBytes	(int,int)->(int)
(	O
l	int
,	O
selectedChar	int
)	O
;	O
f2	*(char)
=	O
r	*(char)
;	O
char	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
*	O
f2	*(char)
++	O
)	O
)	O
undoBufRep	array(char)
[	O
undoBufRepIndex	int
++	O
]	O
=	O
c	char
;	O
if	O
(	O
i	int
==	O
j	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
l	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
r	*(char)
,	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
l	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
r	*(char)
,	O
j	int
)	O
;	O
copyInLine	(int,int,int,int)->(void)
(	O
l	int
,	O
k	int
+	O
j	int
,	O
k	int
+	O
i	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
extendLineText	(int,int)->(int)
(	O
l	int
,	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
l	int
]	O
->	O
byteCount	int
+	O
j	int
-	O
i	int
+	O
1	int
)	O
)	O
{	O
msgBox	(*(char),int,enum(int,int,int))->(int)
(	O
"Insufficient memory!"	*(char)
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
copyInLine	(int,int,int,int)->(void)
(	O
l	int
,	O
k	int
+	O
j	int
,	O
k	int
+	O
i	int
,	O
0	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
l	int
]	O
->	O
text	*(char)
+	O
k	int
,	O
r	*(char)
,	O
j	int
)	O
;	O
}	O
FILE_STATE	enum(int,int,int,int,int)
=	O
MODIFIED	int
;	O
checkLineBounds	(int)->(void)
(	O
l	int
)	O
;	O
_find	(*(char))->(void)
(	O
f	*(char)
)	O
;	O
}	O
void	O
calcTotalCharsInLineC	(int,*(int))->(void)
(	O
int	O
pos	int
,	O
int	O
*	O
carry	*(int)
)	O
{	O
int	O
totalCharsInLine	int
=	O
0	int
;	O
*	O
carry	*(int)
=	O
0	int
;	O
int	O
k	int
;	O
char	O
*	O
c	char
=	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
pos	int
]	O
->	O
text	*(char)
;	O
while	O
(	O
*	O
c	char
)	O
{	O
if	O
(	O
(	O
*	O
c	char
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
continue	O
;	O
if	O
(	O
*	O
c	char
==	O
'\r'	O
||	O
*	O
c	char
==	O
'\n'	O
||	O
*	O
c	char
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
c	char
==	O
'\t'	O
)	O
{	O
k	int
=	O
TABSPACES	O
(	O
totalCharsInLine	int
+	O
(	O
*	O
carry	*(int)
)	O
+	O
1	int
)	O
;	O
(	O
*	O
carry	*(int)
)	O
+=	O
k	int
;	O
}	O
totalCharsInLine	int
++	O
;	O
c	char
++	O
;	O
}	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
pos	int
]	O
->	O
charCount	int
=	O
totalCharsInLine	int
;	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
pos	int
]	O
->	O
byteCount	int
=	O
c	char
-	O
lines	array(*(struct(*(char),int,int,int,int)))
[	O
pos	int
]	O
->	O
text	*(char)
;	O
}	O
void	O
calcTotalCharsInLine	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
int	O
carry	*(int)
=	O
0	int
;	O
calcTotalCharsInLineC	(int,*(int))->(void)
(	O
pos	int
,	O
&	O
carry	*(int)
)	O
;	O
}	O
int	O
utfstrlen	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
c	char
;	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
str	*(char)
++	O
)	O
)	O
{	O
if	O
(	O
(	O
c	char
&	O
0xc0	int
)	O
!=	O
0x80	int
)	O
count	int
++	O
;	O
}	O
return	O
count	int
;	O
}	O
