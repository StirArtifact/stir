struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
{	O
int	O
pos	int
[	O
MAX_MOVES	int
]	O
;	O
int	O
score	float
[	O
MAX_MOVES	int
]	O
;	O
const	O
char	O
*	O
message	*(char)
[	O
MAX_MOVES	int
]	O
;	O
int	O
num	int
;	O
int	O
num_tried	int
;	O
}	O
;	O
static	O
int	O
do_find_defense	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
defend1	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
defend2	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
defend3	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
defend4	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
void	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
bamboo_rescue_moves	(int,int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
num_libs	int
,	O
int	O
libs	*(int)
[	O
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_rescue2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_rescue3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_rescue4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
hane_rescue_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
4	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_rescue5_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_rescue6_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
set_up_snapback_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
edge_clamp_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
int	O
do_attack	int
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
attack1	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
attack2	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
attack3	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
attack4	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
void	O
find_cap_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_attack2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_attack3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
special_attack4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
draw_back_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
edge_closing_backfill_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
edge_block_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
int	O
*	O
libs	*(int)
,	O
int	O
liberties	*(int)
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
color	int
)	O
;	O
static	O
void	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
int	O
defend_secondary_chain1_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(int)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
min_liberties	int
)	O
;	O
static	O
void	O
defend_secondary_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
min_liberties	int
)	O
;	O
static	O
void	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
do_find_break_chain2_efficient_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
break_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
require_safe	int
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain2_defense_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain3_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain4_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
liberty_cap	int
,	O
int	O
does_attack	(int,int)->(int)
)	O
;	O
static	O
void	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
superstring_break_chain_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
liberty_cap	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
;	O
static	O
void	O
double_atari_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
generate_more_moves	int
)	O
;	O
static	O
void	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
color	int
,	O
const	O
char	O
*	O
funcname	*(char)
,	O
int	O
killer	int
)	O
;	O
static	O
int	O
simple_ladder_defend	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
;	O
static	O
int	O
in_list	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
num_moves	int
,	O
int	O
*	O
moves	array(int)
)	O
;	O
static	O
int	O
reading_node_counter	int
=	O
0	int
;	O
static	O
int	O
nodes_when_called	int
=	O
0	int
;	O
int	O
attack	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
result	int
;	O
int	O
nodes	int
;	O
int	O
origin	int
;	O
int	O
the_move	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
nodes_when_called	int
=	O
reading_node_counter	int
;	O
if	O
(	O
liberties	*(int)
>	O
4	int
||	O
(	O
liberties	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	*(int)
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
return	O
0	int
;	O
origin	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(int),*(int))->(int)
(	O
ATTACK	int
,	O
origin	int
,	O
&	O
result	int
,	O
&	O
the_move	int
)	O
)	O
{	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
shadow	array(char)
,	O
0	int
,	O
sizeof	O
(	O
shadow	array(char)
)	O
)	O
;	O
result	int
=	O
do_attack	int
(	O
str	int
,	O
&	O
the_move	int
)	O
;	O
nodes	int
=	O
reading_node_counter	int
-	O
nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
{	O
if	O
(	O
reading_node_counter	int
-	O
nodes_when_called	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
result	int
!=	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%oattack %1m(%1m) = %d %1M, %d nodes "	*(char)
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
else	O
gprintf	(*(char))->(int)
(	O
"%oattack %1m(%1m) = %d, %d nodes "	*(char)
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
nodes	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
}	O
store_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int)->(void)
(	O
ATTACK	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
int	O
find_defense	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
result	int
;	O
int	O
nodes	int
;	O
int	O
origin	int
;	O
int	O
the_move	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
nodes_when_called	int
=	O
reading_node_counter	int
;	O
if	O
(	O
liberties	*(int)
>	O
4	int
||	O
(	O
liberties	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
{	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
return	O
WIN	int
;	O
}	O
origin	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(int),*(int))->(int)
(	O
FIND_DEFENSE	int
,	O
origin	int
,	O
&	O
result	int
,	O
&	O
the_move	int
)	O
)	O
{	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
shadow	array(char)
,	O
0	int
,	O
sizeof	O
(	O
shadow	array(char)
)	O
)	O
;	O
result	int
=	O
do_find_defense	(int,*(int))->(int)
(	O
str	int
,	O
&	O
the_move	int
)	O
;	O
nodes	int
=	O
reading_node_counter	int
-	O
nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
{	O
if	O
(	O
reading_node_counter	int
-	O
nodes_when_called	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
result	int
!=	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%odefend %1m(%1m) = %d %1M, %d nodes "	*(char)
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
else	O
gprintf	(*(char))->(int)
(	O
"%odefend %1m(%1m) = %d, %d nodes "	*(char)
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
nodes	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
}	O
}	O
store_persistent_reading_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int)->(void)
(	O
FIND_DEFENSE	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
int	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
attack_code	*(int)
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
defend_code	*(int)
,	O
int	O
*	O
defense_point	*(int)
)	O
{	O
int	O
acode	int
=	O
0	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
dcode	int
=	O
find_defense	(int,*(int))->(int)
(	O
str	int
,	O
&	O
dpos	int
)	O
;	O
ASSERT1	O
(	O
!	O
(	O
acode	int
!=	O
0	int
&&	O
dcode	int
==	O
WIN	int
&&	O
dpos	int
==	O
NO_MOVE	O
)	O
,	O
str	int
)	O
;	O
if	O
(	O
attack_code	*(int)
)	O
*	O
attack_code	*(int)
=	O
acode	int
;	O
if	O
(	O
attack_point	*(int)
)	O
*	O
attack_point	*(int)
=	O
apos	int
;	O
if	O
(	O
defend_code	*(int)
)	O
*	O
defend_code	*(int)
=	O
dcode	int
;	O
if	O
(	O
defense_point	*(int)
)	O
*	O
defense_point	*(int)
=	O
dpos	int
;	O
return	O
acode	int
!=	O
0	int
&&	O
dcode	int
!=	O
0	int
;	O
}	O
int	O
attack_either	(int,int)->(int)
(	O
int	O
astr	int
,	O
int	O
bstr	int
)	O
{	O
int	O
asuccess	int
=	O
0	int
;	O
int	O
bsuccess	int
=	O
0	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
astr	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
astr	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	*(char)
[	O
bstr	int
]	O
,	O
bstr	int
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
astr	int
)	O
>	O
countlib	(int)->(int)
(	O
bstr	int
)	O
)	O
{	O
int	O
t	int
=	O
astr	int
;	O
astr	int
=	O
bstr	int
;	O
bstr	int
=	O
t	int
;	O
}	O
asuccess	int
=	O
attack	(int,*(int))->(int)
(	O
astr	int
,	O
NULL	O
)	O
;	O
if	O
(	O
asuccess	int
==	O
WIN	int
)	O
return	O
asuccess	int
;	O
bsuccess	int
=	O
attack	(int,*(int))->(int)
(	O
bstr	int
,	O
NULL	O
)	O
;	O
if	O
(	O
asuccess	int
||	O
bsuccess	int
)	O
{	O
return	O
(	O
asuccess	int
>	O
bsuccess	int
)	O
?	O
asuccess	int
:	O
bsuccess	int
;	O
}	O
{	O
int	O
alibs	array(int)
[	O
2	int
]	O
;	O
int	O
blibs	array(int)
[	O
2	int
]	O
;	O
int	O
alib	int
=	O
findlib	(int,int,*(int))->(int)
(	O
astr	int
,	O
2	int
,	O
alibs	array(int)
)	O
;	O
int	O
defended0	int
=	O
WIN	int
;	O
int	O
defended1	int
=	O
WIN	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
alib	int
==	O
2	int
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
alibs	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
"attack_either-A"	*(char)
,	O
astr	int
)	O
)	O
{	O
defended0	int
=	O
defend_both	(int,int)->(int)
(	O
astr	int
,	O
bstr	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
defended0	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
alibs	array(int)
[	O
1	int
]	O
,	O
other	int
,	O
"attack_either-B"	*(char)
,	O
astr	int
)	O
)	O
{	O
defended1	int
=	O
defend_both	(int,int)->(int)
(	O
astr	int
,	O
bstr	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
defended0	int
>	O
0	int
&&	O
defended1	int
>	O
0	int
&&	O
findlib	(int,int,*(int))->(int)
(	O
bstr	int
,	O
2	int
,	O
blibs	array(int)
)	O
==	O
2	int
)	O
{	O
defended0	int
=	O
gg_min	O
(	O
defended0	int
,	O
defended1	int
)	O
;	O
defended1	int
=	O
defended0	int
;	O
if	O
(	O
alib	int
==	O
1	int
)	O
alibs	array(int)
[	O
1	int
]	O
=	O
NO_MOVE	O
;	O
if	O
(	O
blibs	array(int)
[	O
0	int
]	O
!=	O
alibs	array(int)
[	O
0	int
]	O
&&	O
blibs	array(int)
[	O
0	int
]	O
!=	O
alibs	array(int)
[	O
1	int
]	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
blibs	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
"attack_either-C"	*(char)
,	O
bstr	int
)	O
)	O
{	O
int	O
defended	int
=	O
defend_both	(int,int)->(int)
(	O
astr	int
,	O
bstr	int
)	O
;	O
defended0	int
=	O
gg_min	O
(	O
defended0	int
,	O
defended	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
defended0	int
&&	O
blibs	array(int)
[	O
1	int
]	O
!=	O
alibs	array(int)
[	O
0	int
]	O
&&	O
blibs	array(int)
[	O
1	int
]	O
!=	O
alibs	array(int)
[	O
1	int
]	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
blibs	array(int)
[	O
1	int
]	O
,	O
other	int
,	O
"attack_either-D"	*(char)
,	O
bstr	int
)	O
)	O
{	O
int	O
defended	int
=	O
defend_both	(int,int)->(int)
(	O
astr	int
,	O
bstr	int
)	O
;	O
defended1	int
=	O
gg_min	O
(	O
defended1	int
,	O
defended	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
return	O
REVERSE_RESULT	O
(	O
gg_min	O
(	O
defended0	int
,	O
defended1	int
)	O
)	O
;	O
}	O
}	O
int	O
defend_both	(int,int)->(int)
(	O
int	O
astr	int
,	O
int	O
bstr	int
)	O
{	O
int	O
a_threatened	int
=	O
0	int
;	O
int	O
b_threatened	int
=	O
0	int
;	O
int	O
a_savepos	int
;	O
int	O
b_savepos	int
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
astr	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
astr	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	*(char)
[	O
bstr	int
]	O
,	O
bstr	int
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
astr	int
)	O
>	O
countlib	(int)->(int)
(	O
bstr	int
)	O
)	O
{	O
int	O
t	int
=	O
astr	int
;	O
astr	int
=	O
bstr	int
;	O
bstr	int
=	O
t	int
;	O
}	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
astr	int
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
a_savepos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
a_threatened	int
=	O
1	int
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
return	O
0	int
;	O
}	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
bstr	int
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
b_savepos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
b_threatened	int
=	O
1	int
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
a_threatened	int
||	O
!	O
b_threatened	int
)	O
return	O
WIN	int
;	O
if	O
(	O
a_savepos	int
==	O
b_savepos	int
)	O
return	O
WIN	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
a_savepos	int
,	O
color	int
,	O
"defend_both-A"	*(char)
,	O
astr	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
bstr	int
]	O
&&	O
!	O
attack	(int,*(int))->(int)
(	O
bstr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
b_savepos	int
,	O
color	int
,	O
"defend_both-B"	*(char)
,	O
bstr	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
astr	int
]	O
&&	O
!	O
attack	(int,*(int))->(int)
(	O
astr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
{	O
int	O
adjs1	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors1	int
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors2	int
;	O
int	O
r	int
;	O
int	O
s	int
;	O
int	O
epos	int
;	O
int	O
fpos	int
;	O
neighbors1	int
=	O
chainlinks	(int,array(int))->(int)
(	O
astr	int
,	O
adjs1	array(int)
)	O
;	O
neighbors2	int
=	O
chainlinks	(int,array(int))->(int)
(	O
bstr	int
,	O
adjs2	array(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
neighbors1	int
;	O
r	int
++	O
)	O
{	O
epos	int
=	O
adjs1	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
epos	int
)	O
<=	O
4	int
&&	O
(	O
epos	int
!=	O
a_savepos	int
)	O
&&	O
(	O
epos	int
!=	O
b_savepos	int
)	O
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
neighbors2	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
adjs2	array(int)
[	O
s	int
]	O
==	O
adjs1	array(int)
[	O
r	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
s	int
==	O
neighbors2	int
)	O
continue	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
epos	int
,	O
&	O
fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
fpos	int
,	O
color	int
,	O
"defend_both-C"	*(char)
,	O
astr	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
astr	int
]	O
&&	O
board	*(char)
[	O
bstr	int
]	O
&&	O
!	O
attack	(int,*(int))->(int)
(	O
astr	int
,	O
NULL	O
)	O
&&	O
!	O
attack	(int,*(int))->(int)
(	O
bstr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
break_through_helper	(int,int,int,int,int,int,int,int)->(int)
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
dpos	int
,	O
int	O
epos	int
,	O
int	O
Fpos	int
,	O
int	O
color	int
,	O
int	O
other	int
)	O
;	O
int	O
break_through	(int,int,int)->(int)
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
apos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
Fpos	int
;	O
int	O
gpos	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
success2	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
apos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	*(char)
[	O
bpos	int
]	O
,	O
bpos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	*(char)
[	O
cpos	int
]	O
,	O
cpos	int
)	O
;	O
Fpos	int
=	O
(	O
apos	int
+	O
cpos	int
)	O
/	O
2	int
;	O
dpos	int
=	O
apos	int
+	O
bpos	int
-	O
Fpos	int
;	O
epos	int
=	O
bpos	int
+	O
cpos	int
-	O
Fpos	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
dpos	int
]	O
==	O
EMPTY	int
,	O
dpos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
epos	int
]	O
==	O
EMPTY	int
,	O
epos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
Fpos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
Fpos	int
]	O
==	O
other	int
,	O
Fpos	int
)	O
;	O
success	int
=	O
break_through_helper	(int,int,int,int,int,int,int,int)->(int)
(	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
,	O
epos	int
,	O
Fpos	int
,	O
color	int
,	O
other	int
)	O
;	O
if	O
(	O
success	int
==	O
WIN	int
)	O
return	O
WIN	int
;	O
success2	int
=	O
break_through_helper	(int,int,int,int,int,int,int,int)->(int)
(	O
cpos	int
,	O
bpos	int
,	O
apos	int
,	O
epos	int
,	O
dpos	int
,	O
Fpos	int
,	O
color	int
,	O
other	int
)	O
;	O
if	O
(	O
success2	int
==	O
WIN	int
)	O
return	O
WIN	int
;	O
if	O
(	O
success2	int
==	O
CUT	int
)	O
success	int
=	O
CUT	int
;	O
success2	int
=	O
0	int
;	O
if	O
(	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
Fpos	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
gpos	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
gpos	int
,	O
other	int
,	O
"break_through-A"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
dpos	int
,	O
color	int
,	O
"break_through-B"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
epos	int
,	O
other	int
)	O
)	O
{	O
success2	int
=	O
CUT	int
;	O
if	O
(	O
!	O
board	*(char)
[	O
cpos	int
]	O
||	O
attack	(int,*(int))->(int)
(	O
cpos	int
,	O
NULL	O
)	O
)	O
success2	int
=	O
WIN	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
success2	int
>	O
0	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
epos	int
,	O
color	int
,	O
"break_through-C"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
dpos	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
&&	O
!	O
attack	(int,*(int))->(int)
(	O
apos	int
,	O
NULL	O
)	O
)	O
success2	int
=	O
CUT	int
;	O
}	O
else	O
success2	int
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
success2	int
>	O
0	int
)	O
return	O
success2	int
;	O
return	O
success	int
;	O
}	O
static	O
int	O
break_through_helper	(int,int,int,int,int,int,int,int)->(int)
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
dpos	int
,	O
int	O
epos	int
,	O
int	O
Fpos	int
,	O
int	O
color	int
,	O
int	O
other	int
)	O
{	O
int	O
success	int
=	O
0	int
;	O
int	O
gpos	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
dpos	int
,	O
other	int
,	O
"break_through_helper-A"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
attack	(int,*(int))->(int)
(	O
Fpos	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
attack	(int,*(int))->(int)
(	O
dpos	int
,	O
&	O
gpos	int
)	O
)	O
success	int
=	O
CUT	int
;	O
else	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
epos	int
,	O
color	int
,	O
"break_through_helper-E"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
board	*(char)
[	O
dpos	int
]	O
||	O
!	O
find_defense	(int,*(int))->(int)
(	O
dpos	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
gpos	int
==	O
epos	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
gpos	int
,	O
color	int
,	O
"break_through_helper-F"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
epos	int
,	O
other	int
,	O
"break_through_helper-G"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
attack	(int,*(int))->(int)
(	O
epos	int
,	O
NULL	O
)	O
)	O
{	O
success	int
=	O
CUT	int
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
&&	O
board	*(char)
[	O
cpos	int
]	O
&&	O
defend_both	(int,int)->(int)
(	O
bpos	int
,	O
cpos	int
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
CUT	int
;	O
}	O
}	O
else	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
board	*(char)
[	O
apos	int
]	O
||	O
!	O
board	*(char)
[	O
bpos	int
]	O
||	O
!	O
defend_both	(int,int)->(int)
(	O
apos	int
,	O
bpos	int
)	O
)	O
success	int
=	O
WIN	int
;	O
else	O
{	O
int	O
attack_on_b	int
=	O
0	int
;	O
int	O
attack_on_a	int
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
epos	int
,	O
color	int
,	O
"break_through_helper-B"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
bpos	int
,	O
NULL	O
)	O
)	O
attack_on_b	int
=	O
1	int
;	O
else	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
apos	int
,	O
NULL	O
)	O
)	O
attack_on_a	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
attack_on_a	int
||	O
attack_on_b	int
)	O
{	O
int	O
hpos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
(	O
(	O
attack_on_a	int
&&	O
find_defense	(int,*(int))->(int)
(	O
apos	int
,	O
&	O
hpos	int
)	O
)	O
||	O
(	O
attack_on_b	int
&&	O
find_defense	(int,*(int))->(int)
(	O
bpos	int
,	O
&	O
hpos	int
)	O
)	O
)	O
&&	O
hpos	int
!=	O
NO_MOVE	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
hpos	int
,	O
color	int
,	O
"break_through_helper-C"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
epos	int
,	O
other	int
,	O
"break_through_helper-D"	*(char)
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
board	*(char)
[	O
bpos	int
]	O
||	O
!	O
board	*(char)
[	O
cpos	int
]	O
||	O
!	O
defend_both	(int,int)->(int)
(	O
bpos	int
,	O
cpos	int
)	O
)	O
success	int
=	O
WIN	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
success	int
=	O
WIN	int
;	O
}	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
success	int
;	O
}	O
int	O
attack_threats	(int,int,array(int),array(int))->(int)
(	O
int	O
str	int
,	O
int	O
max_points	int
,	O
int	O
moves	array(int)
[	O
]	O
,	O
int	O
codes	array(int)
[	O
]	O
)	O
{	O
int	O
other	int
;	O
int	O
num_threats	int
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
num_adj	*(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
l	int
;	O
int	O
r	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
1	int
&&	O
liberties	*(int)
<	O
6	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
aa	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
aa	int
,	O
other	int
,	O
"attack_threats-A"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	(int,int,int,array(int),array(int))->(void)
(	O
aa	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array(int)
,	O
codes	array(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
4	int
;	O
l	int
++	O
)	O
{	O
int	O
bb	int
=	O
libs	*(int)
[	O
k	int
]	O
+	O
delta	array(int)
[	O
l	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bb	int
)	O
||	O
IS_STONE	O
(	O
board	*(char)
[	O
bb	int
]	O
)	O
||	O
liberty_of_string	(int,int)->(int)
(	O
bb	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
bb	int
,	O
other	int
,	O
"attack_threats-B"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	(int,int,int,array(int),array(int))->(void)
(	O
bb	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array(int)
,	O
codes	array(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
num_adj	*(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
str	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_adj	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
bb	int
;	O
int	O
dd	int
;	O
int	O
acode	int
;	O
int	O
dcode	int
;	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
dd	int
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
||	O
dcode	int
==	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
-	O
1	int
;	O
r	int
<	O
max_points	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
{	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adjs	array(int)
[	O
k	int
]	O
]	O
.	O
defense_codes	array(int)
[	O
r	int
]	O
==	O
0	int
)	O
break	O
;	O
bb	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adjs	array(int)
[	O
k	int
]	O
]	O
.	O
defense_points	array(int)
[	O
r	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
bb	int
=	O
dd	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
bb	int
,	O
other	int
,	O
"attack_threats-C"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	(int,int,int,array(int),array(int))->(void)
(	O
bb	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array(int)
,	O
codes	array(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
codes	array(int)
[	O
max_points	int
-	O
1	int
]	O
>	O
0	int
)	O
return	O
max_points	int
;	O
for	O
(	O
num_threats	int
=	O
0	int
;	O
num_threats	int
<	O
max_points	int
;	O
num_threats	int
++	O
)	O
if	O
(	O
codes	array(int)
[	O
num_threats	int
]	O
==	O
0	int
)	O
break	O
;	O
return	O
num_threats	int
;	O
}	O
static	O
int	O
do_find_defense	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
liberties	*(int)
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"find_defense"	*(char)
,	O
str	int
)	O
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
4	int
||	O
(	O
liberties	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	*(int)
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
"too many liberties or stackp > depth"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
0	int
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
liberties	*(int)
>	O
2	int
&&	O
move	*(int)
)	O
xpos	int
=	O
*	O
move	*(int)
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
FIND_DEFENSE	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
if	O
(	O
liberties	*(int)
==	O
1	int
)	O
dcode	int
=	O
defend1	*(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
2	int
)	O
dcode	int
=	O
defend2	*(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
3	int
)	O
dcode	int
=	O
defend3	(int,*(int))->(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
4	int
)	O
dcode	int
=	O
defend4	(int,*(int))->(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
dcode	int
)	O
{	O
READ_RETURN	O
(	O
FIND_DEFENSE	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	int
,	O
dcode	int
)	O
;	O
}	O
READ_RETURN0	O
(	O
FIND_DEFENSE	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
static	O
int	O
allows_under_the_stones_tesuji	(int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	int
;	O
if	O
(	O
accuratelib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
!=	O
2	int
)	O
return	O
0	int
;	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"allows_under_the_stones_tesuji"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
)	O
&&	O
accuratelib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
||	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
)	O
&&	O
accuratelib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
result	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
fast_defense	(int,int,*(int),*(int))->(int)
(	O
int	O
str	int
,	O
int	O
liberties	*(int)
,	O
int	O
*	O
libs	*(int)
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
j	int
,	O
k	int
,	O
l	int
;	O
int	O
goal_liberties	int
=	O
(	O
stackp	int
<	O
fourlib_depth	int
?	O
5	int
:	O
4	int
)	O
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
static	O
unsigned	O
liberty_mark	int
=	O
~	O
0U	int
;	O
static	O
unsigned	O
lm	array(int)
[	O
BOARDMAX	O
]	O
;	O
ASSERT1	O
(	O
libs	*(int)
!=	O
NULL	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
move	*(int)
!=	O
NULL	O
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
accuratelib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
,	O
goal_liberties	int
,	O
NULL	O
)	O
>=	O
goal_liberties	int
)	O
{	O
*	O
move	*(int)
=	O
libs	*(int)
[	O
k	int
]	O
;	O
return	O
1	int
;	O
}	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
adj	array(int)
;	O
j	int
++	O
)	O
{	O
int	O
lib	int
;	O
int	O
missing	int
=	O
goal_liberties	int
-	O
liberties	*(int)
;	O
int	O
total	int
=	O
0	int
;	O
int	O
adj2	int
,	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
alib	int
,	O
alibs	array(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
num_adjacent_stones	int
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
j	int
]	O
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
(	O
liberties	*(int)
==	O
1	int
&&	O
lib	int
==	O
libs	*(int)
[	O
0	int
]	O
&&	O
countstones	(int)->(int)
(	O
adjs	array(int)
[	O
j	int
]	O
)	O
<=	O
2	int
)	O
||	O
is_ko	(int,int,*(int))->(int)
(	O
lib	int
,	O
color	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
num_adjacent_stones	int
=	O
count_adjacent_stones	(int,int,int)->(int)
(	O
adjs	array(int)
[	O
j	int
]	O
,	O
str	int
,	O
missing	int
)	O
;	O
if	O
(	O
!	O
liberty_of_string	(int,int)->(int)
(	O
lib	int
,	O
str	int
)	O
&&	O
num_adjacent_stones	int
>=	O
missing	int
)	O
{	O
*	O
move	*(int)
=	O
lib	int
;	O
return	O
1	int
;	O
}	O
ASSERT1	O
(	O
num_adjacent_stones	int
>=	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
++	O
liberty_mark	int
==	O
0	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
lm	array(int)
,	O
0	int
,	O
sizeof	O
(	O
lm	array(int)
)	O
)	O
;	O
liberty_mark	int
++	O
;	O
}	O
adj2	int
=	O
chainlinks	(int,array(int))->(int)
(	O
adjs	array(int)
[	O
j	int
]	O
,	O
adjs2	array(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj2	int
;	O
k	int
++	O
)	O
{	O
alib	int
=	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
k	int
]	O
,	O
MAXLIBS	O
,	O
alibs	array(int)
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
alib	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
lm	array(int)
[	O
alibs	array(int)
[	O
l	int
]	O
]	O
!=	O
liberty_mark	int
)	O
{	O
lm	array(int)
[	O
alibs	array(int)
[	O
l	int
]	O
]	O
=	O
liberty_mark	int
;	O
total	int
++	O
;	O
}	O
}	O
}	O
total	int
+=	O
countstones	(int)->(int)
(	O
adjs	array(int)
[	O
j	int
]	O
)	O
-	O
2	int
;	O
if	O
(	O
lm	array(int)
[	O
lib	int
]	O
==	O
liberty_mark	int
)	O
total	int
--	O
;	O
if	O
(	O
num_adjacent_stones	int
==	O
1	int
)	O
total	int
--	O
;	O
if	O
(	O
total	int
>=	O
goal_liberties	int
)	O
{	O
if	O
(	O
liberties	*(int)
==	O
1	int
&&	O
lib	int
==	O
libs	*(int)
[	O
0	int
]	O
&&	O
allows_under_the_stones_tesuji	(int,int)->(int)
(	O
lib	int
,	O
color	int
)	O
)	O
{	O
continue	O
;	O
}	O
*	O
move	*(int)
=	O
lib	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
defend1	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	*(int)
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"defend1"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
fast_defense	(int,int,*(int),*(int))->(int)
(	O
str	int
,	O
liberties	*(int)
,	O
&	O
lib	int
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"fast defense"	*(char)
)	O
;	O
moves	array(int)
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array(int)
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array(int)
.	O
message	*(char)
[	O
0	int
]	O
=	O
"liberty"	*(char)
;	O
moves	array(int)
.	O
num	int
=	O
1	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
set_up_snapback_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
lib	int
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
countstones	(int)->(int)
(	O
str	int
)	O
==	O
1	int
&&	O
is_ko	(int,int,*(int))->(int)
(	O
lib	int
,	O
other	int
,	O
NULL	O
)	O
)	O
{	O
int	O
libs2	array(int)
[	O
6	int
]	O
;	O
liberties	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
color	int
,	O
6	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
liberties	*(int)
<=	O
5	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs2	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
(	O
liberties	*(int)
==	O
1	int
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
color	int
,	O
"defend1-C"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
apos	int
,	O
move	*(int)
,	O
"backfilling"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
defend2	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
,	O
other	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
liberties2	int
;	O
int	O
libs2	array(int)
[	O
6	int
]	O
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
int	O
string_size	int
;	O
int	O
be_aggressive	int
;	O
SETUP_TRACE_INFO	O
(	O
"defend2"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
fast_defense	(int,int,*(int),*(int))->(int)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"fast defense"	*(char)
)	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
string_size	int
=	O
countstones	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
string_size	int
==	O
1	int
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"liberty"	*(char)
)	O
;	O
if	O
(	O
string_size	int
==	O
1	int
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
1	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"liberty"	*(char)
)	O
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
libs	*(int)
,	O
liberties	*(int)
,	O
&	O
moves	array(int)
,	O
color	int
)	O
;	O
edge_clamp_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
[	O
k	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
bamboo_rescue_moves	(int,int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
)	O
)	O
{	O
liberties2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
,	O
6	int
,	O
libs2	array(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties2	int
;	O
r	int
++	O
)	O
{	O
xpos	int
=	O
libs2	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
color	int
)	O
&&	O
has_neighbor	(int,int)->(int)
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"backfill-A"	*(char)
)	O
;	O
}	O
}	O
liberties2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
liberties2	int
<=	O
2	int
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties2	int
;	O
r	int
++	O
)	O
{	O
xpos	int
=	O
libs2	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"backfill-B"	*(char)
)	O
;	O
}	O
}	O
}	O
special_rescue4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
be_aggressive	int
=	O
(	O
moves	array(int)
.	O
num	int
==	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
superstring_break_chain_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
4	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
{	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
3	int
,	O
0	int
)	O
;	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
break_chain2_defense_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
be_aggressive	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue5_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
break_chain3_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
be_aggressive	int
)	O
;	O
if	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
break_chain4_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
be_aggressive	int
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
defend3	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"defend3"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
3	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
3	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
fast_defense	(int,int,*(int),*(int))->(int)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"fast defense"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
moves	array(int)
.	O
pos	int
[	O
k	int
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
moves	array(int)
.	O
score	float
[	O
k	int
]	O
=	O
0	int
;	O
moves	array(int)
.	O
message	*(char)
[	O
k	int
]	O
=	O
"liberty"	*(char)
;	O
}	O
moves	array(int)
.	O
num	int
=	O
liberties	*(int)
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
libs	*(int)
,	O
liberties	*(int)
,	O
&	O
moves	array(int)
,	O
color	int
)	O
;	O
edge_clamp_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
hane_rescue_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
[	O
k	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
bamboo_rescue_moves	(int,int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
}	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
superstring_break_chain_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
4	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
)	O
break_chain2_defense_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
special_rescue5_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
special_rescue6_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
3	int
,	O
0	int
)	O
;	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
)	O
break_chain3_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
0	int
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
defend4	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"defend4"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
4	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
fast_defense	(int,int,*(int),*(int))->(int)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"fast defense"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
moves	array(int)
.	O
pos	int
[	O
k	int
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
moves	array(int)
.	O
score	float
[	O
k	int
]	O
=	O
0	int
;	O
moves	array(int)
.	O
message	*(char)
[	O
k	int
]	O
=	O
"liberty"	*(char)
;	O
}	O
moves	array(int)
.	O
num	int
=	O
liberties	*(int)
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
break_chain2_defense_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
0	int
)	O
;	O
break_chain3_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
0	int
)	O
;	O
break_chain4_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
4	int
,	O
0	int
)	O
;	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
[	O
k	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
bamboo_rescue_moves	(int,int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
liberties	*(int)
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
void	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
otherlib	int
;	O
int	O
k	int
;	O
otherlib	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
;	O
if	O
(	O
otherlib	int
>	O
2	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
lib	int
+	O
d	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
lib	int
+	O
d	int
,	O
color	int
)	O
&&	O
otherlib	int
>	O
1	int
)	O
continue	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
>	O
3	int
)	O
{	O
int	O
r	int
;	O
int	O
number_protected	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
lib	int
+	O
d	int
+	O
delta	array(int)
[	O
r	int
]	O
]	O
==	O
EMPTY	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
+	O
d	int
+	O
delta	array(int)
[	O
r	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
)	O
number_protected	int
++	O
;	O
if	O
(	O
number_protected	int
==	O
2	int
)	O
break	O
;	O
}	O
if	O
(	O
number_protected	int
<	O
2	int
)	O
continue	O
;	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
+	O
d	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
bamboo_rescue_moves	(int,int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
num_libs	int
,	O
int	O
libs	*(int)
[	O
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
l1	int
,	O
l2	int
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
num_libs	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
num_libs	int
;	O
l2	int
++	O
)	O
{	O
if	O
(	O
l1	int
==	O
l2	int
)	O
continue	O
;	O
if	O
(	O
libs	*(int)
[	O
l1	int
]	O
==	O
WEST	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
||	O
libs	*(int)
[	O
l1	int
]	O
==	O
EAST	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
SOUTH	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
SOUTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
SOUTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"bamboo_rescue"	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
NORTH	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
NORTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
NORTH	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"bamboo_rescue"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
libs	*(int)
[	O
l1	int
]	O
==	O
NORTH	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
||	O
libs	*(int)
[	O
l1	int
]	O
==	O
SOUTH	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
WEST	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
WEST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
WEST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"bamboo_rescue"	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
EAST	O
(	O
libs	*(int)
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
EAST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
EAST	O
(	O
libs	*(int)
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"bamboo_rescue"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
special_rescue2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
newlibs	array(int)
[	O
4	int
]	O
;	O
int	O
liberties	*(int)
;	O
int	O
newstr	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
2	int
;	O
r	int
++	O
)	O
{	O
int	O
alib	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_suicide	(int,int)->(int)
(	O
alib	int
,	O
other	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
alib	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
same_string	(int,int)->(int)
(	O
alib	int
+	O
delta	array(int)
[	O
k	int
]	O
,	O
str	int
)	O
)	O
{	O
newstr	int
=	O
alib	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
newstr	int
,	O
4	int
,	O
newlibs	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	*(int)
&&	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
newlibs	array(int)
[	O
s	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
newlibs	array(int)
[	O
s	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue2"	*(char)
)	O
;	O
}	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
newstr	int
,	O
moves	array(int)
)	O
;	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
newstr	int
,	O
moves	array(int)
)	O
;	O
edge_clamp_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
newstr	int
,	O
moves	array(int)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
,	O
epos	int
,	O
fpos	int
,	O
gpos	int
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
3	int
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
bpos	int
)	O
)	O
continue	O
;	O
cpos	int
=	O
apos	int
-	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
if	O
(	O
!	O
same_string	(int,int)->(int)
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
normal	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
normal	int
=	O
-	O
normal	int
;	O
dpos	int
=	O
cpos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
dpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
epos	int
=	O
dpos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
epos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
fpos	int
=	O
apos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
fpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
gpos	int
=	O
fpos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
gpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
fpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue3"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
libs2	array(int)
[	O
2	int
]	O
;	O
int	O
k	int
;	O
int	O
r	int
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
bpos	int
=	O
libs	*(int)
[	O
1	int
-	O
k	int
]	O
;	O
if	O
(	O
apos	int
==	O
SOUTH	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
NORTH	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
WEST	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
EAST	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
apos	int
==	O
WEST	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
EAST	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
SOUTH	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
NORTH	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
return	O
;	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
xpos	int
,	O
2	int
,	O
libs2	array(int)
)	O
==	O
2	int
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
2	int
;	O
r	int
++	O
)	O
if	O
(	O
libs2	array(int)
[	O
r	int
]	O
!=	O
apos	int
&&	O
libs2	array(int)
[	O
r	int
]	O
!=	O
bpos	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs2	array(int)
[	O
r	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
r	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue4"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
hane_rescue_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
4	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
;	O
int	O
num_libs	int
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
ASSERT1	O
(	O
num_libs	int
<=	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_libs	int
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
if	O
(	O
!	O
same_string	(int,int)->(int)
(	O
bpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
normal	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
normal	int
=	O
-	O
normal	int
;	O
cpos	int
=	O
apos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
dpos	int
=	O
bpos	int
+	O
normal	int
;	O
if	O
(	O
board	*(char)
[	O
dpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
{	O
int	O
dlibs	int
=	O
countlib	(int)->(int)
(	O
dpos	int
)	O
;	O
if	O
(	O
dlibs	int
>	O
num_libs	int
||	O
dlibs	int
>	O
accuratelib	(int,int,int,*(int))->(int)
(	O
cpos	int
,	O
color	int
,	O
dlibs	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
0	int
&&	O
!	O
in_list	(int,int,*(int))->(int)
(	O
cpos	int
,	O
moves	array(int)
->	O
num	int
,	O
moves	array(int)
->	O
pos	int
)	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"hane_rescue_move added for %1m at %1m\n"	*(char)
,	O
str	int
,	O
cpos	int
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"hane_rescue"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue5_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
int	O
libs2	array(int)
[	O
4	int
]	O
;	O
int	O
liberties2	int
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
2	int
||	O
liberties	*(int)
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
bpos	int
)	O
>	O
liberties	*(int)
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
count_common_libs	(int,int)->(int)
(	O
str	int
,	O
bpos	int
)	O
<	O
2	int
)	O
continue	O
;	O
liberties2	int
=	O
findlib	(int,int,*(int))->(int)
(	O
bpos	int
,	O
4	int
,	O
libs2	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties2	int
;	O
s	int
++	O
)	O
if	O
(	O
!	O
liberty_of_string	(int,int)->(int)
(	O
libs2	array(int)
[	O
s	int
]	O
,	O
str	int
)	O
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs2	array(int)
[	O
s	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
s	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue5-A"	*(char)
)	O
;	O
if	O
(	O
liberties2	int
<=	O
liberties	*(int)
)	O
{	O
int	O
adj	array(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
t	int
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
bpos	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
adj	array(int)
;	O
t	int
++	O
)	O
{	O
int	O
cpos	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs	array(int)
[	O
t	int
]	O
,	O
moves	array(int)
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
t	int
]	O
,	O
1	int
,	O
&	O
cpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
cpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue5-B"	*(char)
)	O
;	O
}	O
double_atari_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
bpos	int
,	O
moves	array(int)
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue6_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
;	O
int	O
right	int
,	O
up	int
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
3	int
||	O
liberties	*(int)
==	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
right	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
right	int
)	O
)	O
continue	O
;	O
bpos	int
=	O
apos	int
+	O
right	int
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
!=	O
color	int
||	O
!	O
same_string	(int,int)->(int)
(	O
str	int
,	O
bpos	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
up	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
up	int
=	O
-	O
up	int
;	O
cpos	int
=	O
bpos	int
+	O
up	int
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
+	O
right	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
cpos	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
cpos	int
+	O
up	int
+	O
right	int
]	O
==	O
color	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue6-A"	*(char)
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue6-B"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
countlib	(int)->(int)
(	O
cpos	int
)	O
<=	O
3	int
&&	O
(	O
board	*(char)
[	O
bpos	int
+	O
right	int
]	O
==	O
EMPTY	int
||	O
(	O
board	*(char)
[	O
bpos	int
+	O
right	int
]	O
==	O
other	int
&&	O
countlib	(int)->(int)
(	O
bpos	int
+	O
right	int
)	O
<=	O
4	int
)	O
)	O
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
cpos	int
+	O
right	int
,	O
color	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_rescue6-C"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
set_up_snapback_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
libs2	array(int)
[	O
2	int
]	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
countstones	(int)->(int)
(	O
str	int
)	O
==	O
1	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
other	int
,	O
2	int
,	O
libs2	array(int)
)	O
==	O
1	int
&&	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
color	int
)	O
||	O
is_ko	(int,int,*(int))->(int)
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
color	int
,	O
NULL	O
)	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"set_up_snapback"	*(char)
)	O
;	O
}	O
static	O
void	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
liberty_cap	int
,	O
int	O
does_attack	(int,int)->(int)
)	O
{	O
int	O
ss_liberties	int
;	O
int	O
ss_libs	array(int)
[	O
MAX_LIBERTIES	int
+	O
4	int
]	O
;	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
find_superstring_liberties	(int,*(int),*(int),int)->(void)
(	O
str	int
,	O
&	O
ss_liberties	int
,	O
ss_libs	array(int)
,	O
liberty_cap	int
)	O
;	O
if	O
(	O
ss_liberties	int
<=	O
5	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
ss_liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
ss_libs	array(int)
[	O
k	int
]	O
;	O
int	O
alibs	array(int)
[	O
2	int
]	O
;	O
int	O
alib	int
=	O
accuratelib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	int
,	O
2	int
,	O
alibs	array(int)
)	O
;	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
apos	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
alib	int
>=	O
2	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"superstring liberty"	*(char)
)	O
;	O
else	O
if	O
(	O
alib	int
==	O
1	int
&&	O
does_attack	(int,int)->(int)
&&	O
board	*(char)
[	O
alibs	array(int)
[	O
0	int
]	O
]	O
==	O
EMPTY	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
alibs	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
alibs	array(int)
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"superstring backfill"	*(char)
)	O
;	O
if	O
(	O
!	O
does_attack	(int,int)->(int)
)	O
special_rescue_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
apos	int
,	O
moves	array(int)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
num_libs	int
;	O
int	O
libs2	array(int)
[	O
4	int
]	O
;	O
int	O
num_libs2	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
potential_move	int
=	O
NO_MOVE	O
;	O
int	O
previous_liberty	int
;	O
num_libs	int
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
gg_assert	O
(	O
num_libs	int
<=	O
4	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_libs	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
is_suicide	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
)	O
)	O
continue	O
;	O
num_libs2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
,	O
4	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
num_libs2	int
!=	O
num_libs	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_libs2	int
;	O
r	int
++	O
)	O
if	O
(	O
!	O
liberty_of_string	(int,int)->(int)
(	O
libs2	array(int)
[	O
r	int
]	O
,	O
str	int
)	O
)	O
{	O
potential_move	int
=	O
libs2	array(int)
[	O
r	int
]	O
;	O
break	O
;	O
}	O
previous_liberty	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
while	O
(	O
is_suicide	(int,int)->(int)
(	O
potential_move	int
,	O
other	int
)	O
)	O
{	O
num_libs2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
potential_move	int
,	O
color	int
,	O
3	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
num_libs2	int
!=	O
2	int
)	O
{	O
potential_move	int
=	O
NO_MOVE	O
;	O
break	O
;	O
}	O
if	O
(	O
libs2	array(int)
[	O
0	int
]	O
==	O
previous_liberty	int
)	O
{	O
previous_liberty	int
=	O
potential_move	int
;	O
potential_move	int
=	O
libs2	array(int)
[	O
1	int
]	O
;	O
}	O
else	O
{	O
previous_liberty	int
=	O
potential_move	int
;	O
potential_move	int
=	O
libs2	array(int)
[	O
0	int
]	O
;	O
}	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
potential_move	int
,	O
str	int
)	O
)	O
{	O
potential_move	int
=	O
NO_MOVE	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
potential_move	int
==	O
NO_MOVE	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
potential_move	int
,	O
other	int
)	O
)	O
continue	O
;	O
approxlib	(int,int,int,*(int))->(int)
(	O
potential_move	int
,	O
other	int
,	O
1	int
,	O
libs2	array(int)
)	O
;	O
num_libs2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
if	O
(	O
num_libs2	int
<	O
3	int
&&	O
num_libs2	int
<	O
approxlib	(int,int,int,*(int))->(int)
(	O
potential_move	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
potential_move	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"squeeze move"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
edge_clamp_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
adjs	array(int)
[	O
r	int
]	O
;	O
bpos	int
=	O
NO_MOVE	O
;	O
findlib	(int,int,*(int))->(int)
(	O
apos	int
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_edge_vertex	(int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
)	O
)	O
{	O
bpos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bpos	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
bpos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
+	O
up	int
]	O
!=	O
other	int
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
cpos	int
=	O
bpos	int
+	O
up	int
-	O
right	int
;	O
dpos	int
=	O
bpos	int
+	O
up	int
+	O
right	int
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
!=	O
color	int
||	O
!	O
same_string	(int,int)->(int)
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
dpos	int
]	O
!=	O
EMPTY	int
||	O
!	O
liberty_of_string	(int,int)->(int)
(	O
dpos	int
,	O
apos	int
)	O
)	O
continue	O
;	O
epos	int
=	O
dpos	int
+	O
up	int
;	O
if	O
(	O
board	*(char)
[	O
epos	int
]	O
!=	O
EMPTY	int
||	O
!	O
liberty_of_string	(int,int)->(int)
(	O
epos	int
,	O
apos	int
)	O
)	O
continue	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
dpos	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
)	O
continue	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
epos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
dpos	int
,	O
10	int
,	O
*	O
moves	array(int)
,	O
"edge_clamp"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
int	O
*	O
libs	*(int)
,	O
int	O
liberties	*(int)
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
to_move	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
right	int
;	O
int	O
up	int
;	O
int	O
apos	int
;	O
int	O
k	int
,	O
l	int
;	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	*(int)
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
up	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
right	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
]	O
==	O
other	int
&&	O
countlib	(int)->(int)
(	O
apos	int
+	O
up	int
)	O
>	O
4	int
&&	O
color	int
==	O
to_move	int
)	O
{	O
int	O
xpos	int
=	O
apos	int
;	O
while	O
(	O
ON_BOARD	O
(	O
xpos	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
xpos	int
]	O
==	O
color	int
||	O
board	*(char)
[	O
xpos	int
+	O
up	int
]	O
==	O
color	int
)	O
break	O
;	O
xpos	int
+=	O
right	int
;	O
}	O
if	O
(	O
!	O
ON_BOARD	O
(	O
xpos	int
)	O
)	O
{	O
REMOVE_CANDIDATE_MOVE	O
(	O
apos	int
,	O
*	O
moves	array(int)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
apos	int
-	O
right	int
+	O
up	int
]	O
==	O
other	int
&&	O
board	*(char)
[	O
apos	int
+	O
right	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
apos	int
+	O
up	int
-	O
right	int
)	O
==	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
up	int
,	O
10	int
,	O
*	O
moves	array(int)
,	O
"propose_edge-A"	*(char)
)	O
;	O
else	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"propose_edge-B"	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
right	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
(	O
liberties	*(int)
!=	O
2	int
||	O
color	int
!=	O
to_move	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
right	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"propose_edge-C"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
do_attack	int
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
;	O
int	O
result	int
=	O
0	int
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"attack"	*(char)
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
color	int
!=	O
0	int
,	O
str	int
)	O
;	O
if	O
(	O
color	int
==	O
0	int
)	O
return	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
4	int
||	O
(	O
liberties	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	*(int)
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
{	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"got 4 liberties (stackp:%d>%d)"	*(char)
,	O
stackp	int
,	O
fourlib_depth	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
buf	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
liberties	*(int)
>	O
3	int
&&	O
move	*(int)
)	O
xpos	int
=	O
*	O
move	*(int)
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
ATTACK	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
if	O
(	O
liberties	*(int)
==	O
1	int
)	O
result	int
=	O
attack1	*(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
2	int
)	O
{	O
if	O
(	O
stackp	int
>	O
depth	int
+	O
10	int
)	O
result	int
=	O
simple_ladder	(int,*(int))->(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
result	int
=	O
attack2	*(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
}	O
else	O
if	O
(	O
liberties	*(int)
==	O
3	int
)	O
result	int
=	O
attack3	(int,*(int))->(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
4	int
)	O
result	int
=	O
attack4	(int,*(int))->(int)
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
ASSERT1	O
(	O
result	int
>=	O
0	int
&&	O
result	int
<=	O
WIN	int
,	O
str	int
)	O
;	O
if	O
(	O
result	int
)	O
{	O
READ_RETURN	O
(	O
ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
xpos	int
,	O
result	int
)	O
;	O
}	O
READ_RETURN0	O
(	O
ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
static	O
int	O
attack1	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
6	int
]	O
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array(int)
;	O
int	O
apos	int
;	O
SETUP_TRACE_INFO	O
(	O
"attack1"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
countstones	(int)->(int)
(	O
str	int
)	O
>	O
1	int
)	O
{	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty"	*(char)
)	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
xpos	int
,	O
other	int
,	O
"attack1-A"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
xpos	int
)	O
>	O
1	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
countstones	(int)->(int)
(	O
xpos	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
get_komaster	()->(int)
(	O
)	O
!=	O
other	int
)	O
{	O
CHECK_RESULT_UNREVERSED	O
(	O
savecode	int
,	O
savemove	int
,	O
KO_A	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty - ko"	*(char)
)	O
;	O
}	O
else	O
{	O
popgo	()->(void)
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
str	int
,	O
color	int
,	O
"attack1-B"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
>	O
1	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty"	*(char)
)	O
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
get_komaster	()->(int)
(	O
)	O
!=	O
color	int
)	O
{	O
CHECK_RESULT_UNREVERSED	O
(	O
savecode	int
,	O
savemove	int
,	O
KO_B	int
,	O
xpos	int
,	O
move	*(int)
,	O
"last liberty - ko"	*(char)
)	O
;	O
}	O
}	O
liberties	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
6	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
liberties	*(int)
<=	O
5	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
other	int
,	O
"attack1-C"	*(char)
,	O
str	int
)	O
)	O
{	O
int	O
dcode	int
=	O
do_find_defense	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
apos	int
,	O
move	*(int)
,	O
"backfilling"	*(char)
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
xpos	int
,	O
adjs	array(int)
[	O
r	int
]	O
)	O
)	O
{	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
adj2	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
adjs2	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj2	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
if	O
(	O
adjs2	array(int)
[	O
k	int
]	O
==	O
str	int
)	O
continue	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
k	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
apos	int
,	O
other	int
,	O
"attack1-D"	*(char)
,	O
str	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
dcode	int
=	O
do_find_defense	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
,	O
move	*(int)
,	O
"attack effective"	*(char)
)	O
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_find_defense	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
savemove	int
=	O
apos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
savecode	int
==	O
0	int
)	O
{	O
RETURN_RESULT	O
(	O
0	int
,	O
0	int
,	O
move	*(int)
,	O
NULL	O
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
attack2	*(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
hpos	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	*(int)
,	O
r	int
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
libs2	array(int)
[	O
2	int
]	O
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
atari_possible	int
=	O
0	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
adjacent_liberties	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack2"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
4	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
if	O
(	O
stackp	int
>	O
depth	int
&&	O
countstones	(int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
)	O
>	O
1	int
&&	O
!	O
have_common_lib	(int,int,*(int))->(int)
(	O
str	int
,	O
adjs	array(int)
[	O
r	int
]	O
,	O
NULL	O
)	O
)	O
{	O
RETURN_RESULT	O
(	O
0	int
,	O
0	int
,	O
move	*(int)
,	O
"boundary in atari"	*(char)
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"save_boundary"	*(char)
)	O
;	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
DIRECT_NEIGHBORS	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
libs	*(int)
[	O
1	int
]	O
)	O
)	O
adjacent_liberties	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
atari_possible	int
=	O
1	int
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
(	O
stackp	int
<=	O
depth	int
||	O
adjacent_liberties	int
)	O
&&	O
!	O
has_neighbor	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array(int)
,	O
"liberty"	*(char)
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
apos	int
,	O
other	int
,	O
2	int
,	O
libs2	array(int)
)	O
==	O
1	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"backfill"	*(char)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
bpos	int
=	O
libs2	array(int)
[	O
0	int
]	O
+	O
delta	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
other	int
&&	O
chainlinks2	(int,array(int),int)->(int)
(	O
bpos	int
,	O
adjs	array(int)
,	O
1	int
)	O
>	O
0	int
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
0	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"back-capture"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
atari_possible	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
edge_block_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
[	O
k	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
apos	int
=	O
adjs	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
apos	int
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
apos	int
)	O
)	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
apos	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
libs	*(int)
,	O
liberties	*(int)
,	O
&	O
moves	array(int)
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
special_attack2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
special_attack3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
special_attack4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
libs	*(int)
,	O
&	O
moves	array(int)
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
find_cap_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill_depth	int
&&	O
(	O
stackp	int
<=	O
superstring_depth	int
||	O
!	O
atari_possible	int
)	O
)	O
{	O
int	O
liberty_cap	int
=	O
2	int
;	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
liberty_cap	int
=	O
3	int
;	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
liberty_cap	int
,	O
1	int
)	O
;	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
other	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
attack3	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack3"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
stackp	int
<=	O
depth	int
,	O
str	int
)	O
;	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
4	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
hpos	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"save_boundary"	*(char)
)	O
;	O
}	O
double_atari_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
stackp	int
<=	O
superstring_depth	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
3	int
,	O
libs	*(int)
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_neighbor	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array(int)
,	O
"liberty"	*(char)
)	O
;	O
edge_closing_backfill_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array(int)
)	O
;	O
edge_block_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
libs	*(int)
,	O
liberties	*(int)
,	O
&	O
moves	array(int)
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
find_cap_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
if	O
(	O
stackp	int
<=	O
fourlib_depth	int
)	O
draw_back_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
libs2	array(int)
[	O
2	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
2	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs2	array(int)
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
break_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
&	O
moves	array(int)
,	O
1	int
,	O
0	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
k	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"save_boundary-2"	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
superstring_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
3	int
,	O
1	int
)	O
;	O
squeeze_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
other	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
attack4	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack4"	*(char)
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
if	O
(	O
stackp	int
>	O
depth	int
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
"stackp > depth"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
2	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
hpos	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
&	O
moves	array(int)
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array(int)
,	O
"save_boundary"	*(char)
)	O
;	O
}	O
double_atari_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
stackp	int
<=	O
superstring_depth	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array(int)
.	O
num	int
;	O
k	int
++	O
)	O
moves	array(int)
.	O
score	float
[	O
k	int
]	O
+=	O
5	int
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_neighbor	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array(int)
,	O
"liberty"	*(char)
)	O
;	O
edge_closing_backfill_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array(int)
)	O
;	O
edge_block_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array(int)
)	O
;	O
}	O
propose_edge_moves	(int,*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
str	int
,	O
libs	*(int)
,	O
liberties	*(int)
,	O
&	O
moves	array(int)
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
find_cap_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
other	int
,	O
read_function_name	*(char)
,	O
*	O
move	*(int)
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
void	O
find_cap_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
alib	int
,	O
blib	int
;	O
int	O
numlibs	int
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
i	int
,	O
j	int
;	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	int
,	O
bj	int
;	O
numlibs	int
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
numlibs	int
>	O
4	int
||	O
numlibs	int
<	O
2	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numlibs	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
numlibs	int
;	O
j	int
++	O
)	O
{	O
alib	int
=	O
libs	*(int)
[	O
i	int
]	O
;	O
blib	int
=	O
libs	*(int)
[	O
j	int
]	O
;	O
if	O
(	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
alib	int
,	O
blib	int
)	O
)	O
continue	O
;	O
ai	int
=	O
I	O
(	O
alib	int
)	O
;	O
aj	int
=	O
J	O
(	O
alib	int
)	O
;	O
bi	int
=	O
I	O
(	O
blib	int
)	O
;	O
bj	int
=	O
J	O
(	O
blib	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
POS	O
(	O
bi	int
,	O
aj	int
)	O
,	O
10	int
,	O
*	O
moves	array(int)
,	O
"find_cap"	*(char)
)	O
;	O
else	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
bj	int
)	O
==	O
EMPTY	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
POS	O
(	O
ai	int
,	O
bj	int
)	O
,	O
10	int
,	O
*	O
moves	array(int)
,	O
"find_cap"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
special_attack2_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
newlibs	array(int)
[	O
3	int
]	O
;	O
int	O
xpos	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
)	O
&&	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
,	O
3	int
,	O
newlibs	array(int)
)	O
==	O
2	int
)	O
)	O
{	O
if	O
(	O
newlibs	array(int)
[	O
0	int
]	O
!=	O
libs	*(int)
[	O
1	int
-	O
k	int
]	O
)	O
xpos	int
=	O
newlibs	array(int)
[	O
0	int
]	O
;	O
else	O
xpos	int
=	O
newlibs	array(int)
[	O
1	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
other	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_attack2"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_attack3_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
bpos	int
=	O
libs	*(int)
[	O
1	int
-	O
k	int
]	O
;	O
if	O
(	O
apos	int
==	O
SOUTH	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
NORTH	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
WEST	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
EAST	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
apos	int
==	O
WEST	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
EAST	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
SOUTH	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
NORTH	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
return	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_attack3"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
special_attack4_moves	(int,array(int),*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
libs	*(int)
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
,	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs2	array(int)
[	O
3	int
]	O
;	O
int	O
apos	int
;	O
int	O
bpos	int
=	O
0	int
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
clibs	int
;	O
int	O
dlibs	int
;	O
int	O
elibs	int
;	O
int	O
bc_common_lib	int
;	O
int	O
k	int
,	O
s	int
,	O
t	int
,	O
u	int
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	int
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	int
)	O
)	O
return	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj	array(int)
;	O
s	int
++	O
)	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
apos	int
,	O
adjs	array(int)
[	O
s	int
]	O
)	O
)	O
{	O
bpos	int
=	O
adjs	array(int)
[	O
s	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
s	int
==	O
adj	array(int)
)	O
continue	O
;	O
adj2	int
=	O
chainlinks3	(int,array(int),int)->(int)
(	O
bpos	int
,	O
adjs2	array(int)
,	O
3	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
cpos	int
=	O
adjs2	array(int)
[	O
s	int
]	O
;	O
if	O
(	O
same_string	(int,int)->(int)
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
clibs	int
=	O
findlib	(int,int,*(int))->(int)
(	O
cpos	int
,	O
3	int
,	O
libs2	array(int)
)	O
;	O
if	O
(	O
clibs	int
<	O
2	int
)	O
continue	O
;	O
bc_common_lib	int
=	O
have_common_lib	(int,int,*(int))->(int)
(	O
bpos	int
,	O
cpos	int
,	O
NULL	O
)	O
;	O
if	O
(	O
clibs	int
>	O
2	int
&&	O
!	O
bc_common_lib	int
)	O
continue	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
clibs	int
;	O
t	int
++	O
)	O
{	O
dpos	int
=	O
libs2	array(int)
[	O
t	int
]	O
;	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
dpos	int
,	O
other	int
)	O
)	O
continue	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
clibs	int
;	O
u	int
++	O
)	O
{	O
if	O
(	O
t	int
==	O
u	int
)	O
continue	O
;	O
epos	int
=	O
libs2	array(int)
[	O
u	int
]	O
;	O
elibs	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
epos	int
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
elibs	int
>	O
3	int
)	O
break	O
;	O
dlibs	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
dpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
;	O
if	O
(	O
elibs	int
>	O
dlibs	int
&&	O
!	O
bc_common_lib	int
)	O
break	O
;	O
}	O
if	O
(	O
u	int
>=	O
clibs	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
dpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"special_attack4"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
draw_back_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
r	int
,	O
k	int
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
liberty_of_string	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
str	int
)	O
&&	O
(	O
(	O
ON_BOARD1	O
(	O
SOUTH	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
SOUTH	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
WEST	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
WEST	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
NORTH	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
NORTH	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
EAST	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
EAST	O
(	O
libs	*(int)
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"draw_back"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
edge_closing_backfill_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
number_x	int
,	O
number_o	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
int	O
right	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
]	O
!=	O
color	int
)	O
return	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
right	int
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
-	O
right	int
)	O
||	O
board	*(char)
[	O
apos	int
-	O
right	int
]	O
==	O
color	int
)	O
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
apos	int
-	O
right	int
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
+	O
right	int
)	O
||	O
board	*(char)
[	O
apos	int
+	O
right	int
]	O
==	O
color	int
)	O
)	O
{	O
right	int
=	O
-	O
right	int
;	O
}	O
else	O
return	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
+	O
right	int
]	O
!=	O
other	int
)	O
return	O
;	O
bpos	int
=	O
apos	int
+	O
up	int
+	O
2	int
*	O
right	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bpos	int
)	O
)	O
return	O
;	O
cpos	int
=	O
apos	int
+	O
2	int
*	O
right	int
;	O
number_x	int
=	O
0	int
;	O
number_o	int
=	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
)	O
number_x	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
other	int
)	O
number_o	int
++	O
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
==	O
color	int
)	O
number_x	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
==	O
other	int
)	O
number_o	int
++	O
;	O
if	O
(	O
number_o	int
>	O
number_x	int
)	O
return	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"edge_closing_backfill"	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
static	O
void	O
edge_block_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
l	int
;	O
int	O
up	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
apos	int
+	O
up	int
]	O
!=	O
color	int
||	O
!	O
same_string	(int,int)->(int)
(	O
apos	int
+	O
up	int
,	O
str	int
)	O
)	O
return	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
fpos	int
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
cpos	int
=	O
apos	int
+	O
right	int
;	O
dpos	int
=	O
apos	int
+	O
right	int
+	O
up	int
;	O
epos	int
=	O
cpos	int
+	O
right	int
;	O
fpos	int
=	O
dpos	int
+	O
right	int
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
==	O
color	int
&&	O
board	*(char)
[	O
dpos	int
]	O
==	O
other	int
&&	O
board	*(char)
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
fpos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
dpos	int
)	O
==	O
1	int
)	O
{	O
int	O
gpos	int
=	O
epos	int
+	O
right	int
;	O
if	O
(	O
board	*(char)
[	O
gpos	int
]	O
!=	O
color	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
fpos	int
,	O
30	int
,	O
*	O
moves	array(int)
,	O
"edge_block-A"	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
edge_scan	int
;	O
for	O
(	O
edge_scan	int
=	O
epos	int
;	O
;	O
edge_scan	int
+=	O
right	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
edge_scan	int
]	O
==	O
color	int
||	O
board	*(char)
[	O
edge_scan	int
+	O
up	int
]	O
==	O
color	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
epos	int
,	O
10	int
,	O
*	O
moves	array(int)
,	O
"edge_block-B"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
edge_scan	int
]	O
!=	O
EMPTY	int
||	O
board	*(char)
[	O
edge_scan	int
+	O
up	int
]	O
!=	O
EMPTY	int
)	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
r	int
;	O
int	O
xpos	int
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
1	int
,	O
*	O
moves	array(int)
,	O
"break_chain"	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
defend_secondary_chain1_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(int)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
min_liberties	int
)	O
{	O
int	O
r	int
,	O
s	int
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
int	O
xpos	int
;	O
int	O
adj	array(int)
;	O
int	O
adj2	int
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
min_liberties	int
,	O
NULL	O
)	O
+	O
neighbor_of_string	(int,int)->(int)
(	O
xpos	int
,	O
str	int
)	O
>=	O
min_liberties	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"defend_secondary_chain1-A"	*(char)
)	O
;	O
adj2	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
adjs2	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"defend_secondary_chain1-B"	*(char)
)	O
;	O
}	O
}	O
return	O
adj	array(int)
;	O
}	O
static	O
void	O
defend_secondary_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
min_liberties	int
)	O
{	O
int	O
r	int
,	O
s	int
,	O
t	int
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
int	O
xpos	int
;	O
int	O
adj	array(int)
;	O
int	O
adj2	int
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
have_common_lib	(int,int,*(int))->(int)
(	O
str	int
,	O
adjs	array(int)
[	O
r	int
]	O
,	O
NULL	O
)	O
)	O
continue	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
2	int
;	O
t	int
++	O
)	O
{	O
xpos	int
=	O
libs	*(int)
[	O
t	int
]	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
min_liberties	int
,	O
NULL	O
)	O
+	O
neighbor_of_string	(int,int)->(int)
(	O
xpos	int
,	O
str	int
)	O
>=	O
min_liberties	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"defend_secondary_chain2-A"	*(char)
)	O
;	O
}	O
adj2	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
adjs2	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"defend_secondary_chain2-B"	*(char)
)	O
;	O
}	O
adj2	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
adjs2	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
s	int
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
2	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
-	O
t	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
t	int
]	O
,	O
color	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
t	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"defend_secondary_chain2-C"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain2_efficient_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
r	int
;	O
int	O
adj	array(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
do_find_break_chain2_efficient_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
adjs	array(int)
[	O
r	int
]	O
,	O
moves	array(int)
)	O
;	O
}	O
static	O
void	O
do_find_break_chain2_efficient_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
adj2	int
,	O
adjs2	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
pos1	int
;	O
int	O
pos2	int
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
adj	array(int)
)	O
==	O
2	int
,	O
adj	array(int)
)	O
;	O
adj2	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
adj	array(int)
,	O
adjs2	array(int)
,	O
1	int
)	O
;	O
if	O
(	O
adj2	int
==	O
1	int
&&	O
countlib	(int)->(int)
(	O
str	int
)	O
>	O
2	int
)	O
{	O
int	O
apos	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
adjs2	array(int)
[	O
0	int
]	O
,	O
moves	array(int)
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adjs2	array(int)
[	O
0	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
apos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2_efficient-A"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
adj2	int
>	O
1	int
)	O
return	O
;	O
findlib	(int,int,*(int))->(int)
(	O
adj	array(int)
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
-	O
k	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
1	int
-	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2_efficient-B"	*(char)
)	O
;	O
if	O
(	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
libs	*(int)
[	O
1	int
]	O
)	O
)	O
return	O
;	O
pos1	int
=	O
NORTH	O
(	O
gg_max	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
libs	*(int)
[	O
1	int
]	O
)	O
)	O
;	O
pos2	int
=	O
SOUTH	O
(	O
gg_min	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
libs	*(int)
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
board	*(char)
[	O
pos1	int
]	O
!=	O
other	int
||	O
!	O
is_edge_vertex	(int)->(int)
(	O
pos2	int
)	O
||	O
!	O
same_string	(int,int)->(int)
(	O
pos1	int
,	O
adj	array(int)
)	O
)	O
&&	O
(	O
board	*(char)
[	O
pos2	int
]	O
!=	O
other	int
||	O
!	O
is_edge_vertex	(int)->(int)
(	O
pos1	int
)	O
||	O
!	O
same_string	(int,int)->(int)
(	O
pos2	int
,	O
adj	array(int)
)	O
)	O
)	O
return	O
;	O
if	O
(	O
is_edge_vertex	(int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
)	O
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
1	int
]	O
,	O
1	int
,	O
*	O
moves	array(int)
,	O
"break_chain2_efficient-C"	*(char)
)	O
;	O
if	O
(	O
is_edge_vertex	(int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
)	O
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
1	int
,	O
*	O
moves	array(int)
,	O
"break_chain2_efficient-C"	*(char)
)	O
;	O
}	O
static	O
void	O
break_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
require_safe	int
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
adj	array(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
k	int
;	O
int	O
apos	int
=	O
adjs	array(int)
[	O
r	int
]	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
unsafe	array(int)
[	O
2	int
]	O
;	O
int	O
dummy_adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
apos	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
stackp	int
>	O
backfill_depth	int
&&	O
chainlinks2	(int,array(int),int)->(int)
(	O
apos	int
,	O
dummy_adjs	array(int)
,	O
1	int
)	O
>	O
0	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
unsafe	array(int)
[	O
k	int
]	O
=	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
)	O
;	O
if	O
(	O
!	O
unsafe	array(int)
[	O
k	int
]	O
||	O
is_ko	(int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
,	O
NULL	O
)	O
||	O
(	O
!	O
require_safe	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
<	O
5	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2-A"	*(char)
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
{	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
<	O
4	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
<	O
4	int
)	O
{	O
if	O
(	O
!	O
defend_secondary_chain1_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
moves	array(int)
,	O
2	int
)	O
)	O
defend_secondary_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
moves	array(int)
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
unsafe	array(int)
[	O
0	int
]	O
&&	O
unsafe	array(int)
[	O
1	int
]	O
&&	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
have_common_lib	(int,int,*(int))->(int)
(	O
str	int
,	O
apos	int
,	O
NULL	O
)	O
)	O
)	O
{	O
int	O
lib	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
libs2	array(int)
[	O
3	int
]	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
libs2	array(int)
)	O
==	O
2	int
)	O
{	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2-B"	*(char)
)	O
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs2	array(int)
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array(int)
[	O
1	int
]	O
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2-B"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
{	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2-C"	*(char)
)	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
&&	O
approxlib	(int,int,int,*(int))->(int)
(	O
lib	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"break_chain2-C"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain2_defense_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
saved_num_moves	int
=	O
moves	array(int)
->	O
num	int
;	O
int	O
k	int
;	O
break_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,int)->(void)
(	O
str	int
,	O
moves	array(int)
,	O
!	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
,	O
be_aggressive	int
)	O
;	O
for	O
(	O
k	int
=	O
saved_num_moves	int
;	O
k	int
<	O
moves	array(int)
->	O
num	int
;	O
k	int
++	O
)	O
moves	array(int)
->	O
score	float
[	O
k	int
]	O
=	O
-	O
2	int
;	O
}	O
static	O
void	O
do_find_break_chain3_moves	(*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char))->(void)
(	O
int	O
*	O
chain_links	*(int)
,	O
int	O
num_chain_links	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
,	O
const	O
char	O
*	O
caller_function_name	*(char)
)	O
{	O
int	O
other	int
=	O
board	*(char)
[	O
chain_links	*(int)
[	O
0	int
]	O
]	O
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
other	int
)	O
;	O
signed	O
char	O
move_added	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
possible_moves	array(int)
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_possible_moves	int
=	O
0	int
;	O
int	O
r	int
;	O
int	O
k	int
;	O
gg_assert	O
(	O
num_chain_links	int
>	O
0	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
move_added	array(char)
,	O
0	int
,	O
sizeof	O
move_added	array(char)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_chain_links	int
;	O
r	int
++	O
)	O
{	O
int	O
lib1	int
;	O
int	O
lib2	int
;	O
int	O
lib3	int
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
chain_links	*(int)
[	O
r	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
lib1	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
lib2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
lib1	int
>=	O
4	int
&&	O
lib2	int
>=	O
4	int
)	O
continue	O
;	O
lib3	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
2	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
4	int
||	O
lib2	int
>=	O
4	int
)	O
&&	O
lib3	int
>=	O
4	int
)	O
continue	O
;	O
if	O
(	O
lib1	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array(char)
[	O
libs	*(int)
[	O
0	int
]	O
]	O
)	O
{	O
possible_moves	array(int)
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
0	int
]	O
;	O
move_added	array(char)
[	O
libs	*(int)
[	O
0	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
lib2	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array(char)
[	O
libs	*(int)
[	O
1	int
]	O
]	O
)	O
{	O
possible_moves	array(int)
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
1	int
]	O
;	O
move_added	array(char)
[	O
libs	*(int)
[	O
1	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
lib3	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array(char)
[	O
libs	*(int)
[	O
2	int
]	O
]	O
)	O
{	O
possible_moves	array(int)
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
2	int
]	O
;	O
move_added	array(char)
[	O
libs	*(int)
[	O
2	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
move_added	array(char)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
)	O
{	O
possible_moves	array(int)
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
move_added	array(char)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
defend_secondary_chain1_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(int)
(	O
chain_links	*(int)
[	O
r	int
]	O
,	O
moves	array(int)
,	O
3	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_possible_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
possible_moves	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
||	O
approxlib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
move	*(int)
,	O
-	O
2	int
,	O
*	O
moves	array(int)
,	O
caller_function_name	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
break_chain3_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
chain_links	*(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_chain_links	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
chain_links	*(int)
,	O
3	int
)	O
;	O
if	O
(	O
num_chain_links	int
>	O
0	int
)	O
{	O
do_find_break_chain3_moves	(*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char))->(void)
(	O
chain_links	*(int)
,	O
num_chain_links	int
,	O
moves	array(int)
,	O
be_aggressive	int
,	O
"break_chain3"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
break_chain4_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
int	O
u	int
=	O
0	int
,	O
v	int
;	O
int	O
apos	int
;	O
int	O
adj	array(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
4	int
]	O
;	O
int	O
possible_moves	array(int)
[	O
MAX_MOVES	int
]	O
;	O
int	O
mw	array(int)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mw	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mw	array(int)
)	O
)	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
4	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
int	O
lib1	int
=	O
0	int
,	O
lib2	int
=	O
0	int
,	O
lib3	int
=	O
0	int
,	O
lib4	int
=	O
0	int
;	O
apos	int
=	O
adjs	array(int)
[	O
r	int
]	O
;	O
findlib	(int,int,*(int))->(int)
(	O
apos	int
,	O
4	int
,	O
libs	*(int)
)	O
;	O
lib1	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
lib2	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
lib1	int
>=	O
5	int
&&	O
lib2	int
>=	O
5	int
)	O
continue	O
;	O
lib3	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
2	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
5	int
||	O
lib2	int
>=	O
5	int
)	O
&&	O
lib3	int
>=	O
5	int
)	O
continue	O
;	O
lib4	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
3	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
5	int
||	O
lib2	int
>=	O
5	int
||	O
lib3	int
>=	O
5	int
)	O
&&	O
lib4	int
>=	O
5	int
)	O
continue	O
;	O
if	O
(	O
lib1	int
>=	O
5	int
&&	O
!	O
mw	array(int)
[	O
libs	*(int)
[	O
0	int
]	O
]	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
0	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array(int)
[	O
u	int
++	O
]	O
=	O
libs	*(int)
[	O
0	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib2	int
>=	O
5	int
&&	O
!	O
mw	array(int)
[	O
libs	*(int)
[	O
1	int
]	O
]	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
1	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array(int)
[	O
u	int
++	O
]	O
=	O
libs	*(int)
[	O
1	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib3	int
>=	O
5	int
&&	O
!	O
mw	array(int)
[	O
libs	*(int)
[	O
2	int
]	O
]	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
2	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array(int)
[	O
u	int
++	O
]	O
=	O
libs	*(int)
[	O
2	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib4	int
>=	O
5	int
&&	O
!	O
mw	array(int)
[	O
libs	*(int)
[	O
3	int
]	O
]	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
3	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array(int)
[	O
u	int
++	O
]	O
=	O
libs	*(int)
[	O
3	int
]	O
;	O
continue	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array(int)
[	O
u	int
++	O
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
}	O
}	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
defend_secondary_chain1_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
moves	array(int)
,	O
4	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
u	int
;	O
v	int
++	O
)	O
{	O
int	O
xpos	int
=	O
possible_moves	array(int)
[	O
v	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
||	O
approxlib	(int,int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
-	O
2	int
,	O
*	O
moves	array(int)
,	O
"break_chain4"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
superstring_break_chain_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
int	O
str	int
,	O
int	O
liberty_cap	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
)	O
{	O
int	O
adj	array(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
chain_links3	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_chain_links3	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
apos	int
;	O
proper_superstring_chainlinks	(int,*(int),array(int),int)->(void)
(	O
str	int
,	O
&	O
adj	array(int)
,	O
adjs	array(int)
,	O
liberty_cap	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array(int)
;	O
k	int
++	O
)	O
{	O
int	O
liberties	*(int)
=	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
)	O
;	O
if	O
(	O
liberties	*(int)
==	O
1	int
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array(int)
,	O
"superstring_break_chain"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
liberties	*(int)
==	O
2	int
)	O
do_find_break_chain2_efficient_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
adjs	array(int)
[	O
k	int
]	O
,	O
moves	array(int)
)	O
;	O
else	O
if	O
(	O
liberties	*(int)
==	O
3	int
)	O
chain_links3	array(int)
[	O
num_chain_links3	int
++	O
]	O
=	O
adjs	array(int)
[	O
k	int
]	O
;	O
}	O
if	O
(	O
num_chain_links3	int
>	O
0	int
)	O
{	O
do_find_break_chain3_moves	(*(int),int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char))->(void)
(	O
chain_links3	array(int)
,	O
num_chain_links3	int
,	O
moves	array(int)
,	O
0	int
,	O
"superstring_break_chain-3"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
double_atari_chain2_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
generate_more_moves	int
)	O
{	O
int	O
r	int
,	O
k	int
;	O
int	O
adj	array(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
int	O
mw	array(int)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mw	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mw	array(int)
)	O
)	O
;	O
adj	array(int)
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs	array(int)
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array(int)
;	O
r	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
r	int
]	O
,	O
2	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
++	O
;	O
if	O
(	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
==	O
2	int
)	O
{	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
k	int
]	O
,	O
1	int
,	O
*	O
moves	array(int)
,	O
"double_atari_chain2-A"	*(char)
)	O
;	O
}	O
}	O
}	O
if	O
(	O
generate_more_moves	int
)	O
{	O
int	O
adj3	int
;	O
int	O
adjs3	array(int)
[	O
MAXCHAIN	int
]	O
;	O
adj3	int
=	O
chainlinks2	(int,array(int),int)->(int)
(	O
str	int
,	O
adjs3	array(int)
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj3	int
;	O
r	int
++	O
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs3	array(int)
[	O
r	int
]	O
,	O
3	int
,	O
libs	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
==	O
1	int
)	O
{	O
mw	array(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
=	O
2	int
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
k	int
]	O
,	O
-	O
3	int
,	O
*	O
moves	array(int)
,	O
"double_atari_chain2-B"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
restricted_defend1	(int,*(int),int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
num_forbidden_moves	int
,	O
int	O
*	O
forbidden_moves	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	*(int)
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"restricted_defend1"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
1	int
,	O
str	int
)	O
;	O
moves	array(int)
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array(int)
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array(int)
.	O
message	*(char)
[	O
0	int
]	O
=	O
"liberty"	*(char)
;	O
moves	array(int)
.	O
num	int
=	O
1	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
set_up_snapback_moves	(int,int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
lib	int
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array(int)
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_capture	int
;	O
xpos	int
=	O
moves	array(int)
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
in_list	(int,int,*(int))->(int)
(	O
xpos	int
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
)	O
continue	O
;	O
if	O
(	O
is_ko	(int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
NULL	O
)	O
)	O
ko_capture	int
=	O
1	int
;	O
else	O
ko_capture	int
=	O
0	int
;	O
if	O
(	O
(	O
get_komaster	()->(int)
(	O
)	O
!=	O
other	int
||	O
!	O
ko_capture	int
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
xpos	int
,	O
color	int
,	O
moves	array(int)
.	O
message	*(char)
[	O
k	int
]	O
,	O
str	int
)	O
)	O
{	O
int	O
libs	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
libs	*(int)
>	O
2	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"defense effective"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	int
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
libs	*(int)
==	O
2	int
)	O
{	O
int	O
acode	int
;	O
if	O
(	O
!	O
ko_capture	int
)	O
acode	int
=	O
restricted_attack2	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
;	O
else	O
acode	int
=	O
restricted_attack2	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"defense effective"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	int
;	O
return	O
WIN	int
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
int	O
ko_pos	int
;	O
if	O
(	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
&&	O
(	O
get_komaster	()->(int)
(	O
)	O
==	O
EMPTY	int
||	O
(	O
get_komaster	()->(int)
(	O
)	O
==	O
color	int
&&	O
get_kom_pos	()->(int)
(	O
)	O
==	O
xpos	int
)	O
)	O
&&	O
is_ko	(int,int,*(int))->(int)
(	O
xpos	int
,	O
color	int
,	O
&	O
ko_pos	int
)	O
&&	O
tryko	(int,int,*(char))->(int)
(	O
xpos	int
,	O
color	int
,	O
"restricted_defend1-B"	*(char)
)	O
)	O
{	O
int	O
libs	*(int)
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
libs	*(int)
>	O
2	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
2	int
,	O
xpos	int
)	O
;	O
}	O
else	O
if	O
(	O
libs	*(int)
==	O
2	int
)	O
{	O
int	O
acode	int
;	O
acode	int
=	O
restricted_attack2	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
savemove	int
;	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	*(char)
)	O
;	O
return	O
savecode	int
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
restricted_attack2	(int,*(int),int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
num_forbidden_moves	int
,	O
int	O
*	O
forbidden_moves	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"restricted_attack2"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
ASSERT1	O
(	O
liberties	*(int)
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_pos	int
;	O
int	O
ko_capture	int
;	O
apos	int
=	O
libs	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
in_list	(int,int,*(int))->(int)
(	O
apos	int
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
)	O
continue	O
;	O
if	O
(	O
is_ko	(int,int,*(int))->(int)
(	O
apos	int
,	O
other	int
,	O
&	O
ko_pos	int
)	O
)	O
ko_capture	int
=	O
1	int
;	O
else	O
ko_capture	int
=	O
0	int
;	O
if	O
(	O
(	O
get_komaster	()->(int)
(	O
)	O
!=	O
color	int
||	O
!	O
ko_capture	int
)	O
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
other	int
,	O
"restricted_attack2"	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
(	O
!	O
ko_capture	int
&&	O
!	O
restricted_defend1	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
)	O
||	O
(	O
ko_capture	int
&&	O
!	O
restricted_defend1	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
SGFTRACE	O
(	O
apos	int
,	O
WIN	int
,	O
"attack effective"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
apos	int
;	O
return	O
WIN	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
savecode	int
==	O
0	int
&&	O
(	O
get_komaster	()->(int)
(	O
)	O
==	O
EMPTY	int
||	O
(	O
get_komaster	()->(int)
(	O
)	O
==	O
other	int
&&	O
get_kom_pos	()->(int)
(	O
)	O
==	O
apos	int
)	O
)	O
&&	O
tryko	(int,int,*(char))->(int)
(	O
apos	int
,	O
other	int
,	O
"restricted_attack2"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
restricted_defend1	(int,*(int),int,*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	*(int)
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
savecode	int
=	O
KO_B	int
;	O
savemove	int
=	O
apos	int
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
savemove	int
;	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	*(char)
)	O
;	O
return	O
savecode	int
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
in_list	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
num_moves	int
,	O
int	O
*	O
moves	array(int)
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
==	O
move	*(int)
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
defend_lib_score	array(int)
[	O
6	int
]	O
=	O
{	O
-	O
5	int
,	O
-	O
4	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
50	int
}	O
;	O
static	O
int	O
defend_not_adjacent_lib_score	array(int)
[	O
5	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
5	int
}	O
;	O
static	O
int	O
defend_capture_score	array(int)
[	O
6	int
]	O
=	O
{	O
0	int
,	O
6	int
,	O
9	int
,	O
13	int
,	O
18	int
,	O
24	int
}	O
;	O
static	O
int	O
defend_atari_score	array(int)
[	O
6	int
]	O
=	O
{	O
0	int
,	O
2	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
8	int
}	O
;	O
static	O
int	O
defend_save_score	array(int)
[	O
6	int
]	O
=	O
{	O
0	int
,	O
3	int
,	O
6	int
,	O
8	int
,	O
10	int
,	O
12	int
}	O
;	O
static	O
int	O
defend_open_score	array(int)
[	O
5	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
}	O
;	O
static	O
int	O
attack_own_lib_score	array(int)
[	O
5	int
]	O
=	O
{	O
10	int
,	O
-	O
4	int
,	O
2	int
,	O
3	int
,	O
4	int
}	O
;	O
static	O
int	O
attack_string_lib_score	array(int)
[	O
6	int
]	O
=	O
{	O
-	O
5	int
,	O
2	int
,	O
3	int
,	O
7	int
,	O
10	int
,	O
19	int
}	O
;	O
static	O
int	O
attack_capture_score	array(int)
[	O
6	int
]	O
=	O
{	O
-	O
4	int
,	O
4	int
,	O
10	int
,	O
15	int
,	O
20	int
,	O
25	int
}	O
;	O
static	O
int	O
attack_save_score	array(int)
[	O
6	int
]	O
=	O
{	O
0	int
,	O
10	int
,	O
13	int
,	O
18	int
,	O
21	int
,	O
24	int
}	O
;	O
static	O
int	O
attack_open_score	array(int)
[	O
5	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
2	int
,	O
4	int
,	O
4	int
}	O
;	O
static	O
int	O
defend_not_edge_score	int
=	O
5	int
;	O
static	O
int	O
attack_not_edge_score	int
=	O
1	int
;	O
static	O
int	O
attack_ko_score	int
=	O
-	O
15	int
;	O
static	O
int	O
cannot_defend_penalty	int
=	O
-	O
20	int
;	O
static	O
int	O
safe_atari_score	int
=	O
8	int
;	O
static	O
void	O
sgf_dumpmoves	(*(struct(array(int),array(int),array(*(char)),int,int)),*(char))->(void)
(	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
const	O
char	O
*	O
funcname	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
i	int
,	O
chars	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"Move order for %s: %n"	*(char)
,	O
funcname	*(char)
,	O
&	O
chars	int
)	O
;	O
pos	int
=	O
buf	*(char)
+	O
chars	int
;	O
for	O
(	O
i	int
=	O
moves	array(int)
->	O
num_tried	int
;	O
i	int
<	O
moves	array(int)
->	O
num	int
;	O
i	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
pos	int
,	O
"%c%d (%d) %n"	*(char)
,	O
J	O
(	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
)	O
,	O
moves	array(int)
->	O
score	float
[	O
i	int
]	O
,	O
&	O
chars	int
)	O
;	O
pos	int
+=	O
chars	int
;	O
}	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
static	O
void	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
*	O
moves	array(int)
,	O
int	O
color	int
,	O
const	O
char	O
*	O
funcname	*(char)
,	O
int	O
killer	int
)	O
{	O
int	O
string_color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
string_libs	int
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
int	O
r	int
;	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
moves	array(int)
->	O
num	int
-	O
moves	array(int)
->	O
num_tried	int
<	O
2	int
)	O
{	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
moves	array(int)
->	O
num	int
>	O
moves	array(int)
->	O
num_tried	int
)	O
sgf_dumpmoves	(*(struct(array(int),array(int),array(*(char)),int,int)),*(char))->(void)
(	O
moves	array(int)
,	O
funcname	*(char)
)	O
;	O
return	O
;	O
}	O
for	O
(	O
r	int
=	O
moves	array(int)
->	O
num_tried	int
;	O
r	int
<	O
moves	array(int)
->	O
num	int
;	O
r	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
moves	array(int)
->	O
pos	int
[	O
r	int
]	O
;	O
int	O
number_edges	*(int)
=	O
0	int
;	O
int	O
number_same_string	*(int)
=	O
0	int
;	O
int	O
number_own	*(int)
=	O
0	int
;	O
int	O
number_opponent	*(int)
=	O
0	int
;	O
int	O
captured_stones	*(int)
=	O
0	int
;	O
int	O
threatened_stones	*(int)
=	O
0	int
;	O
int	O
saved_stones	*(int)
=	O
0	int
;	O
int	O
number_open	*(int)
=	O
0	int
;	O
incremental_order_moves	(int,int,int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(void)
(	O
move	*(int)
,	O
color	int
,	O
str	int
,	O
&	O
number_edges	*(int)
,	O
&	O
number_same_string	*(int)
,	O
&	O
number_own	*(int)
,	O
&	O
number_opponent	*(int)
,	O
&	O
captured_stones	*(int)
,	O
&	O
threatened_stones	*(int)
,	O
&	O
saved_stones	*(int)
,	O
&	O
number_open	*(int)
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%o %1m values: %d %d %d %d %d %d %d %d\n"	*(char)
,	O
move	*(int)
,	O
number_edges	*(int)
,	O
number_same_string	*(int)
,	O
number_own	*(int)
,	O
number_opponent	*(int)
,	O
captured_stones	*(int)
,	O
threatened_stones	*(int)
,	O
saved_stones	*(int)
,	O
number_open	*(int)
)	O
;	O
if	O
(	O
color	int
==	O
string_color	int
)	O
{	O
int	O
libs	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
10	int
,	O
NULL	O
)	O
;	O
if	O
(	O
number_same_string	*(int)
>	O
0	int
)	O
{	O
if	O
(	O
libs	*(int)
>	O
5	int
||	O
(	O
libs	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_lib_score	array(int)
[	O
5	int
]	O
+	O
(	O
libs	*(int)
-	O
4	int
)	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_lib_score	array(int)
[	O
libs	*(int)
]	O
;	O
}	O
else	O
{	O
if	O
(	O
libs	*(int)
>	O
4	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_adjacent_lib_score	array(int)
[	O
4	int
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_adjacent_lib_score	array(int)
[	O
libs	*(int)
]	O
;	O
}	O
gg_assert	O
(	O
number_open	*(int)
<=	O
4	int
)	O
;	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_open_score	array(int)
[	O
number_open	*(int)
]	O
;	O
if	O
(	O
number_edges	*(int)
==	O
0	int
||	O
captured_stones	*(int)
>	O
0	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_edge_score	int
;	O
if	O
(	O
captured_stones	*(int)
<=	O
5	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_capture_score	array(int)
[	O
captured_stones	*(int)
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_capture_score	array(int)
[	O
5	int
]	O
+	O
captured_stones	*(int)
;	O
if	O
(	O
libs	*(int)
+	O
captured_stones	*(int)
>	O
1	int
)	O
{	O
if	O
(	O
threatened_stones	*(int)
<=	O
5	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_atari_score	array(int)
[	O
threatened_stones	*(int)
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_atari_score	array(int)
[	O
5	int
]	O
+	O
threatened_stones	*(int)
;	O
}	O
if	O
(	O
saved_stones	*(int)
<=	O
5	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_save_score	array(int)
[	O
saved_stones	*(int)
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
defend_save_score	array(int)
[	O
5	int
]	O
;	O
}	O
else	O
{	O
int	O
libs	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
libs	*(int)
>	O
4	int
)	O
libs	*(int)
=	O
4	int
;	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_own_lib_score	array(int)
[	O
libs	*(int)
]	O
;	O
if	O
(	O
libs	*(int)
==	O
0	int
&&	O
captured_stones	*(int)
==	O
1	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_ko_score	int
;	O
if	O
(	O
(	O
libs	*(int)
+	O
captured_stones	*(int)
>	O
1	int
||	O
(	O
string_libs	int
<=	O
2	int
&&	O
number_own	*(int)
==	O
0	int
)	O
)	O
&&	O
number_same_string	*(int)
>	O
0	int
)	O
{	O
int	O
safe_atari	int
;	O
int	O
liberties	*(int)
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
string_color	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
5	int
||	O
(	O
liberties	*(int)
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
liberties	*(int)
=	O
5	int
;	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_string_lib_score	array(int)
[	O
liberties	*(int)
]	O
;	O
safe_atari	int
=	O
(	O
string_libs	int
<=	O
2	int
&&	O
libs	*(int)
+	O
captured_stones	*(int)
>	O
1	int
)	O
;	O
if	O
(	O
liberties	*(int)
==	O
1	int
&&	O
saved_stones	*(int)
==	O
0	int
&&	O
!	O
safe_atari	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
cannot_defend_penalty	int
;	O
if	O
(	O
safe_atari	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
safe_atari_score	int
;	O
}	O
gg_assert	O
(	O
number_open	*(int)
<=	O
4	int
)	O
;	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_open_score	array(int)
[	O
number_open	*(int)
]	O
;	O
if	O
(	O
number_edges	*(int)
==	O
0	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_not_edge_score	int
;	O
if	O
(	O
captured_stones	*(int)
<=	O
5	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_capture_score	array(int)
[	O
captured_stones	*(int)
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_capture_score	array(int)
[	O
5	int
]	O
;	O
if	O
(	O
saved_stones	*(int)
<=	O
5	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_save_score	array(int)
[	O
saved_stones	*(int)
]	O
;	O
else	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
attack_save_score	array(int)
[	O
5	int
]	O
;	O
}	O
if	O
(	O
moves	array(int)
->	O
pos	int
[	O
r	int
]	O
==	O
killer	int
)	O
moves	array(int)
->	O
score	float
[	O
r	int
]	O
+=	O
50	int
;	O
}	O
for	O
(	O
i	int
=	O
moves	array(int)
->	O
num_tried	int
;	O
i	int
<	O
moves	array(int)
->	O
num	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
maxscore	int
=	O
moves	array(int)
->	O
score	float
[	O
i	int
]	O
;	O
int	O
max_at	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
moves	array(int)
->	O
num	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
->	O
score	float
[	O
j	int
]	O
>	O
maxscore	int
)	O
{	O
maxscore	int
=	O
moves	array(int)
->	O
score	float
[	O
j	int
]	O
;	O
max_at	int
=	O
j	int
;	O
}	O
}	O
if	O
(	O
max_at	int
!=	O
0	int
)	O
{	O
int	O
temp	int
=	O
moves	array(int)
->	O
pos	int
[	O
max_at	int
]	O
;	O
const	O
char	O
*	O
temp_message	*(char)
=	O
moves	array(int)
->	O
message	*(char)
[	O
max_at	int
]	O
;	O
moves	array(int)
->	O
pos	int
[	O
max_at	int
]	O
=	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
;	O
moves	array(int)
->	O
score	float
[	O
max_at	int
]	O
=	O
moves	array(int)
->	O
score	float
[	O
i	int
]	O
;	O
moves	array(int)
->	O
message	*(char)
[	O
max_at	int
]	O
=	O
moves	array(int)
->	O
message	*(char)
[	O
i	int
]	O
;	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
=	O
temp	int
;	O
moves	array(int)
->	O
score	float
[	O
i	int
]	O
=	O
maxscore	int
;	O
moves	array(int)
->	O
message	*(char)
[	O
i	int
]	O
=	O
temp_message	*(char)
;	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%oVariation %d:\n"	*(char)
,	O
count_variations	int
)	O
;	O
for	O
(	O
i	int
=	O
moves	array(int)
->	O
num_tried	int
;	O
i	int
<	O
moves	array(int)
->	O
num	int
;	O
i	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%o  %1M %d\n"	*(char)
,	O
moves	array(int)
->	O
pos	int
[	O
i	int
]	O
,	O
moves	array(int)
->	O
score	float
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
sgf_dumpmoves	(*(struct(array(int),array(int),array(*(char)),int,int)),*(char))->(void)
(	O
moves	array(int)
,	O
funcname	*(char)
)	O
;	O
}	O
void	O
tune_move_ordering	(array(int))->(void)
(	O
int	O
params	array(int)
[	O
MOVE_ORDERING_PARAMETERS	int
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
{	O
defend_lib_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
defend_not_adjacent_lib_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
6	int
]	O
;	O
defend_capture_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
11	int
]	O
;	O
defend_atari_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
17	int
]	O
;	O
defend_save_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
23	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
{	O
defend_open_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
29	int
]	O
;	O
attack_own_lib_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
34	int
]	O
;	O
}	O
attack_string_lib_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
39	int
]	O
;	O
attack_capture_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
45	int
]	O
;	O
attack_save_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
51	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
attack_open_score	array(int)
[	O
k	int
]	O
=	O
params	array(int)
[	O
k	int
+	O
57	int
]	O
;	O
}	O
defend_not_edge_score	int
=	O
params	array(int)
[	O
62	int
]	O
;	O
attack_not_edge_score	int
=	O
params	array(int)
[	O
63	int
]	O
;	O
attack_ko_score	int
=	O
params	array(int)
[	O
64	int
]	O
;	O
cannot_defend_penalty	int
=	O
params	array(int)
[	O
65	int
]	O
;	O
safe_atari_score	int
=	O
params	array(int)
[	O
66	int
]	O
;	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"static int defend_lib_score[6]              = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_lib_score	array(int)
[	O
0	int
]	O
,	O
defend_lib_score	array(int)
[	O
1	int
]	O
,	O
defend_lib_score	array(int)
[	O
2	int
]	O
,	O
defend_lib_score	array(int)
[	O
3	int
]	O
,	O
defend_lib_score	array(int)
[	O
4	int
]	O
,	O
defend_lib_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_not_adjacent_lib_score[5] = {%d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_not_adjacent_lib_score	array(int)
[	O
0	int
]	O
,	O
defend_not_adjacent_lib_score	array(int)
[	O
1	int
]	O
,	O
defend_not_adjacent_lib_score	array(int)
[	O
2	int
]	O
,	O
defend_not_adjacent_lib_score	array(int)
[	O
3	int
]	O
,	O
defend_not_adjacent_lib_score	array(int)
[	O
4	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_capture_score	array(int)
[	O
0	int
]	O
,	O
defend_capture_score	array(int)
[	O
1	int
]	O
,	O
defend_capture_score	array(int)
[	O
2	int
]	O
,	O
defend_capture_score	array(int)
[	O
3	int
]	O
,	O
defend_capture_score	array(int)
[	O
4	int
]	O
,	O
defend_capture_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_atari_score[6]            = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_atari_score	array(int)
[	O
0	int
]	O
,	O
defend_atari_score	array(int)
[	O
1	int
]	O
,	O
defend_atari_score	array(int)
[	O
2	int
]	O
,	O
defend_atari_score	array(int)
[	O
3	int
]	O
,	O
defend_atari_score	array(int)
[	O
4	int
]	O
,	O
defend_atari_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_save_score	array(int)
[	O
0	int
]	O
,	O
defend_save_score	array(int)
[	O
1	int
]	O
,	O
defend_save_score	array(int)
[	O
2	int
]	O
,	O
defend_save_score	array(int)
[	O
3	int
]	O
,	O
defend_save_score	array(int)
[	O
4	int
]	O
,	O
defend_save_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_open_score[5]             = {%d, %d, %d, %d, %d};\n"	*(char)
,	O
defend_open_score	array(int)
[	O
0	int
]	O
,	O
defend_open_score	array(int)
[	O
1	int
]	O
,	O
defend_open_score	array(int)
[	O
2	int
]	O
,	O
defend_open_score	array(int)
[	O
3	int
]	O
,	O
defend_open_score	array(int)
[	O
4	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_own_lib_score[5]          = {%d, %d, %d, %d, %d};\n"	*(char)
,	O
attack_own_lib_score	array(int)
[	O
0	int
]	O
,	O
attack_own_lib_score	array(int)
[	O
1	int
]	O
,	O
attack_own_lib_score	array(int)
[	O
2	int
]	O
,	O
attack_own_lib_score	array(int)
[	O
3	int
]	O
,	O
attack_own_lib_score	array(int)
[	O
4	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_string_lib_score[6]       = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
attack_string_lib_score	array(int)
[	O
0	int
]	O
,	O
attack_string_lib_score	array(int)
[	O
1	int
]	O
,	O
attack_string_lib_score	array(int)
[	O
2	int
]	O
,	O
attack_string_lib_score	array(int)
[	O
3	int
]	O
,	O
attack_string_lib_score	array(int)
[	O
4	int
]	O
,	O
attack_string_lib_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
attack_capture_score	array(int)
[	O
0	int
]	O
,	O
attack_capture_score	array(int)
[	O
1	int
]	O
,	O
attack_capture_score	array(int)
[	O
2	int
]	O
,	O
attack_capture_score	array(int)
[	O
3	int
]	O
,	O
attack_capture_score	array(int)
[	O
4	int
]	O
,	O
attack_capture_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n"	*(char)
,	O
attack_save_score	array(int)
[	O
0	int
]	O
,	O
attack_save_score	array(int)
[	O
1	int
]	O
,	O
attack_save_score	array(int)
[	O
2	int
]	O
,	O
attack_save_score	array(int)
[	O
3	int
]	O
,	O
attack_save_score	array(int)
[	O
4	int
]	O
,	O
attack_save_score	array(int)
[	O
5	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_open_score[5]             = {%d, %d, %d, %d, %d};\n"	*(char)
,	O
attack_open_score	array(int)
[	O
0	int
]	O
,	O
attack_open_score	array(int)
[	O
1	int
]	O
,	O
attack_open_score	array(int)
[	O
2	int
]	O
,	O
attack_open_score	array(int)
[	O
3	int
]	O
,	O
attack_open_score	array(int)
[	O
4	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int defend_not_edge_score            = %d;\n"	*(char)
,	O
defend_not_edge_score	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_not_edge_score            = %d;\n"	*(char)
,	O
attack_not_edge_score	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int attack_ko_score                  = %d;\n"	*(char)
,	O
attack_ko_score	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int cannot_defend_penalty            = %d;\n"	*(char)
,	O
cannot_defend_penalty	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"static int safe_atari_score                 = %d;\n"	*(char)
,	O
safe_atari_score	int
)	O
;	O
}	O
}	O
static	O
int	O
safe_move_cache	array(array(int))
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
static	O
int	O
safe_move_cache_when	array(array(int))
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
static	O
void	O
clear_safe_move_cache	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
clear_safe_move_cache	()->(void)
(	O
void	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
BOARDMIN	O
;	O
k	int
<	O
BOARDMAX	O
;	O
k	int
++	O
)	O
{	O
safe_move_cache_when	array(array(int))
[	O
k	int
]	O
[	O
0	int
]	O
=	O
-	O
1	int
;	O
safe_move_cache_when	array(array(int))
[	O
k	int
]	O
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
int	O
safe_move	(int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
safe	int
=	O
0	int
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
int	O
ko_move	int
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
clear_safe_move_cache	()->(void)
(	O
)	O
;	O
initialized	int
=	O
1	int
;	O
}	O
if	O
(	O
stackp	int
==	O
0	int
&&	O
depth_offset	int
==	O
0	int
&&	O
safe_move_cache_when	array(array(int))
[	O
move	*(int)
]	O
[	O
color	int
==	O
BLACK	int
]	O
==	O
position_number	int
)	O
return	O
safe_move_cache	array(array(int))
[	O
move	*(int)
]	O
[	O
color	int
==	O
BLACK	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"safe_move"	*(char)
,	O
0	int
,	O
&	O
ko_move	int
,	O
1	int
)	O
)	O
{	O
safe	int
=	O
REVERSE_RESULT	O
(	O
attack	(int,*(int))->(int)
(	O
move	*(int)
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
ko_move	int
&&	O
safe	int
!=	O
0	int
)	O
safe	int
=	O
KO_B	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
stackp	int
==	O
0	int
&&	O
depth_offset	int
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"Safe move at %1m for %s cached when depth=%d, position number=%d\n"	*(char)
,	O
move	*(int)
,	O
color_to_string	(int)->(*(char))
(	O
color	int
)	O
,	O
depth	int
,	O
position_number	int
)	O
;	O
safe_move_cache_when	array(array(int))
[	O
move	*(int)
]	O
[	O
color	int
==	O
BLACK	int
]	O
=	O
position_number	int
;	O
safe_move_cache	array(array(int))
[	O
move	*(int)
]	O
[	O
color	int
==	O
BLACK	int
]	O
=	O
safe	int
;	O
}	O
return	O
safe	int
;	O
}	O
int	O
does_secure	(int,int,int)->(int)
(	O
int	O
color	int
,	O
int	O
move	*(int)
,	O
int	O
pos	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
result	int
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
void	O
reset_reading_node_counter	()->(void)
(	O
)	O
{	O
reading_node_counter	int
=	O
0	int
;	O
}	O
int	O
get_reading_node_counter	()->(int)
(	O
)	O
{	O
return	O
reading_node_counter	int
;	O
}	O
void	O
draw_reading_shadow	()->(void)
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
c	char
=	O
' '	O
;	O
int	O
pos	int
;	O
start_draw_board	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%2d"	*(char)
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
!	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
'.'	O
;	O
else	O
if	O
(	O
!	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
!	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
if	O
(	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
','	O
;	O
else	O
if	O
(	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
'o'	O
;	O
else	O
if	O
(	O
shadow	array(char)
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
'x'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %c"	*(char)
,	O
c	char
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
board_size	int
-	O
i	int
)	O
;	O
}	O
end_draw_board	()->(void)
(	O
)	O
;	O
}	O
int	O
simple_ladder	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
dcode	int
;	O
int	O
k	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
SETUP_TRACE_INFO	O
(	O
"simple_ladder"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array(int)
.	O
num	int
=	O
0	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
stackp	int
>	O
depth	int
+	O
20	int
&&	O
get_komaster	()->(int)
(	O
)	O
==	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
PASS_MOVE	int
;	O
return	O
0	int
;	O
}	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
<=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
1	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"simple_ladder"	*(char)
)	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
<=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
0	int
,	O
moves	array(int)
,	O
"simple_ladder"	*(char)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
other	int
,	O
read_function_name	*(char)
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array(int)
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
apos	int
=	O
moves	array(int)
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
apos	int
,	O
other	int
,	O
moves	array(int)
.	O
message	*(char)
[	O
k	int
]	O
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
dcode	int
=	O
simple_ladder_defend	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
SGFTRACE	O
(	O
apos	int
,	O
WIN	int
,	O
"attack effective"	*(char)
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
apos	int
;	O
return	O
WIN	int
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
simple_ladder_defend	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
apos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
static	O
int	O
simple_ladder_defend	(int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct(array(int),array(int),array(*(char)),int,int)
moves	array(int)
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"simple_ladder_defend"	*(char)
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	(int)->(int)
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
moves	array(int)
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array(int)
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array(int)
.	O
message	*(char)
[	O
0	int
]	O
=	O
"liberty"	*(char)
;	O
moves	array(int)
.	O
num	int
=	O
1	int
;	O
moves	array(int)
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)))->(void)
(	O
str	int
,	O
&	O
moves	array(int)
)	O
;	O
order_moves	(int,*(struct(array(int),array(int),array(*(char)),int,int)),int,*(char),int)->(void)
(	O
str	int
,	O
&	O
moves	array(int)
,	O
color	int
,	O
read_function_name	*(char)
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array(int)
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array(int)
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
xpos	int
,	O
color	int
,	O
moves	array(int)
.	O
message	*(char)
[	O
k	int
]	O
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
{	O
int	O
acode	int
;	O
int	O
new_libs	int
=	O
countlib	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
new_libs	int
>	O
2	int
)	O
acode	int
=	O
0	int
;	O
else	O
if	O
(	O
new_libs	int
<	O
2	int
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
simple_ladder	(int,*(int))->(int)
(	O
str	int
,	O
NULL	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
,	O
move	*(int)
,	O
"defense effective"	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
acode	int
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
}	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	*(int)
,	O
"saved move"	*(char)
)	O
;	O
}	O
