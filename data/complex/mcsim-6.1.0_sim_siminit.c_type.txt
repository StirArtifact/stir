void	O
GetModelInfo	O
(	O
PMODELINFO	O
pmi	O
)	O
{	O
pmi	O
->	O
nModelVars	O
=	O
(	O
long	O
)	O
GetNModelVars	()->(int)
(	O
)	O
;	O
pmi	O
->	O
pdModelVars	O
=	O
GetModelVector	()->(*(double))
(	O
)	O
;	O
if	O
(	O
(	O
pmi	O
->	O
nStates	O
=	O
(	O
long	O
)	O
GetNStates	()->(int)
(	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pmi	O
->	O
pStateHvar	O
=	O
(	O
HVAR	long
*	O
)	O
malloc	(long)->(*(void))
(	O
pmi	O
->	O
nStates	O
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetModelInfo"	*(char)
,	O
NULL	O
)	O
;	O
GetStateHandles	O
(	O
pmi	O
->	O
pStateHvar	O
)	O
;	O
}	O
else	O
{	O
pmi	O
->	O
pStateHvar	O
=	O
NULL	O
;	O
}	O
}	O
void	O
InitIntegratorSpec	O
(	O
PINTSPEC	*(struct(int,long,long,long,double,double,long,long,long,long,*(long),*(double),double))
pis	O
)	O
{	O
pis	O
->	O
iAlgo	int
=	O
IAL_DEFAULT	O
;	O
pis	O
->	O
iopt	long
=	O
IOPT_DEFAULT	O
;	O
pis	O
->	O
itask	long
=	O
ITASK_DEFAULT	O
;	O
pis	O
->	O
itol	long
=	O
ITOL_DEFAULT	O
;	O
pis	O
->	O
dRtol	double
=	O
RTOL_DEFAULT	O
;	O
pis	O
->	O
dAtol	double
=	O
ATOL_DEFAULT	O
;	O
pis	O
->	O
iMf	long
=	O
IMF_DEFAULT	O
;	O
pis	O
->	O
liw	long
=	O
LSODES_IWORKSIZE	O
;	O
pis	O
->	O
lrw	long
=	O
LSODES_RWORKSIZE	O
;	O
if	O
(	O
!	O
(	O
pis	O
->	O
iwork	*(long)
=	O
InitlVector	(long)->(*(long))
(	O
pis	O
->	O
liw	long
)	O
)	O
||	O
!	O
(	O
pis	O
->	O
rwork	*(double)
=	O
InitdVector	(long)->(*(double))
(	O
pis	O
->	O
lrw	long
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitIntegratorSpec()"	*(char)
,	O
NULL	O
)	O
;	O
pis	O
->	O
dTStep	double
=	O
TSTEP_DEFAULT	O
;	O
}	O
void	O
InitOutputSpec	O
(	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
)	O
{	O
pos	O
->	O
nOutputs	int
=	O
0	int
;	O
pos	O
->	O
pszOutputNames	*(*(char))
=	O
NULL	O
;	O
pos	O
->	O
phvar_out	*(long)
=	O
NULL	O
;	O
pos	O
->	O
nData	int
=	O
0	int
;	O
pos	O
->	O
pszDataNames	*(*(char))
=	O
NULL	O
;	O
pos	O
->	O
phvar_dat	*(long)
=	O
NULL	O
;	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
NULL	O
;	O
pos	O
->	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
NULL	O
;	O
pos	O
->	O
pcOutputTimes	*(int)
=	O
NULL	O
;	O
pos	O
->	O
piCurrentOut	*(int)
=	O
NULL	O
;	O
pos	O
->	O
prgdOutputTimes	*(*(double))
=	O
NULL	O
;	O
pos	O
->	O
prgdOutputVals	*(*(double))
=	O
NULL	O
;	O
pos	O
->	O
pcData	*(int)
=	O
NULL	O
;	O
pos	O
->	O
prgdDataVals	*(*(double))
=	O
NULL	O
;	O
pos	O
->	O
cDistinctTimes	int
=	O
0	int
;	O
pos	O
->	O
rgdDistinctTimes	*(double)
=	O
NULL	O
;	O
}	O
void	O
InitExperiment	O
(	O
PEXPERIMENT	O
pexp	O
,	O
PMODELINFO	O
pmodelinfo	O
)	O
{	O
pexp	O
->	O
iExp	O
=	O
0	int
;	O
pexp	O
->	O
dT0	double
=	O
T0_DEFAULT	O
;	O
pexp	O
->	O
dTfinal	O
=	O
TFINAL_DEFAULT	O
;	O
pexp	O
->	O
dTime	O
=	O
0.0	int
;	O
pexp	O
->	O
pmodelinfo	O
=	O
pmodelinfo	O
;	O
pexp	O
->	O
plistParmMods	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
InitIntegratorSpec	O
(	O
&	O
pexp	O
->	O
is	O
)	O
;	O
InitOutputSpec	O
(	O
&	O
pexp	O
->	O
os	O
)	O
;	O
}	O
void	O
InitMonteCarlo	O
(	O
PMONTECARLO	O
pmc	O
)	O
{	O
pmc	O
->	O
nRuns	O
=	O
NSIMULATIONS_DEFAULT	O
;	O
pmc	O
->	O
szMCOutfilename	O
=	O
NULL	O
;	O
pmc	O
->	O
pfileMCOut	O
=	O
NULL	O
;	O
pmc	O
->	O
szSetPointsFilename	O
=	O
NULL	O
;	O
pmc	O
->	O
pfileSetPoints	O
=	O
NULL	O
;	O
pmc	O
->	O
plistMCVars	O
=	O
NULL	O
;	O
pmc	O
->	O
rgdParms	O
=	O
NULL	O
;	O
pmc	O
->	O
rghvar	O
=	O
NULL	O
;	O
pmc	O
->	O
rgpMCVar	O
=	O
NULL	O
;	O
}	O
void	O
InitGibbs	O
(	O
PGIBBSDATA	O
pgd	O
)	O
{	O
pgd	O
->	O
nMaxIter	O
=	O
NSIMULATIONS_DEFAULT	O
;	O
pgd	O
->	O
nSimTypeFlag	O
=	O
0	int
;	O
pgd	O
->	O
nPrintIter	O
=	O
NSIMULATIONS_DEFAULT	O
;	O
pgd	O
->	O
nPrintFreq	O
=	O
1	int
;	O
pgd	O
->	O
nMaxPerkSetIter	O
=	O
300000	int
;	O
pgd	O
->	O
szGout	O
=	O
NULL	O
;	O
pgd	O
->	O
pfileOut	O
=	O
NULL	O
;	O
pgd	O
->	O
szGrestart	O
=	O
NULL	O
;	O
pgd	O
->	O
pfileRestart	O
=	O
NULL	O
;	O
pgd	O
->	O
szGdata	O
=	O
NULL	O
;	O
pgd	O
->	O
nPerks	O
=	O
0	int
;	O
pgd	O
->	O
indexT	O
=	O
0	int
;	O
pgd	O
->	O
dCZero	O
=	O
100	int
;	O
pgd	O
->	O
dNZero	O
=	O
100	int
;	O
pgd	O
->	O
startT	O
=	O
0	int
;	O
pgd	O
->	O
endT	O
=	O
0	int
;	O
pgd	O
->	O
rglTransAttempts	O
=	O
NULL	O
;	O
pgd	O
->	O
rglTransAccepts	O
=	O
NULL	O
;	O
}	O
void	O
InitAnalysis	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
int	O
i	O
;	O
if	O
(	O
!	O
panal	O
)	O
return	O
;	O
panal	O
->	O
bDependents	O
=	O
FALSE	O
;	O
panal	O
->	O
bOutputIter	O
=	O
FALSE	O
;	O
panal	O
->	O
nOutputFreq	O
=	O
0	int
;	O
panal	O
->	O
bPrintConvergence	O
=	O
FALSE	O
;	O
panal	O
->	O
iType	int
=	O
AT_DEFAULTSIM	O
;	O
panal	O
->	O
dSeed	double
=	O
SEED_DEFAULT	O
;	O
panal	O
->	O
wContext	O
=	O
CN_GLOBAL	O
;	O
panal	O
->	O
pexpCurrent	O
=	O
&	O
panal	O
->	O
expGlobal	O
;	O
GetModelInfo	O
(	O
&	O
panal	O
->	O
modelinfo	O
)	O
;	O
InitExperiment	O
(	O
&	O
panal	O
->	O
expGlobal	O
,	O
&	O
panal	O
->	O
modelinfo	O
)	O
;	O
panal	O
->	O
szOutfilename	O
=	O
NULL	O
;	O
panal	O
->	O
pfileOut	O
=	O
NULL	O
;	O
panal	O
->	O
bCommandLineSpec	O
=	O
FALSE	O
;	O
panal	O
->	O
bAllocatedFileName	O
=	O
FALSE	O
;	O
panal	O
->	O
iExpts	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
MAX_INSTANCES	O
;	O
i	O
++	O
)	O
panal	O
->	O
rgpExps	O
[	O
i	O
]	O
=	O
NULL	O
;	O
InitMonteCarlo	O
(	O
&	O
panal	O
->	O
mc	O
)	O
;	O
InitGibbs	O
(	O
&	O
panal	O
->	O
gd	O
)	O
;	O
}	O
BOOL	int
InitOutputs	O
(	O
PEXPERIMENT	O
pexp	O
,	O
PINT	*(int)
piOut	O
,	O
PDOUBLE	*(double)
pdTout	O
)	O
{	O
int	O
j	O
;	O
BOOL	int
bReturn	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
pexp	O
->	O
os	O
.	O
nOutputs	int
)	O
ReportError	O
(	O
NULL	O
,	O
RE_NOOUTPUTS	O
,	O
(	O
PSTR	*(char)
)	O
&	O
pexp	O
->	O
iExp	O
,	O
NULL	O
)	O
;	O
else	O
{	O
*	O
piOut	O
=	O
0	int
;	O
*	O
pdTout	O
=	O
pexp	O
->	O
os	O
.	O
rgdDistinctTimes	*(double)
[	O
0	int
]	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pexp	O
->	O
os	O
.	O
nOutputs	int
;	O
j	O
++	O
)	O
pexp	O
->	O
os	O
.	O
piCurrentOut	*(int)
[	O
j	O
]	O
=	O
0	int
;	O
bReturn	O
=	O
TRUE	O
;	O
}	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
int	O
InitOneOutVar	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pInfo	*(void)
)	O
{	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
ppr	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
pData	*(void)
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
=	O
(	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
)	O
pInfo	*(void)
;	O
int	O
i	O
=	O
pos	O
->	O
nOutputs	int
++	O
;	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
i	O
]	O
=	O
ppr	O
->	O
szOutputName	*(char)
;	O
pos	O
->	O
phvar_out	*(long)
[	O
i	O
]	O
=	O
ppr	O
->	O
hvar	long
;	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
=	O
ppr	O
->	O
cTimes	long
;	O
pos	O
->	O
piCurrentOut	*(int)
[	O
i	O
]	O
=	O
0	int
;	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
i	O
]	O
=	O
ppr	O
->	O
pdTimes	*(double)
;	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
i	O
]	O
=	O
InitdVector	(long)->(*(double))
(	O
ppr	O
->	O
cTimes	long
)	O
;	O
if	O
(	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
i	O
]	O
==	O
NULL	O
||	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
i	O
]	O
==	O
NULL	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"InitOneOutVar()"	*(char)
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
InitOneDataVar	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pInfo	*(void)
)	O
{	O
PDATAREC	*(struct(*(char),long,long,*(double)))
pda	O
=	O
(	O
PDATAREC	*(struct(*(char),long,long,*(double)))
)	O
pData	*(void)
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
=	O
(	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
)	O
pInfo	*(void)
;	O
int	O
i	O
=	O
pos	O
->	O
nData	int
++	O
;	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
i	O
]	O
=	O
pda	O
->	O
pdData	*(double)
;	O
pos	O
->	O
pcData	*(int)
[	O
i	O
]	O
=	O
pda	O
->	O
cData	long
;	O
pos	O
->	O
phvar_dat	*(long)
[	O
i	O
]	O
=	O
pda	O
->	O
hvar	long
;	O
pos	O
->	O
pszDataNames	*(*(char))
[	O
i	O
]	O
=	O
pda	O
->	O
szDataName	*(char)
;	O
return	O
0	int
;	O
}	O
BOOL	int
FindNewPoint	O
(	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
,	O
PINT	*(int)
piPoint	O
)	O
{	O
for	O
(	O
*	O
piPoint	O
=	O
0	int
;	O
*	O
piPoint	O
<	O
pos	O
->	O
nOutputs	int
;	O
(	O
*	O
piPoint	O
)	O
++	O
)	O
if	O
(	O
pos	O
->	O
piCurrentOut	*(int)
[	O
*	O
piPoint	O
]	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
*	O
piPoint	O
]	O
)	O
break	O
;	O
return	O
(	O
*	O
piPoint	O
<	O
pos	O
->	O
nOutputs	int
?	O
TRUE	O
:	O
FALSE	O
)	O
;	O
}	O
void	O
CreateOutputSchedule	O
(	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
)	O
{	O
int	O
i	O
,	O
cTimes	long
=	O
0	int
,	O
iPoint	O
;	O
BOOL	int
bCont	O
=	O
TRUE	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pos	O
->	O
nOutputs	int
;	O
i	O
++	O
)	O
cTimes	long
+=	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
;	O
if	O
(	O
!	O
(	O
pos	O
->	O
rgdDistinctTimes	*(double)
=	O
InitdVector	(long)->(*(double))
(	O
cTimes	long
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"CreateOutputSchedule()"	*(char)
,	O
NULL	O
)	O
;	O
cTimes	long
=	O
0	int
;	O
FindNewPoint	O
(	O
pos	O
,	O
&	O
iPoint	O
)	O
;	O
while	O
(	O
bCont	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pos	O
->	O
nOutputs	int
;	O
i	O
++	O
)	O
if	O
(	O
i	O
!=	O
iPoint	O
&&	O
pos	O
->	O
piCurrentOut	*(int)
[	O
i	O
]	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
)	O
{	O
if	O
(	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
i	O
]	O
[	O
pos	O
->	O
piCurrentOut	*(int)
[	O
i	O
]	O
]	O
<	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
iPoint	O
]	O
[	O
pos	O
->	O
piCurrentOut	*(int)
[	O
iPoint	O
]	O
]	O
)	O
iPoint	O
=	O
i	O
;	O
else	O
if	O
(	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
i	O
]	O
[	O
pos	O
->	O
piCurrentOut	*(int)
[	O
i	O
]	O
]	O
==	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
iPoint	O
]	O
[	O
pos	O
->	O
piCurrentOut	*(int)
[	O
iPoint	O
]	O
]	O
)	O
pos	O
->	O
piCurrentOut	*(int)
[	O
i	O
]	O
++	O
;	O
}	O
pos	O
->	O
rgdDistinctTimes	*(double)
[	O
cTimes	long
++	O
]	O
=	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
iPoint	O
]	O
[	O
pos	O
->	O
piCurrentOut	*(int)
[	O
iPoint	O
]	O
]	O
;	O
if	O
(	O
++	O
pos	O
->	O
piCurrentOut	*(int)
[	O
iPoint	O
]	O
>=	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
iPoint	O
]	O
)	O
bCont	O
=	O
FindNewPoint	O
(	O
pos	O
,	O
&	O
iPoint	O
)	O
;	O
}	O
pos	O
->	O
cDistinctTimes	int
=	O
cTimes	long
;	O
}	O
BOOL	int
PrepareOutSpec	O
(	O
PEXPERIMENT	O
pexp	O
)	O
{	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
=	O
&	O
pexp	O
->	O
os	O
;	O
BOOL	int
bReturn	O
=	O
FALSE	O
;	O
int	O
cDat	O
=	O
ListLength	O
(	O
pos	O
->	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
int	O
cOut	O
=	O
ListLength	O
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
if	O
(	O
!	O
cOut	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_NOOUTPUTS	O
,	O
(	O
PSTR	*(char)
)	O
&	O
pexp	O
->	O
iExp	O
,	O
NULL	O
)	O
;	O
else	O
{	O
pos	O
->	O
pszOutputNames	*(*(char))
=	O
(	O
PSTR	*(char)
*	O
)	O
malloc	(long)->(*(void))
(	O
cOut	O
*	O
sizeof	O
(	O
PSTR	*(char)
)	O
)	O
;	O
pos	O
->	O
phvar_out	*(long)
=	O
(	O
HVAR	long
*	O
)	O
malloc	(long)->(*(void))
(	O
cOut	O
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
;	O
pos	O
->	O
pcOutputTimes	*(int)
=	O
InitiVector	(long)->(*(int))
(	O
cOut	O
)	O
;	O
pos	O
->	O
piCurrentOut	*(int)
=	O
InitiVector	(long)->(*(int))
(	O
cOut	O
)	O
;	O
pos	O
->	O
prgdOutputTimes	*(*(double))
=	O
InitpdVector	(long)->(*(*(double)))
(	O
cOut	O
)	O
;	O
pos	O
->	O
prgdOutputVals	*(*(double))
=	O
InitpdVector	(long)->(*(*(double)))
(	O
cOut	O
)	O
;	O
if	O
(	O
pos	O
->	O
pszOutputNames	*(*(char))
==	O
NULL	O
||	O
pos	O
->	O
phvar_out	*(long)
==	O
NULL	O
||	O
pos	O
->	O
pcOutputTimes	*(int)
==	O
NULL	O
||	O
pos	O
->	O
piCurrentOut	*(int)
==	O
NULL	O
||	O
pos	O
->	O
prgdOutputTimes	*(*(double))
==	O
NULL	O
||	O
pos	O
->	O
prgdOutputVals	*(*(double))
==	O
NULL	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"PrepareOutSpec()"	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
pos	O
->	O
nOutputs	int
=	O
0	int
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
InitOneOutVar	O
,	O
(	O
PVOID	*(void)
)	O
&	O
pexp	O
->	O
os	O
)	O
;	O
pos	O
->	O
nOutputs	int
=	O
cOut	O
;	O
CreateOutputSchedule	O
(	O
pos	O
)	O
;	O
pexp	O
->	O
dTfinal	O
=	O
pos	O
->	O
rgdDistinctTimes	*(double)
[	O
pos	O
->	O
cDistinctTimes	int
-	O
1	int
]	O
;	O
if	O
(	O
pexp	O
->	O
dTfinal	O
==	O
pexp	O
->	O
dT0	double
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: starting and final times are equal in Simulation %d "	*(char)
"- Exiting.\n\n"	*(char)
,	O
pexp	O
->	O
iExp	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
bReturn	O
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
!	O
cDat	O
)	O
;	O
else	O
{	O
pos	O
->	O
prgdDataVals	*(*(double))
=	O
InitpdVector	(long)->(*(*(double)))
(	O
cDat	O
)	O
;	O
pos	O
->	O
pcData	*(int)
=	O
InitiVector	(long)->(*(int))
(	O
cDat	O
)	O
;	O
pos	O
->	O
pszDataNames	*(*(char))
=	O
(	O
PSTR	*(char)
*	O
)	O
malloc	(long)->(*(void))
(	O
cDat	O
*	O
sizeof	O
(	O
PSTR	*(char)
)	O
)	O
;	O
pos	O
->	O
phvar_dat	*(long)
=	O
(	O
HVAR	long
*	O
)	O
malloc	(long)->(*(void))
(	O
cDat	O
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
;	O
if	O
(	O
pos	O
->	O
prgdDataVals	*(*(double))
==	O
NULL	O
||	O
pos	O
->	O
phvar_dat	*(long)
==	O
NULL	O
||	O
pos	O
->	O
pszDataNames	*(*(char))
==	O
NULL	O
||	O
pos	O
->	O
pcData	*(int)
==	O
NULL	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"PrepareOutSpec()"	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
pos	O
->	O
nData	int
=	O
0	int
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
pos	O
->	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
InitOneDataVar	O
,	O
(	O
PVOID	*(void)
)	O
&	O
pexp	O
->	O
os	O
)	O
;	O
pos	O
->	O
nData	int
=	O
cDat	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
pos	O
->	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
NULL	O
,	O
FALSE	O
)	O
;	O
}	O
}	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
BOOL	int
PrintOutSpec	O
(	O
PEXPERIMENT	O
pexp	O
)	O
{	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
=	O
&	O
pexp	O
->	O
os	O
;	O
int	O
j	O
,	O
i	O
,	O
cOut	O
=	O
pos	O
->	O
nOutputs	int
;	O
printf	(*(char))->(int)
(	O
"%d Outputs:\n"	*(char)
,	O
cOut	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
cOut	O
;	O
i	O
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  %#0lx  %s: "	*(char)
,	O
pos	O
->	O
phvar_out	*(long)
[	O
i	O
]	O
,	O
pos	O
->	O
pszOutputNames	*(*(char))
[	O
i	O
]	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
pos	O
->	O
pcOutputTimes	*(int)
[	O
i	O
]	O
;	O
j	O
++	O
)	O
printf	(*(char))->(int)
(	O
"%g "	*(char)
,	O
pos	O
->	O
prgdOutputTimes	*(*(double))
[	O
i	O
]	O
[	O
j	O
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
