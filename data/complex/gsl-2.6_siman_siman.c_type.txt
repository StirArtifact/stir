static	O
inline	O
double	O
boltzmann	(double,double,double,*(struct(int,int,double,double,double,double,double)))->(double)
(	O
double	O
E	double
,	O
double	O
new_E	double
,	O
double	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
gsl_siman_params_t	struct(int,int,double,double,double,double,double)
*	O
params	struct(int,int,double,double,double,double,double)
)	O
{	O
double	O
x	double
=	O
-	O
(	O
new_E	double
-	O
E	double
)	O
/	O
(	O
params	struct(int,int,double,double,double,double,double)
->	O
k	long
*	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
)	O
;	O
return	O
(	O
x	double
<	O
GSL_LOG_DBL_MIN	O
)	O
?	O
0.0	int
:	O
exp	(double)->(double)
(	O
x	double
)	O
;	O
}	O
static	O
inline	O
void	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
void	O
*	O
src	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
void	O
*	O
dst	*(void)
,	O
size_t	long
size	long
,	O
gsl_siman_copy_t	*((*(void),*(void))->(void))
copyfunc	*((*(void),*(void))->(void))
)	O
{	O
if	O
(	O
copyfunc	*((*(void),*(void))->(void))
)	O
{	O
copyfunc	*((*(void),*(void))->(void))
(	O
src	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
dst	*(void)
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	*(void)
,	O
src	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
size	long
)	O
;	O
}	O
}	O
void	O
gsl_siman_solve	(*(struct(*(struct(*`,long,long,long,*`,*`,*`)),*(void))),*(void),*((*(void))->(double)),*((*(struct(*`,*`)),*(void),double)->(void)),*((*(void),*(void))->(double)),*((*(void))->(void)),*((*(void),*(void))->(void)),*((*(void))->(*(void))),*((*(void))->(void)),long,struct(int,int,double,double,double,double,double))->(void)
(	O
const	O
gsl_rng	struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void))
*	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
void	O
*	O
x0_p	*(void)
,	O
gsl_siman_Efunc_t	*((*(void))->(double))
Ef	*((*(void))->(double))
,	O
gsl_siman_step_t	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
take_step	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
,	O
gsl_siman_metric_t	*((*(void),*(void))->(double))
distance	*((*(void),*(void))->(double))
,	O
gsl_siman_print_t	*((*(void))->(void))
print_position	*((*(void))->(void))
,	O
gsl_siman_copy_t	*((*(void),*(void))->(void))
copyfunc	*((*(void),*(void))->(void))
,	O
gsl_siman_copy_construct_t	*((*(void))->(*(void)))
copy_constructor	*((*(void))->(*(void)))
,	O
gsl_siman_destroy_t	*((*(void))->(void))
destructor	*((*(void))->(void))
,	O
size_t	long
element_size	long
,	O
gsl_siman_params_t	struct(int,int,double,double,double,double,double)
params	struct(int,int,double,double,double,double,double)
)	O
{	O
void	O
*	O
x	double
,	O
*	O
new_x	*(void)
,	O
*	O
best_x	*(void)
;	O
double	O
E	double
,	O
new_E	double
,	O
best_E	double
;	O
int	O
i	int
;	O
double	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
T_factor	double
;	O
int	O
n_evals	int
=	O
1	int
,	O
n_iter	int
=	O
0	int
,	O
n_accepts	int
,	O
n_rejects	int
,	O
n_eless	int
;	O
assert	O
(	O
(	O
copyfunc	*((*(void),*(void))->(void))
!=	O
NULL	O
&&	O
copy_constructor	*((*(void))->(*(void)))
!=	O
NULL	O
&&	O
destructor	*((*(void))->(void))
!=	O
NULL	O
)	O
||	O
(	O
element_size	long
!=	O
0	int
)	O
)	O
;	O
distance	*((*(void),*(void))->(double))
=	O
0	int
;	O
E	double
=	O
Ef	*((*(void))->(double))
(	O
x0_p	*(void)
)	O
;	O
if	O
(	O
copyfunc	*((*(void),*(void))->(void))
)	O
{	O
x	double
=	O
copy_constructor	*((*(void))->(*(void)))
(	O
x0_p	*(void)
)	O
;	O
new_x	*(void)
=	O
copy_constructor	*((*(void))->(*(void)))
(	O
x0_p	*(void)
)	O
;	O
best_x	*(void)
=	O
copy_constructor	*((*(void))->(*(void)))
(	O
x0_p	*(void)
)	O
;	O
}	O
else	O
{	O
x	double
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
element_size	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
x	double
,	O
x0_p	*(void)
,	O
element_size	long
)	O
;	O
new_x	*(void)
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
element_size	long
)	O
;	O
best_x	*(void)
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
element_size	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
best_x	*(void)
,	O
x0_p	*(void)
,	O
element_size	long
)	O
;	O
}	O
best_E	double
=	O
E	double
;	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
=	O
params	struct(int,int,double,double,double,double,double)
.	O
t_initial	double
;	O
T_factor	double
=	O
1.0	int
/	O
params	struct(int,int,double,double,double,double,double)
.	O
mu_t	double
;	O
if	O
(	O
print_position	*((*(void))->(void))
)	O
{	O
printf	(*(char))->(int)
(	O
"#-iter  #-evals   temperature     position   energy\n"	*(char)
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
n_accepts	int
=	O
0	int
;	O
n_rejects	int
=	O
0	int
;	O
n_eless	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
params	struct(int,int,double,double,double,double,double)
.	O
iters_fixed_T	int
;	O
++	O
i	int
)	O
{	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
x	double
,	O
new_x	*(void)
,	O
element_size	long
,	O
copyfunc	*((*(void),*(void))->(void))
)	O
;	O
take_step	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
(	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
new_x	*(void)
,	O
params	struct(int,int,double,double,double,double,double)
.	O
step_size	double
)	O
;	O
new_E	double
=	O
Ef	*((*(void))->(double))
(	O
new_x	*(void)
)	O
;	O
if	O
(	O
new_E	double
<=	O
best_E	double
)	O
{	O
if	O
(	O
copyfunc	*((*(void),*(void))->(void))
)	O
{	O
copyfunc	*((*(void),*(void))->(void))
(	O
new_x	*(void)
,	O
best_x	*(void)
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
best_x	*(void)
,	O
new_x	*(void)
,	O
element_size	long
)	O
;	O
}	O
best_E	double
=	O
new_E	double
;	O
}	O
++	O
n_evals	int
;	O
if	O
(	O
new_E	double
<	O
E	double
)	O
{	O
if	O
(	O
new_E	double
<	O
best_E	double
)	O
{	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
new_x	*(void)
,	O
best_x	*(void)
,	O
element_size	long
,	O
copyfunc	*((*(void),*(void))->(void))
)	O
;	O
best_E	double
=	O
new_E	double
;	O
}	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
new_x	*(void)
,	O
x	double
,	O
element_size	long
,	O
copyfunc	*((*(void),*(void))->(void))
)	O
;	O
E	double
=	O
new_E	double
;	O
++	O
n_eless	int
;	O
}	O
else	O
if	O
(	O
gsl_rng_uniform	(*(struct(*(struct(*`,long,long,long,*`,*`,*`)),*(void))))->(double)
(	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
)	O
<	O
boltzmann	(double,double,double,*(struct(int,int,double,double,double,double,double)))->(double)
(	O
E	double
,	O
new_E	double
,	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
&	O
params	struct(int,int,double,double,double,double,double)
)	O
)	O
{	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
new_x	*(void)
,	O
x	double
,	O
element_size	long
,	O
copyfunc	*((*(void),*(void))->(void))
)	O
;	O
E	double
=	O
new_E	double
;	O
++	O
n_accepts	int
;	O
}	O
else	O
{	O
++	O
n_rejects	int
;	O
}	O
}	O
if	O
(	O
print_position	*((*(void))->(void))
)	O
{	O
printf	(*(char))->(int)
(	O
"%5d   %7d  %12g"	*(char)
,	O
n_iter	int
,	O
n_evals	int
,	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
)	O
;	O
print_position	*((*(void))->(void))
(	O
x	double
)	O
;	O
printf	(*(char))->(int)
(	O
"  %12g  %12g\n"	*(char)
,	O
E	double
,	O
best_E	double
)	O
;	O
}	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
*=	O
T_factor	double
;	O
++	O
n_iter	int
;	O
if	O
(	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
<	O
params	struct(int,int,double,double,double,double,double)
.	O
t_min	double
)	O
{	O
break	O
;	O
}	O
}	O
copy_state	(*(void),*(void),long,*((*(void),*(void))->(void)))->(void)
(	O
best_x	*(void)
,	O
x0_p	*(void)
,	O
element_size	long
,	O
copyfunc	*((*(void),*(void))->(void))
)	O
;	O
if	O
(	O
copyfunc	*((*(void),*(void))->(void))
)	O
{	O
destructor	*((*(void))->(void))
(	O
x	double
)	O
;	O
destructor	*((*(void))->(void))
(	O
new_x	*(void)
)	O
;	O
destructor	*((*(void))->(void))
(	O
best_x	*(void)
)	O
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
x	double
)	O
;	O
free	(*(void))->(void)
(	O
new_x	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
best_x	*(void)
)	O
;	O
}	O
}	O
void	O
gsl_siman_solve_many	(*(struct(*(struct(*`,long,long,long,*`,*`,*`)),*(void))),*(void),*((*(void))->(double)),*((*(struct(*`,*`)),*(void),double)->(void)),*((*(void),*(void))->(double)),*((*(void))->(void)),long,struct(int,int,double,double,double,double,double))->(void)
(	O
const	O
gsl_rng	struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void))
*	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
void	O
*	O
x0_p	*(void)
,	O
gsl_siman_Efunc_t	*((*(void))->(double))
Ef	*((*(void))->(double))
,	O
gsl_siman_step_t	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
take_step	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
,	O
gsl_siman_metric_t	*((*(void),*(void))->(double))
distance	*((*(void),*(void))->(double))
,	O
gsl_siman_print_t	*((*(void))->(void))
print_position	*((*(void))->(void))
,	O
size_t	long
element_size	long
,	O
gsl_siman_params_t	struct(int,int,double,double,double,double,double)
params	struct(int,int,double,double,double,double,double)
)	O
{	O
void	O
*	O
x	double
,	O
*	O
new_x	*(void)
;	O
double	O
*	O
energies	*(double)
,	O
*	O
probs	*(double)
,	O
*	O
sum_probs	*(double)
;	O
double	O
Ex	double
;	O
double	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
T_factor	double
;	O
int	O
i	int
;	O
double	O
u	double
;	O
int	O
n_iter	int
;	O
if	O
(	O
print_position	*((*(void))->(void))
)	O
{	O
printf	(*(char))->(int)
(	O
"#-iter    temperature       position"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"         delta_pos        energy\n"	*(char)
)	O
;	O
}	O
x	double
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
*	O
element_size	long
)	O
;	O
new_x	*(void)
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
*	O
element_size	long
)	O
;	O
energies	*(double)
=	O
(	O
double	O
*	O
)	O
malloc	(long)->(*(void))
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
probs	*(double)
=	O
(	O
double	O
*	O
)	O
malloc	(long)->(*(void))
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
sum_probs	*(double)
=	O
(	O
double	O
*	O
)	O
malloc	(long)->(*(void))
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
=	O
params	struct(int,int,double,double,double,double,double)
.	O
t_initial	double
;	O
T_factor	double
=	O
1.0	int
/	O
params	struct(int,int,double,double,double,double,double)
.	O
mu_t	double
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
x	double
,	O
x0_p	*(void)
,	O
element_size	long
)	O
;	O
n_iter	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
Ex	double
=	O
Ef	*((*(void))->(double))
(	O
x	double
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
-	O
1	int
;	O
++	O
i	int
)	O
{	O
sum_probs	*(double)
[	O
i	int
]	O
=	O
0	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
char	O
*	O
)	O
new_x	*(void)
+	O
i	int
*	O
element_size	long
,	O
x	double
,	O
element_size	long
)	O
;	O
take_step	*((*(struct(*(struct`),*(void))),*(void),double)->(void))
(	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
,	O
(	O
char	O
*	O
)	O
new_x	*(void)
+	O
i	int
*	O
element_size	long
,	O
params	struct(int,int,double,double,double,double,double)
.	O
step_size	double
)	O
;	O
energies	*(double)
[	O
i	int
]	O
=	O
Ef	*((*(void))->(double))
(	O
(	O
char	O
*	O
)	O
new_x	*(void)
+	O
i	int
*	O
element_size	long
)	O
;	O
probs	*(double)
[	O
i	int
]	O
=	O
boltzmann	(double,double,double,*(struct(int,int,double,double,double,double,double)))->(double)
(	O
Ex	double
,	O
energies	*(double)
[	O
i	int
]	O
,	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
&	O
params	struct(int,int,double,double,double,double,double)
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
char	O
*	O
)	O
new_x	*(void)
+	O
(	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
-	O
1	int
)	O
*	O
element_size	long
,	O
x	double
,	O
element_size	long
)	O
;	O
energies	*(double)
[	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
-	O
1	int
]	O
=	O
Ex	double
;	O
probs	*(double)
[	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
-	O
1	int
]	O
=	O
boltzmann	(double,double,double,*(struct(int,int,double,double,double,double,double)))->(double)
(	O
Ex	double
,	O
energies	*(double)
[	O
i	int
]	O
,	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
,	O
&	O
params	struct(int,int,double,double,double,double,double)
)	O
;	O
sum_probs	*(double)
[	O
0	int
]	O
=	O
probs	*(double)
[	O
0	int
]	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
;	O
++	O
i	int
)	O
{	O
sum_probs	*(double)
[	O
i	int
]	O
=	O
sum_probs	*(double)
[	O
i	int
-	O
1	int
]	O
+	O
probs	*(double)
[	O
i	int
]	O
;	O
}	O
u	double
=	O
gsl_rng_uniform	(*(struct(*(struct(*`,long,long,long,*`,*`,*`)),*(void))))->(double)
(	O
r	*(struct(*(struct(*(char),long,long,long,*((*`,long)->(void)),*((*`)->(long)),*((*`)->(double)))),*(void)))
)	O
*	O
sum_probs	*(double)
[	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
-	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
params	struct(int,int,double,double,double,double,double)
.	O
n_tries	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
u	double
<	O
sum_probs	*(double)
[	O
i	int
]	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
x	double
,	O
(	O
char	O
*	O
)	O
new_x	*(void)
+	O
i	int
*	O
element_size	long
,	O
element_size	long
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
print_position	*((*(void))->(void))
)	O
{	O
printf	(*(char))->(int)
(	O
"%5d\t%12g\t"	*(char)
,	O
n_iter	int
,	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
)	O
;	O
print_position	*((*(void))->(void))
(	O
x	double
)	O
;	O
printf	(*(char))->(int)
(	O
"\t%12g\t%12g\n"	*(char)
,	O
distance	*((*(void),*(void))->(double))
(	O
x	double
,	O
x0_p	*(void)
)	O
,	O
Ex	double
)	O
;	O
}	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
*=	O
T_factor	double
;	O
++	O
n_iter	int
;	O
if	O
(	O
T	*(struct(*(char),long,long,long,*((*(void),long)->(void)),*((*(void))->(long)),*((*(void))->(double))))
<	O
params	struct(int,int,double,double,double,double,double)
.	O
t_min	double
)	O
{	O
break	O
;	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
x0_p	*(void)
,	O
x	double
,	O
element_size	long
)	O
;	O
free	(*(void))->(void)
(	O
x	double
)	O
;	O
free	(*(void))->(void)
(	O
new_x	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
energies	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
probs	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
sum_probs	*(double)
)	O
;	O
}	O
