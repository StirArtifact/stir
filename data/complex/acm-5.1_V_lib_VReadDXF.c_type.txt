char	O
*	O
colors	int
[	O
]	O
=	O
{	O
"black"	*(char)
,	O
"red"	*(char)
,	O
"yellow"	*(char)
,	O
"green"	*(char)
,	O
"cyan"	*(char)
,	O
"blue"	*(char)
,	O
"magenta"	*(char)
,	O
"white"	*(char)
}	O
;	O
extern	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
ScalePolygon	(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double)->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
in	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
VPoint	struct(double,double,double)
*	O
origin	*(struct(double,double,double))
,	O
VPoint	struct(double,double,double)
*	O
scale	int
,	O
VPoint	struct(double,double,double)
*	O
,	O
double	O
)	O
;	O
extern	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
VExtrudeObject	(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))),*(struct(double,double,double)))->(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
obj	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
,	O
VPoint	struct(double,double,double)
*	O
e	*(struct(double,double,double))
)	O
;	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
bobject	array(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short))))
[	O
BOBJECT_MAX	int
]	O
;	O
int	O
btop	int
=	O
0	int
;	O
int	O
lineno	int
=	O
0	int
;	O
enum	O
_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
DXF_NULL	int
,	O
DXF_EOF	int
,	O
DXF_X_COORD	int
,	O
DXF_Y_COORD	int
,	O
DXF_Z_COORD	int
,	O
DXF_X_SCALE	int
,	O
DXF_Y_SCALE	int
,	O
DXF_Z_SCALE	int
,	O
DXF_ROTATE	int
,	O
DXF_SECTION	int
,	O
DXF_ENDSEC	int
,	O
DXF_SEQEND	int
,	O
DXF_TITLE	int
,	O
DXF_POLYLINE	int
,	O
DXF_3DFACE	int
,	O
DXF_ENTITIES	int
,	O
DXF_VERTEX	int
,	O
DXF_BLOCKS	int
,	O
DXF_INSERT	int
,	O
DXF_X_EXTRUDE	int
,	O
DXF_Y_EXTRUDE	int
,	O
DXF_Z_EXTRUDE	int
,	O
DXF_M_COUNT	int
,	O
DXF_N_COUNT	int
,	O
DXF_THIRD_VERTEX	int
,	O
DXF_FOURTH_VERTEX	int
,	O
DXF_FLAGS	int
,	O
DXF_ITEM	int
,	O
DXF_TABLES	int
,	O
DXF_TABLE	int
,	O
DXF_ENDTAB	int
,	O
DXF_LAYER	int
,	O
DXF_STYLE	int
,	O
DXF_LTYPE	int
,	O
DXF_ATTDEF	int
,	O
DXF_ATTRIB	int
,	O
DXF_DICTIONARY	int
,	O
DXF_MLINESTYLE	int
,	O
DXF_ACAD_GROUP	int
,	O
DXF_ACAD_MLINESTYLE	int
,	O
DXF_APPID	int
,	O
DXF_BLOCK	int
,	O
DXF_ENDBLK	int
,	O
DXF_VPORT	int
,	O
DXF_VIEW	int
,	O
DXF_COLOR_INDEX	int
}	O
;	O
typedef	O
enum	O
_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
typedef	O
struct	O
{	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
char	O
*	O
name	*(char)
;	O
}	O
token_table	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
;	O
token_table	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
a	*(struct(double,double,double))
[	O
]	O
=	O
{	O
{	O
DXF_SECTION	int
,	O
"SECTION"	*(char)
}	O
,	O
{	O
DXF_ENDSEC	int
,	O
"ENDSEC"	*(char)
}	O
,	O
{	O
DXF_POLYLINE	int
,	O
"POLYLINE"	*(char)
}	O
,	O
{	O
DXF_3DFACE	int
,	O
"3DFACE"	*(char)
}	O
,	O
{	O
DXF_VERTEX	int
,	O
"VERTEX"	*(char)
}	O
,	O
{	O
DXF_SEQEND	int
,	O
"SEQEND"	*(char)
}	O
,	O
{	O
DXF_EOF	int
,	O
"EOF"	*(char)
}	O
,	O
{	O
DXF_BLOCK	int
,	O
"BLOCK"	*(char)
}	O
,	O
{	O
DXF_ENDBLK	int
,	O
"ENDBLK"	*(char)
}	O
,	O
{	O
DXF_INSERT	int
,	O
"INSERT"	*(char)
}	O
,	O
{	O
DXF_TABLE	int
,	O
"TABLE"	*(char)
}	O
,	O
{	O
DXF_ENDTAB	int
,	O
"ENDTAB"	*(char)
}	O
,	O
{	O
DXF_LAYER	int
,	O
"LAYER"	*(char)
}	O
,	O
{	O
DXF_STYLE	int
,	O
"STYLE"	*(char)
}	O
,	O
{	O
DXF_LTYPE	int
,	O
"LTYPE"	*(char)
}	O
,	O
{	O
DXF_VPORT	int
,	O
"VPORT"	*(char)
}	O
,	O
{	O
DXF_DICTIONARY	int
,	O
"DICTIONARY"	*(char)
}	O
,	O
{	O
DXF_MLINESTYLE	int
,	O
"MLINESTYLE"	*(char)
}	O
,	O
{	O
DXF_APPID	int
,	O
"APPID"	*(char)
}	O
,	O
{	O
DXF_ACAD_GROUP	int
,	O
"ACAD_GROUP"	*(char)
}	O
,	O
{	O
DXF_ACAD_MLINESTYLE	int
,	O
"ACAD_MLINESTYLE"	*(char)
}	O
,	O
{	O
DXF_ATTDEF	int
,	O
"ATTDEF"	*(char)
}	O
,	O
{	O
DXF_ATTRIB	int
,	O
"ATTRIB"	*(char)
}	O
,	O
{	O
DXF_EOF	int
,	O
NULL	O
}	O
}	O
;	O
static	O
int	O
int_value	int
;	O
static	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
ReadToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
FILE	struct
*	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
double	O
*	O
fp_value	*(double)
,	O
char	O
*	O
cp_value	*(char)
,	O
int	O
*	O
code	*(int)
,	O
char	O
*	O
string	union(*(char),*(int))
)	O
{	O
long	O
i	long
;	O
int	O
len	int
;	O
token_table	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
char	O
buf1	array(char)
[	O
512	int
]	O
,	O
buf2	array(char)
[	O
512	int
]	O
,	O
*	O
r1	*(char)
,	O
*	O
r2	*(char)
;	O
r1	*(char)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf1	array(char)
,	O
sizeof	O
(	O
buf1	array(char)
)	O
,	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
)	O
;	O
r2	*(char)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
)	O
;	O
lineno	int
+=	O
2	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf1	array(char)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
buf1	array(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
len	int
>=	O
2	int
&&	O
buf1	array(char)
[	O
len	int
-	O
2	int
]	O
==	O
'\r'	O
)	O
{	O
buf1	array(char)
[	O
len	int
-	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf2	array(char)
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
buf2	array(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
len	int
>=	O
2	int
&&	O
buf2	array(char)
[	O
len	int
-	O
2	int
]	O
==	O
'\r'	O
)	O
{	O
buf2	array(char)
[	O
len	int
-	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp_value	*(char)
,	O
buf2	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string	union(*(char),*(int))
,	O
buf2	array(char)
)	O
;	O
if	O
(	O
r1	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
&&	O
r2	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
i	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf1	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
*	O
code	*(int)
=	O
i	long
;	O
if	O
(	O
i	long
==	O
0	int
)	O
{	O
for	O
(	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
a	*(struct(double,double,double))
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
name	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
++	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
{	O
if	O
(	O
COMPARE	O
(	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
name	*(char)
,	O
buf2	array(char)
)	O
==	O
0	int
)	O
{	O
return	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"Warning: unrecognized directive, \"%s\"\n"	*(char)
,	O
buf2	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
i	long
==	O
2	int
)	O
{	O
if	O
(	O
COMPARE	O
(	O
"ENTITIES"	*(char)
,	O
buf2	array(char)
)	O
==	O
0	int
)	O
{	O
return	O
DXF_ENTITIES	int
;	O
}	O
else	O
if	O
(	O
COMPARE	O
(	O
"BLOCKS"	*(char)
,	O
buf2	array(char)
)	O
==	O
0	int
)	O
{	O
return	O
DXF_BLOCKS	int
;	O
}	O
else	O
if	O
(	O
COMPARE	O
(	O
"TABLES"	*(char)
,	O
buf2	array(char)
)	O
==	O
0	int
)	O
{	O
return	O
DXF_TABLES	int
;	O
}	O
else	O
{	O
return	O
DXF_TITLE	int
;	O
}	O
}	O
else	O
if	O
(	O
i	long
>=	O
10	int
&&	O
i	long
<=	O
19	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_X_COORD	int
;	O
}	O
else	O
if	O
(	O
i	long
>=	O
20	int
&&	O
i	long
<=	O
29	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Y_COORD	int
;	O
}	O
else	O
if	O
(	O
i	long
>=	O
30	int
&&	O
i	long
<=	O
39	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Z_COORD	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
41	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_X_SCALE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
42	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Y_SCALE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
43	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Z_SCALE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
50	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_ROTATE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
62	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_COLOR_INDEX	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
70	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_FLAGS	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
71	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_M_COUNT	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
72	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_N_COUNT	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
73	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_THIRD_VERTEX	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
74	int
)	O
{	O
int_value	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
DXF_FOURTH_VERTEX	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
210	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_X_EXTRUDE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
220	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Y_EXTRUDE	int
;	O
}	O
else	O
if	O
(	O
i	long
==	O
230	int
)	O
{	O
*	O
fp_value	*(double)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
buf2	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
return	O
DXF_Z_EXTRUDE	int
;	O
}	O
else	O
{	O
return	O
DXF_ITEM	int
;	O
}	O
}	O
return	O
DXF_EOF	int
;	O
}	O
static	O
int	O
lookahead_valid	int
=	O
0	int
;	O
static	O
double	O
fp_la	double
;	O
static	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
token_id_la	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
static	O
char	O
cp_la	array(char)
[	O
256	int
]	O
,	O
string_la	array(char)
[	O
256	int
]	O
;	O
static	O
int	O
code_la	int
;	O
static	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
NextToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
FILE	struct
*	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
double	O
*	O
fp_value	*(double)
,	O
char	O
*	O
cp_value	*(char)
,	O
int	O
*	O
code	*(int)
,	O
char	O
*	O
string	union(*(char),*(int))
)	O
{	O
if	O
(	O
lookahead_valid	int
)	O
{	O
lookahead_valid	int
=	O
0	int
;	O
*	O
fp_value	*(double)
=	O
fp_la	double
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp_value	*(char)
,	O
cp_la	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string	union(*(char),*(int))
,	O
string_la	array(char)
)	O
;	O
*	O
code	*(int)
=	O
code_la	int
;	O
return	O
token_id_la	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
}	O
else	O
{	O
return	O
ReadToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
fp_value	*(double)
,	O
cp_value	*(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
}	O
}	O
static	O
void	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
double	O
fp_value	*(double)
,	O
char	O
*	O
cp_value	*(char)
,	O
int	O
code	*(int)
,	O
char	O
*	O
string	union(*(char),*(int))
)	O
{	O
lookahead_valid	int
=	O
1	int
;	O
fp_la	double
=	O
fp_value	*(double)
;	O
token_id_la	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp_la	array(char)
,	O
cp_value	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
string_la	array(char)
,	O
string	union(*(char),*(int))
)	O
;	O
code_la	int
=	O
code	*(int)
;	O
}	O
static	O
void	O
InsertBlock	(*(char),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(int))->(void)
(	O
char	O
*	O
name	*(char)
,	O
VPoint	struct(double,double,double)
*	O
o	*(struct(double,double,double))
,	O
VPoint	struct(double,double,double)
*	O
scale	int
,	O
VPoint	struct(double,double,double)
*	O
extrude	*(struct(double,double,double))
,	O
double	O
r	*(struct(double,double,double))
,	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
*	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
int	O
*	O
ptop	*(int)
)	O
{	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
int	O
i	long
,	O
j	int
,	O
extrusion	int
=	O
0	int
;	O
PDEBUG	O
(	O
(	O
"looking for \"%s\"; offset %g, %g, %g; scale %g, %g, %g; extrude %g, %g, %g; rotate %g\n"	*(char)
,	O
name	*(char)
,	O
o	*(struct(double,double,double))
->	O
x	double
,	O
o	*(struct(double,double,double))
->	O
y	double
,	O
o	*(struct(double,double,double))
->	O
z	double
,	O
scale	int
->	O
x	double
,	O
scale	int
->	O
y	double
,	O
scale	int
->	O
z	double
,	O
extrude	*(struct(double,double,double))
->	O
x	double
,	O
extrude	*(struct(double,double,double))
->	O
y	double
,	O
extrude	*(struct(double,double,double))
->	O
z	double
,	O
r	*(struct(double,double,double))
)	O
)	O
;	O
for	O
(	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
bobject	array(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short))))
,	O
i	long
=	O
0	int
;	O
i	long
<	O
btop	int
;	O
++	O
i	long
,	O
++	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
PDEBUG	O
(	O
(	O
"adding %d polygons to %d existing\n"	*(char)
,	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
numPolys	int
,	O
(	O
*	O
ptop	*(int)
)	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
numPolys	int
;	O
++	O
j	int
)	O
{	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
(	O
*	O
ptop	*(int)
)	O
++	O
]	O
=	O
ScalePolygon	(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double)->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
j	int
]	O
,	O
o	*(struct(double,double,double))
,	O
scale	int
,	O
extrude	*(struct(double,double,double))
,	O
r	*(struct(double,double,double))
)	O
;	O
}	O
if	O
(	O
extrusion	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
numPolys	int
;	O
++	O
j	int
)	O
{	O
VDestroyPolygon	O
(	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
j	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
(	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
)	O
)	O
;	O
}	O
}	O
return	O
;	O
}	O
}	O
}	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
VReadDXFObject	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))
(	O
FILE	struct
*	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
)	O
{	O
return	O
VReadDepthCueuedObject	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))
(	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
0	int
)	O
;	O
}	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
VReadDepthCueuedDXFObject	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))
(	O
FILE	struct
*	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
int	O
flag	int
)	O
{	O
double	O
value	*(char)
,	O
rotate	double
=	O
0	int
;	O
dxf_token_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
saved_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
DXF_NULL	int
;	O
int	O
i	long
,	O
j	int
,	O
m0	int
=	O
0	int
,	O
n0	int
=	O
0	int
,	O
vertices_listed_by_index	int
=	O
0	int
;	O
VPoint	struct(double,double,double)
temp	array(struct(double,double,double))
[	O
POINT_MAX	int
]	O
,	O
temp1	array(struct(double,double,double))
[	O
4	int
]	O
,	O
*	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
scale	int
,	O
pt	*(struct(double,double,double))
,	O
bpt	struct(double,double,double)
,	O
extrude	*(struct(double,double,double))
;	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
;	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
;	O
int	O
top	int
=	O
0	int
;	O
int	O
state	int
=	O
STATE_NORMAL	int
,	O
submode	int
=	O
0	int
;	O
char	O
cp	array(char)
[	O
256	int
]	O
,	O
title	array(char)
[	O
256	int
]	O
,	O
insert_title	array(char)
[	O
256	int
]	O
,	O
*	O
stop_block	*(char)
=	O
"<none>"	*(char)
;	O
int	O
order	*(short)
=	O
0	int
;	O
int	O
indices	array(int)
[	O
4	int
]	O
,	O
num_indices	int
=	O
0	int
;	O
VMatrix	struct(array(array(double)))
m	array(array(double))
;	O
int	O
code	*(int)
,	O
polymode	int
;	O
char	O
string	union(*(char),*(int))
[	O
256	int
]	O
;	O
VColor	struct(*(char),short,short,*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
*	O
blackColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
VAllocColor	(*(char))->(*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
(	O
"black"	*(char)
)	O
;	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
POLY_MAX	O
]	O
;	O
int	O
ptop	*(int)
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
,	O
0	int
,	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
)	O
;	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
blackColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
;	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
order	*(short)
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
;	O
}	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
flags	short
=	O
0	int
;	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
assignedDepth	short
=	O
-	O
1	int
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
top	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
&	O
value	*(char)
,	O
cp	array(char)
,	O
&	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
switch	O
(	O
state	int
)	O
{	O
case	O
STATE_NORMAL	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_ENTITIES	int
:	O
submode	int
=	O
0	int
;	O
state	int
=	O
STATE_ENTITIES	int
;	O
break	O
;	O
case	O
DXF_BLOCKS	int
:	O
submode	int
=	O
1	int
;	O
state	int
=	O
STATE_ENTITIES	int
;	O
break	O
;	O
case	O
DXF_TABLES	int
:	O
state	int
=	O
STATE_TABLES	int
;	O
break	O
;	O
case	O
DXF_EOF	int
:	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
=	O
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
sizeof	O
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
,	O
0	int
,	O
sizeof	O
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
)	O
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"name"	*(char)
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
numPolys	int
=	O
ptop	*(int)
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
=	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
ptop	*(int)
*	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
,	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
ptop	*(int)
*	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
)	O
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
order	*(short)
=	O
(	O
unsigned	O
short	O
*	O
)	O
NULL	O
;	O
VComputeObjectExtent	(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))->(void)
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
)	O
;	O
if	O
(	O
VObjectNeedsOrdering	(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))->(int)
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
)	O
)	O
{	O
VComputePolygonOrdering	(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct`)),*(short))))->(void)
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
)	O
;	O
}	O
VIdentMatrix	(*(struct(array(array(double)))))->(void)
(	O
&	O
m	array(array(double))
)	O
;	O
m	array(array(double))
.	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
-	O
1.0	int
;	O
m	array(array(double))
.	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
-	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
numPolys	int
;	O
++	O
i	long
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
numVtces	short
;	O
++	O
j	int
)	O
{	O
VTransform_	(*(struct(double,double,double)),*(struct(array(array(double)))),*(struct(double,double,double)))->(void)
(	O
&	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
,	O
&	O
m	array(array(double))
,	O
&	O
pt	*(struct(double,double,double))
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
=	O
pt	*(struct(double,double,double))
;	O
}	O
}	O
return	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_TABLES	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_ENDSEC	int
:	O
state	int
=	O
STATE_NORMAL	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_ENTITIES	int
:	O
if	O
(	O
code	*(int)
==	O
0	int
)	O
{	O
saved_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
DXF_NULL	int
;	O
}	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_ATTDEF	int
:	O
case	O
DXF_ATTRIB	int
:	O
saved_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
state	int
=	O
STATE_GENERAL_ENTITY	int
;	O
break	O
;	O
case	O
DXF_POLYLINE	int
:	O
state	int
=	O
STATE_POLYLINE	int
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
0	int
]	O
;	O
top	int
=	O
0	int
;	O
m0	int
=	O
n0	int
=	O
0	int
;	O
vertices_listed_by_index	int
=	O
num_indices	int
=	O
0	int
;	O
polymode	int
=	O
0	int
;	O
break	O
;	O
case	O
DXF_3DFACE	int
:	O
state	int
=	O
STATE_3DFACE	int
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
0	int
]	O
;	O
top	int
=	O
0	int
;	O
break	O
;	O
case	O
DXF_BLOCK	int
:	O
state	int
=	O
STATE_BLOCK	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
title	array(char)
,	O
"*none*"	*(char)
)	O
;	O
bpt	struct(double,double,double)
.	O
x	double
=	O
bpt	struct(double,double,double)
.	O
y	double
=	O
bpt	struct(double,double,double)
.	O
z	double
=	O
0.0	int
;	O
break	O
;	O
case	O
DXF_ENDBLK	int
:	O
state	int
=	O
STATE_BLOCK	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
break	O
;	O
case	O
DXF_INSERT	int
:	O
pt	*(struct(double,double,double))
.	O
x	double
=	O
pt	*(struct(double,double,double))
.	O
y	double
=	O
pt	*(struct(double,double,double))
.	O
z	double
=	O
0.0	int
;	O
scale	int
.	O
x	double
=	O
1.0	int
;	O
scale	int
.	O
y	double
=	O
1.0	int
;	O
scale	int
.	O
z	double
=	O
1.0	int
;	O
rotate	double
=	O
0.0	int
;	O
extrude	*(struct(double,double,double))
=	O
pt	*(struct(double,double,double))
;	O
extrude	*(struct(double,double,double))
.	O
z	double
=	O
1.0	int
;	O
state	int
=	O
STATE_INSERT	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
insert_title	array(char)
,	O
"*not-specified*"	*(char)
)	O
;	O
break	O
;	O
case	O
DXF_ENDSEC	int
:	O
state	int
=	O
STATE_NORMAL	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
code	*(int)
!=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"hmm, %d \"%s\"\n"	*(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
}	O
else	O
{	O
saved_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
state	int
=	O
STATE_GENERAL_ENTITY	int
;	O
}	O
break	O
;	O
case	O
DXF_EOF	int
:	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_POLYLINE	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_COLOR_INDEX	int
:	O
if	O
(	O
int_value	int
<	O
8	int
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
VAllocColor	(*(char))->(*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
(	O
colors	int
[	O
i	long
]	O
)	O
;	O
if	O
(	O
order	*(short)
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"color index %d\n"	*(char)
,	O
int_value	int
)	O
;	O
}	O
break	O
;	O
case	O
DXF_SEQEND	int
:	O
if	O
(	O
vertices_listed_by_index	int
==	O
0	int
)	O
{	O
if	O
(	O
m0	int
!=	O
0	int
||	O
n0	int
!=	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
m0	int
;	O
++	O
i	long
)	O
{	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
n0	int
;	O
++	O
j	int
)	O
{	O
temp1	array(struct(double,double,double))
[	O
0	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
-	O
1	int
)	O
*	O
n0	int
+	O
j	int
-	O
1	int
]	O
;	O
temp1	array(struct(double,double,double))
[	O
1	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
)	O
*	O
n0	int
+	O
j	int
-	O
1	int
]	O
;	O
temp1	array(struct(double,double,double))
[	O
2	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
)	O
*	O
n0	int
+	O
j	int
]	O
;	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
3	int
,	O
temp1	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
temp1	array(struct(double,double,double))
[	O
0	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
)	O
*	O
n0	int
+	O
j	int
]	O
;	O
temp1	array(struct(double,double,double))
[	O
1	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
-	O
1	int
)	O
*	O
n0	int
+	O
j	int
]	O
;	O
temp1	array(struct(double,double,double))
[	O
2	int
]	O
=	O
temp	array(struct(double,double,double))
[	O
(	O
i	long
-	O
1	int
)	O
*	O
n0	int
+	O
j	int
-	O
1	int
]	O
;	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
3	int
,	O
temp1	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
}	O
}	O
PDEBUG	O
(	O
(	O
"mesh %d x %d\n"	*(char)
,	O
m0	int
,	O
n0	int
)	O
)	O
;	O
}	O
else	O
{	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
top	int
,	O
temp	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
}	O
}	O
PDEBUG	O
(	O
(	O
"added POLYLINE polygon number %d\n"	*(char)
,	O
ptop	*(int)
-	O
1	int
)	O
)	O
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
0	int
]	O
;	O
top	int
=	O
0	int
;	O
state	int
=	O
STATE_ENTITIES	int
;	O
break	O
;	O
case	O
DXF_FLAGS	int
:	O
if	O
(	O
(	O
int_value	int
&	O
2	int
)	O
||	O
(	O
int_value	int
&	O
4	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: POLYLINE splines or curves not supported by Vlib (line %d).\n"	*(char)
,	O
lineno	int
)	O
;	O
}	O
if	O
(	O
int_value	int
&	O
64	int
)	O
{	O
polymode	int
=	O
2	int
;	O
}	O
else	O
if	O
(	O
int_value	int
&	O
16	int
)	O
{	O
polymode	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
DXF_VERTEX	int
:	O
state	int
=	O
STATE_VERTEX	int
;	O
break	O
;	O
case	O
DXF_M_COUNT	int
:	O
m0	int
=	O
int_value	int
;	O
break	O
;	O
case	O
DXF_N_COUNT	int
:	O
n0	int
=	O
int_value	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_3DFACE	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_COLOR_INDEX	int
:	O
if	O
(	O
int_value	int
<	O
8	int
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
VAllocColor	(*(char))->(*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
(	O
colors	int
[	O
int_value	int
]	O
)	O
;	O
if	O
(	O
order	*(short)
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"color index %d\n"	*(char)
,	O
int_value	int
)	O
;	O
}	O
break	O
;	O
case	O
DXF_ENDBLK	int
:	O
state	int
=	O
STATE_BLOCK	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
top	int
,	O
temp	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
0	int
]	O
;	O
top	int
=	O
0	int
;	O
break	O
;	O
case	O
DXF_X_COORD	int
:	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
x	double
=	O
value	*(char)
;	O
if	O
(	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
&	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
y	double
,	O
cp	array(char)
,	O
&	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
)	O
!=	O
DXF_Y_COORD	int
)	O
{	O
printf	(*(char))->(int)
(	O
"syntax error4 %d\n"	*(char)
,	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
if	O
(	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(double),*(char),*(int),*(char))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
f	struct(*((*(struct),*(struct(*`,long,int,long,long,long,int,int)),int,int,int,*(char),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int)->(long)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,long)->(int)),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),int,int,int,int)->(*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)))),*((*(struct(int,int,int,int,*`,int,int,int,int,int,int,int,long,long,long,*`,struct`)),long)->(int)))
,	O
&	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
z	double
,	O
cp	array(char)
,	O
&	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
)	O
!=	O
DXF_Z_COORD	int
)	O
{	O
printf	(*(char))->(int)
(	O
"syntax error5 %d\n"	*(char)
,	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
++	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
++	O
top	int
;	O
if	O
(	O
top	int
==	O
POINT_MAX	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Point overflow, increase POINT_MAX.\n"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
DXF_3DFACE	int
:	O
case	O
DXF_POLYLINE	int
:	O
case	O
DXF_ENDSEC	int
:	O
default	O
:	O
if	O
(	O
code	*(int)
==	O
0	int
)	O
{	O
if	O
(	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
1	int
]	O
.	O
x	double
==	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
2	int
]	O
.	O
x	double
&&	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
1	int
]	O
.	O
y	double
==	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
2	int
]	O
.	O
y	double
&&	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
1	int
]	O
.	O
z	double
==	O
temp	array(struct(double,double,double))
[	O
top	int
-	O
2	int
]	O
.	O
z	double
)	O
{	O
--	O
top	int
;	O
}	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
top	int
,	O
temp	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
=	O
&	O
temp	array(struct(double,double,double))
[	O
0	int
]	O
;	O
top	int
=	O
0	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
state	int
=	O
STATE_ENTITIES	int
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_VERTEX	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_COLOR_INDEX	int
:	O
if	O
(	O
int_value	int
<	O
8	int
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
VAllocColor	(*(char))->(*(struct(*(char),short,short,*(struct(*`,short,short,*`)))))
(	O
colors	int
[	O
i	long
]	O
)	O
;	O
if	O
(	O
order	*(short)
)	O
{	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
backColor	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
=	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
.	O
color	*(struct(*(char),short,short,*(struct(*(char),short,short,*(struct`)))))
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"color index %d\n"	*(char)
,	O
int_value	int
)	O
;	O
}	O
break	O
;	O
case	O
DXF_X_COORD	int
:	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
x	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Y_COORD	int
:	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
y	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Z_COORD	int
:	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
->	O
z	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_M_COUNT	int
:	O
vertices_listed_by_index	int
=	O
1	int
;	O
if	O
(	O
int_value	int
<	O
0	int
)	O
{	O
int_value	int
=	O
-	O
int_value	int
;	O
}	O
indices	array(int)
[	O
0	int
]	O
=	O
int_value	int
-	O
1	int
;	O
num_indices	int
=	O
1	int
;	O
break	O
;	O
case	O
DXF_N_COUNT	int
:	O
vertices_listed_by_index	int
=	O
1	int
;	O
if	O
(	O
int_value	int
<	O
0	int
)	O
{	O
int_value	int
=	O
-	O
int_value	int
;	O
}	O
indices	array(int)
[	O
1	int
]	O
=	O
int_value	int
-	O
1	int
;	O
num_indices	int
=	O
2	int
;	O
break	O
;	O
case	O
DXF_THIRD_VERTEX	int
:	O
vertices_listed_by_index	int
=	O
1	int
;	O
if	O
(	O
int_value	int
<	O
0	int
)	O
{	O
int_value	int
=	O
-	O
int_value	int
;	O
}	O
indices	array(int)
[	O
2	int
]	O
=	O
int_value	int
-	O
1	int
;	O
num_indices	int
=	O
3	int
;	O
break	O
;	O
case	O
DXF_FOURTH_VERTEX	int
:	O
vertices_listed_by_index	int
=	O
1	int
;	O
if	O
(	O
int_value	int
<	O
0	int
)	O
{	O
int_value	int
=	O
-	O
int_value	int
;	O
}	O
indices	array(int)
[	O
3	int
]	O
=	O
int_value	int
-	O
1	int
;	O
num_indices	int
=	O
4	int
;	O
break	O
;	O
case	O
DXF_SEQEND	int
:	O
case	O
DXF_VERTEX	int
:	O
if	O
(	O
vertices_listed_by_index	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_indices	int
;	O
++	O
i	long
)	O
{	O
if	O
(	O
indices	array(int)
[	O
i	long
]	O
>=	O
top	int
)	O
{	O
printf	(*(char))->(int)
(	O
"internal error polygon vertex out of range: %d (max %d) -- %d\n"	*(char)
,	O
indices	array(int)
[	O
i	long
]	O
,	O
top	int
,	O
i	long
)	O
;	O
}	O
temp1	array(struct(double,double,double))
[	O
i	long
]	O
=	O
temp	array(struct(double,double,double))
[	O
indices	array(int)
[	O
i	long
]	O
]	O
;	O
}	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
[	O
ptop	*(int)
++	O
]	O
=	O
VCreatePolygonFromTemplate	(int,*(struct(double,double,double)),*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))->(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
(	O
num_indices	int
,	O
temp1	array(struct(double,double,double))
,	O
&	O
template	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
)	O
;	O
}	O
else	O
{	O
++	O
p	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
;	O
++	O
top	int
;	O
if	O
(	O
top	int
==	O
POINT_MAX	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Point overflow, increase POINT_MAX.\n"	*(char)
)	O
;	O
}	O
}	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
state	int
=	O
STATE_POLYLINE	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_INSERT	int
:	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
break	O
;	O
case	O
DXF_ENDBLK	int
:	O
state	int
=	O
STATE_BLOCK	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
InsertBlock	(*(char),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(int))->(void)
(	O
insert_title	array(char)
,	O
&	O
pt	*(struct(double,double,double))
,	O
&	O
scale	int
,	O
&	O
extrude	*(struct(double,double,double))
,	O
rotate	double
,	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
&	O
ptop	*(int)
)	O
;	O
break	O
;	O
case	O
DXF_TITLE	int
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
insert_title	array(char)
,	O
cp	array(char)
)	O
;	O
break	O
;	O
case	O
DXF_X_COORD	int
:	O
pt	*(struct(double,double,double))
.	O
x	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Y_COORD	int
:	O
pt	*(struct(double,double,double))
.	O
y	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Z_COORD	int
:	O
pt	*(struct(double,double,double))
.	O
z	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_X_SCALE	int
:	O
scale	int
.	O
x	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Y_SCALE	int
:	O
scale	int
.	O
y	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Z_SCALE	int
:	O
scale	int
.	O
z	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_ROTATE	int
:	O
rotate	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_X_EXTRUDE	int
:	O
extrude	*(struct(double,double,double))
.	O
x	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Y_EXTRUDE	int
:	O
extrude	*(struct(double,double,double))
.	O
y	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Z_EXTRUDE	int
:	O
extrude	*(struct(double,double,double))
.	O
z	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_INSERT	int
:	O
case	O
DXF_POLYLINE	int
:	O
case	O
DXF_3DFACE	int
:	O
case	O
DXF_ENDSEC	int
:	O
default	O
:	O
if	O
(	O
code	*(int)
==	O
0	int
)	O
{	O
state	int
=	O
STATE_ENTITIES	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
InsertBlock	(*(char),*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)),double,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(int))->(void)
(	O
insert_title	array(char)
,	O
&	O
pt	*(struct(double,double,double))
,	O
&	O
scale	int
,	O
&	O
extrude	*(struct(double,double,double))
,	O
rotate	double
,	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
&	O
ptop	*(int)
)	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
STATE_GENERAL_ENTITY	int
:	O
if	O
(	O
code	*(int)
==	O
0	int
)	O
{	O
state	int
=	O
STATE_ENTITIES	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
}	O
break	O
;	O
case	O
STATE_BLOCK	int
:	O
PDEBUG	O
(	O
(	O
"BLOCK: %s\n"	*(char)
,	O
string	union(*(char),*(int))
)	O
)	O
;	O
switch	O
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
DXF_ENDBLK	int
:	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
=	O
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
sizeof	O
(	O
VObject	struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct(double,double,double),*(struct`),*(struct`),*(struct`),double))),*(short))
)	O
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
name	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
title	array(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
name	*(char)
,	O
title	array(char)
)	O
;	O
PDEBUG	O
(	O
(	O
"added block \"%s\" %d polygons (line %d)\n"	*(char)
,	O
title	array(char)
,	O
ptop	*(int)
,	O
lineno	int
)	O
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
numPolys	int
=	O
ptop	*(int)
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
=	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
*	O
)	O
Vmalloc	(int)->(*(char))
(	O
ptop	*(int)
*	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
char	O
*	O
)	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
,	O
(	O
char	O
*	O
)	O
poly	*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct`))),*(struct(*(char),short,short,*(struct`))),double))
,	O
ptop	*(int)
*	O
sizeof	O
(	O
VPolygon	struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),*(struct(*(char),short,short,*(struct(*`,short,short,*`)))),double)
*	O
)	O
)	O
;	O
ptop	*(int)
=	O
0	int
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
order	*(short)
=	O
(	O
unsigned	O
short	O
*	O
)	O
NULL	O
;	O
PDEBUG	O
(	O
(	O
"Block offset %f, %f, %f\n"	*(char)
,	O
bpt	struct(double,double,double)
.	O
x	double
,	O
bpt	struct(double,double,double)
.	O
y	double
,	O
bpt	struct(double,double,double)
.	O
z	double
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
numPolys	int
;	O
++	O
i	long
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
numVtces	short
;	O
++	O
j	int
)	O
{	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
.	O
x	double
+=	O
bpt	struct(double,double,double)
.	O
x	double
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
.	O
y	double
+=	O
bpt	struct(double,double,double)
.	O
y	double
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
.	O
z	double
+=	O
bpt	struct(double,double,double)
.	O
z	double
;	O
}	O
}	O
bobject	array(*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short))))
[	O
btop	int
++	O
]	O
=	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
;	O
state	int
=	O
STATE_ENTITIES	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
stop_block	*(char)
,	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
VIdentMatrix	(*(struct(array(array(double)))))->(void)
(	O
&	O
m	array(array(double))
)	O
;	O
m	array(array(double))
.	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
-	O
1.0	int
;	O
m	array(array(double))
.	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
-	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
numPolys	int
;	O
++	O
i	long
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
numVtces	short
;	O
++	O
j	int
)	O
{	O
VTransform	(*(struct(double,double,double)),*(struct(array(array(double)))),*(struct(double,double,double)))->(void)
(	O
&	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
,	O
&	O
m	array(array(double))
,	O
&	O
pt	*(struct(double,double,double))
)	O
;	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
->	O
polygon	*(*(struct(short,short,short,struct(double,double,double),*(struct(double,double,double)),*(struct(*`,short,short,*`)),*(struct(*`,short,short,*`)),double)))
[	O
i	long
]	O
->	O
vertex	*(struct(double,double,double))
[	O
j	int
]	O
=	O
pt	*(struct(double,double,double))
;	O
}	O
}	O
return	O
object	*(struct(*(char),struct(double,double,double),struct(double,double,double),struct(double,double,double),struct(double,double,double),double,int,*(*(struct(short,short,short,struct`,*`,*`,*`,double))),*(short)))
;	O
}	O
break	O
;	O
case	O
DXF_TITLE	int
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
title	array(char)
,	O
cp	array(char)
)	O
;	O
break	O
;	O
case	O
DXF_X_COORD	int
:	O
bpt	struct(double,double,double)
.	O
x	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Y_COORD	int
:	O
bpt	struct(double,double,double)
.	O
y	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_Z_COORD	int
:	O
bpt	struct(double,double,double)
.	O
z	double
=	O
value	*(char)
;	O
break	O
;	O
case	O
DXF_POLYLINE	int
:	O
case	O
DXF_3DFACE	int
:	O
case	O
DXF_INSERT	int
:	O
default	O
:	O
if	O
(	O
code	*(int)
==	O
0	int
)	O
{	O
state	int
=	O
STATE_ENTITIES	int
;	O
PushToken	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),double,*(char),int,*(char))->(void)
(	O
id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	*(char)
,	O
cp	array(char)
,	O
code	*(int)
,	O
string	union(*(char),*(int))
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
ArbitraryAxis	(*(struct(double,double,double)),*(struct(array(array(double)))))->(void)
(	O
VPoint	struct(double,double,double)
*	O
normal	struct(double,double,double)
,	O
VMatrix	struct(array(array(double)))
*	O
out	*(struct(array(array(double))))
)	O
{	O
double	O
minval	double
=	O
1.0	int
/	O
64.0	int
,	O
d	long
;	O
VPoint	struct(double,double,double)
Ax	struct(double,double,double)
,	O
Ay	struct(double,double,double)
,	O
Az	struct(double,double,double)
;	O
d	long
=	O
sqrt	(double)->(double)
(	O
normal	struct(double,double,double)
->	O
x	double
*	O
normal	struct(double,double,double)
->	O
x	double
+	O
normal	struct(double,double,double)
->	O
y	double
*	O
normal	struct(double,double,double)
->	O
y	double
+	O
normal	struct(double,double,double)
->	O
z	double
*	O
normal	struct(double,double,double)
->	O
z	double
)	O
;	O
Az	struct(double,double,double)
.	O
x	double
=	O
normal	struct(double,double,double)
->	O
x	double
/	O
d	long
;	O
Az	struct(double,double,double)
.	O
y	double
=	O
normal	struct(double,double,double)
->	O
y	double
/	O
d	long
;	O
Az	struct(double,double,double)
.	O
z	double
=	O
normal	struct(double,double,double)
->	O
z	double
/	O
d	long
;	O
if	O
(	O
fabs	(double)->(double)
(	O
Az	struct(double,double,double)
.	O
x	double
)	O
<	O
minval	double
&&	O
fabs	(double)->(double)
(	O
Az	struct(double,double,double)
.	O
y	double
)	O
<	O
minval	double
)	O
{	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
_VUnitVectorJ	struct(double,double,double)
,	O
&	O
Az	struct(double,double,double)
,	O
&	O
Ax	struct(double,double,double)
)	O
;	O
}	O
else	O
{	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
_VUnitVectorK	struct(double,double,double)
,	O
&	O
Az	struct(double,double,double)
,	O
&	O
Ax	struct(double,double,double)
)	O
;	O
}	O
VCrossProd	(*(struct(double,double,double)),*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
&	O
Az	struct(double,double,double)
,	O
&	O
Ax	struct(double,double,double)
,	O
&	O
Ay	struct(double,double,double)
)	O
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
0	int
]	O
=	O
Ax	struct(double,double,double)
.	O
x	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
1	int
]	O
=	O
Ax	struct(double,double,double)
.	O
y	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
2	int
]	O
=	O
Ax	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
0	int
]	O
=	O
Ay	struct(double,double,double)
.	O
x	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
1	int
]	O
=	O
Ay	struct(double,double,double)
.	O
y	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
2	int
]	O
=	O
Ay	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
0	int
]	O
=	O
Az	struct(double,double,double)
.	O
x	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
1	int
]	O
=	O
Az	struct(double,double,double)
.	O
y	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
2	int
]	O
=	O
Az	struct(double,double,double)
.	O
z	double
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
3	int
]	O
[	O
0	int
]	O
=	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
3	int
]	O
[	O
1	int
]	O
=	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
0	int
]	O
[	O
3	int
]	O
=	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
1	int
]	O
[	O
3	int
]	O
=	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
out	*(struct(array(array(double))))
->	O
m	array(array(double))
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
}	O
