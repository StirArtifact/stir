struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
{	O
char	O
segm	array(char)
[	O
METAPH_SEGM_SIZE	int
]	O
;	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
}	O
;	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
{	O
size_t	long
length	long
;	O
size_t	long
nsegm	long
;	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
,	O
*	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
}	O
;	O
static	O
size_t	long
metaph_code_length	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(long)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
)	O
{	O
return	O
code	int
?	O
code	int
->	O
length	long
:	O
0	int
;	O
}	O
static	O
void	O
metaph_code_trim	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),long)->(void)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
code	int
&&	O
code	int
->	O
length	long
>	O
length	long
)	O
code	int
->	O
length	long
=	O
length	long
;	O
}	O
static	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
void	O
)	O
{	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
code	int
)	O
;	O
if	O
(	O
code	int
)	O
{	O
code	int
->	O
length	long
=	O
0	int
;	O
code	int
->	O
nsegm	long
=	O
0	int
;	O
code	int
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
code	int
->	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
NULL	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
metaph_code_alloc_segment	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(*(struct(array(char),*(struct(array(char),*`)))))
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
)	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
)	O
return	O
NULL	O
;	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
,	O
0	int
,	O
METAPH_SEGM_SIZE	int
)	O
;	O
if	O
(	O
code	int
->	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
)	O
code	int
->	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
else	O
code	int
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
code	int
->	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
code	int
->	O
nsegm	long
++	O
;	O
return	O
newseg	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
}	O
static	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
metaph_code_dup	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
src	*(char)
)	O
{	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
dst	*(char)
=	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
)	O
;	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
,	O
*	O
dst_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
if	O
(	O
!	O
dst	*(char)
)	O
return	O
NULL	O
;	O
for	O
(	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
src	*(char)
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
)	O
{	O
dst_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
metaph_code_alloc_segment	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(*(struct(array(char),*(struct(array(char),*`)))))
(	O
dst	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
,	O
src_segm	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
,	O
METAPH_SEGM_SIZE	int
)	O
;	O
}	O
dst	*(char)
->	O
length	long
=	O
src	*(char)
->	O
length	long
;	O
return	O
dst	*(char)
;	O
}	O
static	O
void	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
)	O
{	O
if	O
(	O
code	int
)	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
s	*(char)
=	O
code	int
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
while	O
(	O
s	*(char)
)	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
s	*(char)
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
s	*(char)
=	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
}	O
free	(*(void))->(void)
(	O
code	int
)	O
;	O
}	O
}	O
static	O
int	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
a	*(struct)
,	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
b	*(struct)
)	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
sa	*(struct(array(char),*(struct(array(char),*(struct`)))))
,	O
*	O
sb	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
size_t	long
length	long
;	O
if	O
(	O
a	*(struct)
==	O
NULL	O
||	O
b	*(struct)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
a	*(struct)
->	O
length	long
!=	O
b	*(struct)
->	O
length	long
)	O
return	O
0	int
;	O
length	long
=	O
a	*(struct)
->	O
length	long
;	O
sa	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
a	*(struct)
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
sb	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
b	*(struct)
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
while	O
(	O
length	long
)	O
{	O
size_t	long
segm_length	long
=	O
length	long
<	O
METAPH_SEGM_SIZE	int
?	O
length	long
:	O
METAPH_SEGM_SIZE	int
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
sa	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
,	O
sb	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
,	O
segm_length	long
)	O
)	O
return	O
0	int
;	O
length	long
-=	O
segm_length	long
;	O
sa	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
sa	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
sb	*(struct(array(char),*(struct(array(char),*(struct`)))))
=	O
sb	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
metaph_code_get_buffer	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(*(char)),*(long))->(int)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
,	O
char	O
*	O
*	O
ret_ptr	*(*(char))
,	O
size_t	long
*	O
ret_size	*(long)
)	O
{	O
size_t	long
s	*(char)
=	O
code	int
->	O
nsegm	long
*	O
METAPH_SEGM_SIZE	int
-	O
code	int
->	O
length	long
;	O
if	O
(	O
s	*(char)
==	O
0	int
)	O
{	O
if	O
(	O
!	O
metaph_code_alloc_segment	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(*(struct(array(char),*(struct(array(char),*`)))))
(	O
code	int
)	O
)	O
return	O
-	O
1	int
;	O
s	*(char)
=	O
METAPH_SEGM_SIZE	int
;	O
}	O
*	O
ret_ptr	*(*(char))
=	O
code	int
->	O
segm_tail	*(struct(array(char),*(struct(array(char),*(struct`)))))
->	O
segm	array(char)
+	O
code	int
->	O
length	long
%	O
METAPH_SEGM_SIZE	int
;	O
*	O
ret_size	*(long)
=	O
s	*(char)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
,	O
char	O
const	O
*	O
str	*(struct)
)	O
{	O
if	O
(	O
str	*(struct)
)	O
{	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
str	*(struct)
)	O
;	O
while	O
(	O
length	long
)	O
{	O
char	O
*	O
p	*(char)
;	O
size_t	long
n	long
;	O
if	O
(	O
metaph_code_get_buffer	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(*(char)),*(long))->(int)
(	O
code	int
,	O
&	O
p	*(char)
,	O
&	O
n	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
>	O
length	long
)	O
n	long
=	O
length	long
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
str	*(struct)
,	O
n	long
)	O
;	O
str	*(struct)
+=	O
n	long
;	O
code	int
->	O
length	long
+=	O
n	long
;	O
length	long
-=	O
n	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
metaph_code_dump	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
)	O
{	O
if	O
(	O
!	O
code	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
"NULL"	*(char)
)	O
;	O
else	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
s	*(char)
;	O
size_t	long
length	long
;	O
printf	(*(char))->(int)
(	O
"length = %zu\n"	*(char)
,	O
code	int
->	O
length	long
)	O
;	O
printf	(*(char))->(int)
(	O
"nsegm = %zu\n"	*(char)
,	O
code	int
->	O
nsegm	long
)	O
;	O
length	long
=	O
code	int
->	O
length	long
;	O
for	O
(	O
s	*(char)
=	O
code	int
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
s	*(char)
;	O
s	*(char)
=	O
s	*(char)
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
)	O
{	O
size_t	long
i	long
;	O
putchar	(int)->(int)
(	O
'\''	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
length	long
>	O
0	int
&&	O
i	long
<	O
METAPH_SEGM_SIZE	int
;	O
i	long
++	O
,	O
length	long
--	O
)	O
putchar	(int)->(int)
(	O
s	*(char)
->	O
segm	array(char)
[	O
i	long
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"'\n"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
metaph_code_print	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
)	O
{	O
if	O
(	O
!	O
code	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
"NULL"	*(char)
)	O
;	O
else	O
{	O
struct	O
metaph_segment	struct(array(char),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
s	*(char)
;	O
size_t	long
length	long
;	O
length	long
=	O
code	int
->	O
length	long
;	O
for	O
(	O
s	*(char)
=	O
code	int
->	O
segm_head	*(struct(array(char),*(struct(array(char),*(struct`)))))
;	O
s	*(char)
;	O
s	*(char)
=	O
s	*(char)
->	O
next	*(struct(array(char),*(struct(array(char),*(struct`)))))
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
length	long
>	O
0	int
&&	O
i	long
<	O
METAPH_SEGM_SIZE	int
;	O
i	long
++	O
,	O
length	long
--	O
)	O
putchar	(int)->(int)
(	O
s	*(char)
->	O
segm	array(char)
[	O
i	long
]	O
)	O
;	O
}	O
}	O
}	O
typedef	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
[	O
2	int
]	O
;	O
static	O
int	O
double_metaphone_add	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),*(char),*(char))->(int)
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
code	int
,	O
char	O
const	O
*	O
primary	*(char)
,	O
char	O
const	O
*	O
secondary	*(char)
)	O
{	O
if	O
(	O
secondary	*(char)
)	O
{	O
if	O
(	O
!	O
code	int
[	O
1	int
]	O
)	O
{	O
code	int
[	O
1	int
]	O
=	O
metaph_code_dup	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
code	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
code	int
[	O
1	int
]	O
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
code	int
[	O
1	int
]	O
,	O
secondary	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
code	int
[	O
1	int
]	O
)	O
{	O
if	O
(	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
code	int
[	O
1	int
]	O
,	O
primary	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
}	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
code	int
[	O
0	int
]	O
,	O
primary	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
unsigned	O
const	O
*	O
str	*(struct)
,	O
size_t	long
pos	long
,	O
int	O
off	int
,	O
char	O
const	O
*	O
pat	*(char)
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
off	int
<	O
0	int
&&	O
pos	long
<	O
-	O
off	int
)	O
return	O
0	int
;	O
pos	long
+=	O
off	int
;	O
i	long
=	O
pos	long
;	O
while	O
(	O
*	O
pat	*(char)
)	O
{	O
if	O
(	O
*	O
pat	*(char)
==	O
str	*(struct)
[	O
i	long
]	O
)	O
{	O
++	O
i	long
;	O
++	O
pat	*(char)
;	O
if	O
(	O
!	O
*	O
pat	*(char)
||	O
*	O
pat	*(char)
==	O
'|'	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
*	O
pat	*(char)
&&	O
*	O
pat	*(char)
!=	O
'|'	O
)	O
++	O
pat	*(char)
;	O
if	O
(	O
*	O
pat	*(char)
)	O
++	O
pat	*(char)
;	O
i	long
=	O
pos	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
double_metaphone_free	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(void)
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
code	int
)	O
{	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
[	O
0	int
]	O
)	O
;	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
[	O
1	int
]	O
)	O
;	O
}	O
static	O
int	O
is_slavo_germanic	(*(int))->(int)
(	O
unsigned	O
const	O
*	O
str	*(struct)
)	O
{	O
static	O
unsigned	O
pat	*(char)
[	O
]	O
=	O
{	O
'W'	O
,	O
0	int
,	O
'K'	O
,	O
0	int
,	O
'C'	O
,	O
'Z'	O
,	O
0	int
,	O
'W'	O
,	O
'I'	O
,	O
'T'	O
,	O
'Z'	O
,	O
0	int
,	O
0	int
}	O
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
pat	*(char)
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
utf8_wc_strstr	(*(int),*(int))->(*(int))
(	O
str	*(struct)
,	O
pat	*(char)
)	O
)	O
return	O
1	int
;	O
while	O
(	O
pat	*(char)
[	O
i	long
]	O
)	O
++	O
i	long
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
double_metaphone_encode	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),*(char),long)->(int)
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
code	int
,	O
char	O
const	O
*	O
str	*(struct)
,	O
size_t	long
max_length	long
)	O
{	O
unsigned	O
*	O
buf	*(void)
;	O
size_t	long
current	long
=	O
0	int
;	O
size_t	long
length	long
,	O
last	long
;	O
int	O
slavo_germanic	int
=	O
-	O
1	int
;	O
if	O
(	O
utf8_mbstr_to_wc	(*(char),*(*(int)),*(long))->(int)
(	O
str	*(struct)
,	O
&	O
buf	*(void)
,	O
NULL	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
"%s: cannot convert \"%s\""	*(char)
,	O
__func__	O
,	O
str	*(struct)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
length	long
=	O
utf8_wc_strlen	(*(int))->(long)
(	O
buf	*(void)
)	O
;	O
last	long
=	O
length	long
-	O
1	int
;	O
code	int
[	O
0	int
]	O
=	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
)	O
;	O
if	O
(	O
!	O
code	int
[	O
0	int
]	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: not enough memory"	*(char)
)	O
,	O
__func__	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
[	O
1	int
]	O
=	O
NULL	O
;	O
utf8_wc_strupper	(*(int))->(void)
(	O
buf	*(void)
)	O
;	O
current	long
=	O
0	int
;	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"GN|KN|PN|WR|PS"	*(char)
)	O
)	O
++	O
current	long
;	O
while	O
(	O
current	long
<	O
length	long
&&	O
(	O
max_length	long
==	O
0	int
||	O
metaph_code_length	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(long)
(	O
code	int
[	O
0	int
]	O
)	O
<	O
max_length	long
||	O
metaph_code_length	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(long)
(	O
code	int
[	O
1	int
]	O
)	O
<	O
max_length	long
)	O
)	O
{	O
switch	O
(	O
buf	*(void)
[	O
current	long
]	O
)	O
{	O
case	O
'A'	O
:	O
case	O
'E'	O
:	O
case	O
'I'	O
:	O
case	O
'O'	O
:	O
case	O
'U'	O
:	O
case	O
'Y'	O
:	O
if	O
(	O
current	long
==	O
0	int
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	*(char)
,	O
NULL	O
)	O
;	O
current	long
++	O
;	O
break	O
;	O
case	O
'B'	O
:	O
DMETAPH_ADD	O
(	O
code	int
,	O
"P"	*(char)
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'B'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
L'Ç'	O
:	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
current	long
>	O
1	int
&&	O
!	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
)	O
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"ACH"	*(char)
)	O
&&	O
buf	*(void)
[	O
current	long
+	O
2	int
]	O
!=	O
'I'	O
&&	O
(	O
buf	*(void)
[	O
current	long
+	O
2	int
]	O
!=	O
'E'	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"BACHER|MACHER"	*(char)
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CAESAR"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CHIA"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CH"	*(char)
)	O
)	O
{	O
if	O
(	O
current	long
>	O
0	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CHAE"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
"X"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
1	int
,	O
"HARAC|HARIS|HOR|HYM|HIA|HEM"	*(char)
)	O
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"CHORE"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"VAN |VON "	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"SCH"	*(char)
)	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"ORCHES|ARCHIT|ORCHID"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"T|S"	*(char)
)	O
||	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"A|O|U|E"	*(char)
)	O
||	O
current	long
==	O
0	int
)	O
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"L|R|N|M|B|H|F|V|W| "	*(char)
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
>	O
0	int
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"MC"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
"K"	*(char)
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
}	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CZ"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"WICZ"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
"X"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"CIA"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CC"	*(char)
)	O
&&	O
!	O
(	O
current	long
==	O
1	int
&&	O
buf	*(void)
[	O
0	int
]	O
==	O
'M'	O
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|H"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"HU"	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
1	int
&&	O
buf	*(void)
[	O
current	long
-	O
1	int
]	O
==	O
'A'	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"UCCEE|UCCES"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KS"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CK|CG|CQ"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CI|CE|CY"	*(char)
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"CIO|CIE|CIA"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
"X"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
" C| Q| G"	*(char)
)	O
)	O
current	long
+=	O
3	int
;	O
else	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"C|K|Q"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"CE|CI"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"DG"	*(char)
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|Y"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"TK"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"DT|DD"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	*(char)
,	O
NULL	O
)	O
;	O
current	long
++	O
;	O
break	O
;	O
case	O
'F'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'F'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
if	O
(	O
(	O
current	long
>	O
0	int
)	O
&&	O
!	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
<	O
3	int
)	O
{	O
if	O
(	O
current	long
==	O
0	int
)	O
{	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
2	int
]	O
==	O
'I'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
current	long
>	O
1	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"B|H|D"	*(char)
)	O
)	O
||	O
(	O
current	long
>	O
2	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
3	int
,	O
"B|H|D"	*(char)
)	O
)	O
||	O
(	O
current	long
>	O
3	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
4	int
,	O
"B|H"	*(char)
)	O
)	O
)	O
{	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
>	O
2	int
&&	O
buf	*(void)
[	O
current	long
-	O
1	int
]	O
==	O
'U'	O
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
3	int
,	O
"C|G|L|R|T"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
current	long
>	O
0	int
&&	O
buf	*(void)
[	O
current	long
-	O
1	int
]	O
!=	O
'I'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'N'	O
)	O
{	O
if	O
(	O
current	long
==	O
1	int
&&	O
ISVOWEL	O
(	O
buf	*(void)
,	O
0	int
,	O
0	int
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KN"	*(char)
,	O
"N"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"EY"	*(char)
)	O
&&	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
!=	O
'Y'	O
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	*(char)
,	O
"KN"	*(char)
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KN"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"LI"	*(char)
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KL"	*(char)
,	O
"L"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'Y'	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"ES|EP|EB|EL|EY|IB|IL|IN|IE|EI|ER"	*(char)
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
"J"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"ER"	*(char)
)	O
||	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'Y'	O
)	O
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"DANGER|RANGER|MANGER"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"E|I|RGY|OGY"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
"J"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"E|I|Y"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"AGGI|OGGI"	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"VAN |VON "	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"SCH"	*(char)
)	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"ET"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
else	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"IER "	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
"K"	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'G'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
(	O
current	long
==	O
0	int
||	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
)	O
)	O
&&	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"H"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
}	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'J'	O
:	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"JOSE"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"SAN "	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
0	int
&&	O
buf	*(void)
[	O
current	long
+	O
4	int
]	O
==	O
' '	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"SAN "	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"H"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
"H"	*(char)
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"JOSE"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
"A"	*(char)
)	O
;	O
else	O
if	O
(	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'A'	O
||	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'O'	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
"H"	*(char)
)	O
;	O
else	O
if	O
(	O
current	long
==	O
last	long
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
" "	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"L|T|K|S|N|M|B|Z"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"S|K|L"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'J'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
'K'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'K'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'L'	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
length	long
-	O
3	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"ILLO|ILLA|ALLE"	*(char)
)	O
)	O
||	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
last	long
,	O
-	O
1	int
,	O
"AS|OS"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
last	long
,	O
0	int
,	O
"A|O"	*(char)
)	O
)	O
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"ALLE"	*(char)
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"L"	*(char)
,	O
" "	*(char)
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
current	long
+=	O
2	int
;	O
}	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"L"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
if	O
(	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"UMB"	*(char)
)	O
&&	O
(	O
current	long
+	O
1	int
==	O
last	long
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"ER"	*(char)
)	O
)	O
)	O
||	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'M'	O
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"M"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'N'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
L'Ń'	O
:	O
case	O
L'Ñ'	O
:	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"P|B"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"P"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'Q'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
if	O
(	O
current	long
==	O
last	long
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"IE"	*(char)
)	O
&&	O
!	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
4	int
,	O
"ME|MA"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"R"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"R"	*(char)
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'R'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"ISL|YSL"	*(char)
)	O
)	O
{	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"SUGAR"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
"S"	*(char)
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"SH"	*(char)
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"HEIM|HOEK|HOLM|HOLZ"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"SIO|SIA"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"SIAN"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
"X"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
current	long
==	O
0	int
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"M|N|L|W"	*(char)
)	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"Z"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
"X"	*(char)
)	O
;	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"Z"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"SC"	*(char)
)	O
)	O
{	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
2	int
]	O
==	O
'H'	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
3	int
,	O
"OO|ER|EN|UY|ED|EM"	*(char)
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
3	int
,	O
"ER|EN"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
"SK"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"SK"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
==	O
0	int
&&	O
!	O
ISVOWEL	O
(	O
buf	*(void)
,	O
3	int
,	O
0	int
)	O
&&	O
buf	*(void)
[	O
3	int
]	O
!=	O
'W'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
"S"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|Y"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"SK"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
last	long
&&	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"AI|OI"	*(char)
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"S"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"S|Z"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"TION"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"TIA|TCH"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"TH|TTH"	*(char)
)	O
)	O
{	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
2	int
,	O
"OM|AM"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"VAN |VON |SCH"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"0"	*(char)
,	O
"T"	*(char)
)	O
;	O
}	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"T|D"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'V'	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	*(char)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"WR"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"R"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"WH"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	*(char)
,	O
"F"	*(char)
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	*(char)
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
(	O
current	long
==	O
last	long
&&	O
ISVOWEL	O
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
)	O
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
1	int
,	O
"EWSKI|EWSKY|OWSKI|OWSKY"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
0	int
,	O
0	int
,	O
"SCH"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"F"	*(char)
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
0	int
,	O
"WICZ|WITZ"	*(char)
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"TS"	*(char)
,	O
"FX"	*(char)
)	O
;	O
current	long
+=	O
4	int
;	O
break	O
;	O
}	O
current	long
++	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
!	O
(	O
current	long
==	O
last	long
&&	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
3	int
,	O
"IAU|EAU"	*(char)
)	O
||	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
-	O
2	int
,	O
"AU|OU"	*(char)
)	O
)	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KS"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"C|X"	*(char)
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
if	O
(	O
buf	*(void)
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	*(char)
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
looking_at	(*(int),long,int,*(char))->(int)
(	O
buf	*(void)
,	O
current	long
,	O
+	O
1	int
,	O
"ZO|ZI|ZA"	*(char)
)	O
||	O
(	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
(	O
current	long
>	O
0	int
&&	O
buf	*(void)
[	O
current	long
-	O
1	int
]	O
!=	O
'T'	O
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
"TS"	*(char)
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	*(char)
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	*(void)
[	O
current	long
]	O
==	O
'Z'	O
)	O
++	O
current	long
;	O
break	O
;	O
default	O
:	O
++	O
current	long
;	O
}	O
}	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
max_length	long
)	O
{	O
metaph_code_trim	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),long)->(void)
(	O
code	int
[	O
0	int
]	O
,	O
max_length	long
)	O
;	O
metaph_code_trim	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),long)->(void)
(	O
code	int
[	O
1	int
]	O
,	O
max_length	long
)	O
;	O
}	O
return	O
0	int
;	O
err	int
:	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
double_metaphone_free	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(void)
(	O
code	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
double_metaphone_eq	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(int)
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
a	*(struct)
,	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
b	*(struct)
)	O
{	O
return	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
a	*(struct)
[	O
0	int
]	O
,	O
b	*(struct)
[	O
0	int
]	O
)	O
||	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
a	*(struct)
[	O
1	int
]	O
,	O
b	*(struct)
[	O
1	int
]	O
)	O
||	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
a	*(struct)
[	O
0	int
]	O
,	O
b	*(struct)
[	O
1	int
]	O
)	O
||	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
a	*(struct)
[	O
1	int
]	O
,	O
b	*(struct)
[	O
0	int
]	O
)	O
;	O
}	O
static	O
size_t	long
double_metaphone_length	long
=	O
4	int
;	O
static	O
int	O
metaphone2_sel	(int,*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
int	O
cmd	int
,	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
key	*(char)
,	O
const	O
char	O
*	O
dict_word	*(char)
)	O
{	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
code	int
;	O
int	O
res	int
;	O
switch	O
(	O
cmd	int
)	O
{	O
case	O
DICO_SELECT_BEGIN	int
:	O
if	O
(	O
double_metaphone_encode	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),*(char),long)->(int)
(	O
code	int
,	O
key	*(char)
->	O
word	*(char)
,	O
double_metaphone_length	long
)	O
)	O
return	O
1	int
;	O
key	*(char)
->	O
call_data	*(void)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
code	int
)	O
;	O
if	O
(	O
!	O
key	*(char)
->	O
call_data	*(void)
)	O
return	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
key	*(char)
->	O
call_data	*(void)
,	O
code	int
,	O
sizeof	O
(	O
code	int
)	O
)	O
;	O
break	O
;	O
case	O
DICO_SELECT_RUN	int
:	O
if	O
(	O
double_metaphone_encode	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),*(char),long)->(int)
(	O
code	int
,	O
dict_word	*(char)
,	O
double_metaphone_length	long
)	O
)	O
return	O
1	int
;	O
res	int
=	O
double_metaphone_eq	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(int)
(	O
*	O
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
*	O
)	O
key	*(char)
->	O
call_data	*(void)
,	O
code	int
)	O
;	O
double_metaphone_free	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(void)
(	O
code	int
)	O
;	O
return	O
res	int
;	O
case	O
DICO_SELECT_END	int
:	O
double_metaphone_free	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(void)
(	O
*	O
(	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
*	O
)	O
key	*(char)
->	O
call_data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
key	*(char)
->	O
call_data	*(void)
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
dico_strategy	struct(*(char),*(char),*((int,*(struct),*(char))->(int)),*(void),int,*(struct))
metaphone2_strat	struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct))
=	O
{	O
"metaphone2"	*(char)
,	O
"Match Double Metaphone encodings"	*(char)
,	O
metaphone2_sel	(int,*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
}	O
;	O
static	O
int	O
metaphone2_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
long	O
size	long
=	O
0	int
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
metaphone2_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
size	long
)	O
,	O
dico_opt_long	int
,	O
&	O
size	long
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
metaphone2_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
size	long
>	O
0	int
)	O
double_metaphone_length	long
=	O
size	long
;	O
dico_strategy_add	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
&	O
metaphone2_strat	struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
metaphone2_run_test	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
modname	*(char)
,	O
*	O
cmd	int
;	O
argc	int
--	O
;	O
modname	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
dico_set_program_name	(*(char))->(void)
(	O
modname	*(char)
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"bad argument list"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
argc	int
--	O
;	O
cmd	int
=	O
*	O
argv	*(*(char))
++	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	int
,	O
"build"	*(char)
)	O
==	O
0	int
)	O
{	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
code	int
;	O
code	int
=	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
)	O
;	O
assert	O
(	O
code	int
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
int	O
res	int
=	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
code	int
,	O
*	O
argv	*(*(char))
++	O
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
metaph_code_dump	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
)	O
;	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	int
,	O
"compare"	*(char)
)	O
==	O
0	int
)	O
{	O
struct	O
metaph_code	struct(long,long,*(struct(array(char),*(struct(array(char),*(struct`))))),*(struct(array(char),*(struct(array(char),*(struct`))))))
*	O
a	*(struct)
,	O
*	O
b	*(struct)
;	O
int	O
res	int
;	O
a	*(struct)
=	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
)	O
;	O
assert	O
(	O
a	*(struct)
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
char	O
*	O
arg	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
":"	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
else	O
{	O
res	int
=	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
a	*(struct)
,	O
arg	*(char)
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
<=	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"bad argument list"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
b	*(struct)
=	O
metaph_code_create	()->(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))
(	O
)	O
;	O
assert	O
(	O
b	*(struct)
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
res	int
=	O
metaph_code_add	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(char))->(int)
(	O
b	*(struct)
,	O
*	O
argv	*(*(char))
++	O
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
res	int
=	O
metaph_code_eq	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))),*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(int)
(	O
a	*(struct)
,	O
b	*(struct)
)	O
;	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
a	*(struct)
)	O
;	O
metaph_code_free	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
b	*(struct)
)	O
;	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
res	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	int
,	O
"encode"	*(char)
)	O
==	O
0	int
)	O
{	O
unsigned	O
long	O
len	int
=	O
0	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
*	O
argv	*(*(char))
,	O
"-length="	*(char)
,	O
8	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
len	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
*	O
argv	*(*(char))
+	O
8	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
assert	O
(	O
*	O
p	*(char)
==	O
0	int
)	O
;	O
--	O
argc	int
;	O
++	O
argv	*(*(char))
;	O
}	O
while	O
(	O
argc	int
--	O
)	O
{	O
char	O
*	O
arg	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
double_metaphone_code	array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`))))))
code	int
;	O
if	O
(	O
double_metaphone_encode	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))),*(char),long)->(int)
(	O
code	int
,	O
arg	*(char)
,	O
len	int
)	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
"can't encode"	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"%s: "	*(char)
,	O
arg	*(char)
)	O
;	O
if	O
(	O
code	int
[	O
0	int
]	O
)	O
{	O
printf	(*(char))->(int)
(	O
"'"	*(char)
)	O
;	O
metaph_code_print	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
[	O
0	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"'"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"NULL"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
" -- "	*(char)
)	O
;	O
if	O
(	O
code	int
[	O
1	int
]	O
)	O
{	O
printf	(*(char))->(int)
(	O
"'"	*(char)
)	O
;	O
metaph_code_print	(*(struct(long,long,*(struct(array(char),*`)),*(struct(array(char),*`)))))->(void)
(	O
code	int
[	O
1	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"'"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"NULL"	*(char)
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
double_metaphone_free	(array(*(struct(long,long,*(struct(array(char),*(struct`))),*(struct(array(char),*(struct`)))))))->(void)
(	O
code	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"unrecognized unit test: %s"	*(char)
,	O
cmd	int
)	O
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_INFO	int
,	O
0	int
,	O
"usage:"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"usage: %s build SEQ [SEQ...]\n"	*(char)
"   build a metaphone code block from the sequence of letters\n"	*(char)
,	O
modname	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"       %s compare SEQ [SEQ...] : SEQ [SEQ...]\n"	*(char)
"   build two blocks and compare them\n"	*(char)
,	O
modname	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"       %s encode [-length=N] WORD [WORD...]\n"	*(char)
"   encode the supplied words\n"	*(char)
,	O
modname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
metaphone2	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NODB	int
,	O
.	O
dico_init	*((int,*(*(char)))->(int))
=	O
metaphone2_init	(int,*(*(char)))->(int)
,	O
.	O
dico_run_test	*((int,*(*(char)))->(int))
=	O
metaphone2_run_test	(int,*(*(char)))->(int)
}	O
;	O
