struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
grecs_sockaddr_new	(long)->(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
(	O
size_t	long
s	*(char)
)	O
{	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
grecs_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
)	O
)	O
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
str	*(char)
=	O
NULL	O
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
sa	*(struct(short,array(char)))
=	O
grecs_zalloc	(long)->(*(void))
(	O
s	*(char)
)	O
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
len	long
=	O
s	*(char)
;	O
return	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
}	O
void	O
grecs_sockaddr_free	(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))->(void)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
)	O
{	O
while	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
)	O
{	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
free	(*(void))->(void)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
sa	*(struct(short,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
)	O
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
}	O
}	O
static	O
int	O
parse_unix	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
const	O
char	O
*	O
addrstr	*(char)
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
s_un	*(struct(short,array(char)))
;	O
size_t	long
slen	long
=	O
strlen	(*(char))->(long)
(	O
addrstr	*(char)
)	O
;	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
if	O
(	O
slen	long
>=	O
sizeof	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"socket path name too long: %s"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
grecs_sockaddr_new	(long)->(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
(	O
sizeof	O
(	O
s_un	*(struct(short,array(char)))
[	O
0	int
]	O
)	O
)	O
;	O
s_un	*(struct(short,array(char)))
=	O
(	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
)	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
sa	*(struct(short,array(char)))
;	O
s_un	*(struct(short,array(char)))
->	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
,	O
addrstr	*(char)
)	O
;	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
=	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_inet	(*(*(struct(*(struct`),*(char),int,*(struct`)))),int,*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
int	O
family	int
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
const	O
char	O
*	O
addrstr	*(char)
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
{	O
int	O
rc	int
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
*	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
ap	array(struct(int,int,*(void),*(void)))
;	O
const	O
char	O
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
NULL	O
;	O
char	O
*	O
nodebuf	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
service	*(char)
=	O
NULL	O
;	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
NULL	O
,	O
*	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
char	O
portbuf	array(char)
[	O
64	int
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
family	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
if	O
(	O
(	O
family	int
==	O
AF_INET6	O
||	O
family	int
==	O
AF_UNSPEC	O
)	O
&&	O
addrstr	*(char)
[	O
0	int
]	O
==	O
'['	O
)	O
{	O
char	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
strchr	(*(char),int)->(*(char))
(	O
addrstr	*(char)
+	O
1	int
,	O
']'	O
)	O
;	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
&&	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
>	O
addrstr	*(char)
+	O
1	int
)	O
{	O
size_t	long
len	long
;	O
addrstr	*(char)
++	O
;	O
len	long
=	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
-	O
addrstr	*(char)
;	O
nodebuf	*(char)
=	O
grecs_malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
nodebuf	*(char)
,	O
addrstr	*(char)
,	O
len	long
)	O
;	O
nodebuf	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
nodebuf	*(char)
;	O
service	*(char)
=	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
+	O
1	int
;	O
family	int
=	O
AF_INET6	O
;	O
}	O
else	O
service	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
addrstr	*(char)
,	O
':'	O
)	O
;	O
}	O
else	O
service	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
addrstr	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
service	*(char)
&&	O
*	O
service	*(char)
)	O
{	O
if	O
(	O
*	O
service	*(char)
!=	O
':'	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"%s: garbage near %s"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
service	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
service	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
)	O
{	O
if	O
(	O
service	*(char)
)	O
{	O
size_t	long
len	long
=	O
service	*(char)
-	O
addrstr	*(char)
-	O
1	int
;	O
if	O
(	O
len	long
==	O
0	int
)	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
NULL	O
;	O
else	O
{	O
nodebuf	*(char)
=	O
grecs_malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
nodebuf	*(char)
,	O
addrstr	*(char)
,	O
len	long
)	O
;	O
nodebuf	*(char)
[	O
len	long
]	O
=	O
0	int
;	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
nodebuf	*(char)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
grecs_str_is_ipaddr	(*(char))->(int)
(	O
addrstr	*(char)
)	O
)	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
addrstr	*(char)
;	O
else	O
if	O
(	O
grecs_str_is_num	(*(char))->(int)
(	O
addrstr	*(char)
)	O
)	O
{	O
service	*(char)
=	O
addrstr	*(char)
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
|=	O
AI_NUMERICSERV	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
service	*(char)
||	O
!	O
*	O
service	*(char)
)	O
{	O
if	O
(	O
!	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
&&	O
addrstr	*(char)
[	O
0	int
]	O
)	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
addrstr	*(char)
;	O
if	O
(	O
gh	*(struct(int,*(char),short))
->	O
flags	int
&	O
GRECS_HINT_SERVICE	int
)	O
{	O
service	*(char)
=	O
gh	*(struct(int,*(char),short))
->	O
service	*(char)
;	O
}	O
else	O
if	O
(	O
gh	*(struct(int,*(char),short))
->	O
flags	int
&	O
GRECS_HINT_PORT	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
portbuf	array(char)
,	O
sizeof	O
portbuf	array(char)
,	O
"%hu"	*(char)
,	O
gh	*(struct(int,*(char),short))
->	O
port	short
)	O
;	O
service	*(char)
=	O
portbuf	array(char)
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
|=	O
AI_NUMERICSERV	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
gh	*(struct(int,*(char),short))
->	O
flags	int
&	O
GRECS_AH_PASSIVE	int
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"service not specified: %s"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
)	O
{	O
if	O
(	O
gh	*(struct(int,*(char),short))
->	O
flags	int
&	O
GRECS_AH_PASSIVE	int
)	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
|=	O
AI_PASSIVE	int
;	O
}	O
rc	int
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
service	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
nodebuf	*(char)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
EAI_SYSTEM	O
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"%s: cannot parse address: %s"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
case	O
EAI_BADFLAGS	O
:	O
case	O
EAI_SOCKTYPE	O
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
"%s:%d: internal error converting %s"	*(char)
,	O
__FILE__	O
,	O
__LINE__	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
;	O
break	O
;	O
case	O
EAI_MEMORY	O
:	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
default	O
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
"%s: %s"	*(char)
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
gai_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
ap	array(struct(int,int,*(void),*(void)))
=	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
ap	array(struct(int,int,*(void),*(void)))
;	O
ap	array(struct(int,int,*(void),*(void)))
=	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
if	O
(	O
family	int
==	O
AF_UNSPEC	O
||	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addr	*(struct(short,array(char)))
->	O
sa_family	short
==	O
family	int
)	O
{	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
grecs_sockaddr_new	(long)->(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
(	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addrlen	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
sa	*(struct(short,array(char)))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addr	*(struct(short,array(char)))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addrlen	int
)	O
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
len	long
=	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addrlen	int
;	O
if	O
(	O
!	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
else	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
}	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
=	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_inet4	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
const	O
char	O
*	O
addrstr	*(char)
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
{	O
return	O
parse_inet	(*(*(struct(*(struct`),*(char),int,*(struct`)))),int,*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
AF_INET	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
addrstr	*(char)
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
static	O
int	O
parse_inet6	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
const	O
char	O
*	O
addrstr	*(char)
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
{	O
return	O
parse_inet	(*(*(struct(*(struct`),*(char),int,*(struct`)))),int,*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
AF_INET6	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
addrstr	*(char)
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
struct	O
schemetab	struct(*(char),long,*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int)))
{	O
const	O
char	O
*	O
scheme	*(char)
;	O
size_t	long
len	long
;	O
int	O
(	O
*	O
parser	*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int))
)	O
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
ret	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
const	O
char	O
*	O
addr	*(char)
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
;	O
struct	O
schemetab	struct(*(char),long,*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int)))
schemetab	struct(*(char),long,*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int)))
[	O
]	O
=	O
{	O
{	O
"inet"	*(char)
,	O
4	int
,	O
parse_inet4	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
}	O
,	O
{	O
"inet4"	*(char)
,	O
5	int
,	O
parse_inet4	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
}	O
,	O
{	O
"inet6"	*(char)
,	O
5	int
,	O
parse_inet6	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
}	O
,	O
{	O
"unix"	*(char)
,	O
4	int
,	O
parse_unix	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
grecs_str_to_sockaddr	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
*	O
sap	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
const	O
char	O
*	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
*	O
gh	*(struct(int,*(char),short))
,	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
{	O
char	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
struct	O
grecs_sockaddr_hints	struct(int,*(char),short)
ghints	struct(int,*(char),short)
;	O
if	O
(	O
!	O
gh	*(struct(int,*(char),short))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ghints	struct(int,*(char),short)
,	O
0	int
,	O
sizeof	O
(	O
ghints	struct(int,*(char),short)
)	O
)	O
;	O
if	O
(	O
grecs_default_port	int
)	O
{	O
ghints	struct(int,*(char),short)
.	O
flags	int
=	O
GRECS_HINT_PORT	int
;	O
ghints	struct(int,*(char),short)
.	O
port	short
=	O
ntohs	(short)->(short)
(	O
grecs_default_port	int
)	O
;	O
}	O
gh	*(struct(int,*(char),short))
=	O
&	O
ghints	struct(int,*(char),short)
;	O
}	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
strchr	(*(char),int)->(*(char))
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
&&	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
>	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
&&	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
[	O
1	int
]	O
==	O
'/'	O
&&	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
[	O
2	int
]	O
==	O
'/'	O
)	O
{	O
size_t	long
len	long
=	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
-	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
;	O
struct	O
schemetab	struct(*(char),long,*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int)))
*	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
;	O
for	O
(	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
=	O
schemetab	struct(*(char),long,*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int)))
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
scheme	*(char)
;	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
++	O
)	O
if	O
(	O
len	long
==	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
len	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
scheme	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
return	O
sp	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
->	O
parser	*((*(*(struct(*`,*`,int,*`))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*`,int,int),struct(*`,int,int))))->(int))
(	O
sap	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char)))))
+	O
3	int
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unknown or unsupported scheme: %s"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
[	O
0	int
]	O
==	O
'/'	O
)	O
return	O
parse_unix	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
sap	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
else	O
if	O
(	O
strlen	(*(char))->(long)
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
>	O
5	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
"unix:"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
[	O
5	int
]	O
!=	O
'/'	O
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"%s: UNIX socket must be an absolute file name"	*(char)
)	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
)	O
;	O
return	O
parse_unix	(*(*(struct(*(struct`),*(char),int,*(struct`)))),*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
sap	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
+	O
5	int
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
return	O
parse_inet	(*(*(struct(*(struct`),*(char),int,*(struct`)))),int,*(char),*(char),*(struct(int,*(char),short)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
sap	*(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))
,	O
AF_UNSPEC	O
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
arg	struct(long,*(*(struct(int,struct(struct`,struct`)))))
,	O
gh	*(struct(int,*(char),short))
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
static	O
int	O
sockaddr_str	(*(struct(short,array(char))),int,*(*(char)),*(long))->(int)
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
socklen_t	int
salen	int
,	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
psz	*(long)
)	O
{	O
int	O
rc	int
;	O
switch	O
(	O
sa	*(struct(short,array(char)))
->	O
sa_family	short
)	O
{	O
case	O
AF_INET	O
:	O
case	O
AF_INET6	O
:	O
{	O
char	O
host	array(char)
[	O
NI_MAXHOST	int
]	O
;	O
char	O
srv	array(char)
[	O
NI_MAXSERV	int
]	O
;	O
if	O
(	O
getnameinfo	(*(struct(short,array(char))),int,*(char),int,*(char),int,int)->(int)
(	O
sa	*(struct(short,array(char)))
,	O
salen	int
,	O
host	array(char)
,	O
sizeof	O
(	O
host	array(char)
)	O
,	O
srv	array(char)
,	O
sizeof	O
(	O
srv	array(char)
)	O
,	O
NI_NUMERICHOST	int
|	O
NI_NUMERICSERV	int
)	O
==	O
0	int
)	O
rc	int
=	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
pbuf	*(*(char))
,	O
psz	*(long)
,	O
"%s://%s:%s"	*(char)
,	O
sa	*(struct(short,array(char)))
->	O
sa_family	short
==	O
AF_INET	O
?	O
"inet"	*(char)
:	O
"inet6"	*(char)
,	O
host	array(char)
,	O
srv	array(char)
)	O
;	O
else	O
rc	int
=	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
pbuf	*(*(char))
,	O
psz	*(long)
,	O
"%s://[getnameinfo failed]"	*(char)
,	O
sa	*(struct(short,array(char)))
->	O
sa_family	short
==	O
AF_INET	O
?	O
"inet"	*(char)
:	O
"inet6"	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
AF_UNIX	O
:	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
s_un	*(struct(short,array(char)))
=	O
(	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
)	O
sa	*(struct(short,array(char)))
;	O
if	O
(	O
S_UN_NAME	O
(	O
s_un	*(struct(short,array(char)))
,	O
salen	int
)	O
[	O
0	int
]	O
==	O
0	int
)	O
rc	int
=	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
pbuf	*(*(char))
,	O
psz	*(long)
,	O
"unix://[anonymous socket]"	*(char)
)	O
;	O
else	O
rc	int
=	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
pbuf	*(*(char))
,	O
psz	*(long)
,	O
"unix://%s"	*(char)
,	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
)	O
;	O
break	O
;	O
}	O
default	O
:	O
rc	int
=	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
pbuf	*(*(char))
,	O
psz	*(long)
,	O
"family:%d"	*(char)
,	O
sa	*(struct(short,array(char)))
->	O
sa_family	short
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
char	O
const	O
*	O
grecs_sockaddr_str	(*(struct(*(struct(*`,*`,int,*`)),*(char),int,*(struct(short,array(char))))))->(*(char))
(	O
struct	O
grecs_sockaddr	struct(*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct(short,array(char))))),*(char),int,*(struct(short,array(char))))
*	O
sa	*(struct(short,array(char)))
)	O
{	O
if	O
(	O
!	O
sa	*(struct(short,array(char)))
->	O
str	*(char)
)	O
{	O
size_t	long
sz	long
=	O
0	int
;	O
if	O
(	O
sockaddr_str	(*(struct(short,array(char))),int,*(*(char)),*(long))->(int)
(	O
sa	*(struct(short,array(char)))
->	O
sa	*(struct(short,array(char)))
,	O
sa	*(struct(short,array(char)))
->	O
len	long
,	O
&	O
sa	*(struct(short,array(char)))
->	O
str	*(char)
,	O
&	O
sz	long
)	O
)	O
{	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
return	O
sa	*(struct(short,array(char)))
->	O
str	*(char)
;	O
}	O
