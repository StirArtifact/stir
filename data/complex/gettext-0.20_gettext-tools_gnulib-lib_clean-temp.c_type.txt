struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
{	O
char	O
*	O
volatile	O
dirname	*(char)
;	O
bool	bool
cleanup_verbose	bool
;	O
gl_list_t	*(struct)
volatile	O
subdirs	*(struct)
;	O
gl_list_t	*(struct)
volatile	O
files	*(struct)
;	O
}	O
;	O
static	O
struct	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
volatile	O
*	O
volatile	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
;	O
size_t	long
volatile	O
tempdir_count	long
;	O
size_t	long
tempdir_allocated	long
;	O
}	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
;	O
static	O
gl_list_t	*(struct)
volatile	O
descriptors	*(struct)
;	O
static	O
bool	bool
string_equals	(*(void),*(void))->(bool)
(	O
const	O
void	O
*	O
x1	*(void)
,	O
const	O
void	O
*	O
x2	*(void)
)	O
{	O
const	O
char	O
*	O
s1	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
x1	*(void)
;	O
const	O
char	O
*	O
s2	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
x2	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
s2	*(char)
)	O
==	O
0	int
;	O
}	O
static	O
size_t	long
string_hash	(*(void))->(long)
(	O
const	O
void	O
*	O
x	*(void)
)	O
{	O
const	O
char	O
*	O
s	long
=	O
(	O
const	O
char	O
*	O
)	O
x	*(void)
;	O
size_t	long
h	long
=	O
0	int
;	O
for	O
(	O
;	O
*	O
s	long
;	O
s	long
++	O
)	O
h	long
=	O
*	O
s	long
+	O
(	O
(	O
h	long
<<	O
9	int
)	O
|	O
(	O
h	long
>>	O
(	O
SIZE_BITS	O
-	O
9	int
)	O
)	O
)	O
;	O
return	O
h	long
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
cleanup_action	(int)->(void)
(	O
int	O
sig	int
_GL_UNUSED	O
)	O
{	O
size_t	long
i	long
;	O
{	O
gl_list_t	*(struct)
fds	*(struct)
=	O
descriptors	*(struct)
;	O
if	O
(	O
fds	*(struct)
!=	O
NULL	O
)	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
element	*(void)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long))
(	O
fds	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
element	*(void)
,	O
NULL	O
)	O
)	O
{	O
int	O
fd	int
=	O
(	O
int	O
)	O
(	O
uintptr_t	long
)	O
element	*(void)
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
dir	*(struct(*(char),bool))
=	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
]	O
;	O
if	O
(	O
dir	*(struct(*(char),bool))
!=	O
NULL	O
)	O
{	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
element	*(void)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long))
(	O
dir	*(struct(*(char),bool))
->	O
files	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
element	*(void)
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
file	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
element	*(void)
;	O
unlink	(*(char))->(int)
(	O
file	*(char)
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long))
(	O
dir	*(struct(*(char),bool))
->	O
subdirs	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
element	*(void)
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
subdir	*(char)
=	O
(	O
const	O
char	O
*	O
)	O
element	*(void)
;	O
rmdir	(*(char))->(int)
(	O
subdir	*(char)
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
rmdir	(*(char))->(int)
(	O
dir	*(struct(*(char),bool))
->	O
dirname	*(char)
)	O
;	O
}	O
}	O
}	O
struct	O
temp_dir	struct(*(char),bool)
*	O
create_temp_dir	(*(char),*(char),bool)->(*(struct(*(char),bool)))
(	O
const	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
parentdir	*(char)
,	O
bool	bool
cleanup_verbose	bool
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
volatile	O
*	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
NULL	O
;	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
;	O
size_t	long
i	long
;	O
char	O
*	O
xtemplate	*(char)
;	O
char	O
*	O
tmpdirname	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
if	O
(	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
]	O
==	O
NULL	O
)	O
{	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
&	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
]	O
;	O
break	O
;	O
}	O
if	O
(	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
==	O
NULL	O
)	O
{	O
if	O
(	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
==	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_allocated	long
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
volatile	O
*	O
old_array	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
;	O
size_t	long
old_allocated	long
=	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_allocated	long
;	O
size_t	long
new_allocated	long
=	O
2	int
*	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_allocated	long
+	O
1	int
;	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
volatile	O
*	O
new_array	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
XNMALLOC	O
(	O
new_allocated	long
,	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
volatile	O
)	O
;	O
if	O
(	O
old_allocated	long
==	O
0	int
)	O
at_fatal_signal	(*((int)->(void)))->(void)
(	O
&	O
cleanup_action	(int)->(void)
)	O
;	O
else	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
old_allocated	long
;	O
k	long
++	O
)	O
new_array	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
k	long
]	O
=	O
old_array	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
k	long
]	O
;	O
}	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
new_array	*(*(struct(*(char),bool,*(struct),*(struct))))
;	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_allocated	long
=	O
new_allocated	long
;	O
if	O
(	O
old_array	*(*(struct(*(char),bool,*(struct),*(struct))))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
*	O
)	O
old_array	*(*(struct(*(char),bool,*(struct),*(struct))))
)	O
;	O
}	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
&	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
]	O
;	O
*	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
NULL	O
;	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
++	O
;	O
}	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
XMALLOC	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
)	O
;	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
dirname	*(char)
=	O
NULL	O
;	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
cleanup_verbose	bool
=	O
cleanup_verbose	bool
;	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKEDHASH_LIST	O
,	O
string_equals	(*(void),*(void))->(bool)
,	O
string_hash	(*(void))->(long)
,	O
NULL	O
,	O
false	int
)	O
;	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKEDHASH_LIST	O
,	O
string_equals	(*(void),*(void))->(bool)
,	O
string_hash	(*(void))->(long)
,	O
NULL	O
,	O
false	int
)	O
;	O
xtemplate	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
path_search	(*(char),long,*(char),*(char),bool)->(int)
(	O
xtemplate	*(char)
,	O
PATH_MAX	int
,	O
parentdir	*(char)
,	O
prefix	*(char)
,	O
parentdir	*(char)
==	O
NULL	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot find a temporary directory, try setting $TMPDIR"	*(char)
)	O
)	O
;	O
goto	O
quit	O
;	O
}	O
block_fatal_signals	()->(void)
(	O
)	O
;	O
tmpdirname	*(char)
=	O
mkdtemp	(*(char))->(*(char))
(	O
xtemplate	*(char)
)	O
;	O
if	O
(	O
tmpdirname	*(char)
!=	O
NULL	O
)	O
{	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
dirname	*(char)
=	O
tmpdirname	*(char)
;	O
*	O
tmpdirp	*(*(struct(*(char),bool,*(struct),*(struct))))
=	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
;	O
}	O
unblock_fatal_signals	()->(void)
(	O
)	O
;	O
if	O
(	O
tmpdirname	*(char)
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot create a temporary directory using template \"%s\""	*(char)
)	O
,	O
xtemplate	*(char)
)	O
;	O
goto	O
quit	O
;	O
}	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
dirname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
tmpdirname	*(char)
)	O
;	O
freea	(*(void))->(void)
(	O
xtemplate	*(char)
)	O
;	O
return	O
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
)	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
;	O
quit	O
:	O
freea	(*(void))->(void)
(	O
xtemplate	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
register_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_file_name	*(char)
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
if	O
(	O
gl_list_search	(*(struct),*(void))->(*(struct))
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
,	O
absolute_file_name	*(char)
)	O
==	O
NULL	O
)	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
,	O
xstrdup	(*(char))->(*(char))
(	O
absolute_file_name	*(char)
)	O
)	O
;	O
}	O
void	O
unregister_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_file_name	*(char)
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
gl_list_t	*(struct)
list	*(struct)
=	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
node	*(struct)
=	O
gl_list_search	(*(struct),*(void))->(*(struct))
(	O
list	*(struct)
,	O
absolute_file_name	*(char)
)	O
;	O
if	O
(	O
node	*(struct)
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_string	*(char)
=	O
(	O
char	O
*	O
)	O
gl_list_node_value	(*(struct),*(struct))->(*(void))
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
gl_list_remove_node	(*(struct),*(struct))->(bool)
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
old_string	*(char)
)	O
;	O
}	O
}	O
void	O
register_temp_subdir	(*(struct(*(char),bool)),*(char))->(void)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_dir_name	*(char)
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
if	O
(	O
gl_list_search	(*(struct),*(void))->(*(struct))
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
,	O
absolute_dir_name	*(char)
)	O
==	O
NULL	O
)	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
,	O
xstrdup	(*(char))->(*(char))
(	O
absolute_dir_name	*(char)
)	O
)	O
;	O
}	O
void	O
unregister_temp_subdir	(*(struct(*(char),bool)),*(char))->(void)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_dir_name	*(char)
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
gl_list_t	*(struct)
list	*(struct)
=	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
node	*(struct)
=	O
gl_list_search	(*(struct),*(void))->(*(struct))
(	O
list	*(struct)
,	O
absolute_dir_name	*(char)
)	O
;	O
if	O
(	O
node	*(struct)
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_string	*(char)
=	O
(	O
char	O
*	O
)	O
gl_list_node_value	(*(struct),*(struct))->(*(void))
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
gl_list_remove_node	(*(struct),*(struct))->(bool)
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
old_string	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
do_unlink	(*(struct(*(char),bool)),*(char))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_file_name	*(char)
)	O
{	O
if	O
(	O
unlink	(*(char))->(int)
(	O
absolute_file_name	*(char)
)	O
<	O
0	int
&&	O
dir	*(struct(*(char),bool))
->	O
cleanup_verbose	bool
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove temporary file %s"	*(char)
)	O
,	O
absolute_file_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
do_rmdir	(*(struct(*(char),bool)),*(char))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_dir_name	*(char)
)	O
{	O
if	O
(	O
rmdir	(*(char))->(int)
(	O
absolute_dir_name	*(char)
)	O
<	O
0	int
&&	O
dir	*(struct(*(char),bool))
->	O
cleanup_verbose	bool
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove temporary directory %s"	*(char)
)	O
,	O
absolute_dir_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
cleanup_temp_file	(*(struct(*(char),bool)),*(char))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_file_name	*(char)
)	O
{	O
int	O
err	int
;	O
err	int
=	O
do_unlink	(*(struct(*(char),bool)),*(char))->(int)
(	O
dir	*(struct(*(char),bool))
,	O
absolute_file_name	*(char)
)	O
;	O
unregister_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
dir	*(struct(*(char),bool))
,	O
absolute_file_name	*(char)
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_subdir	(*(struct(*(char),bool)),*(char))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
,	O
const	O
char	O
*	O
absolute_dir_name	*(char)
)	O
{	O
int	O
err	int
;	O
err	int
=	O
do_rmdir	(*(struct(*(char),bool)),*(char))->(int)
(	O
dir	*(struct(*(char),bool))
,	O
absolute_dir_name	*(char)
)	O
;	O
unregister_temp_subdir	(*(struct(*(char),bool)),*(char))->(void)
(	O
dir	*(struct(*(char),bool))
,	O
absolute_dir_name	*(char)
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_dir_contents	(*(struct(*(char),bool)))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
int	O
err	int
=	O
0	int
;	O
gl_list_t	*(struct)
list	*(struct)
;	O
gl_list_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
element	*(void)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
list	*(struct)
=	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long))
(	O
list	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
element	*(void)
,	O
&	O
node	*(struct)
)	O
)	O
{	O
char	O
*	O
file	*(char)
=	O
(	O
char	O
*	O
)	O
element	*(void)
;	O
err	int
|=	O
do_unlink	(*(struct(*(char),bool)),*(char))->(int)
(	O
dir	*(struct(*(char),bool))
,	O
file	*(char)
)	O
;	O
gl_list_remove_node	(*(struct),*(struct))->(bool)
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
list	*(struct)
=	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
;	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_list_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long))
(	O
list	*(struct)
)	O
;	O
while	O
(	O
gl_list_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
element	*(void)
,	O
&	O
node	*(struct)
)	O
)	O
{	O
char	O
*	O
subdir	*(char)
=	O
(	O
char	O
*	O
)	O
element	*(void)
;	O
err	int
|=	O
do_rmdir	(*(struct(*(char),bool)),*(char))->(int)
(	O
dir	*(struct(*(char),bool))
,	O
subdir	*(char)
)	O
;	O
gl_list_remove_node	(*(struct),*(struct))->(bool)
(	O
list	*(struct)
,	O
node	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
subdir	*(char)
)	O
;	O
}	O
gl_list_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_dir	(*(struct(*(char),bool)))->(int)
(	O
struct	O
temp_dir	struct(*(char),bool)
*	O
dir	*(struct(*(char),bool))
)	O
{	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
=	O
(	O
struct	O
tempdir	struct(*(char),bool,*(struct),*(struct))
*	O
)	O
dir	*(struct(*(char),bool))
;	O
int	O
err	int
=	O
0	int
;	O
size_t	long
i	long
;	O
err	int
|=	O
cleanup_temp_dir_contents	(*(struct(*(char),bool)))->(int)
(	O
dir	*(struct(*(char),bool))
)	O
;	O
err	int
|=	O
do_rmdir	(*(struct(*(char),bool)),*(char))->(int)
(	O
dir	*(struct(*(char),bool))
,	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
dirname	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
if	O
(	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
]	O
==	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
)	O
{	O
if	O
(	O
i	long
+	O
1	int
==	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
)	O
{	O
while	O
(	O
i	long
>	O
0	int
&&	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
-	O
1	int
]	O
==	O
NULL	O
)	O
i	long
--	O
;	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_count	long
=	O
i	long
;	O
}	O
else	O
cleanup_list	struct(*(*(struct(*(char),bool,*(struct`),*(struct`)))),long,long)
.	O
tempdir_list	*(*(struct(*(char),bool,*(struct),*(struct))))
[	O
i	long
]	O
=	O
NULL	O
;	O
gl_list_free	(*(struct))->(void)
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
files	*(struct)
)	O
;	O
gl_list_free	(*(struct))->(void)
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
subdirs	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
->	O
dirname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmpdir	*(struct(*(char),bool,*(struct),*(struct)))
)	O
;	O
return	O
err	int
;	O
}	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
register_fd	(int)->(void)
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
descriptors	*(struct)
==	O
NULL	O
)	O
descriptors	*(struct)
=	O
gl_list_create_empty	(*(struct(*((*`,*`,*`,*`,bool)->(*`)),*((*`,*`,*`,*`,bool,long,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(*`)),*((*`,*`,*`)->(int)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,long)->(*`)),*((*`,long,*`)->(*`)),*((*`,long,long,*`)->(*`)),*((*`,long,long,*`)->(long)),*((*`,*`)->(*`)),*((*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(*`)),*((*`,long,*`)->(*`)),*((*`,*`)->(bool)),*((*`,long)->(bool)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,long,long)->(struct`)),*((*`,*`,*`)->(bool)),*((*`)->(void)),*((*`,*`,*`)->(*`)),*((*`,*`,long,long,*`)->(*`)),*((*`,*`,*`)->(long)),*((*`,*`,long,long,*`)->(long)),*((*`,*`,*`)->(*`)),*((*`,*`,*`)->(bool)))),*((*(void),*(void))->(bool)),*((*(void))->(long)),*((*(void))->(void)),bool)->(*(struct))
(	O
GL_LINKEDHASH_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
false	int
)	O
;	O
gl_list_add_first	(*(struct),*(void))->(*(struct))
(	O
descriptors	*(struct)
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
fd	int
)	O
;	O
}	O
static	O
void	O
unregister_fd	(int)->(void)
(	O
int	O
fd	int
)	O
{	O
gl_list_t	*(struct)
fds	*(struct)
=	O
descriptors	*(struct)
;	O
gl_list_node_t	*(struct)
node	*(struct)
;	O
if	O
(	O
fds	*(struct)
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
node	*(struct)
=	O
gl_list_search	(*(struct),*(void))->(*(struct))
(	O
fds	*(struct)
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
fd	int
)	O
;	O
if	O
(	O
node	*(struct)
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
gl_list_remove_node	(*(struct),*(struct))->(bool)
(	O
fds	*(struct)
,	O
node	*(struct)
)	O
;	O
}	O
int	O
open_temp	(*(char),int,int)->(int)
(	O
const	O
char	O
*	O
file_name	*(char)
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
fd	int
;	O
int	O
saved_errno	int
;	O
block_fatal_signals	()->(void)
(	O
)	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
file_name	*(char)
,	O
flags	int
,	O
mode	int
)	O
;	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
register_fd	(int)->(void)
(	O
fd	int
)	O
;	O
unblock_fatal_signals	()->(void)
(	O
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
fd	int
;	O
}	O
FILE	struct
*	O
fopen_temp	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
file_name	*(char)
,	O
const	O
char	O
*	O
mode	int
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
saved_errno	int
;	O
block_fatal_signals	()->(void)
(	O
)	O
;	O
{	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file_name	*(char)
,	O
mode	int
)	O
;	O
saved_errno	int
=	O
errno	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
int	O
fd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
(	O
fd	int
>=	O
0	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
register_fd	(int)->(void)
(	O
fd	int
)	O
;	O
}	O
unblock_fatal_signals	()->(void)
(	O
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
int	O
close_temp	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
int	O
result	*(struct)
=	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	(int)->(void)
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	*(struct)
;	O
}	O
else	O
return	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
int	O
fclose_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
fd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
result	*(struct)
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	(int)->(void)
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	*(struct)
;	O
}	O
int	O
fwriteerror_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
fd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
result	*(struct)
=	O
fwriteerror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	(int)->(void)
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	*(struct)
;	O
}	O
