enum	O
mailvar_cmd	enum(int,int)
{	O
mailvar_cmd_set	int
,	O
mailvar_cmd_unset	int
}	O
;	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
var	*(char)
;	O
int	O
flags	int
;	O
char	O
*	O
descr	*(char)
;	O
int	O
(	O
*	O
handler	*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int))
)	O
(	O
enum	O
mailvar_cmd	enum(int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
}	O
;	O
mu_list_t	*(struct)
mailvar_list	*(struct)
=	O
NULL	O
;	O
static	O
int	O
set_decode_fallback	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_replyregex	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_screen	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_verbose	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_debug	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_folder	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
static	O
int	O
set_headline	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
)	O
;	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
[	O
]	O
=	O
{	O
{	O
{	O
mailvar_name_allnet	*(char)
,	O
}	O
,	O
MAILVAR_HIDDEN	int
}	O
,	O
{	O
{	O
mailvar_name_append	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"messages saved in mbox are appended to the end rather than prepended"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_appenddeadletter	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"append the contents of canceled letter to dead.letter file"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_askbcc	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for bcc before composing the message"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_askcc	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for cc before composing the message"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_ask	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for subject before composing the message"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_asksub	*(char)
,	O
}	O
,	O
MAILVAR_ALIAS	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_autoinc	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"automatically incorporate newly arrived messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_autoprint	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"delete command behaves like dp"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_byname	*(char)
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"record outgoing messages in a file named after the first recipient; "	*(char)
"overrides the `record' variable"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_bang	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"replace every occurrence of ! in arguments to the shell command"	*(char)
" with the last executed command"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_charset	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"output character set for decoded header fields"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_cmd	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"default shell command for pipe"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_columns	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of columns on terminal screen"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_crt	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
|	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"if numeric, sets the minimum number of output lines needed "	*(char)
"to engage paging; if boolean, use the height of the terminal "	*(char)
"screen to compute the threshold"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_datefield	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"get date from the `Date:' header, instead of the envelope"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_debug	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"set Mailutils debug level"	*(char)
)	O
,	O
set_debug	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_decode_fallback	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"how to represent characters that cannot be rendered using the "	*(char)
"current character set"	*(char)
)	O
,	O
set_decode_fallback	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_dot	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"input message is terminated with a dot alone on a line"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_editheaders	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"allow editing message headers while composing"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_emptystart	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"start interactive mode if the mailbox is empty"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_escape	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"character denoting escapes"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_flipr	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"swap the meaning of reply and Reply commands"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_folder	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"folder directory name"	*(char)
)	O
,	O
set_folder	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_fromfield	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"get sender address from the `From:' header, instead of "	*(char)
"the envelope"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_gnu_last_command	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"last executed command line"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_header	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"run the `headers' command after entering interactive mode"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_headline	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"format string to use for the header summary"	*(char)
)	O
,	O
set_headline	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_hold	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"hold the read or saved messages in the system mailbox"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_ignore	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"ignore keyboard interrupts when composing messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_ignoreeof	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"ignore EOF character"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_indentprefix	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"string used by the ~m escape for indenting quoted messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_inplacealiases	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"expand aliases in the address header field "	*(char)
"before starting composing the message"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_keep	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"keep the empty user's system mailbox,"	*(char)
" instead of removing it"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_keepsave	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"keep saved messages in system mailbox too"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_mailx	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"enable mailx compatibility mode"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_metamail	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"interpret the content of message parts; if set to a string "	*(char)
"specifies the name of the external metamail command"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_metoo	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"do not remove sender addresses from the recipient list"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_mimenoask	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"a comma-separated list of MIME types for which "	*(char)
"no confirmation is needed before running metamail interpreter"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_mode	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"the name of current operation mode"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_nullbody	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"accept messages with an empty body"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_nullbodymsg	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"display this text when sending a message with empty body"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_outfolder	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"keep created files in this folder"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_page	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"pipe command terminates each message with a formfeed"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_prompt	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"command prompt sequence"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_quit	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"keyboard interrupts terminate the program"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_rc	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"read the system-wide configuration file upon startup"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_readonly	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"mailboxes are opened in readonly mode"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_record	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"save outgoing messages in this file"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_recursivealiases	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"recursively expand aliases"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_regex	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"use of regular expressions in search message specifications"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_replyprefix	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"prefix for the subject line of a reply message"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_replyregex	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"regexp for recognizing subject lines of reply messages"	*(char)
)	O
,	O
set_replyregex	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_return_address	*(char)
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"return address for outgoing messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_save	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"store aborted messages in the user's dead.file"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_screen	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of lines on terminal screen"	*(char)
)	O
,	O
set_screen	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_sendmail	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"URL of the mail transport agent"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_sendwait	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_HIDDEN	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_sign	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"signature for use with the ~a command"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_Sign	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"name of the signature file for use with the ~A command"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_showenvelope	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"`print' command includes the SMTP envelope in its output"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_showto	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"if the message was sent by me, print its recipient address "	*(char)
"in the header summary"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_toplines	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of lines to be displayed by `top' or `Top'"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_variable_pretty_print	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"print variables with short descriptions"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_varpp	*(char)
,	O
}	O
,	O
MAILVAR_ALIAS	int
}	O
,	O
{	O
{	O
mailvar_name_variable_strict	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"perform strict checking when setting variables"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_varstrict	*(char)
,	O
}	O
,	O
MAILVAR_ALIAS	int
}	O
,	O
{	O
{	O
mailvar_name_verbose	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"verbosely trace the process of message delivery"	*(char)
)	O
,	O
set_verbose	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
}	O
,	O
{	O
{	O
mailvar_name_xmailer	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"add the `X-Mailer' header to the outgoing messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_mime	*(char)
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"always compose MIME messages"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_onehop	*(char)
,	O
}	O
,	O
MAILVAR_HIDDEN	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_quiet	*(char)
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_HIDDEN	int
,	O
N_	O
(	O
"suppress the printing of the version when first invoked"	*(char)
)	O
}	O
,	O
{	O
{	O
mailvar_name_PID	*(char)
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"PID of this process"	*(char)
)	O
}	O
,	O
{	O
{	O
NULL	O
}	O
,	O
}	O
}	O
;	O
static	O
int	O
mailvar_symbol_count	int
=	O
sizeof	O
(	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
)	O
/	O
sizeof	O
(	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
[	O
0	int
]	O
)	O
-	O
1	int
;	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
const	O
char	O
*	O
var	*(char)
)	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
;	O
for	O
(	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
;	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
;	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
,	O
var	*(char)
)	O
==	O
0	int
)	O
{	O
while	O
(	O
(	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_ALIAS	int
)	O
&&	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
>	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
)	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
--	O
;	O
return	O
ep	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
print_descr	(*(struct),*(char),int,int,int,*(char))->(void)
(	O
mu_stream_t	*(struct)
out	*(struct)
,	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
n	*(long)
,	O
int	O
doc_col	int
,	O
int	O
rmargin	int
,	O
char	O
*	O
pfx	*(char)
)	O
{	O
mu_stream_stat_buffer	array(long)
stat	*(int)
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
out	*(struct)
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	*(int)
)	O
;	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
n	*(long)
;	O
do	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
space	*(char)
=	O
NULL	O
;	O
if	O
(	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
&&	O
pfx	*(char)
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
pfx	*(char)
)	O
;	O
while	O
(	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
<	O
doc_col	int
)	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
out	*(struct)
,	O
" "	*(char)
,	O
1	int
,	O
NULL	O
)	O
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
p	*(char)
&&	O
p	*(char)
<	O
s	*(char)
+	O
(	O
rmargin	int
-	O
doc_col	int
)	O
;	O
p	*(char)
++	O
)	O
if	O
(	O
mu_isspace	O
(	O
*	O
p	*(char)
)	O
)	O
space	*(char)
=	O
p	*(char)
;	O
if	O
(	O
!	O
space	*(char)
||	O
p	*(char)
<	O
s	*(char)
+	O
(	O
rmargin	int
-	O
doc_col	int
)	O
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
s	*(char)
+=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
}	O
else	O
{	O
for	O
(	O
;	O
s	*(char)
<	O
space	*(char)
;	O
s	*(char)
++	O
)	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
out	*(struct)
,	O
s	*(char)
,	O
1	int
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
*	O
s	*(char)
&&	O
mu_isspace	O
(	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
1	int
;	O
}	O
while	O
(	O
*	O
s	*(char)
)	O
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
out	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
mailvar_variable_comp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
const	O
void	O
*	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
const	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
v1	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
=	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
;	O
const	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
v2	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
=	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
v1	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
v2	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
}	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
mailvar_find_variable	(*(char),int)->(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
create	int
)	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
;	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
;	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
var	*(char)
=	O
&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
;	O
else	O
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
entry	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
,	O
*	O
p	*(char)
;	O
entry	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
if	O
(	O
mailvar_list	*(struct)
==	O
NULL	O
)	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
mailvar_list	*(struct)
)	O
;	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
mailvar_list	*(struct)
,	O
mailvar_variable_comp	(*(void),*(void))->(int)
)	O
;	O
}	O
if	O
(	O
mu_list_locate	(*(struct),*(void),*(*(void)))->(int)
(	O
mailvar_list	*(struct)
,	O
&	O
entry	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
create	int
)	O
return	O
0	int
;	O
else	O
{	O
p	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
*	O
p	*(char)
)	O
;	O
p	*(char)
->	O
name	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
mu_list_prepend	(*(struct),*(void))->(int)
(	O
mailvar_list	*(struct)
,	O
p	*(char)
)	O
;	O
}	O
}	O
var	*(char)
=	O
p	*(char)
;	O
var	*(char)
->	O
set	int
=	O
0	int
;	O
var	*(char)
->	O
type	*(char)
=	O
mailvar_type_whatever	int
;	O
var	*(char)
->	O
value	*(void)
.	O
number	int
=	O
0	int
;	O
}	O
return	O
var	*(char)
;	O
}	O
int	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
void	O
*	O
ptr	*(*(void))
,	O
const	O
char	O
*	O
variable	*(char)
,	O
enum	O
mailvar_type	enum(int,int,int,int)
type	*(char)
,	O
int	O
warn	int
)	O
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
=	O
mailvar_find_variable	(*(char),int)->(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))
(	O
variable	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
var	*(char)
->	O
set	int
||	O
var	*(char)
->	O
type	*(char)
!=	O
type	*(char)
)	O
{	O
if	O
(	O
warn	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"No value set for \"%s\""	*(char)
)	O
,	O
variable	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ptr	*(*(void))
)	O
switch	O
(	O
type	*(char)
)	O
{	O
case	O
mailvar_type_string	int
:	O
*	O
(	O
char	O
*	O
*	O
)	O
ptr	*(*(void))
=	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
;	O
break	O
;	O
case	O
mailvar_type_number	int
:	O
*	O
(	O
int	O
*	O
)	O
ptr	*(*(void))
=	O
var	*(char)
->	O
value	*(void)
.	O
number	int
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
*	O
(	O
int	O
*	O
)	O
ptr	*(*(void))
=	O
var	*(char)
->	O
value	*(void)
.	O
bool	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mailvar_is_true	(*(char))->(int)
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
return	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
NULL	O
,	O
name	*(char)
,	O
mailvar_type_boolean	int
,	O
0	int
)	O
==	O
0	int
;	O
}	O
void	O
mailvar_variable_reset	(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(void)
(	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
if	O
(	O
!	O
var	*(char)
->	O
set	int
)	O
return	O
;	O
switch	O
(	O
var	*(char)
->	O
type	*(char)
)	O
{	O
case	O
mailvar_type_string	int
:	O
free	(*(void))->(void)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
var	*(char)
->	O
set	int
=	O
0	int
;	O
}	O
int	O
mailvar_set	(*(char),*(void),enum(int,int,int,int),int)->(int)
(	O
const	O
char	O
*	O
variable	*(char)
,	O
void	O
*	O
value	*(void)
,	O
enum	O
mailvar_type	enum(int,int,int,int)
type	*(char)
,	O
int	O
flags	int
)	O
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
,	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
;	O
const	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
variable	*(char)
)	O
;	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
=	O
(	O
flags	int
&	O
MOPTF_UNSET	int
)	O
?	O
mailvar_cmd_unset	int
:	O
mailvar_cmd_set	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MOPTF_QUIET	int
)	O
&&	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_variable_strict	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"setting unknown variable %s"	*(char)
)	O
,	O
variable	*(char)
)	O
;	O
else	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_set	int
?	O
_	O
(	O
"Cannot set read-only variable %s"	*(char)
)	O
:	O
_	O
(	O
"Cannot unset read-only variable %s"	*(char)
)	O
,	O
variable	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
type	*(char)
)	O
)	O
&&	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_set	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Wrong type for %s"	*(char)
)	O
,	O
variable	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
var	*(char)
=	O
mailvar_find_variable	(*(char),int)->(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))
(	O
variable	*(char)
,	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_set	int
)	O
;	O
if	O
(	O
!	O
var	*(char)
||	O
(	O
var	*(char)
->	O
set	int
&&	O
!	O
(	O
flags	int
&	O
MOPTF_OVERWRITE	int
)	O
)	O
)	O
return	O
0	int
;	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
name	*(char)
=	O
var	*(char)
->	O
name	*(char)
;	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
type	*(char)
=	O
var	*(char)
->	O
type	*(char)
;	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
set	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
value	*(void)
,	O
0	int
,	O
sizeof	O
(	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
value	*(void)
)	O
)	O
;	O
switch	O
(	O
cmd	enum(int,int,int,int,int)
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
if	O
(	O
value	*(void)
)	O
{	O
switch	O
(	O
type	*(char)
)	O
{	O
case	O
mailvar_type_number	int
:	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
value	*(void)
.	O
number	int
=	O
*	O
(	O
int	O
*	O
)	O
value	*(void)
;	O
break	O
;	O
case	O
mailvar_type_string	int
:	O
{	O
char	O
*	O
p	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
value	*(void)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
_	O
(	O
"Not enough memory"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
value	*(void)
.	O
string	*(char)
=	O
p	*(char)
;	O
}	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
value	*(void)
.	O
bool	int
=	O
*	O
(	O
int	O
*	O
)	O
value	*(void)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
set	int
=	O
1	int
;	O
}	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
.	O
type	*(char)
=	O
type	*(char)
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
&&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
handler	*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int))
&&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
type	*(char)
)	O
&&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
handler	*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int))
(	O
cmd	enum(int,int,int,int,int)
,	O
&	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
)	O
)	O
{	O
mailvar_variable_reset	(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(void)
(	O
&	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
)	O
;	O
return	O
1	int
;	O
}	O
mailvar_variable_reset	(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(void)
(	O
var	*(char)
)	O
;	O
*	O
var	*(char)
=	O
newvar	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
&&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
handler	*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int))
&&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
handler	*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int))
(	O
cmd	enum(int,int,int,int,int)
,	O
var	*(char)
)	O
)	O
return	O
1	int
;	O
mailvar_variable_reset	(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(void)
(	O
var	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_folder	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
mu_alloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
var	*(char)
->	O
set	int
)	O
free	(*(void))->(void)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
=	O
p	*(char)
;	O
}	O
rc	int
=	O
mu_set_folder_directory	(*(char))->(int)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_set_folder_directory"	*(char)
,	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
set_headline	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
if	O
(	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_unset	int
)	O
return	O
1	int
;	O
mail_compile_headline	(*(char))->(void)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_decode_fallback	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
char	O
*	O
value	*(void)
;	O
int	O
rc	int
;	O
switch	O
(	O
cmd	enum(int,int,int,int,int)
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
value	*(void)
=	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
value	*(void)
=	O
"none"	*(char)
;	O
}	O
rc	int
=	O
mu_set_default_fallback	(*(char))->(int)
(	O
value	*(void)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Incorrect value for decode-fallback"	*(char)
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
set_replyregex	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
err	long
;	O
switch	O
(	O
cmd	enum(int,int,int,int,int)
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
if	O
(	O
(	O
rc	int
=	O
mu_unre_set_regex	(*(char),int,*(*(char)))->(int)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
,	O
0	int
,	O
&	O
err	long
)	O
)	O
)	O
{	O
if	O
(	O
err	long
)	O
mu_error	(*(char))->(int)
(	O
"%s: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
,	O
err	long
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_screen	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
if	O
(	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_set	int
)	O
page_invalidate	(int)->(void)
(	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_verbose	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
switch	O
(	O
cmd	enum(int,int,int,int,int)
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
mu_debug_set_category_level	(int,int)->(int)
(	O
MU_DEBCAT_APP	int
,	O
DEFAULT_DEBUG_LEVEL	O
)	O
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
mu_debug_set_category_level	(int,int)->(int)
(	O
MU_DEBCAT_APP	int
,	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_debug	(enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))->(int)
(	O
enum	O
mailvar_cmd	enum(int,int)
cmd	enum(int,int,int,int,int)
,	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
)	O
{	O
mu_debug_clear_all	()->(void)
(	O
)	O
;	O
if	O
(	O
cmd	enum(int,int,int,int,int)
==	O
mailvar_cmd_set	int
)	O
{	O
if	O
(	O
var	*(char)
->	O
type	*(char)
==	O
mailvar_type_boolean	int
)	O
{	O
if	O
(	O
var	*(char)
->	O
set	int
)	O
mu_debug_set_category_level	(int,int)->(int)
(	O
MU_DEBCAT_ALL	int
,	O
DEFAULT_DEBUG_LEVEL	O
)	O
;	O
return	O
0	int
;	O
}	O
mu_debug_parse_spec	(*(char))->(void)
(	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
size_t	long
_mailvar_symbol_count	(int)->(long)
(	O
int	O
set	int
)	O
{	O
if	O
(	O
!	O
set	int
)	O
return	O
mailvar_symbol_count	int
;	O
else	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
s	*(char)
;	O
size_t	long
count	*(long)
=	O
0	int
;	O
for	O
(	O
s	*(char)
=	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
;	O
s	*(char)
->	O
var	*(char)
.	O
name	*(char)
;	O
s	*(char)
++	O
)	O
if	O
(	O
s	*(char)
->	O
var	*(char)
.	O
set	int
)	O
count	*(long)
++	O
;	O
return	O
count	*(long)
;	O
}	O
}	O
static	O
int	O
mailvar_mapper	(*(*(void)),long,*(void))->(int)
(	O
void	O
*	O
*	O
itmv	*(*(void))
,	O
size_t	long
itmc	long
,	O
void	O
*	O
call_data	*(void)
)	O
{	O
return	O
MU_LIST_MAP_OK	int
;	O
}	O
int	O
_mailvar_symbol_to_list	(int,*(struct))->(int)
(	O
int	O
set	int
,	O
mu_list_t	*(struct)
list	*(struct)
)	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
s	*(char)
;	O
for	O
(	O
s	*(char)
=	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
;	O
s	*(char)
->	O
var	*(char)
.	O
name	*(char)
;	O
s	*(char)
++	O
)	O
if	O
(	O
!	O
set	int
||	O
s	*(char)
->	O
var	*(char)
.	O
set	int
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
list	*(struct)
,	O
&	O
s	*(char)
->	O
var	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
mu_list_t	*(struct)
mailvar_list_copy	(int)->(*(struct))
(	O
int	O
set	int
)	O
{	O
mu_list_t	*(struct)
list	*(struct)
=	O
NULL	O
;	O
if	O
(	O
mailvar_list	*(struct)
)	O
mu_list_map	(*(struct),*((*(*(void)),long,*(void))->(int)),*(void),long,*(*(struct)))->(int)
(	O
mailvar_list	*(struct)
,	O
mailvar_mapper	(*(*(void)),long,*(void))->(int)
,	O
NULL	O
,	O
1	int
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
!	O
list	*(struct)
)	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
_mailvar_symbol_to_list	(int,*(struct))->(int)
(	O
set	int
,	O
list	*(struct)
)	O
;	O
mu_list_sort	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
list	*(struct)
,	O
mailvar_variable_comp	(*(void),*(void))->(int)
)	O
;	O
return	O
list	*(struct)
;	O
}	O
enum	O
{	O
MAILVAR_ITR_ALL	int
=	O
0	int
,	O
MAILVAR_ITR_SET	int
=	O
0x1	int
,	O
MAILVAR_ITR_WRITABLE	int
=	O
0x2	int
}	O
;	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
{	O
int	O
flags	int
;	O
const	O
char	O
*	O
prefix	array(*(char))
;	O
int	O
prefixlen	int
;	O
mu_list_t	*(struct)
varlist	*(struct)
;	O
mu_iterator_t	*(struct)
varitr	*(struct)
;	O
}	O
;	O
const	O
char	O
*	O
mailvar_iterate_next	(*(struct(int,*(char),int,*(struct),*(struct))))->(*(char))
(	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
*	O
itr	*(struct)
)	O
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
;	O
while	O
(	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
->	O
varitr	*(struct)
)	O
)	O
{	O
size_t	long
len	long
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
->	O
varitr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
->	O
varitr	*(struct)
)	O
;	O
if	O
(	O
itr	*(struct)
->	O
flags	int
&	O
MAILVAR_ITR_WRITABLE	int
)	O
{	O
const	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
&&	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
>=	O
itr	*(struct)
->	O
prefixlen	int
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
itr	*(struct)
->	O
prefix	array(*(char))
,	O
itr	*(struct)
->	O
prefixlen	int
)	O
==	O
0	int
)	O
return	O
strdup	(*(char))->(*(char))
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
itr	*(struct)
->	O
prefixlen	int
>=	O
2	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
itr	*(struct)
->	O
prefix	array(*(char))
,	O
"no"	*(char)
,	O
2	int
)	O
==	O
0	int
&&	O
(	O
len	long
=	O
strlen	(*(char))->(long)
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
)	O
>=	O
itr	*(struct)
->	O
prefixlen	int
-	O
2	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
itr	*(struct)
->	O
prefix	array(*(char))
+	O
2	int
,	O
itr	*(struct)
->	O
prefixlen	int
-	O
2	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
&&	O
!	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
(	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
)	O
)	O
)	O
continue	O
;	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
3	int
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
"no"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
+	O
2	int
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
}	O
return	O
p	*(char)
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
mailvar_iterate_first	(int,*(char),*(*(struct(int,*(char),int,*(struct`),*(struct`)))))->(*(char))
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
prefix	array(*(char))
,	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
*	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
)	O
{	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
*	O
itr	*(struct)
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
*	O
itr	*(struct)
)	O
;	O
itr	*(struct)
->	O
flags	int
=	O
flags	int
;	O
itr	*(struct)
->	O
prefix	array(*(char))
=	O
prefix	array(*(char))
;	O
itr	*(struct)
->	O
prefixlen	int
=	O
strlen	(*(char))->(long)
(	O
prefix	array(*(char))
)	O
;	O
itr	*(struct)
->	O
varlist	*(struct)
=	O
mailvar_list_copy	(int)->(*(struct))
(	O
flags	int
&	O
MAILVAR_ITR_SET	int
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
itr	*(struct)
->	O
varlist	*(struct)
,	O
&	O
itr	*(struct)
->	O
varitr	*(struct)
)	O
;	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
->	O
varitr	*(struct)
)	O
;	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
=	O
itr	*(struct)
;	O
return	O
mailvar_iterate_next	(*(struct(int,*(char),int,*(struct),*(struct))))->(*(char))
(	O
itr	*(struct)
)	O
;	O
}	O
void	O
mailvar_iterate_end	(*(*(struct(int,*(char),int,*(struct`),*(struct`)))))->(void)
(	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
*	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
)	O
{	O
if	O
(	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
&&	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
)	O
{	O
struct	O
mailvar_iterator	struct(int,*(char),int,*(struct),*(struct))
*	O
itr	*(struct)
=	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
->	O
varitr	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
->	O
varlist	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
itr	*(struct)
)	O
;	O
*	O
pitr	*(*(struct(int,*(char),int,*(struct),*(struct))))
=	O
NULL	O
;	O
}	O
}	O
struct	O
mailvar_print_closure	struct(int,*(struct),int)
{	O
int	O
prettyprint	int
;	O
mu_stream_t	*(struct)
out	*(struct)
;	O
int	O
width	int
;	O
}	O
;	O
static	O
int	O
mailvar_printer	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
=	O
item	*(void)
;	O
struct	O
mailvar_print_closure	struct(int,*(struct),int)
*	O
clos	*(void)
=	O
data	*(void)
;	O
if	O
(	O
clos	*(void)
->	O
prettyprint	int
)	O
{	O
const	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
{	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_HIDDEN	int
)	O
return	O
0	int
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"# %s:\n"	*(char)
,	O
_	O
(	O
"Read-only variable"	*(char)
)	O
)	O
;	O
print_descr	(*(struct),*(char),int,int,int,*(char))->(void)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
gettext	(*(char))->(*(char))
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
descr	*(char)
)	O
,	O
1	int
,	O
3	int
,	O
clos	*(void)
->	O
width	int
-	O
1	int
,	O
"# "	*(char)
)	O
;	O
}	O
}	O
switch	O
(	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
type	*(char)
)	O
{	O
case	O
mailvar_type_number	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"%s=%d"	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
value	*(void)
.	O
number	int
)	O
;	O
break	O
;	O
case	O
mailvar_type_string	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"%s=\"%s\""	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
if	O
(	O
!	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
value	*(void)
.	O
bool	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"no"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"%s"	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
mailvar_type_whatever	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"%s %s"	*(char)
,	O
vp	*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)))
->	O
name	*(char)
,	O
_	O
(	O
"oops?"	*(char)
)	O
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
clos	*(void)
->	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mailvar_print	(int)->(void)
(	O
int	O
set	int
)	O
{	O
mu_list_t	*(struct)
varlist	*(struct)
;	O
size_t	long
count	*(long)
;	O
struct	O
mailvar_print_closure	struct(int,*(struct),int)
clos	*(void)
;	O
varlist	*(struct)
=	O
mailvar_list_copy	(int)->(*(struct))
(	O
set	int
)	O
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
varlist	*(struct)
,	O
&	O
count	*(long)
)	O
;	O
clos	*(void)
.	O
out	*(struct)
=	O
open_pager	(long)->(*(struct))
(	O
count	*(long)
)	O
;	O
clos	*(void)
.	O
prettyprint	int
=	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_variable_pretty_print	*(char)
)	O
;	O
clos	*(void)
.	O
width	int
=	O
util_screen_columns	()->(int)
(	O
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
varlist	*(struct)
,	O
mailvar_printer	(*(void),*(void))->(int)
,	O
&	O
clos	*(void)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
varlist	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
clos	*(void)
.	O
out	*(struct)
)	O
;	O
}	O
void	O
mailvar_variable_format	(*(struct),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))),*(char))->(void)
(	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
const	O
struct	O
mailvar_variable	struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))
*	O
var	*(char)
,	O
const	O
char	O
*	O
defval	int
)	O
{	O
if	O
(	O
var	*(char)
)	O
switch	O
(	O
var	*(char)
->	O
type	*(char)
)	O
{	O
case	O
mailvar_type_string	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"%s"	*(char)
,	O
var	*(char)
->	O
value	*(void)
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
mailvar_type_number	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"%d"	*(char)
,	O
var	*(char)
->	O
value	*(void)
.	O
number	int
)	O
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"%s"	*(char)
,	O
var	*(char)
->	O
set	int
?	O
"yes"	*(char)
:	O
"no"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
defval	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"%s"	*(char)
,	O
defval	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
char	O
*	O
typestr	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"untyped"	*(char)
)	O
,	O
N_	O
(	O
"numeric"	*(char)
)	O
,	O
N_	O
(	O
"string"	*(char)
)	O
,	O
N_	O
(	O
"boolean"	*(char)
)	O
}	O
;	O
static	O
void	O
describe_symbol	(*(struct),int,*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))->(void)
(	O
mu_stream_t	*(struct)
out	*(struct)
,	O
int	O
width	int
,	O
const	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
{	O
int	O
i	int
,	O
t	int
;	O
const	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
;	O
mu_stream_stat_buffer	array(long)
stat	*(int)
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
out	*(struct)
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	*(int)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
)	O
;	O
for	O
(	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
+	O
1	int
;	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
&&	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_ALIAS	int
;	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
)	O
+	O
2	int
;	O
if	O
(	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
+	O
len	long
>	O
width	int
)	O
{	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
0	int
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n%s"	*(char)
,	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
)	O
;	O
}	O
else	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
", %s"	*(char)
,	O
ali	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
out	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
_	O
(	O
"Type: "	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
t	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
typestr	array(*(char))
)	O
/	O
sizeof	O
(	O
typestr	array(*(char))
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
i	int
)	O
)	O
{	O
if	O
(	O
t	int
++	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
" %s "	*(char)
,	O
_	O
(	O
"or"	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
typestr	array(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
t	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
typestr	array(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s"	*(char)
,	O
_	O
(	O
"Current value: "	*(char)
)	O
)	O
;	O
mailvar_variable_format	(*(struct),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))),*(char))->(void)
(	O
out	*(struct)
,	O
&	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
,	O
_	O
(	O
"[not set]"	*(char)
)	O
)	O
;	O
if	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
" [%s]"	*(char)
,	O
_	O
(	O
"read-only"	*(char)
)	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
print_descr	(*(struct),*(char),int,int,int,*(char))->(void)
(	O
out	*(struct)
,	O
gettext	(*(char))->(*(char))
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
descr	*(char)
?	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
descr	*(char)
:	O
N_	O
(	O
"Not documented"	*(char)
)	O
)	O
,	O
1	int
,	O
1	int
,	O
width	int
-	O
1	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"\n"	*(char)
)	O
;	O
}	O
int	O
mail_variable	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
pagelines	int
=	O
util_get_crt	()->(int)
(	O
)	O
;	O
int	O
width	int
=	O
util_screen_columns	()->(int)
(	O
)	O
;	O
mu_stream_t	*(struct)
out	*(struct)
=	O
open_pager	(long)->(*(struct))
(	O
pagelines	int
+	O
1	int
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
;	O
for	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
mailvar_tab	array(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*`,enum(int,int,int,int),int,union`)))->(int))))
;	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
var	*(char)
.	O
name	*(char)
;	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
++	O
)	O
if	O
(	O
!	O
(	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
->	O
flags	int
&	O
(	O
MAILVAR_HIDDEN	int
|	O
MAILVAR_ALIAS	int
)	O
)	O
)	O
describe_symbol	(*(struct),int,*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))->(void)
(	O
out	*(struct)
,	O
width	int
,	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
struct	O
mailvar_symbol	struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct(*(char),enum(int,int,int,int),int,union(*`,int,int))))->(int)))
*	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
=	O
find_mailvar_symbol	(*(char))->(*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
out	*(struct)
,	O
"%s: unknown\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
else	O
describe_symbol	(*(struct),int,*(struct(struct(*(char),enum(int,int,int,int),int,union(*`,int,int)),int,*(char),*((enum(int,int),*`)->(int)))))->(void)
(	O
out	*(struct)
,	O
width	int
,	O
sym	*(struct(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int)),int,*(char),*((enum(int,int),*(struct`))->(int))))
)	O
;	O
}	O
}	O
mu_stream_unref	(*(struct))->(void)
(	O
out	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
