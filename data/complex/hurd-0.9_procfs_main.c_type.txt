int	O
opt_clk_tck	int
;	O
mode_t	O
opt_stat_mode	int
;	O
pid_t	O
opt_fake_self	int
;	O
pid_t	O
opt_kernel_pid	int
;	O
uid_t	O
opt_anon_owner	int
;	O
static	O
void	O
set_compatibility_options	()->(void)
(	O
void	O
)	O
{	O
opt_clk_tck	int
=	O
100	int
;	O
opt_stat_mode	int
=	O
0444	int
;	O
opt_fake_self	int
=	O
1	int
;	O
}	O
static	O
error_t	O
argp_parser	(int,*(char),*(struct))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
struct	O
passwd	O
*	O
pw	*(struct)
;	O
char	O
*	O
endp	*(char)
;	O
long	O
int	O
v	long
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'h'	O
:	O
v	long
=	O
strtol	O
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
||	O
!	O
*	O
arg	*(char)
||	O
v	long
<=	O
0	int
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"--clk-tck: HZ should be a positive integer"	*(char)
)	O
;	O
else	O
opt_clk_tck	int
=	O
v	long
;	O
break	O
;	O
case	O
's'	O
:	O
v	long
=	O
strtol	O
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
8	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
||	O
!	O
*	O
arg	*(char)
||	O
(	O
mode_t	O
)	O
v	long
&	O
~	O
07777	int
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"--stat-mode: MODE should be an octal mode"	*(char)
)	O
;	O
else	O
opt_stat_mode	int
=	O
v	long
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
arg	*(char)
)	O
{	O
v	long
=	O
strtol	O
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
||	O
!	O
*	O
arg	*(char)
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"--fake-self: PID must be an integer"	*(char)
)	O
;	O
else	O
opt_fake_self	int
=	O
v	long
;	O
}	O
else	O
opt_fake_self	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
v	long
=	O
strtol	O
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
||	O
!	O
*	O
arg	*(char)
||	O
(	O
signed	O
)	O
opt_kernel_pid	int
<	O
0	int
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"--kernel-process: PID must be a positive integer"	*(char)
)	O
;	O
else	O
opt_kernel_pid	int
=	O
v	long
;	O
break	O
;	O
case	O
'c'	O
:	O
set_compatibility_options	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
pw	*(struct)
=	O
getpwnam	()->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
pw	*(struct)
)	O
{	O
opt_anon_owner	int
=	O
pw	*(struct)
->	O
pw_uid	O
;	O
break	O
;	O
}	O
v	long
=	O
strtol	O
(	O
arg	*(char)
,	O
&	O
endp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	*(char)
||	O
!	O
*	O
arg	*(char)
||	O
v	long
<	O
0	int
)	O
argp_error	()->(int)
(	O
state	*(struct)
,	O
"--anonymous-owner: USER should be "	*(char)
"a user name or a numeric UID."	*(char)
)	O
;	O
else	O
opt_anon_owner	int
=	O
v	long
;	O
break	O
;	O
case	O
NODEV_KEY	O
:	O
break	O
;	O
case	O
NOEXEC_KEY	O
:	O
break	O
;	O
case	O
NOSUID_KEY	O
:	O
break	O
;	O
case	O
ARGP_KEY_ARG	O
:	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"none"	*(char)
)	O
||	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"proc"	*(char)
)	O
)	O
break	O
;	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
argp_option	O
common_options	int
[	O
]	O
=	O
{	O
{	O
"clk-tck"	*(char)
,	O
'h'	O
,	O
"HZ"	*(char)
,	O
0	int
,	O
"Unit used for the values expressed in system clock ticks "	*(char)
"(default: "	*(char)
STR	O
(	O
OPT_CLK_TCK	O
)	O
")"	*(char)
}	O
,	O
{	O
"stat-mode"	*(char)
,	O
's'	O
,	O
"MODE"	*(char)
,	O
0	int
,	O
"The [pid]/stat file publishes information which on Hurd is only "	*(char)
"available to the process owner.  "	*(char)
"You can use this option to override its mode to be more permissive "	*(char)
"for compatibility purposes.  "	*(char)
"(default: "	*(char)
STR	O
(	O
OPT_STAT_MODE	int
)	O
")"	*(char)
}	O
,	O
{	O
"fake-self"	*(char)
,	O
'S'	O
,	O
"PID"	*(char)
,	O
OPTION_ARG_OPTIONAL	O
,	O
"Provide a fake \"self\" symlink to the given PID, for compatibility "	*(char)
"purposes.  If PID is omitted, \"self\" will point to init.  "	*(char)
"(default: no self link)"	*(char)
}	O
,	O
{	O
"kernel-process"	*(char)
,	O
'k'	O
,	O
"PID"	*(char)
,	O
0	int
,	O
"Process identifier for the kernel, used to retrieve its command "	*(char)
"line, as well as the global up and idle times. "	*(char)
"(default: "	*(char)
STR	O
(	O
OPT_KERNEL_PID	O
)	O
")"	*(char)
}	O
,	O
{	O
"compatible"	*(char)
,	O
'c'	O
,	O
NULL	O
,	O
0	int
,	O
"Try to be compatible with the Linux procps utilities.  "	*(char)
"Currently equivalent to -h 100 -s 0444 -S 1."	*(char)
}	O
,	O
{	O
"anonymous-owner"	*(char)
,	O
'a'	O
,	O
"USER"	*(char)
,	O
0	int
,	O
"Make USER the owner of files related to processes without one.  "	*(char)
"Be aware that USER will be granted access to the environment and "	*(char)
"other sensitive information about the processes in question.  "	*(char)
"(default: use uid "	*(char)
STR	O
(	O
OPT_ANON_OWNER	int
)	O
")"	*(char)
}	O
,	O
{	O
"nodev"	*(char)
,	O
NODEV_KEY	O
,	O
NULL	O
,	O
0	int
,	O
"Ignored for compatibility with Linux' procfs."	*(char)
}	O
,	O
{	O
"noexec"	*(char)
,	O
NOEXEC_KEY	O
,	O
NULL	O
,	O
0	int
,	O
"Ignored for compatibility with Linux' procfs."	*(char)
}	O
,	O
{	O
"nosuid"	*(char)
,	O
NOSUID_KEY	O
,	O
NULL	O
,	O
0	int
,	O
"Ignored for compatibility with Linux' procfs."	*(char)
}	O
,	O
{	O
}	O
}	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
.	O
options	O
=	O
common_options	int
,	O
.	O
parser	O
=	O
argp_parser	(int,*(char),*(struct))->(int)
,	O
.	O
doc	O
=	O
"A virtual filesystem emulating the Linux procfs."	*(char)
,	O
.	O
children	O
=	O
(	O
struct	O
argp_child	O
[	O
]	O
)	O
{	O
{	O
&	O
netfs_std_startup_argp	O
,	O
}	O
,	O
{	O
}	O
}	O
,	O
}	O
;	O
static	O
error_t	O
runtime_argp_parser	(int,*(char),*(struct))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'u'	O
:	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
argp	struct
runtime_argp	struct
=	O
{	O
.	O
options	O
=	O
(	O
struct	O
argp_option	O
[	O
]	O
)	O
{	O
{	O
"update"	*(char)
,	O
'u'	O
,	O
NULL	O
,	O
0	int
,	O
"remount; for procfs this does nothing"	*(char)
}	O
,	O
{	O
}	O
,	O
}	O
,	O
.	O
parser	O
=	O
runtime_argp_parser	(int,*(char),*(struct))->(int)
,	O
}	O
;	O
struct	O
argp	struct
netfs_runtime_argp_	struct
=	O
{	O
.	O
options	O
=	O
common_options	int
,	O
.	O
parser	O
=	O
argp_parser	(int,*(char),*(struct))->(int)
,	O
.	O
doc	O
=	O
"A virtual filesystem emulating the Linux procfs."	*(char)
,	O
.	O
children	O
=	O
(	O
struct	O
argp_child	O
[	O
]	O
)	O
{	O
{	O
&	O
runtime_argp	struct
,	O
}	O
,	O
{	O
&	O
netfs_std_runtime_argp	O
,	O
}	O
,	O
{	O
}	O
}	O
,	O
}	O
;	O
struct	O
argp	struct
*	O
netfs_runtime_argp	*(struct)
=	O
&	O
netfs_runtime_argp_	struct
;	O
error_t	O
netfs_append_args	(*(*(char)),*(int))->(int)
(	O
char	O
*	O
*	O
argz	*(*(char))
,	O
size_t	O
*	O
argz_len	*(int)
)	O
{	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
error_t	O
err	O
=	O
0	int
;	O
FOPT	O
(	O
opt_clk_tck	int
,	O
OPT_CLK_TCK	O
,	O
"--clk-tck=%d"	*(char)
,	O
opt_clk_tck	int
)	O
;	O
FOPT	O
(	O
opt_stat_mode	int
,	O
OPT_STAT_MODE	int
,	O
"--stat-mode=%o"	*(char)
,	O
opt_stat_mode	int
)	O
;	O
FOPT	O
(	O
opt_fake_self	int
,	O
OPT_FAKE_SELF	O
,	O
"--fake-self=%d"	*(char)
,	O
opt_fake_self	int
)	O
;	O
FOPT	O
(	O
opt_anon_owner	int
,	O
OPT_ANON_OWNER	int
,	O
"--anonymous-owner=%d"	*(char)
,	O
opt_anon_owner	int
)	O
;	O
FOPT	O
(	O
opt_kernel_pid	int
,	O
OPT_KERNEL_PID	O
,	O
"--kernel-process=%d"	*(char)
,	O
opt_kernel_pid	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
netfs_append_std_options	()->(int)
(	O
argz	*(*(char))
,	O
argz_len	*(int)
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
netfs_get_source	(*(struct),*(char),int)->(int)
(	O
struct	O
protid	O
*	O
cred	*(struct)
,	O
char	O
*	O
source	*(char)
,	O
size_t	O
source_len	int
)	O
{	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
snprintf	O
(	O
source	*(char)
,	O
source_len	int
,	O
"proc"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
root_make_node	(*(struct),*(*(struct)))->(int)
(	O
struct	O
ps_context	O
*	O
pc	*(struct)
,	O
struct	O
node	O
*	O
*	O
np	*(*(struct))
)	O
{	O
struct	O
node	O
*	O
root_dirs	array(*(struct))
[	O
]	O
=	O
{	O
proclist_make_node	()->(int)
(	O
pc	*(struct)
)	O
,	O
rootdir_make_node	()->(int)
(	O
pc	*(struct)
)	O
,	O
}	O
;	O
*	O
np	*(*(struct))
=	O
dircat_make_node	()->(int)
(	O
root_dirs	array(*(struct))
,	O
sizeof	O
root_dirs	array(*(struct))
/	O
sizeof	O
root_dirs	array(*(struct))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
*	O
np	*(*(struct))
)	O
return	O
ENOMEM	O
;	O
(	O
*	O
np	*(*(struct))
)	O
->	O
nn_stat	O
.	O
st_ino	O
=	O
*	O
(	O
uint32_t	O
*	O
)	O
"PROC"	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
ps_context	O
*	O
pc	*(struct)
;	O
mach_port_t	O
bootstrap	O
;	O
error_t	O
err	O
;	O
opt_clk_tck	int
=	O
OPT_CLK_TCK	O
;	O
opt_stat_mode	int
=	O
OPT_STAT_MODE	int
;	O
opt_fake_self	int
=	O
OPT_FAKE_SELF	O
;	O
opt_kernel_pid	int
=	O
OPT_KERNEL_PID	O
;	O
opt_anon_owner	int
=	O
OPT_ANON_OWNER	int
;	O
err	O
=	O
argp_parse	()->(int)
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
error	()->(int)
(	O
1	int
,	O
err	O
,	O
"Could not parse command line"	*(char)
)	O
;	O
err	O
=	O
ps_context_create	()->(int)
(	O
getproc	()->(int)
(	O
)	O
,	O
&	O
pc	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
error	()->(int)
(	O
1	int
,	O
err	O
,	O
"Could not create libps context"	*(char)
)	O
;	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
if	O
(	O
bootstrap	O
==	O
MACH_PORT_NULL	O
)	O
error	()->(int)
(	O
1	int
,	O
0	int
,	O
"Must be started as a translator"	*(char)
)	O
;	O
netfs_init	()->(int)
(	O
)	O
;	O
err	O
=	O
root_make_node	(*(struct),*(*(struct)))->(int)
(	O
pc	*(struct)
,	O
&	O
netfs_root_node	O
)	O
;	O
if	O
(	O
err	O
)	O
error	()->(int)
(	O
1	int
,	O
err	O
,	O
"Could not create the root node"	*(char)
)	O
;	O
netfs_startup	()->(int)
(	O
bootstrap	O
,	O
0	int
)	O
;	O
netfs_server_loop	()->(int)
(	O
)	O
;	O
assert	()->(int)
(	O
0	int
)	O
;	O
}	O
