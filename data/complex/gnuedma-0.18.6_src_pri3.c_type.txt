extern	O
EUint32	long
EDMAEnd	()->(long)
(	O
)	O
;	O
EPVoid	*(void)
EDMAPROC	O
edma_get_data_ref	(long)->(*(void))
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_data_ref"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
(	O
EPVoid	*(void)
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
;	O
}	O
static	O
ESint32	long
EDMAPROC	O
_edma_check_suicide	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
&&	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
==	O
OBJ_DIE	int
)	O
{	O
if	O
(	O
!	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
)	O
edma_free_obj	(long)->(long)
(	O
IdObj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_met3	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
...	O
)	O
{	O
va_list	*(char)
p	*(char)
;	O
ESint32	long
ret_val	long
;	O
ESint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_obj_id1	(long,*(char),*(char))->(long)
(	O
IdObj	long
,	O
"edma_met3"	*(char)
,	O
Id1	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_met3] Invalid Method Name (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
last_checked_update	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
time_last_update	long
)	O
edma_hotswap	(*(char))->(long)
(	O
NULL	O
)	O
;	O
va_start	O
(	O
p	*(char)
,	O
Id1	*(char)
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
++	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
>=	O
MAX_RECURSION	int
)	O
{	O
va_end	O
(	O
p	*(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"FATAL ERROR :: [edma_met3] %ld recursion level achieved. "	*(char)
"Probably, there is a cycle in your class diagram.\n"	*(char)
"            Method %s on object %ld <%s> not executed\n"	*(char)
"**** ABORTING execution"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"==== DEBUG: Max Recursion Level Object List ="	*(char)
"========================"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMaxObj	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
i	long
]	O
!=	O
NULL	O
)	O
if	O
(	O
gObj	O
[	O
i	long
]	O
->	O
rlevel	long
>	O
MAX_RECURSION	int
-	O
MAX_RECURSION	int
*	O
0.1	int
)	O
edma_printf	(*(char))->(long)
(	O
"--> Object %05ld [%05ld] <%-30s> Recursion: %05ld. "	*(char)
"Last Method: '%s'"	*(char)
,	O
i	long
,	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
,	O
gClass	O
[	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gObj	O
[	O
i	long
]	O
->	O
rlevel	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
gObj	O
[	O
i	long
]	O
->	O
last_met	long
]	O
.	O
IdMet	array(char)
)	O
;	O
}	O
edma_printf	(*(char))->(long)
(	O
"======================================"	*(char)
"========================\n"	*(char)
)	O
;	O
EDMAEnd	()->(long)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret_val	long
=	O
edma_met3_pargs	(long,*(char),*(char),long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
NULL	O
,	O
1	int
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
--	O
;	O
_edma_check_suicide	(long)->(long)
(	O
IdObj	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_met3s	(long,*(char),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EPChar	*(char)
Sig	array(char)
,	O
...	O
)	O
{	O
va_list	*(char)
p	*(char)
;	O
ESint32	long
ret_val	long
;	O
ESint32	long
i	long
,	O
len	long
,	O
npar	long
;	O
EChar	char
sig_ext	array(char)
[	O
EDMA_MET_SIG_LEN	int
]	O
,	O
*	O
src	*(char)
,	O
*	O
dest	*(char)
;	O
OBJID	long
sObj	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_met3s"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_met3s] Invalid Method Name (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
last_checked_update	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
time_last_update	long
)	O
edma_hotswap	(*(char))->(long)
(	O
NULL	O
)	O
;	O
va_start	O
(	O
p	*(char)
,	O
Sig	array(char)
)	O
;	O
src	*(char)
=	O
Sig	array(char)
;	O
dest	*(char)
=	O
sig_ext	array(char)
;	O
npar	long
=	O
0	int
;	O
while	O
(	O
*	O
src	*(char)
!=	O
0	int
)	O
{	O
switch	O
(	O
*	O
src	*(char)
)	O
{	O
case	O
'L'	O
:	O
{	O
src	*(char)
++	O
;	O
while	O
(	O
*	O
src	*(char)
!=	O
';'	O
&&	O
*	O
src	*(char)
!=	O
0	int
)	O
{	O
*	O
dest	*(char)
=	O
*	O
src	*(char)
;	O
dest	*(char)
++	O
;	O
src	*(char)
++	O
;	O
}	O
dest	*(char)
--	O
;	O
break	O
;	O
}	O
case	O
'X'	O
:	O
{	O
sObj	long
=	O
(	O
OBJID	long
)	O
(	O
*	O
(	O
(	O
EPUint32	*(long)
)	O
p	*(char)
+	O
npar	long
)	O
)	O
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
sObj	long
,	O
"edma_met3s"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
len	long
=	O
strlen	(*(char))->(int)
(	O
gClass	O
[	O
gObj	O
[	O
sObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dest	*(char)
,	O
gClass	O
[	O
gObj	O
[	O
sObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
len	long
--	O
;	O
dest	*(char)
+=	O
len	long
;	O
break	O
;	O
}	O
default	O
:	O
{	O
*	O
dest	*(char)
=	O
*	O
src	*(char)
;	O
break	O
;	O
}	O
}	O
npar	long
++	O
;	O
dest	*(char)
++	O
;	O
src	*(char)
++	O
;	O
}	O
*	O
dest	*(char)
=	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
++	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
>=	O
MAX_RECURSION	int
)	O
{	O
va_end	O
(	O
p	*(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"FATAL ERROR :: [edma_met3] %ld recursion level achieved. "	*(char)
"Probably, there is a cycle in your class diagram.\n"	*(char)
"            Method %s on object %ld <%s> not executed\n"	*(char)
"**** ABORTING execution"	*(char)
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
,	O
Id1	*(char)
,	O
IdObj	long
,	O
gClass	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf	(*(char))->(long)
(	O
"==== DEBUG: Max Recursion Level Object List ====="	*(char)
"===================="	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMaxObj	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
i	long
]	O
!=	O
NULL	O
)	O
if	O
(	O
gObj	O
[	O
i	long
]	O
->	O
rlevel	long
>	O
MAX_RECURSION	int
-	O
MAX_RECURSION	int
*	O
0.1	int
)	O
edma_printf	(*(char))->(long)
(	O
"--> Object %05ld [%05ld] <%-30s> Recursion: %05ld. "	*(char)
"Last Method: '%s'"	*(char)
,	O
i	long
,	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
,	O
gClass	O
[	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gObj	O
[	O
i	long
]	O
->	O
rlevel	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
gObj	O
[	O
i	long
]	O
->	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
gObj	O
[	O
i	long
]	O
->	O
last_met	long
]	O
.	O
IdMet	array(char)
)	O
;	O
}	O
edma_printf	(*(char))->(long)
(	O
"======================================================"	*(char)
"========\n"	*(char)
)	O
;	O
EDMAEnd	()->(long)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret_val	long
=	O
edma_met3_pargs	(long,*(char),*(char),long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
sig_ext	array(char)
,	O
1	int
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
rlevel	long
--	O
;	O
_edma_check_suicide	(long)->(long)
(	O
IdObj	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_wprop3	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
...	O
)	O
{	O
va_list	*(char)
p	*(char)
;	O
ESint32	long
ret_val	long
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_wprop3] Invalid Property Name (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
p	*(char)
,	O
Id1	*(char)
)	O
;	O
ret_val	long
=	O
edma_wprop3_pargs	(long,*(char),*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_rprop3	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
...	O
)	O
{	O
va_list	*(char)
p	*(char)
;	O
ESint32	long
r	long
;	O
if	O
(	O
Id1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_wprop3] Invalid Property Name (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
p	*(char)
,	O
Id1	*(char)
)	O
;	O
r	long
=	O
edma_rprop3_pargs	(long,*(char),*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
return	O
r	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_sint32	(long,*(char),long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
ESint32	long
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_uint32	(long,*(char),long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EUint32	long
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_sint16	(long,*(char),short)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
ESint16	short
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_uint16	(long,*(char),short)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EUint16	short
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_sint8	(long,*(char),char)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
ESint8	char
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_uint8	(long,*(char),char)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EUint8	char
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_strz	(long,*(char),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EPChar	*(char)
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_prop_obj	(long,*(char),long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
OBJID	long
val	long
)	O
{	O
ESint32	long
ret_val	long
;	O
ret_val	long
=	O
edma_wprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
ret_val	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_sint32	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
ESint32	long
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_prop_uint32	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
EUint32	long
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
ESint16	short
EDMAPROC	O
edma_get_prop_sint16	(long,*(char))->(short)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
ESint16	short
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
EUint16	short
EDMAPROC	O
edma_get_prop_uint16	(long,*(char))->(short)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
EUint16	short
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
ESint8	char
EDMAPROC	O
edma_get_prop_sint8	(long,*(char))->(char)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
ESint8	char
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
EUint8	char
EDMAPROC	O
edma_get_prop_uint8	(long,*(char))->(char)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
EUint8	char
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_prop_strz	(long,*(char),*(char))->(*(char))
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EPChar	*(char)
val	long
)	O
{	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
EDMAPROC	O
edma_get_prop_buffer	(long,*(char),*(struct(long,long,*(void))))->(*(struct(long,long,*(void))))
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
,	O
EDMAT_BUFFER	struct(long,long,*(void))
*	O
buf	*(struct(long,long,*(void)))
)	O
{	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
buf	*(struct(long,long,*(void)))
)	O
;	O
return	O
buf	*(struct(long,long,*(void)))
;	O
}	O
OBJID	long
EDMAPROC	O
edma_get_prop_obj	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
Id1	*(char)
)	O
{	O
OBJID	long
val	long
;	O
edma_rprop3	(long,*(char))->(long)
(	O
IdObj	long
,	O
Id1	*(char)
,	O
&	O
val	long
)	O
;	O
return	O
val	long
;	O
}	O
