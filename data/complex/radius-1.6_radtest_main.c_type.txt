const	O
char	O
*	O
argp_program_version	*(char)
=	O
"radtest ("	*(char)
PACKAGE	*(char)
") "	*(char)
VERSION	*(char)
;	O
static	O
char	O
doc	*(char)
[	O
]	O
=	O
N_	O
(	O
"Radius client shell"	*(char)
)	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"radtest specific switches:"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"assign"	*(char)
,	O
'a'	O
,	O
N_	O
(	O
"VARIABLE=VALUE"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"assign a VALUE to VARIABLE"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"debug"	*(char)
,	O
'x'	O
,	O
"DEBUGSPEC"	*(char)
,	O
0	int
,	O
N_	O
(	O
"set debugging level"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"file"	*(char)
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Read input from FILE. Stops further processing of the command line."	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"quick"	*(char)
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
"Do not read the configuration file"	*(char)
,	O
0	int
}	O
,	O
{	O
"retry"	*(char)
,	O
'r'	O
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set number of retries"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"server"	*(char)
,	O
's'	O
,	O
N_	O
(	O
"SERVER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set radius server parameters"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"timeout"	*(char)
,	O
't'	O
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set timeout"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"verbose mode"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"no-interactive"	*(char)
,	O
'i'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable interactive mode"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"dry-run"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Check the input file syntax and exit"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
verbose	int
;	O
int	O
quick	int
=	O
0	int
;	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
char	O
*	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
NULL	O
;	O
int	O
retry	int
=	O
0	int
;	O
int	O
timeout	int
=	O
0	int
;	O
int	O
disable_readline	int
;	O
int	O
dry_run	int
;	O
static	O
void	O
assign	(*(char))->(void)
(	O
char	O
*	O
s	*(*(char))
)	O
{	O
char	O
*	O
p	*(struct)
;	O
radtest_variable_t	struct
*	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
;	O
radtest_datum_t	union
datum	union(int,struct(long,*(char)))
;	O
radtest_data_type	enum(int,int,int,int,int,int,int)
type	int
=	O
rtv_undefined	int
;	O
p	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
s	*(*(char))
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"assign: expected `='\n"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
*	O
p	*(struct)
++	O
=	O
0	int
;	O
type	int
=	O
parse_datum	(*(char),*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(enum(int,int,int,int,int,int,int))
(	O
p	*(struct)
,	O
&	O
datum	union(int,struct(long,*(char)))
)	O
;	O
if	O
(	O
type	int
==	O
rtv_undefined	int
)	O
return	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
s	*(*(char))
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
=	O
type	int
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
=	O
datum	union(int,struct(long,*(char)))
;	O
}	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
assign	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
quick	int
++	O
;	O
break	O
;	O
case	O
'r'	O
:	O
retry	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
server	*(struct(*(char),int,array(int),*(char),long))
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'f'	O
:	O
filename	*(char)
=	O
arg	*(char)
;	O
*	O
(	O
int	O
*	O
)	O
state	*(int)
->	O
input	*(void)
=	O
state	*(int)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
state	*(int)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
state	*(int)
->	O
argc	int
;	O
break	O
;	O
case	O
'i'	O
:	O
disable_readline	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
dry_run	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
timeout	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
grad_set_debug_levels	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
grad_set_module_debug_level	(*(char),int)->(int)
(	O
"radpdu"	*(char)
,	O
100	int
)	O
;	O
grad_set_module_debug_level	(*(char),int)->(int)
(	O
"client"	*(char)
,	O
100	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
doc	*(char)
,	O
grad_common_argp_child	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
radtest_parse_options	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
return	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
ARGP_NO_EXIT	int
,	O
NULL	O
,	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
grad_server_queue_t	struct(int,int,int,long,*(struct))
*	O
srv_queue	*(struct(int,int,int,long,*(struct)))
;	O
grad_symtab_t	struct(int,int,int,*(*(struct(*(struct`),*(char)))),*(()->(int)))
*	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
;	O
grad_symtab_t	struct(int,int,int,*(*(struct(*(struct`),*(char)))),*(()->(int)))
*	O
functab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
;	O
int	O
reply_code	int
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_list_t	struct
*	O
toplevel_env	*(struct)
;	O
static	O
void	O
init_symbols	()->(void)
(	O
)	O
{	O
radtest_variable_t	struct
*	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
;	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
=	O
grad_symtab_create	(int,*(()->(int)))->(*(struct(int,int,int,*(*(struct`)),*(()->(int)))))
(	O
sizeof	O
(	O
radtest_variable_t	struct
)	O
,	O
NULL	O
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"REPLY_CODE"	*(char)
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
=	O
rtv_integer	int
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"REPLY"	*(char)
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
=	O
rtv_avl	int
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"SOURCEIP"	*(char)
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
=	O
rtv_ipaddress	int
;	O
functab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
=	O
grad_symtab_create	(int,*(()->(int)))->(*(struct(int,int,int,*(*(struct`)),*(()->(int)))))
(	O
sizeof	O
(	O
radtest_function_t	struct
)	O
,	O
NULL	O
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
p	*(struct)
;	O
int	O
index	(*(char),int)->(*(char))
,	O
argind	int
;	O
radtest_variable_t	struct
*	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
;	O
grad_app_setup	()->(void)
(	O
)	O
;	O
init_symbols	()->(void)
(	O
)	O
;	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
if	O
(	O
grad_argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(int),array(*(*(char))),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
,	O
ARGP_IN_ORDER	int
,	O
&	O
argind	int
,	O
&	O
index	(*(char),int)->(*(char))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
index	(*(char),int)->(*(char))
==	O
0	int
)	O
index	(*(char),int)->(*(char))
=	O
argind	int
;	O
argv	*(*(char))
+=	O
index	(*(char),int)->(*(char))
;	O
argc	int
-=	O
index	(*(char),int)->(*(char))
;	O
set_yydebug	()->(void)
(	O
)	O
;	O
grad_path_init	()->(void)
(	O
)	O
;	O
srand	(int)->(void)
(	O
time	struct(long,long)
(	O
NULL	O
)	O
+	O
getpid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
grad_dict_init	()->(int)
(	O
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"error reading dictionary file"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
srv_queue	*(struct(int,int,int,long,*(struct)))
=	O
grad_client_create_queue	(int,int,long)->(*(struct(int,int,int,long,*(struct))))
(	O
!	O
quick	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
srv_queue	*(struct(int,int,int,long,*(struct)))
)	O
return	O
1	int
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"SOURCEIP"	*(char)
)	O
;	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
ipaddr	int
=	O
srv_queue	*(struct(int,int,int,long,*(struct)))
->	O
source_ip	int
;	O
if	O
(	O
timeout	int
)	O
srv_queue	*(struct(int,int,int,long,*(struct)))
->	O
timeout	int
=	O
timeout	int
;	O
if	O
(	O
retry	int
)	O
srv_queue	*(struct(int,int,int,long,*(struct)))
->	O
retries	int
=	O
retry	int
;	O
if	O
(	O
server	*(struct(*(char),int,array(int),*(char),long))
)	O
{	O
grad_server_t	struct
serv	struct(*(char),int,array(int),*(char),long)
;	O
int	O
i	int
,	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
if	O
(	O
grad_argcv_get	(*(char),*(char),*(char),*(int),*(*(*(char))))->(int)
(	O
server	*(struct(*(char),int,array(int),*(char),long))
,	O
":"	*(char)
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't parse server definition"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
<	O
3	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"no shared secret for the server"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
serv	struct(*(char),int,array(int),*(char),long)
,	O
0	int
,	O
sizeof	O
serv	struct(*(char),int,array(int),*(char),long)
)	O
;	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
name	*(char)
=	O
"default"	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
0	int
:	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
addr	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
addr	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad IP address or host name: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
secret	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
break	O
;	O
case	O
4	int
:	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
0	int
]	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad port number %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
1	int
]	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad port number %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
!=	O
':'	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad separator near %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
0	int
]	O
=	O
DEF_AUTH_PORT	int
;	O
if	O
(	O
argc	int
<	O
6	int
)	O
serv	struct(*(char),int,array(int),*(char),long)
.	O
port	array(int)
[	O
1	int
]	O
=	O
DEF_ACCT_PORT	int
;	O
grad_client_append_server	(*(struct(int,int,int,long,*(struct))),*(struct(*(char),int,array(int),*(char),long)))->(void)
(	O
srv_queue	*(struct(int,int,int,long,*(struct)))
,	O
grad_client_alloc_server	(*(struct(*(char),int,array(int),*(char),long)))->(*(struct(*(char),int,array(int),*(char),long)))
(	O
&	O
serv	struct(*(char),int,array(int),*(char),long)
)	O
)	O
;	O
grad_argcv_free	(int,*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
}	O
if	O
(	O
grad_list_count	(*(struct))->(long)
(	O
srv_queue	*(struct(int,int,int,long,*(struct)))
->	O
servers	*(struct)
)	O
==	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"No servers specfied. Use -s option.\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
toplevel_env	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
radtest_env_add_string	(*(struct),*(char))->(void)
(	O
toplevel_env	*(struct)
,	O
filename	*(char)
?	O
filename	*(char)
:	O
""	*(char)
)	O
;	O
for	O
(	O
;	O
argc	int
;	O
argv	*(*(char))
++	O
,	O
argc	int
--	O
)	O
{	O
if	O
(	O
(	O
p	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
argv	*(*(char))
,	O
'='	O
)	O
)	O
!=	O
NULL	O
&&	O
!	O
(	O
p	*(struct)
>	O
*	O
argv	*(*(char))
&&	O
p	*(struct)
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
)	O
assign	(*(char))->(void)
(	O
*	O
argv	*(*(char))
)	O
;	O
else	O
radtest_env_add_string	(*(struct),*(char))->(void)
(	O
toplevel_env	*(struct)
,	O
*	O
argv	*(*(char))
)	O
;	O
}	O
return	O
read_and_eval	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
}	O
radtest_data_type	enum(int,int,int,int,int,int,int)
parse_datum	(*(char),*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(enum(int,int,int,int,int,int,int))
(	O
char	O
*	O
p	*(struct)
,	O
radtest_datum_t	union
*	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
{	O
radtest_data_type	enum(int,int,int,int,int,int,int)
type	int
=	O
rtv_undefined	int
;	O
int	O
length	short
;	O
if	O
(	O
*	O
p	*(struct)
==	O
'"'	O
)	O
{	O
length	short
=	O
strlen	(*(char))->(long)
(	O
++	O
p	*(struct)
)	O
;	O
if	O
(	O
length	short
==	O
0	int
||	O
p	*(struct)
[	O
length	short
-	O
1	int
]	O
!=	O
'"'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"assign: missing closing quote\n"	*(char)
)	O
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
p	*(struct)
[	O
length	short
-	O
1	int
]	O
=	O
0	int
;	O
type	int
=	O
rtv_string	int
;	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
string	*(*(char))
=	O
grad_estrdup	(*(char))->(*(char))
(	O
p	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
p	*(struct)
)	O
)	O
{	O
char	O
*	O
endp	*(*(char))
;	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
number	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(struct)
,	O
&	O
endp	*(*(char))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	*(*(char))
==	O
0	int
)	O
{	O
type	int
=	O
rtv_integer	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
ipaddr	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
p	*(struct)
)	O
)	O
!=	O
0	int
)	O
type	int
=	O
rtv_ipaddress	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"assign: invalid IP address: %s\n"	*(char)
)	O
,	O
p	*(struct)
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
p	*(struct)
,	O
'.'	O
)	O
)	O
{	O
if	O
(	O
(	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
ipaddr	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
p	*(struct)
)	O
)	O
!=	O
0	int
)	O
type	int
=	O
rtv_ipaddress	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"assign: invalid IP address: %s\n"	*(char)
)	O
,	O
p	*(struct)
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
}	O
else	O
{	O
type	int
=	O
rtv_string	int
;	O
dp	*(union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
string	*(*(char))
=	O
grad_estrdup	(*(char))->(*(char))
(	O
p	*(struct)
)	O
;	O
}	O
return	O
type	int
;	O
}	O
void	O
print_pairs	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
for	O
(	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
char	O
*	O
save	*(*(char))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
" %s"	*(char)
,	O
grad_format_pair	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(*(char)))->(*(char))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
1	int
,	O
&	O
save	*(*(char))
)	O
)	O
;	O
free	(*(void))->(void)
(	O
save	*(*(char))
)	O
;	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
","	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
" "	*(char)
)	O
;	O
}	O
}	O
void	O
var_print	(*(struct(*(struct(*`,*`)),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*`,int),*(struct`),*(struct`)))))->(void)
(	O
radtest_variable_t	struct
*	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
)	O
{	O
char	O
buf	*(char)
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
if	O
(	O
!	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
)	O
return	O
;	O
switch	O
(	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
)	O
{	O
case	O
rtv_undefined	int
:	O
printf	(*(char))->(int)
(	O
"UNDEFINED"	*(char)
)	O
;	O
break	O
;	O
case	O
rtv_integer	int
:	O
printf	(*(char))->(int)
(	O
"%ld"	*(char)
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
)	O
;	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
ipaddr	int
,	O
buf	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
rtv_bstring	int
:	O
{	O
int	O
len	int
=	O
grad_format_string_visual	(*(char),int,*(char),int)->(int)
(	O
NULL	O
,	O
3	int
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
bstring	struct(*(char),int)
.	O
ptr	*(*(void))
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
bstring	struct(*(char),int)
.	O
length	short
)	O
;	O
char	O
*	O
pbuf	*(char)
=	O
grad_emalloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
grad_format_string_visual	(*(char),int,*(char),int)->(int)
(	O
pbuf	*(char)
,	O
3	int
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
bstring	struct(*(char),int)
.	O
ptr	*(*(void))
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
bstring	struct(*(char),int)
.	O
length	short
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
pbuf	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
pbuf	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
rtv_string	int
:	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
string	*(*(char))
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
printf	(*(char))->(int)
(	O
"("	*(char)
)	O
;	O
print_pairs	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
printf	(*(char))->(int)
(	O
")"	*(char)
)	O
;	O
break	O
;	O
case	O
rtv_pairlist	int
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
int	O
var_free	(*(struct(*(struct(*`,*`)),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*`,int),*(struct`),*(struct`)))))->(int)
(	O
radtest_variable_t	struct
*	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
)	O
{	O
switch	O
(	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
grad_free	(*(void))->(void)
(	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
string	*(*(char))
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
var	*(struct(*(struct(*(struct`),*(char))),*(char),enum(int,int,int,int,int,int,int),union(long,int,*(char),struct(*(char),int),*(struct),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
->	O
datum	union(int,struct(long,*(char)))
.	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radtest_send	(int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(struct(int,int,int,*(*(struct`)),*(()->(int)))))->(void)
(	O
int	O
port	array(int)
,	O
int	O
code	char
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_symtab_t	struct(int,int,int,*(*(struct(*(struct`),*(char)))),*(()->(int)))
*	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
)	O
{	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
radtest_variable_t	struct
*	O
p	*(struct)
;	O
if	O
(	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
reply_code	int
=	O
0	int
;	O
if	O
(	O
!	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
)	O
{	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_client_send	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
srv_queue	*(struct(int,int,int,long,*(struct)))
,	O
port	array(int)
,	O
code	char
,	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
}	O
else	O
{	O
int	O
id	char
;	O
u_char	char
authenticator	array(char)
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
int	O
sflags	int
=	O
0	int
;	O
int	O
retry	int
=	O
1	int
;	O
radtest_variable_t	struct
*	O
delay	long
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"delay"	*(char)
)	O
;	O
p	*(struct)
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"repeat"	*(char)
)	O
;	O
if	O
(	O
p	*(struct)
)	O
retry	int
=	O
p	*(struct)
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
;	O
p	*(struct)
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"id"	*(char)
)	O
;	O
if	O
(	O
p	*(struct)
)	O
{	O
sflags	int
|=	O
RADCLT_ID	int
;	O
id	char
=	O
p	*(struct)
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
;	O
}	O
p	*(struct)
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
cntl	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"keepauth"	*(char)
)	O
;	O
if	O
(	O
p	*(struct)
&&	O
p	*(struct)
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
)	O
sflags	int
|=	O
RADCLT_AUTHENTICATOR	int
;	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_client_send0	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(int),*(char))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
srv_queue	*(struct(int,int,int,long,*(struct)))
,	O
port	array(int)
,	O
code	char
,	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
0	int
,	O
&	O
id	char
,	O
authenticator	array(char)
)	O
;	O
while	O
(	O
--	O
retry	int
)	O
{	O
if	O
(	O
delay	long
)	O
sleep	(int)->(int)
(	O
delay	long
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
)	O
;	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
grad_client_send0	(*(struct(int,int,int,long,*(struct))),int,int,*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(int),*(char))->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
srv_queue	*(struct(int,int,int,long,*(struct)))
,	O
port	array(int)
,	O
code	char
,	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
sflags	int
,	O
&	O
id	char
,	O
authenticator	array(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
return	O
;	O
reply_code	int
=	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
code	char
;	O
p	*(struct)
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"REPLY_CODE"	*(char)
)	O
;	O
p	*(struct)
->	O
type	int
=	O
rtv_integer	int
;	O
p	*(struct)
->	O
datum	union(int,struct(long,*(char)))
.	O
number	long
=	O
reply_code	int
;	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_client_decrypt_pairlist	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),*(char))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
grad_avl_dup	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
,	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
authenticator	array(char)
,	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
secret	*(char)
)	O
;	O
p	*(struct)
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
vartab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
"REPLY"	*(char)
)	O
;	O
p	*(struct)
->	O
type	int
=	O
rtv_avl	int
;	O
p	*(struct)
->	O
datum	union(int,struct(long,*(char)))
.	O
avl	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_request_free	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
auth	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
}	O
int	O
comp_op	(enum(int,int,int,int,int,int,int),int)->(int)
(	O
enum	O
grad_operator	enum(int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int)
,	O
int	O
result	*(struct)
)	O
{	O
switch	O
(	O
op	enum(int,int,int,int,int,int,int)
)	O
{	O
default	O
:	O
case	O
grad_operator_equal	int
:	O
if	O
(	O
result	*(struct)
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_not_equal	int
:	O
if	O
(	O
result	*(struct)
==	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_than	int
:	O
if	O
(	O
result	*(struct)
>=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_than	int
:	O
if	O
(	O
result	*(struct)
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_equal	int
:	O
if	O
(	O
result	*(struct)
>	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_equal	int
:	O
if	O
(	O
result	*(struct)
<	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
compare_lists	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(int)
(	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
int	O
result	*(struct)
=	O
0	int
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
reply	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avl_dup	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
reply_list	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
for	O
(	O
;	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
&&	O
result	*(struct)
==	O
0	int
;	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
p	*(struct)
,	O
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
NULL	O
;	O
if	O
(	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
attribute	int
>	O
255	int
)	O
continue	O
;	O
for	O
(	O
p	*(struct)
=	O
reply	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
p	*(struct)
&&	O
p	*(struct)
->	O
attribute	int
!=	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
attribute	int
;	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
p	*(struct)
,	O
p	*(struct)
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
-	O
1	int
;	O
switch	O
(	O
p	*(struct)
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
result	*(struct)
=	O
strcmp	(*(char),*(char))->(int)
(	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
p	*(struct)
->	O
avp_strvalue	O
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
result	*(struct)
=	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
-	O
p	*(struct)
->	O
avp_lvalue	O
;	O
break	O
;	O
default	O
:	O
result	*(struct)
=	O
-	O
1	int
;	O
}	O
result	*(struct)
=	O
comp_op	(enum(int,int,int,int,int,int,int),int)->(int)
(	O
sample	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
operator	enum(int,int,int,int,int,int,int)
,	O
result	*(struct)
)	O
;	O
if	O
(	O
result	*(struct)
==	O
0	int
)	O
{	O
if	O
(	O
!	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
reply	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
else	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_avp_free	()->(void)
(	O
p	*(struct)
)	O
;	O
}	O
}	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
reply	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
return	O
result	*(struct)
;	O
}	O
