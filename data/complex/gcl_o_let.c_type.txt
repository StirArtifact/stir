void	O
let_var_list	(int)->(void)
(	O
object	O
var_list	int
)	O
{	O
object	O
x	O
,	O
y	O
;	O
for	O
(	O
x	O
=	O
var_list	int
;	O
!	O
endp	()->(int)
(	O
x	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
y	O
=	O
x	O
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
type_of	()->(int)
(	O
y	O
)	O
==	O
t_symbol	O
)	O
{	O
check_var	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
endp	()->(int)
(	O
y	O
)	O
;	O
check_var	()->(int)
(	O
y	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
y	O
=	O
y	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
y	O
)	O
)	O
;	O
else	O
if	O
(	O
!	O
endp	()->(int)
(	O
y	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
FEerror	()->(int)
(	O
"Too many initial forms to the variable ~S."	*(char)
,	O
1	int
,	O
vs_top	O
[	O
-	O
2	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Flet	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
body	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	O
*	O
old_lex	O
;	O
bds_ptr	O
old_bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEerror	()->(int)
(	O
"No argument to LET."	*(char)
,	O
0	int
)	O
;	O
old_lex	O
=	O
lex_env	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	(int)->(void)
(	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	O
=	O
let_bind	()->(int)
(	O
form	int
->	O
c	O
.	O
c_cdr	O
,	O
start	*(struct)
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	O
*	O
)	O
start	*(struct)
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
Fprogn	()->(int)
(	O
body	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
FletA	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
body	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
object	O
*	O
old_lex	O
;	O
bds_ptr	O
old_bds_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEerror	()->(int)
(	O
"No argument to LET*."	*(char)
,	O
0	int
)	O
;	O
old_lex	O
=	O
lex_env	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	(int)->(void)
(	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	O
=	O
letA_bind	()->(int)
(	O
form	int
->	O
c	O
.	O
c_cdr	O
,	O
start	*(struct)
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	O
*	O
)	O
start	*(struct)
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
Fprogn	()->(int)
(	O
body	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fmultiple_value_bind	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
body	O
,	O
values_form	O
,	O
x	O
,	O
y	O
;	O
int	O
n	int
,	O
m	int
,	O
i	int
;	O
object	O
*	O
base	O
;	O
object	O
*	O
old_lex	O
;	O
bds_ptr	O
old_bds_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEerror	()->(int)
(	O
"No argument to MULTIPLE-VALUE-BIND."	*(char)
,	O
0	int
)	O
;	O
body	O
=	O
form	int
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
body	O
)	O
)	O
FEerror	()->(int)
(	O
"No values-form to MULTIPLE-VALUE-BIND."	*(char)
,	O
0	int
)	O
;	O
values_form	O
=	O
body	O
->	O
c	O
.	O
c_car	O
;	O
body	O
=	O
body	O
->	O
c	O
.	O
c_cdr	O
;	O
old_lex	O
=	O
lex_env	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
eval	()->(int)
(	O
values_form	O
)	O
;	O
base	O
=	O
vs_base	O
;	O
m	int
=	O
vs_top	O
-	O
vs_base	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
x	O
=	O
form	int
->	O
c	O
.	O
c_car	O
;	O
!	O
endp	()->(int)
(	O
x	O
)	O
;	O
n	int
++	O
,	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
y	O
=	O
x	O
->	O
c	O
.	O
c_car	O
;	O
check_var	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
y	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
{	O
object	O
*	O
vt	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
find_special	()->(int)
(	O
body	O
,	O
start	*(struct)
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vt	O
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
bind_var	()->(int)
(	O
start	*(struct)
[	O
i	int
]	O
.	O
bt_var	O
,	O
(	O
i	int
<	O
m	int
?	O
base	O
[	O
i	int
]	O
:	O
Cnil	O
)	O
,	O
start	*(struct)
[	O
i	int
]	O
.	O
bt_spp	O
)	O
;	O
body	O
=	O
vs_pop	O
;	O
vs_top	O
=	O
vs_base	O
=	O
base	O
;	O
vs_push	()->(int)
(	O
body	O
)	O
;	O
Fprogn	()->(int)
(	O
body	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fcompiler_let	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
body	O
;	O
object	O
*	O
old_lex	O
;	O
bds_ptr	O
old_bds_top	O
;	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
*	O
end	*(struct)
,	O
*	O
bt	*(struct)
;	O
if	O
(	O
endp	()->(int)
(	O
form	int
)	O
)	O
FEerror	()->(int)
(	O
"No argument to COMPILER-LET."	*(char)
,	O
0	int
)	O
;	O
body	O
=	O
form	int
->	O
c	O
.	O
c_cdr	O
;	O
old_lex	O
=	O
lex_env	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
start	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	(int)->(void)
(	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
end	*(struct)
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
eval_assign	()->(int)
(	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_init	O
)	O
;	O
}	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
bind_var	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
,	O
bt	*(struct)
->	O
bt_init	O
,	O
Ct	O
)	O
;	O
vs_top	O
=	O
(	O
object	O
*	O
)	O
start	*(struct)
;	O
Fprogn	()->(int)
(	O
body	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
bds_unwind	()->(int)
(	O
old_bds_top	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fflet	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
def_list	O
;	O
object	O
def	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
def_list	O
=	O
MMcar	()->(int)
(	O
args	int
)	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
def_list	O
)	O
)	O
{	O
def	O
=	O
MMcar	()->(int)
(	O
def_list	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
def	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
def	O
)	O
)	O
||	O
type_of	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
)	O
!=	O
t_symbol	O
)	O
FEerror	()->(int)
(	O
"~S~%is an illegal function definition in FLET."	*(char)
,	O
1	int
,	O
def	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex	O
[	O
2	int
]	O
,	O
def	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex	O
[	O
1	int
]	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex	O
[	O
0	int
]	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
sLlambda_block_closure	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_fun_bind	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
def_list	O
=	O
MMcdr	()->(int)
(	O
def_list	O
)	O
;	O
}	O
vs_push	()->(int)
(	O
find_special	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
;	O
Fprogn	()->(int)
(	O
vs_head	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Flabels	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
def_list	O
;	O
object	O
def	O
;	O
object	O
closure_list	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
def_list	O
=	O
MMcar	()->(int)
(	O
args	int
)	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
def_list	O
)	O
)	O
{	O
def	O
=	O
MMcar	()->(int)
(	O
def_list	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
def	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
def	O
)	O
)	O
||	O
type_of	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
)	O
!=	O
t_symbol	O
)	O
FEerror	()->(int)
(	O
"~S~%is an illegal function definition in LABELS."	*(char)
,	O
1	int
,	O
def	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex	O
[	O
2	int
]	O
,	O
def	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
Cnil	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
1	int
]	O
=	O
MMcons	()->(int)
(	O
top	O
[	O
0	int
]	O
,	O
top	O
[	O
1	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex	O
[	O
0	int
]	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
sLlambda_block_closure	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
lex_fun_bind	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
def_list	O
=	O
MMcdr	()->(int)
(	O
def_list	O
)	O
;	O
}	O
closure_list	O
=	O
top	O
[	O
1	int
]	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
closure_list	O
)	O
)	O
{	O
MMcaar	()->(int)
(	O
closure_list	O
)	O
=	O
lex_env	O
[	O
1	int
]	O
;	O
closure_list	O
=	O
MMcdr	()->(int)
(	O
closure_list	O
)	O
;	O
}	O
vs_push	()->(int)
(	O
find_special	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
;	O
Fprogn	()->(int)
(	O
vs_head	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fmacrolet	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
def_list	O
;	O
object	O
def	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
def_list	O
=	O
MMcar	()->(int)
(	O
args	int
)	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
while	O
(	O
!	O
endp	()->(int)
(	O
def_list	O
)	O
)	O
{	O
def	O
=	O
MMcar	()->(int)
(	O
def_list	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
def	O
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
def	O
)	O
)	O
||	O
type_of	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
)	O
!=	O
t_symbol	O
)	O
FEerror	()->(int)
(	O
"~S~%is an illegal macro definition in MACROFLET."	*(char)
,	O
1	int
,	O
def	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
ifuncall3	()->(int)
(	O
sSdefmacroA	O
,	O
MMcar	()->(int)
(	O
def	O
)	O
,	O
MMcadr	()->(int)
(	O
def	O
)	O
,	O
MMcddr	()->(int)
(	O
def	O
)	O
)	O
;	O
lex_macro_bind	()->(int)
(	O
MMcar	()->(int)
(	O
def	O
)	O
,	O
MMcaddr	()->(int)
(	O
top	O
[	O
0	int
]	O
)	O
)	O
;	O
def_list	O
=	O
MMcdr	()->(int)
(	O
def_list	O
)	O
;	O
}	O
vs_push	()->(int)
(	O
find_special	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
;	O
Fprogn	()->(int)
(	O
vs_head	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
}	O
void	O
gcl_init_let	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"LET"	*(char)
,	O
Flet	int
)	O
;	O
make_special_form	()->(int)
(	O
"LET*"	*(char)
,	O
FletA	int
)	O
;	O
make_special_form	()->(int)
(	O
"MULTIPLE-VALUE-BIND"	*(char)
,	O
Fmultiple_value_bind	int
)	O
;	O
make_special_form	()->(int)
(	O
"COMPILER-LET"	*(char)
,	O
Fcompiler_let	int
)	O
;	O
make_special_form	()->(int)
(	O
"FLET"	*(char)
,	O
Fflet	int
)	O
;	O
make_special_form	()->(int)
(	O
"LABELS"	*(char)
,	O
Flabels	int
)	O
;	O
make_special_form	()->(int)
(	O
"MACROLET"	*(char)
,	O
Fmacrolet	int
)	O
;	O
}	O
