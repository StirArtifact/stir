int	O
ov_env	int
=	O
1	int
,	O
ov_pipe	int
=	O
0	int
,	O
ov_asynch	int
=	O
0	int
;	O
int	O
ov_verbose	int
=	O
0	int
;	O
adns_rrtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
ov_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
adns_r_none	int
;	O
int	O
ov_search	int
=	O
0	int
,	O
ov_qc_query	int
=	O
0	int
,	O
ov_qc_anshost	int
=	O
0	int
,	O
ov_qc_cname	int
=	O
1	int
;	O
int	O
ov_tcp	int
=	O
0	int
,	O
ov_cname	int
=	O
0	int
,	O
ov_format	int
=	O
fmt_default	int
;	O
char	O
*	O
ov_id	*(char)
=	O
0	int
;	O
struct	O
perqueryflags_remember	struct(int,int,int,int)
ov_pqfr	struct(int,int,int,int)
=	O
{	O
1	int
,	O
1	int
,	O
1	int
,	O
tm_none	int
}	O
;	O
static	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
global_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
ot_desconly	int
,	O
"global binary options:"	*(char)
}	O
,	O
{	O
ot_flag	int
,	O
"Do not look at environment variables at all"	*(char)
,	O
"e"	*(char)
,	O
"env"	*(char)
,	O
&	O
ov_env	int
,	O
0	int
}	O
,	O
{	O
ot_flag	int
,	O
"Read queries on stdin instead of using args"	*(char)
,	O
"f"	*(char)
,	O
"pipe"	*(char)
,	O
&	O
ov_pipe	int
,	O
1	int
}	O
,	O
{	O
ot_flag	int
,	O
"Allow answers to be reordered"	*(char)
,	O
"a"	*(char)
,	O
"asynch"	*(char)
,	O
&	O
ov_asynch	int
,	O
1	int
}	O
,	O
{	O
ot_desconly	int
,	O
"answer/error output format and destination (see below):"	*(char)
}	O
,	O
{	O
ot_value	int
,	O
"Answers to stdout, errors as messages to stderr (default)"	*(char)
,	O
"Fs"	*(char)
,	O
"fmt-simple"	*(char)
,	O
&	O
ov_format	int
,	O
fmt_simple	int
}	O
,	O
{	O
ot_value	int
,	O
"Answers and errors both to stdout in parseable format"	*(char)
,	O
"Fi"	*(char)
,	O
"fmt-inline"	*(char)
,	O
&	O
ov_format	int
,	O
fmt_inline	int
}	O
,	O
{	O
ot_value	int
,	O
"Fully-parseable output format (default for --asynch)"	*(char)
,	O
"Fa"	*(char)
,	O
"fmt-asynch"	*(char)
,	O
&	O
ov_format	int
,	O
fmt_asynch	int
}	O
,	O
{	O
ot_desconly	int
,	O
"global verbosity level:"	*(char)
}	O
,	O
{	O
ot_value	int
,	O
"Do not print anything to stderr"	*(char)
,	O
"Vq"	*(char)
,	O
"quiet"	*(char)
,	O
&	O
ov_verbose	int
,	O
adns_if_noerrprint	int
}	O
,	O
{	O
ot_value	int
,	O
"Report unexpected kinds of problem only  (default)"	*(char)
,	O
"Vn"	*(char)
,	O
"no-quiet"	*(char)
,	O
&	O
ov_verbose	int
,	O
0	int
}	O
,	O
{	O
ot_value	int
,	O
"Debugging mode"	*(char)
,	O
"Vd"	*(char)
,	O
"debug"	*(char)
,	O
&	O
ov_verbose	int
,	O
adns_if_debug	int
}	O
,	O
{	O
ot_desconly	int
,	O
"other global options:"	*(char)
}	O
,	O
{	O
ot_funcarg	int
,	O
"Configuration to use instead of /etc/resolv.conf"	*(char)
,	O
0	int
,	O
"config"	*(char)
,	O
0	int
,	O
0	int
,	O
of_config	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"<config-text>"	*(char)
}	O
,	O
{	O
ot_func	int
,	O
"Print version number"	*(char)
,	O
0	int
,	O
"version"	*(char)
,	O
0	int
,	O
0	int
,	O
of_version	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
}	O
,	O
{	O
ot_func	int
,	O
"Print usage information"	*(char)
,	O
0	int
,	O
"help"	*(char)
,	O
0	int
,	O
0	int
,	O
of_help	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
}	O
,	O
{	O
ot_end	int
}	O
}	O
;	O
static	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
perquery_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
ot_desconly	int
,	O
"per-query options:"	*(char)
}	O
,	O
{	O
ot_funcarg	int
,	O
"Query type (see below)"	*(char)
,	O
"t"	*(char)
,	O
"type"	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
of_type	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"type"	*(char)
}	O
,	O
{	O
ot_funcarg	int
,	O
"Do reverse query (address -> name lookup)"	*(char)
,	O
"i"	*(char)
,	O
"ptr"	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
of_ptr	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"addr"	*(char)
}	O
,	O
{	O
ot_funcarg2	int
,	O
"Lookup in in-addr-like `zone' (eg MAPS RBL)"	*(char)
,	O
0	int
,	O
"reverse"	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
of_reverse	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"addr"	*(char)
,	O
"zone"	*(char)
}	O
,	O
{	O
ot_desconly	int
,	O
"per-query binary options:"	*(char)
}	O
,	O
{	O
ot_flag	int
,	O
"Use the search list"	*(char)
,	O
"s"	*(char)
,	O
"search"	*(char)
,	O
&	O
ov_search	int
,	O
1	int
}	O
,	O
{	O
ot_flag	int
,	O
"Let query domains contain quote-requiring chars"	*(char)
,	O
"Qq"	*(char)
,	O
"qc-query"	*(char)
,	O
&	O
ov_qc_query	int
,	O
1	int
}	O
,	O
{	O
ot_flag	int
,	O
"Let hostnames in answers contain ..."	*(char)
,	O
"Qa"	*(char)
,	O
"qc-anshost"	*(char)
,	O
&	O
ov_qc_anshost	int
,	O
1	int
}	O
,	O
{	O
ot_flag	int
,	O
"Prevent CNAME target domains from containing ..."	*(char)
,	O
"Qc"	*(char)
,	O
"qc-cname"	*(char)
,	O
&	O
ov_qc_cname	int
,	O
0	int
}	O
,	O
{	O
ot_flag	int
,	O
"Force use of a virtual circuit"	*(char)
,	O
"u"	*(char)
,	O
"tcp"	*(char)
,	O
&	O
ov_tcp	int
,	O
1	int
}	O
,	O
{	O
ot_flag	int
,	O
"Do not display owner name in output"	*(char)
,	O
"Do"	*(char)
,	O
"show-owner"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
show_owner	int
,	O
0	int
}	O
,	O
{	O
ot_flag	int
,	O
"Do not display RR type in output"	*(char)
,	O
"Dt"	*(char)
,	O
"show-type"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
show_type	int
,	O
0	int
}	O
,	O
{	O
ot_flag	int
,	O
"Do not display CNAME target in output"	*(char)
,	O
"Dc"	*(char)
,	O
"show-cname"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
show_cname	int
,	O
0	int
}	O
,	O
{	O
ot_desconly	int
,	O
"per-query TTL mode (NB TTL is minimum across all info in reply):"	*(char)
}	O
,	O
{	O
ot_value	int
,	O
"Show the TTL as a TTL"	*(char)
,	O
"Tt"	*(char)
,	O
"ttl-ttl"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
ttl	int
,	O
tm_rel	int
}	O
,	O
{	O
ot_value	int
,	O
"Show the TTL as a time_t when the data might expire"	*(char)
,	O
"Ta"	*(char)
,	O
"ttl-abs"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
ttl	int
,	O
tm_abs	int
}	O
,	O
{	O
ot_value	int
,	O
"Do not show the TTL (default)"	*(char)
,	O
"Tn"	*(char)
,	O
"no-ttl"	*(char)
,	O
&	O
ov_pqfr	struct(int,int,int,int)
.	O
ttl	int
,	O
tm_none	int
}	O
,	O
{	O
ot_desconly	int
,	O
"per-query CNAME handling mode:"	*(char)
}	O
,	O
{	O
ot_value	int
,	O
"Call it an error if a CNAME is found"	*(char)
,	O
"Cf"	*(char)
,	O
"cname-reject"	*(char)
,	O
&	O
ov_cname	int
,	O
adns_qf_cname_forbid	int
}	O
,	O
{	O
ot_value	int
,	O
"Allow references to CNAMEs in other RRs"	*(char)
,	O
"Cl"	*(char)
,	O
"cname-loose"	*(char)
,	O
&	O
ov_cname	int
,	O
adns_qf_cname_loose	int
}	O
,	O
{	O
ot_value	int
,	O
"CNAME ok for query domain, but not in RRs (default)"	*(char)
,	O
"Cs"	*(char)
,	O
"cname-ok"	*(char)
,	O
&	O
ov_cname	int
,	O
0	int
}	O
,	O
{	O
ot_desconly	int
,	O
"asynchronous/pipe mode options:"	*(char)
}	O
,	O
{	O
ot_funcarg	int
,	O
"Set <id>, default is decimal sequence starting 0"	*(char)
,	O
0	int
,	O
"asynch-id"	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
of_asynch_id	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"id"	*(char)
}	O
,	O
{	O
ot_funcarg	int
,	O
"Cancel the query with id <id> (no error if not found)"	*(char)
,	O
0	int
,	O
"cancel-id"	*(char)
,	O
0	int
,	O
0	int
,	O
&	O
of_cancel_id	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
,	O
"id"	*(char)
}	O
,	O
{	O
ot_end	int
}	O
}	O
;	O
static	O
void	O
printusage	()->(void)
(	O
void	O
)	O
{	O
static	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
const	O
all_optiontables	array(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char))))
[	O
]	O
=	O
{	O
global_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
,	O
perquery_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
,	O
0	int
}	O
;	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
const	O
*	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
,	O
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
0	int
;	O
int	O
maxsopt	int
,	O
maxlopt	int
,	O
l	int
;	O
maxsopt	int
=	O
maxlopt	int
=	O
0	int
;	O
for	O
(	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
=	O
all_optiontables	array(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char))))
;	O
*	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
;	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
++	O
)	O
{	O
for	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
*	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
ot_end	int
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
++	O
)	O
{	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_funcarg	int
)	O
continue	O
;	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
{	O
l	int
=	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
;	O
if	O
(	O
l	int
>	O
maxsopt	int
)	O
maxsopt	int
=	O
l	int
;	O
}	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
{	O
l	int
=	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
;	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_flag	int
&&	O
!	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
value	int
)	O
l	int
+=	O
3	int
;	O
if	O
(	O
l	int
>	O
maxlopt	int
)	O
maxlopt	int
=	O
l	int
;	O
}	O
}	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"usage: adnshost [global-opts] [query-opts] query-domain\n"	*(char)
"                             [[query-opts] query-domain ...]\n"	*(char)
"       adnshost [global-opts] [query-opts] -f|--pipe\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
=	O
all_optiontables	array(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char))))
;	O
*	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
;	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
++	O
)	O
{	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
for	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
*	O
oiap	*(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
ot_end	int
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
++	O
)	O
{	O
switch	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
ot_flag	int
:	O
if	O
(	O
!	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
value	int
)	O
{	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
" +%-*s --no-%-*s %s\n"	*(char)
,	O
maxsopt	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
,	O
maxlopt	int
-	O
2	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
" --no-%-*s %s\n"	*(char)
,	O
maxlopt	int
+	O
maxsopt	int
+	O
1	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
case	O
ot_value	int
:	O
case	O
ot_func	int
:	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
" -%-*s --%-*s %s\n"	*(char)
,	O
maxsopt	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
,	O
maxlopt	int
+	O
1	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
" --%-*s %s\n"	*(char)
,	O
maxlopt	int
+	O
maxsopt	int
+	O
3	int
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
ot_funcarg	int
:	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
{	O
l	int
=	O
(	O
maxlopt	int
+	O
maxsopt	int
-	O
9	int
-	O
(	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
+	O
2	int
*	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" -%s<%s> / --%s <%s>%*s%s\n"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
,	O
l	int
>	O
2	int
?	O
l	int
:	O
2	int
,	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
else	O
{	O
l	int
=	O
(	O
maxlopt	int
+	O
maxsopt	int
+	O
1	int
-	O
(	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" --%s <%s>%*s%s\n"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
,	O
l	int
>	O
2	int
?	O
l	int
:	O
2	int
,	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
ot_funcarg2	int
:	O
assert	O
(	O
!	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
;	O
l	int
=	O
(	O
maxlopt	int
+	O
maxsopt	int
-	O
2	int
-	O
(	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc2	*(char)
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" --%s <%s> <%s>%*s%s\n"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
argdesc2	*(char)
,	O
l	int
>	O
2	int
?	O
l	int
:	O
2	int
,	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
break	O
;	O
case	O
ot_desconly	int
:	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
desc	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
printf	(*(char))->(int)
(	O
"\nEscaping domains which might start with `-':\n"	*(char)
" - %-*s Next argument is a domain, but more options may follow\n"	*(char)
,	O
maxlopt	int
+	O
maxsopt	int
+	O
3	int
,	O
"<domain>"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
"Query domains should always be quoted according to master file format.\n"	*(char)
"\n"	*(char)
"For binary options, --FOO and --no-FOO are opposites, as are\n"	*(char)
"-X and +X.  In each case the default is the one not listed.\n"	*(char)
"Per query options stay set a particular way until they are reset,\n"	*(char)
"whether they appear on the command line or on stdin.\n"	*(char)
"All global options must preceed the first query domain.\n"	*(char)
"\n"	*(char)
"With -f, the input should be lines with either an option, possibly\n"	*(char)
"with a value argument (separated from the option by a space if it's a long\n"	*(char)
"option), or a domain (possibly preceded by a hyphen and a space to\n"	*(char)
"distinguish it from an option).\n"	*(char)
"\n"	*(char)
"Output format is master file format without class or TTL by default:\n"	*(char)
"   [<owner>] [<ttl>] [<type>] <data>\n"	*(char)
"or if the <owner> domain refers to a CNAME and --show-cname is on\n"	*(char)
"   [<owner>] [<ttl>] CNAME <cname>\n"	*(char)
"   [<cname>] [<ttl>] <type> <data>\n"	*(char)
"When a query fails you get an error message to stderr (with --fmt-simple).\n"	*(char)
"Specify --fmt-inline for lines like this (broken here for readability):\n"	*(char)
"   ; failed <statustype> <statusnum> <statusabbrev> \\\n"	*(char)
"       [<owner>] [<ttl>] [<cname>] \"<status string>\"\n"	*(char)
"If you use --fmt-asynch, which is the default for --asynch,\n"	*(char)
"each answer (success or failure) is preceded by a line\n"	*(char)
"   <id> <nrrs> <statustype> <statusnum> <statusabbrev> \\\n"	*(char)
"       [<owner>] [<ttl>] [<cname>] \"<status string>\"\n"	*(char)
"where <nrrs> is the number of RRs that follow and <cname> will be `$' or\n"	*(char)
"the CNAME target; the CNAME indirection and error formats above are not used.\n"	*(char)
"\n"	*(char)
"Exit status:\n"	*(char)
" 0    all went well\n"	*(char)
" 1-6  at least one query failed with statustype:\n"	*(char)
"   1    localfail   )\n"	*(char)
"   2    remotefail  ) temporary errors\n"	*(char)
"   3    tempfail  __)_________________\n"	*(char)
"   4    misconfig   )\n"	*(char)
"   5    misquery    ) permanent errors\n"	*(char)
"   6    permfail    )\n"	*(char)
" 10   system trouble\n"	*(char)
" 11   usage problems\n"	*(char)
"\n"	*(char)
"Query types (see adns.h; default is addr):\n"	*(char)
"  ns  soa  ptr  mx  rp  srv  addr       - enhanced versions\n"	*(char)
"  cname  hinfo  txt                     - types with only one version\n"	*(char)
"  a  ns-  soa-  ptr-  mx-  rp-  srv-    - _raw versions\n"	*(char)
"  type<number>                          - `unknown' type, RFC3597\n"	*(char)
"Default is addr, or ptr for -i/--ptr queries\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
sysfail	(*(char),int)->(void)
(	O
"write usage message"	*(char)
,	O
errno	O
)	O
;	O
}	O
void	O
of_version	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oi	*(struct)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
arg2	*(char)
)	O
{	O
VERSION_PRINT_QUIT	O
(	O
"adnshost"	*(char)
)	O
;	O
}	O
void	O
of_help	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oi	*(struct)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
arg2	*(char)
)	O
{	O
printusage	()->(void)
(	O
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
sysfail	(*(char),int)->(void)
(	O
"finish writing output"	*(char)
,	O
errno	O
)	O
;	O
quitnow	(int)->(void)
(	O
0	int
)	O
;	O
}	O
typedef	O
int	O
comparer_type	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
,	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
;	O
static	O
int	O
oc_long	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
,	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
{	O
return	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
optp	*(*(char))
,	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
;	O
}	O
static	O
int	O
oc_short	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
,	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
{	O
const	O
char	O
*	O
sopt	*(char)
;	O
int	O
l	int
;	O
sopt	*(char)
=	O
entry	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
;	O
if	O
(	O
!	O
sopt	*(char)
)	O
return	O
0	int
;	O
l	int
=	O
strlen	(*(char))->(long)
(	O
sopt	*(char)
)	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
*	O
optp	*(*(char))
,	O
sopt	*(char)
,	O
l	int
)	O
)	O
return	O
0	int
;	O
(	O
*	O
optp	*(*(char))
)	O
+=	O
l	int
;	O
return	O
1	int
;	O
}	O
static	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
find1	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
,	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
table	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
comparer_type	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
*	O
comparer	*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
table	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_end	int
)	O
return	O
0	int
;	O
if	O
(	O
comparer	*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int))
(	O
optp	*(*(char))
,	O
table	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
)	O
return	O
table	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
;	O
table	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
++	O
;	O
}	O
}	O
static	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
find	(*(*(char)),*(char),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
,	O
const	O
char	O
*	O
prefix	*(char)
,	O
comparer_type	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
*	O
comparer	*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int))
)	O
{	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
;	O
const	O
char	O
*	O
opt	*(char)
;	O
opt	*(char)
=	O
*	O
optp	*(*(char))
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
find1	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
optp	*(*(char))
,	O
perquery_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
,	O
comparer	*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int))
)	O
;	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
return	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
find1	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
optp	*(*(char))
,	O
global_options	array(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)),*(char),*(char))->(void)),*(char),*(char)))
,	O
comparer	*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int))
)	O
;	O
if	O
(	O
!	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
usageerr	(*(char))->(void)
(	O
"unknown option %s%s"	*(char)
,	O
prefix	*(char)
,	O
opt	*(char)
)	O
;	O
if	O
(	O
ads	*(struct)
)	O
usageerr	(*(char))->(void)
(	O
"global option %s%s specified after query domain(s)"	*(char)
,	O
prefix	*(char)
,	O
opt	*(char)
)	O
;	O
return	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
;	O
}	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
opt_findl	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
const	O
char	O
*	O
opt	*(char)
)	O
{	O
return	O
find	(*(*(char)),*(char),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
&	O
opt	*(char)
,	O
"--"	*(char)
,	O
oc_long	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
)	O
;	O
}	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
opt_finds	(*(*(char)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
const	O
char	O
*	O
*	O
optp	*(*(char))
)	O
{	O
return	O
find	(*(*(char)),*(char),*((*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`,*`,int,*`,*`,*`)))->(int)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
optp	*(*(char))
,	O
"-"	*(char)
,	O
oc_short	(*(*(char)),*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(int)
)	O
;	O
}	O
static	O
void	O
noninvert	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
NONRETURNING	O
;	O
static	O
void	O
noninvert	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
{	O
usageerr	(*(char))->(void)
(	O
"option %s%s%s%s%s may not be inverted"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
?	O
"-"	*(char)
:	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
?	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
:	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
&&	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
?	O
" / "	*(char)
:	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
?	O
"--"	*(char)
:	O
""	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
?	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
:	O
""	*(char)
)	O
;	O
}	O
void	O
opt_do	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),int,*(char),*(char))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
int	O
invert	int
,	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
arg2	*(char)
)	O
{	O
switch	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
ot_flag	int
:	O
assert	O
(	O
!	O
arg	*(char)
)	O
;	O
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
storep	*(int)
=	O
!	O
invert	int
;	O
return	O
;	O
case	O
ot_value	int
:	O
assert	O
(	O
!	O
arg	*(char)
)	O
;	O
if	O
(	O
invert	int
)	O
noninvert	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(void)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
;	O
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
storep	*(int)
=	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
value	int
;	O
return	O
;	O
case	O
ot_func	int
:	O
case	O
ot_funcarg	int
:	O
case	O
ot_funcarg2	int
:	O
if	O
(	O
invert	int
)	O
noninvert	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))->(void)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
)	O
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
func	*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void))
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
arg	*(char)
,	O
arg2	*(char)
)	O
;	O
return	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
