void	O
next	(*(struct),*(char))->(void)
(	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
,	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
skip	int
=	O
arg	*(char)
?	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
0	int
)	O
:	O
1	int
;	O
if	O
(	O
skip	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"next arg?\n"	*(char)
)	O
;	O
while	O
(	O
skip	int
--	O
)	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
void	O
prev	(*(struct),*(char))->(void)
(	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
,	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
skip	int
=	O
arg	*(char)
?	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
NULL	O
,	O
0	int
)	O
:	O
1	int
;	O
if	O
(	O
skip	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"next arg?\n"	*(char)
)	O
;	O
while	O
(	O
skip	int
--	O
)	O
dico_iterator_prev	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
void	O
print	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
struct	O
itr_shell	struct(*(void),*((*(void))->(*(struct))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char))))
*	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
{	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
=	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
get_iterator	*((*(void))->(*(struct)))
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
)	O
;	O
void	O
*	O
elt	*(void)
;	O
if	O
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
count	long
)	O
printf	(*(char))->(int)
(	O
"# items: %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
count	long
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
)	O
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"get_iterator failed"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
elt	*(void)
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
elt	*(void)
;	O
elt	*(void)
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
print_item	*((*(void))->(void))
(	O
elt	*(void)
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
int	O
iter	(*(int),int,*(*(char)))->(int)
(	O
int	O
*	O
pnum	*(int)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
n	long
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"iter num?\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
||	O
n	long
>=	O
NITR	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"iter [0-%d]?\n"	*(char)
,	O
NITR	int
-	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pnum	*(int)
=	O
n	long
;	O
return	O
0	int
;	O
}	O
void	O
help	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
struct	O
itr_shell	struct(*(void),*((*(void))->(*(struct))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char))))
*	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
{	O
struct	O
itr_shell_command	struct(*(char),int,int,*((*(void),int,*(*(char)))->(void)),*(char),*(char))
*	O
cmd	*(char)
;	O
static	O
char	O
format	array(char)
[	O
]	O
=	O
"%-8.8s %-10.10s - %s\n"	*(char)
;	O
for	O
(	O
cmd	*(char)
=	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
cmdtab	*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char)))
;	O
cmd	*(char)
->	O
name	*(char)
;	O
cmd	*(char)
++	O
)	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
cmd	*(char)
->	O
name	*(char)
,	O
cmd	*(char)
->	O
argstr	*(char)
?	O
cmd	*(char)
->	O
argstr	*(char)
:	O
""	*(char)
,	O
cmd	*(char)
->	O
docstr	*(char)
?	O
cmd	*(char)
->	O
docstr	*(char)
:	O
""	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"next"	*(char)
,	O
"[count]"	*(char)
,	O
"go to next item"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"first"	*(char)
,	O
""	*(char)
,	O
"rewind to the first item"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"print"	*(char)
,	O
""	*(char)
,	O
"print all items"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"quit"	*(char)
,	O
""	*(char)
,	O
"quit the shell"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"iter"	*(char)
,	O
"num"	*(char)
,	O
"switch to iterator #num"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
format	array(char)
,	O
"help"	*(char)
,	O
""	*(char)
,	O
"print this help list"	*(char)
)	O
;	O
}	O
int	O
num	int
=	O
0	int
;	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
[	O
NITR	int
]	O
;	O
void	O
current	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
struct	O
itr_shell	struct(*(void),*((*(void))->(*(struct))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char))))
*	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
{	O
char	O
*	O
elt	*(void)
=	O
dico_iterator_current	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%lu:"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
num	int
)	O
;	O
if	O
(	O
elt	*(void)
)	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
print_item	*((*(void))->(void))
(	O
elt	*(void)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
"NUL"	*(char)
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
dico_iterator_t	*(struct)
shell_iterator	()->(*(struct))
(	O
void	O
)	O
{	O
return	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
;	O
}	O
void	O
shell	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
struct	O
itr_shell	struct(*(void),*((*(void))->(*(struct))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char))))
*	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
{	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(int)
;	O
int	O
wsflags	int
=	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_SHOWERR	int
;	O
int	O
interactive	int
=	O
isatty	(int)->(int)
(	O
0	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
itr	*((*(void),*(void))->(int))
,	O
0	int
,	O
sizeof	O
itr	*((*(void),*(void))->(int))
)	O
;	O
num	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
buf	*(void)
[	O
80	int
]	O
;	O
void	O
*	O
elt	*(void)
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
{	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
=	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
get_iterator	*((*(void))->(*(struct)))
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
{	O
perror	(*(char))->(void)
(	O
"get_iterator"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
;	O
}	O
elt	*(void)
=	O
dico_iterator_current	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
;	O
if	O
(	O
interactive	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%d:("	*(char)
,	O
num	int
)	O
;	O
if	O
(	O
elt	*(void)
)	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
print_item	*((*(void))->(void))
(	O
elt	*(void)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"NUL"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
")> "	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
break	O
;	O
ws	*(int)
.	O
ws_comment	*(char)
=	O
"#"	*(char)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
buf	*(void)
,	O
&	O
ws	*(int)
,	O
wsflags	int
|	O
WRDSF_COMMENT	int
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
wsflags	int
|=	O
WRDSF_REUSE	int
;	O
if	O
(	O
ws	*(int)
.	O
ws_wordc	long
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"next"	*(char)
)	O
==	O
0	int
)	O
next	(*(struct),*(char))->(void)
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
1	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"prev"	*(char)
)	O
==	O
0	int
)	O
prev	(*(struct),*(char))->(void)
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
1	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"first"	*(char)
)	O
==	O
0	int
)	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
[	O
num	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"print"	*(char)
)	O
==	O
0	int
)	O
print	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"quit"	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"iter"	*(char)
)	O
==	O
0	int
)	O
{	O
int	O
n	long
;	O
if	O
(	O
iter	(*(int),int,*(*(char)))->(int)
(	O
&	O
n	long
,	O
ws	*(int)
.	O
ws_wordc	long
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
)	O
==	O
0	int
&&	O
!	O
itr	*((*(void),*(void))->(int))
[	O
n	long
]	O
)	O
{	O
itr	*((*(void),*(void))->(int))
[	O
n	long
]	O
=	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
get_iterator	*((*(void))->(*(struct)))
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
)	O
;	O
if	O
(	O
!	O
itr	*((*(void),*(void))->(int))
[	O
n	long
]	O
)	O
{	O
perror	(*(char))->(void)
(	O
"get_iterator"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
[	O
n	long
]	O
)	O
;	O
}	O
num	int
=	O
n	long
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"close"	*(char)
)	O
==	O
0	int
)	O
{	O
int	O
n	long
;	O
if	O
(	O
iter	(*(int),int,*(*(char)))->(int)
(	O
&	O
n	long
,	O
ws	*(int)
.	O
ws_wordc	long
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
)	O
==	O
0	int
)	O
{	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
[	O
n	long
]	O
)	O
;	O
if	O
(	O
n	long
==	O
num	int
&&	O
++	O
num	int
==	O
NITR	int
)	O
num	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"."	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"cur"	*(char)
)	O
==	O
0	int
)	O
{	O
current	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"help"	*(char)
)	O
==	O
0	int
)	O
help	(*(struct(*(void),*((*`)->(*`)),*((*`)->(void)),*((*`)->(long)),*(struct(*`,int,int,*`,*`,*`)))))->(void)
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
)	O
;	O
else	O
{	O
struct	O
itr_shell_command	struct(*(char),int,int,*((*(void),int,*(*(char)))->(void)),*(char),*(char))
*	O
cmd	*(char)
;	O
for	O
(	O
cmd	*(char)
=	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
cmdtab	*(struct(*(char),int,int,*((*(void),int,*(*`))->(void)),*(char),*(char)))
;	O
cmd	*(char)
->	O
name	*(char)
;	O
cmd	*(char)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
->	O
name	*(char)
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ws	*(int)
.	O
ws_wordc	long
<	O
cmd	*(char)
->	O
minargc	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"too few arguments\n"	*(char)
)	O
;	O
else	O
if	O
(	O
cmd	*(char)
->	O
maxargc	int
&&	O
ws	*(int)
.	O
ws_wordc	long
>	O
cmd	*(char)
->	O
maxargc	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"too many arguments\n"	*(char)
)	O
;	O
else	O
cmd	*(char)
->	O
fun	*((*(void),int,*(*(char)))->(void))
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
,	O
ws	*(int)
.	O
ws_wordc	long
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
cmd	*(char)
->	O
name	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
cmd	*(char)
->	O
fun	*((*(void),int,*(*(char)))->(void))
&&	O
ws	*(int)
.	O
ws_wordc	long
>=	O
cmd	*(char)
->	O
minargc	int
&&	O
(	O
cmd	*(char)
->	O
maxargc	int
==	O
0	int
||	O
ws	*(int)
.	O
ws_wordc	long
<=	O
cmd	*(char)
->	O
maxargc	int
)	O
)	O
cmd	*(char)
->	O
fun	*((*(void),int,*(*(char)))->(void))
(	O
shp	*(struct(*(void),*((*(void))->(*(struct`))),*((*(void))->(void)),*((*(void))->(long)),*(struct(*(char),int,int,*((*`,int,*`)->(void)),*(char),*(char)))))
->	O
object	*(void)
,	O
ws	*(int)
.	O
ws_wordc	long
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"?\n"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(int)
)	O
;	O
}	O
