static	O
void	O
invoke_handler	(int,int)->(void)
(	O
int	O
,	O
int	O
)	O
;	O
void	O
*	O
sfaslp	*(void)
;	O
EXTER	O
unsigned	O
long	O
s4_neg_int	array(long)
[	O
4	int
]	O
,	O
small_neg_int	array(long)
[	O
3	int
]	O
,	O
small_pos_int	array(long)
[	O
3	int
]	O
;	O
handler_function_type	O
our_signal_handler	array(int)
[	O
32	int
]	O
;	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
{	O
object	O
free1	array(int)
[	O
32	int
]	O
;	O
object	O
free2	array(int)
[	O
32	int
]	O
;	O
object	O
altfree1	array(int)
[	O
32	int
]	O
;	O
object	O
altfree2	array(int)
[	O
32	int
]	O
;	O
union	O
lispunion	O
buf	int
[	O
32	int
]	O
;	O
struct	O
call_data	O
fcall	struct
;	O
object	O
*	O
vs_top	*(int)
,	O
vs_topVAL	int
,	O
*	O
vs_base	*(int)
;	O
struct	O
bds_bd	O
*	O
bds_top	*(struct)
,	O
bds_topVAL	struct
;	O
struct	O
invocation_history	O
*	O
ihs_top	*(struct)
,	O
ihs_topVAL	struct
;	O
char	O
*	O
token_bufp	*(char)
;	O
char	O
token_buf	char
[	O
4	int
*	O
INITIAL_TOKEN_LENGTH	O
]	O
;	O
int	O
token_st_dim	int
;	O
void	O
*	O
save_objects	array(*(void))
[	O
75	int
]	O
;	O
}	O
;	O
char	O
signals_handled	array(char)
[	O
]	O
=	O
{	O
SIGINT	O
,	O
SIGUSR2	O
,	O
SIGUSR1	O
,	O
SIGIO	O
,	O
SIGALRM	O
,	O
0	int
}	O
;	O
char	O
safety_required	array(char)
[	O
]	O
=	O
{	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
}	O
;	O
void	O
gcl_init_safety	()->(void)
(	O
void	O
)	O
{	O
safety_required	array(char)
[	O
SIGINT	O
]	O
=	O
sig_try_to_delay	O
;	O
safety_required	array(char)
[	O
SIGALRM	O
]	O
=	O
sig_normal	O
;	O
}	O
DO_INIT	O
(	O
gcl_init_safety	()->(void)
(	O
)	O
;	O
)	O
DEFUN_NEW	()->(int)
(	O
"SIGNAL-SAFETY-REQUIRED"	*(char)
,	O
object	O
,	O
sSsignal_safety_required	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OI	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
signo	int
,	O
fixnum	O
safety	O
)	O
,	O
"Set the safety level required for handling SIGNO to SAFETY, or if SAFETY is negative just return the current safety level for that signal number.  Value of 1 means allow interrupt at any place not specifically marked in the code as bad, and value of 2 means allow it only in very SAFE places."	*(char)
)	O
{	O
if	O
(	O
signo	int
>	O
sizeof	O
(	O
safety_required	array(char)
)	O
)	O
{	O
FEerror	O
(	O
"Illegal signo:~a."	*(char)
,	O
1	int
,	O
make_fixnum	()->(int)
(	O
signo	int
)	O
)	O
;	O
}	O
if	O
(	O
safety	O
>=	O
0	int
)	O
safety_required	array(char)
[	O
signo	int
]	O
=	O
safety	O
;	O
return	O
small_fixnum	O
(	O
safety_required	array(char)
[	O
signo	int
]	O
)	O
;	O
}	O
void	O
main_signal_handler	O
(	O
int	O
signo	int
,	O
int	O
a	O
,	O
int	O
b	O
)	O
{	O
int	O
allowed	int
=	O
signals_allowed	O
;	O
if	O
(	O
allowed	int
>=	O
safety_required	array(char)
[	O
signo	int
]	O
)	O
{	O
signals_allowed	O
=	O
sig_none	O
;	O
if	O
(	O
signo	int
==	O
SIGUSR1	O
||	O
signo	int
==	O
SIGIO	O
)	O
{	O
unblock_sigusr_sigio	O
(	O
)	O
;	O
}	O
invoke_handler	(int,int)->(void)
(	O
signo	int
,	O
allowed	int
)	O
;	O
signals_allowed	O
=	O
allowed	int
;	O
}	O
else	O
{	O
signals_pending	O
|=	O
signal_mask	()->(int)
(	O
signo	int
)	O
;	O
alarm	(int)->(int)
(	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
before_interrupt	()->(int)
(	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
,	O
int	O
allowed	int
)	O
;	O
static	O
void	O
after_interrupt	(*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))),int)->(void)
(	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
,	O
int	O
allowed	int
)	O
;	O
static	O
void	O
invoke_handler	(int,int)->(void)
(	O
int	O
signo	int
,	O
int	O
allowed	int
)	O
{	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
buf	int
;	O
before_interrupt	()->(int)
(	O
&	O
buf	int
,	O
allowed	int
)	O
;	O
signals_pending	O
&=	O
~	O
(	O
signal_mask	()->(int)
(	O
signo	int
)	O
)	O
;	O
{	O
int	O
prev_in_handler	int
=	O
in_signal_handler	O
;	O
in_signal_handler	O
|=	O
(	O
allowed	int
<=	O
sig_normal	O
?	O
1	int
:	O
0	int
)	O
;	O
signals_allowed	O
=	O
allowed	int
;	O
our_signal_handler	array(int)
[	O
signo	int
]	O
(	O
signo	int
)	O
;	O
signals_allowed	O
=	O
0	int
;	O
in_signal_handler	O
=	O
prev_in_handler	int
;	O
after_interrupt	(*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))),int)->(void)
(	O
&	O
buf	int
,	O
allowed	int
)	O
;	O
}	O
}	O
int	O
tok_leng	int
;	O
static	O
void	O
before_interrupt	()->(int)
(	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
,	O
int	O
allowed	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
allowed	int
<	O
sig_safe	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
t_end	O
;	O
i	int
++	O
)	O
{	O
struct	O
typemanager	O
*	O
ad	*(struct)
=	O
&	O
tm_table	O
[	O
i	int
]	O
;	O
{	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
,	O
ad	*(struct)
->	O
tm_free	O
)	O
;	O
if	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
{	O
char	O
*	O
beg	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
;	O
object	O
x	O
=	O
(	O
object	O
)	O
beg	*(char)
;	O
int	O
amt	int
=	O
ad	*(struct)
->	O
tm_size	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
,	O
OBJ_LINK	()->(int)
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
)	O
;	O
ad	*(struct)
->	O
tm_nfree	O
--	O
;	O
bcopy	(*(void),*(void),long)->(void)
(	O
beg	*(char)
,	O
&	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
buf	int
[	O
i	int
]	O
)	O
,	O
amt	int
)	O
;	O
bzero	(*(void),long)->(void)
(	O
beg	*(char)
+	O
sizeof	O
(	O
struct	O
freelist	O
)	O
,	O
amt	int
-	O
sizeof	O
(	O
struct	O
freelist	O
)	O
)	O
;	O
make_unfree	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
)	O
{	O
x	O
=	O
(	O
object	O
)	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
;	O
beg	*(char)
=	O
(	O
char	O
*	O
)	O
x	O
;	O
make_unfree	()->(int)
(	O
x	O
)	O
;	O
bzero	(*(void),long)->(void)
(	O
beg	*(char)
+	O
sizeof	O
(	O
struct	O
freelist	O
)	O
,	O
amt	int
-	O
sizeof	O
(	O
struct	O
freelist	O
)	O
)	O
;	O
SS1	O
(	O
ad	*(struct)
->	O
tm_free	O
,	O
OBJ_LINK	()->(int)
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
)	O
)	O
;	O
ad	*(struct)
->	O
tm_nfree	O
--	O
;	O
}	O
else	O
{	O
SS1	O
(	O
ad	*(struct)
->	O
tm_free	O
,	O
OBJ_LINK	()->(int)
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
fcall	struct
,	O
fcall	struct
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_top	*(int)
,	O
vs_top	*(int)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_topVAL	int
,	O
*	O
vs_top	*(int)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_base	*(int)
,	O
vs_base	*(int)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
bds_top	*(struct)
,	O
bds_top	*(struct)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
bds_topVAL	struct
,	O
*	O
bds_top	*(struct)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
ihs_top	*(struct)
,	O
ihs_top	*(struct)
)	O
;	O
SS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
ihs_topVAL	struct
,	O
*	O
ihs_top	*(struct)
)	O
;	O
{	O
void	O
*	O
*	O
pp	*(*(void))
=	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
save_objects	array(*(void))
;	O
if	O
(	O
(	O
pp	*(*(void))
-	O
(	O
&	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
save_objects	array(*(void))
)	O
[	O
0	int
]	O
)	O
)	O
>=	O
(	O
sizeof	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
save_objects	array(*(void))
)	O
/	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_st_dim	int
=	O
MINN	O
(	O
token	O
->	O
st	O
.	O
st_dim	O
,	O
tok_leng	int
+	O
1	int
)	O
;	O
if	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_st_dim	int
<	O
sizeof	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_buf	char
)	O
)	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_bufp	*(char)
=	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_buf	char
;	O
else	O
{	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_bufp	*(char)
=	O
(	O
void	O
*	O
)	O
alloca	(long)->(*(void))
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_st_dim	int
)	O
;	O
}	O
bcopy	(*(void),*(void),long)->(void)
(	O
token	O
->	O
st	O
.	O
st_self	O
,	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_bufp	*(char)
,	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_st_dim	int
)	O
;	O
}	O
static	O
void	O
after_interrupt	(*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))),int)->(void)
(	O
struct	O
save_for_interrupt	struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void)))
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
,	O
int	O
allowed	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
allowed	int
<	O
sig_safe	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
t_end	O
;	O
i	int
++	O
)	O
{	O
struct	O
typemanager	O
*	O
ad	*(struct)
=	O
&	O
tm_table	O
[	O
i	int
]	O
;	O
object	O
current_fl	O
=	O
ad	*(struct)
->	O
tm_free	O
;	O
{	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
,	O
ad	*(struct)
->	O
tm_free	O
)	O
;	O
if	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
{	O
char	O
*	O
beg	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
;	O
object	O
x	O
=	O
(	O
object	O
)	O
beg	*(char)
;	O
int	O
amt	int
=	O
ad	*(struct)
->	O
tm_size	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
,	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free1	array(int)
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
is_marked_or_free	()->(int)
(	O
x	O
)	O
)	O
error	()->(int)
(	O
"should not be free"	*(char)
)	O
;	O
bcopy	(*(void),*(void),long)->(void)
(	O
&	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
buf	int
[	O
i	int
]	O
)	O
,	O
beg	*(char)
,	O
amt	int
)	O
;	O
if	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
)	O
{	O
x	O
=	O
(	O
object	O
)	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
free2	array(int)
[	O
i	int
]	O
;	O
if	O
(	O
is_marked_or_free	()->(int)
(	O
x	O
)	O
)	O
error	()->(int)
(	O
"should not be free"	*(char)
)	O
;	O
make_free	()->(int)
(	O
x	O
)	O
;	O
F_LINK	()->(int)
(	O
F_LINK	()->(int)
(	O
ad	*(struct)
->	O
tm_free	O
)	O
)	O
=	O
(	O
long	O
)	O
current_fl	O
;	O
ad	*(struct)
->	O
tm_nfree	O
+=	O
2	int
;	O
}	O
else	O
ad	*(struct)
->	O
tm_nfree	O
=	O
1	int
;	O
}	O
else	O
ad	*(struct)
->	O
tm_nfree	O
=	O
0	int
;	O
}	O
}	O
}	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
fcall	struct
,	O
fcall	struct
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_top	*(int)
,	O
vs_top	*(int)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_topVAL	int
,	O
*	O
vs_top	*(int)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
vs_base	*(int)
,	O
vs_base	*(int)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
bds_top	*(struct)
,	O
bds_top	*(struct)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
bds_topVAL	struct
,	O
*	O
bds_top	*(struct)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
ihs_top	*(struct)
,	O
ihs_top	*(struct)
)	O
;	O
RS1	O
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
ihs_topVAL	struct
,	O
*	O
ihs_top	*(struct)
)	O
;	O
{	O
void	O
*	O
*	O
pp	*(*(void))
=	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
save_objects	array(*(void))
;	O
}	O
bcopy	(*(void),*(void),long)->(void)
(	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_bufp	*(char)
,	O
token	O
->	O
st	O
.	O
st_self	O
,	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
->	O
token_st_dim	int
)	O
;	O
}	O
void	O
raise_pending_signals	(int)->(void)
(	O
int	O
cond	int
)	O
{	O
unsigned	O
int	O
allowed	int
=	O
signals_allowed	O
;	O
if	O
(	O
cond	int
==	O
sig_use_signals_allowed_value	O
)	O
if	O
(	O
cond	int
==	O
sig_none	O
||	O
interrupt_enable	O
==	O
0	int
)	O
return	O
;	O
AGAIN	O
:	O
{	O
unsigned	O
int	O
pending	int
=	O
signals_pending	O
;	O
char	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
=	O
signals_handled	array(char)
;	O
if	O
(	O
pending	int
)	O
while	O
(	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
)	O
{	O
if	O
(	O
signal_mask	()->(int)
(	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
)	O
&	O
pending	int
&&	O
cond	int
>=	O
safety_required	array(char)
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
]	O
)	O
{	O
signals_pending	O
&=	O
~	O
(	O
signal_mask	()->(int)
(	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
)	O
)	O
;	O
if	O
(	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
==	O
SIGALRM	O
&&	O
cond	int
>=	O
sig_safe	O
)	O
{	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
}	O
else	O
invoke_handler	(int,int)->(void)
(	O
*	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
,	O
cond	int
)	O
;	O
goto	O
AGAIN	O
;	O
}	O
p	*(struct(array(int),array(int),array(int),array(int),int,struct,*(int),int,*(int),*(struct),struct,*(struct),struct,*(char),char,int,array(*(void))))
++	O
;	O
}	O
signals_allowed	O
=	O
allowed	int
;	O
return	O
;	O
}	O
}	O
DEFUN_NEW	()->(int)
(	O
"ALLOW-SIGNAL"	*(char)
,	O
object	O
,	O
fSallow_signal	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
n	O
)	O
,	O
"Install the default signal handler on signal N"	*(char)
)	O
{	O
signals_allowed	O
|=	O
signal_mask	()->(int)
(	O
n	O
)	O
;	O
unblock_signals	()->(int)
(	O
n	O
,	O
n	O
)	O
;	O
if	O
(	O
our_signal_handler	array(int)
[	O
n	O
]	O
)	O
{	O
gcl_signal	()->(int)
(	O
n	O
,	O
our_signal_handler	array(int)
[	O
n	O
]	O
)	O
;	O
return	O
make_fixnum	()->(int)
(	O
1	int
)	O
;	O
}	O
else	O
return	O
make_fixnum	()->(int)
(	O
0	int
)	O
;	O
}	O
