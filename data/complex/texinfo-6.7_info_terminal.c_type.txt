VFunction	()->(void)
*	O
terminal_begin_inverse_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_end_inverse_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_begin_standout_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_end_standout_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_begin_underline_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_end_underline_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_begin_bold_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_begin_blink_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_end_all_modes_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_default_colour_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_set_colour_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_set_bgcolour_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_prep_terminal_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_unprep_terminal_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_up_line_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_down_line_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_clear_screen_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_clear_to_eol_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_get_screen_size_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_goto_xy_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_initialize_terminal_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_new_terminal_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_put_text_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_ring_bell_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_write_chars_hook	*(()->(void))
=	O
NULL	O
;	O
VFunction	()->(void)
*	O
terminal_scroll_terminal_hook	*(()->(void))
=	O
NULL	O
;	O
int	O
mouse_protocol	int
=	O
MP_NONE	int
;	O
static	O
char	O
*	O
term_buffer	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
term_string_buffer	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
term_name	*(char)
;	O
static	O
char	O
*	O
term_goto	*(char)
,	O
*	O
term_clreol	*(char)
,	O
*	O
term_cr	*(char)
,	O
*	O
term_clrpag	*(char)
;	O
static	O
char	O
*	O
term_begin_use	*(char)
,	O
*	O
term_end_use	*(char)
;	O
static	O
char	O
*	O
term_AL	*(char)
,	O
*	O
term_DL	*(char)
,	O
*	O
term_al	*(char)
,	O
*	O
term_dl	*(char)
;	O
static	O
char	O
*	O
term_cs	*(char)
;	O
static	O
char	O
*	O
term_SF	*(char)
,	O
*	O
term_SR	*(char)
;	O
static	O
char	O
*	O
term_keypad_on	*(char)
,	O
*	O
term_keypad_off	*(char)
;	O
static	O
char	O
*	O
term_up	*(char)
;	O
static	O
char	O
*	O
term_dn	*(char)
;	O
static	O
char	O
*	O
audible_bell	*(char)
;	O
static	O
char	O
*	O
visible_bell	*(char)
;	O
static	O
char	O
*	O
term_invbeg	*(char)
;	O
static	O
char	O
*	O
term_invend	*(char)
;	O
static	O
char	O
*	O
term_Km	*(char)
;	O
char	O
*	O
term_so	*(char)
,	O
*	O
term_se	*(char)
;	O
char	O
*	O
term_us	*(char)
,	O
*	O
term_ue	*(char)
;	O
char	O
*	O
term_AF	*(char)
,	O
*	O
term_AB	*(char)
;	O
char	O
*	O
term_op	*(char)
;	O
char	O
*	O
term_md	*(char)
;	O
char	O
*	O
term_mb	*(char)
;	O
char	O
*	O
term_me	*(char)
;	O
static	O
int	O
output_character_function	(int)->(int)
(	O
int	O
c	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
terminal_begin_using_terminal	()->(void)
(	O
void	O
)	O
{	O
void	O
(	O
*	O
sigsave	*((int)->(void))
)	O
(	O
int	O
signum	int
)	O
;	O
if	O
(	O
mouse_protocol	int
==	O
MP_NORMAL_TRACKING	int
&&	O
term_Km	*(char)
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
term_Km	*(char)
,	O
"\033[M"	*(char)
)	O
)	O
send_to_terminal	O
(	O
"\033[?1000h"	*(char)
)	O
;	O
else	O
term_Km	*(char)
=	O
0	int
;	O
if	O
(	O
term_keypad_on	*(char)
)	O
send_to_terminal	O
(	O
term_keypad_on	*(char)
)	O
;	O
if	O
(	O
!	O
term_begin_use	*(char)
||	O
!	O
*	O
term_begin_use	*(char)
)	O
return	O
;	O
sigsave	*((int)->(void))
=	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
send_to_terminal	O
(	O
term_begin_use	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
STREQ	O
(	O
term_name	*(char)
,	O
"sun-cmd"	*(char)
)	O
)	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
sigsave	*((int)->(void))
)	O
;	O
}	O
static	O
void	O
terminal_end_using_terminal	()->(void)
(	O
void	O
)	O
{	O
void	O
(	O
*	O
sigsave	*((int)->(void))
)	O
(	O
int	O
signum	int
)	O
;	O
if	O
(	O
term_Km	*(char)
)	O
send_to_terminal	O
(	O
"\033[?1000l"	*(char)
)	O
;	O
if	O
(	O
term_keypad_off	*(char)
)	O
send_to_terminal	O
(	O
term_keypad_off	*(char)
)	O
;	O
if	O
(	O
!	O
term_end_use	*(char)
||	O
!	O
*	O
term_end_use	*(char)
)	O
return	O
;	O
sigsave	*((int)->(void))
=	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
send_to_terminal	O
(	O
term_end_use	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
STREQ	O
(	O
term_name	*(char)
,	O
"sun-cmd"	*(char)
)	O
)	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
sigsave	*((int)->(void))
)	O
;	O
}	O
int	O
screenwidth	int
,	O
screenheight	int
;	O
int	O
terminal_is_dumb_p	int
=	O
0	int
;	O
int	O
terminal_has_visible_bell_p	int
=	O
0	int
;	O
int	O
terminal_use_visible_bell_p	int
=	O
0	int
;	O
int	O
terminal_can_scroll	int
=	O
0	int
;	O
int	O
terminal_can_scroll_region	int
=	O
0	int
;	O
char	O
*	O
term_ku	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kd	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kr	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kl	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kP	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kN	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kh	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_ke	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kD	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_ki	*(char)
=	O
NULL	O
;	O
char	O
*	O
term_kB	*(char)
=	O
NULL	O
;	O
void	O
terminal_goto_xy	(int,int)->(void)
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
if	O
(	O
terminal_goto_xy_hook	*(()->(void))
)	O
(	O
*	O
terminal_goto_xy_hook	*(()->(void))
)	O
(	O
x	int
,	O
y	int
)	O
;	O
else	O
{	O
if	O
(	O
term_goto	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_goto	*(char)
,	O
x	int
,	O
y	int
)	O
,	O
1	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
}	O
void	O
terminal_put_text	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
if	O
(	O
terminal_put_text_hook	*(()->(void))
)	O
(	O
*	O
terminal_put_text_hook	*(()->(void))
)	O
(	O
string	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
string	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_write_chars	(*(char),int)->(void)
(	O
char	O
*	O
string	*(char)
,	O
int	O
nchars	int
)	O
{	O
if	O
(	O
terminal_write_chars_hook	*(()->(void))
)	O
(	O
*	O
terminal_write_chars_hook	*(()->(void))
)	O
(	O
string	*(char)
,	O
nchars	int
)	O
;	O
else	O
{	O
if	O
(	O
nchars	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
string	*(char)
,	O
1	int
,	O
nchars	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
void	O
terminal_clear_to_eol	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_clear_to_eol_hook	*(()->(void))
)	O
(	O
*	O
terminal_clear_to_eol_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_clreol	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_clear_screen	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_clear_screen_hook	*(()->(void))
)	O
(	O
*	O
terminal_clear_screen_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_clrpag	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_up_line	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_up_line_hook	*(()->(void))
)	O
(	O
*	O
terminal_up_line_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_up	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_down_line	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_down_line_hook	*(()->(void))
)	O
(	O
*	O
terminal_down_line_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_dn	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_begin_inverse	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_inverse_hook	*(()->(void))
)	O
(	O
*	O
terminal_begin_inverse_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_invbeg	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_end_inverse	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_inverse_hook	*(()->(void))
)	O
(	O
*	O
terminal_end_inverse_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_invend	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_begin_standout	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_standout_hook	*(()->(void))
)	O
(	O
*	O
terminal_begin_standout_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_so	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_end_standout	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_standout_hook	*(()->(void))
)	O
(	O
*	O
terminal_end_standout_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_se	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_begin_underline	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_underline_hook	*(()->(void))
)	O
(	O
*	O
terminal_begin_underline_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_us	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_end_underline	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_underline_hook	*(()->(void))
)	O
(	O
*	O
terminal_end_underline_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_ue	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_begin_bold	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_bold_hook	*(()->(void))
)	O
(	O
*	O
terminal_begin_bold_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_md	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_begin_blink	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_blink_hook	*(()->(void))
)	O
(	O
*	O
terminal_begin_blink_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_mb	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_end_all_modes	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_all_modes_hook	*(()->(void))
)	O
(	O
*	O
terminal_end_all_modes_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_me	*(char)
)	O
;	O
}	O
}	O
void	O
terminal_ring_bell	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_ring_bell_hook	*(()->(void))
)	O
(	O
*	O
terminal_ring_bell_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
if	O
(	O
terminal_has_visible_bell_p	int
&&	O
terminal_use_visible_bell_p	int
)	O
send_to_terminal	O
(	O
visible_bell	*(char)
)	O
;	O
else	O
send_to_terminal	O
(	O
audible_bell	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
terminal_delete_lines	(int,int)->(void)
(	O
int	O
start	int
,	O
int	O
count	int
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
start	int
<	O
0	int
)	O
start	int
=	O
0	int
;	O
lines	int
=	O
screenheight	int
-	O
start	int
;	O
terminal_goto_xy	(int,int)->(void)
(	O
0	int
,	O
start	int
)	O
;	O
if	O
(	O
term_DL	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_DL	*(char)
,	O
0	int
,	O
count	int
)	O
,	O
lines	int
,	O
output_character_function	(int)->(int)
)	O
;	O
else	O
{	O
while	O
(	O
count	int
--	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
term_dl	*(char)
,	O
lines	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
terminal_insert_lines	(int,int)->(void)
(	O
int	O
start	int
,	O
int	O
count	int
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
start	int
<	O
0	int
)	O
start	int
=	O
0	int
;	O
lines	int
=	O
screenheight	int
-	O
start	int
;	O
terminal_goto_xy	(int,int)->(void)
(	O
0	int
,	O
start	int
)	O
;	O
if	O
(	O
term_AL	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_AL	*(char)
,	O
0	int
,	O
count	int
)	O
,	O
lines	int
,	O
output_character_function	(int)->(int)
)	O
;	O
else	O
{	O
while	O
(	O
count	int
--	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
term_al	*(char)
,	O
lines	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
terminal_scroll_region	(int,int,int)->(void)
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
if	O
(	O
amount	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
terminal_scroll_terminal_hook	*(()->(void))
)	O
{	O
(	O
*	O
terminal_scroll_terminal_hook	*(()->(void))
)	O
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
terminal_can_scroll_region	int
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_cs	*(char)
,	O
end	int
-	O
1	int
,	O
start	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
if	O
(	O
amount	int
>	O
0	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_SR	*(char)
,	O
0	int
,	O
amount	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
else	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_SF	*(char)
,	O
0	int
,	O
-	O
amount	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_cs	*(char)
,	O
screenheight	int
-	O
1	int
,	O
0	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
return	O
;	O
}	O
}	O
void	O
terminal_scroll_terminal	(int,int,int)->(void)
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
if	O
(	O
!	O
terminal_can_scroll	int
)	O
return	O
;	O
if	O
(	O
amount	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
terminal_scroll_terminal_hook	*(()->(void))
)	O
(	O
*	O
terminal_scroll_terminal_hook	*(()->(void))
)	O
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
else	O
if	O
(	O
amount	int
>	O
0	int
)	O
{	O
terminal_delete_lines	(int,int)->(void)
(	O
end	int
,	O
amount	int
)	O
;	O
terminal_insert_lines	(int,int)->(void)
(	O
start	int
,	O
amount	int
)	O
;	O
}	O
else	O
{	O
int	O
abs_amount	int
=	O
-	O
amount	int
;	O
terminal_delete_lines	(int,int)->(void)
(	O
start	int
-	O
abs_amount	int
,	O
abs_amount	int
)	O
;	O
terminal_insert_lines	(int,int)->(void)
(	O
end	int
-	O
abs_amount	int
,	O
abs_amount	int
)	O
;	O
}	O
}	O
static	O
void	O
terminal_default_colour	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_default_colour_hook	*(()->(void))
)	O
(	O
*	O
terminal_default_colour_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
term_op	*(char)
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
static	O
void	O
terminal_set_colour	(int)->(void)
(	O
int	O
colour	int
)	O
{	O
if	O
(	O
terminal_set_colour_hook	*(()->(void))
)	O
(	O
*	O
terminal_set_colour_hook	*(()->(void))
)	O
(	O
colour	int
)	O
;	O
else	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_AF	*(char)
,	O
0	int
,	O
colour	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
static	O
void	O
terminal_set_bgcolour	(int)->(void)
(	O
int	O
colour	int
)	O
{	O
if	O
(	O
terminal_set_bgcolour_hook	*(()->(void))
)	O
(	O
*	O
terminal_set_bgcolour_hook	*(()->(void))
)	O
(	O
colour	int
)	O
;	O
else	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
term_AB	*(char)
,	O
0	int
,	O
colour	int
)	O
,	O
0	int
,	O
output_character_function	(int)->(int)
)	O
;	O
}	O
static	O
unsigned	O
long	O
terminal_rendition	long
;	O
void	O
terminal_switch_rendition	(long)->(void)
(	O
unsigned	O
long	O
new	long
)	O
{	O
unsigned	O
long	O
old	long
=	O
terminal_rendition	long
;	O
if	O
(	O
(	O
old	long
&	O
new	long
&	O
COMBINED_MODES	O
)	O
!=	O
(	O
old	long
&	O
COMBINED_MODES	O
)	O
)	O
{	O
terminal_end_all_modes	()->(void)
(	O
)	O
;	O
old	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
&&	O
(	O
old	long
&	O
COLOUR_MASK	int
)	O
||	O
!	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
&&	O
(	O
old	long
&	O
BGCOLOUR_MASK	int
)	O
)	O
{	O
terminal_default_colour	()->(void)
(	O
)	O
;	O
old	long
&=	O
~	O
(	O
COLOUR_MASK	int
|	O
BGCOLOUR_MASK	int
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
!=	O
(	O
old	long
&	O
COLOUR_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
>=	O
8	int
)	O
{	O
terminal_set_colour	(int)->(void)
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
-	O
8	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
!=	O
(	O
old	long
&	O
BGCOLOUR_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
>=	O
8	int
)	O
{	O
terminal_set_bgcolour	(int)->(void)
(	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
)	O
-	O
8	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
new	long
&	O
UNDERLINE_MASK	int
)	O
!=	O
(	O
old	long
&	O
UNDERLINE_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
UNDERLINE_MASK	int
)	O
)	O
terminal_begin_underline	()->(void)
(	O
)	O
;	O
else	O
terminal_end_underline	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
STANDOUT_MASK	int
)	O
!=	O
(	O
old	long
&	O
STANDOUT_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
STANDOUT_MASK	int
)	O
)	O
terminal_begin_standout	()->(void)
(	O
)	O
;	O
else	O
terminal_end_standout	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
BOLD_MASK	int
)	O
!=	O
(	O
old	long
&	O
BOLD_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BOLD_MASK	int
)	O
)	O
terminal_begin_bold	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
BLINK_MASK	int
)	O
!=	O
(	O
old	long
&	O
BLINK_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BLINK_MASK	int
)	O
)	O
terminal_begin_blink	()->(void)
(	O
)	O
;	O
}	O
terminal_rendition	long
=	O
new	long
;	O
}	O
void	O
terminal_new_terminal	(*(char))->(void)
(	O
char	O
*	O
terminal_name	*(char)
)	O
{	O
if	O
(	O
terminal_new_terminal_hook	*(()->(void))
)	O
(	O
*	O
terminal_new_terminal_hook	*(()->(void))
)	O
(	O
terminal_name	*(char)
)	O
;	O
else	O
{	O
terminal_initialize_terminal	(*(char))->(void)
(	O
terminal_name	*(char)
)	O
;	O
}	O
}	O
static	O
char	O
*	O
env_lines	*(char)
,	O
*	O
env_columns	*(char)
;	O
void	O
terminal_get_screen_size	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
terminal_get_screen_size_hook	*(()->(void))
)	O
(	O
*	O
terminal_get_screen_size_hook	*(()->(void))
)	O
(	O
)	O
;	O
else	O
{	O
screenwidth	int
=	O
screenheight	int
=	O
0	int
;	O
{	O
struct	O
winsize	struct(short,short,short,short)
window_size	struct(short,short,short,short)
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
TIOCGWINSZ	int
,	O
&	O
window_size	struct(short,short,short,short)
)	O
==	O
0	int
)	O
{	O
screenwidth	int
=	O
(	O
int	O
)	O
window_size	struct(short,short,short,short)
.	O
ws_col	short
;	O
screenheight	int
=	O
(	O
int	O
)	O
window_size	struct(short,short,short,short)
.	O
ws_row	short
;	O
}	O
}	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
{	O
if	O
(	O
env_columns	*(char)
)	O
screenwidth	int
=	O
atoi	(*(char))->(int)
(	O
env_columns	*(char)
)	O
;	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
screenwidth	int
=	O
tgetnum	(*(char))->(int)
(	O
"co"	*(char)
)	O
;	O
}	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
{	O
if	O
(	O
env_lines	*(char)
)	O
screenheight	int
=	O
atoi	(*(char))->(int)
(	O
env_lines	*(char)
)	O
;	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
screenheight	int
=	O
tgetnum	(*(char))->(int)
(	O
"li"	*(char)
)	O
;	O
}	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
screenwidth	int
=	O
80	int
;	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
screenheight	int
=	O
24	int
;	O
}	O
}	O
BYTEMAP_ENTRY	struct(char,int,*(struct(char,int,*(struct(char,int,*`)))))
*	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
;	O
static	O
void	O
add_seq_to_byte_map	(int,*(char))->(void)
(	O
int	O
key_id	int
,	O
char	O
*	O
seq	*(char)
)	O
{	O
BYTEMAP_ENTRY	struct(char,int,*(struct(char,int,*(struct(char,int,*`)))))
*	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
=	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
;	O
unsigned	O
char	O
*	O
c	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
seq	*(char)
;	O
for	O
(	O
;	O
*	O
c	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_KEY	int
;	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
key	int
=	O
key_id	int
;	O
}	O
else	O
{	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_MAP	int
;	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
key	int
=	O
0	int
;	O
if	O
(	O
!	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
xzalloc	(long)->(*(void))
(	O
256	int
*	O
sizeof	O
(	O
BYTEMAP_ENTRY	struct(char,int,*(struct(char,int,*(struct(char,int,*`)))))
)	O
)	O
;	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
=	O
b	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
*	O
c	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
;	O
}	O
}	O
}	O
int	O
ISO_Latin_p	int
=	O
1	int
;	O
static	O
void	O
initialize_byte_map	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
static	O
struct	O
special_keys	struct(int,*(*(char)))
{	O
int	O
key_id	int
;	O
char	O
*	O
*	O
byte_seq	*(*(char))
;	O
}	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
[	O
]	O
=	O
{	O
KEY_RIGHT_ARROW	int
,	O
&	O
term_kr	*(char)
,	O
KEY_LEFT_ARROW	int
,	O
&	O
term_kl	*(char)
,	O
KEY_UP_ARROW	int
,	O
&	O
term_ku	*(char)
,	O
KEY_DOWN_ARROW	int
,	O
&	O
term_kd	*(char)
,	O
KEY_PAGE_UP	int
,	O
&	O
term_kP	*(char)
,	O
KEY_PAGE_DOWN	int
,	O
&	O
term_kN	*(char)
,	O
KEY_HOME	int
,	O
&	O
term_kh	*(char)
,	O
KEY_END	int
,	O
&	O
term_ke	*(char)
,	O
KEY_DELETE	int
,	O
&	O
term_kD	*(char)
,	O
KEY_INSERT	int
,	O
&	O
term_ki	*(char)
,	O
KEY_BACK_TAB	int
,	O
&	O
term_kB	*(char)
}	O
;	O
static	O
struct	O
special_keys2	struct(int,*(char))
{	O
int	O
key_id	int
;	O
char	O
*	O
byte_seq	*(*(char))
;	O
}	O
keys2	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
KEY_RIGHT_ARROW	int
,	O
"\033[C"	*(char)
,	O
KEY_RIGHT_ARROW	int
,	O
"\033OC"	*(char)
,	O
KEY_LEFT_ARROW	int
,	O
"\033[D"	*(char)
,	O
KEY_LEFT_ARROW	int
,	O
"\033OD"	*(char)
,	O
KEY_UP_ARROW	int
,	O
"\033[A"	*(char)
,	O
KEY_UP_ARROW	int
,	O
"\033OA"	*(char)
,	O
KEY_DOWN_ARROW	int
,	O
"\033[B"	*(char)
,	O
KEY_DOWN_ARROW	int
,	O
"\033OB"	*(char)
}	O
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
=	O
xmalloc	(long)->(*(void))
(	O
256	int
*	O
sizeof	O
(	O
BYTEMAP_ENTRY	struct(char,int,*(struct(char,int,*(struct(char,int,*`)))))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
128	int
;	O
i	int
++	O
)	O
{	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
key	int
=	O
i	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
0	int
;	O
}	O
if	O
(	O
!	O
ISO_Latin_p	int
)	O
for	O
(	O
i	int
=	O
128	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
key	int
=	O
(	O
i	int
-	O
128	int
)	O
+	O
KEYMAP_META_BASE	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
0	int
;	O
}	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
'\177'	O
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
'\177'	O
]	O
.	O
key	int
=	O
KEY_DELETE	int
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
'\177'	O
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
/	O
sizeof	O
(	O
*	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
*	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
[	O
i	int
]	O
.	O
byte_seq	*(*(char))
)	O
continue	O
;	O
add_seq_to_byte_map	(int,*(char))->(void)
(	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
[	O
i	int
]	O
.	O
key_id	int
,	O
*	O
keys	*(struct(*(struct(*(struct`),*(struct`),*(int))),*(struct),*(int)))
[	O
i	int
]	O
.	O
byte_seq	*(*(char))
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
keys2	array(struct(int,*(char)))
)	O
/	O
sizeof	O
(	O
*	O
keys2	array(struct(int,*(char)))
)	O
;	O
i	int
++	O
)	O
{	O
add_seq_to_byte_map	(int,*(char))->(void)
(	O
keys2	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
key_id	int
,	O
keys2	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
byte_seq	*(*(char))
)	O
;	O
}	O
if	O
(	O
term_Km	*(char)
)	O
add_seq_to_byte_map	(int,*(char))->(void)
(	O
KEY_MOUSE	int
,	O
term_Km	*(char)
)	O
;	O
byte_seq_to_key	*(struct(char,int,*(struct(char,int,*(struct`)))))
[	O
'\033'	O
]	O
.	O
type	enum(int,int,int,int)
=	O
BYTEMAP_ESC	int
;	O
}	O
void	O
terminal_initialize_terminal	(*(char))->(void)
(	O
char	O
*	O
terminal_name	*(char)
)	O
{	O
char	O
*	O
buffer	*(struct)
;	O
terminal_is_dumb_p	int
=	O
0	int
;	O
if	O
(	O
terminal_initialize_terminal_hook	*(()->(void))
)	O
{	O
(	O
*	O
terminal_initialize_terminal_hook	*(()->(void))
)	O
(	O
terminal_name	*(char)
)	O
;	O
initialize_byte_map	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
term_name	*(char)
=	O
terminal_name	*(char)
?	O
terminal_name	*(char)
:	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
;	O
if	O
(	O
!	O
term_name	*(char)
)	O
term_name	*(char)
=	O
"dumb"	*(char)
;	O
env_lines	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
;	O
env_columns	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
;	O
if	O
(	O
!	O
term_string_buffer	*(char)
)	O
term_string_buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2048	int
)	O
;	O
if	O
(	O
!	O
term_buffer	*(char)
)	O
term_buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2048	int
)	O
;	O
buffer	*(struct)
=	O
term_string_buffer	*(char)
;	O
term_clrpag	*(char)
=	O
term_cr	*(char)
=	O
term_clreol	*(char)
=	O
NULL	O
;	O
if	O
(	O
tgetent	(*(char),*(char))->(int)
(	O
term_buffer	*(char)
,	O
term_name	*(char)
)	O
<	O
0	int
)	O
{	O
terminal_is_dumb_p	int
=	O
1	int
;	O
screenwidth	int
=	O
80	int
;	O
screenheight	int
=	O
24	int
;	O
term_cr	*(char)
=	O
"\r"	*(char)
;	O
term_up	*(char)
=	O
term_dn	*(char)
=	O
audible_bell	*(char)
=	O
visible_bell	*(char)
=	O
NULL	O
;	O
term_ku	*(char)
=	O
term_kd	*(char)
=	O
term_kl	*(char)
=	O
term_kr	*(char)
=	O
NULL	O
;	O
term_kP	*(char)
=	O
term_kN	*(char)
=	O
NULL	O
;	O
term_kh	*(char)
=	O
term_ke	*(char)
=	O
NULL	O
;	O
term_kD	*(char)
=	O
NULL	O
;	O
return	O
;	O
}	O
BC	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"pc"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
PC	char
=	O
BC	*(char)
?	O
*	O
BC	*(char)
:	O
0	int
;	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
ti	struct(int,int,int,int,char,array(char),int,int)
;	O
if	O
(	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
ti	struct(int,int,int,int,char,array(char),int,int)
)	O
!=	O
-	O
1	int
)	O
ospeed	short
=	O
cfgetospeed	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
&	O
ti	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
else	O
ospeed	short
=	O
B9600	int
;	O
}	O
term_cr	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cr"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_clreol	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ce"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_clrpag	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cl"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_goto	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cm"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_AL	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"AL"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_DL	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"DL"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_al	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"al"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_dl	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"dl"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_cs	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cs"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_SF	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"SF"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_SR	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"SR"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
terminal_can_scroll	int
=	O
(	O
(	O
term_AL	*(char)
||	O
term_al	*(char)
)	O
&&	O
(	O
term_DL	*(char)
||	O
term_dl	*(char)
)	O
)	O
;	O
terminal_can_scroll_region	int
=	O
term_cs	*(char)
&&	O
term_SF	*(char)
&&	O
term_SR	*(char)
;	O
term_invbeg	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"mr"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
term_invbeg	*(char)
)	O
term_invend	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"me"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
else	O
term_invend	*(char)
=	O
NULL	O
;	O
term_so	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"so"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
term_so	*(char)
)	O
term_se	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"se"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
else	O
term_se	*(char)
=	O
NULL	O
;	O
term_us	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"us"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
term_us	*(char)
)	O
term_ue	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ue"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
else	O
term_ue	*(char)
=	O
NULL	O
;	O
term_AF	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"AF"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
term_AF	*(char)
)	O
term_AB	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"AB"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
else	O
term_AB	*(char)
=	O
NULL	O
;	O
term_op	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"op"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_md	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"md"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_mb	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"mb"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_me	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"me"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
!	O
term_me	*(char)
)	O
term_md	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
term_cr	*(char)
)	O
term_cr	*(char)
=	O
"\r"	*(char)
;	O
terminal_get_screen_size	()->(void)
(	O
)	O
;	O
term_up	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"up"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_dn	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"dn"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
visible_bell	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"vb"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
terminal_has_visible_bell_p	int
=	O
(	O
visible_bell	*(char)
!=	O
NULL	O
)	O
;	O
audible_bell	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"bl"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
if	O
(	O
!	O
audible_bell	*(char)
)	O
audible_bell	*(char)
=	O
"\007"	*(char)
;	O
term_begin_use	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ti"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_end_use	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"te"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_keypad_on	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ks"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_keypad_off	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ke"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_ku	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ku"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kd	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kd"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kr	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kr"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kl	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kl"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kP	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kP"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kN	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kN"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kh	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kh"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_ke	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"@7"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_ki	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kI"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kD	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kD"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_kB	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kB"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
term_Km	*(char)
=	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
"Km"	*(char)
,	O
&	O
buffer	*(struct)
)	O
;	O
initialize_byte_map	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
term_goto	*(char)
)	O
terminal_is_dumb_p	int
=	O
1	int
;	O
}	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
original_termios	struct(int,int,int,int,char,array(char),int,int)
,	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
;	O
int	O
terminal_prep_terminal	()->(int)
(	O
void	O
)	O
{	O
int	O
tty	int
;	O
if	O
(	O
terminal_is_dumb_p	int
)	O
return	O
0	int
;	O
if	O
(	O
terminal_prep_terminal_hook	*(()->(void))
)	O
{	O
(	O
*	O
terminal_prep_terminal_hook	*(()->(void))
)	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
terminal_begin_using_terminal	()->(void)
(	O
)	O
;	O
tty	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
&	O
original_termios	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
&	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_iflag	int
&=	O
(	O
~	O
ISTRIP	int
&	O
~	O
INLCR	int
&	O
~	O
IGNCR	int
&	O
~	O
ICRNL	int
&	O
~	O
IXON	int
)	O
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	int
&=	O
~	O
ONLCR	int
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_oflag	int
&=	O
~	O
OCRNL	int
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
&=	O
(	O
~	O
ICANON	int
&	O
~	O
ECHO	int
)	O
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VMIN	int
]	O
=	O
1	int
;	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VTIME	int
]	O
=	O
0	int
;	O
if	O
(	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VINTR	int
]	O
==	O
'\177'	O
)	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VINTR	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VQUIT	int
]	O
==	O
'\177'	O
)	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VQUIT	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VLNEXT	int
]	O
==	O
'\026'	O
)	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VLNEXT	int
]	O
=	O
-	O
1	int
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
TCSANOW	int
,	O
&	O
ttybuff	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
tcflow	(int,int)->(int)
(	O
tty	int
,	O
TCOOFF	int
)	O
;	O
tcflow	(int,int)->(int)
(	O
tty	int
,	O
TCOON	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
terminal_unprep_terminal	()->(void)
(	O
void	O
)	O
{	O
int	O
tty	int
;	O
if	O
(	O
terminal_unprep_terminal_hook	*(()->(void))
)	O
{	O
(	O
*	O
terminal_unprep_terminal_hook	*(()->(void))
)	O
(	O
)	O
;	O
return	O
;	O
}	O
tty	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
TCSANOW	int
,	O
&	O
original_termios	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
terminal_end_using_terminal	()->(void)
(	O
)	O
;	O
}	O
