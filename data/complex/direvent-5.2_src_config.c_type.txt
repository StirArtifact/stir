static	O
struct	O
transtab	struct(*(char),int)
kwpri	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"emerg"	*(char)
,	O
LOG_EMERG	int
}	O
,	O
{	O
"alert"	*(char)
,	O
LOG_ALERT	int
}	O
,	O
{	O
"crit"	*(char)
,	O
LOG_CRIT	int
}	O
,	O
{	O
"err"	*(char)
,	O
LOG_ERR	int
}	O
,	O
{	O
"warning"	*(char)
,	O
LOG_WARNING	int
}	O
,	O
{	O
"notice"	*(char)
,	O
LOG_NOTICE	int
}	O
,	O
{	O
"info"	*(char)
,	O
LOG_INFO	int
}	O
,	O
{	O
"debug"	*(char)
,	O
LOG_DEBUG	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
transtab	struct(*(char),int)
kwfac	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"user"	*(char)
,	O
LOG_USER	O
}	O
,	O
{	O
"daemon"	*(char)
,	O
LOG_DAEMON	O
}	O
,	O
{	O
"auth"	*(char)
,	O
LOG_AUTH	O
}	O
,	O
{	O
"authpriv"	*(char)
,	O
LOG_AUTHPRIV	O
}	O
,	O
{	O
"mail"	*(char)
,	O
LOG_MAIL	O
}	O
,	O
{	O
"cron"	*(char)
,	O
LOG_CRON	O
}	O
,	O
{	O
"local0"	*(char)
,	O
LOG_LOCAL0	O
}	O
,	O
{	O
"local1"	*(char)
,	O
LOG_LOCAL1	O
}	O
,	O
{	O
"local2"	*(char)
,	O
LOG_LOCAL2	O
}	O
,	O
{	O
"local3"	*(char)
,	O
LOG_LOCAL3	O
}	O
,	O
{	O
"local4"	*(char)
,	O
LOG_LOCAL4	O
}	O
,	O
{	O
"local5"	*(char)
,	O
LOG_LOCAL5	O
}	O
,	O
{	O
"local6"	*(char)
,	O
LOG_LOCAL6	O
}	O
,	O
{	O
"local7"	*(char)
,	O
LOG_LOCAL7	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
get_facility	(*(char))->(int)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
f	int
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
errno	O
=	O
0	int
;	O
f	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
==	O
0	int
&&	O
errno	O
==	O
0	int
)	O
return	O
f	int
;	O
if	O
(	O
trans_strtotok	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
kwfac	array(struct(*(char),int))
,	O
arg	*(char)
,	O
&	O
f	int
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"unknown syslog facility: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
f	int
;	O
}	O
int	O
get_priority	(*(char))->(int)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
f	int
;	O
char	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
errno	O
=	O
0	int
;	O
f	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
==	O
0	int
&&	O
errno	O
==	O
0	int
)	O
return	O
f	int
;	O
if	O
(	O
trans_strtotok	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
kwpri	array(struct(*(char),int))
,	O
arg	*(char)
,	O
&	O
f	int
)	O
)	O
{	O
diag	(int,*(char))->(void)
(	O
LOG_CRIT	int
,	O
_	O
(	O
"unknown syslog priority: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
f	int
;	O
}	O
int	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
const	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
int	O
type	enum(int,int,int)
)	O
{	O
if	O
(	O
GRECS_VALUE_EMPTY_P	O
(	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"expected %s"	*(char)
)	O
,	O
grecs_data_type_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
type	enum(int,int,int)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
!=	O
type	enum(int,int,int)
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"expected %s, but found %s"	*(char)
)	O
,	O
grecs_data_type_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
type	enum(int,int,int)
)	O
,	O
grecs_data_type_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_syslog_facility	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
int	O
fac	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
trans_strtotok	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
kwfac	array(struct(*(char),int))
,	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
fac	int
)	O
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unknown syslog facility `%s'"	*(char)
)	O
,	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
else	O
*	O
(	O
int	O
*	O
)	O
varptr	*(void)
=	O
fac	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
grecs_keyword	struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct`))))))
syslog_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
[	O
]	O
=	O
{	O
{	O
"facility"	*(char)
,	O
N_	O
(	O
"name"	*(char)
)	O
,	O
N_	O
(	O
"Set syslog facility. Arg is one of the following: user, daemon, "	*(char)
"auth, authpriv, mail, cron, local0 through local7 "	*(char)
"(case-insensitive), or a facility number."	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
facility	int
,	O
0	int
,	O
cb_syslog_facility	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"tag"	*(char)
,	O
N_	O
(	O
"string"	*(char)
)	O
,	O
N_	O
(	O
"Tag syslog messages with this string"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
tag	*(char)
}	O
,	O
{	O
"print-priority"	*(char)
,	O
N_	O
(	O
"arg"	*(char)
)	O
,	O
N_	O
(	O
"Prefix each message with its priority"	*(char)
)	O
,	O
grecs_type_bool	int
,	O
GRECS_DFLT	int
,	O
&	O
syslog_include_prio	int
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
struct	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
{	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
event_mask	struct(int,int)
ev_mask	struct(int,int)
;	O
filpatlist_t	*(struct)
fpat	*(struct)
;	O
struct	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
;	O
}	O
;	O
static	O
struct	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
static	O
void	O
eventconf_init	()->(void)
(	O
void	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
0	int
,	O
sizeof	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
timeout	int
=	O
DEFAULT_TIMEOUT	int
;	O
}	O
static	O
void	O
eventconf_free	()->(void)
(	O
void	O
)	O
{	O
grecs_list_free	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
prog_handler_free	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))))->(void)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
)	O
;	O
filpatlist_destroy	(*(*(struct)))->(void)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
fpat	*(struct)
)	O
;	O
}	O
void	O
eventconf_flush	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct)
)	O
{	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
struct	O
handler	struct(long,struct(int,int),*(struct),*((*(struct),*(struct(int,int)),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void))
*	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
=	O
prog_handler_alloc	(struct(int,int),*(struct),*(struct(int,*(char),int,*(int),long,int,*(*(char)))))->(*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))
(	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
ev_mask	struct(int,int)
,	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
fpat	*(struct)
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
)	O
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
struct	O
pathent	struct(long,long,array(char))
*	O
pe	*(struct(long,long,array(char)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
struct	O
watchpoint	struct(long,int,*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char))),*(char),int,*(struct),int,*(char))
*	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
;	O
int	O
isnew	int
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
=	O
watchpoint_install	(*(char),*(int))->(*(struct(long,int,*(struct(long,int,*`,*`,int,*`,int,*`)),*(char),int,*(struct),int,*(char))))
(	O
pe	*(struct(long,long,array(char)))
->	O
path	array(char)
,	O
&	O
isnew	int
)	O
;	O
if	O
(	O
!	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
isnew	int
&&	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
!=	O
pe	*(struct(long,long,array(char)))
->	O
depth	int
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
loc	*(struct)
,	O
0	int
,	O
_	O
(	O
"%s: recursion depth does not match previous definition"	*(char)
)	O
,	O
pe	*(struct(long,long,array(char)))
->	O
path	array(char)
)	O
;	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
depth	int
=	O
pe	*(struct(long,long,array(char)))
->	O
depth	int
;	O
handler_list_append	(*(struct),*(struct(long,struct(int,int),*(struct),*((*`,*`,*`,*`,*`)->(int)),*((*`)->(void)),*(void))))->(void)
(	O
wpt	*(struct(long,int,*(struct(long,int,*(struct`),*(char),int,*(struct`),int,*(char))),*(char),int,*(struct),int,*(char)))
->	O
handler_list	*(struct)
,	O
hp	*(struct(long,struct(int,int),*(struct),*((*(struct`),*(struct`),*(char),*(char),*(void))->(int)),*((*(void))->(void)),*(void)))
)	O
;	O
}	O
grecs_list_free	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
eventconf_init	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
cb_watcher	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
int	O
err	long
=	O
0	int
;	O
switch	O
(	O
cmd	enum(int,int,int)
)	O
{	O
case	O
grecs_callback_section_begin	int
:	O
eventconf_init	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
grecs_callback_section_end	int
:	O
if	O
(	O
!	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"no paths configured"	*(char)
)	O
)	O
;	O
++	O
err	long
;	O
}	O
if	O
(	O
!	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
command	*(char)
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"no command configured"	*(char)
)	O
)	O
;	O
++	O
err	long
;	O
}	O
if	O
(	O
evtnullp	(*(struct(int,int)))->(int)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
ev_mask	struct(int,int)
)	O
)	O
evtsetall	(*(struct(int,int)))->(void)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
ev_mask	struct(int,int)
)	O
;	O
if	O
(	O
err	long
==	O
0	int
)	O
eventconf_flush	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
else	O
eventconf_free	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
grecs_callback_set_value	int
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"invalid use of block statement"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
pathent	struct(long,long,array(char))
*	O
pathent_alloc	(*(char),long)->(*(struct(long,long,array(char))))
(	O
char	O
*	O
s	*(char)
,	O
long	O
depth	int
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
struct	O
pathent	struct(long,long,array(char))
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
)	O
+	O
len	long
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
len	long
=	O
len	long
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
path	array(char)
,	O
s	*(char)
)	O
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
->	O
depth	int
=	O
depth	int
;	O
return	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
}	O
static	O
int	O
cb_path	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
*	O
lpp	*(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
=	O
varptr	*(void)
,	O
*	O
lp	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
struct	O
pathent	struct(long,long,array(char))
*	O
pe	*(struct(long,long,array(char)))
;	O
char	O
*	O
s	*(char)
;	O
long	O
depth	int
=	O
0	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
s	*(char)
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"recursive"	*(char)
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"expected \"recursive\" or end of statement"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
)	O
{	O
case	O
2	int
:	O
depth	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
grecs_string_convert	(*(void),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
&	O
depth	int
,	O
grecs_type_long	int
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
2	int
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
2	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
3	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"surplus argument"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
s	*(char)
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unexpected list"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pe	*(struct(long,long,array(char)))
=	O
pathent_alloc	(*(char),long)->(*(struct(long,long,array(char))))
(	O
s	*(char)
,	O
depth	int
)	O
;	O
if	O
(	O
*	O
lpp	*(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
)	O
lp	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
*	O
lpp	*(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
;	O
else	O
{	O
lp	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
_grecs_simple_list_create	(int)->(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
(	O
1	int
)	O
;	O
*	O
lpp	*(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
=	O
lp	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
}	O
grecs_list_append	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(void))->(void)
(	O
lp	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
pe	*(struct(long,long,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_eventlist	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
event_mask	struct(int,int)
*	O
mask	struct(int,int)
=	O
varptr	*(void)
;	O
event_mask	struct(int,int)
m	*(struct(int,int))
;	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
int	O
i	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
if	O
(	O
getevt	(*(char),*(struct(int,int)))->(int)
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
m	*(struct(int,int))
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct(int,int)
->	O
gen_mask	int
|=	O
m	*(struct(int,int))
.	O
gen_mask	int
;	O
mask	struct(int,int)
->	O
sys_mask	int
|=	O
m	*(struct(int,int))
.	O
sys_mask	int
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getevt	(*(char),*(struct(int,int)))->(int)
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
m	*(struct(int,int))
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct(int,int)
->	O
gen_mask	int
|=	O
m	*(struct(int,int))
.	O
gen_mask	int
;	O
mask	struct(int,int)
->	O
sys_mask	int
|=	O
m	*(struct(int,int))
.	O
sys_mask	int
;	O
}	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getevt	(*(char),*(struct(int,int)))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
m	*(struct(int,int))
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct(int,int)
->	O
gen_mask	int
|=	O
m	*(struct(int,int))
.	O
gen_mask	int
;	O
mask	struct(int,int)
->	O
sys_mask	int
|=	O
m	*(struct(int,int))
.	O
sys_mask	int
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
membergid	(int,long,*(int))->(int)
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	long
,	O
gid_t	int
*	O
gv	*(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gc	long
;	O
i	int
++	O
)	O
if	O
(	O
gv	*(int)
[	O
i	int
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	(*(char),int,*(long),*(*(int)))->(void)
(	O
char	O
*	O
user	*(char)
,	O
gid_t	int
gid	int
,	O
size_t	long
*	O
pgidc	*(long)
,	O
gid_t	int
*	O
*	O
pgidv	*(*(int))
)	O
{	O
size_t	long
gidc	long
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	*(int)
=	O
NULL	O
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
gr	*(struct(*(char),*(char),int,*(*(char))))
;	O
n	long
=	O
32	int
;	O
gidv	*(int)
=	O
emalloc	(long)->(*(void))
(	O
n	long
*	O
sizeof	O
(	O
gidv	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
gidv	*(int)
[	O
0	int
]	O
=	O
gid	int
;	O
gidc	long
=	O
1	int
;	O
setgrent	()->(void)
(	O
)	O
;	O
while	O
(	O
gr	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrent	()->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
)	O
)	O
{	O
char	O
*	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
for	O
(	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
=	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_mem	*(*(char))
;	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
;	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
p	*(struct(int,*(char),int,*(int),long,int,*(*(char))))
,	O
user	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	long
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	*(int)
=	O
erealloc	(*(void),long)->(*(void))
(	O
gidv	*(int)
,	O
n	long
*	O
sizeof	O
(	O
gidv	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	(int,long,*(int))->(int)
(	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
,	O
gidc	long
,	O
gidv	*(int)
)	O
)	O
gidv	*(int)
[	O
gidc	long
++	O
]	O
=	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	()->(void)
(	O
)	O
;	O
*	O
pgidc	*(long)
=	O
gidc	long
;	O
*	O
pgidv	*(*(int))
=	O
gidv	*(int)
;	O
}	O
static	O
int	O
cb_user	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
gr	*(struct(*(char),*(char),int,*(*(char))))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
*	O
gv	*(int)
=	O
NULL	O
;	O
gid_t	int
gid	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
>	O
2	int
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
loc	*(struct)
;	O
loc	*(struct)
.	O
beg	struct(*(char),int,int)
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
2	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
;	O
loc	*(struct)
.	O
end	struct(*(char),int,int)
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
-	O
1	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
;	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
loc	*(struct)
,	O
0	int
,	O
_	O
(	O
"surplus arguments"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
0	int
]	O
;	O
gv	*(int)
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
1	int
]	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unexpected list"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"no such user"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
gv	*(int)
)	O
{	O
gr	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
gv	*(int)
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
if	O
(	O
!	O
gr	*(struct(*(char),*(char),int,*(*(char))))
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
gv	*(int)
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"no such group"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
gid	int
=	O
gr	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
;	O
}	O
else	O
gid	int
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
uid	int
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
;	O
get_user_groups	(*(char),int,*(long),*(*(int)))->(void)
(	O
uv	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
gid	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
gidc	long
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
gidv	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_option	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_LIST	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"nowait"	*(char)
)	O
==	O
0	int
)	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
flags	int
|=	O
HF_NOWAIT	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"wait"	*(char)
)	O
==	O
0	int
)	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
flags	int
&=	O
~	O
HF_NOWAIT	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"stdout"	*(char)
)	O
==	O
0	int
)	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
flags	int
|=	O
HF_STDOUT	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"stderr"	*(char)
)	O
==	O
0	int
)	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
flags	int
|=	O
HF_STDERR	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
"shell"	*(char)
)	O
==	O
0	int
)	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
flags	int
|=	O
HF_SHELL	int
;	O
else	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"unrecognized option"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_environ	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
int	O
i	int
,	O
j	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
i	int
=	O
prog_handler_envrealloc	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))),long)->(long)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
,	O
1	int
)	O
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
i	int
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
i	int
+	O
1	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
j	int
=	O
prog_handler_envrealloc	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))),long)->(long)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
;	O
i	int
++	O
,	O
j	int
++	O
)	O
{	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
j	int
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
}	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
j	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
j	int
=	O
prog_handler_envrealloc	(*(struct(int,*(char),int,*(int),long,int,*(*(char)))),long)->(long)
(	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
count	long
)	O
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
,	O
j	int
++	O
)	O
{	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
j	int
]	O
=	O
estrdup	(*(char))->(*(char))
(	O
vp	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
)	O
;	O
}	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
env	*(*(char))
[	O
j	int
]	O
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
file_name_pattern	(*(*(struct)),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
filpatlist_t	*(struct)
*	O
fptr	*(int)
,	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
)	O
{	O
if	O
(	O
assert_grecs_value_type	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
return	O
filpatlist_add	(*(*(struct)),*(char),*(struct))->(int)
(	O
fptr	*(int)
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
string	*(char)
,	O
&	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
static	O
int	O
cb_file_pattern	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
(	O
enum	O
grecs_callback_command	enum(int,int,int)
cmd	enum(int,int,int)
,	O
grecs_node_t	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct`,struct`),union(*`,*`,struct`))),*(struct)))
*	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
varptr	*(void)
,	O
void	O
*	O
cb_data	*(void)
)	O
{	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
=	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
value	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
;	O
filpatlist_t	*(struct)
*	O
fpat	*(struct)
=	O
varptr	*(void)
;	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
int	O
i	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum(int,int,int)
,	O
&	O
node	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
switch	O
(	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
file_name_pattern	(*(*(struct)),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
fpat	*(struct)
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
)	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
c	long
;	O
i	int
++	O
)	O
if	O
(	O
file_name_pattern	(*(*(struct)),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
fpat	*(struct)
,	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
arg	*(char)
.	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
[	O
i	int
]	O
)	O
)	O
break	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
val	*(struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*`,*`,long,*`,*`)),*(char),struct(long,*(*`)))))
->	O
v	union(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),*(char))
.	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
if	O
(	O
file_name_pattern	(*(*(struct)),*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
fpat	*(struct)
,	O
(	O
grecs_value_t	struct(int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(*(struct`),*(struct`),long,*((*`,*`)->(int)),*((*`)->(void)))),*(char),struct(long,*(*(struct`)))))
*	O
)	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
)	O
)	O
break	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
grecs_keyword	struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct`))))))
watcher_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
[	O
]	O
=	O
{	O
{	O
"path"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Pathname to watch"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
pathlist	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
0	int
,	O
cb_path	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"event"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Events to watch for"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
ev_mask	struct(int,int)
,	O
0	int
,	O
cb_eventlist	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"file"	*(char)
,	O
N_	O
(	O
"regexp"	*(char)
)	O
,	O
N_	O
(	O
"Files to watch for"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
fpat	*(struct)
,	O
0	int
,	O
cb_file_pattern	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"command"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Command to execute on event"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
command	*(char)
}	O
,	O
{	O
"user"	*(char)
,	O
N_	O
(	O
"name"	*(char)
)	O
,	O
N_	O
(	O
"Run command as this user"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_user	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"timeout"	*(char)
,	O
N_	O
(	O
"seconds"	*(char)
)	O
,	O
N_	O
(	O
"Timeout for the command"	*(char)
)	O
,	O
grecs_type_uint	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))),struct(int,int),*(struct),struct(int,*(char),int,*(int),long,int,*(*(char))))
.	O
prog_handler	struct(int,*(char),int,*(int),long,int,*(*(char)))
.	O
timeout	int
}	O
,	O
{	O
"option"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"List of additional options"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
NULL	O
,	O
0	int
,	O
cb_option	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
"environ"	*(char)
,	O
N_	O
(	O
"<arg: string> <arg: string>..."	*(char)
)	O
,	O
N_	O
(	O
"Modify environment"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_environ	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
grecs_keyword	struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct`))))))
direvent_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
[	O
]	O
=	O
{	O
{	O
"user"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Run as this user"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
user	*(char)
}	O
,	O
{	O
"foreground"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Run in foreground"	*(char)
)	O
,	O
grecs_type_bool	int
,	O
GRECS_DFLT	int
,	O
&	O
foreground	int
}	O
,	O
{	O
"pidfile"	*(char)
,	O
N_	O
(	O
"file"	*(char)
)	O
,	O
N_	O
(	O
"Set pid file name"	*(char)
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
pidfile	*(char)
}	O
,	O
{	O
"syslog"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Configure syslog logging"	*(char)
)	O
,	O
grecs_type_section	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
syslog_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
}	O
,	O
{	O
"debug"	*(char)
,	O
N_	O
(	O
"level"	*(char)
)	O
,	O
N_	O
(	O
"Set debug level"	*(char)
)	O
,	O
grecs_type_int	int
,	O
GRECS_DFLT	int
,	O
&	O
debug_level	int
}	O
,	O
{	O
"watcher"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Configure event watcher"	*(char)
)	O
,	O
grecs_type_section	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_watcher	(enum(int,int,int),*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
watcher_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
config_help	()->(void)
(	O
)	O
{	O
static	O
char	O
docstring	*(char)
[	O
]	O
=	O
N_	O
(	O
"Configuration file structure for direvent.\n"	*(char)
"For more information, use `info direvent configuration'."	*(char)
)	O
;	O
grecs_print_docstring	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
docstring	*(char)
,	O
0	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
grecs_print_statement_array	(*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`)))),int,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
direvent_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
,	O
1	int
,	O
0	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
config_init	()->(void)
(	O
void	O
)	O
{	O
grecs_include_path_setup	(*(char))->(void)
(	O
INCLUDE_PATH_ARGS	O
,	O
NULL	O
)	O
;	O
}	O
void	O
config_parse	(*(char))->(void)
(	O
char	O
const	O
*	O
conffile	*(char)
)	O
{	O
struct	O
grecs_node	struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct)))),*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct)))),*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct)))),*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct)))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(char),struct(long,*`)))),*(struct)))
*	O
tree	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
;	O
grecs_parser_options	int
=	O
GRECS_OPTION_QUOTED_STRING_CONCAT	int
;	O
tree	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
=	O
grecs_parse	(*(char))->(*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))))
(	O
conffile	*(char)
)	O
;	O
if	O
(	O
!	O
tree	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
grecs_tree_process	(*(struct(enum(int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(struct`),*(struct`)))),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`)))))->(int)
(	O
tree	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
direvent_kw	array(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*(struct(enum(int,int,int),struct`,*`,*`,*`,*`,*`,struct`,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(void),long,*((enum(int,int,int),*`,*`,*`)->(int)),*(void),*(struct(*`,*`,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`,long,*`,*`,*`))))))
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
