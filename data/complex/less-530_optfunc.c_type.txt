extern	O
int	O
nbufs	int
;	O
extern	O
int	O
bufspace	int
;	O
extern	O
int	O
pr_type	int
;	O
extern	O
int	O
plusoption	int
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
int	O
secure	int
;	O
extern	O
int	O
dohelp	int
;	O
extern	O
int	O
any_display	int
;	O
extern	O
char	O
openquote	char
;	O
extern	O
char	O
closequote	char
;	O
extern	O
char	O
*	O
prproto	array(*(char))
[	O
]	O
;	O
extern	O
char	O
*	O
eqproto	*(char)
;	O
extern	O
char	O
*	O
hproto	*(char)
;	O
extern	O
char	O
*	O
wproto	*(char)
;	O
extern	O
char	O
*	O
every_first_cmd	*(char)
;	O
extern	O
IFILE	O
curr_ifile	*(void)
;	O
extern	O
char	O
version	array(char)
[	O
]	O
;	O
extern	O
int	O
jump_sline	int
;	O
extern	O
long	O
jump_sline_fraction	long
;	O
extern	O
int	O
shift_count	int
;	O
extern	O
long	O
shift_count_fraction	long
;	O
extern	O
LWCHAR	long
rscroll_char	long
;	O
extern	O
int	O
rscroll_attr	int
;	O
extern	O
int	O
less_is_more	int
;	O
extern	O
char	O
*	O
namelogfile	*(char)
;	O
extern	O
int	O
force_logfile	int
;	O
extern	O
int	O
logfile	int
;	O
public	O
char	O
*	O
tagoption	*(char)
=	O
NULL	O
;	O
extern	O
char	O
*	O
tags	*(char)
;	O
extern	O
char	O
ztags	array(char)
[	O
]	O
;	O
public	O
void	O
opt_o	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
char	O
*	O
filename	*(char)
;	O
if	O
(	O
secure	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"log file support is not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
namelogfile	*(char)
=	O
save	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_CANSEEK	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Input is not a pipe"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
logfile	int
>=	O
0	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Log file is already in use"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
if	O
(	O
namelogfile	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
namelogfile	*(char)
)	O
;	O
filename	*(char)
=	O
lglob	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
namelogfile	*(char)
=	O
shell_unquote	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
use_logfile	(*(char))->(void)
(	O
namelogfile	*(char)
)	O
;	O
sync_logfile	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
logfile	int
<	O
0	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"No log file"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
namelogfile	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Log file \"%s\""	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__O	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
force_logfile	int
=	O
TRUE	int
;	O
opt_o	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
;	O
}	O
public	O
void	O
opt_j	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
char	O
buf	*(char)
[	O
16	int
]	O
;	O
int	O
len	int
;	O
int	O
err	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'.'	O
)	O
{	O
s	*(char)
++	O
;	O
jump_sline_fraction	long
=	O
getfraction	(*(*(char)),*(char),*(int))->(long)
(	O
&	O
s	*(char)
,	O
"j"	*(char)
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Invalid line fraction"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
calc_jump_sline	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
int	O
sline	int
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
s	*(char)
,	O
"j"	*(char)
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Invalid line number"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
jump_sline	int
=	O
sline	int
;	O
jump_sline_fraction	long
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
jump_sline_fraction	long
<	O
0	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_int	int
=	O
jump_sline	int
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Position target at screen line %d"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
".%06ld"	*(char)
,	O
jump_sline_fraction	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
while	O
(	O
len	int
>	O
2	int
&&	O
buf	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'0'	O
)	O
len	int
--	O
;	O
buf	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
buf	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Position target at screen position %s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
calc_jump_sline	()->(void)
(	O
)	O
{	O
if	O
(	O
jump_sline_fraction	long
<	O
0	int
)	O
return	O
;	O
jump_sline	int
=	O
sc_height	int
*	O
jump_sline_fraction	long
/	O
NUM_FRAC_DENOM	int
;	O
}	O
public	O
void	O
opt_shift	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
char	O
buf	*(char)
[	O
16	int
]	O
;	O
int	O
len	int
;	O
int	O
err	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
*	O
s	*(char)
==	O
'.'	O
)	O
{	O
s	*(char)
++	O
;	O
shift_count_fraction	long
=	O
getfraction	(*(*(char)),*(char),*(int))->(long)
(	O
&	O
s	*(char)
,	O
"#"	*(char)
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Invalid column fraction"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
calc_shift_count	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
int	O
hs	int
=	O
getnum	(*(*(char)),*(char),*(int))->(int)
(	O
&	O
s	*(char)
,	O
"#"	*(char)
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Invalid column number"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
shift_count	int
=	O
hs	int
;	O
shift_count_fraction	long
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
shift_count_fraction	long
<	O
0	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_int	int
=	O
shift_count	int
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Horizontal shift %d columns"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
".%06ld"	*(char)
,	O
shift_count_fraction	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
while	O
(	O
len	int
>	O
2	int
&&	O
buf	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'0'	O
)	O
len	int
--	O
;	O
buf	*(char)
[	O
len	int
]	O
=	O
'\0'	O
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
buf	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Horizontal shift %s of screen width"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
calc_shift_count	()->(void)
(	O
)	O
{	O
if	O
(	O
shift_count_fraction	long
<	O
0	int
)	O
return	O
;	O
shift_count	int
=	O
sc_width	int
*	O
shift_count_fraction	long
/	O
NUM_FRAC_DENOM	int
;	O
}	O
public	O
void	O
opt_k	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
if	O
(	O
lesskey	(*(char),int)->(int)
(	O
s	*(char)
,	O
0	int
)	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
s	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot use lesskey file \"%s\""	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_t	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
IFILE	O
save_ifile	*(void)
;	O
POSITION	long
pos	long
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
tagoption	*(char)
=	O
save	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
if	O
(	O
secure	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"tags support is not available"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
findtag	(*(char))->(void)
(	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
)	O
;	O
save_ifile	*(void)
=	O
save_curr_ifile	()->(*(void))
(	O
)	O
;	O
if	O
(	O
edit_tagfile	()->(int)
(	O
)	O
||	O
(	O
pos	long
=	O
tagsearch	()->(long)
(	O
)	O
)	O
==	O
NULL_POSITION	O
)	O
{	O
reedit_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
break	O
;	O
}	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
jump_loc	(long,int)->(void)
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__T	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
char	O
*	O
filename	*(char)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
tags	*(char)
=	O
save	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
if	O
(	O
tags	*(char)
!=	O
NULL	O
&&	O
tags	*(char)
!=	O
ztags	array(char)
)	O
free	(*(void))->(void)
(	O
tags	*(char)
)	O
;	O
filename	*(char)
=	O
lglob	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
tags	*(char)
=	O
shell_unquote	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
tags	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Tags file \"%s\""	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_p	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
if	O
(	O
less_is_more	int
)	O
{	O
every_first_cmd	*(char)
=	O
save	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
}	O
else	O
{	O
plusoption	int
=	O
TRUE	int
;	O
ungetcc	(long)->(void)
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
ungetsc	(*(char))->(void)
(	O
"/"	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__P	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
char	O
*	O
*	O
proto	*(char)
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
's'	O
:	O
proto	*(char)
=	O
&	O
prproto	array(*(char))
[	O
PR_SHORT	int
]	O
;	O
s	*(char)
++	O
;	O
break	O
;	O
case	O
'm'	O
:	O
proto	*(char)
=	O
&	O
prproto	array(*(char))
[	O
PR_MEDIUM	int
]	O
;	O
s	*(char)
++	O
;	O
break	O
;	O
case	O
'M'	O
:	O
proto	*(char)
=	O
&	O
prproto	array(*(char))
[	O
PR_LONG	int
]	O
;	O
s	*(char)
++	O
;	O
break	O
;	O
case	O
'='	O
:	O
proto	*(char)
=	O
&	O
eqproto	*(char)
;	O
s	*(char)
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
proto	*(char)
=	O
&	O
hproto	*(char)
;	O
s	*(char)
++	O
;	O
break	O
;	O
case	O
'w'	O
:	O
proto	*(char)
=	O
&	O
wproto	*(char)
;	O
s	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
proto	*(char)
=	O
&	O
prproto	array(*(char))
[	O
PR_SHORT	int
]	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
*	O
proto	*(char)
)	O
;	O
*	O
proto	*(char)
=	O
save	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
prproto	array(*(char))
[	O
pr_type	int
]	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_b	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
ch_setbufspace	(int)->(void)
(	O
bufspace	int
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_i	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
TOGGLE	int
:	O
chg_caseless	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
case	O
INIT	int
:	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__V	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
TOGGLE	int
:	O
case	O
QUERY	int
:	O
dispversion	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
INIT	int
:	O
any_display	int
=	O
1	int
;	O
putstr	(*(char))->(void)
(	O
"less "	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
version	array(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
" ("	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"POSIX "	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"regular expressions)\n"	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"Copyright (C) 1984-2017  Mark Nudelman\n\n"	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"less comes with NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"For information about the terms of redistribution,\n"	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"see the file named README in the less distribution.\n"	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
"Homepage: http://www.greenwoodsoftware.com/less\n"	*(char)
)	O
;	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_x	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
extern	O
int	O
tabstops	array(int)
[	O
]	O
;	O
extern	O
int	O
ntabstops	int
;	O
extern	O
int	O
tabdefault	int
;	O
char	O
msg	array(char)
[	O
60	int
+	O
(	O
4	int
*	O
TABSTOP_MAX	int
)	O
]	O
;	O
int	O
i	int
;	O
PARG	union(*(char),int,long)
p	*(char)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
TABSTOP_MAX	int
;	O
)	O
{	O
int	O
n	int
=	O
0	int
;	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
while	O
(	O
*	O
s	*(char)
>=	O
'0'	O
&&	O
*	O
s	*(char)
<=	O
'9'	O
)	O
n	int
=	O
(	O
10	int
*	O
n	int
)	O
+	O
(	O
*	O
s	*(char)
++	O
-	O
'0'	O
)	O
;	O
if	O
(	O
n	int
>	O
tabstops	array(int)
[	O
i	int
-	O
1	int
]	O
)	O
tabstops	array(int)
[	O
i	int
++	O
]	O
=	O
n	int
;	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
if	O
(	O
*	O
s	*(char)
++	O
!=	O
','	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
<	O
2	int
)	O
return	O
;	O
ntabstops	int
=	O
i	int
;	O
tabdefault	int
=	O
tabstops	array(int)
[	O
ntabstops	int
-	O
1	int
]	O
-	O
tabstops	array(int)
[	O
ntabstops	int
-	O
2	int
]	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
msg	array(char)
,	O
"Tab stops "	*(char)
)	O
;	O
if	O
(	O
ntabstops	int
>	O
2	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ntabstops	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
msg	array(char)
,	O
","	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
msg	array(char)
+	O
strlen	(*(char))->(long)
(	O
msg	array(char)
)	O
,	O
"%d"	*(char)
,	O
tabstops	array(int)
[	O
i	int
]	O
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
msg	array(char)
+	O
strlen	(*(char))->(long)
(	O
msg	array(char)
)	O
,	O
" and then "	*(char)
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
msg	array(char)
+	O
strlen	(*(char))->(long)
(	O
msg	array(char)
)	O
,	O
"every %d spaces"	*(char)
,	O
tabdefault	int
)	O
;	O
p	*(char)
.	O
p_string	*(char)
=	O
msg	array(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
p	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_quote	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
char	O
buf	*(char)
[	O
3	int
]	O
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
s	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
openquote	char
=	O
closequote	char
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
s	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
s	*(char)
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"-\" must be followed by 1 or 2 chars"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
openquote	char
=	O
s	*(char)
[	O
0	int
]	O
;	O
if	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
closequote	char
=	O
openquote	char
;	O
else	O
closequote	char
=	O
s	*(char)
[	O
1	int
]	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
buf	*(char)
[	O
0	int
]	O
=	O
openquote	char
;	O
buf	*(char)
[	O
1	int
]	O
=	O
closequote	char
;	O
buf	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
buf	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"quotes %s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_rscroll	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
PARG	union(*(char),int,long)
p	*(char)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
{	O
char	O
*	O
fmt	*(char)
;	O
int	O
attr	int
=	O
AT_STANDOUT	O
;	O
setfmt	(*(char),*(*(char)),*(int),*(char))->(void)
(	O
s	*(char)
,	O
&	O
fmt	*(char)
,	O
&	O
attr	int
,	O
"*s>"	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
fmt	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
rscroll_char	long
=	O
0	int
;	O
}	O
else	O
{	O
rscroll_char	long
=	O
*	O
fmt	*(char)
?	O
*	O
fmt	*(char)
:	O
'>'	O
;	O
rscroll_attr	int
=	O
attr	int
;	O
}	O
break	O
;	O
}	O
case	O
QUERY	int
:	O
{	O
p	*(char)
.	O
p_string	*(char)
=	O
rscroll_char	long
?	O
prchar	(long)->(*(char))
(	O
rscroll_char	long
)	O
:	O
"-"	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"rscroll char is %s"	*(char)
,	O
&	O
p	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
public	O
void	O
opt_query	(int,*(char))->(void)
(	O
type	int
,	O
s	*(char)
)	O
int	O
type	int
;	O
char	O
*	O
s	*(char)
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
QUERY	int
:	O
case	O
TOGGLE	int
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Use \"h\" for help"	*(char)
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
INIT	int
:	O
dohelp	int
=	O
1	int
;	O
}	O
}	O
public	O
int	O
get_swindow	()->(int)
(	O
)	O
{	O
if	O
(	O
swindow	int
>	O
0	int
)	O
return	O
(	O
swindow	int
)	O
;	O
return	O
(	O
sc_height	int
+	O
swindow	int
)	O
;	O
}	O
