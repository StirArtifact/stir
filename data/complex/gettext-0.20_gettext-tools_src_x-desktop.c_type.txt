static	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
;	O
static	O
bool	bool
default_keywords	bool
=	O
true	int
;	O
static	O
void	O
add_keyword	(*(char),*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),bool)->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
bool	bool
is_list	bool
)	O
{	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
default_keywords	bool
=	O
false	int
;	O
else	O
{	O
if	O
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
==	O
NULL	O
)	O
hash_init	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),long)->(int)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
100	int
)	O
;	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
name	*(char)
,	O
is_list	bool
)	O
;	O
}	O
}	O
void	O
x_desktop_keyword	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
add_keyword	(*(char),*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),bool)->(void)
(	O
name	*(char)
,	O
&	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
false	int
)	O
;	O
}	O
static	O
void	O
init_keywords	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
default_keywords	bool
)	O
{	O
if	O
(	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
.	O
table	*(struct)
==	O
NULL	O
)	O
hash_init	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),long)->(int)
(	O
&	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
100	int
)	O
;	O
desktop_add_default_keywords	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
&	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
;	O
default_keywords	bool
=	O
false	int
;	O
}	O
}	O
typedef	O
struct	O
extract_desktop_reader_ty	struct
extract_desktop_reader_ty	struct
;	O
struct	O
extract_desktop_reader_ty	struct
{	O
DESKTOP_READER_TY	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
}	O
;	O
static	O
void	O
extract_desktop_handle_group	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
struct	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
group	*(char)
)	O
{	O
savable_comment_reset	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
extract_desktop_handle_pair	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),long)),*(char),*(char),*(char))->(void)
(	O
struct	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
lex_pos_ty	struct
*	O
key_pos	*(struct(*(char),long))
,	O
const	O
char	O
*	O
key	*(void)
,	O
const	O
char	O
*	O
locale	*(char)
,	O
const	O
char	O
*	O
value	enum(int,int,int,int,int,int)
)	O
{	O
extract_desktop_reader_ty	struct
*	O
extract_reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
=	O
(	O
extract_desktop_reader_ty	struct
*	O
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
;	O
void	O
*	O
keyword_value	*(void)
;	O
if	O
(	O
!	O
locale	*(char)
&&	O
hash_find_entry	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,*(*(void)))->(int)
(	O
&	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
key	*(void)
,	O
strlen	(*(char))->(long)
(	O
key	*(void)
)	O
,	O
&	O
keyword_value	*(void)
)	O
==	O
0	int
)	O
{	O
bool	bool
is_list	bool
=	O
(	O
bool	bool
)	O
keyword_value	*(void)
;	O
remember_a_message	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),bool,struct(int,int,int,int,int,int),*(struct(*(char),long)),*(char),*(struct(int,struct(*(*`),long,long))),bool)->(*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)),int,*(struct(*`,long,*`,*`,*`,*`)))))
(	O
extract_reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
NULL	O
,	O
desktop_unescape_string	(*(char),bool)->(*(char))
(	O
value	enum(int,int,int,int,int,int)
,	O
is_list	bool
)	O
,	O
false	int
,	O
null_context	struct(int,int,int,int,int,int)
,	O
key_pos	*(struct(*(char),long))
,	O
NULL	O
,	O
savable_comment	*(struct(int,struct(*(*(char)),long,long)))
,	O
false	int
)	O
;	O
}	O
savable_comment_reset	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
extract_desktop_handle_comment	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
struct	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
buffer	*(char)
)	O
{	O
size_t	long
buflen	long
=	O
strlen	(*(char))->(long)
(	O
buffer	*(char)
)	O
;	O
size_t	long
bufpos	long
=	O
0	int
;	O
while	O
(	O
bufpos	long
<	O
buflen	long
&&	O
c_isspace	(int)->(bool)
(	O
buffer	*(char)
[	O
bufpos	long
]	O
)	O
)	O
++	O
bufpos	long
;	O
while	O
(	O
buflen	long
>=	O
bufpos	long
&&	O
c_isspace	(int)->(bool)
(	O
buffer	*(char)
[	O
buflen	long
-	O
1	int
]	O
)	O
)	O
--	O
buflen	long
;	O
if	O
(	O
bufpos	long
<	O
buflen	long
)	O
{	O
char	O
*	O
comment	*(struct(*(*(char)),long,long))
=	O
xstrdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
comment	*(struct(*(*(char)),long,long))
[	O
buflen	long
]	O
=	O
0	int
;	O
savable_comment_add	(*(char))->(void)
(	O
&	O
comment	*(struct(*(*(char)),long,long))
[	O
bufpos	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
comment	*(struct(*(*(char)),long,long))
)	O
;	O
}	O
}	O
static	O
void	O
extract_desktop_handle_blank	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
struct	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
savable_comment_reset	()->(void)
(	O
)	O
;	O
}	O
desktop_reader_class_ty	struct
extract_methods	struct(long,*((*(struct(*`)))->(void)),*((*(struct(*`)))->(void)),*((*(struct(*`)),*(char))->(void)),*((*(struct(*`)),*(struct(*`,long)),*(char),*(char),*(char))->(void)),*((*(struct(*`)),*(char))->(void)),*((*(struct(*`)),*(char))->(void)))
=	O
{	O
sizeof	O
(	O
extract_desktop_reader_ty	struct
)	O
,	O
NULL	O
,	O
NULL	O
,	O
extract_desktop_handle_group	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
,	O
extract_desktop_handle_pair	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),long)),*(char),*(char),*(char))->(void)
,	O
extract_desktop_handle_comment	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
,	O
extract_desktop_handle_blank	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
}	O
;	O
void	O
extract_desktop	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(struct(*(*(struct`)),long,long,bool,*(char))))->(void)
(	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
real_filename	*(char)
,	O
const	O
char	O
*	O
logical_filename	*(char)
,	O
flag_context_list_table_ty	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
*	O
flag_table	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
msgdomain_list_ty	struct
*	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
)	O
{	O
desktop_reader_ty	struct
*	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
=	O
desktop_reader_alloc	(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))))->(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))))
(	O
&	O
extract_methods	struct(long,*((*(struct(*`)))->(void)),*((*(struct(*`)))->(void)),*((*(struct(*`)),*(char))->(void)),*((*(struct(*`)),*(struct(*`,long)),*(char),*(char),*(char))->(void)),*((*(struct(*`)),*(char))->(void)),*((*(struct(*`)),*(char))->(void)))
)	O
;	O
extract_desktop_reader_ty	struct
*	O
extract_reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
=	O
(	O
extract_desktop_reader_ty	struct
*	O
)	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
;	O
init_keywords	()->(void)
(	O
)	O
;	O
xgettext_current_source_encoding	*(char)
=	O
po_charset_utf8	*(char)
;	O
extract_reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)))),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
->	O
item	*(*(char))
[	O
0	int
]	O
->	O
messages	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
desktop_parse	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
real_filename	*(char)
,	O
logical_filename	*(char)
)	O
;	O
desktop_reader_free	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
)	O
;	O
reader	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void))))))
=	O
NULL	O
;	O
}	O
