OBJID	long
EDMAPROC	O
edma_upcast_obj	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
classname	*(*(char))
)	O
{	O
CLASSID	long
idc	long
;	O
ESint32	long
i	long
,	O
ap	long
;	O
OBJID	long
f	*(char)
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_upcast_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
idc	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
classname	*(*(char))
)	O
;	O
ap	long
=	O
0	int
;	O
if	O
(	O
idc	long
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
==	O
idc	long
)	O
return	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
}	O
else	O
ap	long
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
!=	O
-	O
1	int
)	O
{	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
ap	long
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
classname	*(*(char))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
return	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
else	O
{	O
f	*(char)
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
if	O
(	O
f	*(char)
!=	O
-	O
1	int
)	O
return	O
f	*(char)
;	O
}	O
continue	O
;	O
}	O
f	*(char)
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
if	O
(	O
f	*(char)
!=	O
-	O
1	int
)	O
return	O
f	*(char)
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_downcast_obj	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
classname	*(*(char))
)	O
{	O
CLASSID	long
idc	long
;	O
ESint32	long
i	long
,	O
ap	long
;	O
OBJID	long
f	*(char)
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_downcast_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
idc	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
classname	*(*(char))
)	O
;	O
ap	long
=	O
0	int
;	O
if	O
(	O
idc	long
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdClass	long
==	O
idc	long
)	O
return	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
}	O
else	O
ap	long
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] Entry %d '%s' still not linked"	*(char)
,	O
__FUNCTION__	O
,	O
i	long
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ap	long
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
classname	*(*(char))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
return	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
;	O
else	O
{	O
f	*(char)
=	O
edma_downcast_obj	(long,*(char))->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
if	O
(	O
f	*(char)
!=	O
-	O
1	int
)	O
return	O
f	*(char)
;	O
}	O
continue	O
;	O
}	O
f	*(char)
=	O
edma_downcast_obj	(long,*(char))->(long)
(	O
pObj2	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
if	O
(	O
f	*(char)
!=	O
-	O
1	int
)	O
return	O
f	*(char)
;	O
}	O
return	O
-	O
1	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_cast_obj	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
classname	*(*(char))
)	O
{	O
OBJID	long
id	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_cast_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
if	O
(	O
id	long
==	O
-	O
1	int
)	O
id	long
=	O
edma_downcast_obj	(long,*(char))->(long)
(	O
IdObj	long
,	O
classname	*(*(char))
)	O
;	O
return	O
id	long
;	O
}	O
