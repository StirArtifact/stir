void	O
DISUpdateWorldCoordinates	(*(struct(double,double,double)),double,double,double)->(void)
(	O
WorldCoordinates	struct(double,double,double)
*	O
p	*(struct(char,char,short,char,char,char,char))
,	O
double	O
cos_course	double
,	O
double	O
sin_course	double
,	O
double	O
d_meters	double
)	O
{	O
double	O
n1	double
,	O
n2	double
,	O
m1	double
;	O
double	O
sin_lat	double
,	O
sin_lat_sqr	double
,	O
tan_lat	double
,	O
sin_course_sqr	double
;	O
double	O
delta_latitude	double
,	O
delta_longitude	double
,	O
d_sqr	double
,	O
cos_lat	double
;	O
double	O
B	double
,	O
C	double
,	O
E	double
,	O
h	double
,	O
sin_newlat	double
;	O
double	O
wgs84_a	double
=	O
WGS84_MAJOR	int
+	O
p	*(struct(char,char,short,char,char,char,char))
->	O
z	float
;	O
sin_lat	double
=	O
sin	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
sin_lat_sqr	double
=	O
sin_lat	double
*	O
sin_lat	double
;	O
cos_lat	double
=	O
cos	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
tan_lat	double
=	O
sin_lat	double
/	O
cos_lat	double
;	O
sin_course_sqr	double
=	O
sin_course	double
*	O
sin_course	double
;	O
d_sqr	double
=	O
d_meters	double
*	O
d_meters	double
;	O
n1	double
=	O
wgs84_a	double
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
;	O
m1	double
=	O
(	O
wgs84_a	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
/	O
pow	(double,double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
,	O
1.5	int
)	O
;	O
B	double
=	O
1.0	int
/	O
m1	double
;	O
h	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
;	O
C	double
=	O
tan_lat	double
/	O
(	O
2.0	int
*	O
m1	double
*	O
n1	double
)	O
;	O
E	double
=	O
(	O
1.0	int
+	O
3.0	int
*	O
tan_lat	double
*	O
tan_lat	double
)	O
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
/	O
(	O
6.0	int
*	O
wgs84_a	double
*	O
wgs84_a	double
)	O
;	O
delta_latitude	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
-	O
d_sqr	double
*	O
C	double
*	O
sin_course_sqr	double
-	O
h	double
*	O
d_sqr	double
*	O
E	double
*	O
sin_course_sqr	double
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
+=	O
delta_latitude	double
;	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
>	O
M_PI_2	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
-=	O
M_PI_2	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
<	O
-	O
M_PI_2	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
+=	O
M_PI_2	int
;	O
}	O
sin_newlat	double
=	O
sin	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
n2	double
=	O
wgs84_a	double
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_newlat	double
*	O
sin_newlat	double
)	O
;	O
delta_longitude	double
=	O
(	O
d_meters	double
*	O
sin_course	double
)	O
/	O
(	O
n2	double
*	O
cos	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
+=	O
delta_longitude	double
;	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
>	O
M_PI	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
-=	O
M_PI	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
<	O
-	O
M_PI	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
+=	O
M_PI	int
;	O
}	O
}	O
void	O
DISUpdateWorldCoordinatesEx	(*(struct(double,double,double)),double,double,double,*(double))->(void)
(	O
WorldCoordinates	struct(double,double,double)
*	O
p	*(struct(char,char,short,char,char,char,char))
,	O
double	O
cos_course	double
,	O
double	O
sin_course	double
,	O
double	O
d_meters	double
,	O
double	O
*	O
delta_course_rad	*(double)
)	O
{	O
double	O
n1	double
,	O
n2	double
,	O
m1	double
;	O
double	O
sin_lat	double
,	O
sin_lat_sqr	double
,	O
tan_lat	double
,	O
sin_course_sqr	double
;	O
double	O
delta_latitude	double
,	O
delta_longitude	double
,	O
d_sqr	double
,	O
cos_lat	double
;	O
double	O
B	double
,	O
C	double
,	O
E	double
,	O
h	double
,	O
sin_newlat	double
;	O
double	O
old_latitude	double
,	O
phi_m	double
,	O
sin_phi_m	double
,	O
cos_phi_m	double
;	O
const	O
double	O
rho	double
=	O
206264.8062470964	int
;	O
double	O
wgs84_a	double
=	O
WGS84_MAJOR	int
+	O
p	*(struct(char,char,short,char,char,char,char))
->	O
z	float
;	O
sin_lat	double
=	O
sin	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
sin_lat_sqr	double
=	O
sin_lat	double
*	O
sin_lat	double
;	O
cos_lat	double
=	O
cos	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
tan_lat	double
=	O
sin_lat	double
/	O
cos_lat	double
;	O
sin_course_sqr	double
=	O
sin_course	double
*	O
sin_course	double
;	O
d_sqr	double
=	O
d_meters	double
*	O
d_meters	double
;	O
n1	double
=	O
wgs84_a	double
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
;	O
m1	double
=	O
(	O
wgs84_a	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
/	O
pow	(double,double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
,	O
1.5	int
)	O
;	O
B	double
=	O
1.0	int
/	O
m1	double
;	O
h	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
;	O
C	double
=	O
tan_lat	double
/	O
(	O
2.0	int
*	O
m1	double
*	O
n1	double
)	O
;	O
E	double
=	O
(	O
1.0	int
+	O
3.0	int
*	O
tan_lat	double
*	O
tan_lat	double
)	O
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
/	O
(	O
6.0	int
*	O
wgs84_a	double
*	O
wgs84_a	double
)	O
;	O
delta_latitude	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
-	O
d_sqr	double
*	O
C	double
*	O
sin_course_sqr	double
-	O
h	double
*	O
d_sqr	double
*	O
E	double
*	O
sin_course_sqr	double
;	O
old_latitude	double
=	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
+=	O
delta_latitude	double
;	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
>	O
M_PI_2	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
-=	O
M_PI_2	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
<	O
-	O
M_PI_2	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
+=	O
M_PI_2	int
;	O
}	O
phi_m	double
=	O
old_latitude	double
+	O
delta_latitude	double
/	O
2.0	int
;	O
sin_phi_m	double
=	O
sin	(double)->(double)
(	O
phi_m	double
)	O
;	O
cos_phi_m	double
=	O
cos	(double)->(double)
(	O
phi_m	double
)	O
;	O
sin_newlat	double
=	O
sin	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
;	O
n2	double
=	O
wgs84_a	double
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_newlat	double
*	O
sin_newlat	double
)	O
;	O
delta_longitude	double
=	O
(	O
d_meters	double
*	O
sin_course	double
)	O
/	O
(	O
n2	double
*	O
cos	(double)->(double)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
)	O
)	O
;	O
*	O
delta_course_rad	*(double)
=	O
delta_longitude	double
*	O
sin_phi_m	double
/	O
cos	(double)->(double)
(	O
delta_latitude	double
/	O
2.0	int
)	O
+	O
delta_longitude	double
*	O
(	O
sin_phi_m	double
*	O
cos_phi_m	double
*	O
cos_phi_m	double
)	O
/	O
rho	double
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
+=	O
delta_longitude	double
;	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
>	O
M_PI	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
-=	O
M_PI	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
<	O
-	O
M_PI	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
+=	O
M_PI	int
;	O
}	O
}	O
void	O
DISGeocentricToWorldCoordinates	(*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
dis_world_coordinates	struct(double,double,double)
*	O
loc	struct(float,float,float)
,	O
WorldCoordinates	struct(double,double,double)
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
double	O
a_sqr	double
=	O
WGS84_MAJOR	int
*	O
WGS84_MAJOR	int
,	O
b_sqr	double
=	O
WGS84_MINOR	int
*	O
WGS84_MINOR	int
;	O
double	O
w	*(struct(double,double,double))
,	O
x	float
,	O
x_sqr	double
,	O
z	float
,	O
delta_x	double
,	O
cos_x	double
;	O
double	O
f	array(float)
,	O
f_prime	double
,	O
w0	double
,	O
z0	double
;	O
w	*(struct(double,double,double))
=	O
sqrt	(double)->(double)
(	O
loc	struct(float,float,float)
->	O
x	float
*	O
loc	struct(float,float,float)
->	O
x	float
+	O
loc	struct(float,float,float)
->	O
y	float
*	O
loc	struct(float,float,float)
->	O
y	float
)	O
;	O
z	float
=	O
loc	struct(float,float,float)
->	O
z	float
;	O
if	O
(	O
w	*(struct(double,double,double))
==	O
0.0	int
&&	O
z	float
==	O
0.0	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
=	O
0.0	int
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
=	O
0.0	int
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
z	float
=	O
0.0	int
;	O
return	O
;	O
}	O
x	float
=	O
z	float
/	O
sqrt	(double)->(double)
(	O
w	*(struct(double,double,double))
*	O
w	*(struct(double,double,double))
+	O
z	float
*	O
z	float
)	O
;	O
for	O
(	O
delta_x	double
=	O
1.0	int
;	O
fabs	(double)->(double)
(	O
delta_x	double
)	O
>	O
4.8E-10	int
;	O
)	O
{	O
x_sqr	double
=	O
x	float
*	O
x	float
;	O
cos_x	double
=	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
x_sqr	double
)	O
;	O
f	array(float)
=	O
2.0	int
*	O
(	O
WGS84_MAJOR	int
*	O
x	float
*	O
w	*(struct(double,double,double))
-	O
a_sqr	double
*	O
x	float
*	O
cos_x	double
-	O
WGS84_MINOR	int
*	O
cos_x	double
*	O
z	float
+	O
b_sqr	double
*	O
cos_x	double
*	O
x	float
)	O
;	O
f_prime	double
=	O
2.0	int
*	O
(	O
a_sqr	double
+	O
2.0	int
*	O
(	O
a_sqr	double
*	O
x_sqr	double
)	O
-	O
WGS84_MAJOR	int
*	O
w	*(struct(double,double,double))
*	O
x_sqr	double
+	O
b_sqr	double
-	O
2.0	int
*	O
b_sqr	double
*	O
x_sqr	double
+	O
WGS84_MINOR	int
*	O
x	float
*	O
z	float
)	O
;	O
delta_x	double
=	O
f	array(float)
/	O
f_prime	double
;	O
x	float
-=	O
delta_x	double
;	O
}	O
z0	double
=	O
WGS84_MINOR	int
*	O
x	float
;	O
w0	double
=	O
WGS84_MAJOR	int
*	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
x	float
*	O
x	float
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
z	float
=	O
sqrt	(double)->(double)
(	O
(	O
z	float
-	O
z0	double
)	O
*	O
(	O
z	float
-	O
z0	double
)	O
+	O
(	O
w	*(struct(double,double,double))
-	O
w0	double
)	O
*	O
(	O
w	*(struct(double,double,double))
-	O
w0	double
)	O
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
latitude	double
=	O
atan	(double)->(double)
(	O
z0	double
/	O
(	O
w0	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
longitude	double
=	O
atan2	(double,double)->(double)
(	O
loc	struct(float,float,float)
->	O
y	float
,	O
loc	struct(float,float,float)
->	O
x	float
)	O
;	O
}	O
void	O
DISWorldCoordinatesToGeocentric	(*(struct(double,double,double)),*(struct(double,double,double)))->(void)
(	O
WorldCoordinates	struct(double,double,double)
*	O
w	*(struct(double,double,double))
,	O
dis_world_coordinates	struct(double,double,double)
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
double	O
N	double
,	O
N1	double
;	O
double	O
cos_latitude	double
,	O
sin_latitude	double
;	O
sin_latitude	double
=	O
sin	(double)->(double)
(	O
w	*(struct(double,double,double))
->	O
latitude	double
)	O
;	O
cos_latitude	double
=	O
cos	(double)->(double)
(	O
w	*(struct(double,double,double))
->	O
latitude	double
)	O
;	O
N	double
=	O
WGS84_MAJOR	int
/	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
(	O
WGS84_ECC_SQR	int
*	O
sin_latitude	double
*	O
sin_latitude	double
)	O
)	O
;	O
N1	double
=	O
N	double
+	O
w	*(struct(double,double,double))
->	O
z	float
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
x	float
=	O
N1	double
*	O
cos_latitude	double
*	O
cos	(double)->(double)
(	O
w	*(struct(double,double,double))
->	O
longitude	double
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
y	float
=	O
N1	double
*	O
cos_latitude	double
*	O
sin	(double)->(double)
(	O
w	*(struct(double,double,double))
->	O
longitude	double
)	O
;	O
p	*(struct(char,char,short,char,char,char,char))
->	O
z	float
=	O
(	O
(	O
(	O
WGS84_MINOR	int
*	O
WGS84_MINOR	int
)	O
/	O
(	O
WGS84_MAJOR	int
*	O
WGS84_MAJOR	int
)	O
)	O
*	O
N	double
+	O
w	*(struct(double,double,double))
->	O
z	float
)	O
*	O
sin_latitude	double
;	O
}	O
char	O
*	O
DISLatitudeToString	(*(char),double,enum(int,int,int,int))->(*(char))
(	O
char	O
*	O
s	array(short)
,	O
double	O
la	double
,	O
LatLongDisplayFormat	enum(int,int,int,int)
mode	enum(int,int,int,int)
)	O
{	O
int	O
d	double
,	O
m	array(array(double))
;	O
double	O
dla	double
,	O
dmin	double
,	O
dsec	double
;	O
double	O
round_dms	double
=	O
1.0	int
/	O
(	O
36000.0	int
*	O
2.0	int
)	O
;	O
double	O
round_dm	double
=	O
1.0	int
/	O
(	O
600.0	int
*	O
2.0	int
)	O
;	O
char	O
*	O
ns	*(char)
;	O
round_dms	double
=	O
round_dm	double
=	O
0.0	int
;	O
switch	O
(	O
mode	enum(int,int,int,int)
)	O
{	O
case	O
LLM_DMS	int
:	O
ns	*(char)
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	*(char)
:	O
"S"	*(char)
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
la	double
)	O
)	O
+	O
round_dms	double
;	O
d	double
=	O
(	O
int	O
)	O
dla	double
;	O
dmin	double
=	O
(	O
dla	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
m	array(array(double))
=	O
(	O
int	O
)	O
dmin	double
;	O
dsec	double
=	O
(	O
dmin	double
-	O
(	O
double	O
)	O
m	array(array(double))
)	O
*	O
60.0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%d %d %.1f %s"	*(char)
,	O
d	double
,	O
m	array(array(double))
,	O
dsec	double
,	O
ns	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_DM	int
:	O
ns	*(char)
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	*(char)
:	O
"S"	*(char)
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
la	double
)	O
)	O
+	O
round_dm	double
;	O
d	double
=	O
(	O
int	O
)	O
dla	double
;	O
dmin	double
=	O
(	O
dla	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%d %.1f %s"	*(char)
,	O
d	double
,	O
dmin	double
,	O
ns	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_D	int
:	O
ns	*(char)
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	*(char)
:	O
"S"	*(char)
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
la	double
)	O
)	O
+	O
0.05	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%.1f %s"	*(char)
,	O
dla	double
,	O
ns	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_SIGNED_D	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%.1f"	*(char)
,	O
RADtoDEG	O
(	O
la	double
)	O
)	O
;	O
break	O
;	O
}	O
return	O
s	array(short)
;	O
}	O
char	O
*	O
DISLongitudeToString	(*(char),double,enum(int,int,int,int))->(*(char))
(	O
char	O
*	O
s	array(short)
,	O
double	O
lo	double
,	O
LatLongDisplayFormat	enum(int,int,int,int)
mode	enum(int,int,int,int)
)	O
{	O
int	O
d	double
,	O
m	array(array(double))
;	O
double	O
dlo	double
,	O
dmin	double
,	O
dsec	double
;	O
double	O
round_dms	double
=	O
1.0	int
/	O
(	O
36000.0	int
*	O
2.0	int
)	O
;	O
double	O
round_dm	double
=	O
1.0	int
/	O
(	O
600.0	int
*	O
2.0	int
)	O
;	O
char	O
*	O
ew	*(char)
;	O
round_dms	double
=	O
round_dm	double
=	O
0.0	int
;	O
switch	O
(	O
mode	enum(int,int,int,int)
)	O
{	O
case	O
LLM_DMS	int
:	O
ew	*(char)
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	*(char)
:	O
"W"	*(char)
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
lo	double
)	O
)	O
+	O
round_dms	double
;	O
d	double
=	O
(	O
int	O
)	O
dlo	double
;	O
dmin	double
=	O
(	O
dlo	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
m	array(array(double))
=	O
(	O
int	O
)	O
dmin	double
;	O
dsec	double
=	O
(	O
dmin	double
-	O
(	O
double	O
)	O
m	array(array(double))
)	O
*	O
60.0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%d %d %.1f %s"	*(char)
,	O
d	double
,	O
m	array(array(double))
,	O
dsec	double
,	O
ew	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_DM	int
:	O
ew	*(char)
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	*(char)
:	O
"W"	*(char)
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
lo	double
)	O
)	O
+	O
round_dm	double
;	O
d	double
=	O
(	O
int	O
)	O
dlo	double
;	O
dmin	double
=	O
(	O
dlo	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%d %.1f %s"	*(char)
,	O
d	double
,	O
dmin	double
,	O
ew	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_D	int
:	O
ew	*(char)
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	*(char)
:	O
"W"	*(char)
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	(double)->(double)
(	O
lo	double
)	O
)	O
+	O
0.05	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%.1f %s"	*(char)
,	O
dlo	double
,	O
ew	*(char)
)	O
;	O
break	O
;	O
case	O
LLM_SIGNED_D	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s	array(short)
,	O
"%.1f"	*(char)
,	O
RADtoDEG	O
(	O
lo	double
)	O
)	O
;	O
break	O
;	O
}	O
return	O
s	array(short)
;	O
}	O
typedef	O
enum	O
{	O
EndOfFile	int
,	O
TOKEN_FLOAT	int
,	O
TOKEN_LONG	int
,	O
TOKEN_DASH	int
,	O
TOKEN_NORTH	int
,	O
TOKEN_SOUTH	int
,	O
TOKEN_EAST	int
,	O
TOKEN_WEST	int
}	O
token_id	enum(int,int,int,int,int,int,int,int)
;	O
typedef	O
union	O
{	O
double	O
double_value	double
;	O
long	O
long_value	long
;	O
}	O
lex_val	union(double,long)
;	O
static	O
lex_val	union(double,long)
lex_value	union(double,long)
;	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
{	O
char	O
*	O
s	array(short)
;	O
FILE	struct
*	O
f	array(float)
;	O
int	O
lookahead_valid	int
;	O
int	O
lookahead	int
;	O
int	O
stack_top	int
;	O
lex_val	union(double,long)
value_stack	array(union(double,long))
[	O
16	int
]	O
;	O
}	O
;	O
static	O
int	O
input	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
int	O
val	array(int)
;	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
lookahead_valid	int
)	O
{	O
p	*(struct(char,char,short,char,char,char,char))
->	O
lookahead_valid	int
=	O
0	int
;	O
val	array(int)
=	O
p	*(struct(char,char,short,char,char,char,char))
->	O
lookahead	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
s	array(short)
)	O
{	O
val	array(int)
=	O
*	O
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
s	array(short)
)	O
++	O
;	O
}	O
else	O
{	O
val	array(int)
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(char,char,short,char,char,char,char))
->	O
f	array(float)
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
char	O
token	array(char)
[	O
256	int
]	O
;	O
static	O
int	O
token_length	int
=	O
0	int
;	O
static	O
token_id	enum(int,int,int,int,int,int,int,int)
NextTokenx	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
register	O
int	O
c	array(char)
,	O
state	*(int)
=	O
STATE_INITIAL	int
;	O
token_length	int
=	O
0	int
;	O
while	O
(	O
(	O
c	array(char)
=	O
input	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
STATE_INITIAL	int
:	O
if	O
(	O
isspace	(int)->(int)
(	O
c	array(char)
)	O
)	O
{	O
continue	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	array(char)
)	O
)	O
{	O
token	array(char)
[	O
token_length	int
++	O
]	O
=	O
c	array(char)
;	O
state	*(int)
=	O
STATE_INTEGER	int
;	O
}	O
else	O
if	O
(	O
c	array(char)
==	O
'.'	O
)	O
{	O
token	array(char)
[	O
token_length	int
++	O
]	O
=	O
c	array(char)
;	O
state	*(int)
=	O
STATE_FLOAT	int
;	O
}	O
else	O
{	O
token	array(char)
[	O
0	int
]	O
=	O
c	array(char)
;	O
token	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
switch	O
(	O
c	array(char)
)	O
{	O
case	O
'-'	O
:	O
return	O
TOKEN_DASH	int
;	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
return	O
TOKEN_NORTH	int
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
return	O
TOKEN_EAST	int
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
return	O
TOKEN_SOUTH	int
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
return	O
TOKEN_WEST	int
;	O
default	O
:	O
return	O
EndOfFile	int
;	O
}	O
}	O
break	O
;	O
case	O
STATE_INTEGER	int
:	O
case	O
STATE_FLOAT	int
:	O
if	O
(	O
isspace	(int)->(int)
(	O
c	array(char)
)	O
||	O
c	array(char)
==	O
'-'	O
||	O
toupper	(int)->(int)
(	O
c	array(char)
)	O
==	O
'N'	O
||	O
toupper	(int)->(int)
(	O
c	array(char)
)	O
==	O
'S'	O
||	O
toupper	(int)->(int)
(	O
c	array(char)
)	O
==	O
'W'	O
||	O
toupper	(int)->(int)
(	O
c	array(char)
)	O
==	O
'E'	O
)	O
{	O
token	array(char)
[	O
token_length	int
]	O
=	O
'\0'	O
;	O
unput	O
(	O
p	*(struct(char,char,short,char,char,char,char))
,	O
c	array(char)
)	O
;	O
if	O
(	O
state	*(int)
==	O
STATE_INTEGER	int
)	O
{	O
lex_value	union(double,long)
.	O
long_value	long
=	O
atoi	(*(char))->(int)
(	O
token	array(char)
)	O
;	O
return	O
TOKEN_LONG	int
;	O
}	O
else	O
{	O
lex_value	union(double,long)
.	O
double_value	double
=	O
atof	(*(char))->(double)
(	O
token	array(char)
)	O
;	O
return	O
TOKEN_FLOAT	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c	array(char)
==	O
'.'	O
)	O
{	O
state	*(int)
=	O
STATE_FLOAT	int
;	O
}	O
token	array(char)
[	O
token_length	int
++	O
]	O
=	O
c	array(char)
;	O
}	O
break	O
;	O
default	O
:	O
token	array(char)
[	O
token_length	int
++	O
]	O
=	O
c	array(char)
;	O
break	O
;	O
}	O
}	O
return	O
EndOfFile	int
;	O
}	O
static	O
token_id	enum(int,int,int,int,int,int,int,int)
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
token_id	enum(int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int)
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextTokenx	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
return	O
t	enum(int,int,int,int,int,int,int,int)
;	O
}	O
static	O
int	O
ParseLatitude	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
double	O
x	float
=	O
0.0	int
;	O
double	O
divider	double
=	O
1.0	int
;	O
int	O
int_valid	int
=	O
1	int
;	O
token_id	enum(int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int)
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TOKEN_NORTH	int
:	O
lex_value	union(double,long)
.	O
double_value	double
=	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_SOUTH	int
:	O
lex_value	union(double,long)
.	O
double_value	double
=	O
-	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_LONG	int
:	O
if	O
(	O
int_valid	int
)	O
{	O
x	float
+=	O
lex_value	union(double,long)
.	O
long_value	long
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_DASH	int
)	O
{	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
}	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
TOKEN_FLOAT	int
:	O
int_valid	int
=	O
0	int
;	O
x	float
+=	O
lex_value	union(double,long)
.	O
double_value	double
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_DASH	int
)	O
{	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
static	O
int	O
ParseLongitude	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
*	O
p	*(struct(char,char,short,char,char,char,char))
)	O
{	O
double	O
x	float
=	O
0.0	int
;	O
double	O
divider	double
=	O
1.0	int
;	O
int	O
t	enum(int,int,int,int,int,int,int,int)
,	O
int_valid	int
=	O
1	int
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TOKEN_EAST	int
:	O
lex_value	union(double,long)
.	O
double_value	double
=	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_WEST	int
:	O
lex_value	union(double,long)
.	O
double_value	double
=	O
-	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_LONG	int
:	O
if	O
(	O
int_valid	int
)	O
{	O
x	float
+=	O
lex_value	union(double,long)
.	O
long_value	long
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_DASH	int
)	O
{	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
}	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
TOKEN_FLOAT	int
:	O
int_valid	int
=	O
0	int
;	O
x	float
+=	O
lex_value	union(double,long)
.	O
double_value	double
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_DASH	int
)	O
{	O
t	enum(int,int,int,int,int,int,int,int)
=	O
NextToken	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(enum(int,int,int,int,int,int,int,int))
(	O
p	*(struct(char,char,short,char,char,char,char))
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
char	O
*	O
DISStringToLatLong	(*(char),*(struct(double,double,double)))->(*(char))
(	O
char	O
*	O
s	array(short)
,	O
WorldCoordinates	struct(double,double,double)
*	O
w	*(struct(double,double,double))
)	O
{	O
struct	O
lex_record	struct(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),int,int,int,array(union(double,long)))
p	*(struct(char,char,short,char,char,char,char))
;	O
p	*(struct(char,char,short,char,char,char,char))
.	O
s	array(short)
=	O
s	array(short)
;	O
p	*(struct(char,char,short,char,char,char,char))
.	O
lookahead_valid	int
=	O
0	int
;	O
if	O
(	O
ParseLatitude	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
&	O
p	*(struct(char,char,short,char,char,char,char))
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
w	*(struct(double,double,double))
->	O
latitude	double
=	O
DEGtoRAD	O
(	O
lex_value	union(double,long)
.	O
double_value	double
)	O
;	O
if	O
(	O
ParseLongitude	(*(struct(*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,int,array(union(double,long)))))->(int)
(	O
&	O
p	*(struct(char,char,short,char,char,char,char))
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
w	*(struct(double,double,double))
->	O
longitude	double
=	O
DEGtoRAD	O
(	O
lex_value	union(double,long)
.	O
double_value	double
)	O
;	O
w	*(struct(double,double,double))
->	O
z	float
=	O
0.0	int
;	O
return	O
p	*(struct(char,char,short,char,char,char,char))
.	O
s	array(short)
;	O
}	O
