static	O
void	O
expand_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
)	O
;	O
static	O
void	O
expand_token	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),enum(int,int,int,int,int,int,int,int),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
,	O
token_type	enum(int,int,int,int,int,int,int,int)
,	O
token_data	struct
*	O
,	O
int	O
)	O
;	O
int	O
expansion_level	int
=	O
0	int
;	O
static	O
int	O
macro_call_id	int
=	O
0	int
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
void	O
expand_input	()->(void)
(	O
void	O
)	O
{	O
token_type	enum(int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int)
;	O
token_data	struct
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
;	O
int	O
line	int
;	O
obstack_init	O
(	O
&	O
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
obstack_init	O
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
while	O
(	O
(	O
t	enum(int,int,int,int,int,int,int,int)
=	O
next_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(int))->(enum(int,int,int,int,int,int,int,int))
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
&	O
line	int
)	O
)	O
!=	O
TOKEN_EOF	int
)	O
expand_token	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),enum(int,int,int,int,int,int,int,int),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int)->(void)
(	O
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
)	O
NULL	O
,	O
t	enum(int,int,int,int,int,int,int,int)
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
line	int
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
expand_token	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),enum(int,int,int,int,int,int,int,int),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
token_type	enum(int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int)
,	O
token_data	struct
*	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
int	O
line	int
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TOKEN_EOF	int
:	O
case	O
TOKEN_MACDEF	int
:	O
break	O
;	O
case	O
TOKEN_OPEN	int
:	O
case	O
TOKEN_COMMA	int
:	O
case	O
TOKEN_CLOSE	int
:	O
case	O
TOKEN_SIMPLE	int
:	O
case	O
TOKEN_STRING	int
:	O
shipout_text	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),int,int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
TOKEN_DATA_TEXT	O
(	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
,	O
strlen	(*(char))->(long)
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
)	O
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_WORD	int
:	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
lookup_symbol	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
==	O
NULL	O
||	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
==	O
TOKEN_VOID	int
||	O
(	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
==	O
TOKEN_FUNC	int
&&	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
&&	O
peek_token	()->(enum(int,int,int,int,int,int,int,int))
(	O
)	O
!=	O
TOKEN_OPEN	int
)	O
)	O
{	O
shipout_text	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),int,int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
TOKEN_DATA_TEXT	O
(	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
,	O
strlen	(*(char))->(long)
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
)	O
,	O
line	int
)	O
;	O
}	O
else	O
expand_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token type in expand_token ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
bool	bool
expand_argument	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))->(bool)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
token_data	struct
*	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
{	O
token_type	enum(int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int)
;	O
token_data	struct
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
;	O
char	O
*	O
text	*(char)
;	O
int	O
paren_level	int
;	O
const	O
char	O
*	O
file	*(char)
=	O
current_file	*(char)
;	O
int	O
line	int
=	O
current_line	int
;	O
TOKEN_DATA_TYPE	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_VOID	int
;	O
do	O
{	O
t	enum(int,int,int,int,int,int,int,int)
=	O
next_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(int))->(enum(int,int,int,int,int,int,int,int))
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_SIMPLE	int
&&	O
isspace	(int)->(int)
(	O
to_uchar	O
(	O
*	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
)	O
)	O
)	O
;	O
paren_level	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
TOKEN_COMMA	int
:	O
case	O
TOKEN_CLOSE	int
:	O
if	O
(	O
paren_level	int
==	O
0	int
)	O
{	O
obstack_1grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
'\0'	O
)	O
;	O
text	*(char)
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
==	O
TOKEN_VOID	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
text	*(char)
;	O
}	O
return	O
t	enum(int,int,int,int,int,int,int,int)
==	O
TOKEN_COMMA	int
;	O
}	O
case	O
TOKEN_OPEN	int
:	O
case	O
TOKEN_SIMPLE	int
:	O
text	*(char)
=	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
if	O
(	O
*	O
text	*(char)
==	O
'('	O
)	O
paren_level	int
++	O
;	O
else	O
if	O
(	O
*	O
text	*(char)
==	O
')'	O
)	O
paren_level	int
--	O
;	O
expand_token	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),enum(int,int,int,int,int,int,int,int),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
t	enum(int,int,int,int,int,int,int,int)
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_EOF	int
:	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	*(char)
,	O
line	int
,	O
"ERROR: end of file in argument list"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_WORD	int
:	O
case	O
TOKEN_STRING	int
:	O
expand_token	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),enum(int,int,int,int,int,int,int,int),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),int)->(void)
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
t	enum(int,int,int,int,int,int,int,int)
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_MACDEF	int
:	O
if	O
(	O
obstack_object_size	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
==	O
0	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_FUNC	int
;	O
TOKEN_DATA_FUNC	O
(	O
argp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
=	O
TOKEN_DATA_FUNC	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
}	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token type in expand_argument ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
t	enum(int,int,int,int,int,int,int,int)
=	O
next_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(int))->(enum(int,int,int,int,int,int,int,int))
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
collect_arguments	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
argptr	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
{	O
token_data	struct
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
;	O
token_data	struct
*	O
tdp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
;	O
bool	bool
more_args	bool
;	O
bool	bool
groks_macro_args	bool
=	O
SYMBOL_MACRO_ARGS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
=	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
tdp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
=	O
(	O
token_data	struct
*	O
)	O
obstack_copy	O
(	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
sizeof	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
obstack_ptr_grow	O
(	O
argptr	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
tdp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
;	O
if	O
(	O
peek_token	()->(enum(int,int,int,int,int,int,int,int))
(	O
)	O
==	O
TOKEN_OPEN	int
)	O
{	O
next_token	(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))),*(int))->(enum(int,int,int,int,int,int,int,int))
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
NULL	O
)	O
;	O
do	O
{	O
more_args	bool
=	O
expand_argument	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))->(bool)
(	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
if	O
(	O
!	O
groks_macro_args	bool
&&	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
==	O
TOKEN_FUNC	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
=	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
}	O
tdp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
=	O
(	O
token_data	struct
*	O
)	O
obstack_copy	O
(	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
&	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
,	O
sizeof	O
td	struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void))))
)	O
;	O
obstack_ptr_grow	O
(	O
argptr	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
tdp	*(struct(enum(int,int,int),union(struct(*(char)),*((*`,int,*`)->(void)))))
)	O
;	O
}	O
while	O
(	O
more_args	bool
)	O
;	O
}	O
}	O
void	O
call_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
{	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
{	O
case	O
TOKEN_FUNC	int
:	O
(	O
*	O
SYMBOL_FUNC	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
(	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
break	O
;	O
case	O
TOKEN_TEXT	int
:	O
expand_user_macro	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),int,*(*(struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad symbol type in call_macro ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
void	O
expand_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
unsigned	O
argv_base	int
;	O
bool	bool
use_argc_stack	bool
=	O
true	int
;	O
token_data	struct
*	O
*	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
int	O
argc	int
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
const	O
char	O
*	O
expanded	*(char)
;	O
bool	bool
traced	bool
;	O
int	O
my_call_id	int
;	O
const	O
char	O
*	O
loc_open_file	*(char)
=	O
current_file	*(char)
;	O
int	O
loc_open_line	int
=	O
current_line	int
;	O
const	O
char	O
*	O
loc_close_file	*(char)
;	O
int	O
loc_close_line	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
++	O
;	O
expansion_level	int
++	O
;	O
if	O
(	O
nesting_limit	int
>	O
0	int
&&	O
expansion_level	int
>	O
nesting_limit	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"recursion limit of %d exceeded, use -L<N> to change it"	*(char)
,	O
nesting_limit	int
)	O
)	O
;	O
macro_call_id	int
++	O
;	O
my_call_id	int
=	O
macro_call_id	int
;	O
traced	bool
=	O
(	O
debug_level	int
&	O
DEBUG_TRACE_ALL	int
)	O
||	O
SYMBOL_TRACED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
argv_base	int
=	O
obstack_object_size	O
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
if	O
(	O
obstack_object_size	O
(	O
&	O
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
>	O
0	int
)	O
{	O
obstack_init	O
(	O
&	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
use_argc_stack	bool
=	O
false	int
;	O
}	O
if	O
(	O
traced	bool
&&	O
(	O
debug_level	int
&	O
DEBUG_TRACE_CALL	int
)	O
)	O
trace_prepre	(*(char),int)->(void)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
my_call_id	int
)	O
;	O
collect_arguments	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
use_argc_stack	bool
?	O
&	O
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
:	O
&	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
argc	int
=	O
(	O
(	O
obstack_object_size	O
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
-	O
argv_base	int
)	O
/	O
sizeof	O
(	O
token_data	struct
*	O
)	O
)	O
;	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
(	O
token_data	struct
*	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
obstack_base	O
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
+	O
argv_base	int
)	O
;	O
loc_close_file	*(char)
=	O
current_file	*(char)
;	O
loc_close_line	int
=	O
current_line	int
;	O
current_file	*(char)
=	O
loc_open_file	*(char)
;	O
current_line	int
=	O
loc_open_line	int
;	O
if	O
(	O
traced	bool
)	O
trace_pre	(*(char),int,int,*(*(struct)))->(void)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
my_call_id	int
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
push_string_init	()->(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
(	O
)	O
;	O
call_macro	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))),int,*(*(struct(enum(int,int,int),union(struct`,*`)))),*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
argc	int
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
,	O
expansion	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
expanded	*(char)
=	O
push_string_finish	()->(*(char))
(	O
)	O
;	O
if	O
(	O
traced	bool
)	O
trace_post	(*(char),int,int,*(char))->(void)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
my_call_id	int
,	O
argc	int
,	O
expanded	*(char)
)	O
;	O
current_file	*(char)
=	O
loc_close_file	*(char)
;	O
current_line	int
=	O
loc_close_line	int
;	O
--	O
expansion_level	int
;	O
--	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
if	O
(	O
SYMBOL_DELETED	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
free_symbol	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(void)
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
if	O
(	O
use_argc_stack	bool
)	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
argc_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
argv	*(*(struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
[	O
0	int
]	O
)	O
;	O
else	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
arguments	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
NULL	O
)	O
;	O
obstack_blank	O
(	O
&	O
argv_stack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
-	O
argc	int
*	O
sizeof	O
(	O
token_data	struct
*	O
)	O
)	O
;	O
}	O
