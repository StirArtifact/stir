struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
{	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
prev	*(char)
;	O
POSITION	long
pos	long
;	O
POSITION	long
gap	long
;	O
LINENUM	long
line	*(char)
;	O
}	O
;	O
static	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
anchor	*(struct)
;	O
static	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
static	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
[	O
NPOOL	int
]	O
;	O
static	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
extern	O
int	O
linenums	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
int	O
screen_trashed	int
;	O
public	O
void	O
clr_linenum	()->(void)
(	O
)	O
{	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
;	O
p	*(char)
<	O
&	O
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
[	O
NPOOL	int
-	O
2	int
]	O
;	O
p	*(char)
++	O
)	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
p	*(char)
+	O
1	int
;	O
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
[	O
NPOOL	int
-	O
2	int
]	O
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
NULL	O
;	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
;	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
&	O
pool	array(struct(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)),long,long,long))
[	O
NPOOL	int
-	O
1	int
]	O
;	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
anchor	*(struct)
.	O
prev	*(char)
=	O
&	O
anchor	*(struct)
;	O
anchor	*(struct)
.	O
gap	long
=	O
0	int
;	O
anchor	*(struct)
.	O
pos	long
=	O
(	O
POSITION	long
)	O
0	int
;	O
anchor	*(struct)
.	O
line	*(char)
=	O
1	int
;	O
}	O
static	O
void	O
calcgap	(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)))->(void)
(	O
p	*(char)
)	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
p	*(char)
;	O
{	O
if	O
(	O
p	*(char)
==	O
&	O
anchor	*(struct)
||	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
==	O
&	O
anchor	*(struct)
)	O
return	O
;	O
p	*(char)
->	O
gap	long
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
pos	long
-	O
p	*(char)
->	O
prev	*(char)
->	O
pos	long
;	O
}	O
public	O
void	O
add_lnum	(long,long)->(void)
(	O
linenum	long
,	O
pos	long
)	O
LINENUM	long
linenum	long
;	O
POSITION	long
pos	long
;	O
{	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
p	*(char)
;	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
nextp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
prevp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
POSITION	long
mingap	long
;	O
for	O
(	O
p	*(char)
=	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
p	*(char)
!=	O
&	O
anchor	*(struct)
&&	O
p	*(char)
->	O
pos	long
<	O
pos	long
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
if	O
(	O
p	*(char)
->	O
line	*(char)
==	O
linenum	long
)	O
return	O
;	O
nextp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
p	*(char)
;	O
prevp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
p	*(char)
->	O
prev	*(char)
;	O
if	O
(	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
!=	O
NULL	O
)	O
{	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
freelist	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
}	O
else	O
{	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
NULL	O
;	O
}	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
nextp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
prev	*(char)
=	O
prevp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
pos	long
=	O
pos	long
;	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
line	*(char)
=	O
linenum	long
;	O
nextp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
prev	*(char)
=	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
prevp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
calcgap	(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)))->(void)
(	O
new	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
;	O
calcgap	(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)))->(void)
(	O
nextp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
;	O
calcgap	(*(struct(*(struct(*`,*`,long,long,long)),*(struct(*`,*`,long,long,long)),long,long,long)))->(void)
(	O
prevp	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
;	O
if	O
(	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
==	O
NULL	O
)	O
{	O
mingap	long
=	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
gap	long
;	O
for	O
(	O
p	*(char)
=	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
!=	O
&	O
anchor	*(struct)
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
{	O
if	O
(	O
p	*(char)
->	O
gap	long
<=	O
mingap	long
)	O
{	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
p	*(char)
;	O
mingap	long
=	O
p	*(char)
->	O
gap	long
;	O
}	O
}	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
prev	*(char)
=	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
prev	*(char)
;	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
prev	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
=	O
spare	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
}	O
}	O
static	O
void	O
longloopmessage	()->(void)
(	O
)	O
{	O
ierror	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Calculating line numbers"	*(char)
,	O
NULL_PARG	O
)	O
;	O
}	O
static	O
int	O
loopcount	int
;	O
static	O
time_type	O
startime	long
;	O
static	O
void	O
longish	()->(void)
(	O
)	O
{	O
if	O
(	O
loopcount	int
>=	O
0	int
&&	O
++	O
loopcount	int
>	O
100	int
)	O
{	O
loopcount	int
=	O
0	int
;	O
if	O
(	O
get_time	()->(long)
(	O
)	O
>=	O
startime	long
+	O
LONGTIME	O
)	O
{	O
longloopmessage	()->(void)
(	O
)	O
;	O
loopcount	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
static	O
void	O
abort_long	()->(void)
(	O
)	O
{	O
if	O
(	O
linenums	int
==	O
OPT_ONPLUS	int
)	O
screen_trashed	int
=	O
1	int
;	O
linenums	int
=	O
0	int
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Line numbers turned off"	*(char)
,	O
NULL_PARG	O
)	O
;	O
}	O
public	O
LINENUM	long
find_linenum	(long)->(long)
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
p	*(char)
;	O
LINENUM	long
linenum	long
;	O
POSITION	long
cpos	long
;	O
if	O
(	O
!	O
linenums	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
pos	long
<=	O
ch_zero	O
(	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
for	O
(	O
p	*(char)
=	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
p	*(char)
!=	O
&	O
anchor	*(struct)
&&	O
p	*(char)
->	O
pos	long
<	O
pos	long
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
continue	O
;	O
if	O
(	O
p	*(char)
->	O
pos	long
==	O
pos	long
)	O
return	O
(	O
p	*(char)
->	O
line	*(char)
)	O
;	O
startime	long
=	O
get_time	()->(long)
(	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
&	O
anchor	*(struct)
||	O
pos	long
-	O
p	*(char)
->	O
prev	*(char)
->	O
pos	long
<	O
p	*(char)
->	O
pos	long
-	O
pos	long
)	O
{	O
p	*(char)
=	O
p	*(char)
->	O
prev	*(char)
;	O
if	O
(	O
ch_seek	(long)->(int)
(	O
p	*(char)
->	O
pos	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
loopcount	int
=	O
0	int
;	O
for	O
(	O
linenum	long
=	O
p	*(char)
->	O
line	*(char)
,	O
cpos	long
=	O
p	*(char)
->	O
pos	long
;	O
cpos	long
<	O
pos	long
;	O
linenum	long
++	O
)	O
{	O
cpos	long
=	O
forw_raw_line	(long,*(*(char)),*(int))->(long)
(	O
cpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
abort_long	()->(void)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
cpos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
0	int
)	O
;	O
longish	()->(void)
(	O
)	O
;	O
}	O
add_lnum	(long,long)->(void)
(	O
linenum	long
,	O
cpos	long
)	O
;	O
if	O
(	O
cpos	long
>	O
pos	long
)	O
linenum	long
--	O
;	O
}	O
else	O
{	O
if	O
(	O
ch_seek	(long)->(int)
(	O
p	*(char)
->	O
pos	long
)	O
)	O
return	O
(	O
0	int
)	O
;	O
loopcount	int
=	O
0	int
;	O
for	O
(	O
linenum	long
=	O
p	*(char)
->	O
line	*(char)
,	O
cpos	long
=	O
p	*(char)
->	O
pos	long
;	O
cpos	long
>	O
pos	long
;	O
linenum	long
--	O
)	O
{	O
cpos	long
=	O
back_raw_line	(long,*(*(char)),*(int))->(long)
(	O
cpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
abort_long	()->(void)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
cpos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
0	int
)	O
;	O
longish	()->(void)
(	O
)	O
;	O
}	O
add_lnum	(long,long)->(void)
(	O
linenum	long
,	O
cpos	long
)	O
;	O
}	O
return	O
(	O
linenum	long
)	O
;	O
}	O
public	O
POSITION	long
find_pos	(long)->(long)
(	O
linenum	long
)	O
LINENUM	long
linenum	long
;	O
{	O
struct	O
linenum_info	struct(*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long)),long,long,long)
*	O
p	*(char)
;	O
POSITION	long
cpos	long
;	O
LINENUM	long
clinenum	long
;	O
if	O
(	O
linenum	long
<=	O
1	int
)	O
return	O
(	O
ch_zero	O
(	O
)	O
)	O
;	O
for	O
(	O
p	*(char)
=	O
anchor	*(struct)
.	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
;	O
p	*(char)
!=	O
&	O
anchor	*(struct)
&&	O
p	*(char)
->	O
line	*(char)
<	O
linenum	long
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),long,long,long)),*(struct(*(struct`),*(struct`),long,long,long)),long,long,long))
)	O
continue	O
;	O
if	O
(	O
p	*(char)
->	O
line	*(char)
==	O
linenum	long
)	O
return	O
(	O
p	*(char)
->	O
pos	long
)	O
;	O
if	O
(	O
p	*(char)
==	O
&	O
anchor	*(struct)
||	O
linenum	long
-	O
p	*(char)
->	O
prev	*(char)
->	O
line	*(char)
<	O
p	*(char)
->	O
line	*(char)
-	O
linenum	long
)	O
{	O
p	*(char)
=	O
p	*(char)
->	O
prev	*(char)
;	O
if	O
(	O
ch_seek	(long)->(int)
(	O
p	*(char)
->	O
pos	long
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
for	O
(	O
clinenum	long
=	O
p	*(char)
->	O
line	*(char)
,	O
cpos	long
=	O
p	*(char)
->	O
pos	long
;	O
clinenum	long
<	O
linenum	long
;	O
clinenum	long
++	O
)	O
{	O
cpos	long
=	O
forw_raw_line	(long,*(*(char)),*(int))->(long)
(	O
cpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
if	O
(	O
cpos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ch_seek	(long)->(int)
(	O
p	*(char)
->	O
pos	long
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
for	O
(	O
clinenum	long
=	O
p	*(char)
->	O
line	*(char)
,	O
cpos	long
=	O
p	*(char)
->	O
pos	long
;	O
clinenum	long
>	O
linenum	long
;	O
clinenum	long
--	O
)	O
{	O
cpos	long
=	O
back_raw_line	(long,*(*(char)),*(int))->(long)
(	O
cpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
if	O
(	O
cpos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
NULL_POSITION	O
)	O
;	O
}	O
}	O
add_lnum	(long,long)->(void)
(	O
clinenum	long
,	O
cpos	long
)	O
;	O
return	O
(	O
cpos	long
)	O
;	O
}	O
public	O
LINENUM	long
currline	(int)->(long)
(	O
where	int
)	O
int	O
where	int
;	O
{	O
POSITION	long
pos	long
;	O
POSITION	long
len	int
;	O
LINENUM	long
linenum	long
;	O
pos	long
=	O
position	(int)->(long)
(	O
where	int
)	O
;	O
len	int
=	O
ch_length	()->(long)
(	O
)	O
;	O
while	O
(	O
pos	long
==	O
NULL_POSITION	O
&&	O
where	int
>=	O
0	int
&&	O
where	int
<	O
sc_height	int
)	O
pos	long
=	O
position	(int)->(long)
(	O
++	O
where	int
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
pos	long
=	O
len	int
;	O
linenum	long
=	O
find_linenum	(long)->(long)
(	O
pos	long
)	O
;	O
if	O
(	O
pos	long
==	O
len	int
)	O
linenum	long
--	O
;	O
return	O
(	O
linenum	long
)	O
;	O
}	O
