int	O
echo_qsize	int
;	O
int	O
echo_pstart	int
;	O
int	O
output_psize	int
;	O
inline	O
void	O
poutput	(int)->(void)
(	O
int	O
c	short
)	O
{	O
if	O
(	O
termflags	long
&	O
FLUSH_OUTPUT	int
)	O
return	O
;	O
if	O
(	O
(	O
c	short
>=	O
' '	O
)	O
&&	O
(	O
c	short
<	O
'\177'	O
)	O
)	O
output_psize	int
++	O
;	O
else	O
if	O
(	O
c	short
==	O
'\r'	O
)	O
output_psize	int
=	O
0	int
;	O
else	O
if	O
(	O
c	short
==	O
'\t'	O
)	O
{	O
output_psize	int
++	O
;	O
while	O
(	O
output_psize	int
%	O
8	int
)	O
output_psize	int
++	O
;	O
}	O
else	O
if	O
(	O
c	short
==	O
'\b'	O
)	O
output_psize	int
--	O
;	O
enqueue	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
&	O
outputq	*(struct)
,	O
c	short
)	O
;	O
}	O
void	O
output_character	(int)->(void)
(	O
int	O
c	short
)	O
{	O
int	O
oflag	int
=	O
termstate	struct
.	O
c_oflag	O
;	O
if	O
(	O
oflag	int
&	O
OPOST	O
)	O
{	O
if	O
(	O
(	O
oflag	int
&	O
ONLCR	O
)	O
&&	O
c	short
==	O
'\n'	O
)	O
{	O
poutput	(int)->(void)
(	O
'\r'	O
)	O
;	O
poutput	(int)->(void)
(	O
'\n'	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
oflag	int
&	O
OXTABS	O
)	O
&&	O
c	short
==	O
'\t'	O
)	O
{	O
poutput	(int)->(void)
(	O
' '	O
)	O
;	O
while	O
(	O
output_psize	int
%	O
8	int
)	O
poutput	(int)->(void)
(	O
' '	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
oflag	int
&	O
ONOEOT	O
)	O
&&	O
c	short
==	O
CHAR_EOT	char
)	O
;	O
else	O
if	O
(	O
(	O
oflag	int
&	O
OLCASE	O
)	O
&&	O
isalpha	O
(	O
c	short
)	O
)	O
{	O
if	O
(	O
isupper	O
(	O
c	short
)	O
)	O
poutput	(int)->(void)
(	O
'\\'	O
)	O
;	O
else	O
c	short
=	O
toupper	O
(	O
c	short
)	O
;	O
poutput	(int)->(void)
(	O
c	short
)	O
;	O
}	O
else	O
poutput	(int)->(void)
(	O
c	short
)	O
;	O
}	O
else	O
poutput	(int)->(void)
(	O
c	short
)	O
;	O
}	O
void	O
write_character	(int)->(void)
(	O
int	O
c	short
)	O
{	O
output_character	(int)->(void)
(	O
c	short
)	O
;	O
echo_qsize	int
=	O
0	int
;	O
echo_pstart	int
=	O
output_psize	int
;	O
}	O
int	O
output_width	(int,int)->(int)
(	O
int	O
c	short
,	O
int	O
loc	int
)	O
{	O
int	O
oflag	int
=	O
termstate	struct
.	O
c_oflag	O
;	O
if	O
(	O
oflag	int
&	O
OPOST	O
)	O
{	O
if	O
(	O
(	O
oflag	int
&	O
OLCASE	O
)	O
&&	O
isalpha	O
(	O
c	short
)	O
&&	O
isupper	O
(	O
c	short
)	O
)	O
return	O
2	int
;	O
}	O
if	O
(	O
c	short
==	O
'\t'	O
)	O
{	O
int	O
n	int
=	O
loc	int
+	O
1	int
;	O
while	O
(	O
n	int
%	O
8	int
)	O
n	int
++	O
;	O
return	O
n	int
-	O
loc	int
;	O
}	O
if	O
(	O
(	O
c	short
>=	O
' '	O
)	O
&&	O
(	O
c	short
<	O
'\177'	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
rawq	*(struct)
;	O
char	O
const	O
char_parity	array(char)
[	O
]	O
=	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
}	O
;	O
static	O
inline	O
int	O
echo_p	(char,int)->(int)
(	O
char	O
c	short
,	O
int	O
quoted	int
)	O
{	O
if	O
(	O
external_processing	int
)	O
return	O
0	int
;	O
return	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ECHO	O
)	O
||	O
(	O
c	short
==	O
'\n'	O
&&	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ECHONL	O
)	O
&&	O
!	O
quoted	int
)	O
)	O
;	O
}	O
static	O
inline	O
int	O
echo_double	(char,int)->(int)
(	O
char	O
c	short
,	O
int	O
quoted	int
)	O
{	O
return	O
(	O
iscntrl	O
(	O
c	short
)	O
&&	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ECHOCTL	O
)	O
&&	O
!	O
(	O
(	O
c	short
==	O
'\n'	O
||	O
c	short
==	O
'\t'	O
)	O
&&	O
!	O
quoted	int
)	O
)	O
;	O
}	O
static	O
inline	O
void	O
write_erase_sequence	()->(void)
(	O
)	O
{	O
poutput	(int)->(void)
(	O
'\b'	O
)	O
;	O
poutput	(int)->(void)
(	O
' '	O
)	O
;	O
poutput	(int)->(void)
(	O
'\b'	O
)	O
;	O
}	O
static	O
void	O
echo_char	(char,int,int)->(void)
(	O
char	O
c	short
,	O
int	O
hderase	int
,	O
int	O
quoted	int
)	O
{	O
echo_qsize	int
++	O
;	O
if	O
(	O
echo_p	(char,int)->(int)
(	O
c	short
,	O
quoted	int
)	O
)	O
{	O
if	O
(	O
!	O
hderase	int
&&	O
(	O
termflags	long
&	O
INSIDE_HDERASE	int
)	O
)	O
{	O
write_character	(int)->(void)
(	O
'/'	O
)	O
;	O
termflags	long
&=	O
~	O
INSIDE_HDERASE	int
;	O
}	O
if	O
(	O
hderase	int
&&	O
!	O
(	O
termflags	long
&	O
INSIDE_HDERASE	int
)	O
)	O
{	O
output_character	(int)->(void)
(	O
'\\'	O
)	O
;	O
termflags	long
|=	O
INSIDE_HDERASE	int
;	O
}	O
if	O
(	O
echo_double	(char,int)->(int)
(	O
c	short
,	O
quoted	int
)	O
)	O
{	O
output_character	(int)->(void)
(	O
'^'	O
)	O
;	O
output_character	(int)->(void)
(	O
c	short
^	O
CTRL_BIT	int
)	O
;	O
}	O
else	O
output_character	(int)->(void)
(	O
c	short
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
reprint_line	()->(void)
(	O
)	O
{	O
short	O
*	O
cp	*(short)
;	O
if	O
(	O
termstate	struct
.	O
c_cc	O
[	O
VREPRINT	O
]	O
!=	O
_POSIX_VDISABLE	O
)	O
echo_char	(char,int,int)->(void)
(	O
termstate	struct
.	O
c_cc	O
[	O
VREPRINT	O
]	O
,	O
0	int
,	O
0	int
)	O
;	O
else	O
echo_char	(char,int,int)->(void)
(	O
CHAR_DC2	char
,	O
0	int
,	O
0	int
)	O
;	O
echo_char	(char,int,int)->(void)
(	O
'\n'	O
,	O
0	int
,	O
0	int
)	O
;	O
echo_qsize	int
=	O
0	int
;	O
echo_pstart	int
=	O
output_psize	int
;	O
for	O
(	O
cp	*(short)
=	O
rawq	*(struct)
->	O
cs	*(short)
;	O
cp	*(short)
!=	O
rawq	*(struct)
->	O
ce	*(short)
;	O
cp	*(short)
++	O
)	O
echo_char	(char,int,int)->(void)
(	O
unquote_char	(short)->(char)
(	O
*	O
cp	*(short)
)	O
,	O
0	int
,	O
char_quoted_p	(short)->(int)
(	O
*	O
cp	*(short)
)	O
)	O
;	O
}	O
static	O
void	O
erase_1	(char)->(void)
(	O
char	O
erase_char	char
)	O
{	O
int	O
quoted	int
;	O
char	O
c	short
;	O
quoted_char	short
cq	short
;	O
if	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
==	O
0	int
)	O
return	O
;	O
cq	short
=	O
queue_erase	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(short)
(	O
rawq	*(struct)
)	O
;	O
c	short
=	O
unquote_char	(short)->(char)
(	O
cq	short
)	O
;	O
quoted	int
=	O
char_quoted_p	(short)->(int)
(	O
cq	short
)	O
;	O
if	O
(	O
!	O
echo_p	(char,int)->(int)
(	O
c	short
,	O
quoted	int
)	O
)	O
return	O
;	O
if	O
(	O
echo_qsize	int
--	O
)	O
{	O
if	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ECHOPRT	O
)	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
1	int
,	O
quoted	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ECHOE	O
)	O
&&	O
erase_char	char
)	O
echo_char	(char,int,int)->(void)
(	O
erase_char	char
,	O
0	int
,	O
0	int
)	O
;	O
else	O
{	O
int	O
nerase	int
;	O
if	O
(	O
echo_double	(char,int)->(int)
(	O
c	short
,	O
quoted	int
)	O
)	O
nerase	int
=	O
2	int
;	O
else	O
if	O
(	O
c	short
==	O
'\t'	O
)	O
{	O
quoted_char	short
*	O
cp	*(short)
;	O
int	O
loc	int
=	O
echo_pstart	int
;	O
for	O
(	O
cp	*(short)
=	O
rawq	*(struct)
->	O
ce	*(short)
-	O
echo_qsize	int
;	O
cp	*(short)
!=	O
rawq	*(struct)
->	O
ce	*(short)
;	O
cp	*(short)
++	O
)	O
loc	int
+=	O
(	O
echo_double	(char,int)->(int)
(	O
unquote_char	(short)->(char)
(	O
*	O
cp	*(short)
)	O
,	O
char_quoted_p	(short)->(int)
(	O
*	O
cp	*(short)
)	O
)	O
?	O
2	int
:	O
output_width	(int,int)->(int)
(	O
*	O
cp	*(short)
,	O
loc	int
)	O
)	O
;	O
nerase	int
=	O
output_psize	int
-	O
loc	int
;	O
}	O
else	O
nerase	int
=	O
output_width	(int,int)->(int)
(	O
c	short
,	O
output_psize	int
)	O
;	O
while	O
(	O
nerase	int
--	O
)	O
write_erase_sequence	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
echo_qsize	int
==	O
0	int
)	O
assert	O
(	O
echo_pstart	int
==	O
output_psize	int
)	O
;	O
}	O
else	O
reprint_line	()->(void)
(	O
)	O
;	O
}	O
int	O
input_character	(int)->(int)
(	O
int	O
c	short
)	O
{	O
int	O
lflag	int
=	O
termstate	struct
.	O
c_lflag	O
;	O
int	O
iflag	int
=	O
termstate	struct
.	O
c_iflag	O
;	O
int	O
cflag	int
=	O
termstate	struct
.	O
c_cflag	O
;	O
cc_t	O
*	O
cc	O
=	O
termstate	struct
.	O
c_cc	O
;	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
*	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
=	O
(	O
lflag	int
&	O
ICANON	O
)	O
?	O
&	O
rawq	*(struct)
:	O
&	O
inputq	*(struct)
;	O
int	O
flush	int
=	O
0	int
;	O
if	O
(	O
(	O
iflag	int
&	O
INPCK	O
)	O
&&	O
(	O
(	O
cflag	int
&	O
PARODD	O
)	O
?	O
checkoddpar	O
(	O
c	short
)	O
:	O
checkevenpar	O
(	O
c	short
)	O
)	O
)	O
{	O
if	O
(	O
iflag	int
&	O
IGNPAR	O
)	O
goto	O
alldone	O
;	O
else	O
if	O
(	O
iflag	int
&	O
PARMRK	O
)	O
{	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
CHAR_USER_QUOTE	char
)	O
;	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
'\0'	O
)	O
;	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
c	short
)	O
;	O
goto	O
alldone	O
;	O
}	O
else	O
c	short
=	O
0	int
;	O
}	O
if	O
(	O
(	O
iflag	int
&	O
IXOFF	O
)	O
&&	O
!	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
*	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
)	O
&&	O
(	O
cc	O
[	O
VSTOP	O
]	O
!=	O
_POSIX_VDISABLE	O
)	O
)	O
{	O
poutput	(int)->(void)
(	O
cc	O
[	O
VSTOP	O
]	O
)	O
;	O
termflags	long
|=	O
SENT_VSTOP	int
;	O
}	O
if	O
(	O
!	O
(	O
iflag	int
&	O
ISTRIP	O
)	O
&&	O
(	O
iflag	int
&	O
PARMRK	O
)	O
&&	O
(	O
c	short
==	O
CHAR_USER_QUOTE	char
)	O
)	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
CHAR_USER_QUOTE	char
)	O
;	O
if	O
(	O
iflag	int
&	O
ISTRIP	O
)	O
c	short
&=	O
0x7f	int
;	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
termflags	long
&	O
LAST_LNEXT	int
)	O
)	O
{	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
c	short
)	O
;	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
0	int
,	O
1	int
)	O
;	O
termflags	long
&=	O
~	O
LAST_LNEXT	int
;	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
iflag	int
&	O
ILCASE	O
)	O
&&	O
isalpha	O
(	O
c	short
)	O
)	O
{	O
if	O
(	O
termflags	long
&	O
LAST_SLASH	int
)	O
erase_1	(char)->(void)
(	O
0	int
)	O
;	O
else	O
c	short
=	O
isupper	O
(	O
c	short
)	O
?	O
tolower	O
(	O
c	short
)	O
:	O
c	short
;	O
}	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
lflag	int
&	O
IEXTEN	O
)	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VLNEXT	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
lflag	int
&	O
ECHO	O
)	O
{	O
poutput	(int)->(void)
(	O
'^'	O
)	O
;	O
poutput	(int)->(void)
(	O
'\b'	O
)	O
;	O
}	O
termflags	long
|=	O
LAST_LNEXT	int
;	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VDISCARD	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
termflags	long
&	O
FLUSH_OUTPUT	int
)	O
termflags	long
&=	O
~	O
FLUSH_OUTPUT	int
;	O
else	O
{	O
drop_output	()->(int)
(	O
)	O
;	O
poutput	(int)->(void)
(	O
cc	O
[	O
VDISCARD	O
]	O
)	O
;	O
termflags	long
|=	O
FLUSH_OUTPUT	int
;	O
}	O
goto	O
alldone	O
;	O
}	O
}	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
lflag	int
&	O
ISIG	O
)	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VINTR	O
]	O
,	O
c	short
)	O
||	O
CCEQ	()->(int)
(	O
cc	O
[	O
VQUIT	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
!	O
(	O
lflag	int
&	O
NOFLSH	O
)	O
)	O
{	O
drop_output	()->(int)
(	O
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
rawq	*(struct)
)	O
;	O
flush	int
=	O
1	int
;	O
}	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
0	int
,	O
0	int
)	O
;	O
echo_qsize	int
=	O
0	int
;	O
echo_pstart	int
=	O
output_psize	int
;	O
send_signal	(int)->(void)
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VINTR	O
]	O
,	O
c	short
)	O
?	O
SIGINT	O
:	O
SIGQUIT	O
)	O
;	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSUSP	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
!	O
(	O
lflag	int
&	O
NOFLSH	O
)	O
)	O
{	O
flush	int
=	O
1	int
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
rawq	*(struct)
)	O
;	O
}	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
0	int
,	O
0	int
)	O
;	O
echo_qsize	int
=	O
0	int
;	O
echo_pstart	int
=	O
output_psize	int
;	O
send_signal	(int)->(void)
(	O
SIGTSTP	O
)	O
;	O
goto	O
alldone	O
;	O
}	O
}	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
iflag	int
&	O
IXON	O
)	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSTOP	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSTART	O
]	O
,	O
c	short
)	O
&&	O
(	O
termflags	long
&	O
USER_OUTPUT_SUSP	int
)	O
)	O
goto	O
alldone	O
;	O
termflags	long
|=	O
USER_OUTPUT_SUSP	int
;	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
suspend_physical_output	*(()->(int))
)	O
(	O
)	O
;	O
return	O
flush	int
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSTART	O
]	O
,	O
c	short
)	O
)	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
!	O
external_processing	int
)	O
{	O
if	O
(	O
c	short
==	O
'\r'	O
)	O
{	O
if	O
(	O
iflag	int
&	O
ICRNL	O
)	O
c	short
=	O
'\n'	O
;	O
else	O
if	O
(	O
iflag	int
&	O
IGNCR	O
)	O
goto	O
alldone	O
;	O
}	O
else	O
if	O
(	O
(	O
c	short
==	O
'\n'	O
)	O
&&	O
(	O
iflag	int
&	O
INLCR	O
)	O
)	O
c	short
=	O
'\r'	O
;	O
}	O
if	O
(	O
!	O
external_processing	int
&&	O
(	O
lflag	int
&	O
ICANON	O
)	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VERASE	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
)	O
erase_1	(char)->(void)
(	O
c	short
)	O
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
LAST_SLASH	int
)	O
||	O
!	O
(	O
lflag	int
&	O
IEXTEN	O
)	O
)	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VKILL	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
!	O
(	O
termflags	long
&	O
LAST_SLASH	int
)	O
||	O
!	O
(	O
lflag	int
&	O
IEXTEN	O
)	O
)	O
{	O
if	O
(	O
(	O
lflag	int
&	O
ECHOKE	O
)	O
&&	O
!	O
(	O
lflag	int
&	O
ECHOPRT	O
)	O
&&	O
(	O
echo_qsize	int
==	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
)	O
)	O
{	O
while	O
(	O
output_psize	int
>	O
echo_pstart	int
)	O
write_erase_sequence	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
lflag	int
&	O
ECHOK	O
)	O
||	O
(	O
lflag	int
&	O
ECHOKE	O
)	O
)	O
echo_char	(char,int,int)->(void)
(	O
'\n'	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
rawq	*(struct)
)	O
;	O
echo_qsize	int
=	O
0	int
;	O
echo_pstart	int
=	O
output_psize	int
;	O
termflags	long
&=	O
~	O
(	O
LAST_SLASH	int
|	O
LAST_LNEXT	int
|	O
INSIDE_HDERASE	int
)	O
;	O
goto	O
alldone	O
;	O
}	O
else	O
erase_1	(char)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VWERASE	O
]	O
,	O
c	short
)	O
)	O
{	O
if	O
(	O
!	O
(	O
lflag	int
&	O
(	O
ECHOPRT	O
|	O
ECHOE	O
)	O
)	O
)	O
echo_char	(char,int,int)->(void)
(	O
cc	O
[	O
VWERASE	O
]	O
,	O
0	int
,	O
1	int
)	O
;	O
while	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
&&	O
isblank	O
(	O
unquote_char	(short)->(char)
(	O
rawq	*(struct)
->	O
ce	*(short)
[	O
-	O
1	int
]	O
)	O
)	O
)	O
erase_1	(char)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
lflag	int
&	O
ALTWERASE	O
)	O
while	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
&&	O
!	O
isblank	O
(	O
unquote_char	(short)->(char)
(	O
rawq	*(struct)
->	O
ce	*(short)
[	O
-	O
1	int
]	O
)	O
)	O
)	O
erase_1	(char)->(void)
(	O
0	int
)	O
;	O
else	O
while	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
&&	O
!	O
isblank	O
(	O
unquote_char	(short)->(char)
(	O
rawq	*(struct)
->	O
ce	*(short)
[	O
-	O
1	int
]	O
)	O
)	O
&&	O
(	O
isalnum	O
(	O
unquote_char	(short)->(char)
(	O
rawq	*(struct)
->	O
ce	*(short)
[	O
-	O
1	int
]	O
)	O
)	O
||	O
(	O
unquote_char	(short)->(char)
(	O
rawq	*(struct)
->	O
ce	*(short)
[	O
-	O
1	int
]	O
)	O
!=	O
'_'	O
)	O
)	O
)	O
erase_1	(char)->(void)
(	O
0	int
)	O
;	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VREPRINT	O
]	O
,	O
c	short
)	O
&&	O
(	O
lflag	int
&	O
IEXTEN	O
)	O
)	O
{	O
reprint_line	()->(void)
(	O
)	O
;	O
goto	O
alldone	O
;	O
}	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSTATUS	O
]	O
,	O
c	short
)	O
&&	O
(	O
lflag	int
&	O
ISIG	O
)	O
&&	O
(	O
lflag	int
&	O
IEXTEN	O
)	O
)	O
{	O
send_signal	(int)->(void)
(	O
SIGINFO	O
)	O
;	O
goto	O
alldone	O
;	O
}	O
}	O
if	O
(	O
!	O
qavail	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
*	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
)	O
)	O
{	O
if	O
(	O
iflag	int
&	O
IMAXBEL	O
)	O
poutput	(int)->(void)
(	O
'\a'	O
)	O
;	O
else	O
{	O
drop_output	()->(int)
(	O
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
rawq	*(struct)
)	O
;	O
echo_pstart	int
=	O
0	int
;	O
echo_qsize	int
=	O
0	int
;	O
flush	int
=	O
1	int
;	O
}	O
goto	O
alldone	O
;	O
}	O
echo_char	(char,int,int)->(void)
(	O
c	short
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
&&	O
(	O
lflag	int
&	O
ECHO	O
)	O
)	O
{	O
int	O
n	int
;	O
n	int
=	O
echo_double	(char,int)->(int)
(	O
c	short
,	O
0	int
)	O
?	O
2	int
:	O
output_width	(int,int)->(int)
(	O
c	short
,	O
output_psize	int
)	O
;	O
while	O
(	O
n	int
--	O
)	O
poutput	(int)->(void)
(	O
'\b'	O
)	O
;	O
}	O
enqueue	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
c	short
)	O
;	O
if	O
(	O
lflag	int
&	O
ICANON	O
)	O
{	O
if	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VEOL	O
]	O
,	O
c	short
)	O
||	O
CCEQ	()->(int)
(	O
cc	O
[	O
VEOL2	O
]	O
,	O
c	short
)	O
||	O
CCEQ	()->(int)
(	O
cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
||	O
c	short
==	O
'\n'	O
)	O
while	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
)	O
enqueue	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
&	O
inputq	*(struct)
,	O
dequeue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(char)
(	O
rawq	*(struct)
)	O
)	O
;	O
}	O
alldone	O
:	O
if	O
(	O
(	O
iflag	int
&	O
IXANY	O
)	O
||	O
(	O
CCEQ	()->(int)
(	O
cc	O
[	O
VSTART	O
]	O
,	O
c	short
)	O
)	O
)	O
termflags	long
&=	O
~	O
USER_OUTPUT_SUSP	int
;	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
start_output	*(()->(int))
)	O
(	O
)	O
;	O
return	O
flush	int
;	O
}	O
void	O
input_break	()->(void)
(	O
)	O
{	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
*	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
=	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
?	O
&	O
rawq	*(struct)
:	O
&	O
inputq	*(struct)
;	O
if	O
(	O
termstate	struct
.	O
c_iflag	O
&	O
IGNBRK	O
)	O
return	O
;	O
if	O
(	O
termstate	struct
.	O
c_iflag	O
&	O
BRKINT	O
)	O
{	O
drop_output	()->(int)
(	O
)	O
;	O
send_signal	(int)->(void)
(	O
SIGINT	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
termstate	struct
.	O
c_iflag	O
&	O
PARMRK	O
)	O
{	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
CHAR_USER_QUOTE	char
)	O
;	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
'\0'	O
)	O
;	O
}	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
'\0'	O
)	O
;	O
}	O
void	O
input_framing_error	(int)->(void)
(	O
int	O
c	short
)	O
{	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
*	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
=	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
?	O
&	O
rawq	*(struct)
:	O
&	O
inputq	*(struct)
;	O
if	O
(	O
termstate	struct
.	O
c_iflag	O
&	O
IGNPAR	O
)	O
return	O
;	O
if	O
(	O
termstate	struct
.	O
c_iflag	O
&	O
PARMRK	O
)	O
{	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
CHAR_USER_QUOTE	char
)	O
;	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
'\0'	O
)	O
;	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
c	short
)	O
;	O
}	O
else	O
enqueue_quote	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
qp	*(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
,	O
'\0'	O
)	O
;	O
}	O
void	O
copy_rawq	()->(void)
(	O
)	O
{	O
while	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
rawq	*(struct)
)	O
)	O
enqueue	(*(*(struct(int,int,int,*(short),*(short),int,*(union`),array(short)))),char)->(void)
(	O
&	O
inputq	*(struct)
,	O
dequeue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(char)
(	O
rawq	*(struct)
)	O
)	O
;	O
}	O
void	O
rescan_inputq	()->(void)
(	O
)	O
{	O
short	O
*	O
buf	*(short)
;	O
int	O
i	int
,	O
n	int
;	O
n	int
=	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
inputq	*(struct)
)	O
;	O
buf	*(short)
=	O
alloca	O
(	O
n	int
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
memcpy	O
(	O
buf	*(short)
,	O
inputq	*(struct)
->	O
cs	*(short)
,	O
n	int
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
inputq	*(struct)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
input_character	(int)->(int)
(	O
unquote_char	(short)->(char)
(	O
buf	*(short)
[	O
i	int
]	O
)	O
)	O
;	O
}	O
error_t	int
drop_output	()->(int)
(	O
)	O
{	O
error_t	int
err	int
=	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
abandon_physical_output	*(()->(int))
)	O
(	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
clear_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(void)
(	O
outputq	*(struct)
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
drain_output	()->(int)
(	O
)	O
{	O
int	O
cancel	int
=	O
0	int
;	O
while	O
(	O
(	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
outputq	*(struct)
)	O
||	O
(	O
*	O
bottom	*(struct(enum,*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*(()->(int)),*((*(struct`))->(int)),*((int,int)->(int)),*((*(int))->(int))))
->	O
pending_output_size	*(()->(int))
)	O
(	O
)	O
)	O
&&	O
(	O
!	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
||	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
&&	O
!	O
cancel	int
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
outputq	*(struct)
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
&	O
global_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
cancel	int
?	O
EINTR	int
:	O
0	int
;	O
}	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
create_queue	(int,int,int)->(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
(	O
int	O
size	*(struct)
,	O
int	O
lowat	int
,	O
int	O
hiwat	int
)	O
{	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
)	O
+	O
size	*(struct)
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
assert	O
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
)	O
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
susp	int
=	O
0	int
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
lowat	int
=	O
lowat	int
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
hiwat	int
=	O
hiwat	int
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
ce	*(short)
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
arraylen	int
=	O
size	*(struct)
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
=	O
malloc	O
(	O
sizeof	O
(	O
pthread_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
)	O
;	O
assert	O
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
)	O
;	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
,	O
NULL	O
)	O
;	O
return	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
;	O
}	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
reallocate_queue	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))
(	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
)	O
{	O
int	O
len	int
;	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
*	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
;	O
len	int
=	O
qsize	(*(struct(int,int,int,*(short),*(short),int,*(union(struct`,array(char),long long)),array(short))))->(int)
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
)	O
;	O
if	O
(	O
len	int
<	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
arraylen	int
/	O
2	int
)	O
{	O
memmove	O
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
,	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
,	O
len	int
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
ce	*(short)
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
+	O
len	int
;	O
}	O
else	O
{	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
queue	struct(int,int,int,*(short),*(short),int,*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)),array(short))
)	O
+	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
arraylen	int
*	O
2	int
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
susp	int
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
susp	int
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
lowat	int
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
lowat	int
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
hiwat	int
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
hiwat	int
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
=	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
ce	*(short)
=	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
+	O
len	int
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
arraylen	int
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
arraylen	int
*	O
2	int
;	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
=	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
wait	*(union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long))
;	O
memmove	O
(	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
array	array(short)
,	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
->	O
cs	*(short)
,	O
len	int
*	O
sizeof	O
(	O
quoted_char	short
)	O
)	O
;	O
free	()->(int)
(	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
)	O
;	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
=	O
newq	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
;	O
}	O
return	O
q	*(struct(int,int,int,*(short),*(short),int,*(union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long)),array(short)))
;	O
}	O
