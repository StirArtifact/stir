lex_pos_ty	struct
gram_pos	struct(*(char),long)
;	O
int	O
gram_pos_column	int
;	O
void	O
po_gram_error	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
*	O
buffer	*(char)
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
if	O
(	O
vasprintf	(*(*(char)),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
&	O
buffer	*(char)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_ERROR	int
,	O
NULL	O
,	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
,	O
gram_pos	struct(*(char),long)
.	O
line_number	long
,	O
gram_pos_column	int
+	O
1	int
,	O
false	int
,	O
buffer	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
if	O
(	O
error_message_count	int
>=	O
gram_max_allowed_errors	int
)	O
po_error	*((int,int,*(char))->(void))
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many errors, aborting"	*(char)
)	O
)	O
;	O
}	O
void	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
const	O
lex_pos_ty	struct
*	O
pp	*(struct(*(char),long))
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
*	O
buffer	*(char)
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
if	O
(	O
vasprintf	(*(*(char)),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
&	O
buffer	*(char)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
<	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_ERROR	int
,	O
NULL	O
,	O
pp	*(struct(*(char),long))
->	O
file_name	*(char)
,	O
pp	*(struct(*(char),long))
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
buffer	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
if	O
(	O
error_message_count	int
>=	O
gram_max_allowed_errors	int
)	O
po_error	*((int,int,*(char))->(void))
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many errors, aborting"	*(char)
)	O
)	O
;	O
}	O
struct	O
mbchar	struct(long,bool,int,array(char))
{	O
size_t	long
bytes	long
;	O
bool	bool
uc_valid	bool
;	O
ucs4_t	int
uc	int
;	O
char	O
buf	array(char)
[	O
MBCHAR_BUF_SIZE	int
]	O
;	O
}	O
;	O
typedef	O
struct	O
mbchar	struct(long,bool,int,array(char))
mbchar_t	array(struct(long,bool,int,array(char)))
[	O
1	int
]	O
;	O
static	O
inline	O
void	O
memcpy_small	(*(void),*(void),long)->(void)
(	O
void	O
*	O
dst	*(void)
,	O
const	O
void	O
*	O
src	*(char)
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
q	*(char)
=	O
(	O
char	O
*	O
)	O
dst	*(void)
;	O
const	O
char	O
*	O
p	*(void)
=	O
(	O
const	O
char	O
*	O
)	O
src	*(char)
;	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
if	O
(	O
--	O
n	long
>	O
0	int
)	O
do	O
*	O
++	O
q	*(char)
=	O
*	O
++	O
p	*(void)
;	O
while	O
(	O
--	O
n	long
>	O
0	int
)	O
;	O
}	O
}	O
static	O
inline	O
bool	bool
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
const	O
char	O
*	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
return	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
;	O
}	O
static	O
inline	O
size_t	long
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
return	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
;	O
}	O
static	O
inline	O
bool	bool
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
,	O
char	O
sc	char
)	O
{	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
1	int
&&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
==	O
sc	char
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_isnul	(array(struct(long,bool,int,array(char))))->(bool)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
==	O
0	int
)	O
;	O
else	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
1	int
&&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
int	O
mb_cmp	(array(struct(long,bool,int,array(char))),array(struct(long,bool,int,array(char))))->(int)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc1	array(struct(long,bool,int,array(char)))
,	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc2	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
&&	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
return	O
(	O
int	O
)	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
uc	int
-	O
(	O
int	O
)	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
uc	int
;	O
else	O
return	O
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
bytes	long
?	O
memcmp	(*(void),*(void),long)->(int)
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
)	O
:	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
<	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
bytes	long
?	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
)	O
>	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
:	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
bytes	long
)	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_equal	(array(struct(long,bool,int,array(char))),array(struct(long,bool,int,array(char))))->(bool)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc1	array(struct(long,bool,int,array(char)))
,	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc2	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
&&	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
return	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
uc	int
==	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
uc	int
;	O
else	O
return	O
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
bytes	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc2	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
mbc1	array(struct(long,bool,int,array(char)))
->	O
bytes	long
)	O
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_isascii	(array(struct(long,bool,int,array(char))))->(bool)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
>=	O
0x0000	int
&&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
<=	O
0x007F	int
)	O
;	O
else	O
return	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
1	int
&&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
>=	O
0x00	int
)	O
;	O
}	O
static	O
int	O
mb_width	(array(struct(long,bool,int,array(char))))->(int)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
{	O
ucs4_t	int
uc	int
=	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
;	O
const	O
char	O
*	O
encoding	*(char)
=	O
(	O
po_lex_iconv	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
?	O
po_lex_charset	*(char)
:	O
""	*(char)
)	O
;	O
int	O
w	int
=	O
uc_width	(int,*(char))->(int)
(	O
uc	int
,	O
encoding	*(char)
)	O
;	O
if	O
(	O
w	int
>=	O
0	int
)	O
return	O
w	int
;	O
if	O
(	O
uc	int
>=	O
0x0000	int
&&	O
uc	int
<=	O
0x001F	int
)	O
{	O
if	O
(	O
uc	int
==	O
0x0009	int
)	O
return	O
8	int
-	O
(	O
gram_pos_column	int
&	O
7	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
uc	int
>=	O
0x007F	int
&&	O
uc	int
<=	O
0x009F	int
)	O
||	O
(	O
uc	int
>=	O
0x2028	int
&&	O
uc	int
<=	O
0x2029	int
)	O
)	O
return	O
0	int
;	O
return	O
MB_UNPRINTABLE_WIDTH	int
;	O
}	O
else	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
==	O
1	int
)	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
>=	O
0x00	int
&&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
<=	O
0x1F	int
)	O
{	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
==	O
0x09	int
)	O
return	O
8	int
-	O
(	O
gram_pos_column	int
&	O
7	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
==	O
0x7F	int
)	O
return	O
0	int
;	O
}	O
return	O
MB_UNPRINTABLE_WIDTH	int
;	O
}	O
}	O
static	O
inline	O
void	O
mb_putc	(array(struct(long,bool,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
,	O
1	int
,	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
inline	O
void	O
mb_setascii	(array(struct(long,bool,int,array(char))),char)->(void)
(	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
,	O
char	O
sc	char
)	O
{	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
=	O
1	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
1	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
=	O
sc	char
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
=	O
sc	char
;	O
}	O
static	O
inline	O
void	O
mb_copy	(array(struct(long,bool,int,array(char))),array(struct(long,bool,int,array(char))))->(void)
(	O
mbchar_t	array(struct(long,bool,int,array(char)))
new_mbc	array(struct(long,bool,int,array(char)))
,	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
old_mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
memcpy_small	(*(void),*(void),long)->(void)
(	O
&	O
new_mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
,	O
&	O
old_mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
,	O
old_mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
)	O
;	O
new_mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
=	O
old_mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
;	O
if	O
(	O
(	O
new_mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
old_mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
)	O
)	O
new_mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
=	O
old_mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
;	O
}	O
struct	O
mbfile	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
bool	bool
eof_seen	bool
;	O
int	O
have_pushback	int
;	O
unsigned	O
int	O
bufcount	int
;	O
char	O
buf	array(char)
[	O
MBCHAR_BUF_SIZE	int
]	O
;	O
struct	O
mbchar	struct(long,bool,int,array(char))
pushback	array(struct(long,bool,int,array(char)))
[	O
NPUSHBACK	int
]	O
;	O
}	O
;	O
typedef	O
struct	O
mbfile	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))
mbfile_t	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
[	O
1	int
]	O
;	O
static	O
bool	bool
signal_eilseq	bool
;	O
static	O
inline	O
void	O
mbfile_init	(array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
mbfile_t	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
eof_seen	bool
=	O
false	int
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
=	O
0	int
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
=	O
0	int
;	O
}	O
static	O
void	O
mbfile_getc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
,	O
mbfile_t	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
{	O
size_t	long
bytes	long
;	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
eof_seen	bool
)	O
goto	O
eof	O
;	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
>	O
0	int
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
--	O
;	O
mb_copy	(array(struct(long,bool,int,array(char))),array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
&	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
pushback	array(struct(long,bool,int,array(char)))
[	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
==	O
0	int
)	O
{	O
int	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
eof_seen	bool
=	O
true	int
;	O
goto	O
eof	O
;	O
}	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
++	O
;	O
}	O
if	O
(	O
po_lex_iconv	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
unsigned	O
char	O
scratchbuf	array(char)
[	O
64	int
]	O
;	O
const	O
char	O
*	O
inptr	*(char)
=	O
&	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
0	int
]	O
;	O
size_t	long
insize	long
=	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
;	O
char	O
*	O
outptr	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
scratchbuf	array(char)
[	O
0	int
]	O
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
scratchbuf	array(char)
)	O
;	O
size_t	long
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
po_lex_iconv	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
outptr	*(char)
,	O
&	O
outsize	long
)	O
;	O
if	O
(	O
(	O
insize	long
<	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
)	O
!=	O
(	O
outsize	long
<	O
sizeof	O
(	O
scratchbuf	array(char)
)	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
outsize	long
==	O
sizeof	O
(	O
scratchbuf	array(char)
)	O
)	O
{	O
if	O
(	O
res	long
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
errno	O
==	O
EILSEQ	int
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	(*(char))->(void)
(	O
_	O
(	O
"invalid multibyte sequence"	*(char)
)	O
)	O
;	O
bytes	long
=	O
1	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
)	O
{	O
int	O
c	int
;	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
==	O
MBCHAR_BUF_SIZE	int
)	O
{	O
bytes	long
=	O
1	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
eof_seen	bool
=	O
true	int
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
eof	O
;	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	(*(char))->(void)
(	O
_	O
(	O
"incomplete multibyte sequence at end of file"	*(char)
)	O
)	O
;	O
bytes	long
=	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
++	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	(*(char))->(void)
(	O
_	O
(	O
"incomplete multibyte sequence at end of line"	*(char)
)	O
)	O
;	O
bytes	long
=	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
-	O
1	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
const	O
char	O
*	O
errno_description	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	(*(char))->(*(char))
(	O
"%s: %s"	*(char)
,	O
_	O
(	O
"iconv failure"	*(char)
)	O
,	O
errno_description	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
outbytes	long
=	O
sizeof	O
(	O
scratchbuf	array(char)
)	O
-	O
outsize	long
;	O
bytes	long
=	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
-	O
insize	long
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
outbytes	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
u8_mbtoucr	(*(int),*(char),long)->(int)
(	O
&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc	int
,	O
scratchbuf	array(char)
,	O
outbytes	long
)	O
<	O
(	O
int	O
)	O
outbytes	long
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	(*(char))->(void)
(	O
_	O
(	O
"invalid multibyte sequence"	*(char)
)	O
)	O
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
po_lex_weird_cjk	bool
&&	O
(	O
unsigned	O
char	O
)	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
0	int
]	O
>=	O
0x80	int
)	O
{	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
==	O
1	int
)	O
{	O
int	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
eof_seen	bool
=	O
true	int
;	O
goto	O
eof	O
;	O
}	O
}	O
else	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
1	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
++	O
;	O
}	O
}	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
>=	O
2	int
&&	O
(	O
unsigned	O
char	O
)	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
1	int
]	O
>=	O
0x30	int
)	O
bytes	long
=	O
2	int
;	O
else	O
bytes	long
=	O
1	int
;	O
}	O
else	O
{	O
bytes	long
=	O
1	int
;	O
}	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
}	O
memcpy_small	(*(void),*(void),long)->(void)
(	O
&	O
mbc	array(struct(long,bool,int,array(char)))
->	O
buf	array(char)
[	O
0	int
]	O
,	O
&	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
0	int
]	O
,	O
bytes	long
)	O
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
=	O
bytes	long
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
-=	O
bytes	long
;	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
bufcount	int
;	O
char	O
*	O
p	*(void)
=	O
&	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
buf	array(char)
[	O
0	int
]	O
;	O
do	O
{	O
*	O
p	*(void)
=	O
*	O
(	O
p	*(void)
+	O
bytes	long
)	O
;	O
p	*(void)
++	O
;	O
}	O
while	O
(	O
--	O
count	int
>	O
0	int
)	O
;	O
}	O
return	O
;	O
eof	O
:	O
mbc	array(struct(long,bool,int,array(char)))
->	O
bytes	long
=	O
0	int
;	O
mbc	array(struct(long,bool,int,array(char)))
->	O
uc_valid	bool
=	O
false	int
;	O
return	O
;	O
}	O
static	O
void	O
mbfile_ungetc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
,	O
mbfile_t	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
{	O
if	O
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
>=	O
NPUSHBACK	int
)	O
abort	()->(void)
(	O
)	O
;	O
mb_copy	(array(struct(long,bool,int,array(char))),array(struct(long,bool,int,array(char))))->(void)
(	O
&	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
pushback	array(struct(long,bool,int,array(char)))
[	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
]	O
,	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
have_pushback	int
++	O
;	O
}	O
static	O
mbfile_t	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
;	O
unsigned	O
int	O
gram_max_allowed_errors	int
=	O
20	int
;	O
static	O
bool	bool
po_lex_obsolete	bool
;	O
static	O
bool	bool
po_lex_previous	bool
;	O
static	O
bool	bool
pass_comments	bool
=	O
false	int
;	O
bool	bool
pass_obsolete_entries	bool
=	O
false	int
;	O
void	O
lex_start	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
real_filename	*(char)
,	O
const	O
char	O
*	O
logical_filename	*(char)
)	O
{	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
real_filename	*(char)
)	O
;	O
mbfile_init	(array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
gram_pos	struct(*(char),long)
.	O
line_number	long
=	O
1	int
;	O
gram_pos_column	int
=	O
0	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
po_lex_charset_init	()->(void)
(	O
)	O
;	O
}	O
void	O
lex_end	()->(void)
(	O
)	O
{	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
=	O
NULL	O
;	O
gram_pos	struct(*(char),long)
.	O
line_number	long
=	O
0	int
;	O
gram_pos_column	int
=	O
0	int
;	O
signal_eilseq	bool
=	O
false	int
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
po_lex_charset_close	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
mbfile_getc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
;	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
bomb	O
:	O
{	O
const	O
char	O
*	O
errno_description	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
po_xerror	*((int,*(struct),*(char),long,long,int,*(char))->(void))
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	(*(char))->(*(char))
(	O
"%s: %s"	*(char)
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"error while reading \"%s\""	*(char)
)	O
,	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
)	O
,	O
errno_description	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
{	O
gram_pos	struct(*(char),long)
.	O
line_number	long
++	O
;	O
gram_pos_column	int
=	O
0	int
;	O
break	O
;	O
}	O
gram_pos_column	int
+=	O
mb_width	(array(struct(long,bool,int,array(char))))->(int)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\\'	O
)	O
)	O
{	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc2	array(struct(long,bool,int,array(char)))
;	O
mbfile_getc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
mbc2	array(struct(long,bool,int,array(char)))
,	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
;	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc2	array(struct(long,bool,int,array(char)))
)	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
bomb	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc2	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
{	O
mbfile_ungetc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
mbc2	array(struct(long,bool,int,array(char)))
,	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
;	O
break	O
;	O
}	O
gram_pos	struct(*(char),long)
.	O
line_number	long
++	O
;	O
gram_pos_column	int
=	O
0	int
;	O
}	O
else	O
break	O
;	O
}	O
}	O
static	O
void	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
const	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
)	O
{	O
if	O
(	O
!	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
{	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
gram_pos	struct(*(char),long)
.	O
line_number	long
--	O
;	O
else	O
gram_pos_column	int
-=	O
mb_width	(array(struct(long,bool,int,array(char))))->(int)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
mbfile_ungetc	(array(struct(long,bool,int,array(char))),array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char))))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
mbf	array(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),bool,int,int,array(char),array(struct(long,bool,int,array(char)))))
)	O
;	O
}	O
}	O
static	O
int	O
keyword_p	(*(char))->(int)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
!	O
po_lex_previous	bool
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"domain"	*(char)
)	O
)	O
return	O
DOMAIN	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgid"	*(char)
)	O
)	O
return	O
MSGID	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgid_plural"	*(char)
)	O
)	O
return	O
MSGID_PLURAL	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgstr"	*(char)
)	O
)	O
return	O
MSGSTR	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgctxt"	*(char)
)	O
)	O
return	O
MSGCTXT	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgid"	*(char)
)	O
)	O
return	O
PREV_MSGID	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgid_plural"	*(char)
)	O
)	O
return	O
PREV_MSGID_PLURAL	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"msgctxt"	*(char)
)	O
)	O
return	O
PREV_MSGCTXT	int
;	O
}	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
&	O
gram_pos	struct(*(char),long)
,	O
_	O
(	O
"keyword \"%s\" unknown"	*(char)
)	O
,	O
s	*(char)
)	O
;	O
return	O
NAME	int
;	O
}	O
static	O
int	O
control_sequence	()->(int)
(	O
)	O
{	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
;	O
int	O
val	int
;	O
int	O
max	int
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
return	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
val	int
=	O
0	int
;	O
max	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
;	O
val	int
=	O
val	int
*	O
8	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
if	O
(	O
++	O
max	int
==	O
3	int
)	O
break	O
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
break	O
;	O
}	O
return	O
val	int
;	O
case	O
'x'	O
:	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
||	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
!=	O
1	int
||	O
!	O
c_isxdigit	(int)->(bool)
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
)	O
break	O
;	O
val	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
;	O
val	int
*=	O
16	int
;	O
if	O
(	O
c_isdigit	(int)->(bool)
(	O
c	int
)	O
)	O
val	int
+=	O
c	int
-	O
'0'	O
;	O
else	O
if	O
(	O
c_isupper	(int)->(bool)
(	O
c	int
)	O
)	O
val	int
+=	O
c	int
-	O
'A'	O
+	O
10	int
;	O
else	O
val	int
+=	O
c	int
-	O
'a'	O
+	O
10	int
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
break	O
;	O
}	O
return	O
val	int
;	O
}	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
po_gram_error	(*(char))->(void)
(	O
_	O
(	O
"invalid control sequence"	*(char)
)	O
)	O
;	O
return	O
' '	O
;	O
}	O
int	O
po_gram_lex	()->(int)
(	O
)	O
{	O
static	O
char	O
*	O
buf	array(char)
;	O
static	O
size_t	long
bufmax	long
;	O
mbchar_t	array(struct(long,bool,int,array(char)))
mbc	array(struct(long,bool,int,array(char)))
;	O
size_t	long
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
return	O
0	int
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'\n'	O
:	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
'\r'	O
:	O
case	O
'\f'	O
:	O
case	O
'\v'	O
:	O
break	O
;	O
case	O
'#'	O
:	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'~'	O
)	O
)	O
{	O
po_lex_obsolete	bool
=	O
true	int
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'|'	O
)	O
)	O
po_lex_previous	bool
=	O
true	int
;	O
else	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'|'	O
)	O
)	O
{	O
po_lex_previous	bool
=	O
true	int
;	O
break	O
;	O
}	O
signal_eilseq	bool
=	O
false	int
;	O
if	O
(	O
pass_comments	bool
)	O
{	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
bufpos	long
+	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
,	O
bufmax	long
)	O
;	O
}	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
||	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
break	O
;	O
memcpy_small	(*(void),*(void),long)->(void)
(	O
&	O
buf	array(char)
[	O
bufpos	long
]	O
,	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
,	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
;	O
bufpos	long
+=	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
}	O
buf	array(char)
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
string	*(char)
=	O
buf	array(char)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
return	O
COMMENT	int
;	O
}	O
else	O
{	O
while	O
(	O
!	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
&&	O
!	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'"'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
while	O
(	O
bufpos	long
+	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
,	O
bufmax	long
)	O
;	O
}	O
if	O
(	O
mb_iseof	(array(struct(long,bool,int,array(char))))->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
{	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
&	O
gram_pos	struct(*(char),long)
,	O
_	O
(	O
"end-of-file within string"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\n'	O
)	O
)	O
{	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
&	O
gram_pos	struct(*(char),long)
,	O
_	O
(	O
"end-of-line within string"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'"'	O
)	O
)	O
break	O
;	O
if	O
(	O
mb_iseq	(array(struct(long,bool,int,array(char))),char)->(bool)
(	O
mbc	array(struct(long,bool,int,array(char)))
,	O
'\\'	O
)	O
)	O
{	O
buf	array(char)
[	O
bufpos	long
++	O
]	O
=	O
control_sequence	()->(int)
(	O
)	O
;	O
continue	O
;	O
}	O
memcpy_small	(*(void),*(void),long)->(void)
(	O
&	O
buf	array(char)
[	O
bufpos	long
]	O
,	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
,	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
)	O
;	O
bufpos	long
+=	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
}	O
buf	array(char)
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
buf	array(char)
,	O
MSGCTXT_SEPARATOR	char
)	O
!=	O
NULL	O
)	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
&	O
gram_pos	struct(*(char),long)
,	O
_	O
(	O
"context separator <EOT> within string"	*(char)
)	O
)	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buf	array(char)
)	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
(	O
po_lex_previous	bool
?	O
PREV_STRING	int
:	O
STRING	int
)	O
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'_'	O
:	O
case	O
'$'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
;	O
if	O
(	O
bufpos	long
+	O
1	int
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
,	O
bufmax	long
)	O
;	O
}	O
buf	array(char)
[	O
bufpos	long
++	O
]	O
=	O
c	int
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'_'	O
:	O
case	O
'$'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
}	O
break	O
;	O
}	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
buf	array(char)
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
{	O
int	O
k	int
=	O
keyword_p	(*(char))->(int)
(	O
buf	array(char)
)	O
;	O
if	O
(	O
k	int
==	O
NAME	int
)	O
{	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
buf	array(char)
)	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
string	*(char)
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
}	O
else	O
{	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
}	O
return	O
k	int
;	O
}	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
;	O
if	O
(	O
bufpos	long
+	O
1	int
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf	array(char)
,	O
bufmax	long
+	O
1	int
)	O
;	O
}	O
buf	array(char)
[	O
bufpos	long
++	O
]	O
=	O
c	int
;	O
lex_getc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
if	O
(	O
mb_len	(array(struct(long,bool,int,array(char))))->(long)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	(array(struct(long,bool,int,array(char))))->(*(char))
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
[	O
0	int
]	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
}	O
break	O
;	O
}	O
lex_ungetc	(array(struct(long,bool,int,array(char))))->(void)
(	O
mbc	array(struct(long,bool,int,array(char)))
)	O
;	O
buf	array(char)
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
number	long
.	O
number	long
=	O
atol	(*(char))->(long)
(	O
buf	array(char)
)	O
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
number	long
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
number	long
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
NUMBER	int
;	O
case	O
'['	O
:	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
'['	O
;	O
case	O
']'	O
:	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
pos	*(struct(*(char),long))
=	O
gram_pos	struct(*(char),long)
;	O
po_gram_lval	union(struct(*(char),struct(*(char),long),bool),struct(struct(*(*(char)),long,long),struct(*(char),long),bool),struct(long,struct(*(char),long),bool),struct(struct(*(char),long),bool),struct(*(char),*(char),*(char),struct(*(char),long),bool),struct(*(char),*(char),*(char),*(char),struct(*(char),long),bool),struct(struct(*(char),long),struct(*(char),long),bool))
.	O
pos	*(struct(*(char),long))
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
']'	O
;	O
default	O
:	O
return	O
JUNK	int
;	O
}	O
else	O
return	O
JUNK	int
;	O
}	O
}	O
void	O
po_lex_pass_comments	(bool)->(void)
(	O
bool	bool
flag	bool
)	O
{	O
pass_comments	bool
=	O
flag	bool
;	O
}	O
void	O
po_lex_pass_obsolete_entries	(bool)->(void)
(	O
bool	bool
flag	bool
)	O
{	O
pass_obsolete_entries	bool
=	O
flag	bool
;	O
}	O
