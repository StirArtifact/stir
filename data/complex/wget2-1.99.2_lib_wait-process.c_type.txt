typedef	O
struct	O
{	O
volatile	O
sig_atomic_t	int
used	int
;	O
volatile	O
pid_t	int
child	int
;	O
}	O
slaves_entry_t	struct(int,int)
;	O
static	O
slaves_entry_t	struct(int,int)
static_slaves	array(struct(int,int))
[	O
32	int
]	O
;	O
static	O
slaves_entry_t	struct(int,int)
*	O
volatile	O
slaves	*(struct(int,int))
=	O
static_slaves	array(struct(int,int))
;	O
static	O
sig_atomic_t	int
volatile	O
slaves_count	int
=	O
0	int
;	O
static	O
size_t	long
slaves_allocated	long
=	O
SIZEOF	O
(	O
static_slaves	array(struct(int,int))
)	O
;	O
static	O
_GL_ASYNC_SAFE	O
void	O
cleanup_slaves	()->(void)
(	O
void	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
n	long
=	O
slaves_count	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
n	long
--	O
;	O
slaves_count	int
=	O
n	long
;	O
if	O
(	O
slaves	*(struct(int,int))
[	O
n	long
]	O
.	O
used	int
)	O
{	O
pid_t	int
slave	int
=	O
slaves	*(struct(int,int))
[	O
n	long
]	O
.	O
child	int
;	O
kill	(int,int)->(int)
(	O
slave	int
,	O
TERMINATOR	O
)	O
;	O
}	O
}	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
cleanup_slaves_action	(int)->(void)
(	O
int	O
sig	int
_GL_UNUSED	O
)	O
{	O
cleanup_slaves	()->(void)
(	O
)	O
;	O
}	O
void	O
register_slave_subprocess	(int)->(void)
(	O
pid_t	int
child	int
)	O
{	O
static	O
bool	bool
cleanup_slaves_registered	bool
=	O
false	int
;	O
if	O
(	O
!	O
cleanup_slaves_registered	bool
)	O
{	O
atexit	(*(()->(void)))->(int)
(	O
cleanup_slaves	()->(void)
)	O
;	O
at_fatal_signal	(*((int)->(void)))->(void)
(	O
cleanup_slaves_action	(int)->(void)
)	O
;	O
cleanup_slaves_registered	bool
=	O
true	int
;	O
}	O
{	O
slaves_entry_t	struct(int,int)
*	O
s	long
=	O
slaves	*(struct(int,int))
;	O
slaves_entry_t	struct(int,int)
*	O
s_end	*(struct(int,int))
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	long
<	O
s_end	*(struct(int,int))
;	O
s	long
++	O
)	O
if	O
(	O
!	O
s	long
->	O
used	int
)	O
{	O
s	long
->	O
child	int
=	O
child	int
;	O
s	long
->	O
used	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
slaves_count	int
==	O
slaves_allocated	long
)	O
{	O
slaves_entry_t	struct(int,int)
*	O
old_slaves	*(struct(int,int))
=	O
slaves	*(struct(int,int))
;	O
size_t	long
new_slaves_allocated	long
=	O
2	int
*	O
slaves_allocated	long
;	O
slaves_entry_t	struct(int,int)
*	O
new_slaves	*(struct(int,int))
=	O
(	O
slaves_entry_t	struct(int,int)
*	O
)	O
malloc	(long)->(*(void))
(	O
new_slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct(int,int)
)	O
)	O
;	O
if	O
(	O
new_slaves	*(struct(int,int))
==	O
NULL	O
)	O
{	O
kill	(int,int)->(int)
(	O
child	int
,	O
TERMINATOR	O
)	O
;	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_slaves	*(struct(int,int))
,	O
old_slaves	*(struct(int,int))
,	O
slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct(int,int)
)	O
)	O
;	O
slaves	*(struct(int,int))
=	O
new_slaves	*(struct(int,int))
;	O
slaves_allocated	long
=	O
new_slaves_allocated	long
;	O
if	O
(	O
old_slaves	*(struct(int,int))
!=	O
static_slaves	array(struct(int,int))
)	O
free	(*(void))->(void)
(	O
old_slaves	*(struct(int,int))
)	O
;	O
}	O
slaves	*(struct(int,int))
[	O
slaves_count	int
]	O
.	O
child	int
=	O
child	int
;	O
slaves	*(struct(int,int))
[	O
slaves_count	int
]	O
.	O
used	int
=	O
1	int
;	O
slaves_count	int
++	O
;	O
}	O
static	O
void	O
unregister_slave_subprocess	(int)->(void)
(	O
pid_t	int
child	int
)	O
{	O
slaves_entry_t	struct(int,int)
*	O
s	long
=	O
slaves	*(struct(int,int))
;	O
slaves_entry_t	struct(int,int)
*	O
s_end	*(struct(int,int))
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	long
<	O
s_end	*(struct(int,int))
;	O
s	long
++	O
)	O
if	O
(	O
s	long
->	O
used	int
&&	O
s	long
->	O
child	int
==	O
child	int
)	O
s	long
->	O
used	int
=	O
0	int
;	O
}	O
int	O
wait_subprocess	(int,*(char),bool,bool,bool,bool,*(int))->(int)
(	O
pid_t	int
child	int
,	O
const	O
char	O
*	O
progname	*(char)
,	O
bool	bool
ignore_sigpipe	bool
,	O
bool	bool
null_stderr	bool
,	O
bool	bool
slave_process	bool
,	O
bool	bool
exit_on_error	bool
,	O
int	O
*	O
termsigp	*(int)
)	O
{	O
int	O
status	int
;	O
if	O
(	O
termsigp	*(int)
!=	O
NULL	O
)	O
*	O
termsigp	*(int)
=	O
0	int
;	O
status	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
result	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
child	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
result	int
!=	O
child	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	(int,int,*(char))->(void)
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
errno	O
,	O
_	O
(	O
"%s subprocess"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
slave_process	bool
)	O
unregister_slave_subprocess	(int)->(void)
(	O
child	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
termsigp	*(int)
!=	O
NULL	O
)	O
*	O
termsigp	*(int)
=	O
WTERMSIG	O
(	O
status	int
)	O
;	O
if	O
(	O
WTERMSIG	O
(	O
status	int
)	O
==	O
SIGPIPE	int
&&	O
ignore_sigpipe	bool
)	O
return	O
0	int
;	O
if	O
(	O
exit_on_error	bool
||	O
(	O
!	O
null_stderr	bool
&&	O
termsigp	*(int)
==	O
NULL	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess got fatal signal %d"	*(char)
)	O
,	O
progname	*(char)
,	O
(	O
int	O
)	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
127	int
)	O
{	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	(int,int,*(char))->(void)
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
return	O
127	int
;	O
}	O
return	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
}	O
