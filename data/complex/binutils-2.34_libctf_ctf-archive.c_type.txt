static	O
off_t	long
arc_write_one_ctf	O
(	O
ctf_file_t	struct
*	O
f	O
,	O
int	O
fd	int
,	O
size_t	long
threshold	long
)	O
;	O
static	O
ctf_file_t	struct
*	O
ctf_arc_open_by_offset	O
(	O
const	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
size_t	long
offset	long
,	O
int	O
*	O
errp	*(int)
)	O
;	O
static	O
int	O
sort_modent_by_name	O
(	O
const	O
void	O
*	O
one	O
,	O
const	O
void	O
*	O
two	O
,	O
void	O
*	O
n	O
)	O
;	O
static	O
void	O
*	O
arc_mmap_header	O
(	O
int	O
fd	int
,	O
size_t	long
headersz	O
)	O
;	O
static	O
void	O
*	O
arc_mmap_file	O
(	O
int	O
fd	int
,	O
size_t	long
size	long
)	O
;	O
static	O
int	O
arc_mmap_writeout	O
(	O
int	O
fd	int
,	O
void	O
*	O
header	O
,	O
size_t	long
headersz	O
,	O
const	O
char	O
*	O
*	O
errmsg	O
)	O
;	O
static	O
int	O
arc_mmap_unmap	O
(	O
void	O
*	O
header	O
,	O
size_t	long
headersz	O
,	O
const	O
char	O
*	O
*	O
errmsg	O
)	O
;	O
static	O
__thread	O
char	O
*	O
search_nametbl	O
;	O
int	O
ctf_arc_write_fd	(int,*(*(struct)),long,*(*(char)),long)->(int)
(	O
int	O
fd	int
,	O
ctf_file_t	struct
*	O
*	O
ctf_files	O
,	O
size_t	long
ctf_file_cnt	O
,	O
const	O
char	O
*	O
*	O
names	O
,	O
size_t	long
threshold	long
)	O
{	O
const	O
char	O
*	O
errmsg	O
;	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
archdr	O
;	O
size_t	long
i	*(struct)
;	O
char	O
dummy	O
=	O
0	int
;	O
size_t	long
headersz	O
;	O
ssize_t	long
namesz	array(char)
;	O
size_t	long
ctf_startoffs	O
;	O
char	O
*	O
nametbl	O
=	O
NULL	O
;	O
char	O
*	O
np	O
;	O
off_t	long
nameoffs	O
;	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
modent	O
;	O
ctf_dprintf	O
(	O
"Writing CTF archive with %lu files\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
ctf_file_cnt	O
)	O
;	O
headersz	O
=	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
+	O
(	O
ctf_file_cnt	O
*	O
sizeof	O
(	O
uint64_t	long
)	O
*	O
2	int
)	O
;	O
ctf_dprintf	O
(	O
"headersz is %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
headersz	O
)	O
;	O
ctf_startoffs	O
=	O
headersz	O
;	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
ctf_startoffs	O
-	O
1	int
,	O
SEEK_SET	O
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): cannot extend file while writing: %s\n"	*(char)
;	O
goto	O
err	long
;	O
}	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
&	O
dummy	O
,	O
1	int
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): cannot extend file while writing: %s\n"	*(char)
;	O
goto	O
err	long
;	O
}	O
if	O
(	O
(	O
archdr	O
=	O
arc_mmap_header	O
(	O
fd	int
,	O
headersz	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): Cannot mmap(): %s\n"	*(char)
;	O
goto	O
err	long
;	O
}	O
archdr	O
->	O
ctfa_magic	long
=	O
htole64	O
(	O
CTFA_MAGIC	O
)	O
;	O
archdr	O
->	O
ctfa_nfiles	long
=	O
htole64	O
(	O
ctf_file_cnt	O
)	O
;	O
archdr	O
->	O
ctfa_ctfs	long
=	O
htole64	O
(	O
ctf_startoffs	O
)	O
;	O
if	O
(	O
ctf_file_cnt	O
>	O
0	int
)	O
archdr	O
->	O
ctfa_model	long
=	O
htole64	O
(	O
ctf_getmodel	(*(struct))->(int)
(	O
ctf_files	O
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
namesz	array(char)
=	O
0	int
;	O
i	*(struct)
<	O
le64toh	O
(	O
archdr	O
->	O
ctfa_nfiles	long
)	O
;	O
i	*(struct)
++	O
)	O
namesz	array(char)
+=	O
strlen	O
(	O
names	O
[	O
i	*(struct)
]	O
)	O
+	O
1	int
;	O
nametbl	O
=	O
malloc	(long)->(*(void))
(	O
namesz	array(char)
)	O
;	O
if	O
(	O
nametbl	O
==	O
NULL	O
)	O
{	O
errmsg	O
=	O
"Error writing named CTF to archive: %s\n"	*(char)
;	O
goto	O
err_unmap	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
namesz	array(char)
=	O
0	int
,	O
modent	O
=	O
(	O
ctf_archive_modent_t	struct(long,long)
*	O
)	O
(	O
(	O
char	O
*	O
)	O
archdr	O
+	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
)	O
;	O
i	*(struct)
<	O
le64toh	O
(	O
archdr	O
->	O
ctfa_nfiles	long
)	O
;	O
i	*(struct)
++	O
)	O
{	O
off_t	long
off	O
;	O
strcpy	O
(	O
&	O
nametbl	O
[	O
namesz	array(char)
]	O
,	O
names	O
[	O
i	*(struct)
]	O
)	O
;	O
off	O
=	O
arc_write_one_ctf	O
(	O
ctf_files	O
[	O
i	*(struct)
]	O
,	O
fd	int
,	O
threshold	long
)	O
;	O
if	O
(	O
(	O
off	O
<	O
0	int
)	O
&&	O
(	O
off	O
>	O
-	O
ECTF_BASE	int
)	O
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): Cannot determine file "	*(char)
"position while writing to archive: %s"	*(char)
;	O
goto	O
err_free	O
;	O
}	O
if	O
(	O
off	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): Cannot write CTF file to archive: %s\n"	*(char)
;	O
errno	O
=	O
off	O
*	O
-	O
1	int
;	O
goto	O
err_free	O
;	O
}	O
modent	O
->	O
name_offset	long
=	O
htole64	O
(	O
namesz	array(char)
)	O
;	O
modent	O
->	O
ctf_offset	long
=	O
htole64	O
(	O
off	O
-	O
ctf_startoffs	O
)	O
;	O
namesz	array(char)
+=	O
strlen	O
(	O
names	O
[	O
i	*(struct)
]	O
)	O
+	O
1	int
;	O
modent	O
++	O
;	O
}	O
ctf_qsort_r	(*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(void)
(	O
(	O
ctf_archive_modent_t	struct(long,long)
*	O
)	O
(	O
(	O
char	O
*	O
)	O
archdr	O
+	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
)	O
,	O
le64toh	O
(	O
archdr	O
->	O
ctfa_nfiles	long
)	O
,	O
sizeof	O
(	O
struct	O
ctf_archive_modent	struct(long,long)
)	O
,	O
sort_modent_by_name	O
,	O
nametbl	O
)	O
;	O
if	O
(	O
(	O
nameoffs	O
=	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	O
)	O
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): Cannot get current file position "	*(char)
"in archive: %s\n"	*(char)
;	O
goto	O
err_free	O
;	O
}	O
archdr	O
->	O
ctfa_names	long
=	O
htole64	O
(	O
nameoffs	O
)	O
;	O
np	O
=	O
nametbl	O
;	O
while	O
(	O
namesz	array(char)
>	O
0	int
)	O
{	O
ssize_t	long
len	int
;	O
if	O
(	O
(	O
len	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
np	O
,	O
namesz	array(char)
)	O
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_write(): Cannot write name table to archive: %s\n"	*(char)
;	O
goto	O
err_free	O
;	O
}	O
namesz	array(char)
-=	O
len	int
;	O
np	O
+=	O
len	int
;	O
}	O
free	(*(void))->(void)
(	O
nametbl	O
)	O
;	O
if	O
(	O
arc_mmap_writeout	O
(	O
fd	int
,	O
archdr	O
,	O
headersz	O
,	O
&	O
errmsg	O
)	O
<	O
0	int
)	O
goto	O
err_unmap	O
;	O
if	O
(	O
arc_mmap_unmap	O
(	O
archdr	O
,	O
headersz	O
,	O
&	O
errmsg	O
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
return	O
0	int
;	O
err_free	O
:	O
free	(*(void))->(void)
(	O
nametbl	O
)	O
;	O
err_unmap	O
:	O
arc_mmap_unmap	O
(	O
archdr	O
,	O
headersz	O
,	O
NULL	O
)	O
;	O
err	long
:	O
ctf_dprintf	O
(	O
errmsg	O
,	O
errno	O
<	O
ECTF_BASE	int
?	O
strerror	O
(	O
errno	O
)	O
:	O
ctf_errmsg	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
int	O
ctf_arc_write	(*(char),*(*(struct)),long,*(*(char)),long)->(int)
(	O
const	O
char	O
*	O
file	*(struct)
,	O
ctf_file_t	struct
*	O
*	O
ctf_files	O
,	O
size_t	long
ctf_file_cnt	O
,	O
const	O
char	O
*	O
*	O
names	O
,	O
size_t	long
threshold	long
)	O
{	O
int	O
err	long
;	O
int	O
fd	int
;	O
if	O
(	O
(	O
fd	int
=	O
open	O
(	O
file	*(struct)
,	O
O_RDWR	O
|	O
O_CREAT	O
|	O
O_TRUNC	O
|	O
O_CLOEXEC	O
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	O
(	O
"ctf_arc_write(): cannot create %s: %s\n"	*(char)
,	O
file	*(struct)
,	O
strerror	O
(	O
errno	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
err	long
=	O
ctf_arc_write_fd	(int,*(*(struct)),long,*(*(char)),long)->(int)
(	O
fd	int
,	O
ctf_files	O
,	O
ctf_file_cnt	O
,	O
names	O
,	O
threshold	long
)	O
;	O
if	O
(	O
err	long
)	O
goto	O
err	long
;	O
if	O
(	O
(	O
err	long
=	O
close	*((*(void))->(int))
(	O
fd	int
)	O
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	O
(	O
"ctf_arc_write(): Cannot close after writing to archive: "	*(char)
"%s\n"	*(char)
,	O
strerror	O
(	O
errno	O
)	O
)	O
;	O
goto	O
err_close	O
;	O
}	O
err	long
:	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
unlink	(*(char))->(int)
(	O
file	*(struct)
)	O
;	O
return	O
err	long
;	O
err_close	O
:	O
if	O
(	O
err	long
<	O
0	int
)	O
unlink	(*(char))->(int)
(	O
file	*(struct)
)	O
;	O
return	O
err	long
;	O
}	O
static	O
off_t	long
arc_write_one_ctf	O
(	O
ctf_file_t	struct
*	O
f	O
,	O
int	O
fd	int
,	O
size_t	long
threshold	long
)	O
{	O
off_t	long
off	O
,	O
end_off	O
;	O
uint64_t	long
ctfsz	O
=	O
0	int
;	O
char	O
*	O
ctfszp	O
;	O
size_t	long
ctfsz_len	O
;	O
int	O
(	O
*	O
writefn	O
)	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
fd	int
)	O
;	O
if	O
(	O
ctf_serialize	O
(	O
f	O
)	O
<	O
0	int
)	O
return	O
f	O
->	O
ctf_errno	(*(struct))->(int)
*	O
-	O
1	int
;	O
if	O
(	O
(	O
off	O
=	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	O
)	O
)	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
if	O
(	O
f	O
->	O
ctf_size	O
>	O
threshold	long
)	O
writefn	O
=	O
ctf_compress_write	(*(struct),int)->(int)
;	O
else	O
writefn	O
=	O
ctf_write	(*(struct),int)->(int)
;	O
ctfsz_len	O
=	O
sizeof	O
(	O
ctfsz	O
)	O
;	O
ctfszp	O
=	O
(	O
char	O
*	O
)	O
&	O
ctfsz	O
;	O
while	O
(	O
ctfsz_len	O
>	O
0	int
)	O
{	O
ssize_t	long
writelen	O
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
ctfszp	O
,	O
ctfsz_len	O
)	O
;	O
if	O
(	O
writelen	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
ctfsz_len	O
-=	O
writelen	O
;	O
ctfszp	O
+=	O
writelen	O
;	O
}	O
if	O
(	O
writefn	O
(	O
f	O
,	O
fd	int
)	O
!=	O
0	int
)	O
return	O
f	O
->	O
ctf_errno	(*(struct))->(int)
*	O
-	O
1	int
;	O
if	O
(	O
(	O
end_off	O
=	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	O
)	O
)	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
ctfsz	O
=	O
htole64	O
(	O
end_off	O
-	O
off	O
)	O
;	O
if	O
(	O
(	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
off	O
,	O
SEEK_SET	O
)	O
)	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
ctfsz_len	O
=	O
sizeof	O
(	O
ctfsz	O
)	O
;	O
ctfszp	O
=	O
(	O
char	O
*	O
)	O
&	O
ctfsz	O
;	O
while	O
(	O
ctfsz_len	O
>	O
0	int
)	O
{	O
ssize_t	long
writelen	O
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
ctfszp	O
,	O
ctfsz_len	O
)	O
;	O
if	O
(	O
writelen	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
ctfsz_len	O
-=	O
writelen	O
;	O
ctfszp	O
+=	O
writelen	O
;	O
}	O
end_off	O
=	O
LCTF_ALIGN_OFFS	O
(	O
end_off	O
,	O
8	int
)	O
;	O
if	O
(	O
(	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
end_off	O
,	O
SEEK_SET	O
)	O
)	O
<	O
0	int
)	O
return	O
errno	O
*	O
-	O
1	int
;	O
return	O
off	O
;	O
}	O
static	O
int	O
sort_modent_by_name	O
(	O
const	O
void	O
*	O
one	O
,	O
const	O
void	O
*	O
two	O
,	O
void	O
*	O
n	O
)	O
{	O
const	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
one	O
;	O
const	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
two	O
;	O
char	O
*	O
nametbl	O
=	O
n	O
;	O
return	O
strcmp	O
(	O
&	O
nametbl	O
[	O
le64toh	O
(	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name_offset	long
)	O
]	O
,	O
&	O
nametbl	O
[	O
le64toh	O
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name_offset	long
)	O
]	O
)	O
;	O
}	O
static	O
int	O
search_modent_by_name	O
(	O
const	O
void	O
*	O
key	O
,	O
const	O
void	O
*	O
ent	O
)	O
{	O
const	O
char	O
*	O
k	O
=	O
key	O
;	O
const	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
v	O
=	O
ent	O
;	O
return	O
strcmp	O
(	O
k	O
,	O
&	O
search_nametbl	O
[	O
le64toh	O
(	O
v	O
->	O
name_offset	long
)	O
]	O
)	O
;	O
}	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
ctf_arc_bufopen	O
(	O
const	O
void	O
*	O
buf	*(void)
,	O
size_t	long
size	long
_libctf_unused_	O
,	O
int	O
*	O
errp	*(int)
)	O
{	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
=	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
)	O
buf	*(void)
;	O
if	O
(	O
le64toh	O
(	O
arc	O
->	O
ctfa_magic	long
)	O
!=	O
CTFA_MAGIC	O
)	O
{	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
ECTF_FMT	int
;	O
return	O
NULL	O
;	O
}	O
return	O
arc	O
;	O
}	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
ctf_arc_open_internal	O
(	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
const	O
char	O
*	O
errmsg	O
;	O
int	O
fd	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(char)
;	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
;	O
libctf_init_debug	O
(	O
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
open	O
(	O
filename	*(char)
,	O
O_RDONLY	O
)	O
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_open(): cannot open %s: %s\n"	*(char)
;	O
goto	O
err	long
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
s	*(char)
)	O
<	O
0	int
)	O
{	O
errmsg	O
=	O
"ctf_arc_open(): cannot stat %s: %s\n"	*(char)
;	O
goto	O
err_close	O
;	O
}	O
if	O
(	O
(	O
arc	O
=	O
arc_mmap_file	O
(	O
fd	int
,	O
s	*(char)
.	O
st_size	array(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
errmsg	O
=	O
"ctf_arc_open(): Cannot read in %s: %s\n"	*(char)
;	O
goto	O
err_close	O
;	O
}	O
if	O
(	O
le64toh	O
(	O
arc	O
->	O
ctfa_magic	long
)	O
!=	O
CTFA_MAGIC	O
)	O
{	O
errmsg	O
=	O
"ctf_arc_open(): Invalid magic number"	*(char)
;	O
errno	O
=	O
ECTF_FMT	int
;	O
goto	O
err_unmap	O
;	O
}	O
arc	O
->	O
ctfa_magic	long
=	O
s	*(char)
.	O
st_size	array(char)
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
arc	O
;	O
err_unmap	O
:	O
arc_mmap_unmap	O
(	O
arc	O
,	O
s	*(char)
.	O
st_size	array(char)
,	O
NULL	O
)	O
;	O
err_close	O
:	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
err	long
:	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
errno	O
;	O
ctf_dprintf	O
(	O
errmsg	O
,	O
filename	*(char)
,	O
errno	O
<	O
ECTF_BASE	int
?	O
strerror	O
(	O
errno	O
)	O
:	O
ctf_errmsg	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
ctf_arc_close_internal	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
)	O
{	O
if	O
(	O
arc	O
==	O
NULL	O
)	O
return	O
;	O
arc_mmap_unmap	O
(	O
arc	O
,	O
arc	O
->	O
ctfa_magic	long
,	O
NULL	O
)	O
;	O
}	O
void	O
ctf_arc_close	(*(struct))->(void)
(	O
ctf_archive_t	struct
*	O
arc	O
)	O
{	O
if	O
(	O
arc	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
arc	O
->	O
ctfi_is_archive	O
)	O
ctf_arc_close_internal	O
(	O
arc	O
->	O
ctfi_archive	O
)	O
;	O
else	O
ctf_file_close	(*(struct))->(void)
(	O
arc	O
->	O
ctfi_file	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
arc	O
->	O
ctfi_symsect	O
.	O
cts_data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
arc	O
->	O
ctfi_data	O
)	O
;	O
if	O
(	O
arc	O
->	O
ctfi_bfd_close	O
)	O
arc	O
->	O
ctfi_bfd_close	O
(	O
arc	O
)	O
;	O
free	(*(void))->(void)
(	O
arc	O
)	O
;	O
}	O
static	O
ctf_file_t	struct
*	O
ctf_arc_open_by_name_internal	O
(	O
const	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
modent	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
_CTF_SECTION	O
;	O
ctf_dprintf	O
(	O
"ctf_arc_open_by_name(%s): opening\n"	*(char)
,	O
name	*(char)
)	O
;	O
modent	O
=	O
(	O
ctf_archive_modent_t	struct(long,long)
*	O
)	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
)	O
;	O
search_nametbl	O
=	O
(	O
char	O
*	O
)	O
arc	O
+	O
le64toh	O
(	O
arc	O
->	O
ctfa_names	long
)	O
;	O
modent	O
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
name	*(char)
,	O
modent	O
,	O
le64toh	O
(	O
arc	O
->	O
ctfa_nfiles	long
)	O
,	O
sizeof	O
(	O
struct	O
ctf_archive_modent	struct(long,long)
)	O
,	O
search_modent_by_name	O
)	O
;	O
if	O
(	O
modent	O
==	O
NULL	O
)	O
{	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
ECTF_ARNNAME	int
;	O
return	O
NULL	O
;	O
}	O
return	O
ctf_arc_open_by_offset	O
(	O
arc	O
,	O
symsect	O
,	O
strsect	O
,	O
le64toh	O
(	O
modent	O
->	O
ctf_offset	long
)	O
,	O
errp	*(int)
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_arc_open_by_name_sections	(*(struct),*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(char),*(int))->(*(struct))
(	O
const	O
ctf_archive_t	struct
*	O
arc	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
if	O
(	O
arc	O
->	O
ctfi_is_archive	O
)	O
{	O
ctf_file_t	struct
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
ctf_arc_open_by_name_internal	O
(	O
arc	O
->	O
ctfi_archive	O
,	O
symsect	O
,	O
strsect	O
,	O
name	*(char)
,	O
errp	*(int)
)	O
;	O
if	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
->	O
ctf_archive	struct(long,long,long,long,long)
=	O
(	O
ctf_archive_t	struct
*	O
)	O
arc	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
if	O
(	O
(	O
name	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
strcmp	O
(	O
name	*(char)
,	O
_CTF_SECTION	O
)	O
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
ECTF_ARNNAME	int
;	O
return	O
NULL	O
;	O
}	O
arc	O
->	O
ctfi_file	O
->	O
ctf_archive	struct(long,long,long,long,long)
=	O
(	O
ctf_archive_t	struct
*	O
)	O
arc	O
;	O
arc	O
->	O
ctfi_file	O
->	O
ctf_refcnt	O
++	O
;	O
return	O
arc	O
->	O
ctfi_file	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_arc_open_by_name	(*(struct),*(char),*(int))->(*(struct))
(	O
const	O
ctf_archive_t	struct
*	O
arc	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
*	O
errp	*(int)
)	O
{	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
=	O
&	O
arc	O
->	O
ctfi_symsect	O
;	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
=	O
&	O
arc	O
->	O
ctfi_strsect	O
;	O
if	O
(	O
symsect	O
->	O
cts_name	*(char)
==	O
NULL	O
)	O
symsect	O
=	O
NULL	O
;	O
if	O
(	O
strsect	O
->	O
cts_name	*(char)
==	O
NULL	O
)	O
strsect	O
=	O
NULL	O
;	O
return	O
ctf_arc_open_by_name_sections	(*(struct),*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(char),*(int))->(*(struct))
(	O
arc	O
,	O
symsect	O
,	O
strsect	O
,	O
name	*(char)
,	O
errp	*(int)
)	O
;	O
}	O
static	O
ctf_file_t	struct
*	O
ctf_arc_open_by_offset	O
(	O
const	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
size_t	long
offset	long
,	O
int	O
*	O
errp	*(int)
)	O
{	O
ctf_sect_t	struct(*(char),*(void),long,long)
ctfsect	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
;	O
ctf_dprintf	O
(	O
"ctf_arc_open_by_offset(%lu): opening\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
memset	O
(	O
&	O
ctfsect	O
,	O
0	int
,	O
sizeof	O
(	O
ctf_sect_t	struct(*(char),*(void),long,long)
)	O
)	O
;	O
offset	long
+=	O
le64toh	O
(	O
arc	O
->	O
ctfa_ctfs	long
)	O
;	O
ctfsect	O
.	O
cts_name	*(char)
=	O
_CTF_SECTION	O
;	O
ctfsect	O
.	O
cts_size	long
=	O
le64toh	O
(	O
*	O
(	O
(	O
uint64_t	long
*	O
)	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
offset	long
)	O
)	O
)	O
;	O
ctfsect	O
.	O
cts_entsize	long
=	O
1	int
;	O
ctfsect	O
.	O
cts_data	*(void)
=	O
(	O
void	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
offset	long
+	O
sizeof	O
(	O
uint64_t	long
)	O
)	O
;	O
fp	*(struct)
=	O
ctf_bufopen	(*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(struct(*(char),*(void),long,long)),*(int))->(*(struct))
(	O
&	O
ctfsect	O
,	O
symsect	O
,	O
strsect	O
,	O
errp	*(int)
)	O
;	O
if	O
(	O
fp	*(struct)
)	O
ctf_setmodel	(*(struct),int)->(int)
(	O
fp	*(struct)
,	O
le64toh	O
(	O
arc	O
->	O
ctfa_model	long
)	O
)	O
;	O
return	O
fp	*(struct)
;	O
}	O
static	O
int	O
ctf_archive_raw_iter_internal	O
(	O
const	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
ctf_archive_raw_member_f	(*(char),*(void),long,*(void))->(int)
*	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	O
;	O
size_t	long
i	*(struct)
;	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
modent	O
;	O
const	O
char	O
*	O
nametbl	O
;	O
modent	O
=	O
(	O
ctf_archive_modent_t	struct(long,long)
*	O
)	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
)	O
;	O
nametbl	O
=	O
(	O
(	O
(	O
const	O
char	O
*	O
)	O
arc	O
)	O
+	O
le64toh	O
(	O
arc	O
->	O
ctfa_names	long
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
le64toh	O
(	O
arc	O
->	O
ctfa_nfiles	long
)	O
;	O
i	*(struct)
++	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
fp	*(struct)
;	O
name	*(char)
=	O
&	O
nametbl	O
[	O
le64toh	O
(	O
modent	O
[	O
i	*(struct)
]	O
.	O
name_offset	long
)	O
]	O
;	O
fp	*(struct)
=	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
le64toh	O
(	O
arc	O
->	O
ctfa_ctfs	long
)	O
+	O
le64toh	O
(	O
modent	O
[	O
i	*(struct)
]	O
.	O
ctf_offset	long
)	O
)	O
;	O
if	O
(	O
(	O
rc	O
=	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
(	O
name	*(char)
,	O
(	O
void	O
*	O
)	O
(	O
fp	*(struct)
+	O
sizeof	O
(	O
uint64_t	long
)	O
)	O
,	O
le64toh	O
(	O
*	O
(	O
(	O
uint64_t	long
*	O
)	O
fp	*(struct)
)	O
)	O
,	O
data	*(void)
)	O
)	O
!=	O
0	int
)	O
return	O
rc	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
ctf_archive_raw_iter	(*(struct),*((*(char),*(void),long,*(void))->(int)),*(void))->(int)
(	O
const	O
ctf_archive_t	struct
*	O
arc	O
,	O
ctf_archive_raw_member_f	(*(char),*(void),long,*(void))->(int)
*	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
if	O
(	O
arc	O
->	O
ctfi_is_archive	O
)	O
return	O
ctf_archive_raw_iter_internal	O
(	O
arc	O
->	O
ctfi_archive	O
,	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
data	*(void)
)	O
;	O
return	O
-	O
EINVAL	O
;	O
}	O
static	O
int	O
ctf_archive_iter_internal	O
(	O
const	O
ctf_archive_t	struct
*	O
wrapper	O
,	O
const	O
struct	O
ctf_archive	struct(long,long,long,long,long)
*	O
arc	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
,	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
,	O
ctf_archive_member_f	(*(struct),*(char),*(void))->(int)
*	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	O
;	O
size_t	long
i	*(struct)
;	O
ctf_file_t	struct
*	O
f	O
;	O
struct	O
ctf_archive_modent	struct(long,long)
*	O
modent	O
;	O
const	O
char	O
*	O
nametbl	O
;	O
modent	O
=	O
(	O
ctf_archive_modent_t	struct(long,long)
*	O
)	O
(	O
(	O
char	O
*	O
)	O
arc	O
+	O
sizeof	O
(	O
struct	O
ctf_archive	struct(long,long,long,long,long)
)	O
)	O
;	O
nametbl	O
=	O
(	O
(	O
(	O
const	O
char	O
*	O
)	O
arc	O
)	O
+	O
le64toh	O
(	O
arc	O
->	O
ctfa_names	long
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
le64toh	O
(	O
arc	O
->	O
ctfa_nfiles	long
)	O
;	O
i	*(struct)
++	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
&	O
nametbl	O
[	O
le64toh	O
(	O
modent	O
[	O
i	*(struct)
]	O
.	O
name_offset	long
)	O
]	O
;	O
if	O
(	O
(	O
f	O
=	O
ctf_arc_open_by_name_internal	O
(	O
arc	O
,	O
symsect	O
,	O
strsect	O
,	O
name	*(char)
,	O
&	O
rc	O
)	O
)	O
==	O
NULL	O
)	O
return	O
rc	O
;	O
f	O
->	O
ctf_archive	struct(long,long,long,long,long)
=	O
(	O
ctf_archive_t	struct
*	O
)	O
wrapper	O
;	O
if	O
(	O
(	O
rc	O
=	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
(	O
f	O
,	O
name	*(char)
,	O
data	*(void)
)	O
)	O
!=	O
0	int
)	O
{	O
ctf_file_close	(*(struct))->(void)
(	O
f	O
)	O
;	O
return	O
rc	O
;	O
}	O
ctf_file_close	(*(struct))->(void)
(	O
f	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
ctf_archive_iter	(*(struct),*((*(struct),*(char),*(void))->(int)),*(void))->(int)
(	O
const	O
ctf_archive_t	struct
*	O
arc	O
,	O
ctf_archive_member_f	(*(struct),*(char),*(void))->(int)
*	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
symsect	O
=	O
&	O
arc	O
->	O
ctfi_symsect	O
;	O
const	O
ctf_sect_t	struct(*(char),*(void),long,long)
*	O
strsect	O
=	O
&	O
arc	O
->	O
ctfi_strsect	O
;	O
if	O
(	O
symsect	O
->	O
cts_name	*(char)
==	O
NULL	O
)	O
symsect	O
=	O
NULL	O
;	O
if	O
(	O
strsect	O
->	O
cts_name	*(char)
==	O
NULL	O
)	O
strsect	O
=	O
NULL	O
;	O
if	O
(	O
arc	O
->	O
ctfi_is_archive	O
)	O
return	O
ctf_archive_iter_internal	O
(	O
arc	O
,	O
arc	O
->	O
ctfi_archive	O
,	O
symsect	O
,	O
strsect	O
,	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
,	O
data	*(void)
)	O
;	O
return	O
func	*((*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(void))->(int))
(	O
arc	O
->	O
ctfi_file	O
,	O
_CTF_SECTION	O
,	O
data	*(void)
)	O
;	O
}	O
static	O
void	O
*	O
arc_mmap_header	O
(	O
int	O
fd	int
,	O
size_t	long
headersz	O
)	O
{	O
void	O
*	O
hdr	O
;	O
if	O
(	O
(	O
hdr	O
=	O
mmap	O
(	O
NULL	O
,	O
headersz	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_SHARED	O
,	O
fd	int
,	O
0	int
)	O
)	O
==	O
MAP_FAILED	O
)	O
return	O
NULL	O
;	O
return	O
hdr	O
;	O
}	O
static	O
void	O
*	O
arc_mmap_file	O
(	O
int	O
fd	int
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
arc	O
;	O
if	O
(	O
(	O
arc	O
=	O
mmap	O
(	O
NULL	O
,	O
size	long
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_PRIVATE	O
,	O
fd	int
,	O
0	int
)	O
)	O
==	O
MAP_FAILED	O
)	O
return	O
NULL	O
;	O
return	O
arc	O
;	O
}	O
static	O
int	O
arc_mmap_writeout	O
(	O
int	O
fd	int
_libctf_unused_	O
,	O
void	O
*	O
header	O
,	O
size_t	long
headersz	O
,	O
const	O
char	O
*	O
*	O
errmsg	O
)	O
{	O
if	O
(	O
msync	O
(	O
header	O
,	O
headersz	O
,	O
MS_ASYNC	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errmsg	O
)	O
*	O
errmsg	O
=	O
"arc_mmap_writeout(): Cannot sync after writing to %s: %s\n"	*(char)
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
arc_mmap_unmap	O
(	O
void	O
*	O
header	O
,	O
size_t	long
headersz	O
,	O
const	O
char	O
*	O
*	O
errmsg	O
)	O
{	O
if	O
(	O
munmap	O
(	O
header	O
,	O
headersz	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errmsg	O
)	O
*	O
errmsg	O
=	O
"arc_mmap_munmap(): Cannot unmap after writing to %s: %s\n"	*(char)
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
