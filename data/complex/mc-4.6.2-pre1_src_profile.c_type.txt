enum	O
{	O
FirstBrace	int
,	O
OnSecHeader	int
,	O
IgnoreToEOL	int
,	O
KeyDef	int
,	O
KeyDefOnKey	int
,	O
KeyValue	int
}	O
;	O
typedef	O
struct	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
{	O
char	O
*	O
KeyName	*(char)
;	O
char	O
*	O
Value	*(char)
;	O
struct	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
link	(*(char),*(char))->(int)
;	O
}	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
;	O
typedef	O
struct	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
{	O
char	O
*	O
AppName	*(char)
;	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
struct	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
link	(*(char),*(char))->(int)
;	O
}	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
;	O
typedef	O
struct	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
{	O
char	O
*	O
FileName	*(char)
;	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
struct	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
link	(*(char),*(char))->(int)
;	O
}	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
;	O
static	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
0	int
;	O
static	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
find_loaded	(*(char),*(*(struct(*(char),*(struct`),*(struct`)))))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
const	O
char	O
*	O
FileName	*(char)
,	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
)	O
{	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
=	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
while	O
(	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
FileName	*(char)
,	O
p	*(void)
->	O
FileName	*(char)
)	O
)	O
{	O
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
p	*(void)
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
return	O
p	*(void)
;	O
}	O
p	*(void)
=	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
str_untranslate_newline_dup	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
l	int
=	O
0	int
;	O
char	O
*	O
p	*(void)
=	O
s	*(char)
,	O
*	O
q	*(char)
;	O
g_return_val_if_fail	O
(	O
s	*(char)
,	O
NULL	O
)	O
;	O
while	O
(	O
*	O
p	*(void)
)	O
{	O
l	int
++	O
;	O
l	int
+=	O
(	O
*	O
p	*(void)
==	O
'\n'	O
||	O
*	O
p	*(void)
==	O
TRANSLATION_CHAR	char
)	O
;	O
p	*(void)
++	O
;	O
}	O
q	*(char)
=	O
p	*(void)
=	O
g_malloc	(long)->(*(void))
(	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
q	*(char)
)	O
return	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'\n'	O
:	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	*(void)
++	O
=	O
'n'	O
;	O
break	O
;	O
case	O
TRANSLATION_CHAR	char
:	O
if	O
(	O
s	*(char)
[	O
1	int
]	O
==	O
'n'	O
||	O
s	*(char)
[	O
1	int
]	O
==	O
TRANSLATION_CHAR	char
)	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
break	O
;	O
case	O
'\0'	O
:	O
*	O
p	*(void)
=	O
'\0'	O
;	O
return	O
q	*(char)
;	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
}	O
s	*(char)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
str_translate_newline_dup	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
g_return_val_if_fail	O
(	O
s	*(char)
,	O
NULL	O
)	O
;	O
q	*(char)
=	O
p	*(void)
=	O
g_malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
q	*(char)
)	O
return	O
0	int
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
TRANSLATION_CHAR	char
)	O
{	O
switch	O
(	O
*	O
(	O
++	O
s	*(char)
)	O
)	O
{	O
case	O
'n'	O
:	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
TRANSLATION_CHAR	char
:	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
break	O
;	O
case	O
'\0'	O
:	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
return	O
q	*(char)
;	O
default	O
:	O
*	O
p	*(void)
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
}	O
}	O
else	O
{	O
*	O
p	*(void)
++	O
=	O
*	O
s	*(char)
;	O
}	O
s	*(char)
++	O
;	O
}	O
*	O
p	*(void)
=	O
'\0'	O
;	O
return	O
q	*(char)
;	O
}	O
static	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
load	(*(char))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
state	*(int)
;	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
0	int
;	O
char	O
CharBuffer	array(char)
[	O
STRSIZE	int
]	O
;	O
char	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
int	O
c	int
;	O
if	O
(	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"r"	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
state	*(int)
=	O
FirstBrace	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
continue	O
;	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
OnSecHeader	int
:	O
if	O
(	O
c	int
==	O
']'	O
||	O
overflow	O
)	O
{	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
'\0'	O
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
AppName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
CharBuffer	array(char)
)	O
;	O
state	*(int)
=	O
IgnoreToEOL	int
;	O
}	O
else	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
=	O
c	int
;	O
break	O
;	O
case	O
IgnoreToEOL	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
state	*(int)
=	O
KeyDef	int
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
}	O
break	O
;	O
case	O
FirstBrace	int
:	O
case	O
KeyDef	int
:	O
case	O
KeyDefOnKey	int
:	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
g_new	O
(	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
,	O
1	int
)	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
link	(*(char),*(char))->(int)
=	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
0	int
;	O
state	*(int)
=	O
OnSecHeader	int
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
break	O
;	O
}	O
if	O
(	O
state	*(int)
==	O
FirstBrace	int
)	O
break	O
;	O
if	O
(	O
(	O
c	int
==	O
' '	O
&&	O
state	*(int)
!=	O
KeyDefOnKey	int
)	O
||	O
c	int
==	O
'\t'	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
overflow	O
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
'='	O
||	O
overflow	O
)	O
{	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
'\0'	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
g_new	O
(	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
,	O
1	int
)	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
link	(*(char),*(char))->(int)
=	O
temp	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
KeyName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
CharBuffer	array(char)
)	O
;	O
state	*(int)
=	O
KeyValue	int
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
}	O
else	O
{	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
=	O
c	int
;	O
state	*(int)
=	O
KeyDefOnKey	int
;	O
}	O
break	O
;	O
case	O
KeyValue	int
:	O
if	O
(	O
overflow	O
||	O
c	int
==	O
'\n'	O
)	O
{	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
'\0'	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
Value	*(char)
=	O
str_translate_newline_dup	(*(char))->(*(char))
(	O
CharBuffer	array(char)
)	O
;	O
state	*(int)
=	O
c	int
==	O
'\n'	O
?	O
KeyDef	int
:	O
IgnoreToEOL	int
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
CharBuffer	array(char)
;	O
}	O
else	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
=	O
c	int
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
KeyValue	int
:	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
'\0'	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
Value	*(char)
=	O
str_translate_newline_dup	(*(char))->(*(char))
(	O
CharBuffer	array(char)
)	O
;	O
break	O
;	O
case	O
OnSecHeader	int
:	O
{	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
link	(*(char),*(char))->(int)
=	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
link	(*(char),*(char))->(int)
;	O
g_free	(*(void))->(void)
(	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
link	(*(char),*(char))->(int)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: Corrupted initialization file `%s'\n"	*(char)
,	O
file	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
SecHeader	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
}	O
static	O
void	O
new_key	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(char),*(char))->(void)
(	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
Value	*(char)
)	O
{	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
key	*(void)
;	O
key	*(void)
=	O
g_new	O
(	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
,	O
1	int
)	O
;	O
key	*(void)
->	O
KeyName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
KeyName	*(char)
)	O
;	O
key	*(void)
->	O
Value	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
Value	*(char)
)	O
;	O
key	*(void)
->	O
link	(*(char),*(char))->(int)
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
key	*(void)
;	O
}	O
static	O
const	O
char	O
*	O
GetSetProfileChar	(int,*(char),*(char),*(char),*(char))->(*(char))
(	O
int	O
set	int
,	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
Default	*(char)
,	O
const	O
char	O
*	O
FileName	*(char)
)	O
{	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
key	*(void)
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
find_loaded	(*(char),*(*(struct(*(char),*(struct`),*(struct`)))))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
FileName	*(char)
,	O
&	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
)	O
;	O
if	O
(	O
!	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
{	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
g_new	O
(	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
,	O
1	int
)	O
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
link	(*(char),*(char))->(int)
=	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
FileName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
FileName	*(char)
)	O
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
load	(*(char))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
FileName	*(char)
)	O
;	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
}	O
for	O
(	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
==	O
0	int
||	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
,	O
AppName	*(char)
)	O
)	O
continue	O
;	O
for	O
(	O
key	*(void)
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
key	*(void)
;	O
key	*(void)
=	O
key	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
key	*(void)
->	O
KeyName	*(char)
,	O
KeyName	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
set	int
)	O
{	O
g_free	(*(void))->(void)
(	O
key	*(void)
->	O
Value	*(char)
)	O
;	O
key	*(void)
->	O
Value	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
Default	*(char)
)	O
;	O
}	O
return	O
key	*(void)
->	O
Value	*(char)
;	O
}	O
if	O
(	O
set	int
)	O
{	O
new_key	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(char),*(char))->(void)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
KeyName	*(char)
,	O
Default	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
set	int
&&	O
Default	*(char)
)	O
{	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
g_new	O
(	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
,	O
1	int
)	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
AppName	*(char)
)	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
0	int
;	O
new_key	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(char),*(char))->(void)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
KeyName	*(char)
,	O
Default	*(char)
)	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
link	(*(char),*(char))->(int)
=	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
}	O
return	O
Default	*(char)
;	O
}	O
static	O
short	O
GetSetProfile	(int,*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
int	O
set	int
,	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
Default	*(char)
,	O
char	O
*	O
ReturnedString	*(char)
,	O
short	O
Size	short
,	O
const	O
char	O
*	O
FileName	*(char)
)	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
s	*(char)
=	O
GetSetProfileChar	(int,*(char),*(char),*(char),*(char))->(*(char))
(	O
set	int
,	O
AppName	*(char)
,	O
KeyName	*(char)
,	O
Default	*(char)
,	O
FileName	*(char)
)	O
;	O
if	O
(	O
!	O
set	int
)	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
ReturnedString	*(char)
,	O
s	*(char)
,	O
Size	short
)	O
;	O
return	O
1	int
;	O
}	O
short	O
GetPrivateProfileString	(*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
Default	*(char)
,	O
char	O
*	O
ReturnedString	*(char)
,	O
short	O
Size	short
,	O
const	O
char	O
*	O
FileName	*(char)
)	O
{	O
return	O
(	O
GetSetProfile	(int,*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
0	int
,	O
AppName	*(char)
,	O
KeyName	*(char)
,	O
Default	*(char)
,	O
ReturnedString	*(char)
,	O
Size	short
,	O
FileName	*(char)
)	O
)	O
;	O
}	O
const	O
char	O
*	O
get_profile_string	(*(char),*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
Default	*(char)
,	O
const	O
char	O
*	O
FileName	*(char)
)	O
{	O
return	O
GetSetProfileChar	(int,*(char),*(char),*(char),*(char))->(*(char))
(	O
0	int
,	O
AppName	*(char)
,	O
KeyName	*(char)
,	O
Default	*(char)
,	O
FileName	*(char)
)	O
;	O
}	O
int	O
GetPrivateProfileInt	(*(char),*(char),int,*(char))->(int)
(	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
int	O
Default	*(char)
,	O
const	O
char	O
*	O
File	*(char)
)	O
{	O
char	O
IntBuf	array(char)
[	O
BUF_TINY	int
]	O
;	O
char	O
buf	*(char)
[	O
BUF_TINY	int
]	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%d"	*(char)
,	O
Default	*(char)
)	O
;	O
GetPrivateProfileString	(*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
AppName	*(char)
,	O
KeyName	*(char)
,	O
buf	*(char)
,	O
IntBuf	array(char)
,	O
BUF_TINY	int
,	O
File	*(char)
)	O
;	O
if	O
(	O
!	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
IntBuf	array(char)
,	O
"true"	*(char)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
IntBuf	array(char)
,	O
"yes"	*(char)
)	O
)	O
return	O
1	int
;	O
return	O
(	O
int	O
)	O
atol	(*(char))->(long)
(	O
IntBuf	array(char)
)	O
;	O
}	O
int	O
WritePrivateProfileString	(*(char),*(char),*(char),*(char))->(int)
(	O
const	O
char	O
*	O
AppName	*(char)
,	O
const	O
char	O
*	O
KeyName	*(char)
,	O
const	O
char	O
*	O
String	*(char)
,	O
const	O
char	O
*	O
FileName	*(char)
)	O
{	O
return	O
GetSetProfile	(int,*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
1	int
,	O
AppName	*(char)
,	O
KeyName	*(char)
,	O
String	*(char)
,	O
NULL	O
,	O
0	int
,	O
FileName	*(char)
)	O
;	O
}	O
static	O
void	O
dump_keys	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
FILE	struct
*	O
profile	*(char)
,	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
p	*(void)
)	O
{	O
char	O
*	O
t	long
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
dump_keys	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
profile	*(char)
,	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
t	long
=	O
str_untranslate_newline_dup	(*(char))->(*(char))
(	O
p	*(void)
->	O
Value	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
profile	*(char)
,	O
"%s=%s\n"	*(char)
,	O
p	*(void)
->	O
KeyName	*(char)
,	O
t	long
)	O
;	O
g_free	(*(void))->(void)
(	O
t	long
)	O
;	O
}	O
static	O
void	O
dump_sections	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
FILE	struct
*	O
profile	*(char)
,	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
dump_sections	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
profile	*(char)
,	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
if	O
(	O
p	*(void)
->	O
AppName	*(char)
[	O
0	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
profile	*(char)
,	O
"\n[%s]\n"	*(char)
,	O
p	*(void)
->	O
AppName	*(char)
)	O
;	O
dump_keys	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
profile	*(char)
,	O
p	*(void)
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
}	O
}	O
static	O
void	O
dump_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
)	O
{	O
FILE	struct
*	O
profile	*(char)
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
dump_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
if	O
(	O
p	*(void)
->	O
FileName	*(char)
[	O
0	int
]	O
!=	O
(	O
char	O
)	O
0	int
)	O
if	O
(	O
(	O
profile	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(void)
->	O
FileName	*(char)
,	O
"w"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
dump_sections	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
profile	*(char)
,	O
p	*(void)
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
profile	*(char)
)	O
;	O
}	O
}	O
void	O
sync_profiles	()->(void)
(	O
void	O
)	O
{	O
dump_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
}	O
static	O
void	O
free_keys	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
free_keys	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
KeyName	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
Value	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
static	O
void	O
free_sections	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
free_sections	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
free_keys	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
AppName	*(char)
)	O
;	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
=	O
0	int
;	O
p	*(void)
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
static	O
void	O
free_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
)	O
{	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
free_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
;	O
free_sections	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
FileName	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
void	O
free_profile_name	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
;	O
for	O
(	O
p	*(void)
=	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
p	*(void)
->	O
FileName	*(char)
)	O
==	O
0	int
)	O
{	O
free_sections	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
p	*(void)
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
p	*(void)
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
0	int
;	O
p	*(void)
->	O
FileName	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
return	O
;	O
}	O
}	O
}	O
void	O
free_profiles	()->(void)
(	O
void	O
)	O
{	O
free_profile	(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
;	O
}	O
void	O
*	O
profile_init_iterator	(*(char),*(char))->(*(void))
(	O
const	O
char	O
*	O
appname	*(char)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
find_loaded	(*(char),*(*(struct(*(char),*(struct`),*(struct`)))))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
file	*(char)
,	O
&	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
)	O
;	O
if	O
(	O
!	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
)	O
{	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
g_new	O
(	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
,	O
1	int
)	O
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
link	(*(char),*(char))->(int)
=	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
FileName	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
file	*(char)
)	O
;	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
load	(*(char))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
file	*(char)
)	O
;	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
=	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
Current	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
->	O
Section	*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
}	O
for	O
(	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
,	O
appname	*(char)
)	O
)	O
continue	O
;	O
return	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
Keys	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
}	O
return	O
0	int
;	O
}	O
void	O
*	O
profile_iterator_next	(*(void),*(*(char)),*(*(char)))->(*(void))
(	O
void	O
*	O
s	*(char)
,	O
char	O
*	O
*	O
key	*(void)
,	O
char	O
*	O
*	O
value	*(void)
)	O
{	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
keys	*(struct(*(char),int))
=	O
(	O
TKeys	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))))
*	O
)	O
s	*(char)
;	O
if	O
(	O
keys	*(struct(*(char),int))
)	O
{	O
*	O
key	*(void)
=	O
keys	*(struct(*(char),int))
->	O
KeyName	*(char)
;	O
*	O
value	*(void)
=	O
keys	*(struct(*(char),int))
->	O
Value	*(char)
;	O
keys	*(struct(*(char),int))
=	O
keys	*(struct(*(char),int))
->	O
link	(*(char),*(char))->(int)
;	O
}	O
return	O
keys	*(struct(*(char),int))
;	O
}	O
void	O
profile_clean_section	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
appname	*(char)
,	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
if	O
(	O
!	O
find_loaded	(*(char),*(*(struct(*(char),*(struct`),*(struct`)))))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
file	*(char)
,	O
&	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: profile_clean_section called before init\n"	*(char)
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
,	O
appname	*(char)
)	O
)	O
continue	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
int	O
profile_has_section	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
section_name	*(char)
,	O
const	O
char	O
*	O
profile	*(char)
)	O
{	O
TSecHeader	struct(*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`))))),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
if	O
(	O
!	O
find_loaded	(*(char),*(*(struct(*(char),*(struct`),*(struct`)))))->(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
profile	*(char)
,	O
&	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
)	O
)	O
{	O
return	O
0	int
;	O
}	O
for	O
(	O
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
section	*(*(struct(*(char),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
->	O
AppName	*(char)
,	O
section_name	*(char)
)	O
)	O
continue	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
profile_forget_profile	(*(char))->(void)
(	O
const	O
char	O
*	O
file	*(char)
)	O
{	O
TProfile	struct(*(char),*(struct(*(char),*(struct(*(char),*(char),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))),*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`))))))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
Base	*(struct(*(char),*(struct(*(char),*(struct`),*(struct`))),*(struct(*(char),*(struct`),*(struct`)))))
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
link	(*(char),*(char))->(int)
)	O
{	O
if	O
(	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
file	*(char)
,	O
p	*(void)
->	O
FileName	*(char)
)	O
)	O
continue	O
;	O
p	*(void)
->	O
FileName	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
