int	O
dfa_verbose	int
=	O
0	int
;	O
static	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
aux_dfa	O
[	O
DFA_BINS	O
]	O
;	O
static	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
aux_temp	O
;	O
static	O
int	O
dfa_was_initialized	O
=	O
0	int
;	O
static	O
int	O
aux_count	O
=	O
0	int
;	O
static	O
const	O
char	O
att2val	O
[	O
8	int
]	O
=	O
{	O
'.'	O
,	O
'X'	O
,	O
'O'	O
,	O
'x'	O
,	O
'o'	O
,	O
','	O
,	O
'a'	O
,	O
'!'	O
}	O
;	O
static	O
void	O
clean_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
;	O
static	O
void	O
resize_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
int	O
max_states	int
,	O
int	O
max_indexes	int
)	O
;	O
static	O
void	O
create_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
const	O
char	O
*	O
str	int
,	O
int	O
att_val	O
)	O
;	O
static	O
void	O
do_sync_product	O
(	O
int	O
l	O
,	O
int	O
r	O
)	O
;	O
static	O
void	O
sync_product	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pout	O
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pleft	O
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pright	O
)	O
;	O
static	O
void	O
dfa_prepare_rotation_data	O
(	O
void	O
)	O
;	O
static	O
int	O
member_att	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
int	O
att	char
,	O
int	O
val	long
)	O
{	O
while	O
(	O
att	char
!=	O
0	int
)	O
{	O
if	O
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
val	long
==	O
val	long
)	O
return	O
1	int
;	O
att	char
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
union_att	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa1	O
,	O
int	O
att1	O
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa2	O
,	O
int	O
att2	O
)	O
{	O
int	O
att	char
;	O
int	O
att_aux	O
;	O
att	char
=	O
0	int
;	O
while	O
(	O
att1	O
!=	O
0	int
)	O
{	O
pdfa	*(struct)
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	*(struct)
->	O
last_index	int
>=	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
resize_dfa	O
(	O
pdfa	*(struct)
,	O
pdfa	*(struct)
->	O
max_states	int
,	O
pdfa	*(struct)
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	O
)	O
;	O
att_aux	O
=	O
pdfa	*(struct)
->	O
last_index	int
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att_aux	O
]	O
.	O
val	long
=	O
pdfa1	O
->	O
indexes	*(struct(short,short))
[	O
att1	O
]	O
.	O
val	long
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att_aux	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
att	char
;	O
att	char
=	O
att_aux	O
;	O
att1	O
=	O
pdfa1	O
->	O
indexes	*(struct(short,short))
[	O
att1	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
while	O
(	O
att2	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
member_att	O
(	O
pdfa	*(struct)
,	O
att	char
,	O
pdfa2	O
->	O
indexes	*(struct(short,short))
[	O
att2	O
]	O
.	O
val	long
)	O
)	O
{	O
pdfa	*(struct)
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	*(struct)
->	O
last_index	int
>=	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
resize_dfa	O
(	O
pdfa	*(struct)
,	O
pdfa	*(struct)
->	O
max_states	int
,	O
pdfa	*(struct)
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	O
)	O
;	O
att_aux	O
=	O
pdfa	*(struct)
->	O
last_index	int
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att_aux	O
]	O
.	O
val	long
=	O
pdfa2	O
->	O
indexes	*(struct(short,short))
[	O
att2	O
]	O
.	O
val	long
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att_aux	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
att	char
;	O
att	char
=	O
att_aux	O
;	O
}	O
att2	O
=	O
pdfa2	O
->	O
indexes	*(struct(short,short))
[	O
att2	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
return	O
att	char
;	O
}	O
static	O
void	O
compactify_att	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
k	int
;	O
int	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
0	int
;	O
int	O
save_last	O
=	O
pdfa	*(struct)
->	O
last_index	int
;	O
int	O
*	O
map	O
;	O
int	O
*	O
search_first	O
;	O
int	O
*	O
search_next	O
;	O
int	O
size	int
=	O
(	O
save_last	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
;	O
map	O
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
map	O
[	O
0	int
]	O
=	O
0	int
;	O
search_first	O
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
search_first	O
,	O
0	int
,	O
size	int
)	O
;	O
search_next	O
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
search_next	O
,	O
0	int
,	O
size	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
save_last	O
;	O
k	int
++	O
)	O
{	O
int	O
i	int
=	O
search_first	O
[	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
val	long
]	O
;	O
if	O
(	O
i	int
)	O
{	O
while	O
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
!=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
if	O
(	O
!	O
search_next	O
[	O
i	int
]	O
)	O
{	O
search_next	O
[	O
i	int
]	O
=	O
++	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
i	int
=	O
0	int
;	O
break	O
;	O
}	O
i	int
=	O
search_next	O
[	O
i	int
]	O
;	O
}	O
}	O
else	O
search_first	O
[	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
val	long
]	O
=	O
++	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
if	O
(	O
i	int
)	O
map	O
[	O
k	int
]	O
=	O
i	int
;	O
else	O
{	O
map	O
[	O
k	int
]	O
=	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
search_first	O
)	O
;	O
free	(*(void))->(void)
(	O
search_next	O
)	O
;	O
if	O
(	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
<	O
save_last	O
)	O
{	O
pdfa	*(struct)
->	O
last_index	int
=	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pdfa	*(struct)
->	O
last_index	int
;	O
k	int
++	O
)	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
map	O
[	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pdfa	*(struct)
->	O
last_state	int
;	O
k	int
++	O
)	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
k	int
]	O
.	O
att	char
=	O
map	O
[	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
k	int
]	O
.	O
att	char
]	O
;	O
if	O
(	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"compactified: %d attributes left of %d\n"	*(char)
,	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
save_last	O
)	O
;	O
compactify_att	O
(	O
pdfa	*(struct)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
map	O
)	O
;	O
}	O
int	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
states_size	O
,	O
indexes_size	O
;	O
states_size	O
=	O
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
state_rt_t	struct(array(short),short)
)	O
;	O
indexes_size	O
=	O
(	O
pdfa	*(struct)
->	O
last_index	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
attrib_rt_t	struct(short,short)
)	O
;	O
return	O
(	O
states_size	O
+	O
indexes_size	O
+	O
sizeof	O
(	O
dfa_rt_t	struct(array(char),*(struct(array(short),short)),*(struct(short,short)))
)	O
)	O
/	O
1024	int
;	O
}	O
static	O
void	O
resize_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
int	O
max_states	int
,	O
int	O
max_indexes	int
)	O
{	O
state_t	struct(int,array(int))
*	O
pBuf	O
;	O
attrib_t	struct(int,int)
*	O
pBuf2	O
;	O
int	O
i	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Resizing dfa %s\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
)	O
;	O
assert	O
(	O
pdfa	*(struct)
->	O
last_state	int
<=	O
pdfa	*(struct)
->	O
max_states	int
)	O
;	O
assert	O
(	O
pdfa	*(struct)
->	O
last_index	int
<=	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
;	O
pBuf	O
=	O
realloc	(*(void),long)->(*(void))
(	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
,	O
max_states	int
*	O
sizeof	O
(	O
*	O
pBuf	O
)	O
)	O
;	O
pBuf2	O
=	O
realloc	(*(void),long)->(*(void))
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
,	O
max_indexes	int
*	O
sizeof	O
(	O
*	O
pBuf2	O
)	O
)	O
;	O
if	O
(	O
pBuf	O
==	O
NULL	O
||	O
pBuf2	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No memory left for dfa: %s"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
pdfa	*(struct)
->	O
max_states	int
;	O
i	int
<	O
max_states	int
;	O
i	int
++	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
pBuf	O
+	O
i	int
,	O
0	int
,	O
sizeof	O
(	O
state_t	struct(int,array(int))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
pdfa	*(struct)
->	O
max_indexes	int
;	O
i	int
<	O
max_indexes	int
;	O
i	int
++	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
pBuf2	O
+	O
i	int
,	O
0	int
,	O
sizeof	O
(	O
attrib_t	struct(int,int)
)	O
)	O
;	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
=	O
pBuf	O
;	O
pdfa	*(struct)
->	O
max_states	int
=	O
max_states	int
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
=	O
pBuf2	O
;	O
pdfa	*(struct)
->	O
max_indexes	int
=	O
max_indexes	int
;	O
}	O
static	O
const	O
char	O
*	O
line	int
=	O
"----------------------------------------------------\n"	*(char)
;	O
void	O
dump_dfa	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
i	int
;	O
int	O
att	char
,	O
k	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" name : %s\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" Nb states :  %7d, max= %d\n"	*(char)
,	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
,	O
pdfa	*(struct)
->	O
max_states	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" Nb Indexes : %7d, max= %d\n"	*(char)
,	O
pdfa	*(struct)
->	O
last_index	int
,	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" memory needed : %d Mb\n"	*(char)
,	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
pdfa	*(struct)
)	O
/	O
1024	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	int
)	O
;	O
if	O
(	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
pdfa	*(struct)
)	O
>	O
10000	int
)	O
return	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" state  |   .    |   O    |   X    |   #    |  att \n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
!=	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
*	O
pnext	O
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %6d |"	*(char)
,	O
i	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %6d | %6d | %6d |"	*(char)
,	O
pnext	O
[	O
0	int
]	O
,	O
pnext	O
[	O
1	int
]	O
,	O
pnext	O
[	O
2	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %6d |"	*(char)
,	O
pnext	O
[	O
OUT_BOARD	O
]	O
)	O
;	O
att	char
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
att	char
;	O
k	int
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %5d:"	*(char)
,	O
att	char
)	O
;	O
while	O
(	O
att	char
!=	O
0	int
&&	O
k	int
<	O
10	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %4d"	*(char)
,	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
val	long
)	O
;	O
att	char
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
k	int
++	O
;	O
}	O
if	O
(	O
att	char
!=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" ..."	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
clean_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
,	O
0	int
,	O
pdfa	*(struct)
->	O
max_states	int
*	O
sizeof	O
(	O
state_t	struct(int,array(int))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
,	O
0	int
,	O
pdfa	*(struct)
->	O
max_indexes	int
*	O
sizeof	O
(	O
attrib_t	struct(int,int)
)	O
)	O
;	O
pdfa	*(struct)
->	O
last_state	int
=	O
1	int
;	O
pdfa	*(struct)
->	O
last_index	int
=	O
0	int
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
0	int
]	O
.	O
val	long
=	O
-	O
1	int
;	O
}	O
void	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
const	O
char	O
*	O
name	short
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
)	O
;	O
resize_dfa	O
(	O
pdfa	*(struct)
,	O
DFA_INIT_SIZE	O
,	O
DFA_INIT_SIZE	O
)	O
;	O
clean_dfa	O
(	O
pdfa	*(struct)
)	O
;	O
if	O
(	O
name	short
!=	O
NULL	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
pdfa	*(struct)
->	O
name	short
,	O
name	short
)	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
pdfa	*(struct)
->	O
name	short
,	O
"noname "	*(char)
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dfa %s is born :)\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
)	O
;	O
}	O
void	O
kill_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
free	(*(void))->(void)
(	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
)	O
;	O
free	(*(void))->(void)
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dfa %s is dead :(\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
)	O
)	O
;	O
}	O
void	O
copy_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
)	O
{	O
assert	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
!=	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
)	O
;	O
if	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_states	int
<	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_state	int
)	O
resize_dfa	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
,	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_states	int
,	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_indexes	int
)	O
;	O
if	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_indexes	int
<	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_index	int
)	O
resize_dfa	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
,	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_states	int
,	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
max_indexes	int
)	O
;	O
clean_dfa	O
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
states	*(struct(array(short),short))
,	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
states	*(struct(array(short),short))
,	O
sizeof	O
(	O
state_t	struct(int,array(int))
)	O
*	O
(	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_state	int
+	O
1	int
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
indexes	*(struct(short,short))
,	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
indexes	*(struct(short,short))
,	O
sizeof	O
(	O
attrib_t	struct(int,int)
)	O
*	O
(	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_index	int
+	O
1	int
)	O
)	O
;	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_state	int
=	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_state	int
;	O
p_to	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_index	int
=	O
p_from	*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int))
->	O
last_index	int
;	O
}	O
void	O
print_c_dfa	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
FILE	struct
*	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
name	short
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
sizeof	O
(	O
unsigned	O
short	O
)	O
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#error shorts too short"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error: shorts are expected to be at least 2 bytes long.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
assert	O
(	O
dfa_minmax_delta	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),int,int)->(int)
(	O
pdfa	*(struct)
,	O
-	O
1	int
,	O
1	int
)	O
>	O
-	O
32768	int
)	O
;	O
if	O
(	O
dfa_minmax_delta	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),int,int)->(int)
(	O
pdfa	*(struct)
,	O
-	O
1	int
,	O
0	int
)	O
>	O
32768	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#error too many states"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error: The dfa states are too disperse. Can't fit delta into a short.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
if	O
(	O
pdfa	*(struct)
->	O
last_index	int
+	O
1	int
>	O
65535	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#error too many states"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error: Too many index entries. Can't fit delta into a short.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n#include \"dfa-mkpat.h\"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static const state_rt_t state_%s[%d] = {\n"	*(char)
,	O
name	short
,	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{{"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
int	O
n	int
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
;	O
assert	O
(	O
(	O
n	int
==	O
0	int
)	O
||	O
(	O
abs	(int)->(int)
(	O
n	int
-	O
i	int
)	O
<	O
32768	int
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
n	int
?	O
n	int
-	O
i	int
:	O
0	int
)	O
;	O
if	O
(	O
j	int
!=	O
3	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
","	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"}, %d},%s"	*(char)
,	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
att	char
,	O
(	O
(	O
i	int
+	O
1	int
)	O
%	O
3	int
?	O
"\t"	*(char)
:	O
"\n"	*(char)
)	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"};\n\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static const attrib_rt_t idx_%s[%d] = {\n"	*(char)
,	O
name	short
,	O
pdfa	*(struct)
->	O
last_index	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
pdfa	*(struct)
->	O
last_index	int
+	O
1	int
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{%d,%d},%s"	*(char)
,	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
i	int
]	O
.	O
val	long
,	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
(	O
(	O
i	int
+	O
1	int
)	O
%	O
4	int
?	O
"\t"	*(char)
:	O
"\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"};\n\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"static dfa_rt_t dfa_%s = {\n"	*(char)
,	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" \"%s\",\n"	*(char)
,	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"state_%s,\n"	*(char)
,	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"idx_%s"	*(char)
,	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
of	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"};\n"	*(char)
)	O
;	O
}	O
static	O
void	O
create_dfa	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
const	O
char	O
*	O
str	int
,	O
int	O
att_val	O
)	O
{	O
int	O
new_state	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"linear dfa in %s with string: %s\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
,	O
str	int
)	O
;	O
assert	O
(	O
str	int
!=	O
NULL	O
)	O
;	O
assert	O
(	O
pdfa	*(struct)
->	O
max_states	int
>	O
1	int
)	O
;	O
assert	O
(	O
pdfa	*(struct)
->	O
max_indexes	int
>	O
1	int
)	O
;	O
clean_dfa	O
(	O
pdfa	*(struct)
)	O
;	O
new_state	O
=	O
1	int
;	O
for	O
(	O
;	O
*	O
str	int
!=	O
'\0'	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"$#+-|OoXx.?,!a*"	*(char)
,	O
*	O
str	int
)	O
;	O
str	int
++	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"$?.ox,a!*"	*(char)
,	O
*	O
str	int
)	O
)	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
0	int
]	O
=	O
new_state	O
+	O
1	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"$?Oo"	*(char)
,	O
*	O
str	int
)	O
)	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
1	int
]	O
=	O
new_state	O
+	O
1	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"$?Xx"	*(char)
,	O
*	O
str	int
)	O
)	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
2	int
]	O
=	O
new_state	O
+	O
1	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"$#+-|"	*(char)
,	O
*	O
str	int
)	O
)	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
OUT_BOARD	O
]	O
=	O
new_state	O
+	O
1	int
;	O
new_state	O
++	O
;	O
if	O
(	O
new_state	O
>=	O
pdfa	*(struct)
->	O
max_states	int
)	O
resize_dfa	O
(	O
pdfa	*(struct)
,	O
pdfa	*(struct)
->	O
max_states	int
+	O
DFA_RESIZE_STEP	O
,	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
pdfa	*(struct)
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	*(struct)
->	O
last_index	int
>=	O
pdfa	*(struct)
->	O
max_indexes	int
)	O
resize_dfa	O
(	O
pdfa	*(struct)
,	O
pdfa	*(struct)
->	O
max_states	int
,	O
pdfa	*(struct)
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
(	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
pdfa	*(struct)
->	O
last_index	int
]	O
)	O
,	O
0	int
,	O
sizeof	O
(	O
attrib_t	struct(int,int)
)	O
)	O
;	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
att	char
=	O
pdfa	*(struct)
->	O
last_index	int
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
att	char
]	O
.	O
val	long
=	O
att_val	O
;	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
new_state	O
]	O
.	O
att	char
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
0	int
;	O
pdfa	*(struct)
->	O
last_state	int
=	O
new_state	O
;	O
}	O
typedef	O
struct	O
entry	O
{	O
int	O
l	O
,	O
r	O
;	O
int	O
val	long
;	O
struct	O
entry	O
*	O
pnext	O
;	O
}	O
entry_t	O
;	O
typedef	O
struct	O
test_array	O
{	O
entry_t	O
*	O
hash	O
[	O
MAX_HASH_VALUE	O
]	O
;	O
}	O
test_array_t	O
;	O
static	O
void	O
new_test_array	O
(	O
test_array_t	O
*	O
pta	O
)	O
{	O
int	O
h	O
;	O
for	O
(	O
h	O
=	O
0	int
;	O
h	O
!=	O
MAX_HASH_VALUE	O
;	O
h	O
++	O
)	O
pta	O
->	O
hash	O
[	O
h	O
]	O
=	O
NULL	O
;	O
}	O
static	O
int	O
get_from_entry_list	O
(	O
entry_t	O
*	O
plist	O
,	O
int	O
l	O
,	O
int	O
r	O
)	O
{	O
int	O
val	long
=	O
0	int
;	O
while	O
(	O
plist	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
plist	O
->	O
l	O
==	O
l	O
&&	O
plist	O
->	O
r	O
==	O
r	O
)	O
val	long
=	O
plist	O
->	O
val	long
;	O
plist	O
=	O
plist	O
->	O
pnext	O
;	O
}	O
return	O
val	long
;	O
}	O
static	O
int	O
get_from_test_array	O
(	O
test_array_t	O
*	O
pta	O
,	O
int	O
l	O
,	O
int	O
r	O
)	O
{	O
return	O
get_from_entry_list	O
(	O
pta	O
->	O
hash	O
[	O
(	O
l	O
+	O
r	O
)	O
%	O
MAX_HASH_VALUE	O
]	O
,	O
l	O
,	O
r	O
)	O
;	O
}	O
static	O
void	O
add_to_entry_list	O
(	O
entry_t	O
*	O
*	O
pplist	O
,	O
int	O
l	O
,	O
int	O
r	O
,	O
int	O
val	long
)	O
{	O
entry_t	O
*	O
new_entry	O
;	O
assert	O
(	O
val	long
>	O
0	int
)	O
;	O
assert	O
(	O
!	O
get_from_entry_list	O
(	O
*	O
pplist	O
,	O
l	O
,	O
r	O
)	O
)	O
;	O
new_entry	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
new_entry	O
)	O
)	O
;	O
if	O
(	O
new_entry	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No memory left for new entry\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
new_entry	O
->	O
pnext	O
=	O
*	O
pplist	O
;	O
new_entry	O
->	O
l	O
=	O
l	O
;	O
new_entry	O
->	O
r	O
=	O
r	O
;	O
new_entry	O
->	O
val	long
=	O
val	long
;	O
*	O
pplist	O
=	O
new_entry	O
;	O
}	O
static	O
void	O
add_to_test_array	O
(	O
test_array_t	O
*	O
pta	O
,	O
int	O
l	O
,	O
int	O
r	O
,	O
int	O
val	long
)	O
{	O
add_to_entry_list	O
(	O
&	O
(	O
pta	O
->	O
hash	O
[	O
(	O
l	O
+	O
r	O
)	O
%	O
MAX_HASH_VALUE	O
]	O
)	O
,	O
l	O
,	O
r	O
,	O
val	long
)	O
;	O
}	O
static	O
void	O
free_entry_list	O
(	O
entry_t	O
*	O
plist	O
)	O
{	O
entry_t	O
*	O
pentry	O
;	O
while	O
(	O
plist	O
!=	O
NULL	O
)	O
{	O
pentry	O
=	O
plist	O
;	O
plist	O
=	O
plist	O
->	O
pnext	O
;	O
free	(*(void))->(void)
(	O
pentry	O
)	O
;	O
}	O
}	O
static	O
void	O
free_test_array	O
(	O
test_array_t	O
*	O
pta	O
)	O
{	O
int	O
h	O
;	O
for	O
(	O
h	O
=	O
0	int
;	O
h	O
!=	O
MAX_HASH_VALUE	O
;	O
h	O
++	O
)	O
{	O
free_entry_list	O
(	O
pta	O
->	O
hash	O
[	O
h	O
]	O
)	O
;	O
pta	O
->	O
hash	O
[	O
h	O
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
gpout	O
,	O
*	O
gpleft	O
,	O
*	O
gpright	O
;	O
static	O
test_array_t	O
gtest	O
;	O
static	O
void	O
do_sync_product	O
(	O
int	O
l	O
,	O
int	O
r	O
)	O
{	O
int	O
c	char
;	O
int	O
nextl	O
,	O
nextr	O
;	O
int	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
=	O
gpout	O
->	O
last_state	int
;	O
gpout	O
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
att	char
=	O
union_att	O
(	O
gpout	O
,	O
gpleft	O
,	O
gpleft	O
->	O
states	*(struct(array(short),short))
[	O
l	O
]	O
.	O
att	char
,	O
gpright	O
,	O
gpright	O
->	O
states	*(struct(array(short),short))
[	O
r	O
]	O
.	O
att	char
)	O
;	O
for	O
(	O
c	char
=	O
0	int
;	O
c	char
!=	O
4	int
;	O
c	char
++	O
)	O
{	O
nextl	O
=	O
gpleft	O
->	O
states	*(struct(array(short),short))
[	O
l	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
c	char
]	O
;	O
nextr	O
=	O
gpright	O
->	O
states	*(struct(array(short),short))
[	O
r	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
c	char
]	O
;	O
assert	O
(	O
nextl	O
<	O
gpleft	O
->	O
last_state	int
+	O
1	int
)	O
;	O
assert	O
(	O
nextr	O
<	O
gpright	O
->	O
last_state	int
+	O
1	int
)	O
;	O
if	O
(	O
nextl	O
!=	O
0	int
||	O
nextr	O
!=	O
0	int
)	O
{	O
if	O
(	O
get_from_test_array	O
(	O
&	O
gtest	O
,	O
nextl	O
,	O
nextr	O
)	O
==	O
0	int
)	O
{	O
gpout	O
->	O
last_state	int
++	O
;	O
if	O
(	O
gpout	O
->	O
last_state	int
>=	O
gpout	O
->	O
max_states	int
)	O
resize_dfa	O
(	O
gpout	O
,	O
gpout	O
->	O
max_states	int
+	O
DFA_RESIZE_STEP	O
,	O
gpout	O
->	O
max_indexes	int
)	O
;	O
add_to_test_array	O
(	O
&	O
gtest	O
,	O
nextl	O
,	O
nextr	O
,	O
gpout	O
->	O
last_state	int
)	O
;	O
gpout	O
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
c	char
]	O
=	O
gpout	O
->	O
last_state	int
;	O
do_sync_product	O
(	O
nextl	O
,	O
nextr	O
)	O
;	O
}	O
else	O
{	O
gpout	O
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
c	char
]	O
=	O
get_from_test_array	O
(	O
&	O
gtest	O
,	O
nextl	O
,	O
nextr	O
)	O
;	O
}	O
}	O
else	O
{	O
gpout	O
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
c	char
]	O
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
sync_product	O
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pout	O
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pleft	O
,	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pright	O
)	O
{	O
pout	O
->	O
last_index	int
=	O
0	int
;	O
if	O
(	O
dfa_verbose	int
>	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Product between %s and %s\n"	*(char)
,	O
pleft	O
->	O
name	short
,	O
pright	O
->	O
name	short
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"result in %s\n"	*(char)
,	O
pout	O
->	O
name	short
)	O
;	O
}	O
gpout	O
=	O
pout	O
;	O
gpleft	O
=	O
pleft	O
;	O
gpright	O
=	O
pright	O
;	O
new_test_array	O
(	O
&	O
gtest	O
)	O
;	O
add_to_test_array	O
(	O
&	O
gtest	O
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
pout	O
->	O
last_state	int
=	O
1	int
;	O
do_sync_product	O
(	O
1	int
,	O
1	int
)	O
;	O
free_test_array	O
(	O
&	O
gtest	O
)	O
;	O
}	O
void	O
dfa_init	()->(void)
(	O
void	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dfa: init\n"	*(char)
)	O
;	O
dfa_was_initialized	O
++	O
;	O
build_spiral_order	()->(void)
(	O
)	O
;	O
dfa_prepare_rotation_data	O
(	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
DFA_BINS	O
;	O
j	int
++	O
)	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
(	O
&	O
(	O
aux_dfa	O
[	O
j	int
]	O
)	O
,	O
"binAux "	*(char)
)	O
;	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
(	O
&	O
aux_temp	O
,	O
"tempAux "	*(char)
)	O
;	O
}	O
void	O
dfa_end	()->(void)
(	O
void	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dfa: end\n"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
DFA_BINS	O
;	O
j	int
++	O
)	O
kill_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
(	O
aux_dfa	O
[	O
j	int
]	O
)	O
)	O
;	O
kill_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
aux_temp	O
)	O
;	O
dfa_was_initialized	O
--	O
;	O
}	O
int	O
dfa_minmax_delta	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),int,int)->(int)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
int	O
next_index	int
,	O
int	O
isMin	int
)	O
{	O
int	O
ret	O
,	O
i	int
,	O
j	int
;	O
assert	O
(	O
next_index	int
<=	O
3	int
)	O
;	O
if	O
(	O
isMin	int
)	O
ret	O
=	O
99999	int
;	O
else	O
ret	O
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
pdfa	*(struct)
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
next_index	int
||	O
next_index	int
<	O
0	int
)	O
{	O
int	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
;	O
if	O
(	O
!	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
continue	O
;	O
if	O
(	O
isMin	int
)	O
{	O
if	O
(	O
ret	O
>	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
-	O
i	int
)	O
ret	O
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
-	O
i	int
;	O
}	O
else	O
{	O
if	O
(	O
ret	O
<	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
-	O
i	int
)	O
ret	O
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
-	O
i	int
;	O
}	O
}	O
}	O
}	O
return	O
ret	O
;	O
}	O
void	O
dfa_shuffle	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
struct	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
*	O
old_states	O
;	O
int	O
*	O
state_to	O
;	O
int	O
*	O
state_from	O
;	O
int	O
*	O
queue1	O
;	O
int	O
*	O
queue2	O
;	O
int	O
*	O
tempq	O
;	O
int	O
next_new_state	O
;	O
int	O
q1p	O
;	O
int	O
q2p	O
;	O
int	O
i	int
,	O
j	int
;	O
state_to	O
=	O
calloc	(long,long)->(*(void))
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
*	O
state_to	O
)	O
)	O
;	O
state_from	O
=	O
calloc	(long,long)->(*(void))
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
*	O
state_from	O
)	O
)	O
;	O
queue1	O
=	O
malloc	(long)->(*(void))
(	O
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
queue1	O
)	O
)	O
;	O
queue2	O
=	O
malloc	(long)->(*(void))
(	O
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
queue2	O
)	O
)	O
;	O
q1p	O
=	O
1	int
;	O
q2p	O
=	O
0	int
;	O
queue1	O
[	O
0	int
]	O
=	O
1	int
;	O
state_from	O
[	O
0	int
]	O
=	O
state_to	O
[	O
0	int
]	O
=	O
0	int
;	O
state_from	O
[	O
1	int
]	O
=	O
state_to	O
[	O
1	int
]	O
=	O
1	int
;	O
next_new_state	O
=	O
2	int
;	O
while	O
(	O
q1p	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
q1p	O
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
int	O
n	int
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
queue1	O
[	O
i	int
]	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
;	O
while	O
(	O
n	int
&&	O
!	O
state_to	O
[	O
n	int
]	O
)	O
{	O
state_to	O
[	O
n	int
]	O
=	O
next_new_state	O
;	O
state_from	O
[	O
next_new_state	O
]	O
=	O
n	int
;	O
next_new_state	O
++	O
;	O
queue2	O
[	O
q2p	O
++	O
]	O
=	O
n	int
;	O
n	int
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
n	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
0	int
]	O
;	O
}	O
}	O
}	O
tempq	O
=	O
queue1	O
;	O
queue1	O
=	O
queue2	O
;	O
queue2	O
=	O
tempq	O
;	O
q1p	O
=	O
q2p	O
;	O
q2p	O
=	O
0	int
;	O
}	O
old_states	O
=	O
malloc	(long)->(*(void))
(	O
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
old_states	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
pdfa	*(struct)
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
old_states	O
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
;	O
old_states	O
[	O
i	int
]	O
.	O
att	char
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
att	char
;	O
}	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
pdfa	*(struct)
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
assert	O
(	O
state_to	O
[	O
i	int
]	O
>	O
0	int
)	O
;	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
=	O
state_to	O
[	O
old_states	O
[	O
state_from	O
[	O
i	int
]	O
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
j	int
]	O
]	O
;	O
}	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
i	int
]	O
.	O
att	char
=	O
old_states	O
[	O
state_from	O
[	O
i	int
]	O
]	O
.	O
att	char
;	O
}	O
}	O
int	O
dfa_calculate_max_matched_patterns	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
total_max	O
=	O
0	int
;	O
int	O
*	O
state_max	O
=	O
calloc	(long,long)->(*(void))
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
char	O
*	O
queued	O
=	O
calloc	(long,long)->(*(void))
(	O
pdfa	*(struct)
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
int	O
*	O
queue	O
=	O
malloc	(long)->(*(void))
(	O
pdfa	*(struct)
->	O
last_state	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
int	O
queue_start	O
=	O
0	int
;	O
int	O
queue_end	O
=	O
1	int
;	O
queue	O
[	O
0	int
]	O
=	O
1	int
;	O
while	O
(	O
queue_start	O
<	O
queue_end	O
)	O
{	O
int	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
=	O
queue	O
[	O
queue_start	O
++	O
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
att	char
;	O
k	int
;	O
k	int
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
k	int
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
state_max	O
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
++	O
;	O
if	O
(	O
total_max	O
<	O
state_max	O
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
)	O
total_max	O
=	O
state_max	O
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
k	int
]	O
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
queued	O
[	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
)	O
{	O
queue	O
[	O
queue_end	O
++	O
]	O
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
queued	O
[	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
=	O
1	int
;	O
}	O
if	O
(	O
state_max	O
[	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
<	O
state_max	O
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
)	O
state_max	O
[	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
=	O
state_max	O
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
;	O
}	O
}	O
}	O
assert	O
(	O
queue_end	O
==	O
pdfa	*(struct)
->	O
last_state	int
)	O
;	O
free	(*(void))->(void)
(	O
state_max	O
)	O
;	O
free	(*(void))->(void)
(	O
queued	O
)	O
;	O
free	(*(void))->(void)
(	O
queue	O
)	O
;	O
return	O
total_max	O
;	O
}	O
void	O
dfa_finalize	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
)	O
{	O
int	O
j	int
;	O
int	O
next_bin	O
=	O
aux_count	O
;	O
int	O
last_bin	O
=	O
aux_count	O
+	O
DFA_BINS	O
-	O
1	int
;	O
while	O
(	O
next_bin	O
+	O
1	int
!=	O
last_bin	O
)	O
{	O
for	O
(	O
j	int
=	O
aux_count	O
+	O
1	int
;	O
j	int
<=	O
last_bin	O
;	O
j	int
+=	O
2	int
)	O
{	O
if	O
(	O
j	int
+	O
1	int
==	O
next_bin	O
)	O
copy_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
&	O
aux_dfa	O
[	O
next_bin	O
%	O
DFA_BINS	O
]	O
,	O
&	O
aux_dfa	O
[	O
j	int
%	O
DFA_BINS	O
]	O
)	O
;	O
else	O
sync_product	O
(	O
&	O
aux_dfa	O
[	O
next_bin	O
%	O
DFA_BINS	O
]	O
,	O
&	O
aux_dfa	O
[	O
j	int
%	O
DFA_BINS	O
]	O
,	O
&	O
aux_dfa	O
[	O
(	O
j	int
+	O
1	int
)	O
%	O
DFA_BINS	O
]	O
)	O
;	O
next_bin	O
++	O
;	O
}	O
last_bin	O
=	O
next_bin	O
-	O
1	int
;	O
aux_count	O
--	O
;	O
next_bin	O
=	O
aux_count	O
;	O
}	O
copy_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(void)
(	O
pdfa	*(struct)
,	O
&	O
aux_dfa	O
[	O
last_bin	O
%	O
DFA_BINS	O
]	O
)	O
;	O
compactify_att	O
(	O
pdfa	*(struct)
)	O
;	O
}	O
float	O
dfa_add_string	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char),int,int)->(float)
(	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
pdfa	*(struct)
,	O
const	O
char	O
*	O
str	int
,	O
int	O
pattern_index	int
,	O
int	O
ll	int
)	O
{	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
=	O
&	O
(	O
aux_dfa	O
[	O
aux_count	O
%	O
DFA_BINS	O
]	O
)	O
;	O
dfa_t	struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)
*	O
old_dfa	O
=	O
&	O
(	O
aux_dfa	O
[	O
(	O
aux_count	O
+	O
1	int
)	O
%	O
DFA_BINS	O
]	O
)	O
;	O
float	O
ratio	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Adding to dfa %s the string: %s\n"	*(char)
,	O
pdfa	*(struct)
->	O
name	short
,	O
str	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  pat_ind: %d; rotation: %d at bin: %d\n"	*(char)
,	O
pattern_index	int
,	O
ll	int
,	O
aux_count	O
)	O
;	O
}	O
assert	O
(	O
dfa_was_initialized	O
>	O
0	int
)	O
;	O
assert	O
(	O
pdfa	*(struct)
!=	O
NULL	O
)	O
;	O
create_dfa	O
(	O
&	O
aux_temp	O
,	O
str	int
,	O
pattern_index	int
)	O
;	O
sync_product	O
(	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
,	O
old_dfa	O
,	O
&	O
aux_temp	O
)	O
;	O
aux_count	O
++	O
;	O
ratio	O
=	O
1	int
;	O
if	O
(	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
old_dfa	O
)	O
>	O
0	int
)	O
ratio	O
=	O
(	O
float	O
)	O
(	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
new_dfa	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)),*(char))->(void)
)	O
/	O
dfa_size	(*(struct(array(char),*(struct(int,array(int))),int,int,*(struct(int,int)),int,int)))->(int)
(	O
old_dfa	O
)	O
)	O
;	O
return	O
ratio	O
;	O
}	O
static	O
int	O
dfa_rotation_data	O
[	O
DFA_BASE	O
*	O
DFA_BASE	O
]	O
;	O
static	O
void	O
dfa_prepare_rotation_data	O
(	O
void	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DFA_MAX_ORDER	O
;	O
k	int
++	O
)	O
dfa_rotation_data	O
[	O
DFA_POS	O
(	O
0	int
,	O
0	int
)	O
+	O
spiral	array(array(int))
[	O
k	int
]	O
[	O
0	int
]	O
]	O
=	O
k	int
;	O
}	O
void	O
dfa_rotate_string	(*(char),*(char),int)->(void)
(	O
char	O
*	O
rotated_string	O
,	O
const	O
char	O
*	O
string	int
,	O
int	O
transformation	array(array(int))
)	O
{	O
if	O
(	O
transformation	array(array(int))
>	O
0	int
)	O
{	O
int	O
k	int
;	O
int	O
length	O
=	O
strlen	(*(char))->(long)
(	O
string	int
)	O
;	O
int	O
new_length	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
rotated_string	O
,	O
'$'	O
,	O
DFA_MAX_ORDER	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
length	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
string	int
[	O
k	int
]	O
!=	O
'$'	O
)	O
{	O
int	O
string_position	O
=	O
dfa_rotation_data	O
[	O
DFA_POS	O
(	O
0	int
,	O
0	int
)	O
+	O
spiral	array(array(int))
[	O
k	int
]	O
[	O
transformation	array(array(int))
]	O
]	O
;	O
rotated_string	O
[	O
string_position	O
]	O
=	O
string	int
[	O
k	int
]	O
;	O
if	O
(	O
string_position	O
+	O
1	int
>	O
new_length	O
)	O
new_length	O
=	O
string_position	O
+	O
1	int
;	O
}	O
}	O
rotated_string	O
[	O
new_length	O
]	O
=	O
0	int
;	O
}	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
rotated_string	O
,	O
string	int
)	O
;	O
}	O
void	O
pattern_2_string	(*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct(int,int,int)),*(char),int,int)->(void)
(	O
struct	O
pattern	*(struct)
*	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
struct	O
patval_b	struct(int,int,int)
*	O
elements	*(struct(int,int,int))
,	O
char	O
*	O
str	int
,	O
int	O
ci	int
,	O
int	O
cj	int
)	O
{	O
char	O
work_space	O
[	O
DFA_MAX_BOARD	O
*	O
4	int
]	O
[	O
DFA_MAX_BOARD	O
*	O
4	int
]	O
;	O
int	O
m	int
,	O
n	int
;	O
int	O
edges	O
,	O
borders	O
,	O
to_test	O
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
char	O
c	char
;	O
m	int
=	O
DFA_MAX_BOARD	O
*	O
2	int
+	O
ci	int
;	O
n	int
=	O
DFA_MAX_BOARD	O
*	O
2	int
+	O
cj	int
;	O
assert	O
(	O
dfa_was_initialized	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
str	int
,	O
0	int
,	O
DFA_MAX_ORDER	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
work_space	O
,	O
'#'	O
,	O
sizeof	O
(	O
work_space	O
)	O
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"converting pattern into string.\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'$'	O
;	O
for	O
(	O
i	int
=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
mini	int
+	O
m	int
;	O
i	int
!=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
+	O
m	int
+	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
minj	int
+	O
n	int
;	O
j	int
!=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxj	int
+	O
n	int
+	O
1	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'?'	O
;	O
if	O
(	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
&	O
SOUTH_EDGE	O
)	O
{	O
for	O
(	O
i	int
=	O
m	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
+	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
&	O
EAST_EDGE	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
n	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxj	int
+	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
}	O
if	O
(	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
&	O
NORTH_EDGE	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
m	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
mini	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
4	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
&	O
WEST_EDGE	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
m	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
+	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
n	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
minj	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
if	O
(	O
!	O
(	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
&	O
SOUTH_EDGE	O
)	O
)	O
{	O
for	O
(	O
i	int
=	O
m	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
+	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
n	int
+	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
minj	int
;	O
j	int
++	O
)	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
}	O
}	O
if	O
(	O
dfa_verbose	int
>	O
4	int
)	O
{	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
m	int
&&	O
j	int
==	O
n	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"s"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
!=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
c	char
=	O
EXPECTED_VAL	O
(	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
att	char
)	O
;	O
assert	O
(	O
work_space	O
[	O
m	int
+	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
]	O
[	O
n	int
+	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
]	O
==	O
'?'	O
)	O
;	O
work_space	O
[	O
m	int
+	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
]	O
[	O
n	int
+	O
elements	*(struct(int,int,int))
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
]	O
=	O
c	char
;	O
}	O
if	O
(	O
dfa_verbose	int
>	O
3	int
)	O
{	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
m	int
&&	O
j	int
==	O
n	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"s"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
work_space	O
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
to_test	O
=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patlen	int
;	O
edges	O
=	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
edge_constraints	int
;	O
borders	O
=	O
0xF	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
(	O
k	int
!=	O
DFA_MAX_ORDER	O
-	O
1	int
)	O
&&	O
(	O
(	O
borders	O
>	O
0	int
)	O
||	O
edges	O
||	O
to_test	O
>	O
0	int
)	O
;	O
k	int
++	O
)	O
{	O
j	int
=	O
spiral	array(array(int))
[	O
k	int
]	O
[	O
0	int
]	O
%	O
DFA_BASE	O
;	O
if	O
(	O
j	int
>=	O
DFA_MAX_BOARD	O
)	O
j	int
-=	O
DFA_BASE	O
;	O
if	O
(	O
j	int
<=	O
-	O
DFA_MAX_BOARD	O
)	O
j	int
+=	O
DFA_BASE	O
;	O
i	int
=	O
(	O
spiral	array(array(int))
[	O
k	int
]	O
[	O
0	int
]	O
-	O
j	int
)	O
/	O
DFA_BASE	O
;	O
if	O
(	O
i	int
==	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
)	O
borders	O
&=	O
~	O
SOUTH_EDGE	O
;	O
if	O
(	O
i	int
==	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
mini	int
)	O
borders	O
&=	O
~	O
NORTH_EDGE	O
;	O
if	O
(	O
j	int
==	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxj	int
)	O
borders	O
&=	O
~	O
EAST_EDGE	O
;	O
if	O
(	O
j	int
==	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
minj	int
)	O
borders	O
&=	O
~	O
WEST_EDGE	O
;	O
assert	O
(	O
m	int
+	O
i	int
<	O
DFA_MAX_BOARD	O
*	O
3	int
&&	O
m	int
+	O
i	int
<	O
DFA_MAX_BOARD	O
*	O
3	int
)	O
;	O
str	int
[	O
k	int
]	O
=	O
work_space	O
[	O
m	int
+	O
i	int
]	O
[	O
n	int
+	O
j	int
]	O
;	O
assert	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"XOxo.,a!?$#|-+"	*(char)
,	O
str	int
[	O
k	int
]	O
)	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"XOxo.,a!"	*(char)
,	O
str	int
[	O
k	int
]	O
)	O
)	O
to_test	O
--	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"#|-+"	*(char)
,	O
str	int
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
i	int
>	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxi	int
)	O
edges	O
&=	O
~	O
SOUTH_EDGE	O
;	O
if	O
(	O
i	int
<	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
mini	int
)	O
edges	O
&=	O
~	O
NORTH_EDGE	O
;	O
if	O
(	O
j	int
>	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
maxj	int
)	O
edges	O
&=	O
~	O
EAST_EDGE	O
;	O
if	O
(	O
j	int
<	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
minj	int
)	O
edges	O
&=	O
~	O
WEST_EDGE	O
;	O
}	O
}	O
assert	O
(	O
k	int
<	O
DFA_MAX_ORDER	O
)	O
;	O
str	int
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
0	int
&&	O
dfa_verbose	int
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"converted pattern %s into string: %s\n"	*(char)
,	O
pat	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
name	short
,	O
str	int
)	O
;	O
}	O
static	O
dfa_attrib	struct
*	O
dfa_attrib_new	O
(	O
dfa_attrib_array	struct
*	O
array	*(struct(array(long)))
,	O
int	O
string_index	int
)	O
{	O
dfa_attrib	struct
*	O
attribute	O
;	O
if	O
(	O
array	*(struct(array(long)))
->	O
allocated	int
==	O
DFA_ATTRIB_BLOCK_SIZE	int
)	O
{	O
dfa_attrib_block	struct
*	O
new_block	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
new_block	O
)	O
)	O
;	O
assert	O
(	O
new_block	O
)	O
;	O
new_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
new_block	O
;	O
array	*(struct(array(long)))
->	O
allocated	int
=	O
0	int
;	O
}	O
attribute	O
=	O
&	O
(	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
->	O
attrib	struct(int,int)
[	O
array	*(struct(array(long)))
->	O
allocated	int
++	O
]	O
)	O
;	O
attribute	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
NULL	O
;	O
attribute	O
->	O
string_index	int
=	O
string_index	int
;	O
return	O
attribute	O
;	O
}	O
static	O
void	O
dfa_attrib_array_reset	O
(	O
dfa_attrib_array	struct
*	O
array	*(struct(array(long)))
)	O
{	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
array	*(struct(array(long)))
->	O
allocated	int
=	O
DFA_ATTRIB_BLOCK_SIZE	int
;	O
}	O
static	O
void	O
dfa_attrib_array_partially_clear	O
(	O
dfa_attrib_block	struct
*	O
cutoff_point	O
)	O
{	O
if	O
(	O
cutoff_point	O
)	O
{	O
dfa_attrib_block	struct
*	O
block	O
=	O
cutoff_point	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
while	O
(	O
block	O
)	O
{	O
dfa_attrib_block	struct
*	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
free	(*(void))->(void)
(	O
block	O
)	O
;	O
block	O
=	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
}	O
cutoff_point	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
dfa_attrib_array_clear	O
(	O
dfa_attrib_array	struct
*	O
array	*(struct(array(long)))
)	O
{	O
if	O
(	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
)	O
{	O
dfa_attrib_array_partially_clear	O
(	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
)	O
;	O
free	(*(void))->(void)
(	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
)	O
;	O
array	*(struct(array(long)))
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
}	O
array	*(struct(array(long)))
->	O
allocated	int
=	O
DFA_ATTRIB_BLOCK_SIZE	int
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_node_new	O
(	O
dfa_graph	struct
*	O
graph	O
)	O
{	O
dfa_node	struct
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
graph	O
->	O
allocated	int
==	O
DFA_NODE_BLOCK_SIZE	O
)	O
{	O
dfa_node_block	struct
*	O
new_block	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
new_block	O
)	O
)	O
;	O
assert	O
(	O
new_block	O
)	O
;	O
new_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
new_block	O
;	O
graph	O
->	O
allocated	int
=	O
0	int
;	O
}	O
graph	O
->	O
num_nodes	O
++	O
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
(	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
[	O
graph	O
->	O
allocated	int
++	O
]	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
0	int
,	O
sizeof	O
(	O
dfa_node	struct
)	O
)	O
;	O
return	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
dfa_hash_entry	O
*	O
dfa_hash_table	O
[	O
DFA_HASH_TABLE_SIZE	O
]	O
;	O
static	O
dfa_hash_block	O
*	O
dfa_hash_last_block	O
=	O
NULL	O
;	O
static	O
int	O
dfa_hash_allocated	O
;	O
static	O
dfa_hash_entry	O
*	O
dfa_hash_entry_new	O
(	O
void	O
)	O
{	O
if	O
(	O
dfa_hash_allocated	O
==	O
DFA_HASH_BLOCK_SIZE	O
)	O
{	O
dfa_hash_block	O
*	O
new_block	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
new_block	O
)	O
)	O
;	O
assert	O
(	O
new_block	O
)	O
;	O
new_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
dfa_hash_last_block	O
;	O
dfa_hash_last_block	O
=	O
new_block	O
;	O
dfa_hash_allocated	O
=	O
0	int
;	O
}	O
return	O
&	O
(	O
dfa_hash_last_block	O
->	O
entry	O
[	O
dfa_hash_allocated	O
++	O
]	O
)	O
;	O
}	O
static	O
void	O
dfa_hash_clear	O
(	O
void	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
dfa_hash_table	O
,	O
0	int
,	O
DFA_HASH_TABLE_SIZE	O
*	O
sizeof	O
(	O
dfa_hash_entry	O
*	O
)	O
)	O
;	O
if	O
(	O
dfa_hash_last_block	O
)	O
{	O
dfa_hash_block	O
*	O
block	O
=	O
dfa_hash_last_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
while	O
(	O
block	O
)	O
{	O
dfa_hash_block	O
*	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
free	(*(void))->(void)
(	O
block	O
)	O
;	O
block	O
=	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
}	O
dfa_hash_last_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
dfa_hash_allocated	O
=	O
0	int
;	O
}	O
else	O
dfa_hash_allocated	O
=	O
DFA_HASH_BLOCK_SIZE	O
;	O
}	O
static	O
int	O
dfa_hash_value	O
(	O
dfa_attrib	struct
*	O
key	O
)	O
{	O
int	O
hash_value	O
=	O
DFA_HASH_VALUE_1	O
*	O
key	O
->	O
string_index	int
;	O
if	O
(	O
key	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
hash_value	O
+=	O
DFA_HASH_VALUE_2	O
*	O
key	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
->	O
string_index	int
;	O
if	O
(	O
key	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
hash_value	O
+=	O
DFA_HASH_VALUE_3	O
*	O
key	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
->	O
string_index	int
;	O
}	O
return	O
hash_value	O
%	O
DFA_HASH_TABLE_SIZE	O
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_hash_search	O
(	O
dfa_attrib	struct
*	O
key	O
)	O
{	O
int	O
hash_value	O
=	O
dfa_hash_value	O
(	O
key	O
)	O
;	O
dfa_hash_entry	O
*	O
entry	O
;	O
for	O
(	O
entry	O
=	O
dfa_hash_table	O
[	O
hash_value	O
]	O
;	O
entry	O
;	O
entry	O
=	O
entry	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
dfa_attrib	struct
*	O
left	O
=	O
key	O
;	O
dfa_attrib	struct
*	O
right	O
=	O
entry	O
->	O
key	O
;	O
while	O
(	O
left	O
&&	O
right	O
)	O
{	O
if	O
(	O
left	O
->	O
string_index	int
!=	O
right	O
->	O
string_index	int
)	O
break	O
;	O
left	O
=	O
left	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
right	O
=	O
right	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
if	O
(	O
!	O
left	O
&&	O
!	O
right	O
)	O
return	O
entry	O
->	O
value	*(char)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
dfa_hash_add_node	O
(	O
dfa_node	struct
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
int	O
hash_value	O
=	O
dfa_hash_value	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
passing_strings	O
)	O
;	O
dfa_hash_entry	O
*	O
entry	O
;	O
entry	O
=	O
dfa_hash_entry_new	O
(	O
)	O
;	O
entry	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
dfa_hash_table	O
[	O
hash_value	O
]	O
;	O
dfa_hash_table	O
[	O
hash_value	O
]	O
=	O
entry	O
;	O
entry	O
->	O
key	O
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
passing_strings	O
;	O
entry	O
->	O
value	*(char)
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
dfa_node_block	struct
*	O
dfa_iterator_block	O
;	O
static	O
int	O
dfa_iterator_node_num	O
;	O
static	O
dfa_node	struct
*	O
dfa_iterator_reset	O
(	O
dfa_graph	struct
*	O
graph	O
)	O
{	O
assert	O
(	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
)	O
;	O
if	O
(	O
graph	O
->	O
allocated	int
>	O
0	int
)	O
{	O
dfa_iterator_block	O
=	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
dfa_iterator_node_num	O
=	O
graph	O
->	O
allocated	int
-	O
1	int
;	O
}	O
else	O
{	O
dfa_iterator_block	O
=	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
assert	O
(	O
dfa_iterator_block	O
)	O
;	O
dfa_iterator_node_num	O
=	O
DFA_NODE_BLOCK_SIZE	O
-	O
1	int
;	O
}	O
return	O
&	O
(	O
dfa_iterator_block	O
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
[	O
dfa_iterator_node_num	O
]	O
)	O
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_iterate	O
(	O
void	O
)	O
{	O
dfa_iterator_node_num	O
--	O
;	O
if	O
(	O
dfa_iterator_node_num	O
<	O
0	int
)	O
{	O
dfa_iterator_block	O
=	O
dfa_iterator_block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
assert	O
(	O
dfa_iterator_block	O
)	O
;	O
dfa_iterator_node_num	O
=	O
DFA_NODE_BLOCK_SIZE	O
-	O
1	int
;	O
}	O
return	O
&	O
(	O
dfa_iterator_block	O
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
[	O
dfa_iterator_node_num	O
]	O
)	O
;	O
}	O
void	O
dfa_graph_reset	O
(	O
dfa_graph	struct
*	O
graph	O
)	O
{	O
graph	O
->	O
num_nodes	O
=	O
0	int
;	O
graph	O
->	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
graph	O
->	O
allocated	int
=	O
DFA_NODE_BLOCK_SIZE	O
;	O
dfa_attrib_array_reset	O
(	O
&	O
(	O
graph	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
)	O
;	O
}	O
static	O
void	O
dfa_graph_clear	O
(	O
dfa_graph	struct
*	O
graph	O
)	O
{	O
dfa_node_block	struct
*	O
block	O
=	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
graph	O
->	O
num_nodes	O
=	O
0	int
;	O
graph	O
->	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
while	O
(	O
block	O
)	O
{	O
dfa_node_block	struct
*	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
block	O
->	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
free	(*(void))->(void)
(	O
block	O
)	O
;	O
block	O
=	O
previous	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
}	O
graph	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
=	O
NULL	O
;	O
graph	O
->	O
allocated	int
=	O
DFA_NODE_BLOCK_SIZE	O
;	O
dfa_attrib_array_clear	O
(	O
&	O
(	O
graph	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
)	O
;	O
}	O
static	O
void	O
dfa_graph_build_level	O
(	O
dfa_graph	struct
*	O
graph	O
,	O
char	O
*	O
*	O
strings	array(int)
,	O
int	O
level	int
,	O
dfa_node	struct
*	O
terminal_node	O
,	O
dfa_attrib_array	struct
*	O
passing_strings_array	O
)	O
{	O
int	O
save_num_nodes	O
=	O
graph	O
->	O
num_nodes	O
;	O
dfa_attrib_block	struct
*	O
cutoff_point	O
;	O
dfa_node	struct
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
dfa_node	struct
*	O
this_terminal_node	O
=	O
dfa_iterator_reset	O
(	O
graph	O
)	O
;	O
cutoff_point	O
=	O
passing_strings_array	O
->	O
last_block	*(struct(*(struct(*(struct`),array(struct(*(struct(*(struct(*`,int)),int)),int)))),array(struct(*(struct(*(struct(*`,int)),int)),int))))
;	O
dfa_hash_clear	O
(	O
)	O
;	O
for	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
this_terminal_node	O
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
terminal_node	O
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
dfa_iterate	O
(	O
)	O
)	O
{	O
int	O
k	int
;	O
int	O
num_masks	O
=	O
0	int
;	O
char	O
mask	O
[	O
4	int
]	O
;	O
dfa_attrib	struct
*	O
passing_string	O
;	O
dfa_attrib	struct
*	O
*	O
link	O
=	O
&	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
;	O
dfa_attrib	struct
*	O
new_passing_strings	O
[	O
4	int
]	O
;	O
dfa_attrib	struct
*	O
*	O
new_link	O
[	O
4	int
]	O
;	O
for	O
(	O
passing_string	O
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
passing_strings	O
;	O
passing_string	O
&&	O
num_masks	O
<	O
4	int
;	O
passing_string	O
=	O
passing_string	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
=	O
passing_string	O
->	O
string_index	int
;	O
char	O
string_mask	O
=	O
strings	array(int)
[	O
index	(*(char),int)->(*(char))
]	O
[	O
level	int
]	O
;	O
if	O
(	O
string_mask	O
)	O
{	O
int	O
limit	O
=	O
num_masks	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
limit	O
;	O
k	int
++	O
)	O
{	O
char	O
common_branches	O
=	O
string_mask	O
&	O
mask	O
[	O
k	int
]	O
;	O
if	O
(	O
common_branches	O
&&	O
common_branches	O
!=	O
mask	O
[	O
k	int
]	O
)	O
{	O
mask	O
[	O
k	int
]	O
^=	O
common_branches	O
;	O
mask	O
[	O
num_masks	O
++	O
]	O
=	O
common_branches	O
;	O
}	O
string_mask	O
^=	O
common_branches	O
;	O
}	O
if	O
(	O
string_mask	O
)	O
{	O
mask	O
[	O
num_masks	O
++	O
]	O
=	O
string_mask	O
;	O
}	O
}	O
else	O
{	O
*	O
link	O
=	O
dfa_attrib_new	O
(	O
&	O
(	O
graph	O
->	O
attributes	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int)))
)	O
,	O
index	(*(char),int)->(*(char))
)	O
;	O
link	O
=	O
&	O
(	O
(	O
*	O
link	O
)	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	O
;	O
k	int
++	O
)	O
new_link	O
[	O
k	int
]	O
=	O
&	O
(	O
new_passing_strings	O
[	O
k	int
]	O
)	O
;	O
for	O
(	O
passing_string	O
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
passing_strings	O
;	O
passing_string	O
;	O
passing_string	O
=	O
passing_string	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
=	O
passing_string	O
->	O
string_index	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strings	array(int)
[	O
index	(*(char),int)->(*(char))
]	O
[	O
level	int
]	O
&	O
mask	O
[	O
k	int
]	O
)	O
{	O
*	O
(	O
new_link	O
[	O
k	int
]	O
)	O
=	O
dfa_attrib_new	O
(	O
passing_strings_array	O
,	O
index	(*(char),int)->(*(char))
)	O
;	O
new_link	O
[	O
k	int
]	O
=	O
&	O
(	O
(	O
*	O
(	O
new_link	O
[	O
k	int
]	O
)	O
)	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
}	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	O
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
dfa_node	struct
*	O
new_node	O
=	O
dfa_hash_search	O
(	O
new_passing_strings	O
[	O
k	int
]	O
)	O
;	O
if	O
(	O
!	O
new_node	O
)	O
{	O
new_node	O
=	O
dfa_node_new	O
(	O
graph	O
)	O
;	O
new_node	O
->	O
passing_strings	O
=	O
new_passing_strings	O
[	O
k	int
]	O
;	O
dfa_hash_add_node	O
(	O
new_node	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mask	O
[	O
k	int
]	O
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
branch	O
[	O
i	int
]	O
=	O
new_node	O
;	O
}	O
}	O
}	O
dfa_attrib_array_partially_clear	O
(	O
cutoff_point	O
)	O
;	O
if	O
(	O
graph	O
->	O
num_nodes	O
!=	O
save_num_nodes	O
)	O
{	O
dfa_graph_build_level	O
(	O
graph	O
,	O
strings	array(int)
,	O
level	int
+	O
1	int
,	O
this_terminal_node	O
,	O
passing_strings_array	O
)	O
;	O
}	O
}	O
static	O
char	O
*	O
dfa_prepare_string	O
(	O
const	O
char	O
*	O
string	int
)	O
{	O
int	O
k	int
;	O
int	O
l	O
=	O
strlen	(*(char))->(long)
(	O
string	int
)	O
;	O
char	O
*	O
dfa_string	O
=	O
malloc	(long)->(*(void))
(	O
l	O
+	O
1	int
)	O
;	O
assert	O
(	O
dfa_string	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
l	O
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
string	int
[	O
k	int
]	O
)	O
{	O
case	O
'$'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
15	int
;	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'|'	O
:	O
case	O
'+'	O
:	O
case	O
'#'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
8	int
;	O
break	O
;	O
case	O
'.'	O
:	O
case	O
','	O
:	O
case	O
'!'	O
:	O
case	O
'a'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
'?'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
7	int
;	O
break	O
;	O
case	O
'O'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
2	int
;	O
break	O
;	O
case	O
'X'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
4	int
;	O
break	O
;	O
case	O
'o'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
3	int
;	O
break	O
;	O
case	O
'x'	O
:	O
dfa_string	O
[	O
k	int
]	O
=	O
5	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
dfa_string	O
[	O
l	O
]	O
=	O
0	int
;	O
return	O
dfa_string	O
;	O
}	O
void	O
dfa_patterns_reset	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
{	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
=	O
0	int
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
=	O
NULL	O
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
=	O
NULL	O
;	O
dfa_graph_reset	O
(	O
&	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
)	O
)	O
;	O
}	O
void	O
dfa_patterns_clear	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
{	O
dfa_pattern	O
*	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
;	O
while	O
(	O
pattern	*(struct)
)	O
{	O
int	O
k	int
;	O
dfa_pattern	O
*	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
num_variations	char
;	O
k	int
++	O
)	O
free	(*(void))->(void)
(	O
pattern	*(struct)
->	O
variation	O
[	O
k	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
pattern	*(struct)
)	O
;	O
pattern	*(struct)
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
=	O
0	int
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
=	O
NULL	O
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
=	O
NULL	O
;	O
dfa_graph_clear	O
(	O
&	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
)	O
)	O
;	O
}	O
void	O
dfa_patterns_add_pattern	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
const	O
char	O
*	O
string	int
,	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
dfa_pattern	O
*	O
pattern	*(struct)
=	O
NULL	O
;	O
if	O
(	O
index	(*(char),int)->(*(char))
==	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
-	O
1	int
)	O
{	O
assert	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
)	O
;	O
assert	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
->	O
num_variations	char
<	O
8	int
)	O
;	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
;	O
}	O
else	O
{	O
assert	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
<=	O
index	(*(char),int)->(*(char))
)	O
;	O
while	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
<=	O
index	(*(char),int)->(*(char))
)	O
{	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
++	O
;	O
pattern	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
pattern	*(struct)
)	O
)	O
;	O
pattern	*(struct)
->	O
num_variations	char
=	O
0	int
;	O
if	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
)	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
pattern	*(struct)
;	O
else	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
=	O
pattern	*(struct)
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
=	O
pattern	*(struct)
;	O
}	O
pattern	*(struct)
->	O
current_variation	O
=	O
0	int
;	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
NULL	O
;	O
}	O
pattern	*(struct)
->	O
variation	O
[	O
pattern	*(struct)
->	O
num_variations	char
++	O
]	O
=	O
dfa_prepare_string	O
(	O
string	int
)	O
;	O
}	O
void	O
dfa_patterns_set_last_pattern_variation	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
int	O
variation	O
)	O
{	O
assert	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
)	O
;	O
assert	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
->	O
num_variations	char
>	O
variation	O
)	O
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
->	O
current_variation	O
=	O
variation	O
;	O
}	O
void	O
dfa_patterns_select_shortest_variation	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
{	O
int	O
k	int
;	O
int	O
min_length	O
;	O
dfa_pattern	O
*	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
last_pattern	O
;	O
assert	O
(	O
pattern	*(struct)
)	O
;	O
pattern	*(struct)
->	O
current_variation	O
=	O
0	int
;	O
min_length	O
=	O
strlen	(*(char))->(long)
(	O
pattern	*(struct)
->	O
variation	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
pattern	*(struct)
->	O
num_variations	char
;	O
k	int
++	O
)	O
{	O
int	O
length	O
=	O
strlen	(*(char))->(long)
(	O
pattern	*(struct)
->	O
variation	O
[	O
k	int
]	O
)	O
;	O
if	O
(	O
length	O
<	O
min_length	O
)	O
{	O
pattern	*(struct)
->	O
current_variation	O
=	O
k	int
;	O
min_length	O
=	O
length	O
;	O
}	O
}	O
}	O
void	O
dfa_patterns_build_graph	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
{	O
int	O
k	int
=	O
0	int
;	O
char	O
*	O
*	O
strings	array(int)
;	O
dfa_attrib_array	struct
passing_strings_array	O
;	O
dfa_attrib	struct
*	O
*	O
link	O
;	O
dfa_node	struct
*	O
error_state	O
;	O
dfa_graph	struct
*	O
graph	O
=	O
&	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
)	O
;	O
dfa_pattern	O
*	O
pattern	*(struct)
;	O
strings	array(int)
=	O
malloc	(long)->(*(void))
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
*	O
sizeof	O
(	O
*	O
strings	array(int)
)	O
)	O
;	O
assert	O
(	O
strings	array(int)
)	O
;	O
dfa_graph_clear	O
(	O
graph	O
)	O
;	O
dfa_attrib_array_reset	O
(	O
&	O
passing_strings_array	O
)	O
;	O
error_state	O
=	O
dfa_node_new	O
(	O
graph	O
)	O
;	O
graph	O
->	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
dfa_node_new	O
(	O
graph	O
)	O
;	O
link	O
=	O
&	O
(	O
graph	O
->	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
passing_strings	O
)	O
;	O
for	O
(	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
;	O
pattern	*(struct)
;	O
pattern	*(struct)
=	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
k	int
++	O
)	O
{	O
if	O
(	O
pattern	*(struct)
->	O
num_variations	char
>	O
0	int
)	O
{	O
assert	O
(	O
pattern	*(struct)
->	O
current_variation	O
<	O
pattern	*(struct)
->	O
num_variations	char
)	O
;	O
strings	array(int)
[	O
k	int
]	O
=	O
pattern	*(struct)
->	O
variation	O
[	O
pattern	*(struct)
->	O
current_variation	O
]	O
;	O
*	O
link	O
=	O
dfa_attrib_new	O
(	O
&	O
passing_strings_array	O
,	O
k	int
)	O
;	O
link	O
=	O
&	O
(	O
(	O
*	O
link	O
)	O
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
}	O
else	O
strings	array(int)
[	O
k	int
]	O
=	O
NULL	O
;	O
}	O
dfa_graph_build_level	O
(	O
graph	O
,	O
strings	array(int)
,	O
0	int
,	O
error_state	O
,	O
&	O
passing_strings_array	O
)	O
;	O
free	(*(void))->(void)
(	O
strings	array(int)
)	O
;	O
dfa_attrib_array_clear	O
(	O
&	O
passing_strings_array	O
)	O
;	O
}	O
int	O
*	O
dfa_patterns_optimize_variations	O
(	O
dfa_patterns	O
*	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
int	O
iterations	O
)	O
{	O
int	O
k	int
=	O
0	int
;	O
int	O
failed_iterations	O
=	O
0	int
;	O
int	O
min_nodes_so_far	O
;	O
int	O
num_nodes_original	O
;	O
int	O
*	O
best_variations	O
;	O
double	O
lower_limit	O
=	O
2.0	int
/	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
;	O
double	O
upper_limit	O
=	O
6.0	int
/	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
;	O
double	O
change_probability	O
=	O
4.0	int
/	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
;	O
dfa_pattern	O
*	O
pattern	*(struct)
;	O
best_variations	O
=	O
malloc	(long)->(*(void))
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
*	O
sizeof	O
(	O
*	O
best_variations	O
)	O
)	O
;	O
assert	O
(	O
best_variations	O
)	O
;	O
for	O
(	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
;	O
pattern	*(struct)
;	O
pattern	*(struct)
=	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
k	int
++	O
)	O
best_variations	O
[	O
k	int
]	O
=	O
pattern	*(struct)
->	O
current_variation	O
;	O
dfa_patterns_build_graph	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
;	O
num_nodes_original	O
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
.	O
num_nodes	O
;	O
min_nodes_so_far	O
=	O
num_nodes_original	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Original number of DFA states: %d\n"	*(char)
,	O
min_nodes_so_far	O
-	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Trying to optimize in %d iterations\n"	*(char)
,	O
iterations	O
)	O
;	O
gg_srand	O
(	O
num_nodes_original	O
+	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
)	O
;	O
while	O
(	O
iterations	O
--	O
)	O
{	O
int	O
changed_variations	O
=	O
0	int
;	O
int	O
k	int
=	O
0	int
;	O
for	O
(	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
;	O
pattern	*(struct)
;	O
pattern	*(struct)
=	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
k	int
++	O
)	O
{	O
if	O
(	O
gg_drand	O
(	O
)	O
<	O
change_probability	O
&&	O
pattern	*(struct)
->	O
num_variations	char
>	O
1	int
)	O
{	O
int	O
new_variation	O
=	O
gg_rand	O
(	O
)	O
%	O
(	O
pattern	*(struct)
->	O
num_variations	char
-	O
1	int
)	O
;	O
if	O
(	O
new_variation	O
>=	O
pattern	*(struct)
->	O
current_variation	O
)	O
new_variation	O
++	O
;	O
pattern	*(struct)
->	O
current_variation	O
=	O
new_variation	O
;	O
changed_variations	O
++	O
;	O
}	O
else	O
pattern	*(struct)
->	O
current_variation	O
=	O
best_variations	O
[	O
k	int
]	O
;	O
}	O
if	O
(	O
changed_variations	O
==	O
0	int
)	O
{	O
iterations	O
++	O
;	O
continue	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"."	*(char)
)	O
;	O
dfa_patterns_build_graph	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
;	O
if	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
.	O
num_nodes	O
<	O
min_nodes_so_far	O
)	O
{	O
int	O
k	int
=	O
0	int
;	O
for	O
(	O
pattern	*(struct)
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
;	O
pattern	*(struct)
;	O
pattern	*(struct)
=	O
pattern	*(struct)
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
k	int
++	O
)	O
best_variations	O
[	O
k	int
]	O
=	O
pattern	*(struct)
->	O
current_variation	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nOptimized: %d => %d states (%d iterations left)\n"	*(char)
,	O
min_nodes_so_far	O
-	O
1	int
,	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
.	O
num_nodes	O
-	O
1	int
,	O
iterations	O
)	O
;	O
min_nodes_so_far	O
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
.	O
num_nodes	O
;	O
failed_iterations	O
=	O
0	int
;	O
}	O
else	O
failed_iterations	O
++	O
;	O
if	O
(	O
failed_iterations	O
>=	O
30	int
)	O
{	O
double	O
delta	array(int)
=	O
gg_drand	O
(	O
)	O
/	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
num_patterns	O
;	O
if	O
(	O
change_probability	O
>	O
upper_limit	O
||	O
(	O
change_probability	O
>=	O
lower_limit	O
&&	O
gg_rand	O
(	O
)	O
%	O
2	int
==	O
0	int
)	O
)	O
delta	array(int)
=	O
-	O
delta	array(int)
;	O
change_probability	O
+=	O
delta	array(int)
;	O
failed_iterations	O
=	O
0	int
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\nTotal optimization result: %d => %d states\n"	*(char)
,	O
num_nodes_original	O
-	O
1	int
,	O
min_nodes_so_far	O
-	O
1	int
)	O
;	O
dfa_graph_clear	O
(	O
&	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
->	O
graph	O
)	O
)	O
;	O
return	O
best_variations	O
;	O
}	O
