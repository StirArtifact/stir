int	O
grad_set_nonblocking	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
flags	int
;	O
if	O
(	O
(	O
flags	int
=	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
F_GETFL	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"F_GETFL"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
F_SETFL	int
,	O
flags	int
|	O
FCNTL_NONBLOCK	O
)	O
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"F_SETFL"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
grad_max_fd	()->(int)
(	O
)	O
{	O
return	O
getdtablesize	()->(int)
(	O
)	O
;	O
}	O
static	O
grad_uint32_t	int
grad_first_ip_nameindex	()->(int)
(	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
=	O
INADDR_ANY	O
;	O
return	O
ip	*(struct)
;	O
}	O
static	O
grad_uint32_t	int
grad_first_ip_hostname	()->(int)
(	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
=	O
INADDR_ANY	O
;	O
char	O
*	O
name	*(char)
;	O
int	O
name_len	int
=	O
256	int
;	O
int	O
status	int
;	O
name	*(char)
=	O
grad_emalloc	(long)->(*(void))
(	O
name_len	int
)	O
;	O
while	O
(	O
name	*(char)
&&	O
(	O
status	int
=	O
gethostname	(*(char),long)->(int)
(	O
name	*(char)
,	O
name_len	int
)	O
)	O
==	O
0	int
&&	O
!	O
memchr	(*(void),int,long)->(*(void))
(	O
name	*(char)
,	O
0	int
,	O
name_len	int
)	O
)	O
{	O
name_len	int
*=	O
2	int
;	O
name	*(char)
=	O
grad_erealloc	(*(void),long)->(*(void))
(	O
name	*(char)
,	O
name_len	int
)	O
;	O
}	O
if	O
(	O
status	int
==	O
0	int
)	O
ip	*(struct)
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
ip	*(struct)
;	O
}	O
grad_uint32_t	int
grad_first_ip	()->(int)
(	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
=	O
INADDR_ANY	O
;	O
ip	*(struct)
=	O
grad_first_ip_nameindex	()->(int)
(	O
)	O
;	O
if	O
(	O
ip	*(struct)
==	O
INADDR_ANY	O
)	O
ip	*(struct)
=	O
grad_first_ip_hostname	()->(int)
(	O
)	O
;	O
return	O
ip	*(struct)
;	O
}	O
grad_signal_handler_t	*((int)->(void))
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
int	O
sig	int
,	O
grad_signal_handler_t	*((int)->(void))
sighandler	*((int)->(void))
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
oact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
sighandler	*((int)->(void))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
|=	O
SA_INTERRUPT	int
;	O
if	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
oact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
<	O
0	int
)	O
return	O
SIG_ERR	O
;	O
return	O
oact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
;	O
}	O
void	O
grad_reset_signal	(int,*((int)->(void)))->(void)
(	O
int	O
sig	int
ARG_UNUSED	O
,	O
grad_signal_handler_t	*((int)->(void))
sighandler	*((int)->(void))
ARG_UNUSED	O
)	O
{	O
}	O
