extern	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
optionsArray	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
extern	O
char	O
*	O
CHARTRUE	*(char)
;	O
static	O
int	O
swextopt_statusG	int
=	O
0	int
;	O
static	O
char	O
*	O
utilnames	array(*(char))
[	O
]	O
=	O
{	O
"swask"	*(char)
,	O
"swcopy"	*(char)
,	O
"swinstall"	*(char)
,	O
"swconfig"	*(char)
,	O
"swlist"	*(char)
,	O
"swmodify"	*(char)
,	O
"swpackage"	*(char)
,	O
"swremove"	*(char)
,	O
"swverify"	*(char)
,	O
""	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
i_is_value_false	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
||	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"f"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"false"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"no"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"n"	*(char)
)	O
==	O
0	int
||	O
0	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
i_is_value_true	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
NULL	O
&&	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"t"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"true"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"yes"	*(char)
)	O
==	O
0	int
||	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"y"	*(char)
)	O
==	O
0	int
||	O
0	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
find_pow	(int)->(int)
(	O
int	O
flag	*(int)
)	O
{	O
int	O
i	int
=	O
1	int
;	O
if	O
(	O
flag	*(int)
<=	O
1	int
)	O
return	O
0	int
;	O
while	O
(	O
flag	*(int)
/	O
2	int
>	O
1	int
)	O
{	O
flag	*(int)
=	O
flag	*(int)
>>	O
1	int
;	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
i_getEnumFromName	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
char	O
*	O
optionname	*(char)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
optionname	*(char)
)	O
)	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
}	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
(	O
(	O
(	O
char	O
*	O
)	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
-	O
(	O
char	O
*	O
)	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
/	O
sizeof	O
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
)	O
;	O
}	O
static	O
int	O
check_applicability	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(int)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
int	O
bit	int
;	O
int	O
index	(*(char),int)->(*(char))
;	O
char	O
*	O
cu	*(char)
;	O
int	O
ret	int
;	O
char	O
*	O
*	O
names	*(*(char))
=	O
utilnames	array(*(char))
;	O
int	O
ap_mask	int
;	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
ap_mask	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
app_flags	int
;	O
cu	*(char)
=	O
swlib_utilname_get	()->(*(char))
(	O
)	O
;	O
while	O
(	O
*	O
names	*(*(char))
&&	O
strcmp	(*(char),*(char))->(int)
(	O
cu	*(char)
,	O
*	O
names	*(*(char))
)	O
)	O
{	O
names	*(*(char))
++	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
names	*(*(char))
)	O
)	O
return	O
1	int
;	O
index	(*(char),int)->(*(char))
=	O
(	O
int	O
)	O
(	O
names	*(*(char))
-	O
utilnames	array(*(char))
)	O
;	O
bit	int
=	O
1	int
<<	O
index	(*(char),int)->(*(char))
;	O
ret	int
=	O
!	O
(	O
ap_mask	int
&	O
bit	int
)	O
;	O
if	O
(	O
ret	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: option not valid: %s\n"	*(char)
,	O
cu	*(char)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
optionNameM	*(char)
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
combine1	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
result	*(int)
,	O
char	O
*	O
directory	*(char)
,	O
char	O
*	O
soc_spec	*(char)
)	O
{	O
char	O
*	O
x	*(char)
;	O
char	O
*	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
E_DEBUG3	O
(	O
"directory=%s soc_spec=%s"	*(char)
,	O
directory	*(char)
,	O
soc_spec	*(char)
)	O
;	O
if	O
(	O
*	O
directory	*(char)
==	O
'@'	O
)	O
directory	*(char)
++	O
;	O
if	O
(	O
*	O
soc_spec	*(char)
==	O
'@'	O
)	O
directory	*(char)
++	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
"@"	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
)	O
;	O
x	*(char)
=	O
directory	*(char)
;	O
if	O
(	O
*	O
directory	*(char)
==	O
':'	O
)	O
x	*(char)
++	O
;	O
if	O
(	O
*	O
directory	*(char)
==	O
'@'	O
)	O
x	*(char)
++	O
;	O
if	O
(	O
soc_spec	*(char)
[	O
strlen	(*(char))->(long)
(	O
soc_spec	*(char)
)	O
-	O
1	int
]	O
!=	O
':'	O
&&	O
directory	*(char)
[	O
0	int
]	O
!=	O
':'	O
&&	O
1	int
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
":"	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
)	O
;	O
}	O
if	O
(	O
*	O
directory	*(char)
==	O
':'	O
)	O
directory	*(char)
++	O
;	O
if	O
(	O
(	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
strrchr	(*(char),int)->(*(char))
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
,	O
':'	O
)	O
)	O
&&	O
*	O
(	O
t	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
+	O
1	int
)	O
==	O
'\0'	O
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
)	O
;	O
}	O
else	O
{	O
swlib_unix_dircat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
)	O
;	O
}	O
}	O
static	O
void	O
close_stdio	()->(void)
(	O
void	O
)	O
{	O
close	*((*(void))->(int))
(	O
STDOUT_FILENO	int
)	O
;	O
close	*((*(void))->(int))
(	O
STDERR_FILENO	int
)	O
;	O
}	O
static	O
void	O
i_set_opta	(int,*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
int	O
optsetflag	int
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
value	int
&&	O
strpbrk	(*(char),*(char))->(*(char))
(	O
value	int
,	O
SWBIS_TAINTED_CHARS	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: shell meta-characters detected for %s option\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
optionNameM	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
option_setM	char
=	O
(	O
char	O
)	O
optsetflag	int
;	O
if	O
(	O
value	int
)	O
{	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
valueM	int
=	O
strdup	(*(char))->(*(char))
(	O
value	int
)	O
;	O
}	O
else	O
{	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
valueM	int
=	O
value	int
;	O
}	O
}	O
void	O
debug_writeBooleanExtendedOptions	(int,*(struct(char,char,char,*(char),*(char),*(char),int)))->(void)
(	O
int	O
ofd	int
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
int	O
op	int
=	O
0	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
{	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
is_boolM	char
)	O
swlib_writef	(int,*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(int)
(	O
ofd	int
,	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"%s=%d\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
swextopt_is_value_true	(*(char))->(int)
(	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
op	int
)	O
)	O
)	O
;	O
op	int
++	O
;	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
}	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
void	O
swextopt_write_session_options	(*(struct(*(char),*(char),int,int,int,char,int)),*(struct(char,char,char,*(char),*(char),*(char),int)),int)->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
SWC_FLAG	int
)	O
{	O
char	O
*	O
value	int
;	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
int	O
op	int
=	O
0	int
;	O
int	O
bv	int
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
""	*(char)
)	O
;	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
{	O
if	O
(	O
(	O
SWC_FLAG	int
==	O
0	int
)	O
||	O
(	O
SWC_FLAG	int
&	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
app_flags	int
)	O
)	O
)	O
{	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
is_boolM	char
)	O
{	O
bv	int
=	O
swextopt_is_value_true	(*(char))->(int)
(	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
op	int
)	O
)	O
;	O
switch	O
(	O
bv	int
)	O
{	O
case	O
1	int
:	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
1	int
,	O
"%s=\"true\"\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
1	int
,	O
"%s=\"false\"\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
value	int
=	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
op	int
)	O
;	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
strpbrk	(*(char),*(char))->(*(char))
(	O
value	int
,	O
SWBIS_TAINTED_CHARS	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: shell meta-characters detected for %s option\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
;	O
value	int
=	O
""	*(char)
;	O
}	O
}	O
else	O
{	O
value	int
=	O
""	*(char)
;	O
}	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
1	int
,	O
"%s=\"%s\"\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
value	int
)	O
;	O
}	O
}	O
op	int
++	O
;	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
}	O
}	O
int	O
swextopt_is_value_false	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
i_is_value_false	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
i_is_value_true	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: extended option boolean value '%s' is improperly formatted, assuming false\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
swextopt_is_value_true	(*(char))->(int)
(	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
i_is_value_true	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
i_is_value_false	(*(char))->(int)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: extended option boolean value '%s' is improperly formatted, assuming false\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swextopt_is_option_false	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
char	O
*	O
val	int
;	O
val	int
=	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
swextopt_is_value_false	(*(char))->(int)
(	O
val	int
)	O
;	O
}	O
int	O
swextopt_is_option_true	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
char	O
*	O
val	int
;	O
val	int
=	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
swextopt_is_value_true	(*(char))->(int)
(	O
val	int
)	O
;	O
}	O
int	O
swextopt_is_option_set	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
return	O
(	O
int	O
)	O
(	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
option_setM	char
)	O
;	O
}	O
int	O
parseDefaultsFile	(*(char),*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),int)->(int)
(	O
char	O
*	O
utility_name	*(char)
,	O
char	O
*	O
defaults_filename	*(char)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
doPreserveOptions	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
int	O
is_option_set	int
;	O
int	O
is_util_set	int
;	O
char	O
*	O
value	int
;	O
char	O
*	O
option	struct(*(char),int,*(int),int)
;	O
char	O
*	O
optionutil	*(char)
;	O
char	O
nullb	char
=	O
'\0'	O
;	O
int	O
fd	int
;	O
int	O
uxfio_fd	int
;	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
line	*(char)
;	O
char	O
*	O
oldvalue	*(char)
;	O
int	O
is_util_option	int
;	O
int	O
is_global_option	int
;	O
int	O
is_set	int
;	O
uxfio_fd	int
=	O
uxfio_open	(*(char),int,int)->(int)
(	O
""	*(char)
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
uxfio_fd	int
<	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
uxfio_fcntl	(int,int,int)->(int)
(	O
uxfio_fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	(int,int,int)->(int)
(	O
uxfio_fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
defaults_filename	*(char)
,	O
SWBIS_STDIO_FNAME	*(char)
)	O
!=	O
0	int
)	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
defaults_filename	*(char)
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
else	O
fd	int
=	O
STDIN_FILENO	int
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s : %s\n"	*(char)
,	O
defaults_filename	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
uxfio_close	(int)->(int)
(	O
uxfio_fd	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
sw_yyparse	(int,int,*(char),int,int)->(int)
(	O
fd	int
,	O
uxfio_fd	int
,	O
"OPTION"	*(char)
,	O
0	int
,	O
SWPARSE_FORM_MKUP_LEN	O
)	O
)	O
{	O
uxfio_close	(int)->(int)
(	O
uxfio_fd	int
)	O
;	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
3	int
;	O
}	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
uxfio_write	(int,*(void),long)->(long)
(	O
uxfio_fd	int
,	O
(	O
void	O
*	O
)	O
(	O
&	O
nullb	char
)	O
,	O
1	int
)	O
;	O
if	O
(	O
uxfio_lseek	(int,long,int)->(long)
(	O
uxfio_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
)	O
{	O
uxfio_close	(int)->(int)
(	O
uxfio_fd	int
)	O
;	O
return	O
4	int
;	O
}	O
if	O
(	O
uxfio_get_dynamic_buffer	(int,*(*(char)),*(int),*(int))->(int)
(	O
uxfio_fd	int
,	O
&	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
NULL	O
)	O
<	O
0	int
)	O
return	O
5	int
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
line	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"\r\n"	*(char)
)	O
;	O
while	O
(	O
line	*(char)
)	O
{	O
value	int
=	O
NULL	O
;	O
option	struct(*(char),int,*(int),int)
=	O
NULL	O
;	O
optionutil	*(char)
=	O
NULL	O
;	O
is_util_option	int
=	O
0	int
;	O
is_global_option	int
=	O
0	int
;	O
option	struct(*(char),int,*(int),int)
=	O
swheaderline_get_keyword	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
value	int
=	O
swheaderline_get_value	(*(char),*(int))->(*(char))
(	O
line	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
option	struct(*(char),int,*(int),int)
,	O
utility_name	*(char)
)	O
==	O
option	struct(*(char),int,*(int),int)
)	O
&&	O
option	struct(*(char),int,*(int),int)
[	O
strlen	(*(char))->(long)
(	O
utility_name	*(char)
)	O
]	O
==	O
'.'	O
)	O
{	O
is_util_option	int
=	O
1	int
;	O
option	struct(*(char),int,*(int),int)
+=	O
(	O
strlen	(*(char))->(long)
(	O
utility_name	*(char)
)	O
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
option	struct(*(char),int,*(int),int)
,	O
'.'	O
)	O
==	O
NULL	O
)	O
{	O
is_global_option	int
=	O
1	int
;	O
}	O
if	O
(	O
is_util_option	int
||	O
is_global_option	int
)	O
{	O
if	O
(	O
(	O
oldvalue	*(char)
=	O
getExtendedOption	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),*(int),*(int),*(int))->(*(char))
(	O
option	struct(*(char),int,*(int),int)
,	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
&	O
is_set	int
,	O
&	O
is_option_set	int
,	O
&	O
is_util_set	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
is_util_set	int
==	O
0	int
&&	O
is_global_option	int
&&	O
is_option_set	int
==	O
0	int
)	O
||	O
(	O
(	O
is_util_option	int
||	O
is_set	int
==	O
0	int
)	O
&&	O
is_option_set	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
is_set	int
&&	O
oldvalue	*(char)
)	O
free	(*(void))->(void)
(	O
oldvalue	*(char)
)	O
;	O
if	O
(	O
value	int
)	O
value	int
=	O
strdup	(*(char))->(*(char))
(	O
value	int
)	O
;	O
setExtendedOption	(*(char),*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),int,int)->(int)
(	O
option	struct(*(char),int,*(int),int)
,	O
value	int
,	O
options	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
doPreserveOptions	int
,	O
is_util_option	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: option %s not recognized\n"	*(char)
,	O
utility_name	*(char)
,	O
option	struct(*(char),int,*(int),int)
)	O
;	O
ret	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
line	*(char)
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
"\n"	*(char)
)	O
;	O
}	O
uxfio_close	(int)->(int)
(	O
uxfio_fd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
initExtendedOption	()->(int)
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
char	O
*	O
getLongOptionNameFromValue	(*(struct(*(char),int,*(int),int)),int)->(*(char))
(	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
arr	*(struct(*(char),int,*(int),int))
,	O
int	O
val	int
)	O
{	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
p	*(char)
=	O
arr	*(struct(*(char),int,*(int),int))
;	O
while	O
(	O
p	*(char)
->	O
val	int
&&	O
p	*(char)
->	O
name	*(char)
)	O
{	O
if	O
(	O
p	*(char)
->	O
val	int
==	O
val	int
)	O
return	O
(	O
char	O
*	O
)	O
(	O
p	*(char)
->	O
name	*(char)
)	O
;	O
p	*(char)
++	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
int	O
getEnumFromName	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
char	O
*	O
fp_optionname	*(char)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
optionname	*(char)
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
;	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
fp_optionname	*(char)
)	O
;	O
optionname	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
swlib_tr	(*(char),int,int)->(int)
(	O
optionname	*(char)
,	O
(	O
int	O
)	O
'_'	O
,	O
(	O
int	O
)	O
'-'	O
)	O
;	O
ret	int
=	O
i_getEnumFromName	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
optionname	*(char)
,	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
{	O
return	O
ret	int
;	O
}	O
swlib_tr	(*(char),int,int)->(int)
(	O
optionname	*(char)
,	O
(	O
int	O
)	O
'-'	O
,	O
(	O
int	O
)	O
'_'	O
)	O
;	O
ret	int
=	O
i_getEnumFromName	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)))->(int)
(	O
optionname	*(char)
,	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
setExtendedOption	(*(char),*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),int,int)->(int)
(	O
char	O
*	O
optionname	*(char)
,	O
char	O
*	O
value	int
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
optSet	int
,	O
int	O
is_util_option	int
)	O
{	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
if	O
(	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
}	O
else	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
optionsArray	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
}	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
optionname	*(char)
)	O
)	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
}	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
{	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
util_setM	char
&&	O
is_util_option	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
optSet	int
&&	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
option_setM	char
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
is_util_option	int
)	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
util_setM	char
=	O
(	O
char	O
)	O
1	int
;	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
valueM	int
=	O
value	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
swextopt_writeExtendedOptions	(int,*(struct(char,char,char,*(char),*(char),*(char),int)),int)->(int)
(	O
int	O
ofd	int
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
SWC_FLAG	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
swextopt_writeExtendedOptions_strob	(*(struct(*(char),*(char),int,int,int,char,int)),*(struct(char,char,char,*(char),*(char),*(char),int)),int,int)->(void)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
SWC_FLAG	int
,	O
0	int
)	O
;	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	*((*(void),*(char),long)->(long))
,	O
ofd	int
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strob_strlen	(*(struct(*(char),*(char),int,int,int,char,int)))->(long)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
return	O
-	O
1	int
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swextopt_writeExtendedOptions_strob	(*(struct(*(char),*(char),int,int,int,char,int)),*(struct(char,char,char,*(char),*(char),*(char),int)),int,int)->(void)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
SWC_FLAG	int
,	O
int	O
do_shell_protect	int
)	O
{	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
{	O
if	O
(	O
(	O
SWC_FLAG	int
==	O
0	int
)	O
||	O
(	O
SWC_FLAG	int
&	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
app_flags	int
)	O
)	O
)	O
{	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
getExtendedOption	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),*(int),*(int),*(int))->(*(char))
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
""	*(char)
;	O
if	O
(	O
do_shell_protect	int
==	O
0	int
)	O
{	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
STROB_DO_APPEND	int
,	O
"%s=%s\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
else	O
{	O
swlib_is_sh_tainted_string_fatal	(*(char))->(void)
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_sprintf	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
STROB_DO_APPEND	int
,	O
"%s=\"%s\"\n"	*(char)
,	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
}	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
}	O
}	O
char	O
*	O
getExtendedOption	(*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),*(int),*(int),*(int))->(*(char))
(	O
char	O
*	O
optionname	*(char)
,	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
int	O
*	O
pis_set	*(int)
,	O
int	O
*	O
isOptSet	*(int)
,	O
int	O
*	O
isUtilSet	*(int)
)	O
{	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
if	O
(	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
)	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
peop	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
}	O
else	O
{	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
=	O
optionsArray	*(struct(char,char,char,*(char),*(char),*(char),int))
;	O
}	O
while	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
,	O
optionname	*(char)
)	O
)	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
++	O
;	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
optionNameM	*(char)
)	O
{	O
if	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
valueM	int
)	O
{	O
if	O
(	O
isOptSet	*(int)
)	O
*	O
isOptSet	*(int)
=	O
(	O
int	O
)	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
option_setM	char
)	O
;	O
if	O
(	O
isUtilSet	*(int)
)	O
*	O
isUtilSet	*(int)
=	O
(	O
int	O
)	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
util_setM	char
)	O
;	O
if	O
(	O
pis_set	*(int)
)	O
*	O
pis_set	*(int)
=	O
1	int
;	O
return	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
valueM	int
;	O
}	O
else	O
{	O
if	O
(	O
isOptSet	*(int)
)	O
*	O
isOptSet	*(int)
=	O
(	O
int	O
)	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
option_setM	char
)	O
;	O
if	O
(	O
isUtilSet	*(int)
)	O
*	O
isUtilSet	*(int)
=	O
(	O
int	O
)	O
(	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
util_setM	char
)	O
;	O
if	O
(	O
pis_set	*(int)
)	O
*	O
pis_set	*(int)
=	O
0	int
;	O
return	O
eop	*(struct(char,char,char,*(char),*(char),*(char),int))
->	O
defaultValueM	*(char)
;	O
}	O
}	O
if	O
(	O
isOptSet	*(int)
)	O
*	O
isOptSet	*(int)
=	O
0	int
;	O
if	O
(	O
isUtilSet	*(int)
)	O
*	O
isUtilSet	*(int)
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
void	O
set_opta_boolean	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
is_boolM	char
)	O
{	O
if	O
(	O
value	int
!=	O
NULL	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"t"	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"f"	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
SW_E_TRUE	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
SW_E_FALSE	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"no"	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"yes"	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"n"	*(char)
)	O
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"y"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"0"	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
value	int
,	O
"1"	*(char)
)	O
)	O
{	O
swextopt_statusG	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
*	O
value	int
==	O
'0'	O
)	O
value	int
=	O
SW_E_FALSE	*(char)
;	O
if	O
(	O
*	O
value	int
==	O
'1'	O
)	O
value	int
=	O
SW_E_TRUE	*(char)
;	O
}	O
i_set_opta	(int,*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
1	int
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	int
)	O
;	O
}	O
void	O
set_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
is_boolM	char
)	O
set_opta_boolean	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	int
)	O
;	O
else	O
i_set_opta	(int,*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
1	int
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	int
)	O
;	O
}	O
void	O
set_opta_initial	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
char	O
*	O
value	int
)	O
{	O
i_set_opta	(int,*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
0	int
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
value	int
)	O
;	O
}	O
char	O
*	O
swbisoption_get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
char	O
*	O
value	int
;	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"internal warning: swbis option %d [%s] is null\n"	*(char)
,	O
(	O
int	O
)	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
optionNameM	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
defaultValueM	*(char)
;	O
return	O
value	int
;	O
}	O
char	O
*	O
get_opta_isc	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
char	O
*	O
value	int
;	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
host	*(char)
;	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
if	O
(	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
SW_E_installed_software_catalog	int
)	O
{	O
return	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: sw option %d [%s] is null, using default [%s]\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
optionNameM	*(char)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
defaultValueM	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
defaultValueM	*(char)
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strstr	(*(char),*(char))->(*(char))
(	O
value	int
,	O
FILE_URL	*(char)
)	O
;	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"processing ordinary path"	*(char)
)	O
;	O
swlib_squash_all_leading_slash	(*(char))->(void)
(	O
value	int
)	O
;	O
swlib_squash_all_dot_slash	(*(char))->(void)
(	O
value	int
)	O
;	O
swlib_squash_leading_dot_slash	(*(char))->(void)
(	O
value	int
)	O
;	O
return	O
value	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"processing file URL"	*(char)
)	O
;	O
if	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
value	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning malformed file URL: %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
value	int
)	O
;	O
return	O
value	int
;	O
}	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+=	O
strlen	(*(char))->(long)
(	O
FILE_URL	*(char)
)	O
;	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
==	O
'/'	O
)	O
{	O
host	*(char)
=	O
NULL	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
}	O
else	O
{	O
host	*(char)
=	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
strchr	(*(char),int)->(*(char))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
'/'	O
)	O
;	O
if	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: malformed file URL, assuming host part is file part\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
)	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
host	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
host	*(char)
,	O
"localhost/"	*(char)
)	O
!=	O
host	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: remote catalog URL not supported: %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
value	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: Possibly you intend URL: file:///absolute/path\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: exiting with error\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
char	O
*	O
get_opta	(*(struct(char,char,char,*(char),*(char),*(char),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
enum	O
eOpts	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
char	O
*	O
value	int
;	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: sw option %d [%s] is null, using default [%s]\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
(	O
int	O
)	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
optionNameM	*(char)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
defaultValueM	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
[	O
nopt	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
.	O
defaultValueM	*(char)
;	O
return	O
value	int
;	O
}	O
int	O
parse_options_file	(*(struct(char,char,char,*(char),*(char),*(char),int)),*(char),*(char))->(int)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
util_name	*(char)
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
filename	*(char)
,	O
R_OK	int
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
SWBIS_STDIO_FNAME	*(char)
)	O
==	O
0	int
)	O
{	O
ret	int
=	O
parseDefaultsFile	(*(char),*(char),*(struct(char,char,char,*(char),*(char),*(char),int)),int)->(int)
(	O
util_name	*(char)
,	O
filename	*(char)
,	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
1	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
char	O
*	O
initialize_options_files_list	(*(char))->(*(char))
(	O
char	O
*	O
usethis	*(char)
)	O
{	O
char	O
*	O
ret	int
;	O
if	O
(	O
usethis	*(char)
)	O
{	O
ret	int
=	O
strdup	(*(char))->(*(char))
(	O
usethis	*(char)
)	O
;	O
}	O
else	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SYSTEM_DEFAULTS_FILE	O
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
" "	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
SYSTEM_SWBISDEFAULTS_FILE	O
)	O
;	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
" "	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"/.swbis/swdefaults"	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
" "	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"/.swbis/swbisdefaults"	*(char)
)	O
;	O
}	O
ret	int
=	O
strdup	(*(char))->(*(char))
(	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swextopt_parse_options_files	(*(struct(char,char,char,*(char),*(char),*(char),int)),*(char),*(char),int,int)->(int)
(	O
struct	O
extendedOptions	struct(char,char,char,*(char),*(char),*(char),int)
*	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
char	O
*	O
option_files	*(char)
,	O
char	O
*	O
util_name	*(char)
,	O
int	O
reqd	int
,	O
int	O
show_only	int
)	O
{	O
int	O
do_check_access	int
=	O
0	int
;	O
char	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
skip	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
ktmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
if	O
(	O
option_files	*(char)
&&	O
strlen	(*(char))->(long)
(	O
option_files	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
option_files	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
show_only	int
)	O
{	O
do_check_access	int
=	O
1	int
;	O
}	O
do_check_access	int
=	O
1	int
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
option_files	*(char)
)	O
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
ktmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
" ,\n\r"	*(char)
)	O
;	O
while	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
do_check_access	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SWBIS_STDIO_FNAME	*(char)
)	O
)	O
{	O
if	O
(	O
access	(*(char),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
R_OK	int
)	O
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
if	O
(	O
reqd	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s : %s\n"	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
show_only	int
==	O
0	int
)	O
{	O
close_stdio	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
skip	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
skip	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
if	O
(	O
show_only	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
skip	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
show_only	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
skip	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
skip	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
ret	int
=	O
parse_options_file	(*(struct(char,char,char,*(char),*(char),*(char),int)),*(char),*(char))->(int)
(	O
opta	*(struct(char,char,char,*(char),*(char),*(char),int))
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
util_name	*(char)
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error processing option file : %s\n"	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
skip	int
=	O
0	int
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
strob_strtok	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(*(char))
(	O
ktmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
NULL	O
,	O
" "	*(char)
)	O
;	O
}	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
ktmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
has_file_part	(*(char))->(int)
(	O
char	O
*	O
soc	*(char)
)	O
{	O
if	O
(	O
!	O
soc	*(char)
||	O
strlen	(*(char))->(long)
(	O
soc	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
soc	*(char)
,	O
':'	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
soc	*(char)
+	O
(	O
strlen	(*(char))->(long)
(	O
soc	*(char)
)	O
-	O
1	int
)	O
)	O
==	O
':'	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_host	(*(char))->(int)
(	O
char	O
*	O
soc	*(char)
)	O
{	O
if	O
(	O
!	O
soc	*(char)
||	O
!	O
strlen	(*(char))->(long)
(	O
soc	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
soc	*(char)
==	O
'@'	O
)	O
soc	*(char)
++	O
;	O
if	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
soc	*(char)
,	O
"."	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
soc	*(char)
,	O
"./"	*(char)
)	O
)	O
&&	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
soc	*(char)
,	O
':'	O
)	O
&&	O
*	O
soc	*(char)
!=	O
':'	O
)	O
||	O
(	O
strchr	(*(char),int)->(*(char))
(	O
soc	*(char)
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
soc	*(char)
!=	O
'/'	O
)	O
||	O
soc	*(char)
[	O
strlen	(*(char))->(long)
(	O
soc	*(char)
)	O
-	O
1	int
]	O
==	O
':'	O
||	O
0	int
)	O
)	O
{	O
E_DEBUG2	O
(	O
"is host: %s"	*(char)
,	O
soc	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"is not host: %s"	*(char)
,	O
soc	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
is_fq	(*(char))->(int)
(	O
char	O
*	O
soc_spec	*(char)
)	O
{	O
char	O
*	O
trailing_colon	*(char)
;	O
if	O
(	O
*	O
soc_spec	*(char)
==	O
'/'	O
)	O
return	O
1	int
;	O
trailing_colon	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
soc_spec	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
trailing_colon	*(char)
&&	O
*	O
(	O
trailing_colon	*(char)
+	O
1	int
)	O
==	O
'/'	O
)	O
return	O
1	int
;	O
if	O
(	O
trailing_colon	*(char)
&&	O
*	O
(	O
trailing_colon	*(char)
+	O
1	int
)	O
==	O
'.'	O
&&	O
*	O
(	O
trailing_colon	*(char)
+	O
2	int
)	O
==	O
'\0'	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
swextopt_combine_directory	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
result	*(int)
,	O
char	O
*	O
soc_spec	*(char)
,	O
char	O
*	O
directory	*(char)
)	O
{	O
int	O
retval	int
;	O
E_DEBUG	O
(	O
"ENTERING"	*(char)
)	O
;	O
E_DEBUG3	O
(	O
"soc_spec=%s directory=%s"	*(char)
,	O
soc_spec	*(char)
,	O
directory	*(char)
)	O
;	O
if	O
(	O
soc_spec	*(char)
)	O
{	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
)	O
;	O
}	O
if	O
(	O
soc_spec	*(char)
==	O
NULL	O
||	O
directory	*(char)
==	O
NULL	O
||	O
strlen	(*(char))->(long)
(	O
directory	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
directory	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
directory	*(char)
,	O
":"	*(char)
)	O
==	O
0	int
||	O
(	O
*	O
soc_spec	*(char)
==	O
'.'	O
&&	O
*	O
directory	*(char)
==	O
'.'	O
)	O
||	O
(	O
*	O
soc_spec	*(char)
==	O
'-'	O
)	O
||	O
is_fq	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
||	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"returning doing nothing"	*(char)
)	O
;	O
E_DEBUG	O
(	O
"LEAVING retval=0"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
E_DEBUG3	O
(	O
"soc_spec=%s directory=%s"	*(char)
,	O
soc_spec	*(char)
,	O
directory	*(char)
)	O
;	O
retval	int
=	O
0	int
;	O
if	O
(	O
(	O
is_host	(*(char))->(int)
(	O
directory	*(char)
)	O
&&	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
)	O
||	O
(	O
is_host	(*(char))->(int)
(	O
directory	*(char)
)	O
==	O
0	int
&&	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
==	O
0	int
)	O
||	O
0	int
)	O
{	O
;	O
E_DEBUG3	O
(	O
"directory: is_host(%s)=%d"	*(char)
,	O
directory	*(char)
,	O
is_host	(*(char))->(int)
(	O
directory	*(char)
)	O
)	O
;	O
E_DEBUG3	O
(	O
"soc_spec:  is_host(%s)=%d"	*(char)
,	O
soc_spec	*(char)
,	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
)	O
;	O
E_DEBUG	O
(	O
"AMBIG retval=-1"	*(char)
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
strlen	(*(char))->(long)
(	O
soc_spec	*(char)
)	O
>	O
1	int
&&	O
*	O
soc_spec	*(char)
==	O
':'	O
)	O
||	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
directory	*(char)
,	O
':'	O
)	O
)	O
{	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
if	O
(	O
directory	*(char)
[	O
strlen	(*(char))->(long)
(	O
directory	*(char)
)	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
"/"	*(char)
)	O
;	O
}	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
+	O
1	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
)	O
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
soc_spec	*(char)
,	O
'/'	O
)	O
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
E_DEBUG	O
(	O
"LEAVING retval=-1"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strlen	(*(char))->(long)
(	O
soc_spec	*(char)
)	O
>=	O
1	int
&&	O
*	O
soc_spec	*(char)
==	O
'/'	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
directory	*(char)
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
directory	*(char)
!=	O
'/'	O
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
"@"	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
":"	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
*	O
soc_spec	*(char)
!=	O
':'	O
&&	O
*	O
soc_spec	*(char)
!=	O
'/'	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
soc_spec	*(char)
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
directory	*(char)
==	O
'/'	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
directory	*(char)
,	O
':'	O
)	O
==	O
NULL	O
&&	O
strlen	(*(char))->(long)
(	O
directory	*(char)
)	O
>	O
0	int
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
soc_spec	*(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
soc_spec	*(char)
)	O
>	O
0	int
)	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
":"	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
result	*(int)
,	O
directory	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
is_host	(*(char))->(int)
(	O
directory	*(char)
)	O
&&	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
&&	O
has_file_part	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
==	O
0	int
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
combine1	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(void)
(	O
result	*(int)
,	O
directory	*(char)
,	O
soc_spec	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
is_host	(*(char))->(int)
(	O
directory	*(char)
)	O
&&	O
!	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	*(char)
)	O
;	O
combine1	(*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char))->(void)
(	O
result	*(int)
,	O
soc_spec	*(char)
,	O
directory	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
is_host	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
&&	O
has_file_part	(*(char))->(int)
(	O
soc_spec	*(char)
)	O
&&	O
1	int
)	O
{	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"null case"	*(char)
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"result=%s"	*(char)
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
result	*(int)
)	O
)	O
;	O
E_DEBUG2	O
(	O
"returning with value %d"	*(char)
,	O
retval	int
)	O
;	O
E_DEBUG2	O
(	O
"LEAVING retval=%d"	*(char)
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swextopt_get_status	()->(int)
(	O
void	O
)	O
{	O
E_DEBUG	O
(	O
""	*(char)
)	O
;	O
return	O
swextopt_statusG	int
;	O
}	O
