struct	O
lockdef	struct(*(char),*(char))
{	O
char	O
const	O
*	O
login	*(char)
;	O
char	O
const	O
*	O
revno	*(char)
;	O
}	O
;	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
{	O
char	O
const	O
*	O
revno	*(char)
;	O
char	O
const	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
link	(*(char),*(char))->(int)
*	O
branches	*(struct)
;	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
*	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
}	O
;	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
{	O
int	O
c	int
;	O
struct	O
fro	struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long)
*	O
from	*(struct)
;	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
;	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
;	O
struct	O
cbuf	struct(*(char),long)
xrep	struct(*(char),long)
;	O
size_t	long
lno	long
;	O
size_t	long
head_lno	long
;	O
struct	O
cbuf	struct(*(char),long)
bor_no	struct(*(char),long)
;	O
}	O
;	O
static	O
void	O
ignoble	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	*(*(char))
;	O
struct	O
cbuf	struct(*(char),long)
msg	struct(*(char),long)
;	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
scratch	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
scratch	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
->	O
space	*(struct)
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
obstack_finish	O
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
)	O
;	O
va_start	O
(	O
args	*(*(char))
,	O
fmt	*(char)
)	O
;	O
obstack_vprintf	(*(struct),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
fmt	*(char)
,	O
args	*(*(char))
)	O
;	O
va_end	O
(	O
args	*(*(char))
)	O
;	O
msg	struct(*(char),long)
.	O
string	*(char)
=	O
finish_string	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(long))->(*(char))
(	O
scratch	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
&	O
msg	struct(*(char),long)
.	O
size	long
)	O
;	O
complain	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
fatal_syntax	(long,*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
,	O
"%s"	*(char)
,	O
msg	struct(*(char),long)
.	O
string	*(char)
)	O
;	O
}	O
static	O
void	O
eof_too_soon	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
{	O
BUMMER	O
(	O
"unexpected end of file"	*(char)
)	O
;	O
}	O
static	O
void	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
++	O
;	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
return	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
}	O
static	O
void	O
must_read_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
struct	O
tinysym	struct(char,array(char))
const	O
*	O
kw	*(struct(char,array(char)))
)	O
{	O
CBEG	O
(	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
)	O
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
kw	*(struct(char,array(char)))
->	O
len	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
[	O
i	int
]	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
BUMMER	O
(	O
"missing `%s' keyword"	*(char)
,	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
;	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
=	O
kw	*(struct(char,array(char)))
->	O
len	char
;	O
CEND	O
(	O
)	O
;	O
}	O
static	O
bool	bool
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
struct	O
tinysym	struct(char,array(char))
const	O
*	O
kw	*(struct(char,array(char)))
)	O
{	O
off_t	long
was	long
;	O
bool	bool
rv	bool
=	O
true	int
;	O
CBEG	O
(	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
)	O
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
was	long
=	O
fro_tello	(*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(long)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
kw	*(struct(char,array(char)))
->	O
len	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
rv	bool
=	O
(	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
[	O
i	int
]	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
)	O
break	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
if	O
(	O
rv	bool
)	O
{	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
TINYS	O
(	O
kw	*(struct(char,array(char)))
)	O
;	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
=	O
kw	*(struct(char,array(char)))
->	O
len	char
;	O
}	O
else	O
{	O
fro_move	(*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)),long)->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
,	O
was	long
-	O
1	int
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
return	O
rv	bool
;	O
}	O
static	O
void	O
accb	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
{	O
accumulate_byte	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),int)->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
static	O
bool	bool
maybe_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),bool)->(bool)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
bool	bool
must_be_delta_p	bool
)	O
{	O
char	O
*	O
p	*(char)
;	O
size_t	long
dots	long
=	O
0	int
;	O
CBEG	O
(	O
"num"	*(char)
)	O
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
while	O
(	O
'.'	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
||	O
isdigit	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
{	O
if	O
(	O
must_be_delta_p	bool
)	O
dots	long
+=	O
(	O
'.'	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
;	O
accb	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
p	*(char)
=	O
finish_string	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(long))->(*(char))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
)	O
;	O
CEND	O
(	O
)	O
;	O
if	O
(	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
)	O
{	O
bool	bool
trailing_garbage	bool
=	O
(	O
';'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
&&	O
!	O
isspace	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
;	O
if	O
(	O
trailing_garbage	bool
)	O
{	O
accs	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(char)
)	O
;	O
while	O
(	O
';'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
&&	O
!	O
isspace	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
accb	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
p	*(char)
=	O
finish_string	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(long))->(*(char))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
)	O
;	O
}	O
if	O
(	O
trailing_garbage	bool
||	O
(	O
must_be_delta_p	bool
&&	O
!	O
(	O
1	int
&	O
dots	long
)	O
)	O
)	O
BUMMER	O
(	O
"invalid %s: %s"	*(char)
,	O
ks_revno	array(char)
,	O
p	*(char)
)	O
;	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
p	*(char)
;	O
return	O
true	int
;	O
}	O
brush_off	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(void))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(char)
)	O
;	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
""	*(char)
;	O
return	O
false	int
;	O
}	O
static	O
void	O
must_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
char	O
const	O
*	O
role	*(char)
)	O
{	O
if	O
(	O
!	O
maybe_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),bool)->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
ks_revno	array(char)
==	O
role	*(char)
)	O
)	O
BUMMER	O
(	O
"missing %s"	*(char)
,	O
role	*(char)
)	O
;	O
}	O
static	O
bool	bool
maybe_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(bool)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
{	O
char	O
*	O
p	*(char)
;	O
CBEG	O
(	O
"snippet"	*(char)
)	O
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
while	O
(	O
';'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
&&	O
':'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
&&	O
!	O
isspace	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
&&	O
UNKN	int
!=	O
ctab	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
]	O
)	O
accb	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
p	*(char)
=	O
finish_string	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(long))->(*(char))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
)	O
;	O
CEND	O
(	O
)	O
;	O
if	O
(	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
)	O
{	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
p	*(char)
;	O
return	O
true	int
;	O
}	O
brush_off	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(void))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(char)
)	O
;	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
=	O
""	*(char)
;	O
return	O
false	int
;	O
}	O
static	O
void	O
must_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
char	O
const	O
*	O
role	*(char)
)	O
{	O
if	O
(	O
!	O
maybe_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
)	O
BUMMER	O
(	O
"missing %s"	*(char)
,	O
role	*(char)
)	O
;	O
}	O
static	O
void	O
start_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),bool)->(void)
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
bool	bool
blankp	bool
)	O
{	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
->	O
space	*(struct)
;	O
if	O
(	O
blankp	bool
)	O
obstack_blank	O
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
sizeof	O
(	O
struct	O
atat	*(struct)
)	O
)	O
;	O
}	O
static	O
struct	O
atat	*(struct)
*	O
finish_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(long,long,long,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),long,array(long))))
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
struct	O
atat	*(struct)
*	O
rv	bool
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
->	O
space	*(struct)
;	O
size_t	long
hsize	long
=	O
obstack_object_size	O
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
-	O
sizeof	O
(	O
struct	O
atat	*(struct)
)	O
;	O
rv	bool
=	O
obstack_finish	O
(	O
o	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
rv	bool
->	O
count	long
=	O
hsize	long
/	O
sizeof	O
(	O
off_t	long
)	O
;	O
return	O
rv	bool
;	O
}	O
static	O
bool	bool
maybe_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))))->(bool)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
struct	O
atat	*(struct)
*	O
*	O
res	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
struct	O
atat	*(struct)
*	O
atat	*(struct)
;	O
off_t	long
beg	*(char)
;	O
size_t	long
lno_start	long
;	O
bool	bool
newlinep	bool
=	O
false	int
;	O
CBEG	O
(	O
"atat"	*(char)
)	O
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
lno_start	long
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
;	O
beg	*(char)
=	O
POS	O
(	O
-	O
1	int
)	O
;	O
start_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),bool)->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
true	int
)	O
;	O
while	O
(	O
SDELIM	char
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
{	O
off_t	long
hole	long
;	O
bool	bool
needexp	bool
=	O
false	int
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
while	O
(	O
SDELIM	char
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
{	O
if	O
(	O
WITH_NEEDEXP	int
&&	O
KDELIM	char
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
needexp	bool
=	O
true	int
;	O
else	O
if	O
(	O
(	O
newlinep	bool
=	O
(	O
'\n'	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
)	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
++	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
hole	long
=	O
(	O
needexp	bool
?	O
MASK_OFFMSB	O
:	O
0	int
)	O
|	O
POS	O
(	O
SDELIM	char
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
?	O
-	O
1	int
:	O
-	O
2	int
)	O
;	O
obstack_grow	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
->	O
space	*(struct)
,	O
&	O
hole	long
,	O
sizeof	O
(	O
hole	long
)	O
)	O
;	O
}	O
if	O
(	O
(	O
atat	*(struct)
=	O
finish_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(long,long,long,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),long,array(long))))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
)	O
)	O
)	O
{	O
size_t	long
count	long
=	O
atat	*(struct)
->	O
count	long
;	O
atat	*(struct)
->	O
lno	long
=	O
lno_start	long
;	O
atat	*(struct)
->	O
line_count	long
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
-	O
atat	*(struct)
->	O
lno	long
+	O
!	O
newlinep	bool
;	O
atat	*(struct)
->	O
beg	*(char)
=	O
beg	*(char)
;	O
atat	*(struct)
->	O
from	*(struct)
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
;	O
start_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),bool)->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
false	int
)	O
;	O
*	O
res	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
obstack_copy	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
->	O
space	*(struct)
,	O
atat	*(struct)
,	O
(	O
sizeof	O
(	O
struct	O
atat	*(struct)
)	O
+	O
count	long
*	O
sizeof	O
(	O
off_t	long
)	O
)	O
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
return	O
atat	*(struct)
;	O
}	O
static	O
void	O
must_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
struct	O
atat	*(struct)
*	O
*	O
res	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
const	O
*	O
role	*(char)
)	O
{	O
if	O
(	O
!	O
maybe_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
res	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
BUMMER	O
(	O
"missing %s"	*(char)
,	O
role	*(char)
)	O
;	O
}	O
static	O
void	O
must_colon_revno	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
char	O
const	O
*	O
role	*(char)
)	O
{	O
CBEG	O
(	O
role	*(char)
)	O
;	O
CBEG	O
(	O
"colon"	*(char)
)	O
;	O
if	O
(	O
':'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
BUMMER	O
(	O
"missing ':' in %s"	*(char)
,	O
role	*(char)
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
CEND	O
(	O
)	O
;	O
must_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
bor_no	struct(*(char),long)
.	O
string	*(char)
)	O
;	O
CEND	O
(	O
)	O
;	O
}	O
static	O
void	O
must_semi	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
char	O
const	O
*	O
clause	*(char)
)	O
{	O
size_t	long
was	long
;	O
was	long
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
;	O
skip_whitespace	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
if	O
(	O
';'	O
!=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
BUMMER	O
(	O
"missing semicolon after `%s'"	*(char)
,	O
clause	*(char)
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
}	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
{	O
size_t	long
sz	long
;	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
*	O
a	*(*(struct(*(void),*(struct(*`,*`)))))
;	O
}	O
;	O
static	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
*	O
make_hash_table	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),long)->(*(struct(long,*(*(struct`)))))
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
size_t	long
sz	long
)	O
{	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
*	O
ht	*(struct)
=	O
alloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"hash-table"	*(char)
,	O
sizeof	O
(	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
)	O
)	O
;	O
ht	*(struct)
->	O
sz	long
=	O
sz	long
;	O
ht	*(struct)
->	O
a	*(*(struct(*(void),*(struct(*`,*`)))))
=	O
zlloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"hash-table buckets"	*(char)
,	O
sz	long
*	O
sizeof	O
(	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
)	O
)	O
;	O
return	O
ht	*(struct)
;	O
}	O
static	O
size_t	long
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
(	O
char	O
const	O
*	O
key	*(char)
,	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
*	O
ht	*(struct)
)	O
{	O
return	O
hash_pjw	(*(void),long)->(long)
(	O
key	*(char)
,	O
ht	*(struct)
->	O
sz	long
)	O
;	O
}	O
static	O
void	O
puthash	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(*(char),*(char),*(struct(*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,struct`,*`,*`,*`,bool,long)))),*(struct(long,*(*(struct`)))))->(void)
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
*	O
ht	*(struct)
)	O
{	O
size_t	long
slot	long
=	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
,	O
ht	*(struct)
)	O
;	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
,	O
*	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
*	O
cur	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ht	*(struct)
->	O
a	*(*(struct(*(void),*(struct(*`,*`)))))
[	O
slot	long
]	O
;	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
&	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
;	O
while	O
(	O
(	O
cur	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
maybe	struct(*((*(struct(*((*`)->(*`)),bool,struct(*`,long),*(struct`),struct(*`,long),*(struct`),int)))->(*(struct))),bool,struct(*(char),long),*(struct),struct(*(char),long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int)
=	O
cur	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
;	O
if	O
(	O
STR_SAME	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
,	O
maybe	struct(*((*(struct(*((*`)->(*`)),bool,struct(*`,long),*(struct`),struct(*`,long),*(struct`),int)))->(*(struct))),bool,struct(*(char),long),*(struct),struct(*(char),long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int)
->	O
revno	*(char)
)	O
)	O
{	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
return	O
;	O
}	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
wextend	(*(struct(*(void),*(struct(*`,*`)))),*(void),*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ht	*(struct)
->	O
a	*(*(struct(*(void),*(struct(*`,*`)))))
[	O
slot	long
]	O
=	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
static	O
void	O
*	O
gethash	(*(char),*(struct(long,*(*(struct`)))))->(*(void))
(	O
char	O
const	O
*	O
revno	*(char)
,	O
struct	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
*	O
ht	*(struct)
)	O
{	O
size_t	long
slot	long
=	O
hash	struct(long,*(*(struct(*(void),*(struct(*`,*`))))))
(	O
revno	*(char)
,	O
ht	*(struct)
)	O
;	O
for	O
(	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ht	*(struct)
->	O
a	*(*(struct(*(void),*(struct(*`,*`)))))
[	O
slot	long
]	O
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
;	O
if	O
(	O
STR_SAME	O
(	O
revno	*(char)
,	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
)	O
)	O
return	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
fwref	struct(*(char),long)
{	O
char	O
const	O
*	O
revno	*(char)
;	O
size_t	long
lno	long
;	O
}	O
;	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
empty_repo	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct),*(struct))))
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
=	O
zlloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"repo"	*(char)
,	O
sizeof	O
(	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
)	O
)	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
strict	bool
=	O
STRICT_LOCKING	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
expand	int
=	O
-	O
1	int
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
neck	long
=	O
-	O
1	int
;	O
return	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
;	O
}	O
static	O
const	O
char	O
ks_ner	array(char)
[	O
]	O
=	O
"non-existent revision"	*(char)
;	O
static	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
full	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct(*`,*`)),*(struct(long,*`)))))
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
fro	struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long)
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
off_t	long
neck	long
;	O
size_t	long
count	long
;	O
struct	O
link	(*(char),*(char))->(int)
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
,	O
*	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
follow	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
*	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
=	O
FZLLOC	O
(	O
struct	O
grok	struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct`))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long)),struct(*(char),long),long,long,struct(*(char),long))
)	O
;	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
=	O
empty_repo	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct),*(struct))))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
ht	*(struct)
=	O
make_hash_table	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),long)->(*(struct(long,*(*(struct`)))))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NSLOTS	int
)	O
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
=	O
make_space	(array(char))->(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))
(	O
"systolic"	*(char)
)	O
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
=	O
make_space	(array(char))->(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))
(	O
"tranquil"	*(char)
)	O
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
=	O
1	int
;	O
accf	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
"branch or %s"	*(char)
,	O
ks_revno	array(char)
)	O
;	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
bor_no	struct(*(char),long)
.	O
string	*(char)
=	O
finish_string	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(long))->(*(char))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
&	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
bor_no	struct(*(char),long)
.	O
size	long
)	O
;	O
MORE	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
CBEG	O
(	O
"admin node"	*(char)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
head	*(char)
)	O
;	O
if	O
(	O
MAYBE_REVNO	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
)	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
head_lno	long
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
,	O
STASH	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
head	*(char)
)	O
;	O
if	O
(	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
branch	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
maybe_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),bool)->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
false	int
)	O
)	O
STASH	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
branch	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
branch	*(char)
)	O
;	O
}	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
access	*(struct)
)	O
;	O
for	O
(	O
PREP	O
(	O
access	*(struct)
)	O
;	O
maybe_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
count	long
++	O
)	O
HANG	O
(	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
)	O
;	O
DONE	O
(	O
access	*(struct)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
access	*(struct)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
symbols	*(struct)
)	O
;	O
for	O
(	O
PREP	O
(	O
symbols	*(struct)
)	O
;	O
maybe_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
symdef	struct(*(char),*(char))
*	O
sym	*(struct(char,array(char)))
=	O
STRUCTALLOC	O
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
symdef	struct(*(char),*(char))
)	O
;	O
STASH	O
(	O
sym	*(struct(char,array(char)))
->	O
meaningful	*(char)
)	O
;	O
must_colon_revno	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
"symbolic name definition"	*(char)
)	O
;	O
STASH	O
(	O
sym	*(struct(char,array(char)))
->	O
underlying	*(char)
)	O
;	O
HANG	O
(	O
sym	*(struct(char,array(char)))
)	O
;	O
}	O
DONE	O
(	O
symbols	*(struct)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
symbols	*(struct)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
locks	*(struct)
)	O
;	O
for	O
(	O
PREP	O
(	O
locks	*(struct)
)	O
;	O
maybe_read_snippet	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
lockdef	struct(*(char),*(char))
*	O
lock	*(struct(*(char),*(char)))
=	O
STRUCTALLOC	O
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
lockdef	struct(*(char),*(char))
)	O
;	O
STASH	O
(	O
lock	*(struct(*(char),*(char)))
->	O
login	*(char)
)	O
;	O
must_colon_revno	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
"locker definition"	*(char)
)	O
;	O
STASH	O
(	O
lock	*(struct(*(char),*(char)))
->	O
revno	*(char)
)	O
;	O
HANG	O
(	O
lock	*(struct(*(char),*(char)))
)	O
;	O
}	O
DONE	O
(	O
locks	*(struct)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
locks	*(struct)
)	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
=	O
alloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"locker definition"	*(char)
,	O
count	long
*	O
sizeof	O
(	O
struct	O
lockdef	struct(*(char),*(char))
)	O
)	O
;	O
for	O
(	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks	*(struct)
;	O
count	long
--	O
;	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
struct	O
lockdef	struct(*(char),*(char))
const	O
*	O
orig	*(struct(*(char),*(char)))
=	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
[	O
count	long
]	O
=	O
*	O
orig	*(struct(*(char),*(char)))
;	O
}	O
if	O
(	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
strict	bool
=	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
strict	bool
)	O
)	O
)	O
)	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
strict	bool
)	O
;	O
if	O
(	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
integrity	*(struct)
)	O
)	O
)	O
{	O
maybe_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
integrity	*(struct)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
integrity	*(struct)
)	O
;	O
}	O
if	O
(	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
comment	*(struct)
)	O
)	O
)	O
{	O
maybe_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
comment	*(struct)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
comment	*(struct)
)	O
;	O
}	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
expand	int
=	O
-	O
1	int
;	O
if	O
(	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
expand	int
)	O
)	O
)	O
{	O
struct	O
atat	*(struct)
*	O
expand	int
;	O
if	O
(	O
maybe_read_atat	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(*(struct(long,long,long,*(struct`),long,array(long)))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
expand	int
)	O
)	O
{	O
struct	O
cbuf	struct(*(char),long)
cb	*(struct(*(char),long))
=	O
string_from_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(long,long,long,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),long,array(long))))->(struct(*(char),long))
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
expand	int
)	O
;	O
if	O
(	O
PROB	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
expand	int
=	O
recognize_kwsub	(*(struct(*(char),long)))->(int)
(	O
&	O
cb	*(struct(*(char),long))
)	O
)	O
)	O
BUMMER	O
(	O
"invalid expand mode: %s"	*(char)
,	O
cb	*(struct(*(char),long))
.	O
string	*(char)
)	O
;	O
}	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
expand	int
)	O
;	O
}	O
CBEG	O
(	O
"revisions"	*(char)
)	O
;	O
{	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
,	O
*	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
prev	struct(bool,*(char),*(char),*(char),*(char),*(char))
=	O
NULL	O
;	O
struct	O
fwref	struct(*(char),long)
*	O
fw	*(struct(*(char),long))
;	O
for	O
(	O
count	long
=	O
0	int
,	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas	*(struct)
,	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
&	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
;	O
MAYBE_REVNO	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
STRUCTALLOC	O
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
)	O
;	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
*	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
STRUCTALLOC	O
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
)	O
;	O
size_t	long
numlen	long
=	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
;	O
STASH	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
)	O
;	O
if	O
(	O
prev	struct(bool,*(char),*(char),*(char),*(char),*(char))
&&	O
!	O
prev	struct(bool,*(char),*(char),*(char),*(char),*(char))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
&&	O
2	int
<=	O
countnumflds	(*(char))->(int)
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
)	O
)	O
{	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
if	O
(	O
(	O
fw	*(struct(*(char),long))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
)	O
->	O
lno	long
&&	O
STR_SAME	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
,	O
fw	*(struct(*(char),long))
->	O
revno	*(char)
)	O
)	O
{	O
fw	*(struct(*(char),long))
->	O
lno	long
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
BUMMER	O
(	O
"unexpected new branch %s: %s"	*(char)
,	O
ks_revno	array(char)
,	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
)	O
;	O
}	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
branches	*(struct)
=	O
NULL	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
ilk	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
NULL	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
lockedby	*(char)
=	O
NULL	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
pretty_log	struct(*(char),long)
.	O
string	*(char)
=	O
NULL	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
pretty_log	struct(*(char),long)
.	O
size	long
=	O
0	int
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
selector	bool
=	O
true	int
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
log	*(struct)
=	O
NULL	O
;	O
STASH	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
)	O
;	O
CBEG	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
date	*(char)
)	O
;	O
must_read_num	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
"date"	*(char)
)	O
;	O
STASH	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
date	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
date	*(char)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
author	*(char)
)	O
;	O
MUST_SNIPPET	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
author	*(char)
)	O
;	O
STASH	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
author	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
author	*(char)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
state	*(char)
)	O
;	O
MUST_SNIPPET	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
state	*(char)
)	O
;	O
STASH	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
state	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
state	*(char)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
branches	*(struct)
)	O
;	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
,	O
tp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
&	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
;	O
while	O
(	O
MAYBE_REVNO	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
)	O
{	O
if	O
(	O
numlen	long
>=	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
size	long
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
,	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
,	O
numlen	long
)	O
||	O
'.'	O
!=	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
[	O
numlen	long
]	O
||	O
2	int
!=	O
countnumflds	(*(char))->(int)
(	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
+	O
numlen	long
+	O
1	int
)	O
)	O
BUMMER	O
(	O
"invalid branch `%s' at branchpoint `%s'"	*(char)
,	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
,	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
)	O
;	O
fw	*(struct(*(char),long))
=	O
STRUCTALLOC	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
,	O
struct	O
fwref	struct(*(char),long)
)	O
;	O
fw	*(struct(*(char),long))
->	O
revno	*(char)
=	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
;	O
fw	*(struct(*(char),long))
->	O
lno	long
=	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
;	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
wprepend	(*(void),*(struct(*(void),*(struct(*`,*`)))),*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
fw	*(struct(*(char),long))
,	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
)	O
;	O
HANG	O
(	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
)	O
;	O
}	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
branches	*(struct)
=	O
box	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
branches	*(struct)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
MAYBE_REVNO	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
)	O
STASH	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
else	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
probe_keyword	(*(struct(int,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),*(struct(*`,*`,*`,long)),struct(*(char),long),long,long,struct(*(char),long))),*(struct(char,array(char))))->(bool)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
TINY	O
(	O
commitid	*(char)
)	O
)	O
)	O
{	O
MUST_SNIPPET	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
commitid	*(char)
)	O
;	O
STASH	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
commitid	*(char)
)	O
;	O
checkssym	(*(char))->(void)
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
commitid	*(char)
)	O
;	O
SEMI	int
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
commitid	*(char)
)	O
;	O
}	O
else	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
commitid	*(char)
=	O
NULL	O
;	O
CEND	O
(	O
)	O
;	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
wextend	(*(struct(*(void),*(struct(*`,*`)))),*(void),*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
puthash	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(*(char),*(char),*(struct(*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,struct`,*`,*`,*`,bool,long)))),*(struct(long,*(*(struct`)))))->(void)
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
ht	*(struct)
)	O
;	O
prev	struct(bool,*(char),*(char),*(char),*(char),*(char))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
}	O
for	O
(	O
;	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
if	O
(	O
(	O
fw	*(struct(*(char),long))
=	O
all_br	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
)	O
->	O
lno	long
)	O
{	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
=	O
fw	*(struct(*(char),long))
->	O
lno	long
;	O
BUMMER	O
(	O
"branch refers to %s `%s'"	*(char)
,	O
ks_ner	array(char)
,	O
fw	*(struct(*(char),long))
->	O
revno	*(char)
)	O
;	O
}	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas	*(struct)
=	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas_count	long
=	O
count	long
;	O
}	O
CEND	O
(	O
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
desc	*(struct)
)	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
neck	long
=	O
fro_tello	(*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(long)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
)	O
;	O
MUST_ATAT	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
desc	*(struct)
,	O
desc	*(struct)
)	O
;	O
CEND	O
(	O
)	O
;	O
for	O
(	O
struct	O
lockdef	struct(*(char),*(char))
const	O
*	O
lock	*(struct(*(char),*(char)))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
;	O
lock	*(struct(*(char),*(char)))
<	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
+	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks_count	long
;	O
lock	*(struct(*(char),*(char)))
++	O
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
FIND_NY	O
(	O
lock	*(struct(*(char),*(char)))
->	O
revno	*(char)
)	O
;	O
if	O
(	O
!	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
)	O
{	O
RWARN	O
(	O
"user `%s' holds a lock for %s `%s'"	*(char)
,	O
lock	*(struct(*(char),*(char)))
->	O
login	*(char)
,	O
ks_ner	array(char)
,	O
lock	*(struct(*(char),*(char)))
->	O
revno	*(char)
)	O
;	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
zlloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dummy ny"	*(char)
,	O
sizeof	O
(	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
)	O
)	O
;	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
zlloc	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(char),long)->(*(void))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"dummy delta"	*(char)
,	O
sizeof	O
(	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
)	O
)	O
;	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
revno	*(char)
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
=	O
lock	*(struct(*(char),*(char)))
->	O
revno	*(char)
;	O
puthash	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(*(char),*(char),*(struct(*`,*`)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,struct`,*`,*`,*`,bool,long)))),*(struct(long,*(*(struct`)))))->(void)
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
ht	*(struct)
)	O
;	O
}	O
}	O
CBEG	O
(	O
"edits"	*(char)
)	O
;	O
for	O
(	O
count	long
=	O
0	int
,	O
follow	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas	*(struct)
;	O
(	O
neck	long
=	O
fro_tello	(*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(long)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
)	O
)	O
&&	O
count	long
<	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas_count	long
;	O
count	long
++	O
)	O
{	O
char	O
const	O
*	O
revno	*(char)
;	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
*	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
MUST_REVNO	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
;	O
revno	*(char)
=	O
XREP	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
)	O
.	O
string	*(char)
;	O
CBEG	O
(	O
revno	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
FIND_NY	O
(	O
revno	*(char)
)	O
)	O
)	O
BUMMER	O
(	O
"found edits for %s `%s'"	*(char)
,	O
ks_ner	array(char)
,	O
revno	*(char)
)	O
;	O
follow	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
follow	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
follow	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
if	O
(	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
log	*(struct)
)	O
BUMMER	O
(	O
"duplicate delta log for %s `%s'"	*(char)
,	O
ks_revno	array(char)
,	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
num	*(char)
)	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
neck	long
=	O
neck	long
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
log	*(struct)
)	O
;	O
MUST_ATAT	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
log	*(struct)
,	O
log	*(struct)
)	O
;	O
SYNCH	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
text	*(struct)
)	O
;	O
MUST_ATAT	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
,	O
&	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
text	*(struct)
,	O
text	*(struct)
)	O
;	O
CEND	O
(	O
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
CBEG	O
(	O
"clean tail"	*(char)
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
lno	long
++	O
;	O
GETCHAR_OR	O
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
,	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
from	*(struct)
,	O
goto	O
ok	O
)	O
;	O
}	O
BUMMER	O
(	O
"junk at end of file: '%c'"	*(char)
,	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
c	int
)	O
;	O
ok	O
:	O
CEND	O
(	O
)	O
;	O
if	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
&&	O
!	O
FIND_NY	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
)	O
)	O
fatal_syntax	(long,*(char))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
head_lno	long
,	O
"RCS file head names a %s `%s'"	*(char)
,	O
ks_ner	array(char)
,	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
)	O
;	O
for	O
(	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
deltas	*(struct)
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
,	O
*	O
deref	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
*	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
if	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
ilk	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
FIND_D	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
branches	*(struct)
)	O
{	O
struct	O
link	(*(char),*(char))->(int)
*	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
wlink	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
,	O
*	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
branches	*(struct)
,	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
branches	*(struct)
,	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
&	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
;	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
wextend	(*(struct(*(void),*(struct(*`,*`)))),*(void),*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
wtp	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
FIND_D	O
(	O
bls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
)	O
,	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
branches	*(struct)
=	O
wbox	struct(*(void),*(struct(*(void),*(struct(*`,*`)))))
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
ls	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
entry	*(void)
=	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
}	O
close_space	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
systolic	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
)	O
;	O
close_space	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(void)
(	O
g	*(struct(int,*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),*(struct(*(char),*(struct`),*(void),long)),struct(*(char),long),long,long,struct(*(char),long)))
->	O
tranquil	*(struct(*(char),*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void),long))
)	O
;	O
return	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
;	O
}	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
grok_all	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct),*(struct))))
(	O
struct	O
divvy	struct(*(char),*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int)),*(void),long)
*	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
fro	struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct`),long)))->(void)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),long)
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
=	O
full	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(int,long,enum(int,int,int),*(char),*(char),*(char),*((*`)->(void)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),long)))->(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct(*`,*`)),*(struct(long,*`)))))
(	O
to	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
grok_resynch	(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct),*(struct))))->(void)
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
)	O
;	O
return	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
;	O
}	O
void	O
grok_resynch	(*(struct(*(char),*(char),long,*(struct(*`,*`)),long,*(struct(*`,*`)),long,*(struct(*`,*`)),bool,*(struct(long,long,long,*`,long,array(long))),*(struct(long,long,long,*`,long,array(long))),int,long,*(struct(*`,*`)),*(struct(long,long,long,*`,long,array(long))),long,*(struct),*(struct))))->(void)
(	O
struct	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
*	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
)	O
{	O
struct	O
notyet	struct(*(char),*(char),*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
;	O
REPO	O
(	O
tip	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
)	O
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
&&	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
FIND_NY	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
head	*(char)
)	O
)	O
?	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
:	O
NULL	O
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks	*(struct)
=	O
NULL	O
;	O
for	O
(	O
struct	O
lockdef	struct(*(char),*(char))
const	O
*	O
orig	*(struct(*(char),*(char)))
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
+	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks_count	long
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
lockdefs	*(struct)
<	O
orig	*(struct(*(char),*(char)))
--	O
&&	O
(	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
FIND_NY	O
(	O
orig	*(struct(*(char),*(char)))
->	O
revno	*(char)
)	O
)	O
;	O
)	O
{	O
struct	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
*	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
=	O
ny	*(struct(*(char),*(char),*(struct(*(void),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
struct	O
rcslock	struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
*	O
rl	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
=	O
FALLOC	O
(	O
struct	O
rcslock	struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)))
)	O
;	O
rl	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
login	*(char)
=	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
->	O
lockedby	*(char)
=	O
orig	*(struct(*(char),*(char)))
->	O
login	*(char)
;	O
rl	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
->	O
delta	struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct),*(struct),*(char),struct(*(char),long),*(struct),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long)),bool,long)
=	O
d	*(struct(*(char),*(char),*(char),*(char),*(char),*(struct(long,long,long,*(struct`),long,array(long))),*(struct(long,long,long,*(struct`),long,array(long))),*(char),struct(*(char),long),*(struct(*(void),*(struct`))),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long)),bool,long))
;	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks	*(struct)
=	O
prepend	(*(void),*(struct(*(void),*(struct(*`,*`)))),*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
rl	*(struct(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),*(char),struct(*`,long),*(struct`),*(char),*(struct`),bool,long))))
,	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
locks	*(struct)
,	O
SINGLE	O
)	O
;	O
}	O
BE	O
(	O
strictly_locking	bool
)	O
=	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
strict	bool
;	O
if	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
comment	*(struct)
)	O
REPO	O
(	O
log_lead	struct(*(char),long)
)	O
=	O
string_from_atat	(*(struct(*(char),*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),*(void),long)),*(struct(long,long,long,*(struct(int,long,enum(int,int,int),*`,*`,*`,*`,*`,long)),long,array(long))))->(struct(*(char),long))
(	O
SINGLE	O
,	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
comment	*(struct)
)	O
;	O
else	O
clear_buf	O
(	O
&	O
REPO	O
(	O
log_lead	struct(*(char),long)
)	O
)	O
;	O
BE	O
(	O
kws	int
)	O
=	O
PROB	O
(	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
expand	int
)	O
?	O
kwsub_kv	int
:	O
repo	struct(*(char),*(char),long,*(struct),long,*(struct),long,*(struct),bool,*(struct),*(struct),int,long,*(struct),*(struct),long,*(struct),*(struct))
->	O
expand	int
;	O
}	O
