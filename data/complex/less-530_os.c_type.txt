public	O
int	O
reading	int
;	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
read_label	array(struct(array(long),int,struct(array(long))))
;	O
extern	O
int	O
sigs	int
;	O
public	O
int	O
iread	(int,*(char),int)->(int)
(	O
fd	int
,	O
buf	*(char)
,	O
len	int
)	O
int	O
fd	int
;	O
unsigned	O
char	O
*	O
buf	*(char)
;	O
unsigned	O
int	O
len	int
;	O
{	O
int	O
n	int
;	O
start	O
:	O
if	O
(	O
SET_JUMP	O
(	O
read_label	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
reading	int
=	O
0	int
;	O
{	O
sigset_t	struct(array(long))
mask	struct(array(long))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
mask	struct(array(long))
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
mask	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
READ_INTR	O
)	O
;	O
}	O
flush	()->(void)
(	O
)	O
;	O
reading	int
=	O
1	int
;	O
n	int
=	O
read	(int,*(void),long)->(long)
(	O
fd	int
,	O
buf	*(char)
,	O
len	int
)	O
;	O
{	O
extern	O
int	O
ignore_eoi	int
;	O
if	O
(	O
!	O
ignore_eoi	int
)	O
{	O
static	O
int	O
consecutive_nulls	int
=	O
0	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
consecutive_nulls	int
++	O
;	O
else	O
consecutive_nulls	int
=	O
0	int
;	O
if	O
(	O
consecutive_nulls	int
>	O
20	int
)	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
}	O
reading	int
=	O
0	int
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
goto	O
start	O
;	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
goto	O
start	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
n	int
)	O
;	O
}	O
public	O
void	O
intread	()->(void)
(	O
)	O
{	O
LONG_JUMP	O
(	O
read_label	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
public	O
time_type	O
get_time	()->(long)
(	O
)	O
{	O
time_type	O
t	long
;	O
time	(*(long))->(long)
(	O
&	O
t	long
)	O
;	O
return	O
(	O
t	long
)	O
;	O
}	O
public	O
char	O
*	O
errno_message	(*(char))->(*(char))
(	O
filename	*(char)
)	O
char	O
*	O
filename	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
m	*(char)
;	O
int	O
len	int
;	O
p	*(char)
=	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
;	O
len	int
=	O
(	O
int	O
)	O
(	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
+	O
3	int
)	O
;	O
m	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
len	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
SNPRINTF2	O
(	O
m	*(char)
,	O
len	int
,	O
"%s: %s"	*(char)
,	O
filename	*(char)
,	O
p	*(char)
)	O
;	O
return	O
(	O
m	*(char)
)	O
;	O
}	O
static	O
POSITION	long
muldiv	(long,long,long)->(long)
(	O
val	long
,	O
num	long
,	O
den	long
)	O
POSITION	long
val	long
,	O
num	long
,	O
den	long
;	O
{	O
double	O
v	double
=	O
(	O
(	O
(	O
double	O
)	O
val	long
)	O
*	O
num	long
)	O
/	O
den	long
;	O
return	O
(	O
(	O
POSITION	long
)	O
(	O
v	double
+	O
0.5	int
)	O
)	O
;	O
}	O
public	O
int	O
percentage	(long,long)->(int)
(	O
num	long
,	O
den	long
)	O
POSITION	long
num	long
;	O
POSITION	long
den	long
;	O
{	O
return	O
(	O
int	O
)	O
muldiv	(long,long,long)->(long)
(	O
num	long
,	O
(	O
POSITION	long
)	O
100	int
,	O
den	long
)	O
;	O
}	O
public	O
POSITION	long
percent_pos	(long,int,long)->(long)
(	O
pos	long
,	O
percent	int
,	O
fraction	long
)	O
POSITION	long
pos	long
;	O
int	O
percent	int
;	O
long	O
fraction	long
;	O
{	O
POSITION	long
perden	long
=	O
(	O
percent	int
*	O
(	O
NUM_FRAC_DENOM	int
/	O
100	int
)	O
)	O
+	O
(	O
fraction	long
/	O
100	int
)	O
;	O
if	O
(	O
perden	long
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
POSITION	long
)	O
muldiv	(long,long,long)->(long)
(	O
pos	long
,	O
perden	long
,	O
(	O
POSITION	long
)	O
NUM_FRAC_DENOM	int
)	O
;	O
}	O
