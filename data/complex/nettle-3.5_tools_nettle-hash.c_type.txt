static	O
void	O
list_algorithms	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
i	int
;	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
;	O
printf	(*(char))->(int)
(	O
"%10s digestsize (internal block size, context size), in units of octets\n"	*(char)
,	O
"name"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
=	O
nettle_hashes	O
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%10s %d (%d, %d)\n"	*(char)
,	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
,	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
digest_size	int
,	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
block_size	int
,	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
context_size	int
)	O
;	O
}	O
;	O
static	O
int	O
hash_file	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))),*(void),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
,	O
void	O
*	O
ctx	*(void)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
uint8_t	char
buffer	array(char)
[	O
BUFSIZE	int
]	O
;	O
size_t	long
res	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	array(char)
,	O
1	int
,	O
sizeof	O
(	O
buffer	array(char)
)	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
0	int
;	O
hash	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
update	*((*(void),long,*(char))->(void))
(	O
ctx	*(void)
,	O
res	long
,	O
buffer	array(char)
)	O
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
1	int
;	O
}	O
}	O
static	O
int	O
digest_file	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))),int,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
,	O
unsigned	O
digest_length	int
,	O
int	O
raw	int
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
void	O
*	O
ctx	*(void)
;	O
uint8_t	char
*	O
digest	*((*(void),long,*(char))->(void))
;	O
ctx	*(void)
=	O
xalloc	(long)->(*(void))
(	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
context_size	int
)	O
;	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
init	*((*(void))->(void))
(	O
ctx	*(void)
)	O
;	O
if	O
(	O
!	O
hash_file	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))),*(void),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
,	O
ctx	*(void)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
ctx	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
digest	*((*(void),long,*(char))->(void))
=	O
xalloc	(long)->(*(void))
(	O
digest_length	int
)	O
;	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
digest	*((*(void),long,*(char))->(void))
(	O
ctx	*(void)
,	O
digest_length	int
,	O
digest	*((*(void),long,*(char))->(void))
)	O
;	O
free	(*(void))->(void)
(	O
ctx	*(void)
)	O
;	O
if	O
(	O
raw	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
digest	*((*(void),long,*(char))->(void))
,	O
digest_length	int
,	O
1	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
unsigned	O
i	int
;	O
char	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
8	int
)	O
+	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
+	O
8	int
<	O
digest_length	int
;	O
i	int
+=	O
8	int
)	O
{	O
base16_encode_update	O
(	O
hex	array(char)
,	O
8	int
,	O
digest	*((*(void),long,*(char))->(void))
+	O
i	int
)	O
;	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
8	int
)	O
]	O
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"%s "	*(char)
,	O
hex	array(char)
)	O
;	O
}	O
base16_encode_update	O
(	O
hex	array(char)
,	O
digest_length	int
-	O
i	int
,	O
digest	*((*(void),long,*(char))->(void))
+	O
i	int
)	O
;	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
digest_length	int
-	O
i	int
)	O
]	O
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"%s %s\n"	*(char)
,	O
hex	array(char)
,	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
name	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
digest	*((*(void),long,*(char))->(void))
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage: nettle-hash -a ALGORITHM [OPTIONS] [FILE ...]\n"	*(char)
"Options:\n"	*(char)
"  --help              Show this help.\n"	*(char)
"  -V, --version       Show version information.\n"	*(char)
"  --list              List supported hash algorithms.\n"	*(char)
"  -a, --algorithm=ALG Hash algorithm to use.\n"	*(char)
"  -l, --length=LENGTH Desired digest length (octets)\n"	*(char)
"  --raw               Raw binary output.\n"	*(char)
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
const	O
char	O
*	O
alg_name	*(char)
=	O
NULL	O
;	O
const	O
struct	O
nettle_hash	struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void)))
*	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
;	O
unsigned	O
length	long
=	O
0	int
;	O
int	O
raw	int
=	O
0	int
;	O
int	O
c	int
;	O
enum	O
{	O
OPT_HELP	int
=	O
0x300	int
,	O
OPT_RAW	int
,	O
OPT_LIST	int
}	O
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_HELP	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"algorithm"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"length"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"list"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_LIST	int
}	O
,	O
{	O
"raw"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_RAW	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"Va:l:"	*(char)
,	O
options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'?'	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
case	O
OPT_HELP	int
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'V'	O
:	O
printf	(*(char))->(int)
(	O
"nettle-hash ("	*(char)
PACKAGE_STRING	*(char)
")\n"	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'a'	O
:	O
alg_name	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'l'	O
:	O
{	O
int	O
arg	int
;	O
arg	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
arg	int
<=	O
0	int
)	O
die	(*(char))->(void)
(	O
"Invalid length argument: `%s'\n"	*(char)
,	O
optarg	*(char)
)	O
;	O
length	long
=	O
arg	int
;	O
}	O
break	O
;	O
case	O
OPT_RAW	int
:	O
raw	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_LIST	int
:	O
list_algorithms	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
!	O
alg_name	*(char)
)	O
die	(*(char))->(void)
(	O
"Algorithm argument (-a option) is mandatory.\n"	*(char)
"See nettle-hash --help for further information.\n"	*(char)
)	O
;	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
=	O
nettle_lookup_hash	(*(char))->(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))))
(	O
alg_name	*(char)
)	O
;	O
if	O
(	O
!	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
)	O
die	(*(char))->(void)
(	O
"Hash algorithm `%s' not supported or .\n"	*(char)
"Use nettle-hash --list to list available algorithms.\n"	*(char)
,	O
alg_name	*(char)
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
length	long
=	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
digest_size	int
;	O
else	O
if	O
(	O
length	long
>	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
->	O
digest_size	int
)	O
die	(*(char))->(void)
(	O
"Length argument %d too large for selected algorithm.\n"	*(char)
,	O
length	long
)	O
;	O
argv	*(*(char))
+=	O
optind	int
;	O
argc	int
-=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
digest_file	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))),int,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
,	O
length	long
,	O
raw	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
die	(*(char))->(void)
(	O
"Cannot open `%s': %s\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
,	O
STRERROR	O
(	O
errno	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s: "	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
digest_file	(*(struct(*(char),int,int,int,*((*`)->(void)),*((*`,long,*`)->(void)),*((*`,long,*`)->(void)))),int,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
alg	*(struct(*(char),int,int,int,*((*(void))->(void)),*((*(void),long,*(char))->(void)),*((*(void),long,*(char))->(void))))
,	O
length	long
,	O
raw	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
die	(*(char))->(void)
(	O
"Reading `%s' failed: %s\n"	*(char)
,	O
argv	*(*(char))
[	O
i	int
]	O
,	O
STRERROR	O
(	O
errno	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
die	(*(char))->(void)
(	O
"Write failed: %s\n"	*(char)
,	O
STRERROR	O
(	O
errno	O
)	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
