static	O
char	O
netobuf	array(char)
[	O
BUFSIZ	int
+	O
NETSLOP	int
]	O
,	O
*	O
nfrontp	*(char)
,	O
*	O
nbackp	*(char)
;	O
static	O
char	O
*	O
neturg	*(char)
;	O
static	O
char	O
ptyobuf	array(char)
[	O
BUFSIZ	int
+	O
NETSLOP	int
]	O
,	O
*	O
pfrontp	*(char)
,	O
*	O
pbackp	*(char)
;	O
static	O
char	O
netibuf	array(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
netip	*(char)
;	O
static	O
int	O
ncc	int
;	O
static	O
char	O
ptyibuf	array(char)
[	O
BUFSIZ	int
]	O
,	O
*	O
ptyip	*(char)
;	O
static	O
int	O
pcc	int
;	O
int	O
not42	int
;	O
static	O
int	O
readstream	(int,*(char),int)->(int)
(	O
int	O
p	*(void)
,	O
char	O
*	O
ibuf	*(char)
,	O
int	O
bufsize	int
)	O
{	O
return	O
read	*((*(void),*(char),long)->(long))
(	O
p	*(void)
,	O
ibuf	*(char)
,	O
bufsize	int
)	O
;	O
}	O
void	O
io_setup	()->(void)
(	O
void	O
)	O
{	O
pfrontp	*(char)
=	O
pbackp	*(char)
=	O
ptyobuf	array(char)
;	O
nfrontp	*(char)
=	O
nbackp	*(char)
=	O
netobuf	array(char)
;	O
netip	*(char)
=	O
netibuf	array(char)
;	O
ptyip	*(char)
=	O
ptyibuf	array(char)
;	O
}	O
void	O
set_neturg	()->(void)
(	O
void	O
)	O
{	O
neturg	*(char)
=	O
nfrontp	*(char)
-	O
1	int
;	O
}	O
void	O
net_output_byte	(int)->(void)
(	O
int	O
c	int
)	O
{	O
*	O
nfrontp	*(char)
++	O
=	O
c	int
;	O
}	O
int	O
net_output_data	(*(char))->(int)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
size_t	long
remaining	long
,	O
ret	long
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	*(char)
-	O
netobuf	array(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
format	*(char)
)	O
>	O
remaining	long
||	O
BUFSIZ	int
/	O
4	int
>	O
remaining	long
)	O
{	O
netflush	()->(void)
(	O
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	*(char)
-	O
netobuf	array(char)
)	O
;	O
}	O
ret	long
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
nfrontp	*(char)
,	O
remaining	long
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
nfrontp	*(char)
+=	O
(	O
(	O
ret	long
<	O
remaining	long
-	O
1	int
)	O
?	O
ret	long
:	O
remaining	long
-	O
1	int
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
ret	long
;	O
}	O
int	O
net_output_datalen	(*(void),long)->(int)
(	O
const	O
void	O
*	O
buf	*(void)
,	O
size_t	long
l	long
)	O
{	O
size_t	long
remaining	long
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	*(char)
-	O
netobuf	array(char)
)	O
;	O
if	O
(	O
remaining	long
<	O
l	long
)	O
{	O
netflush	()->(void)
(	O
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	*(char)
-	O
netobuf	array(char)
)	O
;	O
}	O
if	O
(	O
remaining	long
<	O
l	long
)	O
return	O
-	O
1	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
nfrontp	*(char)
,	O
buf	*(void)
,	O
l	long
)	O
;	O
nfrontp	*(char)
+=	O
l	long
;	O
return	O
(	O
int	O
)	O
l	long
;	O
}	O
int	O
net_input_level	()->(int)
(	O
void	O
)	O
{	O
return	O
ncc	int
;	O
}	O
int	O
net_output_level	()->(int)
(	O
void	O
)	O
{	O
return	O
nfrontp	*(char)
-	O
nbackp	*(char)
;	O
}	O
int	O
net_buffer_is_full	()->(int)
(	O
void	O
)	O
{	O
return	O
(	O
&	O
netobuf	array(char)
[	O
BUFSIZ	int
]	O
-	O
nfrontp	*(char)
)	O
<	O
2	int
;	O
}	O
int	O
net_get_char	(int)->(int)
(	O
int	O
peek	int
)	O
{	O
if	O
(	O
peek	int
)	O
return	O
*	O
netip	*(char)
;	O
else	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
ncc	int
--	O
;	O
return	O
*	O
netip	*(char)
++	O
&	O
0377	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
net_read	()->(int)
(	O
void	O
)	O
{	O
ncc	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
net	int
,	O
netibuf	array(char)
,	O
sizeof	O
(	O
netibuf	array(char)
)	O
)	O
;	O
if	O
(	O
ncc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
ncc	int
=	O
0	int
;	O
else	O
if	O
(	O
ncc	int
==	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"telnetd:  peer died"	*(char)
)	O
;	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
netip	*(char)
=	O
netibuf	array(char)
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: netread %d chars\r\n"	*(char)
,	O
ncc	int
)	O
)	O
;	O
DEBUG	O
(	O
debug_net_data	int
,	O
1	int
,	O
printdata	(*(char),*(char),int)->(void)
(	O
"nd"	*(char)
,	O
netip	*(char)
,	O
ncc	int
)	O
)	O
;	O
}	O
return	O
ncc	int
;	O
}	O
int	O
pty_buffer_is_full	()->(int)
(	O
void	O
)	O
{	O
return	O
(	O
&	O
ptyobuf	array(char)
[	O
BUFSIZ	int
]	O
-	O
pfrontp	*(char)
)	O
<	O
2	int
;	O
}	O
void	O
pty_output_byte	(int)->(void)
(	O
int	O
c	int
)	O
{	O
*	O
pfrontp	*(char)
++	O
=	O
c	int
;	O
}	O
void	O
pty_output_datalen	(*(void),long)->(void)
(	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
(	O
&	O
ptyobuf	array(char)
[	O
BUFSIZ	int
]	O
-	O
pfrontp	*(char)
)	O
>	O
len	long
)	O
ptyflush	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pfrontp	*(char)
,	O
data	*(void)
,	O
len	long
)	O
;	O
pfrontp	*(char)
+=	O
len	long
;	O
}	O
int	O
pty_input_level	()->(int)
(	O
void	O
)	O
{	O
return	O
pcc	int
;	O
}	O
int	O
pty_output_level	()->(int)
(	O
void	O
)	O
{	O
return	O
pfrontp	*(char)
-	O
pbackp	*(char)
;	O
}	O
void	O
ptyflush	()->(void)
(	O
void	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
(	O
n	long
=	O
pfrontp	*(char)
-	O
pbackp	*(char)
)	O
>	O
0	int
)	O
{	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: ptyflush %d chars\r\n"	*(char)
,	O
n	long
)	O
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
printdata	(*(char),*(char),int)->(void)
(	O
"pd"	*(char)
,	O
pbackp	*(char)
,	O
n	long
)	O
)	O
;	O
n	long
=	O
write	*((*(void),*(char),long)->(long))
(	O
pty	int
,	O
pbackp	*(char)
,	O
n	long
)	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EINTR	int
)	O
return	O
;	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
(	O
0	int
)	O
;	O
}	O
pbackp	*(char)
+=	O
n	long
;	O
if	O
(	O
pbackp	*(char)
==	O
pfrontp	*(char)
)	O
pbackp	*(char)
=	O
pfrontp	*(char)
=	O
ptyobuf	array(char)
;	O
}	O
int	O
pty_get_char	(int)->(int)
(	O
int	O
peek	int
)	O
{	O
if	O
(	O
peek	int
)	O
return	O
*	O
ptyip	*(char)
;	O
else	O
if	O
(	O
pcc	int
>	O
0	int
)	O
{	O
pcc	int
--	O
;	O
return	O
*	O
ptyip	*(char)
++	O
&	O
0377	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
pty_input_putback	(*(char),long)->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	long
>	O
&	O
ptyibuf	array(char)
[	O
BUFSIZ	int
]	O
-	O
ptyip	*(char)
)	O
len	long
=	O
&	O
ptyibuf	array(char)
[	O
BUFSIZ	int
]	O
-	O
ptyip	*(char)
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
ptyip	*(char)
,	O
str	*(char)
,	O
len	long
)	O
;	O
pcc	int
+=	O
len	long
;	O
return	O
0	int
;	O
}	O
int	O
pty_read	()->(int)
(	O
void	O
)	O
{	O
pcc	int
=	O
readstream	(int,*(char),int)->(int)
(	O
pty	int
,	O
ptyibuf	array(char)
,	O
BUFSIZ	int
)	O
;	O
if	O
(	O
pcc	int
<	O
0	int
&&	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EAGAIN	int
||	O
errno	O
==	O
EIO	int
)	O
)	O
pcc	int
=	O
0	int
;	O
ptyip	*(char)
=	O
ptyibuf	array(char)
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"ptyread %d chars\r\n"	*(char)
,	O
pcc	int
)	O
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
printdata	(*(char),*(char),int)->(void)
(	O
"pty"	*(char)
,	O
ptyip	*(char)
,	O
pcc	int
)	O
)	O
;	O
return	O
pcc	int
;	O
}	O
void	O
io_drain	()->(void)
(	O
void	O
)	O
{	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: ttloop\r\n"	*(char)
)	O
)	O
;	O
if	O
(	O
nfrontp	*(char)
-	O
nbackp	*(char)
>	O
0	int
)	O
netflush	()->(void)
(	O
)	O
;	O
again	O
:	O
ncc	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
net	int
,	O
netibuf	array(char)
,	O
sizeof	O
netibuf	array(char)
)	O
;	O
if	O
(	O
ncc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"ttloop: retrying"	*(char)
)	O
;	O
goto	O
again	O
;	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"ttloop:  read: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
ncc	int
==	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"ttloop:  peer died: %m\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: ttloop read %d chars\r\n"	*(char)
,	O
ncc	int
)	O
)	O
;	O
netip	*(char)
=	O
netibuf	array(char)
;	O
telrcv	()->(void)
(	O
)	O
;	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
pfrontp	*(char)
=	O
pbackp	*(char)
=	O
ptyobuf	array(char)
;	O
telrcv	()->(void)
(	O
)	O
;	O
}	O
}	O
int	O
stilloob	(int)->(int)
(	O
int	O
s	long
)	O
{	O
static	O
struct	O
timeval	struct(long,long)
timeout	struct(long,long)
=	O
{	O
0	int
}	O
;	O
fd_set	struct(array(long))
excepts	struct(array(long))
;	O
int	O
value	int
;	O
do	O
{	O
FD_ZERO	O
(	O
&	O
excepts	struct(array(long))
)	O
;	O
FD_SET	O
(	O
s	long
,	O
&	O
excepts	struct(array(long))
)	O
;	O
value	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
s	long
+	O
1	int
,	O
(	O
fd_set	struct(array(long))
*	O
)	O
0	int
,	O
(	O
fd_set	struct(array(long))
*	O
)	O
0	int
,	O
&	O
excepts	struct(array(long))
,	O
&	O
timeout	struct(long,long)
)	O
;	O
}	O
while	O
(	O
value	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
value	int
<	O
0	int
)	O
fatalperror	(int,*(char))->(void)
(	O
pty	int
,	O
"select"	*(char)
)	O
;	O
return	O
FD_ISSET	O
(	O
s	long
,	O
&	O
excepts	struct(array(long))
)	O
;	O
}	O
char	O
*	O
nextitem	(*(char))->(*(char))
(	O
char	O
*	O
current	struct(char,char)
)	O
{	O
if	O
(	O
(	O
*	O
current	struct(char,char)
&	O
0xff	int
)	O
!=	O
IAC	int
)	O
return	O
current	struct(char,char)
+	O
1	int
;	O
switch	O
(	O
*	O
(	O
current	struct(char,char)
+	O
1	int
)	O
&	O
0xff	int
)	O
{	O
case	O
DO	int
:	O
case	O
DONT	int
:	O
case	O
WILL	int
:	O
case	O
WONT	int
:	O
return	O
current	struct(char,char)
+	O
3	int
;	O
case	O
SB	int
:	O
{	O
register	O
char	O
*	O
look	*(char)
=	O
current	struct(char,char)
+	O
2	int
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
(	O
*	O
look	*(char)
++	O
&	O
0xff	int
)	O
==	O
IAC	int
&&	O
(	O
*	O
look	*(char)
++	O
&	O
0xff	int
)	O
==	O
SE	int
)	O
return	O
look	*(char)
;	O
default	O
:	O
return	O
current	struct(char,char)
+	O
2	int
;	O
}	O
}	O
}	O
void	O
netclear	()->(void)
(	O
void	O
)	O
{	O
register	O
char	O
*	O
thisitem	*(char)
,	O
*	O
next	*(char)
;	O
char	O
*	O
good	*(char)
;	O
thisitem	*(char)
=	O
netobuf	array(char)
;	O
while	O
(	O
(	O
next	*(char)
=	O
nextitem	(*(char))->(*(char))
(	O
thisitem	*(char)
)	O
)	O
<=	O
nbackp	*(char)
)	O
thisitem	*(char)
=	O
next	*(char)
;	O
good	*(char)
=	O
netobuf	array(char)
;	O
while	O
(	O
nfrontp	*(char)
>	O
thisitem	*(char)
)	O
{	O
if	O
(	O
wewant	O
(	O
thisitem	*(char)
)	O
)	O
{	O
int	O
length	int
;	O
for	O
(	O
next	*(char)
=	O
thisitem	*(char)
;	O
wewant	O
(	O
next	*(char)
)	O
&&	O
nfrontp	*(char)
>	O
next	*(char)
;	O
next	*(char)
=	O
nextitem	(*(char))->(*(char))
(	O
next	*(char)
)	O
)	O
;	O
length	int
=	O
next	*(char)
-	O
thisitem	*(char)
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
good	*(char)
,	O
thisitem	*(char)
,	O
length	int
)	O
;	O
good	*(char)
+=	O
length	int
;	O
thisitem	*(char)
=	O
next	*(char)
;	O
}	O
else	O
{	O
thisitem	*(char)
=	O
nextitem	(*(char))->(*(char))
(	O
thisitem	*(char)
)	O
;	O
}	O
}	O
nbackp	*(char)
=	O
netobuf	array(char)
;	O
nfrontp	*(char)
=	O
good	*(char)
;	O
neturg	*(char)
=	O
0	int
;	O
}	O
void	O
netflush	()->(void)
(	O
void	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
(	O
n	long
=	O
nfrontp	*(char)
-	O
nbackp	*(char)
)	O
>	O
0	int
)	O
{	O
NET_ENCRYPT	O
(	O
)	O
;	O
if	O
(	O
!	O
neturg	*(char)
||	O
!	O
not42	int
)	O
n	long
=	O
write	*((*(void),*(char),long)->(long))
(	O
net	int
,	O
nbackp	*(char)
,	O
n	long
)	O
;	O
else	O
{	O
n	long
=	O
neturg	*(char)
-	O
nbackp	*(char)
;	O
if	O
(	O
n	long
>	O
1	int
)	O
n	long
=	O
send	(int,*(void),long,int)->(long)
(	O
net	int
,	O
nbackp	*(char)
,	O
n	long
-	O
1	int
,	O
0	int
)	O
;	O
else	O
n	long
=	O
send	(int,*(void),long,int)->(long)
(	O
net	int
,	O
nbackp	*(char)
,	O
n	long
,	O
MSG_OOB	int
)	O
;	O
}	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EINTR	int
)	O
return	O
;	O
cleanup	*((*(struct(int,int,*((*`,int)->(int)),*((*`)->(int)),*((*`,*`,int)->(void)),*((*`,*`,int)->(void)),*((*`,*`,int)->(int)),*((*`,int,*`,int)->(void)),*((*`)->(void)))))->(void))
(	O
0	int
)	O
;	O
}	O
nbackp	*(char)
+=	O
n	long
;	O
if	O
(	O
nbackp	*(char)
>=	O
neturg	*(char)
)	O
neturg	*(char)
=	O
0	int
;	O
if	O
(	O
nbackp	*(char)
==	O
nfrontp	*(char)
)	O
{	O
nbackp	*(char)
=	O
nfrontp	*(char)
=	O
netobuf	array(char)
;	O
}	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	(*(char))->(void)
(	O
"td: netflush %d chars\r\n"	*(char)
,	O
n	long
)	O
)	O
;	O
}	O
void	O
fatal	(int,*(char))->(void)
(	O
int	O
f	int
,	O
char	O
*	O
msg	*(char)
)	O
{	O
char	O
buf	*(void)
[	O
BUFSIZ	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
,	O
"telnetd: %s.\r\n"	*(char)
,	O
msg	*(char)
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
f	int
,	O
buf	*(void)
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
)	O
;	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
fatalperror	(int,*(char))->(void)
(	O
int	O
f	int
,	O
char	O
*	O
msg	*(char)
)	O
{	O
char	O
buf	*(void)
[	O
BUFSIZ	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
,	O
"%s: %s"	*(char)
,	O
msg	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
fatal	(int,*(char))->(void)
(	O
f	int
,	O
buf	*(void)
)	O
;	O
}	O
static	O
unsigned	O
char	O
ttytype_sbbuf	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_TTYPE	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
static	O
void	O
_gettermname	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
return	O
;	O
settimer	O
(	O
baseline	int
)	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
ttytype_sbbuf	array(char)
,	O
sizeof	O
ttytype_sbbuf	array(char)
)	O
;	O
ttloop	O
(	O
sequenceIs	O
(	O
ttypesubopt	int
,	O
baseline	int
)	O
)	O
;	O
}	O
int	O
getterminaltype	(*(char))->(int)
(	O
char	O
*	O
user_name	*(char)
)	O
{	O
int	O
retval	int
=	O
-	O
1	int
;	O
settimer	O
(	O
baseline	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_TTYPE	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_TSPEED	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_NEW_ENVIRON	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_OLD_ENVIRON	int
,	O
1	int
)	O
;	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_TTYPE	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_TSPEED	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_XDISPLOC	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TSPEED	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_TSPEED	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
sb	array(char)
,	O
sizeof	O
sb	array(char)
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_XDISPLOC	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
sb	array(char)
,	O
sizeof	O
sb	array(char)
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_NEW_ENVIRON	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
sb	array(char)
,	O
sizeof	O
sb	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_OLD_ENVIRON	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	(*(void),long)->(int)
(	O
sb	array(char)
,	O
sizeof	O
sb	array(char)
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
)	O
net_output_datalen	(*(void),long)->(int)
(	O
ttytype_sbbuf	array(char)
,	O
sizeof	O
ttytype_sbbuf	array(char)
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TSPEED	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
tspeedsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
xdisplocsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
environsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
oenvironsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
)	O
{	O
char	O
*	O
first	*(char)
=	O
NULL	O
,	O
*	O
last	*(char)
=	O
NULL	O
;	O
ttloop	O
(	O
sequenceIs	O
(	O
ttypesubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
&&	O
!	O
terminaltypeok	(*(char))->(int)
(	O
terminaltype	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
first	*(char)
)	O
;	O
first	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
terminaltype	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
free	(*(void))->(void)
(	O
last	*(char)
)	O
;	O
last	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
terminaltype	*(char)
)	O
;	O
_gettermname	()->(void)
(	O
)	O
;	O
if	O
(	O
terminaltypeok	(*(char))->(int)
(	O
terminaltype	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
last	*(char)
,	O
terminaltype	*(char)
)	O
==	O
0	int
)	O
||	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
first	*(char)
,	O
terminaltype	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
_gettermname	()->(void)
(	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
first	*(char)
,	O
terminaltype	*(char)
)	O
!=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
terminaltype	*(char)
)	O
;	O
terminaltype	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
first	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
first	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
last	*(char)
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
terminaltypeok	(*(char))->(int)
(	O
char	O
*	O
s	long
)	O
{	O
char	O
buf	*(void)
[	O
1024	int
]	O
;	O
if	O
(	O
terminaltype	*(char)
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
tgetent	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
s	long
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
FILE	struct
*	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
static	O
int	O
debug_open	()->(int)
(	O
void	O
)	O
{	O
int	O
um	int
=	O
umask	(int)->(int)
(	O
077	int
)	O
;	O
if	O
(	O
!	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"/tmp/telnet.debug"	*(char)
,	O
"a"	*(char)
)	O
;	O
umask	(int)->(int)
(	O
um	int
)	O
;	O
return	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
;	O
}	O
static	O
int	O
debug_close	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
void	O
debug_output_datalen	(*(char),long)->(void)
(	O
const	O
char	O
*	O
data	*(void)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
debug_open	()->(int)
(	O
)	O
)	O
return	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
data	*(void)
,	O
1	int
,	O
len	long
,	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
debug_close	()->(int)
(	O
)	O
;	O
}	O
void	O
debug_output_data	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
debug_open	()->(int)
(	O
)	O
)	O
return	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
debug_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
debug_close	()->(int)
(	O
)	O
;	O
}	O
void	O
printoption	(*(char),int)->(void)
(	O
register	O
char	O
*	O
fmt	*(char)
,	O
register	O
int	O
option	int
)	O
{	O
if	O
(	O
TELOPT_OK	O
(	O
option	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s %s\r\n"	*(char)
,	O
fmt	*(char)
,	O
TELOPT	O
(	O
option	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
option	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s %s\r\n"	*(char)
,	O
fmt	*(char)
,	O
TELCMD	O
(	O
option	int
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
"%s %d\r\n"	*(char)
,	O
fmt	*(char)
,	O
option	int
)	O
;	O
}	O
void	O
printsub	*((*(char),int,*(char),int)->(void))
(	O
int	O
direction	int
,	O
unsigned	O
char	O
*	O
pointer	*(char)
,	O
int	O
length	int
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
direction	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"td: %s suboption "	*(char)
,	O
direction	int
==	O
'<'	O
?	O
"recv"	*(char)
:	O
"send"	*(char)
)	O
;	O
if	O
(	O
length	int
>=	O
3	int
)	O
{	O
register	O
int	O
j	int
;	O
i	int
=	O
pointer	*(char)
[	O
length	int
-	O
2	int
]	O
;	O
j	int
=	O
pointer	*(char)
[	O
length	int
-	O
1	int
]	O
;	O
if	O
(	O
i	int
!=	O
IAC	int
||	O
j	int
!=	O
SE	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"(terminated by "	*(char)
)	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
i	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s "	*(char)
,	O
TELOPT	O
(	O
i	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
i	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s "	*(char)
,	O
TELCMD	O
(	O
i	int
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
"%d "	*(char)
,	O
i	int
)	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
j	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s"	*(char)
,	O
TELOPT	O
(	O
j	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
j	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s"	*(char)
,	O
TELCMD	O
(	O
j	int
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
"%d"	*(char)
,	O
j	int
)	O
;	O
debug_output_data	(*(char))->(void)
(	O
", not IAC SE!) "	*(char)
)	O
;	O
}	O
}	O
length	int
-=	O
2	int
;	O
}	O
if	O
(	O
length	int
<	O
1	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"(Empty suboption??\?)"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
pointer	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
TELOPT_TTYPE	int
:	O
debug_output_data	(*(char))->(void)
(	O
"TERMINAL-TYPE "	*(char)
)	O
;	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	(*(char))->(void)
(	O
"IS \"%.*s\""	*(char)
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	*(char)
+	O
2	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	(*(char))->(void)
(	O
"SEND"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
"- unknown qualifier %d (0x%x)."	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
debug_output_data	(*(char))->(void)
(	O
"TERMINAL-SPEED"	*(char)
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" (empty suboption??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	(*(char))->(void)
(	O
" IS %.*s"	*(char)
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	*(char)
+	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
pointer	*(char)
[	O
1	int
]	O
==	O
1	int
)	O
debug_output_data	(*(char))->(void)
(	O
" SEND"	*(char)
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
" %d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
debug_output_data	(*(char))->(void)
(	O
"TOGGLE-FLOW-CONTROL"	*(char)
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" (empty suboption??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
LFLOW_OFF	int
:	O
debug_output_data	(*(char))->(void)
(	O
" OFF"	*(char)
)	O
;	O
break	O
;	O
case	O
LFLOW_ON	int
:	O
debug_output_data	(*(char))->(void)
(	O
" ON"	*(char)
)	O
;	O
break	O
;	O
case	O
LFLOW_RESTART_ANY	int
:	O
debug_output_data	(*(char))->(void)
(	O
" RESTART-ANY"	*(char)
)	O
;	O
break	O
;	O
case	O
LFLOW_RESTART_XON	int
:	O
debug_output_data	(*(char))->(void)
(	O
" RESTART-XON"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
" %d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELOPT_NAWS	int
:	O
debug_output_data	(*(char))->(void)
(	O
"NAWS"	*(char)
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" (empty suboption??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
length	int
==	O
2	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	(*(char))->(void)
(	O
" %d %d (%d)"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
,	O
pointer	*(char)
[	O
2	int
]	O
,	O
(	O
int	O
)	O
(	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	*(char)
[	O
1	int
]	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	*(char)
[	O
2	int
]	O
)	O
)	O
)	O
;	O
if	O
(	O
length	int
==	O
4	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
3	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	(*(char))->(void)
(	O
" %d %d (%d)"	*(char)
,	O
pointer	*(char)
[	O
3	int
]	O
,	O
pointer	*(char)
[	O
4	int
]	O
,	O
(	O
int	O
)	O
(	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	*(char)
[	O
3	int
]	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	*(char)
[	O
4	int
]	O
)	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
5	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
debug_output_data	(*(char))->(void)
(	O
"LINEMODE "	*(char)
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" (empty suboption??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
WILL	int
:	O
debug_output_data	(*(char))->(void)
(	O
"WILL "	*(char)
)	O
;	O
goto	O
common	O
;	O
case	O
WONT	int
:	O
debug_output_data	(*(char))->(void)
(	O
"WONT "	*(char)
)	O
;	O
goto	O
common	O
;	O
case	O
DO	int
:	O
debug_output_data	(*(char))->(void)
(	O
"DO "	*(char)
)	O
;	O
goto	O
common	O
;	O
case	O
DONT	int
:	O
debug_output_data	(*(char))->(void)
(	O
"DONT "	*(char)
)	O
;	O
common	O
:	O
if	O
(	O
length	int
<	O
3	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"(no option??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	*(char)
[	O
2	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
debug_output_data	(*(char))->(void)
(	O
"Forward Mask"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %x"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
"%d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %d"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
LM_SLC	int
:	O
debug_output_data	(*(char))->(void)
(	O
"SLC"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
-	O
2	int
;	O
i	int
+=	O
3	int
)	O
{	O
if	O
(	O
SLC_NAME_OK	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %s"	*(char)
,	O
SLC_NAME	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
" %d"	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
;	O
switch	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_LEVELBITS	int
)	O
{	O
case	O
SLC_NOSUPPORT	int
:	O
debug_output_data	(*(char))->(void)
(	O
" NOSUPPORT"	*(char)
)	O
;	O
break	O
;	O
case	O
SLC_CANTCHANGE	int
:	O
debug_output_data	(*(char))->(void)
(	O
" CANTCHANGE"	*(char)
)	O
;	O
break	O
;	O
case	O
SLC_VARIABLE	int
:	O
debug_output_data	(*(char))->(void)
(	O
" VARIABLE"	*(char)
)	O
;	O
break	O
;	O
case	O
SLC_DEFAULT	int
:	O
debug_output_data	(*(char))->(void)
(	O
" DEFAULT"	*(char)
)	O
;	O
break	O
;	O
}	O
debug_output_data	(*(char))->(void)
(	O
"%s%s%s"	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_ACK	int
?	O
"|ACK"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_FLUSHIN	int
?	O
"|FLUSHIN"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_FLUSHOUT	int
?	O
"|FLUSHOUT"	*(char)
:	O
""	*(char)
)	O
;	O
if	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
~	O
(	O
SLC_ACK	int
|	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
|	O
SLC_LEVELBITS	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"(0x%x)"	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_FLAGS	int
]	O
)	O
;	O
debug_output_data	(*(char))->(void)
(	O
" %d;"	*(char)
,	O
pointer	*(char)
[	O
i	int
+	O
SLC_VALUE	int
]	O
)	O
;	O
if	O
(	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_VALUE	int
]	O
==	O
IAC	int
)	O
&&	O
(	O
pointer	*(char)
[	O
i	int
+	O
SLC_VALUE	int
+	O
1	int
]	O
==	O
IAC	int
)	O
)	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
LM_MODE	int
:	O
debug_output_data	(*(char))->(void)
(	O
"MODE "	*(char)
)	O
;	O
if	O
(	O
length	int
<	O
3	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"(no mode??\?)"	*(char)
)	O
;	O
break	O
;	O
}	O
{	O
char	O
tbuf	array(char)
[	O
32	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
tbuf	array(char)
,	O
sizeof	O
(	O
tbuf	array(char)
)	O
,	O
"%s%s%s%s%s"	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
&	O
MODE_EDIT	int
?	O
"|EDIT"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
&	O
MODE_TRAPSIG	int
?	O
"|TRAPSIG"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
&	O
MODE_SOFT_TAB	int
?	O
"|SOFT_TAB"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
&	O
MODE_LIT_ECHO	int
?	O
"|LIT_ECHO"	*(char)
:	O
""	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
&	O
MODE_ACK	int
?	O
"|ACK"	*(char)
:	O
""	*(char)
)	O
;	O
debug_output_data	(*(char))->(void)
(	O
"%s"	*(char)
,	O
tbuf	array(char)
[	O
1	int
]	O
?	O
&	O
tbuf	array(char)
[	O
1	int
]	O
:	O
"0"	*(char)
)	O
;	O
}	O
if	O
(	O
pointer	*(char)
[	O
2	int
]	O
&	O
~	O
(	O
MODE_EDIT	int
|	O
MODE_TRAPSIG	int
|	O
MODE_ACK	int
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
" (0x%x)"	*(char)
,	O
pointer	*(char)
[	O
2	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" ?0x%x?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
"%d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %d"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_STATUS	int
:	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
register	O
int	O
j	int
,	O
k	int
;	O
debug_output_data	(*(char))->(void)
(	O
"STATUS"	*(char)
)	O
;	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
default	O
:	O
if	O
(	O
pointer	*(char)
[	O
1	int
]	O
==	O
TELQUAL_SEND	int
)	O
debug_output_data	(*(char))->(void)
(	O
" SEND"	*(char)
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
" %d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" ?%d?"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	(*(char))->(void)
(	O
" IS\r\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
pointer	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
DO	int
:	O
cp	*(char)
=	O
"DO"	*(char)
;	O
goto	O
common2	O
;	O
case	O
DONT	int
:	O
cp	*(char)
=	O
"DONT"	*(char)
;	O
goto	O
common2	O
;	O
case	O
WILL	int
:	O
cp	*(char)
=	O
"WILL"	*(char)
;	O
goto	O
common2	O
;	O
case	O
WONT	int
:	O
cp	*(char)
=	O
"WONT"	*(char)
;	O
goto	O
common2	O
;	O
common2	O
:	O
i	int
++	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
pointer	*(char)
[	O
i	int
]	O
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %s %s\r\n"	*(char)
,	O
cp	*(char)
,	O
TELOPT	O
(	O
pointer	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
" %s %d\r\n"	*(char)
,	O
cp	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
debug_output_data	(*(char))->(void)
(	O
" SB "	*(char)
)	O
;	O
i	int
++	O
;	O
j	int
=	O
k	int
=	O
i	int
;	O
while	O
(	O
j	int
<	O
length	int
)	O
{	O
if	O
(	O
pointer	*(char)
[	O
j	int
]	O
==	O
SE	int
)	O
{	O
if	O
(	O
j	int
+	O
1	int
==	O
length	int
)	O
break	O
;	O
if	O
(	O
pointer	*(char)
[	O
j	int
+	O
1	int
]	O
==	O
SE	int
)	O
j	int
++	O
;	O
else	O
break	O
;	O
}	O
pointer	*(char)
[	O
k	int
++	O
]	O
=	O
pointer	*(char)
[	O
j	int
++	O
]	O
;	O
}	O
printsub	*((*(char),int,*(char),int)->(void))
(	O
0	int
,	O
&	O
pointer	*(char)
[	O
i	int
]	O
,	O
k	int
-	O
i	int
)	O
;	O
if	O
(	O
i	int
<	O
length	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
" SE"	*(char)
)	O
;	O
i	int
=	O
j	int
;	O
}	O
else	O
i	int
=	O
j	int
-	O
1	int
;	O
debug_output_data	(*(char))->(void)
(	O
"\r\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
" %d"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_XDISPLOC	int
:	O
debug_output_data	(*(char))->(void)
(	O
"X-DISPLAY-LOCATION "	*(char)
)	O
;	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	(*(char))->(void)
(	O
"IS \"%.*s\""	*(char)
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	*(char)
+	O
2	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	(*(char))->(void)
(	O
"SEND"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	(*(char))->(void)
(	O
"- unknown qualifier %d (0x%x)."	*(char)
,	O
pointer	*(char)
[	O
1	int
]	O
,	O
pointer	*(char)
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
debug_output_data	(*(char))->(void)
(	O
"NEW-ENVIRON "	*(char)
)	O
;	O
goto	O
env_common1	O
;	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
debug_output_data	(*(char))->(void)
(	O
"OLD-ENVIRON"	*(char)
)	O
;	O
env_common1	O
:	O
switch	O
(	O
pointer	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	(*(char))->(void)
(	O
"IS "	*(char)
)	O
;	O
goto	O
env_common	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	(*(char))->(void)
(	O
"SEND "	*(char)
)	O
;	O
goto	O
env_common	O
;	O
case	O
TELQUAL_INFO	int
:	O
debug_output_data	(*(char))->(void)
(	O
"INFO "	*(char)
)	O
;	O
env_common	O
:	O
{	O
register	O
int	O
noquote	int
=	O
2	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
pointer	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
NEW_ENV_VAR	int
:	O
debug_output_data	(*(char))->(void)
(	O
"\" VAR "	*(char)
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
NEW_ENV_VALUE	int
:	O
debug_output_data	(*(char))->(void)
(	O
"\" VALUE "	*(char)
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
debug_output_data	(*(char))->(void)
(	O
"\" ESC "	*(char)
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
ENV_USERVAR	int
:	O
debug_output_data	(*(char))->(void)
(	O
"\" USERVAR "	*(char)
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
isprint	(int)->(int)
(	O
pointer	*(char)
[	O
i	int
]	O
)	O
&&	O
pointer	*(char)
[	O
i	int
]	O
!=	O
'"'	O
)	O
{	O
if	O
(	O
noquote	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"\""	*(char)
)	O
;	O
noquote	int
=	O
0	int
;	O
}	O
debug_output_datalen	(*(char),long)->(void)
(	O
(	O
char	O
*	O
)	O
&	O
pointer	*(char)
[	O
i	int
]	O
,	O
1	int
)	O
;	O
}	O
else	O
{	O
debug_output_data	(*(char))->(void)
(	O
"\" %03o "	*(char)
+	O
noquote	int
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
noquote	int
=	O
2	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
noquote	int
)	O
debug_output_data	(*(char))->(void)
(	O
"\""	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
TELOPT_OK	O
(	O
pointer	*(char)
[	O
0	int
]	O
)	O
)	O
debug_output_data	(*(char))->(void)
(	O
"%s (unknown)"	*(char)
,	O
TELOPT	O
(	O
pointer	*(char)
[	O
0	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	(*(char))->(void)
(	O
"%d (unknown)"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	(*(char))->(void)
(	O
" %d"	*(char)
,	O
pointer	*(char)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	(*(char))->(void)
(	O
"\r\n"	*(char)
)	O
;	O
}	O
void	O
printdata	(*(char),*(char),int)->(void)
(	O
register	O
char	O
*	O
tag	*(char)
,	O
register	O
char	O
*	O
ptr	*(char)
,	O
register	O
int	O
cnt	int
)	O
{	O
register	O
int	O
i	int
;	O
char	O
xbuf	array(char)
[	O
30	int
]	O
;	O
while	O
(	O
cnt	int
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"%s: "	*(char)
,	O
tag	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
20	int
&&	O
cnt	int
;	O
i	int
++	O
)	O
{	O
debug_output_data	(*(char))->(void)
(	O
"%02x"	*(char)
,	O
*	O
ptr	*(char)
)	O
;	O
xbuf	array(char)
[	O
i	int
]	O
=	O
isprint	(int)->(int)
(	O
*	O
ptr	*(char)
)	O
?	O
*	O
ptr	*(char)
:	O
'.'	O
;	O
if	O
(	O
i	int
%	O
2	int
)	O
debug_output_data	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
cnt	int
--	O
;	O
ptr	*(char)
++	O
;	O
}	O
xbuf	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
debug_output_data	(*(char))->(void)
(	O
" %s\r\n"	*(char)
,	O
xbuf	array(char)
)	O
;	O
}	O
}	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
{	O
int	O
state	*(int)
;	O
int	O
level	int
;	O
char	O
*	O
source	*(char)
;	O
char	O
*	O
cp	*(char)
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
}	O
;	O
static	O
char	O
*	O
_var_short_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
static	O
char	O
*	O
_var_long_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))),*(char),int)->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
,	O
char	O
*	O
start	*(char)
,	O
int	O
length	int
)	O
;	O
static	O
char	O
*	O
_expand_var	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
static	O
void	O
_expand_cond	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
static	O
void	O
_skip_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
static	O
void	O
_expand_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
char	O
*	O
_var_short_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
{	O
char	O
*	O
q	*(char)
;	O
char	O
timebuf	array(char)
[	O
64	int
]	O
;	O
time_t	long
t	long
;	O
switch	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
)	O
{	O
case	O
'a'	O
:	O
return	O
NULL	O
;	O
case	O
'd'	O
:	O
time	struct(long,long)
(	O
&	O
t	long
)	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
timebuf	array(char)
,	O
sizeof	O
(	O
timebuf	array(char)
)	O
,	O
"%l:%M%P on %A, %d %B %Y"	*(char)
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
)	O
;	O
return	O
xstrdup	(*(char))->(*(char))
(	O
timebuf	array(char)
)	O
;	O
case	O
'h'	O
:	O
return	O
xstrdup	(*(char))->(*(char))
(	O
remote_hostname	*(char)
)	O
;	O
case	O
'l'	O
:	O
return	O
xstrdup	(*(char))->(*(char))
(	O
local_hostname	*(char)
)	O
;	O
case	O
't'	O
:	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
line	array(char)
+	O
1	int
,	O
'/'	O
)	O
;	O
if	O
(	O
q	*(char)
)	O
q	*(char)
++	O
;	O
else	O
q	*(char)
=	O
line	array(char)
;	O
return	O
xstrdup	(*(char))->(*(char))
(	O
q	*(char)
)	O
;	O
case	O
'T'	O
:	O
return	O
terminaltype	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
terminaltype	*(char)
)	O
:	O
NULL	O
;	O
case	O
'u'	O
:	O
return	O
user_name	*(char)
?	O
xstrdup	(*(char))->(*(char))
(	O
user_name	*(char)
)	O
:	O
NULL	O
;	O
default	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
state	*(int)
=	O
EXP_STATE_ERROR	int
;	O
return	O
NULL	O
;	O
}	O
}	O
char	O
*	O
_var_long_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))),*(char),int)->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
,	O
char	O
*	O
start	*(char)
,	O
int	O
length	int
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
state	*(int)
=	O
EXP_STATE_ERROR	int
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
_expand_var	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
{	O
char	O
*	O
p	*(void)
;	O
switch	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
)	O
{	O
case	O
'{'	O
:	O
for	O
(	O
p	*(void)
=	O
++	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
;	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
&&	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
!=	O
'}'	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
==	O
0	int
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
=	O
p	*(void)
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
state	*(int)
=	O
EXP_STATE_ERROR	int
;	O
break	O
;	O
}	O
p	*(void)
=	O
_var_long_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))),*(char),int)->(*(char))
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
,	O
p	*(void)
,	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
-	O
p	*(void)
)	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
break	O
;	O
default	O
:	O
p	*(void)
=	O
_var_short_name	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
void	O
_expand_cond	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
{	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
*	O
++	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
==	O
'?'	O
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
p	*(void)
=	O
_expand_var	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
if	O
(	O
p	*(void)
)	O
{	O
_expand_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
_skip_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
}	O
else	O
{	O
_skip_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
_expand_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
else	O
{	O
p	*(void)
=	O
_expand_var	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(*(char))
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
if	O
(	O
p	*(void)
)	O
obstack_grow	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
p	*(void)
,	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
}	O
void	O
_skip_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
{	O
int	O
level	int
=	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
;	O
if	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
!=	O
'{'	O
)	O
return	O
;	O
for	O
(	O
;	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
)	O
{	O
case	O
'{'	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
--	O
;	O
if	O
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
==	O
level	int
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
void	O
_expand_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
{	O
int	O
level	int
=	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
;	O
if	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
==	O
'{'	O
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
++	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
}	O
while	O
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
state	*(int)
==	O
EXP_STATE_CONTINUE	int
)	O
{	O
for	O
(	O
;	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
&&	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
!=	O
'%'	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
)	O
{	O
case	O
'{'	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
--	O
;	O
if	O
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
level	int
==	O
level	int
)	O
{	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
'\\'	O
:	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
++	O
;	O
break	O
;	O
}	O
obstack_1grow	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
)	O
;	O
}	O
if	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
==	O
0	int
)	O
{	O
obstack_1grow	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
state	*(int)
=	O
EXP_STATE_SUCCESS	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
==	O
'%'	O
&&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
[	O
1	int
]	O
==	O
'%'	O
)	O
{	O
obstack_1grow	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
*	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
)	O
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
->	O
cp	*(char)
+=	O
2	int
;	O
continue	O
;	O
}	O
_expand_cond	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
}	O
}	O
char	O
*	O
expand_line	(*(char))->(*(char))
(	O
const	O
char	O
*	O
line	array(char)
)	O
{	O
char	O
*	O
p	*(void)
=	O
NULL	O
;	O
struct	O
line_expander	struct(int,int,*(char),*(char),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int))
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
state	*(int)
=	O
EXP_STATE_CONTINUE	int
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
level	int
=	O
0	int
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
source	*(char)
=	O
(	O
char	O
*	O
)	O
line	array(char)
;	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
cp	*(char)
=	O
(	O
char	O
*	O
)	O
line	array(char)
;	O
obstack_init	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
_expand_block	(*(struct(int,int,*(char),*(char),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int))))->(void)
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
)	O
;	O
if	O
(	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
state	*(int)
==	O
EXP_STATE_SUCCESS	int
)	O
p	*(void)
=	O
xstrdup	(*(char))->(*(char))
(	O
obstack_finish	O
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
)	O
;	O
else	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"can't expand line: %s"	*(char)
,	O
line	array(char)
)	O
;	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"stopped near %s"	*(char)
,	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
cp	*(char)
?	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
cp	*(char)
:	O
"(END)"	*(char)
)	O
;	O
}	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
exp	*(struct(int,int,*(char),*(char),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)))
.	O
stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
