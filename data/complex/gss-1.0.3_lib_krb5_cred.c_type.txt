static	O
OM_uint32	int
acquire_cred1	(*(int),*(struct(long,*(char),*(struct(int,*`)))),int,*(struct(long,*(struct(int,*`)))),int,*(*(struct(*(struct`)))),*(*(struct(long,*(struct`)))),*(int))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
desired_name	*(struct)
,	O
OM_uint32	int
time_req	int
,	O
const	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
desired_mechs	*(struct(long,*(struct(int,*(void)))))
,	O
gss_cred_usage_t	int
cred_usage	int
,	O
gss_cred_id_t	*(struct)
*	O
output_cred_handle	*(*(struct))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
,	O
OM_uint32	int
*	O
time_rec	*(int)
)	O
{	O
gss_name_t	*(struct)
name	*(*(struct))
=	O
desired_name	*(struct)
;	O
_gss_krb5_cred_t	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
=	O
(	O
*	O
output_cred_handle	*(*(struct))
)	O
->	O
krb5	O
;	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
desired_name	*(struct)
==	O
GSS_C_NO_NAME	O
)	O
{	O
gss_buffer_desc	struct(long,*(void))
buf	struct(long,*(void))
=	O
{	O
4	int
,	O
(	O
char	O
*	O
)	O
"host"	*(char)
}	O
;	O
maj_stat	int
=	O
gss_import_name	(*(int),*(struct(long,*(void))),*(struct(int,*(void))),*(*(struct)))->(int)
(	O
minor_status	*(int)
,	O
&	O
buf	struct(long,*(void))
,	O
GSS_C_NT_HOSTBASED_SERVICE	*(struct(int,*(void)))
,	O
&	O
name	*(*(struct))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
maj_stat	int
=	O
gss_krb5_canonicalize_name	(*(int),*(struct(long,*(char),*(struct(int,*`)))),*(struct(int,*(void))),*(*(struct(long,*(char),*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
name	*(*(struct))
,	O
GSS_KRB5	O
,	O
&	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
if	O
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
==	O
GSS_C_NO_NAME	O
)	O
{	O
maj_stat	int
=	O
gss_release_name	(*(int),*(*(struct)))->(int)
(	O
minor_status	*(int)
,	O
&	O
name	*(*(struct))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
return	O
GSS_S_BAD_NAME	O
;	O
}	O
if	O
(	O
shishi_init_server	()->(int)
(	O
&	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
sh	*(int)
)	O
!=	O
SHISHI_OK	O
)	O
return	O
GSS_S_FAILURE	O
;	O
{	O
char	O
*	O
p	*(char)
;	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
->	O
length	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
->	O
value	*(void)
,	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
->	O
length	int
)	O
;	O
p	*(char)
[	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
->	O
length	int
]	O
=	O
0	int
;	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
key	*(int)
=	O
shishi_hostkeys_for_serverrealm	()->(int)
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
sh	*(int)
,	O
p	*(char)
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
key	*(int)
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
GSS_KRB5_S_KG_KEYTAB_NOMATCH	O
;	O
return	O
GSS_S_NO_CRED	O
;	O
}	O
if	O
(	O
time_rec	*(int)
)	O
*	O
time_rec	*(int)
=	O
GSS_C_INDEFINITE	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_krb5_acquire_cred	(*(int),*(struct(long,*(char),*(struct(int,*`)))),int,*(struct(long,*(struct(int,*`)))),int,*(*(struct(*(struct`)))),*(*(struct(long,*(struct`)))),*(int))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_name_t	*(struct)
desired_name	*(struct)
,	O
OM_uint32	int
time_req	int
,	O
const	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
desired_mechs	*(struct(long,*(struct(int,*(void)))))
,	O
gss_cred_usage_t	int
cred_usage	int
,	O
gss_cred_id_t	*(struct)
*	O
output_cred_handle	*(*(struct))
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
,	O
OM_uint32	int
*	O
time_rec	*(int)
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
gss_cred_id_t	*(struct)
p	*(char)
=	O
*	O
output_cred_handle	*(*(struct))
;	O
p	*(char)
->	O
krb5	O
=	O
calloc	(long,long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
->	O
krb5	O
)	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(char)
->	O
krb5	O
)	O
{	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
if	O
(	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
maj_stat	int
=	O
gss_create_empty_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
krb5	O
)	O
;	O
return	O
maj_stat	int
;	O
}	O
maj_stat	int
=	O
gss_add_oid_set_member	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
GSS_KRB5	O
,	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
krb5	O
)	O
;	O
return	O
maj_stat	int
;	O
}	O
}	O
maj_stat	int
=	O
acquire_cred1	(*(int),*(struct(long,*(char),*(struct(int,*`)))),int,*(struct(long,*(struct(int,*`)))),int,*(*(struct(*(struct`)))),*(*(struct(long,*(struct`)))),*(int))->(int)
(	O
minor_status	*(int)
,	O
desired_name	*(struct)
,	O
time_req	int
,	O
desired_mechs	*(struct(long,*(struct(int,*(void)))))
,	O
cred_usage	int
,	O
&	O
p	*(char)
,	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
,	O
time_rec	*(int)
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
{	O
if	O
(	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
)	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
NULL	O
,	O
actual_mechs	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
krb5	O
)	O
;	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
static	O
OM_uint32	int
inquire_cred	(*(int),*(struct(*(struct(int,*`)))),*(*(struct(long,*(char),*(struct`)))),*(int),*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_cred_id_t	*(struct)
cred_handle	*(*(struct))
,	O
gss_name_t	*(struct)
*	O
name	*(*(struct))
,	O
OM_uint32	int
*	O
lifetime	*(int)
,	O
gss_cred_usage_t	int
*	O
cred_usage	int
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
cred_handle	*(*(struct))
==	O
GSS_C_NO_CREDENTIAL	O
)	O
return	O
GSS_S_NO_CRED	O
;	O
if	O
(	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
maj_stat	int
=	O
gss_create_empty_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
maj_stat	int
=	O
gss_add_oid_set_member	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
GSS_KRB5	O
,	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
name	*(*(struct))
)	O
{	O
maj_stat	int
=	O
gss_duplicate_name	(*(int),*(struct),*(*(struct)))->(int)
(	O
minor_status	*(int)
,	O
cred_handle	*(*(struct))
->	O
krb5	O
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
,	O
name	*(*(struct))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
if	O
(	O
cred_usage	int
)	O
*	O
cred_usage	int
=	O
GSS_C_BOTH	int
;	O
if	O
(	O
lifetime	*(int)
)	O
*	O
lifetime	*(int)
=	O
GSS_C_INDEFINITE	int
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_krb5_inquire_cred	(*(int),*(struct(*(struct(int,*`)))),*(*(struct(long,*(char),*(struct`)))),*(int),*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_cred_id_t	*(struct)
cred_handle	*(*(struct))
,	O
gss_name_t	*(struct)
*	O
name	*(*(struct))
,	O
OM_uint32	int
*	O
lifetime	*(int)
,	O
gss_cred_usage_t	int
*	O
cred_usage	int
,	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
*	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
{	O
return	O
inquire_cred	(*(int),*(struct(*(struct(int,*`)))),*(*(struct(long,*(char),*(struct`)))),*(int),*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
cred_handle	*(*(struct))
,	O
name	*(*(struct))
,	O
lifetime	*(int)
,	O
cred_usage	int
,	O
mechanisms	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
}	O
OM_uint32	int
gss_krb5_inquire_cred_by_mech	(*(int),*(struct(*(struct(int,*`)))),*(struct(int,*(void))),*(*(struct(long,*(char),*(struct`)))),*(int),*(int),*(int))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
const	O
gss_cred_id_t	*(struct)
cred_handle	*(*(struct))
,	O
const	O
gss_OID	*(struct(int,*(void)))
mech_type	*(struct(int,*(void)))
,	O
gss_name_t	*(struct)
*	O
name	*(*(struct))
,	O
OM_uint32	int
*	O
initiator_lifetime	*(int)
,	O
OM_uint32	int
*	O
acceptor_lifetime	*(int)
,	O
gss_cred_usage_t	int
*	O
cred_usage	int
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
maj_stat	int
=	O
inquire_cred	(*(int),*(struct(*(struct(int,*`)))),*(*(struct(long,*(char),*(struct`)))),*(int),*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
minor_status	*(int)
,	O
cred_handle	*(*(struct))
,	O
name	*(*(struct))
,	O
initiator_lifetime	*(int)
,	O
cred_usage	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acceptor_lifetime	*(int)
)	O
*	O
acceptor_lifetime	*(int)
=	O
*	O
initiator_lifetime	*(int)
;	O
return	O
maj_stat	int
;	O
}	O
OM_uint32	int
gss_krb5_release_cred	(*(int),*(*(struct(*(struct`)))))->(int)
(	O
OM_uint32	int
*	O
minor_status	*(int)
,	O
gss_cred_id_t	*(struct)
*	O
cred_handle	*(*(struct))
)	O
{	O
_gss_krb5_cred_t	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
=	O
(	O
*	O
cred_handle	*(*(struct))
)	O
->	O
krb5	O
;	O
if	O
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
!=	O
GSS_C_NO_NAME	O
)	O
gss_release_name	(*(int),*(*(struct)))->(int)
(	O
NULL	O
,	O
&	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
peerptr	*(struct(long,*(char),*(struct(int,*(void)))))
)	O
;	O
shishi_key_done	()->(int)
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
key	*(int)
)	O
;	O
shishi_done	()->(int)
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
->	O
sh	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
k5	*(struct(*(int),*(struct(long,*(char),*(struct`))),*(int)))
)	O
;	O
if	O
(	O
minor_status	*(int)
)	O
*	O
minor_status	*(int)
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
