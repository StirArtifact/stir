bfd_boolean	int
_bfd_elf_create_ifunc_sections	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
struct	O
bfd_link_info	O
*	O
info	*(void)
)	O
{	O
flagword	int
flags	int
,	O
pltflags	O
;	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
s	*(void)
;	O
const	O
struct	O
elf_backend_data	O
*	O
bed	O
=	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
;	O
struct	O
elf_link_hash_table	O
*	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
=	O
elf_hash_table	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
irelifunc	O
!=	O
NULL	O
||	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
iplt	O
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
flags	int
=	O
bed	O
->	O
dynamic_sec_flags	O
;	O
pltflags	O
=	O
flags	int
;	O
if	O
(	O
bed	O
->	O
plt_not_loaded	O
)	O
pltflags	O
&=	O
~	O
(	O
SEC_CODE	O
|	O
SEC_LOAD	O
|	O
SEC_HAS_CONTENTS	O
)	O
;	O
else	O
pltflags	O
|=	O
SEC_ALLOC	O
|	O
SEC_CODE	O
|	O
SEC_LOAD	O
;	O
if	O
(	O
bed	O
->	O
plt_readonly	O
)	O
pltflags	O
|=	O
SEC_READONLY	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	*(void)
)	O
)	O
{	O
const	O
char	O
*	O
rel_sec	O
=	O
(	O
bed	O
->	O
rela_plts_and_copies_p	O
?	O
".rela.ifunc"	*(char)
:	O
".rel.ifunc"	*(char)
)	O
;	O
s	*(void)
=	O
bfd_make_section_with_flags	(*(struct),*(char),int)->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
rel_sec	O
,	O
flags	int
|	O
SEC_READONLY	O
)	O
;	O
if	O
(	O
s	*(void)
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
s	*(void)
,	O
bed	O
->	O
s	*(void)
->	O
log_file_align	O
)	O
)	O
return	O
FALSE	O
;	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
irelifunc	O
=	O
s	*(void)
;	O
}	O
else	O
{	O
s	*(void)
=	O
bfd_make_section_with_flags	(*(struct),*(char),int)->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
".iplt"	*(char)
,	O
pltflags	O
)	O
;	O
if	O
(	O
s	*(void)
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
s	*(void)
,	O
bed	O
->	O
plt_alignment	O
)	O
)	O
return	O
FALSE	O
;	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
iplt	O
=	O
s	*(void)
;	O
s	*(void)
=	O
bfd_make_section_with_flags	(*(struct),*(char),int)->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
(	O
bed	O
->	O
rela_plts_and_copies_p	O
?	O
".rela.iplt"	*(char)
:	O
".rel.iplt"	*(char)
)	O
,	O
flags	int
|	O
SEC_READONLY	O
)	O
;	O
if	O
(	O
s	*(void)
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
s	*(void)
,	O
bed	O
->	O
s	*(void)
->	O
log_file_align	O
)	O
)	O
return	O
FALSE	O
;	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
irelplt	O
=	O
s	*(void)
;	O
if	O
(	O
bed	O
->	O
want_got_plt	O
)	O
s	*(void)
=	O
bfd_make_section_with_flags	(*(struct),*(char),int)->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
".igot.plt"	*(char)
,	O
flags	int
)	O
;	O
else	O
s	*(void)
=	O
bfd_make_section_with_flags	(*(struct),*(char),int)->(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))
(	O
abfd	*(struct)
,	O
".igot"	*(char)
,	O
flags	int
)	O
;	O
if	O
(	O
s	*(void)
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
s	*(void)
,	O
bed	O
->	O
s	*(void)
->	O
log_file_align	O
)	O
)	O
return	O
FALSE	O
;	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
igotplt	O
=	O
s	*(void)
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_allocate_ifunc_dyn_relocs	O
(	O
struct	O
bfd_link_info	O
*	O
info	*(void)
,	O
struct	O
elf_link_hash_entry	O
*	O
h	O
,	O
struct	O
elf_dyn_relocs	O
*	O
*	O
head	O
,	O
bfd_boolean	int
*	O
readonly_dynrelocs_against_ifunc_p	O
,	O
unsigned	O
int	O
plt_entry_size	O
,	O
unsigned	O
int	O
plt_header_size	O
,	O
unsigned	O
int	O
got_entry_size	O
,	O
bfd_boolean	int
avoid_plt	O
)	O
{	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
plt	O
,	O
*	O
gotplt	O
,	O
*	O
relplt	O
;	O
struct	O
elf_dyn_relocs	O
*	O
p	*(void)
;	O
unsigned	O
int	O
sizeof_reloc	O
;	O
const	O
struct	O
elf_backend_data	O
*	O
bed	O
;	O
struct	O
elf_link_hash_table	O
*	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
;	O
bfd_boolean	int
readonly_dynrelocs_against_ifunc	O
;	O
bfd_boolean	int
use_plt	O
=	O
!	O
avoid_plt	O
||	O
h	O
->	O
plt	O
.	O
refcount	O
>	O
0	int
;	O
bfd_boolean	int
need_dynreloc	O
=	O
!	O
use_plt	O
||	O
bfd_link_pic	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
!	O
need_dynreloc	O
&&	O
!	O
(	O
bfd_link_pde	O
(	O
info	*(void)
)	O
&&	O
h	O
->	O
def_regular	O
)	O
&&	O
(	O
h	O
->	O
dynindx	O
!=	O
-	O
1	int
||	O
info	*(void)
->	O
export_dynamic	O
)	O
&&	O
h	O
->	O
pointer_equality_needed	O
)	O
{	O
info	*(void)
->	O
callbacks	O
->	O
einfo	O
(	O
_	O
(	O
"%F%P: dynamic STT_GNU_IFUNC symbol `%s' with pointer "	*(char)
"equality in `%pB' can not be used when making an "	*(char)
"executable; recompile with -fPIE and relink with -pie\n"	*(char)
)	O
,	O
h	O
->	O
root	O
.	O
root	O
.	O
string	*(char)
,	O
h	O
->	O
root	O
.	O
u	union(long,*(struct))
.	O
def	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
owner	*(struct)
)	O
;	O
bfd_set_error	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	O
;	O
}	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
=	O
elf_hash_table	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
need_dynreloc	O
&&	O
h	O
->	O
ref_regular	O
)	O
{	O
bfd_boolean	int
keep	O
=	O
FALSE	O
;	O
for	O
(	O
p	*(void)
=	O
*	O
head	O
;	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
p	*(void)
->	O
count	int
)	O
{	O
h	O
->	O
non_got_ref	O
=	O
1	int
;	O
keep	O
=	O
TRUE	int
;	O
if	O
(	O
p	*(void)
->	O
pc_count	O
)	O
{	O
use_plt	O
=	O
TRUE	int
;	O
need_dynreloc	O
=	O
bfd_link_pic	O
(	O
info	*(void)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
keep	O
)	O
goto	O
keep	O
;	O
}	O
if	O
(	O
h	O
->	O
plt	O
.	O
refcount	O
<=	O
0	int
&&	O
h	O
->	O
got	O
.	O
refcount	O
<=	O
0	int
)	O
{	O
h	O
->	O
got	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
init_got_offset	O
;	O
h	O
->	O
plt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
init_plt_offset	O
;	O
*	O
head	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
h	O
->	O
ref_regular	O
)	O
{	O
if	O
(	O
h	O
->	O
plt	O
.	O
refcount	O
>	O
0	int
||	O
h	O
->	O
got	O
.	O
refcount	O
>	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
h	O
->	O
got	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
init_got_offset	O
;	O
h	O
->	O
plt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
init_plt_offset	O
;	O
*	O
head	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
keep	O
:	O
bed	O
=	O
get_elf_backend_data	O
(	O
info	*(void)
->	O
output_bfd	*(struct)
)	O
;	O
if	O
(	O
bed	O
->	O
rela_plts_and_copies_p	O
)	O
sizeof_reloc	O
=	O
bed	O
->	O
s	*(void)
->	O
sizeof_rela	O
;	O
else	O
sizeof_reloc	O
=	O
bed	O
->	O
s	*(void)
->	O
sizeof_rel	O
;	O
if	O
(	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
splt	O
!=	O
NULL	O
)	O
{	O
plt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
splt	O
;	O
gotplt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
sgotplt	O
;	O
relplt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
srelplt	O
;	O
if	O
(	O
plt	O
->	O
size	long
==	O
0	int
&&	O
use_plt	O
)	O
plt	O
->	O
size	long
+=	O
plt_header_size	O
;	O
}	O
else	O
{	O
plt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
iplt	O
;	O
gotplt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
igotplt	O
;	O
relplt	O
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
irelplt	O
;	O
}	O
if	O
(	O
use_plt	O
)	O
{	O
h	O
->	O
plt	O
.	O
offset	long
=	O
plt	O
->	O
size	long
;	O
plt	O
->	O
size	long
+=	O
plt_entry_size	O
;	O
gotplt	O
->	O
size	long
+=	O
got_entry_size	O
;	O
}	O
if	O
(	O
use_plt	O
)	O
{	O
relplt	O
->	O
size	long
+=	O
sizeof_reloc	O
;	O
relplt	O
->	O
reloc_count	int
++	O
;	O
}	O
if	O
(	O
!	O
need_dynreloc	O
||	O
!	O
h	O
->	O
non_got_ref	O
)	O
*	O
head	O
=	O
NULL	O
;	O
readonly_dynrelocs_against_ifunc	O
=	O
FALSE	O
;	O
p	*(void)
=	O
*	O
head	O
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
)	O
{	O
bfd_size_type	long
count	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
!	O
readonly_dynrelocs_against_ifunc	O
)	O
{	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
s	*(void)
=	O
p	*(void)
->	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
output_section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
s	*(void)
!=	O
NULL	O
&&	O
(	O
s	*(void)
->	O
flags	int
&	O
SEC_READONLY	O
)	O
!=	O
0	int
)	O
readonly_dynrelocs_against_ifunc	O
=	O
TRUE	int
;	O
}	O
count	int
+=	O
p	*(void)
->	O
count	int
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
while	O
(	O
p	*(void)
!=	O
NULL	O
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	*(void)
)	O
)	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
irelifunc	O
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	O
;	O
else	O
if	O
(	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
splt	O
!=	O
NULL	O
)	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
srelgot	O
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	O
;	O
else	O
{	O
relplt	O
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	O
;	O
relplt	O
->	O
reloc_count	int
+=	O
count	int
;	O
}	O
}	O
if	O
(	O
readonly_dynrelocs_against_ifunc_p	O
)	O
*	O
readonly_dynrelocs_against_ifunc_p	O
=	O
readonly_dynrelocs_against_ifunc	O
;	O
if	O
(	O
use_plt	O
&&	O
(	O
h	O
->	O
got	O
.	O
refcount	O
<=	O
0	int
||	O
(	O
bfd_link_pic	O
(	O
info	*(void)
)	O
&&	O
(	O
h	O
->	O
dynindx	O
==	O
-	O
1	int
||	O
h	O
->	O
forced_local	O
)	O
)	O
||	O
(	O
!	O
bfd_link_pic	O
(	O
info	*(void)
)	O
&&	O
!	O
h	O
->	O
pointer_equality_needed	O
)	O
||	O
bfd_link_pie	O
(	O
info	*(void)
)	O
||	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
sgot	O
==	O
NULL	O
)	O
)	O
{	O
h	O
->	O
got	O
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
use_plt	O
)	O
{	O
h	O
->	O
plt	O
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
h	O
->	O
got	O
.	O
refcount	O
<=	O
0	int
)	O
{	O
h	O
->	O
got	O
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
h	O
->	O
got	O
.	O
offset	long
=	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
sgot	O
->	O
size	long
;	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
sgot	O
->	O
size	long
+=	O
got_entry_size	O
;	O
if	O
(	O
need_dynreloc	O
)	O
{	O
if	O
(	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
splt	O
!=	O
NULL	O
)	O
htab	struct(*((*(void))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(*(void)),long,long,long,int,int,*((long,long)->(*(void))),*((*(void))->(void)),*(void),*((*(void),long,long)->(*(void))),*((*(void),*(void))->(void)),int)
->	O
srelgot	O
->	O
size	long
+=	O
sizeof_reloc	O
;	O
else	O
{	O
relplt	O
->	O
size	long
+=	O
sizeof_reloc	O
;	O
relplt	O
->	O
reloc_count	int
++	O
;	O
}	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
