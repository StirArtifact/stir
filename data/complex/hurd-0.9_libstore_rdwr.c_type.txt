static	O
inline	O
store_offset_t	long
store_find_first_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long,*(*(struct(long,long))),*(*(struct(long,long))),*(long),*(long))->(long)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
store_offset_t	long
addr	long
,	O
struct	O
store_run	struct(long,long)
*	O
*	O
run	*(*(struct(long,long)))
,	O
struct	O
store_run	struct(long,long)
*	O
*	O
runs_end	*(*(struct(long,long)))
,	O
store_offset_t	long
*	O
base	*(long)
,	O
size_t	long
*	O
index	(*(char),int)->(*(char))
)	O
{	O
struct	O
store_run	struct(long,long)
*	O
tail	*(struct(long,long))
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
runs	*(struct(long,long))
,	O
*	O
tail_end	*(struct(long,long))
=	O
tail	*(struct(long,long))
+	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
num_runs	long
;	O
store_offset_t	long
wrap_src	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
;	O
if	O
(	O
addr	long
>=	O
wrap_src	long
&&	O
addr	long
<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
)	O
{	O
*	O
base	*(long)
=	O
addr	long
/	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_dst	long
;	O
addr	long
%=	O
wrap_src	long
;	O
}	O
else	O
*	O
base	*(long)
=	O
0	int
;	O
while	O
(	O
tail	*(struct(long,long))
<	O
tail_end	*(struct(long,long))
)	O
{	O
store_offset_t	long
run_blocks	long
=	O
tail	*(struct(long,long))
->	O
length	long
;	O
if	O
(	O
run_blocks	long
>	O
addr	long
)	O
{	O
*	O
run	*(*(struct(long,long)))
=	O
tail	*(struct(long,long))
;	O
*	O
runs_end	*(*(struct(long,long)))
=	O
tail_end	*(struct(long,long))
;	O
*	O
index	(*(char),int)->(*(char))
=	O
tail	*(struct(long,long))
-	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
runs	*(struct(long,long))
;	O
return	O
addr	long
;	O
}	O
addr	long
-=	O
run_blocks	long
;	O
tail	*(struct(long,long))
++	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
store_next_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),*(struct(long,long)),*(*(struct(long,long))),*(long),*(long))->(int)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
struct	O
store_run	struct(long,long)
*	O
runs_end	*(*(struct(long,long)))
,	O
struct	O
store_run	struct(long,long)
*	O
*	O
run	*(*(struct(long,long)))
,	O
store_offset_t	long
*	O
base	*(long)
,	O
size_t	long
*	O
index	(*(char),int)->(*(char))
)	O
{	O
(	O
*	O
run	*(*(struct(long,long)))
)	O
++	O
;	O
(	O
*	O
index	(*(char),int)->(*(char))
)	O
++	O
;	O
if	O
(	O
*	O
run	*(*(struct(long,long)))
==	O
runs_end	*(*(struct(long,long)))
)	O
{	O
*	O
run	*(*(struct(long,long)))
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
runs	*(struct(long,long))
;	O
*	O
base	*(long)
+=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_dst	long
;	O
*	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
return	O
(	O
*	O
base	*(long)
<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
)	O
;	O
}	O
else	O
return	O
1	int
;	O
}	O
error_t	(*(int))->(int)
store_write	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long,*(void),long,*(long))->(int)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
store_offset_t	long
addr	long
,	O
const	O
void	O
*	O
buf	*(void)
,	O
size_t	long
len	int
,	O
size_t	long
*	O
amount	*(int)
)	O
{	O
error_t	(*(int))->(int)
err	(*(int))->(int)
;	O
size_t	long
index	(*(char),int)->(*(char))
;	O
store_offset_t	long
base	*(long)
;	O
struct	O
store_run	struct(long,long)
*	O
run	*(*(struct(long,long)))
,	O
*	O
runs_end	*(*(struct(long,long)))
;	O
int	O
block_shift	int
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
;	O
store_write_meth_t	*(int)
write	int
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
class	*(struct)
->	O
write	int
;	O
if	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
flags	int
&	O
STORE_READONLY	int
)	O
return	O
EROFS	O
;	O
if	O
(	O
(	O
addr	long
<<	O
block_shift	int
)	O
+	O
len	int
>	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
size	long
)	O
return	O
EIO	O
;	O
if	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
block_size	long
!=	O
0	int
&&	O
(	O
len	int
&	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
block_size	long
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
EINVAL	O
;	O
addr	long
=	O
store_find_first_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long,*(*(struct(long,long))),*(*(struct(long,long))),*(long),*(long))->(long)
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
addr	long
,	O
&	O
run	*(*(struct(long,long)))
,	O
&	O
runs_end	*(*(struct(long,long)))
,	O
&	O
base	*(long)
,	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
addr	long
<	O
0	int
)	O
err	(*(int))->(int)
=	O
EIO	O
;	O
else	O
if	O
(	O
(	O
len	int
>>	O
block_shift	int
)	O
<=	O
run	*(*(struct(long,long)))
->	O
length	long
-	O
addr	long
)	O
err	(*(int))->(int)
=	O
(	O
*	O
write	int
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
+	O
addr	long
,	O
index	(*(char),int)->(*(char))
,	O
buf	*(void)
,	O
len	int
,	O
amount	*(int)
)	O
;	O
else	O
{	O
mach_msg_type_number_t	O
try	O
,	O
written	O
;	O
try	O
=	O
(	O
run	*(*(struct(long,long)))
->	O
length	long
-	O
addr	long
)	O
<<	O
block_shift	int
;	O
err	(*(int))->(int)
=	O
(	O
*	O
write	int
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
+	O
addr	long
,	O
index	(*(char),int)->(*(char))
,	O
buf	*(void)
,	O
try	O
,	O
&	O
written	O
)	O
;	O
if	O
(	O
!	O
err	(*(int))->(int)
&&	O
written	O
==	O
try	O
)	O
{	O
buf	*(void)
+=	O
written	O
;	O
len	int
-=	O
written	O
;	O
while	O
(	O
store_next_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),*(struct(long,long)),*(*(struct(long,long))),*(long),*(long))->(int)
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
runs_end	*(*(struct(long,long)))
,	O
&	O
run	*(*(struct(long,long)))
,	O
&	O
base	*(long)
,	O
&	O
index	(*(char),int)->(*(char))
)	O
&&	O
run	*(*(struct(long,long)))
->	O
start	long
>=	O
0	int
)	O
{	O
mach_msg_type_number_t	O
seg_written	O
;	O
if	O
(	O
(	O
len	int
>>	O
block_shift	int
)	O
<=	O
run	*(*(struct(long,long)))
->	O
length	long
)	O
try	O
=	O
len	int
;	O
else	O
try	O
=	O
run	*(*(struct(long,long)))
->	O
length	long
<<	O
block_shift	int
;	O
err	(*(int))->(int)
=	O
(	O
*	O
write	int
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
,	O
index	(*(char),int)->(*(char))
,	O
buf	*(void)
,	O
try	O
,	O
&	O
seg_written	O
)	O
;	O
if	O
(	O
err	(*(int))->(int)
)	O
break	O
;	O
written	O
+=	O
seg_written	O
;	O
if	O
(	O
seg_written	O
<	O
try	O
)	O
break	O
;	O
len	int
-=	O
seg_written	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
break	O
;	O
buf	*(void)
+=	O
seg_written	O
;	O
}	O
}	O
*	O
amount	*(int)
=	O
written	O
;	O
}	O
return	O
err	(*(int))->(int)
;	O
}	O
error_t	(*(int))->(int)
store_read	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long,long,*(*(void)),*(long))->(int)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
store_offset_t	long
addr	long
,	O
size_t	long
amount	*(int)
,	O
void	O
*	O
*	O
buf	*(void)
,	O
size_t	long
*	O
len	int
)	O
{	O
size_t	long
index	(*(char),int)->(*(char))
;	O
store_offset_t	long
base	*(long)
;	O
struct	O
store_run	struct(long,long)
*	O
run	*(*(struct(long,long)))
,	O
*	O
runs_end	*(*(struct(long,long)))
;	O
int	O
block_shift	int
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
;	O
store_read_meth_t	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long,long,int,*(*(void)),*(int))->(int))
read	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long,long,int,*(*(void)),*(int))->(int))
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
class	*(struct)
->	O
read	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long,long,int,*(*(void)),*(int))->(int))
;	O
addr	long
=	O
store_find_first_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long,*(*(struct(long,long))),*(*(struct(long,long))),*(long),*(long))->(long)
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
addr	long
,	O
&	O
run	*(*(struct(long,long)))
,	O
&	O
runs_end	*(*(struct(long,long)))
,	O
&	O
base	*(long)
,	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
addr	long
<	O
0	int
||	O
run	*(*(struct(long,long)))
->	O
start	long
<	O
0	int
)	O
return	O
EIO	O
;	O
if	O
(	O
(	O
addr	long
<<	O
block_shift	int
)	O
+	O
amount	*(int)
>	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
size	long
)	O
amount	*(int)
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
size	long
-	O
(	O
addr	long
<<	O
block_shift	int
)	O
;	O
if	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
block_size	long
!=	O
0	int
&&	O
(	O
amount	*(int)
&	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
block_size	long
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
EINVAL	O
;	O
if	O
(	O
(	O
amount	*(int)
>>	O
block_shift	int
)	O
<=	O
run	*(*(struct(long,long)))
->	O
length	long
-	O
addr	long
)	O
return	O
(	O
*	O
read	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long,long,int,*(*(void)),*(int))->(int))
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
+	O
addr	long
,	O
index	(*(char),int)->(*(char))
,	O
amount	*(int)
,	O
buf	*(void)
,	O
len	int
)	O
;	O
else	O
{	O
error_t	(*(int))->(int)
err	(*(int))->(int)
;	O
int	O
all	int
;	O
void	O
*	O
whole_buf	*(void)
=	O
*	O
buf	*(void)
,	O
*	O
buf_end	*(void)
;	O
size_t	long
whole_buf_len	long
=	O
*	O
len	int
;	O
inline	O
error_t	(*(int))->(int)
seg_read	()->(int)
(	O
store_offset_t	long
addr	long
,	O
size_t	long
len	int
,	O
int	O
*	O
all	int
)	O
{	O
void	O
*	O
seg_buf	O
=	O
buf_end	*(void)
;	O
size_t	long
seg_buf_len	O
=	O
len	int
;	O
error_t	(*(int))->(int)
err	(*(int))->(int)
=	O
(	O
*	O
read	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long,long,int,*(*(void)),*(int))->(int))
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
addr	long
,	O
index	(*(char),int)->(*(char))
,	O
len	int
,	O
&	O
seg_buf	O
,	O
&	O
seg_buf_len	O
)	O
;	O
if	O
(	O
!	O
err	(*(int))->(int)
)	O
{	O
if	O
(	O
seg_buf	O
!=	O
buf_end	*(void)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf_end	*(void)
,	O
seg_buf	O
,	O
seg_buf_len	O
)	O
;	O
munmap	(*(void),long)->(int)
(	O
seg_buf	O
,	O
seg_buf_len	O
)	O
;	O
}	O
buf_end	*(void)
+=	O
seg_buf_len	O
;	O
amount	*(int)
-=	O
seg_buf_len	O
;	O
*	O
all	int
=	O
(	O
seg_buf_len	O
==	O
len	int
)	O
;	O
}	O
return	O
err	(*(int))->(int)
;	O
}	O
if	O
(	O
whole_buf_len	long
<	O
amount	*(int)
)	O
{	O
whole_buf_len	long
=	O
amount	*(int)
;	O
whole_buf	*(void)
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
0	int
,	O
amount	*(int)
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
whole_buf	*(void)
==	O
(	O
void	O
*	O
)	O
-	O
1	int
)	O
return	O
errno	O
;	O
}	O
buf_end	*(void)
=	O
whole_buf	*(void)
;	O
err	(*(int))->(int)
=	O
seg_read	()->(int)
(	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
+	O
addr	long
,	O
(	O
run	*(*(struct(long,long)))
->	O
length	long
-	O
addr	long
)	O
<<	O
block_shift	int
,	O
&	O
all	int
)	O
;	O
while	O
(	O
!	O
err	(*(int))->(int)
&&	O
all	int
&&	O
amount	*(int)
>	O
0	int
&&	O
store_next_run	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),*(struct(long,long)),*(*(struct(long,long))),*(long),*(long))->(int)
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
runs_end	*(*(struct(long,long)))
,	O
&	O
run	*(*(struct(long,long)))
,	O
&	O
base	*(long)
,	O
&	O
index	(*(char),int)->(*(char))
)	O
)	O
{	O
if	O
(	O
run	*(*(struct(long,long)))
->	O
start	long
<	O
0	int
)	O
break	O
;	O
else	O
err	(*(int))->(int)
=	O
seg_read	()->(int)
(	O
base	*(long)
+	O
run	*(*(struct(long,long)))
->	O
start	long
,	O
(	O
amount	*(int)
>>	O
block_shift	int
)	O
<=	O
run	*(*(struct(long,long)))
->	O
length	long
?	O
amount	*(int)
:	O
(	O
run	*(*(struct(long,long)))
->	O
length	long
<<	O
block_shift	int
)	O
,	O
&	O
all	int
)	O
;	O
}	O
*	O
len	int
=	O
buf_end	*(void)
-	O
whole_buf	*(void)
;	O
if	O
(	O
*	O
len	int
>	O
0	int
)	O
err	(*(int))->(int)
=	O
0	int
;	O
if	O
(	O
whole_buf	*(void)
!=	O
*	O
buf	*(void)
)	O
{	O
if	O
(	O
err	(*(int))->(int)
)	O
munmap	(*(void),long)->(int)
(	O
whole_buf	*(void)
,	O
whole_buf_len	long
)	O
;	O
else	O
{	O
vm_size_t	O
unused	O
=	O
whole_buf_len	long
-	O
round_page	O
(	O
*	O
len	int
)	O
;	O
if	O
(	O
unused	O
)	O
munmap	(*(void),long)->(int)
(	O
whole_buf	*(void)
+	O
whole_buf_len	long
-	O
unused	O
,	O
unused	O
)	O
;	O
*	O
buf	*(void)
=	O
whole_buf	*(void)
;	O
}	O
}	O
return	O
err	(*(int))->(int)
;	O
}	O
}	O
error_t	(*(int))->(int)
store_set_size	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))),long)->(int)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
size_t	long
newsize	long
)	O
{	O
error_t	(*(int))->(int)
err	(*(int))->(int)
;	O
store_set_size_meth_t	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long)->(int))
set_size	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long)->(int))
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
class	*(struct)
->	O
set_size	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long)->(int))
;	O
err	(*(int))->(int)
=	O
(	O
*	O
set_size	*((*(struct(int,*(struct`),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct`),*(*`),long,*(void))),long)->(int))
)	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
,	O
newsize	long
)	O
;	O
return	O
err	(*(int))->(int)
;	O
}	O
