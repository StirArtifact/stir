void	O
Ldirectory	()->(void)
(	O
void	O
)	O
;	O
void	O
coerce_to_filename	(int,*(char))->(void)
(	O
object	O
pathname	int
,	O
char	O
*	O
p	*(char)
)	O
{	O
object	O
namestring	O
=	O
coerce_to_namestring	O
(	O
pathname	int
)	O
;	O
unsigned	O
e	int
=	O
namestring	O
->	O
st	O
.	O
st_fillp	O
;	O
char	O
*	O
q	*(char)
=	O
namestring	O
->	O
st	O
.	O
st_self	O
,	O
*	O
qe	*(char)
=	O
q	*(char)
+	O
e	int
;	O
;	O
if	O
(	O
pathname	int
==	O
Cnil	O
)	O
FEerror	()->(int)
(	O
"NIL argument."	*(char)
,	O
1	int
,	O
pathname	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
'~'	O
)	O
{	O
unsigned	O
m	int
=	O
0	int
;	O
char	O
*	O
s	*(char)
=	O
++	O
q	*(char)
,	O
*	O
c	*(char)
;	O
for	O
(	O
;	O
s	*(char)
<	O
qe	*(char)
&&	O
*	O
s	*(char)
!=	O
'/'	O
;	O
s	*(char)
++	O
)	O
;	O
if	O
(	O
s	*(char)
==	O
q	*(char)
&&	O
(	O
c	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
)	O
pcopy	O
(	O
c	*(char)
,	O
p	*(char)
,	O
0	int
,	O
m	int
=	O
strlen	(*(char))->(long)
(	O
c	*(char)
)	O
)	O
;	O
else	O
{	O
struct	O
passwd	O
*	O
pwent	*(struct)
;	O
if	O
(	O
s	*(char)
==	O
q	*(char)
)	O
pwent	*(struct)
=	O
getpwuid	()->(int)
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
else	O
{	O
*	O
s	*(char)
=	O
0	int
;	O
pwent	*(struct)
=	O
getpwnam	()->(int)
(	O
q	*(char)
)	O
;	O
*	O
s	*(char)
=	O
'/'	O
;	O
}	O
if	O
(	O
!	O
pwent	*(struct)
)	O
FEerror	()->(int)
(	O
"Can't expand pathname ~a"	*(char)
,	O
1	int
,	O
namestring	O
)	O
;	O
pcopy	O
(	O
pwent	*(struct)
->	O
pw_dir	O
,	O
p	*(char)
,	O
0	int
,	O
m	int
=	O
strlen	(*(char))->(long)
(	O
pwent	*(struct)
->	O
pw_dir	O
)	O
)	O
;	O
}	O
pcopy	O
(	O
s	*(char)
,	O
p	*(char)
,	O
m	int
,	O
qe	*(char)
-	O
s	*(char)
)	O
;	O
}	O
else	O
pcopy	O
(	O
q	*(char)
,	O
p	*(char)
,	O
0	int
,	O
e	int
)	O
;	O
}	O
object	O
truename	(int)->(int)
(	O
object	O
pathname	int
)	O
{	O
register	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
char	O
truefilename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
char	O
current_directory	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
char	O
directory	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
massert	()->(int)
(	O
current_directory	array(char)
==	O
getcwd	(*(char),long)->(*(char))
(	O
current_directory	array(char)
,	O
sizeof	O
(	O
current_directory	array(char)
)	O
)	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
pathname	int
,	O
filename	array(char)
)	O
;	O
for	O
(	O
p	*(char)
=	O
filename	array(char)
,	O
q	*(char)
=	O
0	int
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
if	O
(	O
*	O
p	*(char)
==	O
'/'	O
)	O
q	*(char)
=	O
p	*(char)
;	O
if	O
(	O
q	*(char)
==	O
filename	array(char)
)	O
{	O
q	*(char)
++	O
;	O
p	*(char)
=	O
"/"	*(char)
;	O
}	O
else	O
if	O
(	O
q	*(char)
==	O
0	int
)	O
{	O
q	*(char)
=	O
filename	array(char)
;	O
p	*(char)
=	O
current_directory	array(char)
;	O
}	O
else	O
{	O
*	O
q	*(char)
++	O
=	O
'\0'	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
filename	array(char)
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"Cannot get the truename of ~S."	*(char)
,	O
1	int
,	O
pathname	int
)	O
;	O
p	*(char)
=	O
getcwd	(*(char),long)->(*(char))
(	O
directory	array(char)
,	O
sizeof	O
(	O
directory	array(char)
)	O
)	O
;	O
}	O
if	O
(	O
p	*(char)
[	O
0	int
]	O
==	O
'/'	O
&&	O
p	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
q	*(char)
,	O
".."	*(char)
)	O
==	O
0	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
truefilename	array(char)
,	O
"/."	*(char)
)	O
;	O
else	O
sprintf	O
(	O
truefilename	array(char)
,	O
"/%s"	*(char)
,	O
q	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
q	*(char)
,	O
"."	*(char)
)	O
==	O
0	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
truefilename	array(char)
,	O
p	*(char)
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
q	*(char)
,	O
".."	*(char)
)	O
==	O
0	int
)	O
{	O
for	O
(	O
q	*(char)
=	O
p	*(char)
+	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
*	O
--	O
q	*(char)
!=	O
'/'	O
;	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
q	*(char)
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
truefilename	array(char)
,	O
"/."	*(char)
)	O
;	O
else	O
{	O
*	O
q	*(char)
=	O
'\0'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
truefilename	array(char)
,	O
p	*(char)
)	O
;	O
*	O
q	*(char)
=	O
'/'	O
;	O
}	O
}	O
else	O
sprintf	O
(	O
truefilename	array(char)
,	O
"%s/%s"	*(char)
,	O
p	*(char)
,	O
q	*(char)
)	O
;	O
massert	()->(int)
(	O
!	O
chdir	(*(char))->(int)
(	O
current_directory	array(char)
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_simple_string	()->(int)
(	O
truefilename	array(char)
)	O
)	O
;	O
pathname	int
=	O
coerce_to_pathname	()->(int)
(	O
vs_head	O
)	O
;	O
vs_popp	O
;	O
return	O
(	O
pathname	int
)	O
;	O
}	O
object	O
sSAallow_gzipped_fileA	int
;	O
bool	O
file_exists	(int)->(int)
(	O
object	O
file	int
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
struct	O
stat	()->(int)
filestatus	struct
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
file	int
,	O
filename	array(char)
)	O
;	O
if	O
(	O
stat	()->(int)
(	O
filename	array(char)
,	O
&	O
filestatus	struct
)	O
>=	O
0	int
&&	O
!	O
S_ISDIR	()->(int)
(	O
filestatus	struct
.	O
st_mode	O
)	O
)	O
{	O
return	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
sSAallow_gzipped_fileA	int
->	O
s	*(char)
.	O
s_dbind	O
!=	O
sLnil	O
&&	O
(	O
strcat	(*(char),*(char))->(*(char))
(	O
filename	array(char)
,	O
".gz"	*(char)
)	O
,	O
stat	()->(int)
(	O
filename	array(char)
,	O
&	O
filestatus	struct
)	O
>=	O
0	int
&&	O
!	O
S_ISDIR	()->(int)
(	O
filestatus	struct
.	O
st_mode	O
)	O
)	O
)	O
return	O
TRUE	O
;	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
FILE	O
*	O
fopen_not_dir	(*(char),*(char))->(*(int))
(	O
char	O
*	O
filename	array(char)
,	O
char	O
*	O
option	*(char)
)	O
{	O
struct	O
stat	()->(int)
ss	struct
;	O
if	O
(	O
!	O
stat	()->(int)
(	O
filename	array(char)
,	O
&	O
ss	struct
)	O
&&	O
S_ISDIR	()->(int)
(	O
ss	struct
.	O
st_mode	O
)	O
)	O
return	O
NULL	O
;	O
else	O
return	O
fopen	()->(int)
(	O
filename	array(char)
,	O
option	*(char)
)	O
;	O
}	O
FILE	O
*	O
backup_fopen	(*(char),*(char))->(*(int))
(	O
char	O
*	O
filename	array(char)
,	O
char	O
*	O
option	*(char)
)	O
{	O
char	O
backupfilename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
char	O
command	array(char)
[	O
MAXPATHLEN	int
*	O
2	int
]	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
strcpy	(*(char),*(char))->(*(char))
(	O
backupfilename	array(char)
,	O
filename	array(char)
)	O
,	O
".BAK"	*(char)
)	O
;	O
sprintf	O
(	O
command	array(char)
,	O
"mv %s %s"	*(char)
,	O
filename	array(char)
,	O
backupfilename	array(char)
)	O
;	O
msystem	()->(int)
(	O
command	array(char)
)	O
;	O
return	O
(	O
fopen	()->(int)
(	O
filename	array(char)
,	O
option	*(char)
)	O
)	O
;	O
}	O
int	O
file_len	(*(int))->(int)
(	O
FILE	O
*	O
fp	*(int)
)	O
{	O
struct	O
stat	()->(int)
filestatus	struct
;	O
if	O
(	O
fstat	()->(int)
(	O
fileno	()->(int)
(	O
fp	*(int)
)	O
,	O
&	O
filestatus	struct
)	O
==	O
0	int
)	O
return	O
(	O
filestatus	struct
.	O
st_size	O
)	O
;	O
else	O
return	O
0	int
;	O
}	O
LFD	(int)->(int)
(	O
Ltruename	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
truename	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lrename_file	int
)	O
(	O
void	O
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
char	O
newfilename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
check_type_or_Pathname_string_symbol	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
filename	array(char)
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
coerce_to_pathname	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
1	int
]	O
=	O
coerce_to_pathname	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_base	O
[	O
1	int
]	O
=	O
merge_pathnames	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
,	O
Cnil	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
vs_base	O
[	O
1	int
]	O
,	O
newfilename	array(char)
)	O
;	O
sprintf	O
(	O
command	array(char)
,	O
"mv %s %s"	*(char)
,	O
filename	array(char)
,	O
newfilename	array(char)
)	O
;	O
msystem	()->(int)
(	O
command	array(char)
)	O
;	O
vs_push	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_push	()->(int)
(	O
truename	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
truename	(int)->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
)	O
;	O
vs_base	O
+=	O
2	int
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"DIRECTORY"	*(char)
,	O
sKdirectory	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LINK"	*(char)
,	O
sKlink	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FILE"	*(char)
,	O
sKfile	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
int	O
gcl_putenv	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
return	O
putenv	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
}	O
char	O
*	O
gcl_strncpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
d	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
size_t	long
z	long
)	O
{	O
return	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
d	*(char)
,	O
s	*(char)
,	O
z	long
)	O
;	O
}	O
char	O
*	O
gcl_strncpy_chk	(long)->(*(char))
(	O
size_t	long
z	long
)	O
{	O
char	O
a	array(char)
[	O
10	int
]	O
,	O
b	array(char)
[	O
10	int
]	O
;	O
return	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
a	array(char)
,	O
b	array(char)
,	O
z	long
)	O
;	O
}	O
uid_t	int
gcl_geteuid	()->(int)
(	O
void	O
)	O
{	O
return	O
geteuid	()->(int)
(	O
)	O
;	O
}	O
uid_t	int
gcl_getegid	()->(int)
(	O
void	O
)	O
{	O
return	O
getegid	()->(int)
(	O
)	O
;	O
}	O
int	O
gcl_dup2	(int,int)->(int)
(	O
int	O
o	int
,	O
int	O
n	int
)	O
{	O
return	O
dup2	(int,int)->(int)
(	O
o	int
,	O
n	int
)	O
;	O
}	O
char	O
*	O
gcl_gets	(*(char),int)->(*(char))
(	O
char	O
*	O
s	*(char)
,	O
int	O
z	long
)	O
{	O
return	O
fgets	()->(int)
(	O
s	*(char)
,	O
z	long
,	O
stdin	O
)	O
;	O
}	O
int	O
gcl_puts	(*(char))->(int)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
fputs	()->(int)
(	O
s	*(char)
,	O
stdout	O
)	O
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
return	O
i	int
;	O
}	O
int	O
gcl_feof	(*(void))->(int)
(	O
void	O
*	O
v	*(void)
)	O
{	O
return	O
feof	()->(int)
(	O
(	O
(	O
FILE	O
*	O
)	O
v	*(void)
)	O
)	O
;	O
}	O
int	O
gcl_getc	(*(void))->(int)
(	O
void	O
*	O
v	*(void)
)	O
{	O
return	O
getc	()->(int)
(	O
(	O
(	O
FILE	O
*	O
)	O
v	*(void)
)	O
)	O
;	O
}	O
int	O
gcl_putc	(int,*(void))->(int)
(	O
int	O
i	int
,	O
void	O
*	O
v	*(void)
)	O
{	O
return	O
putc	()->(int)
(	O
i	int
,	O
(	O
(	O
FILE	O
*	O
)	O
v	*(void)
)	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"STAT"	*(char)
,	O
object	O
,	O
fSstat	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
path	O
)	O
,	O
""	*(char)
)	O
{	O
char	O
filename	array(char)
[	O
4096	int
]	O
;	O
struct	O
stat	()->(int)
ss	struct
;	O
bzero	(*(void),long)->(void)
(	O
filename	array(char)
,	O
sizeof	O
(	O
filename	array(char)
)	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
path	O
,	O
filename	array(char)
)	O
;	O
if	O
(	O
lstat	()->(int)
(	O
filename	array(char)
,	O
&	O
ss	struct
)	O
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
else	O
{	O
RETURN1	()->(int)
(	O
list	()->(int)
(	O
3	int
,	O
S_ISDIR	()->(int)
(	O
ss	struct
.	O
st_mode	O
)	O
?	O
sKdirectory	O
:	O
(	O
S_ISLNK	()->(int)
(	O
ss	struct
.	O
st_mode	O
)	O
?	O
sKlink	O
:	O
sKfile	O
)	O
,	O
make_fixnum	()->(int)
(	O
ss	struct
.	O
st_size	O
)	O
,	O
make_fixnum	()->(int)
(	O
ss	struct
.	O
st_ctime	O
)	O
)	O
)	O
;	O
}	O
}	O
DEFUN_NEW	()->(int)
(	O
"SETENV"	*(char)
,	O
object	O
,	O
fSsetenv	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
variable	O
,	O
object	O
value	O
)	O
,	O
"Set environment VARIABLE to VALUE"	*(char)
)	O
{	O
int	O
res	int
=	O
-	O
1	int
;	O
RETURN1	()->(int)
(	O
(	O
res	int
==	O
0	int
?	O
Ct	O
:	O
Cnil	O
)	O
)	O
;	O
}	O
DEFUNO_NEW	()->(int)
(	O
"DELETE-FILE"	*(char)
,	O
object	O
,	O
fLdelete_file	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Ldelete_file	O
,	O
(	O
object	O
path	O
)	O
,	O
""	*(char)
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
path	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
path	O
,	O
filename	array(char)
)	O
;	O
if	O
(	O
unlink	(*(char))->(int)
(	O
filename	array(char)
)	O
<	O
0	int
&&	O
rmdir	(*(char))->(int)
(	O
filename	array(char)
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"Cannot delete the file ~S: ~s."	*(char)
,	O
2	int
,	O
path	O
,	O
make_simple_string	()->(int)
(	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
path	O
=	O
Ct	O
;	O
RETURN1	()->(int)
(	O
path	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lprobe_file	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
file_exists	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
truename	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfile_write_date	int
)	O
(	O
void	O
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
struct	O
stat	()->(int)
filestatus	struct
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
filename	array(char)
)	O
;	O
if	O
(	O
stat	()->(int)
(	O
filename	array(char)
,	O
&	O
filestatus	struct
)	O
<	O
0	int
||	O
S_ISDIR	()->(int)
(	O
filestatus	struct
.	O
st_mode	O
)	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
return	O
;	O
}	O
vs_base	O
[	O
0	int
]	O
=	O
unix_time_to_universal_time	()->(int)
(	O
filestatus	struct
.	O
st_mtime	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfile_author	int
)	O
(	O
void	O
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
struct	O
stat	()->(int)
filestatus	struct
;	O
struct	O
passwd	O
*	O
pwent	*(struct)
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
filename	array(char)
)	O
;	O
if	O
(	O
stat	()->(int)
(	O
filename	array(char)
,	O
&	O
filestatus	struct
)	O
<	O
0	int
||	O
S_ISDIR	()->(int)
(	O
filestatus	struct
.	O
st_mode	O
)	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
return	O
;	O
}	O
pwent	*(struct)
=	O
getpwuid	()->(int)
(	O
filestatus	struct
.	O
st_uid	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
make_simple_string	()->(int)
(	O
pwent	*(struct)
->	O
pw_name	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Luser_homedir_pathname	int
)	O
(	O
void	O
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
make_simple_string	()->(int)
(	O
"~/"	*(char)
)	O
,	O
filename	array(char)
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
coerce_to_pathname	()->(int)
(	O
make_simple_string	()->(int)
(	O
filename	array(char)
)	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"OPENDIR"	*(char)
,	O
object	O
,	O
fSopendir	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	O
)	O
,	O
""	*(char)
)	O
{	O
DIR	O
*	O
d	*(char)
;	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
check_type_string	()->(int)
(	O
&	O
x	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
filename	array(char)
,	O
x	O
->	O
st	O
.	O
st_self	O
,	O
x	O
->	O
st	O
.	O
st_fillp	O
)	O
;	O
filename	array(char)
[	O
x	O
->	O
st	O
.	O
st_fillp	O
]	O
=	O
0	int
;	O
d	*(char)
=	O
opendir	()->(int)
(	O
filename	array(char)
)	O
;	O
return	O
(	O
object	O
)	O
d	*(char)
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"READDIR"	*(char)
,	O
object	O
,	O
fSreaddir	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OI	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
x	O
,	O
fixnum	O
y	O
)	O
,	O
""	*(char)
)	O
{	O
struct	O
dirent	O
*	O
e	int
;	O
object	O
z	long
;	O
if	O
(	O
!	O
x	O
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
e	int
=	O
readdir	()->(int)
(	O
(	O
DIR	O
*	O
)	O
x	O
)	O
;	O
RETURN1	()->(int)
(	O
e	int
?	O
make_simple_string	()->(int)
(	O
e	int
->	O
d_name	O
)	O
:	O
Cnil	O
)	O
;	O
if	O
(	O
!	O
e	int
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
z	long
=	O
make_simple_string	()->(int)
(	O
e	int
->	O
d_name	O
)	O
;	O
RETURN1	()->(int)
(	O
z	long
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"CLOSEDIR"	*(char)
,	O
object	O
,	O
fSclosedir	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
x	O
)	O
,	O
""	*(char)
)	O
{	O
closedir	()->(int)
(	O
(	O
DIR	O
*	O
)	O
x	O
)	O
;	O
return	O
Cnil	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MKDIR"	*(char)
,	O
object	O
,	O
fSmkdir	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	O
)	O
,	O
""	*(char)
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
check_type_string	()->(int)
(	O
&	O
x	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
filename	array(char)
,	O
x	O
->	O
st	O
.	O
st_self	O
,	O
x	O
->	O
st	O
.	O
st_fillp	O
)	O
;	O
filename	array(char)
[	O
x	O
->	O
st	O
.	O
st_fillp	O
]	O
=	O
0	int
;	O
if	O
(	O
mkdir	()->(int)
(	O
filename	array(char)
,	O
01777	int
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"Cannot make the directory ~S."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
RETURN1	()->(int)
(	O
x	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLchdir	int
)	O
(	O
void	O
)	O
{	O
char	O
filename	array(char)
[	O
MAXPATHLEN	int
]	O
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_or_pathname_string_symbol_stream	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
coerce_to_filename	(int,*(char))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
filename	array(char)
)	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
filename	array(char)
)	O
<	O
0	int
)	O
FEerror	()->(int)
(	O
"Can't change the current directory to ~S."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
void	O
gcl_init_unixfsys	()->(void)
(	O
void	O
)	O
{	O
make_function	()->(int)
(	O
"TRUENAME"	*(char)
,	O
Ltruename	int
)	O
;	O
make_function	()->(int)
(	O
"RENAME-FILE"	*(char)
,	O
Lrename_file	int
)	O
;	O
make_function	()->(int)
(	O
"DELETE-FILE"	*(char)
,	O
Ldelete_file	O
)	O
;	O
make_function	()->(int)
(	O
"PROBE-FILE"	*(char)
,	O
Lprobe_file	int
)	O
;	O
make_function	()->(int)
(	O
"FILE-WRITE-DATE"	*(char)
,	O
Lfile_write_date	int
)	O
;	O
make_function	()->(int)
(	O
"FILE-AUTHOR"	*(char)
,	O
Lfile_author	int
)	O
;	O
make_function	()->(int)
(	O
"USER-HOMEDIR-PATHNAME"	*(char)
,	O
Luser_homedir_pathname	int
)	O
;	O
make_function	()->(int)
(	O
"DIRECTORY"	*(char)
,	O
Ldirectory	()->(void)
)	O
;	O
make_si_function	()->(int)
(	O
"CHDIR"	*(char)
,	O
siLchdir	int
)	O
;	O
}	O
