typedef	O
struct	O
temp_dir	struct(*(char),bool)
m4_temp_dir	struct(*(char),bool)
;	O
typedef	O
struct	O
m4_diversion	struct
m4_diversion	struct
;	O
struct	O
m4_diversion	struct
{	O
union	O
{	O
FILE	struct
*	O
file	*(char)
;	O
char	O
*	O
buffer	*(char)
;	O
m4_diversion	struct
*	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
;	O
int	O
divnum	int
;	O
int	O
size	*((*(struct))->(long))
;	O
int	O
used	int
;	O
}	O
;	O
static	O
gl_oset_t	*(struct)
diversion_table	*(struct)
;	O
static	O
m4_diversion	struct
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
;	O
static	O
m4_diversion	struct
*	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
diversion_storage	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
static	O
int	O
total_buffer_size	int
;	O
int	O
current_diversion	int
;	O
static	O
m4_diversion	struct
*	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
static	O
FILE	struct
*	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
char	O
*	O
output_cursor	*(char)
;	O
static	O
int	O
output_unused	int
;	O
int	O
output_current_line	int
;	O
static	O
m4_temp_dir	struct(*(char),bool)
*	O
output_temp_dir	*(struct(*(char),bool))
;	O
static	O
FILE	struct
*	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
FILE	struct
*	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
int	O
tmp_file1_owner	int
;	O
static	O
int	O
tmp_file2_owner	int
;	O
static	O
bool	bool
tmp_file2_recent	bool
;	O
static	O
int	O
cmp_diversion_CB	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
elt1	*(void)
,	O
const	O
void	O
*	O
elt2	*(void)
)	O
{	O
const	O
m4_diversion	struct
*	O
d1	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt1	*(void)
;	O
const	O
m4_diversion	struct
*	O
d2	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt2	*(void)
;	O
return	O
d1	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
-	O
d2	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
;	O
}	O
static	O
bool	bool
threshold_diversion_CB	(*(void),*(void))->(bool)
(	O
const	O
void	O
*	O
elt	*(void)
,	O
const	O
void	O
*	O
threshold	*(void)
)	O
{	O
const	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
return	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
>=	O
*	O
(	O
const	O
int	O
*	O
)	O
threshold	*(void)
;	O
}	O
static	O
void	O
cleanup_tmpfile	()->(void)
(	O
void	O
)	O
{	O
bool	bool
fail	bool
=	O
false	int
;	O
if	O
(	O
diversion_table	*(struct)
)	O
{	O
const	O
void	O
*	O
elt	*(void)
;	O
gl_oset_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_oset_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long))
(	O
diversion_table	*(struct)
)	O
;	O
while	O
(	O
gl_oset_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
!	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
&&	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
&&	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
!=	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"cannot clean temporary file for diversion"	*(char)
)	O
)	O
;	O
fail	bool
=	O
true	int
;	O
}	O
}	O
gl_oset_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
}	O
if	O
(	O
cleanup_temp_dir	(*(struct(*(char),bool)))->(int)
(	O
output_temp_dir	*(struct(*(char),bool))
)	O
!=	O
0	int
)	O
fail	bool
=	O
true	int
;	O
if	O
(	O
fail	bool
)	O
_exit	(int)->(void)
(	O
exit_failure	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
m4_tmpname	(int)->(*(char))
(	O
int	O
divnum	int
)	O
{	O
static	O
char	O
*	O
buffer	*(char)
;	O
static	O
char	O
*	O
tail	*(char)
;	O
if	O
(	O
buffer	*(char)
==	O
NULL	O
)	O
{	O
tail	*(char)
=	O
xasprintf	(*(char))->(*(char))
(	O
"%s/m4-%d"	*(char)
,	O
output_temp_dir	*(struct(*(char),bool))
->	O
dir_name	*(char)
,	O
INT_MAX	O
)	O
;	O
buffer	*(char)
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
&	O
diversion_storage	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
tail	*(char)
,	O
strlen	(*(char))->(long)
(	O
tail	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
tail	*(char)
)	O
;	O
tail	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
buffer	*(char)
,	O
'-'	O
)	O
+	O
1	int
;	O
}	O
assert	O
(	O
0	int
<	O
divnum	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
tail	*(char)
,	O
"%d"	*(char)
,	O
divnum	int
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
static	O
FILE	struct
*	O
m4_tmpfile	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
int	O
divnum	int
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
FILE	struct
*	O
file	*(char)
;	O
if	O
(	O
output_temp_dir	*(struct(*(char),bool))
==	O
NULL	O
)	O
{	O
output_temp_dir	*(struct(*(char),bool))
=	O
create_temp_dir	(*(char),*(char),bool)->(*(struct(*(char),bool)))
(	O
"m4-"	*(char)
,	O
NULL	O
,	O
true	int
)	O
;	O
if	O
(	O
output_temp_dir	*(struct(*(char),bool))
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	*(char)
)	O
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
cleanup_tmpfile	()->(void)
)	O
;	O
}	O
name	*(char)
=	O
m4_tmpname	(int)->(*(char))
(	O
divnum	int
)	O
;	O
register_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
output_temp_dir	*(struct(*(char),bool))
,	O
name	*(char)
)	O
;	O
file	*(char)
=	O
fopen_temp	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
O_BINARY	int
?	O
"wb+"	*(char)
:	O
"w+"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
==	O
NULL	O
)	O
{	O
unregister_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
output_temp_dir	*(struct(*(char),bool))
,	O
name	*(char)
)	O
;	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
set_cloexec_flag	(int,bool)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
,	O
true	int
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"Warning: cannot protect diversion across forks"	*(char)
)	O
)	O
;	O
return	O
file	*(char)
;	O
}	O
static	O
FILE	struct
*	O
m4_tmpopen	(int,bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
int	O
divnum	int
,	O
bool	bool
reread	bool
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
FILE	struct
*	O
file	*(char)
;	O
if	O
(	O
tmp_file1_owner	int
==	O
divnum	int
)	O
{	O
if	O
(	O
reread	bool
&&	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	*(char)
)	O
)	O
;	O
tmp_file2_recent	bool
=	O
false	int
;	O
return	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
if	O
(	O
tmp_file2_owner	int
==	O
divnum	int
)	O
{	O
if	O
(	O
reread	bool
&&	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	*(char)
)	O
)	O
;	O
tmp_file2_recent	bool
=	O
true	int
;	O
return	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
name	*(char)
=	O
m4_tmpname	(int)->(*(char))
(	O
divnum	int
)	O
;	O
file	*(char)
=	O
fopen_temp	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
O_BINARY	int
?	O
"rb+"	*(char)
:	O
"r+"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
set_cloexec_flag	(int,bool)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
,	O
true	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot protect diversion across forks"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
!	O
reread	bool
&&	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(char)
,	O
0	int
,	O
SEEK_END	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	*(char)
)	O
)	O
;	O
return	O
file	*(char)
;	O
}	O
static	O
int	O
m4_tmpclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
FILE	struct
*	O
file	*(char)
,	O
int	O
divnum	int
)	O
{	O
int	O
result	*(*(char))
=	O
0	int
;	O
if	O
(	O
divnum	int
!=	O
tmp_file1_owner	int
&&	O
divnum	int
!=	O
tmp_file2_owner	int
)	O
{	O
if	O
(	O
tmp_file2_recent	bool
)	O
{	O
if	O
(	O
tmp_file1_owner	int
)	O
result	*(*(char))
=	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(char)
;	O
tmp_file1_owner	int
=	O
divnum	int
;	O
}	O
else	O
{	O
if	O
(	O
tmp_file2_owner	int
)	O
result	*(*(char))
=	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(char)
;	O
tmp_file2_owner	int
=	O
divnum	int
;	O
}	O
}	O
return	O
result	*(*(char))
;	O
}	O
static	O
int	O
m4_tmpremove	(int)->(int)
(	O
int	O
divnum	int
)	O
{	O
if	O
(	O
divnum	int
==	O
tmp_file1_owner	int
)	O
{	O
int	O
result	*(*(char))
=	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
result	*(*(char))
)	O
return	O
result	*(*(char))
;	O
tmp_file1_owner	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
divnum	int
==	O
tmp_file2_owner	int
)	O
{	O
int	O
result	*(*(char))
=	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
result	*(*(char))
)	O
return	O
result	*(*(char))
;	O
tmp_file2_owner	int
=	O
0	int
;	O
}	O
return	O
cleanup_temp_file	(*(struct(*(char),bool)),*(char))->(int)
(	O
output_temp_dir	*(struct(*(char),bool))
,	O
m4_tmpname	(int)->(*(char))
(	O
divnum	int
)	O
)	O
;	O
}	O
static	O
FILE	struct
*	O
m4_tmprename	(int,int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
int	O
oldnum	int
,	O
int	O
newnum	int
)	O
{	O
char	O
*	O
oldname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
m4_tmpname	(int)->(*(char))
(	O
oldnum	int
)	O
)	O
;	O
const	O
char	O
*	O
newname	*(char)
=	O
m4_tmpname	(int)->(*(char))
(	O
newnum	int
)	O
;	O
register_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
output_temp_dir	*(struct(*(char),bool))
,	O
newname	*(char)
)	O
;	O
if	O
(	O
oldnum	int
==	O
tmp_file1_owner	int
)	O
{	O
if	O
(	O
RENAME_OPEN_FILE_WORKS	int
)	O
tmp_file1_owner	int
=	O
newnum	int
;	O
else	O
{	O
if	O
(	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file1	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	*(char)
)	O
)	O
;	O
tmp_file1_owner	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
oldnum	int
==	O
tmp_file2_owner	int
)	O
{	O
if	O
(	O
RENAME_OPEN_FILE_WORKS	int
)	O
tmp_file2_owner	int
=	O
newnum	int
;	O
else	O
{	O
if	O
(	O
close_stream_temp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tmp_file2	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	*(char)
)	O
)	O
;	O
tmp_file2_owner	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
oldname	*(char)
,	O
newname	*(char)
)	O
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot create temporary file for diversion"	*(char)
)	O
)	O
;	O
unregister_temp_file	(*(struct(*(char),bool)),*(char))->(void)
(	O
output_temp_dir	*(struct(*(char),bool))
,	O
oldname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
oldname	*(char)
)	O
;	O
return	O
m4_tmpopen	(int,bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
newnum	int
,	O
false	int
)	O
;	O
}	O
void	O
output_init	()->(void)
(	O
void	O
)	O
{	O
diversion_table	*(struct)
=	O
gl_oset_create_empty	(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))->(*(struct))
(	O
GL_AVLTREE_OSET	O
,	O
cmp_diversion_CB	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
.	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
&	O
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
;	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
obstack_init	O
(	O
&	O
diversion_storage	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
void	O
output_exit	()->(void)
(	O
void	O
)	O
{	O
gl_oset_t	*(struct)
table	*(struct)
=	O
diversion_table	*(struct)
;	O
if	O
(	O
tmp_file1_owner	int
)	O
m4_tmpremove	(int)->(int)
(	O
tmp_file1_owner	int
)	O
;	O
if	O
(	O
tmp_file2_owner	int
)	O
m4_tmpremove	(int)->(int)
(	O
tmp_file2_owner	int
)	O
;	O
diversion_table	*(struct)
=	O
NULL	O
;	O
gl_oset_free	(*(struct))->(void)
(	O
table	*(struct)
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
diversion_storage	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
make_room_for	(int)->(void)
(	O
int	O
length	long
)	O
{	O
int	O
wanted_size	int
;	O
m4_diversion	struct
*	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
NULL	O
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
-	O
output_unused	int
;	O
for	O
(	O
wanted_size	int
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
wanted_size	int
<	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
+	O
length	long
;	O
wanted_size	int
=	O
wanted_size	int
==	O
0	int
?	O
INITIAL_BUFFER_SIZE	int
:	O
wanted_size	int
*	O
2	int
)	O
;	O
if	O
(	O
total_buffer_size	int
-	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
+	O
wanted_size	int
>	O
MAXIMUM_TOTAL_SIZE	O
)	O
{	O
int	O
selected_used	int
;	O
char	O
*	O
selected_buffer	*(char)
;	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
int	O
count	long
;	O
gl_oset_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
elt	*(void)
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
selected_used	int
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
+	O
length	long
;	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_oset_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long))
(	O
diversion_table	*(struct)
)	O
;	O
while	O
(	O
gl_oset_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
)	O
)	O
{	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
>	O
selected_used	int
)	O
{	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
selected_used	int
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
}	O
}	O
gl_oset_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
selected_buffer	*(char)
=	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
;	O
total_buffer_size	int
-=	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
0	int
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
m4_tmpfile	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
;	O
if	O
(	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
>	O
0	int
)	O
{	O
count	long
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
selected_buffer	*(char)
,	O
(	O
size_t	long
)	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
,	O
1	int
,	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
;	O
if	O
(	O
count	long
!=	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"ERROR: cannot flush diversion to temporary file"	*(char)
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
selected_buffer	*(char)
)	O
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
1	int
;	O
}	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
==	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
output_cursor	*(char)
=	O
NULL	O
;	O
output_unused	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
FILE	struct
*	O
file	*(char)
=	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(char)
,	O
selected_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	*(char)
)	O
)	O
;	O
}	O
{	O
char	O
*	O
buffer	*(char)
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
=	O
xcharalloc	(long)->(*(char))
(	O
(	O
size_t	long
)	O
wanted_size	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
,	O
buffer	*(char)
,	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
}	O
total_buffer_size	int
+=	O
wanted_size	int
-	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
wanted_size	int
;	O
output_cursor	*(char)
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
+	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
output_unused	int
=	O
wanted_size	int
-	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
}	O
}	O
static	O
void	O
output_character_helper	(int)->(void)
(	O
int	O
character	int
)	O
{	O
make_room_for	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
character	int
,	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
*	O
output_cursor	*(char)
++	O
=	O
character	int
;	O
output_unused	int
--	O
;	O
}	O
}	O
void	O
output_text	(*(char),int)->(void)
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
length	long
)	O
{	O
int	O
count	long
;	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
||	O
!	O
length	long
)	O
return	O
;	O
if	O
(	O
!	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
length	long
>	O
output_unused	int
)	O
make_room_for	(int)->(void)
(	O
length	long
)	O
;	O
if	O
(	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
count	long
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
text	*(char)
,	O
length	long
,	O
1	int
,	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
count	long
!=	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"ERROR: copying inserted file"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
output_cursor	*(char)
,	O
text	*(char)
,	O
(	O
size_t	long
)	O
length	long
)	O
;	O
output_cursor	*(char)
+=	O
length	long
;	O
output_unused	int
-=	O
length	long
;	O
}	O
}	O
void	O
shipout_text	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(char),int,int)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
*	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
length	long
,	O
int	O
line	int
)	O
{	O
static	O
bool	bool
start_of_output_line	bool
=	O
true	int
;	O
const	O
char	O
*	O
cursor	*(char)
;	O
if	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
!=	O
NULL	O
)	O
{	O
obstack_grow	O
(	O
obs	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
,	O
text	*(char)
,	O
length	long
)	O
;	O
return	O
;	O
}	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
!	O
sync_output	int
)	O
switch	O
(	O
length	long
)	O
{	O
case	O
8	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
7	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
6	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
5	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
4	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
3	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
2	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
text	*(char)
++	O
;	O
case	O
1	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
case	O
0	int
:	O
return	O
;	O
default	O
:	O
output_text	(*(char),int)->(void)
(	O
text	*(char)
,	O
length	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
start_of_output_line	bool
)	O
{	O
start_of_output_line	bool
=	O
false	int
;	O
output_current_line	int
++	O
;	O
if	O
(	O
output_current_line	int
!=	O
line	int
)	O
{	O
OUTPUT_CHARACTER	O
(	O
'#'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'l'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'i'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'n'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'e'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
' '	O
)	O
;	O
for	O
(	O
cursor	*(char)
=	O
ntoa	(int,int)->(*(char))
(	O
line	int
,	O
10	int
)	O
;	O
*	O
cursor	*(char)
;	O
cursor	*(char)
++	O
)	O
OUTPUT_CHARACTER	O
(	O
*	O
cursor	*(char)
)	O
;	O
if	O
(	O
output_current_line	int
<	O
1	int
&&	O
current_file	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
OUTPUT_CHARACTER	O
(	O
' '	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'"'	O
)	O
;	O
for	O
(	O
cursor	*(char)
=	O
current_file	*(char)
;	O
*	O
cursor	*(char)
;	O
cursor	*(char)
++	O
)	O
OUTPUT_CHARACTER	O
(	O
*	O
cursor	*(char)
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'"'	O
)	O
;	O
}	O
OUTPUT_CHARACTER	O
(	O
'\n'	O
)	O
;	O
output_current_line	int
=	O
line	int
;	O
}	O
}	O
for	O
(	O
;	O
length	long
--	O
>	O
0	int
;	O
text	*(char)
++	O
)	O
{	O
if	O
(	O
start_of_output_line	bool
)	O
{	O
start_of_output_line	bool
=	O
false	int
;	O
output_current_line	int
++	O
;	O
}	O
OUTPUT_CHARACTER	O
(	O
*	O
text	*(char)
)	O
;	O
if	O
(	O
*	O
text	*(char)
==	O
'\n'	O
)	O
start_of_output_line	bool
=	O
true	int
;	O
}	O
}	O
}	O
void	O
make_diversion	(int)->(void)
(	O
int	O
divnum	int
)	O
{	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
NULL	O
;	O
if	O
(	O
current_diversion	int
==	O
divnum	int
)	O
return	O
;	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
&&	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
{	O
assert	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
;	O
if	O
(	O
!	O
gl_oset_remove	(*(struct),*(void))->(bool)
(	O
diversion_table	*(struct)
,	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
)	O
assert	O
(	O
false	int
)	O
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
}	O
else	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
)	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
-	O
output_unused	int
;	O
else	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
{	O
FILE	struct
*	O
file	*(char)
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(char)
,	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	*(char)
)	O
)	O
;	O
}	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
NULL	O
;	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
output_cursor	*(char)
=	O
NULL	O
;	O
output_unused	int
=	O
0	int
;	O
}	O
current_diversion	int
=	O
divnum	int
;	O
if	O
(	O
divnum	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
divnum	int
==	O
0	int
)	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
&	O
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
;	O
else	O
{	O
const	O
void	O
*	O
elt	*(void)
;	O
if	O
(	O
gl_oset_search_atleast	(*(struct),*((*(void),*(void))->(bool)),*(void),*(*(void)))->(bool)
(	O
diversion_table	*(struct)
,	O
threshold_diversion_CB	(*(void),*(void))->(bool)
,	O
&	O
divnum	int
,	O
&	O
elt	*(void)
)	O
)	O
{	O
m4_diversion	struct
*	O
temp	union(long,*(void))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
temp	union(long,*(void))
->	O
divnum	int
==	O
divnum	int
)	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
temp	union(long,*(void))
;	O
}	O
}	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
==	O
NULL	O
)	O
{	O
if	O
(	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
else	O
{	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
diversion_storage	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
0	int
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
0	int
;	O
}	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
=	O
divnum	int
;	O
gl_oset_add	(*(struct),*(void))->(bool)
(	O
diversion_table	*(struct)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
}	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
)	O
{	O
output_cursor	*(char)
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
+	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
output_unused	int
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
-	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
&&	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
m4_tmpopen	(int,bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
false	int
)	O
;	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
}	O
output_current_line	int
=	O
-	O
1	int
;	O
}	O
void	O
insert_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
file	*(char)
)	O
{	O
static	O
char	O
buffer	*(char)
[	O
COPY_BUFFER_SIZE	O
]	O
;	O
size_t	long
length	long
;	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
return	O
;	O
while	O
(	O
1	int
)	O
{	O
length	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	*(char)
,	O
1	int
,	O
sizeof	O
buffer	*(char)
,	O
file	*(char)
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error reading inserted file"	*(char)
)	O
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
break	O
;	O
output_text	(*(char),int)->(void)
(	O
buffer	*(char)
,	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
insert_diversion_helper	(*(struct(union(*(struct`),*(char),*(struct`)),int,int,int)))->(void)
(	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
if	O
(	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
{	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
)	O
{	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
{	O
assert	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
&&	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
!=	O
&	O
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
&&	O
!	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
output_cursor	*(char)
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
+	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
output_unused	int
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
-	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
=	O
NULL	O
;	O
}	O
else	O
{	O
total_buffer_size	int
-=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
output_text	(*(char),int)->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
{	O
assert	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
&&	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
!=	O
&	O
div0	struct(union(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(struct(union(*`,*`,*`),int,int,int))),int,int,int)
&&	O
!	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
m4_tmprename	(int,int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
;	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
1	int
;	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
m4_tmpopen	(int,bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
true	int
)	O
;	O
insert_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
;	O
}	O
output_current_line	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
)	O
{	O
if	O
(	O
!	O
output_diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
total_buffer_size	int
-=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
;	O
free	(*(void))->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
buffer	*(char)
)	O
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
{	O
FILE	struct
*	O
file	*(char)
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(char)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot clean temporary file for diversion"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
m4_tmpremove	(int)->(int)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"cannot clean temporary file for diversion"	*(char)
)	O
)	O
;	O
}	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
=	O
0	int
;	O
gl_oset_remove	(*(struct),*(void))->(bool)
(	O
diversion_table	*(struct)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
free_list	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
;	O
}	O
void	O
insert_diversion	(int)->(void)
(	O
int	O
divnum	int
)	O
{	O
const	O
void	O
*	O
elt	*(void)
;	O
if	O
(	O
divnum	int
<=	O
0	int
||	O
current_diversion	int
==	O
divnum	int
)	O
return	O
;	O
if	O
(	O
gl_oset_search_atleast	(*(struct),*((*(void),*(void))->(bool)),*(void),*(*(void)))->(bool)
(	O
diversion_table	*(struct)
,	O
threshold_diversion_CB	(*(void),*(void))->(bool)
,	O
&	O
divnum	int
,	O
&	O
elt	*(void)
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
==	O
divnum	int
)	O
insert_diversion_helper	(*(struct(union(*(struct`),*(char),*(struct`)),int,int,int)))->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
}	O
}	O
void	O
undivert_all	()->(void)
(	O
void	O
)	O
{	O
const	O
void	O
*	O
elt	*(void)
;	O
gl_oset_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_oset_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long))
(	O
diversion_table	*(struct)
)	O
;	O
while	O
(	O
gl_oset_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
!=	O
current_diversion	int
)	O
insert_diversion_helper	(*(struct(union(*(struct`),*(char),*(struct`)),int,int,int)))->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
}	O
gl_oset_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
}	O
void	O
freeze_diversions	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
file	*(char)
)	O
{	O
int	O
saved_number	int
;	O
int	O
last_inserted	int
;	O
gl_oset_iterator_t	struct(*(struct),*(struct),long,*(void),*(void),long,long)
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
;	O
const	O
void	O
*	O
elt	*(void)
;	O
saved_number	int
=	O
current_diversion	int
;	O
last_inserted	int
=	O
0	int
;	O
make_diversion	(int)->(void)
(	O
0	int
)	O
;	O
output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(char)
;	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
=	O
gl_oset_iterator	(*(struct))->(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long))
(	O
diversion_table	*(struct)
)	O
;	O
while	O
(	O
gl_oset_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)),*(*(void)))->(bool)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
,	O
&	O
elt	*(void)
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	*(void)
;	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
||	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
{	O
if	O
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
size	*((*(struct))->(long))
)	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"D%d,%d\n"	*(char)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
used	int
)	O
;	O
else	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
=	O
m4_tmpopen	(int,bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
true	int
)	O
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
u	union(struct(*(char)),*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))
.	O
file	*(char)
)	O
,	O
&	O
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot stat diversion"	*(char)
)	O
)	O
;	O
if	O
(	O
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
<	O
0	int
||	O
(	O
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
0UL	int
!=	O
(	O
unsigned	O
long	O
int	O
)	O
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"diversion too large"	*(char)
)	O
)	O
;	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"D%d,%lu\n"	*(char)
,	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
,	O
(	O
unsigned	O
long	O
int	O
)	O
file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
}	O
insert_diversion_helper	(*(struct(union(*(struct`),*(char),*(struct`)),int,int,int)))->(void)
(	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
file	*(char)
)	O
;	O
last_inserted	int
=	O
diversion	*(struct(union(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(union`,int,int,int))),int,int,int))
->	O
divnum	int
;	O
}	O
}	O
gl_oset_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long)))->(void)
(	O
&	O
iter	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct),long,*(void),*(void),long,long)
)	O
;	O
if	O
(	O
saved_number	int
!=	O
last_inserted	int
)	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"D%d,0\n\n"	*(char)
,	O
saved_number	int
)	O
;	O
}	O
