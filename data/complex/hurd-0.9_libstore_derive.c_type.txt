void	O
_store_derive	(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct(enum,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*(struct`)),long,*(void))))->(void)
(	O
struct	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
)	O
{	O
unsigned	O
i	int
;	O
struct	O
store_run	struct(long,long)
*	O
runs	*(struct(long,long))
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
runs	*(struct(long,long))
;	O
unsigned	O
num_runs	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
num_runs	long
;	O
size_t	long
bsize	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
block_size	long
;	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
blocks	long
=	O
0	int
;	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_runs	long
;	O
i	int
++	O
)	O
{	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
+=	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
length	long
;	O
if	O
(	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
start	long
>=	O
0	int
)	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
blocks	long
+=	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
length	long
;	O
}	O
if	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
==	O
0	int
)	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
;	O
else	O
if	O
(	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
)	O
{	O
size_t	long
num_iters	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
/	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
;	O
store_offset_t	long
last_part_base	long
=	O
num_iters	long
*	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
wrap_src	long
;	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
blocks	long
*=	O
num_iters	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_runs	long
;	O
i	int
++	O
)	O
if	O
(	O
last_part_base	long
+	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
length	long
<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
)	O
{	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
blocks	long
+=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
-	O
(	O
last_part_base	long
+	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
length	long
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
start	long
>=	O
0	int
)	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
blocks	long
+=	O
runs	*(struct(long,long))
[	O
i	int
]	O
.	O
length	long
;	O
}	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
size	long
=	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
end	long
*	O
bsize	long
;	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
=	O
0	int
;	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_blocks_per_page	int
=	O
0	int
;	O
if	O
(	O
bsize	long
!=	O
0	int
)	O
{	O
while	O
(	O
(	O
1	int
<<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
)	O
<	O
bsize	long
)	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
++	O
;	O
assert	O
(	O
(	O
1	int
<<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_block_size	int
)	O
==	O
bsize	long
)	O
;	O
while	O
(	O
(	O
bsize	long
<<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_blocks_per_page	int
)	O
<	O
vm_page_size	O
)	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_blocks_per_page	int
++	O
;	O
assert	O
(	O
(	O
bsize	long
<<	O
store	struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct(int,*(struct(long,long)),long,long,long,long,*(char),int,long,long,long,int,int,int,*(void),long,*(struct),*(*(struct`)),long,*(void)))),long,*(void))
->	O
log2_blocks_per_page	int
)	O
==	O
vm_page_size	O
)	O
;	O
}	O
}	O
