struct	O
mh_alias	struct(*(char),*(struct),int)
{	O
char	O
*	O
name	*(char)
;	O
mu_list_t	*(struct)
rcpt_list	*(struct)
;	O
int	O
inclusive	int
;	O
}	O
;	O
static	O
mu_list_t	*(struct)
alias_list	*(struct)
;	O
static	O
mu_list_t	*(struct)
list_create_or_die	()->(*(struct))
(	O
void	O
)	O
{	O
int	O
status	int
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
status	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"can't create list: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
list	*(struct)
;	O
}	O
static	O
char	O
*	O
ali_list_to_string	(*(*(struct)))->(*(char))
(	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
)	O
{	O
size_t	long
n	long
;	O
char	O
*	O
string	*(char)
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
*	O
plist	*(*(struct))
,	O
&	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
1	int
)	O
{	O
mu_list_get	(*(struct),long,*(*(void)))->(int)
(	O
*	O
plist	*(*(struct))
,	O
0	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
string	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	*(char)
;	O
size_t	long
length	long
=	O
0	int
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
*	O
plist	*(*(struct))
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	*(char)
)	O
;	O
length	long
+=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
;	O
}	O
string	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
length	long
+	O
1	int
)	O
;	O
p	*(char)
=	O
string	*(char)
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
s	*(char)
)	O
;	O
p	*(char)
+=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
*	O
p	*(char)
++	O
=	O
' '	O
;	O
}	O
*	O
--	O
p	*(char)
=	O
0	int
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
plist	*(*(struct))
)	O
;	O
return	O
string	*(char)
;	O
}	O
static	O
void	O
ali_append	(*(struct(*(char),*(struct),int)))->(void)
(	O
struct	O
mh_alias	struct(*(char),*(struct),int)
*	O
ali	*(struct(*(char),*(struct),int))
)	O
{	O
if	O
(	O
ali	*(struct(*(char),*(struct),int))
)	O
{	O
if	O
(	O
!	O
alias_list	*(struct)
)	O
alias_list	*(struct)
=	O
list_create_or_die	()->(*(struct))
(	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
alias_list	*(struct)
,	O
ali	*(struct(*(char),*(struct),int))
)	O
;	O
}	O
}	O
static	O
mu_list_t	*(struct)
unix_group_to_list	(*(char))->(*(struct))
(	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
mu_list_t	*(struct)
unix_gid_to_list	(*(char))->(*(struct))
(	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
mu_list_t	*(struct)
unix_passwd_to_list	()->(*(struct))
(	O
void	O
)	O
;	O
int	O
ali_yyerror	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
;	O
int	O
ali_yylex	()->(int)
(	O
void	O
)	O
;	O
extern	O
int	O
ali_yydebug	int
;	O
enum	O
yytokentype	enum(int,int)
{	O
EOL	int
=	O
258	int
,	O
STRING	int
=	O
259	int
}	O
;	O
typedef	O
union	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
{	O
char	O
*	O
string	*(char)
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
struct	O
mh_alias	struct(*(char),*(struct),int)
*	O
alias	*(char)
;	O
}	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
extern	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
extern	O
YYLTYPE	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
ali_yyparse	()->(int)
(	O
void	O
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
ali_yyalloc	union(short,union(*(char),*(struct),*(struct(*(char),*(struct),int))),struct(struct(*(char),int,int),struct(*(char),int,int)))
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
yyvs_alloc	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
YYLTYPE	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
9	int
,	O
8	int
,	O
10	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
5	int
,	O
6	int
,	O
2	int
,	O
7	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyprhs	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
18	int
,	O
19	int
,	O
24	int
,	O
26	int
,	O
29	int
,	O
32	int
,	O
34	int
,	O
36	int
,	O
40	int
,	O
42	int
,	O
44	int
}	O
;	O
static	O
const	O
yytype_int8	char
yyrhs	array(char)
[	O
]	O
=	O
{	O
12	int
,	O
0	int
,	O
-	O
1	int
,	O
13	int
,	O
-	O
1	int
,	O
14	int
,	O
-	O
1	int
,	O
13	int
,	O
3	int
,	O
14	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
4	int
,	O
5	int
,	O
15	int
,	O
17	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
4	int
,	O
6	int
,	O
16	int
,	O
17	int
,	O
-	O
1	int
,	O
18	int
,	O
-	O
1	int
,	O
7	int
,	O
4	int
,	O
-	O
1	int
,	O
8	int
,	O
4	int
,	O
-	O
1	int
,	O
9	int
,	O
-	O
1	int
,	O
19	int
,	O
-	O
1	int
,	O
18	int
,	O
10	int
,	O
19	int
,	O
-	O
1	int
,	O
20	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
20	int
,	O
4	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyrline	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
126	int
,	O
126	int
,	O
129	int
,	O
133	int
,	O
140	int
,	O
143	int
,	O
143	int
,	O
151	int
,	O
151	int
,	O
161	int
,	O
162	int
,	O
167	int
,	O
172	int
,	O
178	int
,	O
183	int
,	O
190	int
,	O
196	int
,	O
201	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
yytname	array(*(char))
[	O
]	O
=	O
{	O
"$end"	*(char)
,	O
"error"	*(char)
,	O
"$undefined"	*(char)
,	O
"EOL"	*(char)
,	O
"STRING"	*(char)
,	O
"':'"	*(char)
,	O
"';'"	*(char)
,	O
"'='"	*(char)
,	O
"'+'"	*(char)
,	O
"'*'"	*(char)
,	O
"','"	*(char)
,	O
"$accept"	*(char)
,	O
"input"	*(char)
,	O
"alias_list"	*(char)
,	O
"alias"	*(char)
,	O
"$@1"	*(char)
,	O
"$@2"	*(char)
,	O
"address_group"	*(char)
,	O
"address_list"	*(char)
,	O
"address"	*(char)
,	O
"string_list"	*(char)
,	O
YY_NULL	int
}	O
;	O
static	O
const	O
yytype_uint8	char
ali_yyr1	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
14	int
,	O
16	int
,	O
14	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
20	int
}	O
;	O
static	O
const	O
yytype_uint8	char
ali_yyr2	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
4	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
2	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array(char)
[	O
]	O
=	O
{	O
5	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
6	int
,	O
8	int
,	O
1	int
,	O
5	int
,	O
0	int
,	O
0	int
,	O
4	int
,	O
17	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
7	int
,	O
10	int
,	O
14	int
,	O
16	int
,	O
9	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
18	int
,	O
15	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array(char)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
9	int
,	O
10	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
}	O
;	O
static	O
const	O
yytype_int8	char
ali_yypact	array(char)
[	O
]	O
=	O
{	O
-	O
3	int
,	O
1	int
,	O
2	int
,	O
5	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
3	int
,	O
-	O
4	int
,	O
-	O
4	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
6	int
,	O
7	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
1	int
,	O
-	O
9	int
,	O
8	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array(char)
[	O
]	O
=	O
{	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
10	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
4	int
,	O
-	O
9	int
,	O
-	O
8	int
,	O
-	O
9	int
}	O
;	O
static	O
const	O
yytype_uint8	char
ali_yytable	array(char)
[	O
]	O
=	O
{	O
12	int
,	O
1	int
,	O
7	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
5	int
,	O
6	int
,	O
8	int
,	O
23	int
,	O
21	int
,	O
22	int
,	O
24	int
,	O
12	int
,	O
20	int
,	O
25	int
,	O
0	int
,	O
0	int
,	O
11	int
}	O
;	O
static	O
const	O
yytype_int8	char
ali_yycheck	array(char)
[	O
]	O
=	O
{	O
4	int
,	O
4	int
,	O
0	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
5	int
,	O
6	int
,	O
3	int
,	O
10	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
10	int
,	O
23	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
8	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
4	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
3	int
,	O
15	int
,	O
16	int
,	O
14	int
,	O
4	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
17	int
,	O
4	int
,	O
4	int
,	O
10	int
,	O
4	int
,	O
19	int
}	O
;	O
static	O
void	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
const	O
*	O
const	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
FILE	struct
*	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
YYUSE	O
(	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
)	O
return	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYUSE	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
const	O
*	O
const	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
if	O
(	O
yytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"token %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"nterm %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
YY_LOCATION_PRINT	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": "	*(char)
)	O
;	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yytype	int
,	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
")"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_stack_print	(*(short),*(short))->(void)
(	O
yytype_int16	short
*	O
yybottom	*(short)
,	O
yytype_int16	short
*	O
yytop	*(short)
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack now"	*(char)
)	O
;	O
for	O
(	O
;	O
yybottom	*(short)
<=	O
yytop	*(short)
;	O
yybottom	*(short)
++	O
)	O
{	O
int	O
yybot	int
=	O
*	O
yybottom	*(short)
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
yybot	int
)	O
;	O
}	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_reduce_print	(*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))),int)->(void)
(	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
*	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
int	O
ali_yyrule	int
)	O
{	O
int	O
yynrhs	int
=	O
ali_yyr2	array(char)
[	O
ali_yyrule	int
]	O
;	O
int	O
yyi	int
;	O
unsigned	O
long	O
int	O
yylno	long
=	O
yyrline	array(char)
[	O
ali_yyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reducing stack by rule %d (line %lu):\n"	*(char)
,	O
ali_yyrule	int
-	O
1	int
,	O
yylno	long
)	O
;	O
for	O
(	O
yyi	int
=	O
0	int
;	O
yyi	int
<	O
yynrhs	int
;	O
yyi	int
++	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   $%d = "	*(char)
,	O
yyi	int
+	O
1	int
)	O
;	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yyrhs	array(char)
[	O
yyprhs	array(char)
[	O
ali_yyrule	int
]	O
+	O
yyi	int
]	O
,	O
&	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
int	O
ali_yydebug	int
;	O
static	O
void	O
yydestruct	(*(char),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
const	O
char	O
*	O
yymsg	*(char)
,	O
int	O
yytype	int
,	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
*	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
YYLTYPE	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
YYUSE	O
(	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
)	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
yymsg	*(char)
)	O
yymsg	*(char)
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	*(char)
,	O
yytype	int
,	O
yyvaluep	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
ali_yychar	int
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
YYLTYPE	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
ali_yynerrs	int
;	O
int	O
ali_yyparse	()->(int)
(	O
void	O
)	O
{	O
int	O
ali_yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array(short)
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	*(short)
;	O
yytype_int16	short
*	O
yyssp	*(short)
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
yyvsa	array(union(*(char),*(struct),*(struct(*(char),*(struct),int))))
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
*	O
yyvs	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
*	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
;	O
YYLTYPE	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
YYINITDEPTH	int
]	O
;	O
YYLTYPE	O
*	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
3	int
]	O
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
YYLTYPE	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
ali_yylen	int
=	O
0	int
;	O
yyssp	*(short)
=	O
yyss	*(short)
=	O
yyssa	array(short)
;	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
yyvs	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
yyvsa	array(union(*(char),*(struct),*(struct(*(char),*(struct),int))))
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
ali_yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
ali_yynerrs	int
=	O
0	int
;	O
ali_yychar	int
=	O
YYEMPTY	O
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
0	int
]	O
=	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	*(short)
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	*(short)
=	O
ali_yystate	int
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	*(short)
-	O
yyss	*(short)
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	*(short)
=	O
yyss	*(short)
;	O
union	O
ali_yyalloc	union(short,union(*(char),*(struct),*(struct(*(char),*(struct),int))),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
yyptr	*(union(short,union(*(char),*(struct),*(struct(*`,*`,int))),struct(struct(*(char),int,int),struct(*(char),int,int))))
=	O
(	O
union	O
ali_yyalloc	union(short,union(*(char),*(struct),*(struct(*(char),*(struct),int))),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	*(union(short,union(*(char),*(struct),*(struct(*`,*`,int))),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	*(short)
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
yyvs	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
yyss1	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss1	*(short)
)	O
;	O
}	O
yyssp	*(short)
=	O
yyss	*(short)
+	O
yysize	long
-	O
1	int
;	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
yyvs	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
+	O
yysize	long
-	O
1	int
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
ali_yystate	int
)	O
)	O
;	O
if	O
(	O
ali_yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
ali_yypact	array(char)
[	O
ali_yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
ali_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
ali_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
ali_yychar	int
<=	O
YYEOF	int
)	O
{	O
ali_yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
ali_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
yytoken	int
,	O
&	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
&	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
ali_yycheck	array(char)
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
ali_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yytoken	int
,	O
&	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
&	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
ali_yychar	int
=	O
YYEMPTY	O
;	O
ali_yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array(char)
[	O
ali_yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
ali_yylen	int
=	O
ali_yyr2	array(char)
[	O
yyn	int
]	O
;	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
=	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
1	int
-	O
ali_yylen	int
]	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
-	O
ali_yylen	int
)	O
,	O
ali_yylen	int
)	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
3	int
:	O
{	O
ali_append	(*(struct(*(char),*(struct),int)))->(void)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
alias	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
ali_append	(*(struct(*(char),*(struct),int)))->(void)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
alias	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
5	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
{	O
ali_verbatim	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
ali_verbatim	(int)->(void)
(	O
0	int
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
)	O
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
name	*(char)
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
string	*(char)
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
rcpt_list	*(struct)
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
inclusive	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
ali_verbatim	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
ali_verbatim	(int)->(void)
(	O
0	int
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
)	O
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
name	*(char)
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
string	*(char)
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
rcpt_list	*(struct)
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
alias	*(char)
)	O
->	O
inclusive	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
unix_group_to_list	(*(char))->(*(struct))
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
unix_gid_to_list	(*(char))->(*(struct))
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
unix_passwd_to_list	()->(*(struct))
(	O
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
list_create_or_die	()->(*(struct))
(	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
string	*(char)
)	O
=	O
ali_list_to_string	(*(*(struct)))->(*(char))
(	O
&	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	*(struct)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
;	O
(	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
ali_yyr1	array(char)
[	O
yyn	int
]	O
,	O
&	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
&	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
YYPOPSTACK	O
(	O
ali_yylen	int
)	O
;	O
ali_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
*	O
++	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
ali_yyval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
yyn	int
=	O
ali_yyr1	array(char)
[	O
yyn	int
]	O
;	O
ali_yystate	int
=	O
yypgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	*(short)
;	O
if	O
(	O
0	int
<=	O
ali_yystate	int
&&	O
ali_yystate	int
<=	O
YYLAST	int
&&	O
ali_yycheck	array(char)
[	O
ali_yystate	int
]	O
==	O
*	O
yyssp	*(short)
)	O
ali_yystate	int
=	O
ali_yytable	array(char)
[	O
ali_yystate	int
]	O
;	O
else	O
ali_yystate	int
=	O
yydefgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
ali_yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
ali_yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
ali_yynerrs	int
;	O
ali_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
}	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
ali_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
ali_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	(*(char),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: discarding"	*(char)
,	O
yytoken	int
,	O
&	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
&	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
ali_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
-	O
ali_yylen	int
]	O
;	O
YYPOPSTACK	O
(	O
ali_yylen	int
)	O
;	O
ali_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
ali_yystate	int
=	O
*	O
yyssp	*(short)
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
ali_yypact	array(char)
[	O
ali_yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
ali_yycheck	array(char)
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
ali_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	*(short)
==	O
yyss	*(short)
)	O
YYABORT	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yydestruct	(*(char),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: popping"	*(char)
,	O
yystos	array(char)
[	O
ali_yystate	int
]	O
,	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
ali_yystate	int
=	O
*	O
yyssp	*(short)
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
=	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
2	int
]	O
=	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
2	int
)	O
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yystos	array(char)
[	O
yyn	int
]	O
,	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
ali_yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
ali_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
ali_yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
ali_yychar	int
)	O
;	O
yydestruct	(*(char),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
yytoken	int
,	O
&	O
ali_yylval	union(*(char),*(struct),*(struct(*(char),*(struct),int)))
,	O
&	O
ali_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
YYPOPSTACK	O
(	O
ali_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
while	O
(	O
yyssp	*(short)
!=	O
yyss	*(short)
)	O
{	O
yydestruct	(*(char),int,*(union(*(char),*(struct),*(struct(*`,*`,int)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: popping"	*(char)
,	O
yystos	array(char)
[	O
*	O
yyssp	*(short)
]	O
,	O
yyvsp	*(union(*(char),*(struct),*(struct(*(char),*(struct`),int))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss	*(short)
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
static	O
mu_list_t	*(struct)
ali_list_dup	(*(struct))->(*(struct))
(	O
mu_list_t	*(struct)
src	*(char)
)	O
{	O
mu_list_t	*(struct)
dst	*(char)
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
dst	*(char)
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
src	*(char)
,	O
&	O
itr	*(struct)
)	O
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
dst	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
void	O
*	O
data	*(void)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
data	*(void)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
dst	*(char)
,	O
data	*(void)
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
return	O
dst	*(char)
;	O
}	O
static	O
int	O
ali_member	(*(struct),*(char))->(int)
(	O
mu_list_t	*(struct)
list	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
found	int
=	O
0	int
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
list	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
0	int
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
found	int
&&	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
item	*(void)
;	O
mu_address_t	*(struct)
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
item	*(void)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
item	*(void)
,	O
name	*(char)
)	O
==	O
0	int
)	O
found	int
=	O
1	int
;	O
else	O
if	O
(	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
item	*(void)
)	O
==	O
0	int
)	O
{	O
found	int
=	O
mu_address_contains_email	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(int)
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
name	*(char)
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
return	O
found	int
;	O
}	O
int	O
aliascmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
1	int
&&	O
pattern	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'*'	O
)	O
return	O
strncmp	(*(char),*(char),long)->(int)
(	O
pattern	*(char)
,	O
name	*(char)
,	O
len	int
-	O
2	int
)	O
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
pattern	*(char)
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
mh_alias_get_internal	(*(char),*(struct),*(*(struct)),*(int))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_iterator_t	*(struct)
start	long
,	O
mu_list_t	*(struct)
*	O
return_list	*(*(struct))
,	O
int	O
*	O
inclusive	int
)	O
;	O
int	O
alias_expand_list	(*(struct),*(struct),*(int))->(int)
(	O
mu_list_t	*(struct)
name_list	*(struct)
,	O
mu_iterator_t	*(struct)
orig_itr	*(struct)
,	O
int	O
*	O
inclusive	int
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
name_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
1	int
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
mu_list_t	*(struct)
exlist	*(struct)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
mh_alias_get_internal	(*(char),*(struct),*(*(struct)),*(int))->(int)
(	O
name	*(char)
,	O
orig_itr	*(struct)
,	O
&	O
exlist	*(struct)
,	O
inclusive	int
)	O
==	O
0	int
)	O
{	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_insert_list	int
,	O
exlist	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
exlist	*(struct)
)	O
;	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mh_alias_get_internal	(*(char),*(struct),*(*(struct)),*(int))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_iterator_t	*(struct)
start	long
,	O
mu_list_t	*(struct)
*	O
return_list	*(*(struct))
,	O
int	O
*	O
inclusive	int
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
rc	int
=	O
1	int
;	O
if	O
(	O
!	O
start	long
)	O
{	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
alias_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
1	int
;	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
}	O
else	O
{	O
mu_iterator_dup	(*(*(struct)),*(struct))->(int)
(	O
&	O
itr	*(struct)
,	O
start	long
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
}	O
for	O
(	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mh_alias	struct(*(char),*(struct),int)
*	O
alias	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
alias	*(char)
)	O
;	O
if	O
(	O
aliascmp	(*(char),*(char))->(int)
(	O
alias	*(char)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
inclusive	int
)	O
*	O
inclusive	int
|=	O
alias	*(char)
->	O
inclusive	int
;	O
*	O
return_list	*(*(struct))
=	O
ali_list_dup	(*(struct))->(*(struct))
(	O
alias	*(char)
->	O
rcpt_list	*(struct)
)	O
;	O
alias_expand_list	(*(struct),*(struct),*(int))->(int)
(	O
*	O
return_list	*(*(struct))
,	O
itr	*(struct)
,	O
inclusive	int
)	O
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_alias_get	(*(char),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
*	O
return_list	*(*(struct))
)	O
{	O
return	O
mh_alias_get_internal	(*(char),*(struct),*(*(struct)),*(int))->(int)
(	O
name	*(char)
,	O
NULL	O
,	O
return_list	*(*(struct))
,	O
NULL	O
)	O
;	O
}	O
int	O
mh_alias_get_address	(*(char),*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(int))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_address_t	*(struct)
*	O
paddr	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
int	O
*	O
incl	*(int)
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
if	O
(	O
incl	*(int)
)	O
*	O
incl	*(int)
=	O
0	int
;	O
if	O
(	O
mh_alias_get_internal	(*(char),*(struct),*(*(struct)),*(int))->(int)
(	O
name	*(char)
,	O
NULL	O
,	O
&	O
list	*(struct)
,	O
incl	*(int)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_list_is_empty	(*(struct))->(int)
(	O
list	*(struct)
)	O
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
list	*(struct)
,	O
&	O
itr	*(struct)
)	O
==	O
0	int
)	O
{	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
item	*(void)
;	O
mu_address_t	*(struct)
a	*(struct(int,int,array(char),array(char)))
;	O
char	O
*	O
ptr	*(*(char))
=	O
NULL	O
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
item	*(void)
)	O
;	O
if	O
(	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
a	*(struct(int,int,array(char),array(char)))
,	O
item	*(void)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Error expanding aliases -- invalid address `%s'"	*(char)
)	O
,	O
item	*(void)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
incl	*(int)
&&	O
*	O
incl	*(int)
)	O
mu_address_set_personal	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),long,*(char))->(int)
(	O
a	*(struct(int,int,array(char),array(char)))
,	O
1	int
,	O
name	*(char)
)	O
;	O
mu_address_union	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
paddr	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
a	*(struct(int,int,array(char),array(char)))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
a	*(struct(int,int,array(char),array(char)))
)	O
;	O
}	O
if	O
(	O
ptr	*(*(char))
)	O
free	(*(void))->(void)
(	O
ptr	*(*(char))
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mh_alias_get_alias	(*(char),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
uname	*(char)
,	O
mu_list_t	*(struct)
*	O
return_list	*(*(struct))
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
rc	int
=	O
1	int
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
alias_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
1	int
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mh_alias	struct(*(char),*(struct),int)
*	O
alias	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
alias	*(char)
)	O
;	O
if	O
(	O
ali_member	(*(struct),*(char))->(int)
(	O
alias	*(char)
->	O
rcpt_list	*(struct)
,	O
uname	*(char)
)	O
)	O
{	O
if	O
(	O
*	O
return_list	*(*(struct))
==	O
NULL	O
&&	O
mu_list_create	(*(*(struct)))->(int)
(	O
return_list	*(*(struct))
)	O
)	O
break	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
*	O
return_list	*(*(struct))
,	O
alias	*(char)
->	O
name	*(char)
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
mh_alias_enumerate	(*((*(char),*(struct),*(void))->(int)),*(void))->(void)
(	O
mh_alias_enumerator_t	*((*(char),*(struct),*(void))->(int))
fun	*((*(char),*(struct),*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
alias_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
rc	int
==	O
0	int
&&	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mh_alias	struct(*(char),*(struct),int)
*	O
alias	*(char)
;	O
mu_list_t	*(struct)
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
alias	*(char)
)	O
;	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
ali_list_dup	(*(struct))->(*(struct))
(	O
alias	*(char)
->	O
rcpt_list	*(struct)
)	O
;	O
alias_expand_list	(*(struct),*(struct),*(int))->(int)
(	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
itr	*(struct)
,	O
NULL	O
)	O
;	O
rc	int
=	O
fun	*((*(char),*(struct),*(void))->(int))
(	O
alias	*(char)
->	O
name	*(char)
,	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
data	*(void)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
tmp	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
static	O
mu_list_t	*(struct)
unix_group_to_list	(*(char))->(*(struct))
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grp	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
name	*(char)
)	O
;	O
mu_list_t	*(struct)
lst	*(struct)
=	O
list_create_or_die	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
grp	*(struct(*(char),*(char),int,*(*(char))))
)	O
{	O
char	O
*	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
grp	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_mem	*(*(char))
;	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
lst	*(struct)
,	O
mu_strdup	(*(char))->(*(char))
(	O
*	O
p	*(char)
)	O
)	O
;	O
}	O
return	O
lst	*(struct)
;	O
}	O
static	O
mu_list_t	*(struct)
unix_gid_to_list	(*(char))->(*(struct))
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grp	*(struct(*(char),*(char),int,*(*(char))))
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
name	*(char)
)	O
;	O
mu_list_t	*(struct)
lst	*(struct)
=	O
list_create_or_die	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
grp	*(struct(*(char),*(char),int,*(*(char))))
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
setpwent	()->(void)
(	O
)	O
;	O
while	O
(	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwent	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
)	O
)	O
{	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
==	O
grp	*(struct(*(char),*(char),int,*(*(char))))
->	O
gr_gid	int
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
lst	*(struct)
,	O
mu_strdup	(*(char))->(*(char))
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
)	O
;	O
}	O
endpwent	()->(void)
(	O
)	O
;	O
}	O
return	O
lst	*(struct)
;	O
}	O
static	O
mu_list_t	*(struct)
unix_passwd_to_list	()->(*(struct))
(	O
)	O
{	O
mu_list_t	*(struct)
lst	*(struct)
=	O
list_create_or_die	()->(*(struct))
(	O
)	O
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
setpwent	()->(void)
(	O
)	O
;	O
while	O
(	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwent	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
)	O
)	O
{	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_uid	int
>	O
200	int
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
lst	*(struct)
,	O
mu_strdup	(*(char))->(*(char))
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_name	*(char)
)	O
)	O
;	O
}	O
endpwent	()->(void)
(	O
)	O
;	O
return	O
lst	*(struct)
;	O
}	O
int	O
mh_read_aliases	()->(int)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
alias_list	*(struct)
)	O
return	O
0	int
;	O
p	*(char)
=	O
mh_global_profile_get	O
(	O
"Aliasfile"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
p	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot split line `%s': %s"	*(char)
)	O
,	O
p	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
mh_alias_read	(*(char),int)->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
,	O
1	int
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
}	O
mh_alias_read	(*(char),int)->(int)
(	O
DEFAULT_ALIAS_FILE	O
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
