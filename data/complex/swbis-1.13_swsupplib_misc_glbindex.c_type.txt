static	O
char	O
*	O
determine_control_directory	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
{	O
char	O
*	O
value	long
;	O
value	long
=	O
swheader_get_single_attribute_value	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
SW_A_control_directory	*(char)
)	O
;	O
if	O
(	O
!	O
value	long
)	O
value	long
=	O
swheader_get_single_attribute_value	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
SW_A_tag	*(char)
)	O
;	O
return	O
value	long
;	O
}	O
static	O
char	O
*	O
search_object_for_directory	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char),*(char),int)->(*(char))
(	O
char	O
*	O
i_next_line	*(char)
,	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
char	O
*	O
key_dir	*(char)
,	O
char	O
*	O
object_name	*(char)
,	O
int	O
level	int
)	O
{	O
char	O
*	O
control_directory	*(char)
;	O
char	O
*	O
next_line	*(char)
=	O
i_next_line	*(char)
;	O
char	O
*	O
keyword	*(char)
;	O
while	O
(	O
next_line	*(char)
)	O
{	O
keyword	*(char)
=	O
swheaderline_get_keyword	(*(char))->(*(char))
(	O
next_line	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
keyword	*(char)
,	O
object_name	*(char)
)	O
==	O
0	int
)	O
{	O
control_directory	*(char)
=	O
determine_control_directory	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
if	O
(	O
control_directory	*(char)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
key_dir	*(char)
,	O
control_directory	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
next_line	*(char)
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
next_line	*(char)
=	O
swheader_get_next_object	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int,int)->(*(char))
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
level	int
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
search_for_fileset	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
char	O
*	O
i_next_line	*(char)
,	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
char	O
*	O
key_dir	*(char)
)	O
{	O
char	O
*	O
ret	*(char)
;	O
int	O
level	int
;	O
int	O
type	enum(int,int,int,int)
;	O
level	int
=	O
swheaderline_get_level	(*(char))->(int)
(	O
i_next_line	*(char)
)	O
;	O
type	enum(int,int,int,int)
=	O
swheaderline_get_type	(*(char))->(char)
(	O
i_next_line	*(char)
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
SWPARSE_MD_TYPE_OBJ	char
)	O
{	O
level	int
++	O
;	O
}	O
ret	*(char)
=	O
search_object_for_directory	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char),*(char),int)->(*(char))
(	O
i_next_line	*(char)
,	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
key_dir	*(char)
,	O
SW_A_fileset	*(char)
,	O
level	int
)	O
;	O
return	O
ret	*(char)
;	O
}	O
static	O
char	O
*	O
search_for_product	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
char	O
*	O
i_next_line	*(char)
,	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
char	O
*	O
key_dir	*(char)
)	O
{	O
char	O
*	O
ret	*(char)
;	O
int	O
level	int
;	O
level	int
=	O
swheaderline_get_level	(*(char))->(int)
(	O
i_next_line	*(char)
)	O
;	O
ret	*(char)
=	O
search_object_for_directory	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char),*(char),int)->(*(char))
(	O
i_next_line	*(char)
,	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
key_dir	*(char)
,	O
SW_A_product	*(char)
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
return	O
ret	*(char)
;	O
}	O
static	O
int	O
determine_object	(*(struct(*(char),*(char),int,int,int,char,int)),*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
object_keyword	*(char)
,	O
STRAR	struct(int,int,*(struct(*(*(char)),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
SWPATH_EX	struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
if	O
(	O
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
is_minimal_layoutM	int
==	O
0	int
&&	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
product_control_dir	*(char)
)	O
&&	O
!	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
fileset_control_dir	*(char)
)	O
&&	O
1	int
)	O
||	O
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
is_minimal_layoutM	int
==	O
1	int
&&	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
pfiles	*(char)
)	O
&&	O
(	O
!	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
fileset_control_dir	*(char)
)	O
)	O
&&	O
1	int
)	O
)	O
{	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
SW_A_product	*(char)
)	O
;	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
product_control_dir	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
object_keyword	*(char)
,	O
SW_A_product	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
is_minimal_layoutM	int
==	O
0	int
&&	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
product_control_dir	*(char)
)	O
&&	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
fileset_control_dir	*(char)
)	O
&&	O
1	int
)	O
||	O
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
is_minimal_layoutM	int
==	O
1	int
&&	O
!	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
product_control_dir	*(char)
)	O
&&	O
!	O
strlen	(*(char))->(long)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
fileset_control_dir	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
basename	(*(char))->(*(char))
,	O
SW_A_INFO	*(char)
)	O
==	O
0	int
&&	O
1	int
)	O
)	O
{	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
SW_A_product	*(char)
)	O
;	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
product_control_dir	*(char)
)	O
;	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
SW_A_fileset	*(char)
)	O
;	O
strar_add	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(char))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
->	O
fileset_control_dir	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
object_keyword	*(char)
,	O
SW_A_fileset	*(char)
)	O
;	O
}	O
else	O
{	O
{	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
10	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"swinstall: Uh-Oh WARNING IN "	*(char)
__FILE__	O
" %d\n"	*(char)
,	O
__LINE__	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
swpath_ex_print	(*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
,	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"glbindex.c "	*(char)
)	O
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
tmp	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
object_keyword	*(char)
,	O
SW_A_distribution	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
glbindex_find_by_swpath_ex	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
global_index	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
SWPATH_EX	struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
int	O
ret	*(char)
=	O
0	int
;	O
char	O
*	O
next_line	*(char)
;	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
;	O
STRAR	struct(int,int,*(struct(*(*(char)),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int)))
*	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
object_keyword	*(char)
;	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
=	O
global_index	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
;	O
swheader_store_state	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(int),int,int)))->(void)
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
NULL	O
)	O
;	O
swheader_set_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int)->(void)
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
0	int
)	O
;	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
=	O
strar_open	()->(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))))
(	O
)	O
;	O
object_keyword	*(char)
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
20	int
)	O
;	O
determine_object	(*(struct(*(char),*(char),int,int,int,char,int)),*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(int)
(	O
object_keyword	*(char)
,	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
swpath_ex	*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char)))
)	O
;	O
next_line	*(char)
=	O
swheader_get_next_object	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int,int)->(*(char))
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
strar_num_elements	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))))->(int)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
>	O
3	int
)	O
{	O
next_line	*(char)
=	O
search_for_product	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
next_line	*(char)
,	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
1	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	*(char)
!=	O
NULL	O
)	O
;	O
next_line	*(char)
=	O
search_for_fileset	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
next_line	*(char)
,	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
3	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	*(char)
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
next_line	*(char)
=	O
search_for_product	(*(char),*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
next_line	*(char)
,	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
strar_get	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))),int)->(*(char))
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
,	O
1	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	*(char)
!=	O
NULL	O
)	O
;	O
}	O
ret	*(char)
=	O
swheader_get_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(int)
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
strar_close	(*(struct(int,int,*(struct(*`,int,int,long,int)),*(struct(*`,*`,int,int,int,char,int)))))->(void)
(	O
control_dir_list	*(struct(int,int,*(struct(*(*`),int,int,long,int)),*(struct(*(char),*(char),int,int,int,char,int))))
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
object_keyword	*(char)
)	O
;	O
swheader_restore_state	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(int),int,int)))->(void)
(	O
swheader	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
NULL	O
)	O
;	O
return	O
ret	*(char)
;	O
}	O
