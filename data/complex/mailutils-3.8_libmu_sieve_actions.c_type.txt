static	O
int	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
int	O
deleted	int
)	O
{	O
mu_attribute_t	*(struct)
attr	*(struct)
=	O
0	int
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
{	O
if	O
(	O
deleted	int
)	O
rc	int
=	O
mu_attribute_set_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
else	O
rc	int
=	O
mu_attribute_unset_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
sieve_action_stop	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"STOP"	*(char)
,	O
NULL	O
)	O
;	O
mach	*(struct)
->	O
pc	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_action_keep	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"KEEP"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_action_discard	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"DISCARD"	*(char)
,	O
_	O
(	O
"marking as deleted"	*(char)
)	O
)	O
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_action_fileinto	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
int	O
rc	int
;	O
int	O
mbflags	int
=	O
0	int
;	O
char	O
*	O
filename	*(char)
;	O
char	O
*	O
perms	int
;	O
mu_sieve_get_arg	(*(struct),long,enum(int,int,int,int,int),*(void))->(void)
(	O
mach	*(struct)
,	O
0	int
,	O
SVT_STRING	int
,	O
&	O
filename	*(char)
)	O
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"permissions"	*(char)
,	O
SVT_STRING	int
,	O
&	O
perms	int
)	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
mu_parse_stream_perm_string	(*(int),*(char),*(*(char)))->(int)
(	O
&	O
mbflags	int
,	O
perms	int
,	O
&	O
p	*(char)
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"invalid permissions (near %s)"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
}	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"FILEINTO"	*(char)
,	O
_	O
(	O
"delivering into %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
rc	int
=	O
mu_message_save_to_mailbox	(*(struct),*(char),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
filename	*(char)
,	O
mbflags	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot save to mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
1	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_sieve_get_message_sender	(*(struct),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
*	O
*	O
ptext	*(*(char))
)	O
{	O
int	O
rc	int
;	O
mu_envelope_t	*(struct)
envelope	*(struct)
;	O
rc	int
=	O
mu_message_get_envelope	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
envelope	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_envelope_aget_sender	(*(struct),*(*(char)))->(int)
(	O
envelope	*(struct)
,	O
ptext	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_header_aget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_SENDER	*(char)
,	O
ptext	*(*(char))
)	O
)	O
)	O
rc	int
=	O
mu_header_aget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_FROM	*(char)
,	O
ptext	*(*(char))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
mime_create_reason	(*(struct),*(struct),*(char))->(void)
(	O
mu_mime_t	*(struct)
mime	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
time_t	long
t	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
char	O
*	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
static	O
char	O
*	O
content_header	*(char)
=	O
"Content-Type: text/plain;charset="	*(char)
MU_SIEVE_CHARSET	*(char)
"\n"	*(char)
"Content-Transfer-Encoding: 8bit\n"	*(char)
;	O
mu_message_create	(*(*(struct)),*(void))->(int)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
body	*(struct)
)	O
;	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
time	struct(long,long)
(	O
&	O
t	long
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_sieve_get_message_sender	(*(struct),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
&	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_c_streamftime	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
stream	*(struct)
,	O
"The original message was received at "	*(char)
"%a, %b %d %H:%M:%S %Y %Z"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
NULL	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
" from %s.\n"	*(char)
,	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
sender	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Message was refused by recipient's mail filtering program.\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Reason given was as follows:\n\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"%s"	*(char)
,	O
text	*(char)
)	O
;	O
mu_stream_close	(*(struct))->(int)
(	O
stream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
mu_header_create	(*(*(struct)),*(char),long)->(int)
(	O
&	O
hdr	*(struct)
,	O
content_header	*(char)
,	O
strlen	(*(char))->(long)
(	O
content_header	*(char)
)	O
)	O
;	O
mu_message_set_header	(*(struct),*(struct),*(void))->(int)
(	O
newmsg	*(*(struct))
,	O
hdr	*(struct)
,	O
NULL	O
)	O
;	O
mu_mime_add_part	(*(struct),*(struct))->(int)
(	O
mime	*(struct)
,	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
}	O
static	O
void	O
mime_create_ds	(*(struct),*(struct))->(void)
(	O
mu_mime_t	*(struct)
mime	*(struct)
,	O
mu_message_t	*(struct)
orig	*(struct)
)	O
{	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
char	O
*	O
email	*(char)
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
*	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
struct	O
mu_timezone	struct(int,*(char))
tz	*(struct(int,*(char)))
;	O
mu_envelope_t	*(struct)
env	*(struct)
;	O
const	O
char	O
*	O
p	*(char)
;	O
time_t	long
t	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
mu_message_create	(*(*(struct)),*(void))->(int)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
hdr	*(struct)
,	O
"Content-Type"	*(char)
,	O
"message/delivery-status"	*(char)
,	O
1	int
)	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
body	*(struct)
)	O
;	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Reporting-UA: sieve; %s\n"	*(char)
,	O
PACKAGE_STRING	*(char)
)	O
;	O
mu_message_get_envelope	(*(struct),*(*(struct)))->(int)
(	O
orig	*(struct)
,	O
&	O
env	*(struct)
)	O
;	O
if	O
(	O
mu_envelope_sget_date	(*(struct),*(*(char)))->(int)
(	O
env	*(struct)
,	O
&	O
p	*(char)
)	O
==	O
0	int
&&	O
mu_scan_datetime	(*(char),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))),*(*(char)))->(int)
(	O
p	*(char)
,	O
MU_DATETIME_FROM	*(char)
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
&	O
tz	*(struct(int,*(char)))
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
}	O
else	O
{	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_datetime_tz_local	(*(struct(int,*(char))))->(void)
(	O
&	O
tz	*(struct(int,*(char)))
)	O
;	O
}	O
mu_c_streamftime	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
stream	*(struct)
,	O
"Arrival-Date: %a, %b %d %H:%M:%S %Y %Z%n"	*(char)
,	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
,	O
&	O
tz	*(struct(int,*(char)))
)	O
;	O
email	*(char)
=	O
mu_get_user_email	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Final-Recipient: RFC822; %s\n"	*(char)
,	O
email	*(char)
?	O
email	*(char)
:	O
"unknown"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
email	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Action: deleted\n"	*(char)
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"Disposition: automatic-action/MDN-sent-automatically;deleted\n"	*(char)
)	O
;	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
mu_datetime_tz_local	(*(struct(int,*(char))))->(void)
(	O
&	O
tz	*(struct(int,*(char)))
)	O
;	O
mu_c_streamftime	(*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))),*(struct(int,*(char))))->(int)
(	O
stream	*(struct)
,	O
"Last-Attempt-Date: %a, %b %d %H:%M:%S %Y %Z%n"	*(char)
,	O
tmp	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
,	O
&	O
tz	*(struct(int,*(char)))
)	O
;	O
mu_stream_close	(*(struct))->(int)
(	O
stream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
mu_mime_add_part	(*(struct),*(struct))->(int)
(	O
mime	*(struct)
,	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
}	O
static	O
int	O
mime_create_quote	(*(struct),*(struct))->(int)
(	O
mu_mime_t	*(struct)
mime	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
)	O
{	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
mu_stream_t	*(struct)
istream	*(struct)
,	O
ostream	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
int	O
rc	int
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
mu_message_create	(*(*(struct)),*(void))->(int)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
hdr	*(struct)
,	O
"Content-Type"	*(char)
,	O
"message/rfc822"	*(char)
,	O
1	int
)	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
body	*(struct)
)	O
;	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
ostream	*(struct)
)	O
;	O
mu_message_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
istream	*(struct)
)	O
;	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
ostream	*(struct)
,	O
istream	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
istream	*(struct)
)	O
;	O
mu_stream_close	(*(struct))->(int)
(	O
ostream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
ostream	*(struct)
)	O
;	O
mu_mime_add_part	(*(struct),*(struct))->(int)
(	O
mime	*(struct)
,	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
build_mime	(*(*(struct)),*(struct),*(char))->(int)
(	O
mu_mime_t	*(struct)
*	O
pmime	*(*(struct))
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
mu_mime_t	*(struct)
mime	*(struct)
=	O
NULL	O
;	O
int	O
status	int
;	O
mu_mime_create	(*(*(struct)),*(struct),int)->(int)
(	O
&	O
mime	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
mime_create_reason	(*(struct),*(struct),*(char))->(void)
(	O
mime	*(struct)
,	O
msg	*(struct)
,	O
text	*(char)
)	O
;	O
mime_create_ds	(*(struct),*(struct))->(void)
(	O
mime	*(struct)
,	O
msg	*(struct)
)	O
;	O
status	int
=	O
mime_create_quote	(*(struct),*(struct))->(int)
(	O
mime	*(struct)
,	O
msg	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
return	O
status	int
;	O
}	O
*	O
pmime	*(*(struct))
=	O
mime	*(struct)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_action_reject	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_mime_t	*(struct)
mime	*(struct)
=	O
NULL	O
;	O
mu_mailer_t	*(struct)
mailer	*(struct)
=	O
mu_sieve_get_mailer	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
int	O
rc	int
;	O
mu_message_t	*(struct)
newmsg	*(*(struct))
;	O
char	O
*	O
addrtext	*(char)
;	O
mu_address_t	*(struct)
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
char	O
*	O
text	*(char)
;	O
mu_sieve_get_arg	(*(struct),long,enum(int,int,int,int,int),*(void))->(void)
(	O
mach	*(struct)
,	O
0	int
,	O
SVT_STRING	int
,	O
&	O
text	*(char)
)	O
;	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"REJECT"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
rc	int
=	O
build_mime	(*(*(struct)),*(struct),*(char))->(int)
(	O
&	O
mime	*(struct)
,	O
mach	*(struct)
->	O
msg	*(struct)
,	O
text	*(char)
)	O
;	O
mu_mime_get_message	(*(struct),*(*(struct)))->(int)
(	O
mime	*(struct)
,	O
&	O
newmsg	*(*(struct))
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
newmsg	*(*(struct))
)	O
;	O
mu_sieve_get_message_sender	(*(struct),*(*(char)))->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
&	O
addrtext	*(char)
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_prepend	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
addrtext	*(char)
)	O
;	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
addrtext	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot create recipient address <%s>: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
addrtext	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
addrtext	*(char)
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
free	(*(void))->(void)
(	O
addrtext	*(char)
)	O
;	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
mu_sieve_get_daemon_email	(*(struct))->(*(char))
(	O
mach	*(struct)
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot create sender address <%s>: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_sieve_get_daemon_email	(*(struct))->(*(char))
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_mailer_open	(*(struct),int)->(int)
(	O
mailer	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
mu_mailer_get_url	(*(struct),*(*(struct)))->(int)
(	O
mailer	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot open mailer %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_mailer_send_message	(*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
mailer	*(struct)
,	O
newmsg	*(*(struct))
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
mu_mailer_close	(*(struct))->(int)
(	O
mailer	*(struct)
)	O
;	O
end	struct(*(char),int,int)
:	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
rc	int
==	O
0	int
)	O
;	O
mu_mime_destroy	(*(*(struct)))->(void)
(	O
&	O
mime	*(struct)
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
check_redirect_loop	(*(struct))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
size_t	long
i	long
,	O
num	long
=	O
0	int
;	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
int	O
loop	int
=	O
0	int
;	O
char	O
*	O
email	*(char)
=	O
mu_get_user_email	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_get_field_count	(*(struct),*(long))->(int)
(	O
hdr	*(struct)
,	O
&	O
num	long
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
!	O
loop	int
&&	O
i	long
<=	O
num	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mu_header_get_field_name	(*(struct),long,*(char),long,*(long))->(int)
(	O
hdr	*(struct)
,	O
i	long
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"X-Loop-Prevention"	*(char)
)	O
==	O
0	int
)	O
{	O
size_t	long
j	long
,	O
cnt	*(long)
=	O
0	int
;	O
mu_address_t	*(struct)
addr	int
;	O
if	O
(	O
mu_header_get_field_value	(*(struct),long,*(char),long,*(long))->(int)
(	O
hdr	*(struct)
,	O
i	long
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
addr	int
,	O
buf	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
mu_address_get_count	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(long))->(int)
(	O
addr	int
,	O
&	O
cnt	*(long)
)	O
==	O
0	int
)	O
{	O
for	O
(	O
j	long
=	O
1	int
;	O
!	O
loop	int
&&	O
j	long
<=	O
cnt	*(long)
;	O
j	long
++	O
)	O
{	O
if	O
(	O
mu_address_get_email	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),long,*(char),long,*(long))->(int)
(	O
addr	int
,	O
j	long
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
NULL	O
)	O
==	O
0	int
&&	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
email	*(char)
)	O
==	O
0	int
)	O
loop	int
=	O
1	int
;	O
}	O
}	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
addr	int
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
email	*(char)
)	O
;	O
return	O
loop	int
;	O
}	O
static	O
int	O
sieve_action_redirect	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_message_t	*(struct)
msg	*(struct)
,	O
newmsg	*(*(struct))
=	O
NULL	O
;	O
mu_address_t	*(struct)
addr	int
=	O
NULL	O
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
NULL	O
;	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
int	O
rc	int
;	O
char	O
*	O
fromaddr	*(char)
,	O
*	O
p	*(char)
;	O
mu_mailer_t	*(struct)
mailer	*(struct)
=	O
mu_sieve_get_mailer	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
char	O
*	O
addrstr	*(char)
;	O
mu_sieve_get_arg	(*(struct),long,enum(int,int,int,int,int),*(void))->(void)
(	O
mach	*(struct)
,	O
0	int
,	O
SVT_STRING	int
,	O
&	O
addrstr	*(char)
)	O
;	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
addr	int
,	O
addrstr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: parsing recipient address `%s' failed: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
addrstr	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"REDIRECT"	*(char)
,	O
_	O
(	O
"to %s"	*(char)
)	O
,	O
addrstr	*(char)
)	O
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
msg	*(struct)
=	O
mu_sieve_get_message	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
if	O
(	O
check_redirect_loop	(*(struct))->(int)
(	O
msg	*(struct)
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: redirection loop detected"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_sieve_get_message_sender	(*(struct),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
&	O
fromaddr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot get envelope sender: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_address_create	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))),*(char))->(int)
(	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
fromaddr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot create sender address <%s>: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
fromaddr	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
fromaddr	*(char)
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
free	(*(void))->(void)
(	O
fromaddr	*(char)
)	O
;	O
rc	int
=	O
mu_message_create_copy	(*(*(struct)),*(struct))->(int)
(	O
&	O
newmsg	*(*(struct))
,	O
msg	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot copy message: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
newmsg	*(*(struct))
,	O
&	O
hdr	*(struct)
)	O
;	O
p	*(char)
=	O
mu_get_user_email	(*(char))->(*(char))
(	O
NULL	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
hdr	*(struct)
,	O
"X-Loop-Prevention"	*(char)
,	O
p	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
else	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot get my email address"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_mailer_open	(*(struct),int)->(int)
(	O
mailer	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
mu_mailer_get_url	(*(struct),*(*(struct)))->(int)
(	O
mailer	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"%lu: cannot open mailer %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mu_sieve_get_message_num	(*(struct))->(long)
(	O
mach	*(struct)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
end	struct(*(char),int,int)
;	O
}	O
rc	int
=	O
mu_mailer_send_message	(*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
mailer	*(struct)
,	O
newmsg	*(*(struct))
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
addr	int
)	O
;	O
mu_mailer_close	(*(struct))->(int)
(	O
mailer	*(struct)
)	O
;	O
end	struct(*(char),int,int)
:	O
sieve_mark_deleted	(*(struct),int)->(int)
(	O
mach	*(struct)
->	O
msg	*(struct)
,	O
rc	int
==	O
0	int
)	O
;	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
newmsg	*(*(struct))
,	O
NULL	O
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
mu_address_destroy	(*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))->(void)
(	O
&	O
addr	int
)	O
;	O
return	O
rc	int
;	O
}	O
mu_sieve_data_type	enum(int,int,int,int,int)
fileinto_args	array(enum(int,int,int,int,int))
[	O
]	O
=	O
{	O
SVT_STRING	int
,	O
SVT_VOID	int
}	O
;	O
static	O
int	O
perms_tag_checker	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
size_t	long
i	long
;	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
mach	*(struct)
->	O
tagcount	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mach	*(struct)
->	O
tagcount	long
;	O
i	long
++	O
)	O
{	O
int	O
flag	int
;	O
const	O
char	O
*	O
p	*(char)
;	O
mu_sieve_value_t	struct(enum(int,int,int,int,int),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),long,struct(long,long)))
*	O
t	long
=	O
mu_sieve_get_tag_n	(*(struct),long)->(*(struct(enum(int,int,int,int,int),*(char),struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),long,struct(long,long)))))
(	O
mach	*(struct)
,	O
i	long
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
->	O
tag	*(char)
,	O
"permissions"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
mu_parse_stream_perm_string	(*(int),*(char),*(*(char)))->(int)
(	O
&	O
flag	int
,	O
t	long
->	O
v	array(*(char))
.	O
string	*(*(char))
,	O
&	O
p	*(char)
)	O
)	O
{	O
mu_diag_at_locus_range	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_LOG_ERROR	int
,	O
&	O
t	long
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
_	O
(	O
"invalid permissions (near %s)"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
mu_i_sv_error	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mach	*(struct)
)	O
;	O
err	int
=	O
1	int
;	O
}	O
}	O
}	O
return	O
err	int
;	O
}	O
static	O
mu_sieve_tag_def_t	struct(*(char),enum(int,int,int,int,int))
perms_tags	array(struct(*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"permissions"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_tag_group_t	struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int)))
fileinto_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct(struct`,int,*`,*`,*`,*`,*`,long,long,*`,long,long,*`,long,long,long,*`,enum(int,int,int,int,int),long,long,*`,*`,*`,long,long,*`,*`,long,long,long,*`,int,array(struct(array(long),int,struct(array(long)))),*`,*`,long,*`,int,int,int,struct`,int,struct`,*`,*`,*`,*`,*`,*`)))->(int))))
[	O
]	O
=	O
{	O
{	O
perms_tags	array(struct(*(char),enum(int,int,int,int,int)))
,	O
perms_tag_checker	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mu_i_sv_register_standard_actions	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"stop"	*(char)
,	O
sieve_action_stop	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"keep"	*(char)
,	O
sieve_action_keep	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"discard"	*(char)
,	O
sieve_action_discard	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"fileinto"	*(char)
,	O
sieve_action_fileinto	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
fileinto_args	array(enum(int,int,int,int,int))
,	O
fileinto_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct(struct`,int,*`,*`,*`,*`,*`,long,long,*`,long,long,*`,long,long,long,*`,enum(int,int,int,int,int),long,long,*`,*`,*`,long,long,*`,*`,long,long,long,*`,int,array(struct(array(long),int,struct(array(long)))),*`,*`,long,*`,int,int,int,struct`,int,struct`,*`,*`,*`,*`,*`,*`)))->(int))))
,	O
0	int
)	O
;	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"reject"	*(char)
,	O
sieve_action_reject	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
fileinto_args	array(enum(int,int,int,int,int))
,	O
NULL	O
,	O
0	int
)	O
;	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"redirect"	*(char)
,	O
sieve_action_redirect	(*(struct(struct(struct(*`,int,int),struct(*`,int,int)),int,*(struct),*(struct),*(struct),*(struct),*(*(char)),long,long,*(struct(int,int,*`,*`,*`)),long,long,*(struct(enum(int,int,int,int,int),*`,struct`,union`)),long,long,long,*(union(*`,*`,*`,*`,long,long,long,int,*`,int)),enum(int,int,int,int,int),long,long,*(struct),*(char),*(struct(int,int)),long,long,*(struct),*(char),long,long,long,*((*`,*`,*`)->(int)),int,array(struct(array(long),int,struct(array(long)))),*(struct),*(struct),long,*(struct),int,int,int,struct(struct(*`,int,int),struct(*`,int,int)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(struct),*(struct),*((*`,*`,*`,array(struct(int,int,*(void),*(void))))->(void)),*(struct),*(char),*(void))))->(int)
,	O
fileinto_args	array(enum(int,int,int,int,int))
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
