int	O
SLang_Version	int
=	O
SLANG_VERSION	int
;	O
char	O
*	O
SLang_Version_String	*(char)
=	O
SLANG_VERSION_STRING	*(char)
;	O
int	O
_pSLinterp_UTF8_Mode	int
=	O
0	int
;	O
int	O
_pSLtt_UTF8_Mode	int
=	O
0	int
;	O
int	O
_pSLutf8_mode	int
=	O
0	int
;	O
int	O
SLutf8_is_utf8_mode	()->(int)
(	O
void	O
)	O
{	O
return	O
_pSLutf8_mode	int
;	O
}	O
int	O
SLinterp_utf8_enable	(int)->(int)
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
_pSLinterp_UTF8_Mode	int
=	O
mode	int
;	O
}	O
int	O
SLinterp_is_utf8_mode	()->(int)
(	O
void	O
)	O
{	O
return	O
_pSLinterp_UTF8_Mode	int
;	O
}	O
static	O
int	O
utf8_enable	(int)->(int)
(	O
int	O
mode	int
)	O
{	O
char	O
*	O
locale	*(char)
;	O
if	O
(	O
mode	int
!=	O
-	O
1	int
)	O
return	O
(	O
mode	int
!=	O
0	int
)	O
;	O
(	O
void	O
)	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
locale	*(char)
=	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
(	O
(	O
locale	*(char)
==	O
NULL	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
0	int
)	O
)	O
&&	O
(	O
(	O
NULL	O
==	O
(	O
locale	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
)	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
0	int
)	O
)	O
&&	O
(	O
(	O
NULL	O
==	O
(	O
locale	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LC_CTYPE"	*(char)
)	O
)	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
0	int
)	O
)	O
&&	O
(	O
(	O
NULL	O
==	O
(	O
locale	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LANG"	*(char)
)	O
)	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
0	int
)	O
)	O
)	O
return	O
0	int
;	O
while	O
(	O
*	O
locale	*(char)
&&	O
(	O
*	O
locale	*(char)
!=	O
'.'	O
)	O
&&	O
(	O
*	O
locale	*(char)
!=	O
'@'	O
)	O
&&	O
(	O
*	O
locale	*(char)
!=	O
'+'	O
)	O
&&	O
(	O
*	O
locale	*(char)
!=	O
','	O
)	O
)	O
locale	*(char)
++	O
;	O
if	O
(	O
*	O
locale	*(char)
==	O
'.'	O
)	O
{	O
locale	*(char)
++	O
;	O
if	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
locale	*(char)
,	O
"UTF-8"	*(char)
,	O
5	int
)	O
)	O
locale	*(char)
+=	O
5	int
;	O
else	O
if	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
locale	*(char)
,	O
"utf8"	*(char)
,	O
4	int
)	O
)	O
locale	*(char)
+=	O
4	int
;	O
else	O
return	O
0	int
;	O
if	O
(	O
(	O
*	O
locale	*(char)
==	O
0	int
)	O
||	O
(	O
*	O
locale	*(char)
==	O
'@'	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
'+'	O
)	O
||	O
(	O
*	O
locale	*(char)
==	O
','	O
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
SLutf8_enable	(int)->(int)
(	O
int	O
mode	int
)	O
{	O
mode	int
=	O
utf8_enable	(int)->(int)
(	O
mode	int
)	O
;	O
_pSLutf8_mode	int
=	O
mode	int
;	O
_pSLtt_UTF8_Mode	int
=	O
mode	int
;	O
_pSLinterp_UTF8_Mode	int
=	O
mode	int
;	O
return	O
mode	int
;	O
}	O
char	O
*	O
SLcalloc	(int,int)->(*(char))
(	O
unsigned	O
int	O
nelems	int
,	O
unsigned	O
int	O
len	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
len	int
=	O
nelems	int
*	O
len	int
;	O
p	*(char)
=	O
SLmalloc	O
(	O
len	int
)	O
;	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(char)
,	O
0	int
,	O
len	int
)	O
;	O
return	O
p	*(char)
;	O
}	O
int	O
_pSLsecure_issetugid	()->(int)
(	O
void	O
)	O
{	O
static	O
int	O
enable_secure	int
;	O
if	O
(	O
enable_secure	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
getuid	()->(int)
(	O
)	O
!=	O
geteuid	()->(int)
(	O
)	O
)	O
||	O
(	O
getgid	()->(int)
(	O
)	O
!=	O
getegid	()->(int)
(	O
)	O
)	O
)	O
enable_secure	int
=	O
1	int
;	O
else	O
enable_secure	int
=	O
-	O
1	int
;	O
}	O
return	O
(	O
enable_secure	int
==	O
1	int
)	O
;	O
}	O
char	O
*	O
_pSLsecure_getenv	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
_pSLsecure_issetugid	()->(int)
(	O
)	O
)	O
return	O
NULL	O
;	O
return	O
getenv	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
}	O
typedef	O
struct	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
{	O
int	O
(	O
*	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
(	O
VOID_STAR	*(void)
)	O
;	O
VOID_STAR	*(void)
client_data	*(void)
;	O
struct	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
;	O
static	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
static	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
find_interrupt_hook	(*((*(void))->(int)),*(void),*(*(struct(*((*`)->(int)),*(void),*(struct`)))))->(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
(	O
int	O
(	O
*	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
(	O
VOID_STAR	*(void)
)	O
,	O
VOID_STAR	*(void)
cd	*(void)
,	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
*	O
prevp	*(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
)	O
{	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
prev	*(struct(*(struct(*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
while	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
==	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
&&	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
client_data	*(void)
==	O
cd	*(void)
)	O
)	O
{	O
if	O
(	O
prevp	*(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
!=	O
NULL	O
)	O
*	O
prevp	*(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
=	O
prev	*(struct(*(struct(*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int)),int))
;	O
return	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
}	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
return	O
NULL	O
;	O
}	O
int	O
SLang_add_interrupt_hook	(*((*(void))->(int)),*(void))->(int)
(	O
int	O
(	O
*	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
(	O
VOID_STAR	*(void)
)	O
,	O
VOID_STAR	*(void)
cd	*(void)
)	O
{	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
if	O
(	O
NULL	O
!=	O
find_interrupt_hook	(*((*(void))->(int)),*(void),*(*(struct(*((*`)->(int)),*(void),*(struct`)))))->(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
(	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
,	O
cd	*(void)
,	O
NULL	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
NULL	O
==	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
(	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
)	O
SLmalloc	O
(	O
sizeof	O
(	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
client_data	*(void)
=	O
cd	*(void)
;	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
return	O
0	int
;	O
}	O
void	O
SLang_remove_interrupt_hook	(*((*(void))->(int)),*(void))->(void)
(	O
int	O
(	O
*	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
(	O
VOID_STAR	*(void)
)	O
,	O
VOID_STAR	*(void)
cd	*(void)
)	O
{	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
,	O
*	O
hprev	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
if	O
(	O
NULL	O
==	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
find_interrupt_hook	(*((*(void))->(int)),*(void),*(*(struct(*((*`)->(int)),*(void),*(struct`)))))->(*(struct(*((*`)->(int)),*(void),*(struct(*`,*`,*`)))))
(	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
,	O
cd	*(void)
,	O
&	O
hprev	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
)	O
)	O
)	O
return	O
;	O
if	O
(	O
hprev	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
==	O
NULL	O
)	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
else	O
hprev	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
)	O
;	O
}	O
int	O
SLang_handle_interrupt	()->(int)
(	O
void	O
)	O
{	O
Interrupt_Hook_Type	struct(*((*(void))->(int)),*(void),*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`))))))
*	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
int	O
status	int
=	O
0	int
;	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
Interrupt_Hooks	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
;	O
while	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
func	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
)	O
(	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
client_data	*(void)
)	O
)	O
status	int
=	O
-	O
1	int
;	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
=	O
h	*(struct(*((*(void))->(int)),*(void),*(struct(*((*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
return	O
status	int
;	O
}	O
