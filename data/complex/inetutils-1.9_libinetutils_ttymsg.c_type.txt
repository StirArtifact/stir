static	O
int	O
fork2	()->(int)
(	O
void	O
)	O
;	O
static	O
char	O
*	O
normalize_path	(*(char),*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
,	O
const	O
char	O
*	O
delim	*(char)
)	O
;	O
char	O
*	O
ttymsg	(*(struct(*(void),long)),int,*(char),int)->(*(char))
(	O
struct	O
iovec	struct(*(void),long)
*	O
iov	*(struct(*(void),long))
,	O
int	O
iovcnt	int
,	O
char	O
*	O
line	*(char)
,	O
int	O
tmout	int
)	O
{	O
static	O
char	O
errbuf	array(char)
[	O
MAX_ERRBUF	int
]	O
;	O
char	O
*	O
device	*(char)
;	O
register	O
int	O
cnt	int
,	O
fd	int
,	O
left	int
,	O
wret	int
;	O
struct	O
iovec	struct(*(void),long)
localiov	array(struct(*(void),long))
[	O
6	int
]	O
;	O
int	O
forked	int
=	O
0	int
;	O
if	O
(	O
iovcnt	int
>	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
localiov	array(struct(*(void),long))
)	O
/	O
sizeof	O
(	O
localiov	array(struct(*(void),long))
[	O
0	int
]	O
)	O
)	O
)	O
return	O
(	O
char	O
*	O
)	O
(	O
"too many iov's (change code in wall/ttymsg.c)"	*(char)
)	O
;	O
device	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
PATH_TTY_PFX	O
-	O
1	int
+	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
device	*(char)
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
errbuf	array(char)
,	O
sizeof	O
errbuf	array(char)
,	O
"Not enough memory for tty device name"	*(char)
)	O
;	O
return	O
errbuf	array(char)
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
device	*(char)
,	O
PATH_TTY_PFX	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
device	*(char)
,	O
line	*(char)
)	O
;	O
normalize_path	(*(char),*(char))->(*(char))
(	O
device	*(char)
,	O
"/"	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
device	*(char)
,	O
PATH_TTY_PFX	O
,	O
strlen	(*(char))->(long)
(	O
PATH_TTY_PFX	O
)	O
)	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
errbuf	array(char)
,	O
sizeof	O
(	O
errbuf	array(char)
)	O
,	O
"bad line name: %s"	*(char)
,	O
line	*(char)
)	O
;	O
return	O
(	O
errbuf	array(char)
)	O
;	O
}	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
device	*(char)
,	O
O_WRONLY	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EBUSY	int
||	O
errno	O
==	O
EACCES	int
)	O
return	O
(	O
NULL	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
errbuf	array(char)
,	O
sizeof	O
(	O
errbuf	array(char)
)	O
,	O
"%s: %s"	*(char)
,	O
device	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
device	*(char)
)	O
;	O
return	O
errbuf	array(char)
;	O
}	O
for	O
(	O
cnt	int
=	O
left	int
=	O
0	int
;	O
cnt	int
<	O
iovcnt	int
;	O
++	O
cnt	int
)	O
left	int
+=	O
iov	*(struct(*(void),long))
[	O
cnt	int
]	O
.	O
iov_len	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
wret	int
=	O
writev	(int,*(struct(*(void),long)),int)->(long)
(	O
fd	int
,	O
iov	*(struct(*(void),long))
,	O
iovcnt	int
)	O
;	O
if	O
(	O
wret	int
>=	O
left	int
)	O
break	O
;	O
if	O
(	O
wret	int
>=	O
0	int
)	O
{	O
left	int
-=	O
wret	int
;	O
if	O
(	O
iov	*(struct(*(void),long))
!=	O
localiov	array(struct(*(void),long))
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
localiov	array(struct(*(void),long))
,	O
iov	*(struct(*(void),long))
,	O
iovcnt	int
*	O
sizeof	O
(	O
struct	O
iovec	struct(*(void),long)
)	O
)	O
;	O
iov	*(struct(*(void),long))
=	O
localiov	array(struct(*(void),long))
;	O
}	O
for	O
(	O
cnt	int
=	O
0	int
;	O
wret	int
>=	O
(	O
int	O
)	O
iov	*(struct(*(void),long))
->	O
iov_len	long
;	O
++	O
cnt	int
)	O
{	O
wret	int
-=	O
iov	*(struct(*(void),long))
->	O
iov_len	long
;	O
++	O
iov	*(struct(*(void),long))
;	O
--	O
iovcnt	int
;	O
}	O
if	O
(	O
wret	int
)	O
{	O
iov	*(struct(*(void),long))
->	O
iov_base	*(void)
=	O
(	O
char	O
*	O
)	O
iov	*(struct(*(void),long))
->	O
iov_base	*(void)
+	O
wret	int
;	O
iov	*(struct(*(void),long))
->	O
iov_len	long
-=	O
wret	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
int	O
cpid	int
,	O
off	int
=	O
0	int
;	O
if	O
(	O
forked	int
)	O
{	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
cpid	int
=	O
fork2	()->(int)
(	O
)	O
;	O
if	O
(	O
cpid	int
<	O
0	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
errbuf	array(char)
,	O
sizeof	O
(	O
errbuf	array(char)
)	O
,	O
"fork: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
free	(*(void))->(void)
(	O
device	*(char)
)	O
;	O
return	O
(	O
errbuf	array(char)
)	O
;	O
}	O
if	O
(	O
cpid	int
)	O
{	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
free	(*(void))->(void)
(	O
device	*(char)
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
forked	int
++	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
SIG_DFL	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
{	O
sigset_t	struct(array(long))
empty	struct(array(long))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
empty	struct(array(long))
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_SETMASK	int
,	O
&	O
empty	struct(array(long))
,	O
0	int
)	O
;	O
}	O
alarm	(int)->(int)
(	O
(	O
u_int	int
)	O
tmout	int
)	O
;	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
O_NONBLOCK	int
,	O
&	O
off	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
ENODEV	int
||	O
errno	O
==	O
EIO	int
)	O
break	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
if	O
(	O
forked	int
)	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
errbuf	array(char)
,	O
sizeof	O
(	O
errbuf	array(char)
)	O
,	O
"%s: %s"	*(char)
,	O
device	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
device	*(char)
)	O
;	O
return	O
(	O
errbuf	array(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
device	*(char)
)	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
if	O
(	O
forked	int
)	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
static	O
int	O
fork2	()->(int)
(	O
void	O
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
)	O
{	O
switch	O
(	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
-	O
1	int
:	O
_exit	(int)->(void)
(	O
errno	O
)	O
;	O
default	O
:	O
_exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
pid	int
<	O
0	int
||	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
else	O
errno	O
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
else	O
errno	O
=	O
EINTR	int
;	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
normalize_path	(*(char),*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
,	O
const	O
char	O
*	O
delim	*(char)
)	O
{	O
int	O
len	int
;	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
path	*(char)
)	O
return	O
path	*(char)
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
path	*(char)
;	O
if	O
(	O
len	int
&&	O
path	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
delim	*(char)
[	O
0	int
]	O
)	O
path	*(char)
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
path	*(char)
,	O
'.'	O
)	O
;	O
p	*(char)
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
'.'	O
)	O
)	O
{	O
if	O
(	O
p	*(char)
>	O
path	*(char)
&&	O
p	*(char)
[	O
-	O
1	int
]	O
==	O
delim	*(char)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
p	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
p	*(char)
[	O
2	int
]	O
==	O
0	int
||	O
p	*(char)
[	O
2	int
]	O
==	O
delim	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
q	*(char)
,	O
*	O
s	*(char)
;	O
for	O
(	O
q	*(char)
=	O
p	*(char)
-	O
2	int
;	O
*	O
q	*(char)
!=	O
delim	*(char)
[	O
0	int
]	O
&&	O
q	*(char)
>=	O
path	*(char)
;	O
q	*(char)
--	O
)	O
;	O
if	O
(	O
q	*(char)
<	O
path	*(char)
)	O
break	O
;	O
s	*(char)
=	O
p	*(char)
+	O
2	int
;	O
p	*(char)
=	O
q	*(char)
;	O
while	O
(	O
(	O
*	O
q	*(char)
++	O
=	O
*	O
s	*(char)
++	O
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
p	*(char)
++	O
;	O
}	O
if	O
(	O
path	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
path	*(char)
[	O
0	int
]	O
=	O
delim	*(char)
[	O
0	int
]	O
;	O
path	*(char)
[	O
1	int
]	O
=	O
0	int
;	O
}	O
return	O
path	*(char)
;	O
}	O
