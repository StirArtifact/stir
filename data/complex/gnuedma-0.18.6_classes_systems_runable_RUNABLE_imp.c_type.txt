typedef	O
struct	O
{	O
EUint32	long
thread	long
;	O
OBJID	int
id	int
;	O
}	O
DtRUNABLE	struct(long,int)
;	O
typedef	O
struct	O
s_par	struct(int,int,*(char),*(void))
{	O
OBJID	int
idProxy	int
;	O
OBJID	int
id	int
;	O
EPChar	*(char)
name	*(char)
;	O
EPVoid	*(void)
pars	*(void)
;	O
}	O
TH_PAR	struct(int,int,*(char),*(void))
;	O
void	O
*	O
threaded_func	(*(void))->(*(void))
(	O
void	O
*	O
pars	*(void)
)	O
;	O
ESint32	int
EDMAPROC	O
RUNABLENewObj	(int,*(char))->(int)
(	O
OBJID	int
IdObj	int
,	O
EPChar	*(char)
name	*(char)
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Creating object of class %s"	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
m	*(struct(long,int))
->	O
id	int
=	O
edma_new_obj	(*(char))->(int)
(	O
name	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
RUNABLEFreeObj	(int)->(int)
(	O
OBJID	int
IdObj	int
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_free_obj	(int)->(long)
(	O
m	*(struct(long,int))
->	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
RUNABLEWProp3	(int,int,*(char),*(void))->(int)
(	O
OBJID	int
IdObj	int
,	O
CLASSID	int
id	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPVoid	*(void)
par	*(void)
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
return	O
edma_wprop3_pargs	(int,*(char),*(void))->(int)
(	O
m	*(struct(long,int))
->	O
id	int
,	O
name	*(char)
,	O
par	*(void)
)	O
;	O
}	O
ESint32	int
EDMAPROC	O
RUNABLERProp3	(int,int,*(char),*(void))->(int)
(	O
OBJID	int
IdObj	int
,	O
CLASSID	int
id	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPVoid	*(void)
par	*(void)
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
return	O
edma_rprop3_pargs	(int,*(char),*(void))->(int)
(	O
m	*(struct(long,int))
->	O
id	int
,	O
name	*(char)
,	O
par	*(void)
)	O
;	O
}	O
ESint32	int
EDMAPROC	O
RUNABLEMet3	(int,int,*(char),*(void))->(int)
(	O
OBJID	int
IdObj	int
,	O
CLASSID	int
id	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPVoid	*(void)
par	*(void)
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
TH_PAR	struct(int,int,*(char),*(void))
*	O
pars	*(void)
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
pars	*(void)
=	O
(	O
TH_PAR	struct(int,int,*(char),*(void))
*	O
)	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
TH_PAR	struct(int,int,*(char),*(void))
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"%s"	*(char)
,	O
"Can't allocate memory for thread parameters"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pars	*(void)
->	O
idProxy	int
=	O
IdObj	int
;	O
pars	*(void)
->	O
id	int
=	O
m	*(struct(long,int))
->	O
id	int
;	O
pars	*(void)
->	O
name	*(char)
=	O
name	*(char)
;	O
pars	*(void)
->	O
pars	*(void)
=	O
par	*(void)
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Creating thread for method %s"	*(char)
,	O
name	*(char)
)	O
;	O
pthread_create	(*(long),*(union(array(char),long)),*((*(void))->(*(void))),*(void))->(int)
(	O
&	O
m	*(struct(long,int))
->	O
thread	long
,	O
NULL	O
,	O
threaded_func	(*(void))->(*(void))
,	O
pars	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
RUNABLEMet3S	(int,int,*(char),*(char),*(void))->(int)
(	O
OBJID	int
IdObj	int
,	O
CLASSID	int
id	int
,	O
EPChar	*(char)
name	*(char)
,	O
EPChar	*(char)
sig	*(char)
,	O
EPVoid	*(void)
par	*(void)
)	O
{	O
DtRUNABLE	struct(long,int)
*	O
m	*(struct(long,int))
;	O
m	*(struct(long,int))
=	O
(	O
DtRUNABLE	struct(long,int)
*	O
)	O
edma_get_data_ref	(int)->(*(void))
(	O
IdObj	int
)	O
;	O
edma_printf_obj	(int,*(char))->(long)
(	O
IdObj	int
,	O
"Met3S still not implemented"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
*	O
threaded_func	(*(void))->(*(void))
(	O
void	O
*	O
pars	*(void)
)	O
{	O
TH_PAR	struct(int,int,*(char),*(void))
*	O
p	*(struct(int,int,*(char),*(void)))
;	O
edma_thread_register	()->(int)
(	O
)	O
;	O
p	*(struct(int,int,*(char),*(void)))
=	O
(	O
TH_PAR	struct(int,int,*(char),*(void))
*	O
)	O
pars	*(void)
;	O
edma_printf	(*(char))->(long)
(	O
"[RUNABLE] Invoking threaded method %s on object %d"	*(char)
,	O
p	*(struct(int,int,*(char),*(void)))
->	O
name	*(char)
,	O
p	*(struct(int,int,*(char),*(void)))
->	O
id	int
)	O
;	O
edma_met3_pargs	(int,*(char),*(char),int,*(void))->(int)
(	O
p	*(struct(int,int,*(char),*(void)))
->	O
id	int
,	O
p	*(struct(int,int,*(char),*(void)))
->	O
name	*(char)
,	O
NULL	O
,	O
1	int
,	O
p	*(struct(int,int,*(char),*(void)))
->	O
pars	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
pars	*(void)
)	O
;	O
edma_thread_unregister	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
