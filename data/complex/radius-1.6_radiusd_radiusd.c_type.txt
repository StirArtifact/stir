const	O
char	O
*	O
argp_program_version	*(char)
=	O
"radiusd ("	*(char)
PACKAGE	*(char)
") "	*(char)
VERSION	*(char)
;	O
static	O
char	O
doc	*(char)
[	O
]	O
=	O
N_	O
(	O
"GNU radius daemon"	*(char)
)	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	int
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"radiusd specific switches:"	*(char)
)	O
,	O
GRP	int
}	O
,	O
{	O
"foreground"	*(char)
,	O
'f'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Stay in foreground"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"mode"	*(char)
,	O
'm'	O
,	O
"{t|c|b}"	*(char)
,	O
0	int
,	O
N_	O
(	O
"Select operation mode: test, checkconf, builddbm."	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"single-process"	*(char)
,	O
's'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Run in single process mode"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"pid-file-dir"	*(char)
,	O
'P'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Store pidfile in DIR"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"show-defaults"	*(char)
,	O
SHOW_DEFAULTS_OPTION	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Show compilation defaults"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"quiet"	*(char)
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Quiet mode (valid only with --mode)"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Daemon configuration options. Please use raddb/config instead."	*(char)
)	O
,	O
GRP	int
}	O
,	O
{	O
"log-auth-detail"	*(char)
,	O
'A'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Do detailed authentication logging"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"acct-directory"	*(char)
,	O
'a'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set accounting directory"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"logging-directory"	*(char)
,	O
'l'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set logging directory name"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"do-not-resolve"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Do not resolve IP addresses"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ip-address"	*(char)
,	O
'i'	O
,	O
N_	O
(	O
"IPADDR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Listen on IPADDR"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"port"	*(char)
,	O
'p'	O
,	O
"NUMBER"	*(char)
,	O
0	int
,	O
N_	O
(	O
"Set authentication port number"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-stripped-names"	*(char)
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Strip prefixes/suffixes off user names before logging"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"debug"	*(char)
,	O
'x'	O
,	O
N_	O
(	O
"DEBUGSPEC"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set debugging level"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-auth"	*(char)
,	O
'y'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Log authentications"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-auth-pass"	*(char)
,	O
'z'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Log users' passwords"	*(char)
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
debug_flag	int
;	O
int	O
log_mode	int
;	O
int	O
console_logging_priority	int
=	O
-	O
1	int
;	O
char	O
*	O
auth_log_hook	*(char)
;	O
static	O
int	O
foreground	int
;	O
int	O
spawn_flag	int
;	O
int	O
use_dbm	int
=	O
0	int
;	O
int	O
auth_detail	int
=	O
0	int
;	O
char	O
*	O
auth_detail_template	*(char)
;	O
int	O
acct_detail	int
=	O
1	int
;	O
char	O
*	O
acct_detail_template	*(char)
;	O
int	O
acct_system	int
=	O
1	int
;	O
int	O
auth_trace_rules	int
=	O
0	int
;	O
int	O
acct_trace_rules	int
=	O
0	int
;	O
int	O
strip_names	int
;	O
int	O
suspend_flag	int
;	O
int	O
auth_reject_malformed_names	int
=	O
0	int
;	O
RADIUS_USER	struct(*(char),int,int)
radiusd_user	struct(*(char),int,int)
;	O
RADIUS_USER	struct(*(char),int,int)
exec_user	struct(*(char),int,int)
;	O
int	O
daemon_command	int
=	O
CMD_NONE	int
;	O
static	O
INPUT	struct
*	O
radius_input	*(struct)
;	O
int	O
auth_comp_flag	int
;	O
int	O
acct_comp_flag	int
;	O
int	O
checkrad_assume_logged	int
=	O
1	int
;	O
size_t	long
max_requests	int
=	O
MAX_REQUESTS	int
;	O
size_t	long
max_children	long
=	O
MAX_CHILDREN	int
;	O
unsigned	O
process_timeout	int
=	O
PROCESS_TIMEOUT	int
;	O
unsigned	O
radiusd_write_timeout	int
=	O
RADIUSD_WRITE_TIMEOUT	int
;	O
unsigned	O
radiusd_read_timeout	int
=	O
RADIUSD_READ_TIMEOUT	int
;	O
grad_uint32_t	int
warning_seconds	int
;	O
int	O
use_guile	int
;	O
char	O
*	O
message_text	array(*(char))
[	O
MSG_COUNT	int
]	O
;	O
grad_uint32_t	int
myip	int
=	O
INADDR_ANY	O
;	O
grad_uint32_t	int
ref_ip	int
=	O
INADDR_ANY	O
;	O
int	O
auth_port	int
;	O
int	O
acct_port	int
;	O
pid_t	int
radiusd_pid	int
;	O
int	O
radius_mode	int
=	O
MODE_DAEMON	int
;	O
int	O
xargc	int
;	O
char	O
*	O
*	O
xargv	*(*(char))
;	O
char	O
*	O
x_debug_spec	*(char)
;	O
static	O
RETSIGTYPE	void
sig_handler	(int)->(void)
(	O
int	O
sig	int
)	O
;	O
void	O
radiusd_main_loop	()->(void)
(	O
)	O
;	O
static	O
size_t	long
radius_count_channels	()->(long)
(	O
)	O
;	O
void	O
radiusd_run_preconfig_hooks	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
config_syntax	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
auth_detail	int
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
grad_acct_dir	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
foreground	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
grad_log_dir	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
switch	O
(	O
arg	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
't'	O
:	O
radius_mode	int
=	O
MODE_TEST	int
;	O
break	O
;	O
case	O
'b'	O
:	O
argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
state	*(int)
,	O
_	O
(	O
"radiusd compiled without DBM support"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
radius_mode	int
=	O
MODE_CHECKCONF	int
;	O
break	O
;	O
default	O
:	O
argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
state	*(int)
,	O
_	O
(	O
"unknown mode: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'n'	O
:	O
grad_resolve_hostnames	int
=	O
0	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
(	O
myip	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid IP address: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
grad_pid_dir	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'p'	O
:	O
auth_port	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
acct_port	int
=	O
auth_port	int
+	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
console_logging_priority	int
=	O
GRAD_LOG_ERR	int
;	O
break	O
;	O
case	O
'S'	O
:	O
strip_names	int
++	O
;	O
break	O
;	O
case	O
's'	O
:	O
spawn_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
x_debug_spec	*(char)
=	O
arg	*(char)
;	O
grad_set_debug_levels	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
log_mode	int
|=	O
RLOG_AUTH	int
;	O
break	O
;	O
case	O
'z'	O
:	O
log_mode	int
|=	O
RLOG_AUTH_PASS	int
;	O
break	O
;	O
case	O
SHOW_DEFAULTS_OPTION	int
:	O
show_compilation_defaults	()->(int)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	int
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
doc	*(char)
,	O
grad_common_argp_child	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
,	O
NULL	O
,	O
NULL	O
}	O
;	O
void	O
set_config_defaults	()->(void)
(	O
)	O
{	O
username_valid_chars	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
".-_!@#$%^&\\/"	*(char)
)	O
;	O
message_text	array(*(char))
[	O
MSG_ACCOUNT_CLOSED	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"Sorry, your account is currently closed\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_PASSWORD_EXPIRED	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"Password has expired\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_PASSWORD_EXPIRE_WARNING	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"Password will expire in %R{Password-Expire-Days} Days\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_ACCESS_DENIED	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"\nAccess denied\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_REALM_QUOTA	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"\nRealm quota exceeded - access denied\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_MULTIPLE_LOGIN	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"\nYou are already logged in %R{Simultaneous-Use} times - access denied\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_SECOND_LOGIN	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"\nYou are already logged in - access denied\n"	*(char)
)	O
)	O
;	O
message_text	array(*(char))
[	O
MSG_TIMESPAN_VIOLATION	int
]	O
=	O
grad_estrdup	(*(char))->(*(char))
(	O
_	O
(	O
"You are calling outside your allowed timespan\n"	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
get_port_number	(*(char),*(char),int)->(int)
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
proto	int
,	O
int	O
defval	*(char)
)	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
;	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
name	*(char)
,	O
proto	int
)	O
;	O
return	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
?	O
ntohs	(short)->(short)
(	O
svp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
)	O
:	O
defval	*(char)
;	O
}	O
unsigned	O
max_ttl	(*(long))->(int)
(	O
time_t	long
*	O
t	long
)	O
{	O
unsigned	O
i	int
,	O
delta	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
R_MAX	int
;	O
i	int
++	O
)	O
if	O
(	O
delta	int
<	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
i	int
]	O
.	O
ttl	int
)	O
delta	int
=	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
i	int
]	O
.	O
ttl	int
;	O
if	O
(	O
t	long
)	O
{	O
time	struct(long,long)
(	O
t	long
)	O
;	O
*	O
t	long
+=	O
delta	int
;	O
}	O
return	O
delta	int
;	O
}	O
static	O
void	O
terminate_subprocesses	()->(void)
(	O
)	O
{	O
int	O
kill_sent	int
=	O
0	int
;	O
time_t	long
t	long
;	O
radiusd_flush_queue	()->(void)
(	O
)	O
;	O
request_init_queue	()->(void)
(	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Terminating the subprocesses"	*(char)
)	O
)	O
;	O
rpp_kill	(int,int)->(int)
(	O
-	O
1	int
,	O
SIGTERM	int
)	O
;	O
max_ttl	(*(long))->(int)
(	O
&	O
t	long
)	O
;	O
while	O
(	O
rpp_count	()->(long)
(	O
)	O
)	O
{	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
radiusd_cleanup	()->(void)
(	O
)	O
;	O
if	O
(	O
time	struct(long,long)
(	O
NULL	O
)	O
>=	O
t	long
)	O
{	O
if	O
(	O
kill_sent	int
)	O
{	O
int	O
n	long
=	O
rpp_count	()->(long)
(	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%d process left!"	*(char)
,	O
"%d processes left!"	*(char)
,	O
n	long
)	O
,	O
n	long
)	O
;	O
break	O
;	O
}	O
max_ttl	(*(long))->(int)
(	O
&	O
t	long
)	O
;	O
rpp_kill	(int,int)->(int)
(	O
-	O
1	int
,	O
SIGKILL	int
)	O
;	O
kill_sent	int
=	O
1	int
;	O
}	O
}	O
}	O
static	O
void	O
radiusd_preconfig_hook	(*(void),*(void))->(void)
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
terminate_subprocesses	()->(void)
(	O
)	O
;	O
input_close_channels	(*(struct))->(void)
(	O
radius_input	*(struct)
)	O
;	O
}	O
static	O
void	O
radiusd_postconfig_hook	(*(void),*(void))->(void)
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
radius_count_channels	()->(long)
(	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
foreground	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"Radiusd is not listening on any port."	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"Radiusd is not listening on any port. Trying to continue anyway..."	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
void	O
daemon_postconfig_hook	(*(void),*(void))->(void)
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
system_acct_init	()->(void)
(	O
)	O
;	O
}	O
void	O
radiusd_setup	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
grad_max_fd	()->(int)
(	O
)	O
;	O
i	int
>=	O
3	int
;	O
i	int
--	O
)	O
close	*((*(void))->(int))
(	O
i	int
)	O
;	O
if	O
(	O
auth_port	int
==	O
0	int
)	O
auth_port	int
=	O
get_port_number	(*(char),*(char),int)->(int)
(	O
"radius"	*(char)
,	O
"udp"	*(char)
,	O
DEF_AUTH_PORT	int
)	O
;	O
if	O
(	O
acct_port	int
==	O
0	int
)	O
acct_port	int
=	O
get_port_number	(*(char),*(char),int)->(int)
(	O
"radacct"	*(char)
,	O
"udp"	*(char)
,	O
auth_port	int
+	O
1	int
)	O
;	O
srand	(int)->(void)
(	O
time	struct(long,long)
(	O
NULL	O
)	O
)	O
;	O
radiusd_set_preconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
radiusd_preconfig_hook	(*(void),*(void))->(void)
,	O
NULL	O
,	O
0	int
)	O
;	O
radiusd_set_postconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
radiusd_postconfig_hook	(*(void),*(void))->(void)
,	O
NULL	O
,	O
0	int
)	O
;	O
rewrite_init	()->(void)
(	O
)	O
;	O
dynload_init	()->(void)
(	O
)	O
;	O
snmp_init	(int,int,*((long)->(*(void))),*((*(void))->(*(void))))->(void)
(	O
0	int
,	O
0	int
,	O
(	O
snmp_alloc_t	*((long)->(*(void)))
)	O
grad_emalloc	(long)->(*(void))
,	O
(	O
snmp_free_t	*((*(void))->(*(void)))
)	O
grad_free	(*(void))->(void)
)	O
;	O
mlc_init	()->(int)
(	O
)	O
;	O
sql_init	O
(	O
)	O
;	O
}	O
void	O
common_init	()->(void)
(	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Starting"	*(char)
)	O
)	O
;	O
radiusd_pid	int
=	O
getpid	()->(int)
(	O
)	O
;	O
radius_input	*(struct)
=	O
input_create	()->(*(struct))
(	O
)	O
;	O
input_register_method	(*(struct),*(char),int,*((int,*(void))->(int)),*((int,*(void))->(int)),*((*(void),*(void))->(int)))->(void)
(	O
radius_input	*(struct)
,	O
"rpp"	*(char)
,	O
0	int
,	O
rpp_input_handler	(int,*(void))->(int)
,	O
rpp_input_close	(int,*(void))->(int)
,	O
NULL	O
)	O
;	O
input_register_method	(*(struct),*(char),int,*((int,*(void))->(int)),*((int,*(void))->(int)),*((*(void),*(void))->(int)))->(void)
(	O
radius_input	*(struct)
,	O
"udp"	*(char)
,	O
1	int
,	O
udp_input_handler	(int,*(void))->(int)
,	O
udp_input_close	(int,*(void))->(int)
,	O
udp_input_cmp	(*(void),*(void))->(int)
)	O
;	O
setvbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,long)->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NULL	O
,	O
_IOLBF	int
,	O
0	int
)	O
;	O
radiusd_signal_init	(*((int)->(void)))->(void)
(	O
sig_handler	(int)->(void)
)	O
;	O
forward_init	()->(void)
(	O
)	O
;	O
acct_init	()->(void)
(	O
)	O
;	O
radiusd_reconfigure	()->(void)
(	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Ready"	*(char)
)	O
)	O
;	O
}	O
void	O
radiusd_daemon	()->(void)
(	O
)	O
{	O
char	O
*	O
p	*(struct)
;	O
int	O
i	int
;	O
pid_t	int
pid	int
;	O
switch	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
setsid	()->(int)
(	O
)	O
;	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
switch	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
-	O
1	int
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
default	O
:	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
p	*(struct)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_log_dir	*(char)
,	O
"radius.stderr"	*(char)
)	O
;	O
i	int
=	O
open	(*(char),int)->(int)
(	O
p	*(struct)
,	O
O_CREAT	int
|	O
O_WRONLY	int
,	O
0644	int
)	O
;	O
if	O
(	O
i	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
i	int
!=	O
2	int
)	O
dup2	(int,int)->(int)
(	O
i	int
,	O
2	int
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
)	O
dup2	(int,int)->(int)
(	O
i	int
,	O
1	int
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
&&	O
i	int
!=	O
2	int
)	O
close	*((*(void))->(int))
(	O
i	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
}	O
int	O
radiusd_master	()->(int)
(	O
)	O
{	O
return	O
radiusd_pid	int
==	O
getpid	()->(int)
(	O
)	O
;	O
}	O
void	O
radiusd_main	()->(void)
(	O
)	O
{	O
switch	O
(	O
radius_mode	int
)	O
{	O
case	O
MODE_CHECKCONF	int
:	O
common_init	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
MODE_TEST	int
:	O
common_init	()->(void)
(	O
)	O
;	O
tsh	()->(int)
(	O
)	O
;	O
case	O
MODE_DAEMON	int
:	O
if	O
(	O
myip	int
!=	O
INADDR_ANY	O
)	O
ref_ip	int
=	O
myip	int
;	O
else	O
ref_ip	int
=	O
grad_first_ip	()->(int)
(	O
)	O
;	O
if	O
(	O
ref_ip	int
==	O
INADDR_ANY	O
)	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"can't find out my own IP address"	*(char)
)	O
)	O
;	O
chdir	(*(char))->(int)
(	O
"/"	*(char)
)	O
;	O
umask	(int)->(int)
(	O
022	int
)	O
;	O
if	O
(	O
!	O
foreground	int
)	O
radiusd_daemon	()->(void)
(	O
)	O
;	O
radiusd_set_postconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
daemon_postconfig_hook	(*(void),*(void))->(void)
,	O
NULL	O
,	O
0	int
)	O
;	O
common_init	()->(void)
(	O
)	O
;	O
}	O
radiusd_pidfile_write	(*(char))->(void)
(	O
RADIUSD_PID_FILE	*(char)
)	O
;	O
if	O
(	O
radiusd_user	struct(*(char),int,int)
.	O
username	*(char)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
log_change_owner	(*(struct(*(char),int,int)))->(int)
(	O
&	O
radiusd_user	struct(*(char),int,int)
)	O
;	O
p	*(struct)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_log_dir	*(char)
,	O
"radius.stderr"	*(char)
)	O
;	O
chown	(*(char),int,int)->(int)
(	O
p	*(struct)
,	O
radiusd_user	struct(*(char),int,int)
.	O
uid	int
,	O
radiusd_user	struct(*(char),int,int)
.	O
gid	int
)	O
;	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
radius_switch_to_user	(*(struct(*(char),int,int)))->(int)
(	O
&	O
radiusd_user	struct(*(char),int,int)
)	O
;	O
}	O
radiusd_main_loop	()->(void)
(	O
)	O
;	O
}	O
void	O
radiusd_start	()->(void)
(	O
)	O
{	O
radiusd_main	()->(void)
(	O
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
debug_flag	int
==	O
0	int
)	O
{	O
foreground	int
=	O
0	int
;	O
spawn_flag	int
=	O
1	int
;	O
}	O
grad_app_setup	()->(void)
(	O
)	O
;	O
grad_set_logger	(*((int,*(struct(int,short,char,char,array(char),*`,*`)),*(struct(*`,long)),*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(void)))->(*((int,*(struct(int,short,char,char,array(char),*`,*`)),*(struct(*`,long)),*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(void)))
(	O
radiusd_logger	(int,*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(*(char),long)),*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(void)
)	O
;	O
xargc	int
=	O
argc	int
;	O
xargv	*(*(char))
=	O
argv	*(*(char))
;	O
set_config_defaults	()->(void)
(	O
)	O
;	O
argp_program_version_hook	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void))))->(void))
=	O
version	()->(void)
;	O
if	O
(	O
grad_argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(int),array(*(*(char))),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
log_set_default	(*(char),int,int)->(void)
(	O
"default.log"	*(char)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
radius_mode	int
!=	O
MODE_DAEMON	int
)	O
log_set_to_console	(int,int)->(void)
(	O
-	O
1	int
,	O
console_logging_priority	int
)	O
;	O
radiusd_setup	()->(void)
(	O
)	O
;	O
radiusd_start	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
snmp_request_to_command	()->(int)
(	O
)	O
{	O
return	O
CMD_NONE	int
;	O
}	O
void	O
radiusd_suspend	()->(void)
(	O
)	O
{	O
if	O
(	O
suspend_flag	int
==	O
0	int
)	O
{	O
terminate_subprocesses	()->(void)
(	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"RADIUSD SUSPENDED"	*(char)
)	O
)	O
;	O
suspend_flag	int
=	O
1	int
;	O
}	O
}	O
void	O
radiusd_continue	()->(void)
(	O
)	O
{	O
if	O
(	O
suspend_flag	int
)	O
{	O
terminate_subprocesses	()->(void)
(	O
)	O
;	O
suspend_flag	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
check_reload	()->(void)
(	O
)	O
{	O
if	O
(	O
daemon_command	int
==	O
CMD_NONE	int
)	O
daemon_command	int
=	O
snmp_request_to_command	()->(int)
(	O
)	O
;	O
switch	O
(	O
daemon_command	int
)	O
{	O
case	O
CMD_CLEANUP	int
:	O
radiusd_cleanup	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_RELOAD	int
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Reloading configuration now"	*(char)
)	O
)	O
;	O
radiusd_reconfigure	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_RESTART	int
:	O
radiusd_restart	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_MEMINFO	int
:	O
break	O
;	O
case	O
CMD_DUMPDB	int
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Dumping users db to `%s'"	*(char)
)	O
,	O
RADIUS_DUMPDB_NAME	*(char)
)	O
;	O
dump_users_db	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_SUSPEND	int
:	O
radiusd_suspend	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_CONTINUE	int
:	O
radiusd_continue	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CMD_SHUTDOWN	int
:	O
radiusd_exit	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
daemon_command	int
=	O
CMD_NONE	int
;	O
}	O
void	O
radiusd_register_input_fd	(*(char),int,*(void))->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
fd	int
,	O
void	O
*	O
data	*(void)
)	O
{	O
input_register_channel	(*(struct),*(char),int,*(void))->(int)
(	O
radius_input	*(struct)
,	O
name	*(char)
,	O
fd	int
,	O
data	*(void)
)	O
;	O
}	O
void	O
radiusd_close_channel	(int)->(void)
(	O
int	O
fd	int
)	O
{	O
input_close_channel_fd	(*(struct),int)->(void)
(	O
radius_input	*(struct)
,	O
fd	int
)	O
;	O
}	O
void	O
radiusd_collect_children	()->(void)
(	O
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
(	O
pid_t	int
)	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
<=	O
0	int
)	O
break	O
;	O
rpp_status_changed	(int,int)->(void)
(	O
pid	int
,	O
status	int
)	O
;	O
}	O
}	O
void	O
radiusd_cleanup	()->(void)
(	O
)	O
{	O
rpp_collect_exited	()->(void)
(	O
)	O
;	O
}	O
void	O
radiusd_restart	()->(void)
(	O
)	O
{	O
pid_t	int
pid	int
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"restart initiated"	*(char)
)	O
)	O
;	O
if	O
(	O
xargv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't restart: not started as absolute pathname"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
radiusd_run_preconfig_hooks	(*(void))->(void)
(	O
NULL	O
)	O
;	O
if	O
(	O
foreground	int
)	O
pid	int
=	O
0	int
;	O
else	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"radiusd_restart: cannot fork"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
radiusd_signal_init	(*((int)->(void)))->(void)
(	O
SIG_DFL	O
)	O
;	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
sleep	(int)->(int)
(	O
10	int
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
sleep	(int)->(int)
(	O
10	int
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"restarting radius"	*(char)
)	O
)	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
xargv	*(*(char))
[	O
0	int
]	O
,	O
xargv	*(*(char))
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"RADIUS NOT RESTARTED: exec failed"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
static	O
int	O
radiusd_rpp_wait	(*(void))->(int)
(	O
void	O
*	O
arg	*(char)
)	O
{	O
time_t	long
*	O
tp	*(long)
=	O
arg	*(char)
;	O
struct	O
timeval	struct(long,long)
tv	*(struct(long,long))
;	O
if	O
(	O
time	struct(long,long)
(	O
NULL	O
)	O
>	O
*	O
tp	*(long)
)	O
return	O
1	int
;	O
tv	*(struct(long,long))
.	O
tv_sec	long
=	O
2	int
;	O
tv	*(struct(long,long))
.	O
tv_usec	long
=	O
0	int
;	O
input_select_channel	(*(struct),*(char),*(struct(long,long)))->(int)
(	O
radius_input	*(struct)
,	O
"rpp"	*(char)
,	O
&	O
tv	*(struct(long,long))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radiusd_flush_queue	()->(void)
(	O
)	O
{	O
time_t	long
t	long
;	O
max_ttl	(*(long))->(int)
(	O
&	O
t	long
)	O
;	O
rpp_flush	(*((*(void))->(int)),*(void))->(void)
(	O
radiusd_rpp_wait	(*(void))->(int)
,	O
&	O
t	long
)	O
;	O
}	O
void	O
radiusd_exit	()->(void)
(	O
)	O
{	O
stat_done	O
(	O
)	O
;	O
radiusd_pidfile_remove	(*(char))->(void)
(	O
RADIUSD_PID_FILE	*(char)
)	O
;	O
radiusd_flush_queue	()->(void)
(	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"Normal shutdown."	*(char)
)	O
)	O
;	O
rpp_kill	(int,int)->(int)
(	O
-	O
1	int
,	O
SIGTERM	int
)	O
;	O
radiusd_exit0	()->(void)
(	O
)	O
;	O
}	O
void	O
radiusd_exit0	()->(void)
(	O
)	O
{	O
radiusd_sql_shutdown	O
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
radiusd_main_loop	()->(void)
(	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Ready to process requests."	*(char)
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
log_open	(int)->(void)
(	O
GRAD_LOG_MAIN	O
)	O
;	O
check_reload	()->(void)
(	O
)	O
;	O
input_select	(*(struct),*(struct(long,long)))->(int)
(	O
radius_input	*(struct)
,	O
NULL	O
)	O
;	O
}	O
}	O
struct	O
hook_rec	struct(*((*(void),*(void))->(void)),*(void),int)
{	O
void	O
(	O
*	O
function	*((*(void),*(void))->(void))
)	O
(	O
void	O
*	O
func_data	*(void)
,	O
void	O
*	O
call_data	*(void)
)	O
;	O
void	O
*	O
data	*(void)
;	O
int	O
once	int
;	O
}	O
;	O
static	O
grad_list_t	struct
*	O
preconfig	*(struct)
;	O
static	O
grad_list_t	struct
*	O
postconfig	*(struct)
;	O
void	O
radiusd_set_preconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
void	O
(	O
*	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
p	*(struct)
,	O
int	O
once	int
)	O
{	O
struct	O
hook_rec	struct(*((*(void),*(void))->(void)),*(void),int)
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
)	O
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
function	*((*(void),*(void))->(void))
=	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
data	*(void)
=	O
p	*(struct)
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
once	int
=	O
once	int
;	O
if	O
(	O
!	O
preconfig	*(struct)
)	O
preconfig	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_prepend	(*(struct),*(void))->(void)
(	O
preconfig	*(struct)
,	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
;	O
}	O
void	O
radiusd_set_postconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
void	O
(	O
*	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
p	*(struct)
,	O
int	O
once	int
)	O
{	O
struct	O
hook_rec	struct(*((*(void),*(void))->(void)),*(void),int)
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
)	O
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
function	*((*(void),*(void))->(void))
=	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
data	*(void)
=	O
p	*(struct)
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
once	int
=	O
once	int
;	O
if	O
(	O
!	O
postconfig	*(struct)
)	O
postconfig	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_prepend	(*(struct),*(void))->(void)
(	O
postconfig	*(struct)
,	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
;	O
}	O
struct	O
hook_runtime_closure	struct(*(struct),*(void))
{	O
grad_list_t	struct
*	O
list	*(*(struct))
;	O
void	O
*	O
call_data	*(void)
;	O
}	O
;	O
static	O
int	O
_hook_call	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
hook_rec	struct(*((*(void),*(void))->(void)),*(void),int)
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
=	O
item	*(void)
;	O
struct	O
hook_runtime_closure	struct(*(struct),*(void))
*	O
clos	*(struct(*(struct),*(void)))
=	O
data	*(void)
;	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
function	*((*(void),*(void))->(void))
(	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
data	*(void)
,	O
clos	*(struct(*(struct),*(void)))
->	O
call_data	*(void)
)	O
;	O
if	O
(	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
->	O
once	int
)	O
{	O
grad_list_remove	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
clos	*(struct(*(struct),*(void)))
->	O
list	*(*(struct))
,	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
,	O
NULL	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radiusd_run_preconfig_hooks	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
hook_runtime_closure	struct(*(struct),*(void))
clos	*(struct(*(struct),*(void)))
;	O
clos	*(struct(*(struct),*(void)))
.	O
list	*(*(struct))
=	O
preconfig	*(struct)
;	O
clos	*(struct(*(struct),*(void)))
.	O
call_data	*(void)
=	O
data	*(void)
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
clos	*(struct(*(struct),*(void)))
.	O
list	*(*(struct))
,	O
_hook_call	(*(void),*(void))->(int)
,	O
&	O
clos	*(struct(*(struct),*(void)))
)	O
;	O
}	O
void	O
radiusd_run_postconfig_hooks	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
hook_runtime_closure	struct(*(struct),*(void))
clos	*(struct(*(struct),*(void)))
;	O
clos	*(struct(*(struct),*(void)))
.	O
list	*(*(struct))
=	O
postconfig	*(struct)
;	O
clos	*(struct(*(struct),*(void)))
.	O
call_data	*(void)
=	O
data	*(void)
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
clos	*(struct(*(struct),*(void)))
.	O
list	*(*(struct))
,	O
_hook_call	(*(void),*(void))->(int)
,	O
&	O
clos	*(struct(*(struct),*(void)))
)	O
;	O
}	O
void	O
radiusd_reconfigure	()->(void)
(	O
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
char	O
*	O
filename	*(char)
;	O
radiusd_run_preconfig_hooks	(*(void))->(void)
(	O
NULL	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Loading configuration files."	*(char)
)	O
)	O
;	O
filename	*(char)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_config_dir	*(char)
,	O
RADIUS_CONFIG	*(char)
)	O
;	O
cfg_read	(*(char),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*(void))->(int)
(	O
filename	*(char)
,	O
config_syntax	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
rc	int
=	O
reload_config_file	(enum(int,int,int,int,int,int,int,int,int,int,int,int))->(int)
(	O
reload_all	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"Errors reading config file - EXITING"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
grad_path_init	()->(void)
(	O
)	O
;	O
radiusd_run_postconfig_hooks	(*(void))->(void)
(	O
NULL	O
)	O
;	O
}	O
static	O
RETSIGTYPE	void
sig_handler	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
switch	O
(	O
sig	int
)	O
{	O
case	O
SIGHUP	int
:	O
daemon_command	int
=	O
CMD_RELOAD	int
;	O
break	O
;	O
case	O
SIGUSR1	int
:	O
daemon_command	int
=	O
CMD_MEMINFO	int
;	O
break	O
;	O
case	O
SIGUSR2	int
:	O
daemon_command	int
=	O
CMD_DUMPDB	int
;	O
break	O
;	O
case	O
SIGCHLD	int
:	O
radiusd_collect_children	()->(void)
(	O
)	O
;	O
daemon_command	int
=	O
CMD_CLEANUP	int
;	O
break	O
;	O
case	O
SIGTERM	int
:	O
case	O
SIGQUIT	int
:	O
daemon_command	int
=	O
CMD_SHUTDOWN	int
;	O
break	O
;	O
case	O
SIGPIPE	int
:	O
daemon_command	int
=	O
CMD_CLEANUP	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
grad_reset_signal	(int,*((int)->(void)))->(void)
(	O
sig	int
,	O
sig_handler	(int)->(void)
)	O
;	O
}	O
void	O
radiusd_signal_init	(*((int)->(void)))->(void)
(	O
RETSIGTYPE	void
(	O
*	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
(	O
int	O
sig	int
)	O
)	O
{	O
static	O
int	O
signum	array(int)
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGUSR1	int
,	O
SIGUSR2	int
,	O
SIGCHLD	int
,	O
SIGTERM	int
,	O
SIGQUIT	int
,	O
SIGPIPE	int
}	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
signum	array(int)
)	O
/	O
sizeof	O
(	O
signum	array(int)
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
grad_set_signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
signum	array(int)
[	O
i	int
]	O
,	O
hp	*(struct(*((*(void),*(void))->(void)),*(void),int))
)	O
;	O
}	O
void	O
radiusd_pidfile_write	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
{	O
pid_t	int
pid	int
=	O
getpid	()->(int)
(	O
)	O
;	O
char	O
*	O
p	*(struct)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_pid_dir	*(char)
,	O
name	*(char)
)	O
;	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%lu\n"	*(char)
,	O
(	O
u_long	long
)	O
pid	int
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
}	O
pid_t	int
radiusd_pidfile_read	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
unsigned	O
long	O
val	array(int)
;	O
char	O
*	O
p	*(struct)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_pid_dir	*(char)
,	O
name	*(char)
)	O
;	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%lu"	*(char)
,	O
&	O
val	array(int)
)	O
!=	O
1	int
)	O
val	array(int)
=	O
-	O
1	int
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
return	O
(	O
pid_t	int
)	O
val	array(int)
;	O
}	O
void	O
radiusd_pidfile_remove	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
p	*(struct)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_pid_dir	*(char)
,	O
name	*(char)
)	O
;	O
unlink	(*(char))->(int)
(	O
p	*(struct)
)	O
;	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
}	O
static	O
u_char	char
recv_buffer	array(char)
[	O
RAD_BUFFER_SIZE	int
]	O
;	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
{	O
int	O
type	enum(int,int,int,int)
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
addr	int
;	O
}	O
;	O
int	O
udp_input_handler	(int,*(void))->(int)
(	O
int	O
fd	int
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
sockaddr	struct(short,array(char))
sa	struct(short,array(char))
;	O
socklen_t	int
salen	int
=	O
sizeof	O
(	O
sa	struct(short,array(char))
)	O
;	O
int	O
size	int
;	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
*	O
sd	int
=	O
data	*(void)
;	O
size	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
recv_buffer	array(char)
,	O
sizeof	O
(	O
recv_buffer	array(char)
)	O
,	O
0	int
,	O
&	O
sa	struct(short,array(char))
,	O
&	O
salen	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
request_fail	(int,*(struct(short,short,struct(int),array(char))))->(void)
(	O
sd	int
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
&	O
sa	struct(short,array(char))
)	O
;	O
else	O
{	O
REQUEST	struct
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
request_create	(int,int,*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(char),long)->(*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))))
(	O
sd	int
->	O
type	enum(int,int,int,int)
,	O
fd	int
,	O
&	O
sd	int
->	O
addr	int
,	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
&	O
sa	struct(short,array(char))
,	O
recv_buffer	array(char)
,	O
size	int
)	O
;	O
if	O
(	O
request_handle	(*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))),*((*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))->(int)))->(int)
(	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
spawn_flag	int
?	O
rpp_forward_request	(*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))))->(int)
:	O
request_respond	(*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))))->(int)
)	O
)	O
request_free	(*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct(int),array(char)),struct(short,short,struct(int),array(char)),*(struct(int,int,long,int,int,*`,*`,long,int,struct`,struct`,*`)))))->(void)
(	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
udp_input_close	(int,*(void))->(int)
(	O
int	O
fd	int
,	O
void	O
*	O
data	*(void)
)	O
{	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
grad_free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
udp_input_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
const	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
const	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
*	O
sda	*(struct(int,struct(short,short,struct(int),array(char))))
=	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
const	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
*	O
sdb	*(struct(int,struct(short,short,struct(int),array(char))))
=	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
sda	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_port	short
!=	O
sdb	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_port	short
)	O
return	O
1	int
;	O
if	O
(	O
sda	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_addr	struct(int)
.	O
s_addr	int
==	O
INADDR_ANY	O
||	O
sdb	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_addr	struct(int)
.	O
s_addr	int
==	O
INADDR_ANY	O
)	O
return	O
0	int
;	O
return	O
sda	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_addr	struct(int)
.	O
s_addr	int
!=	O
sdb	*(struct(int,struct(short,short,struct(int),array(char))))
->	O
addr	int
.	O
sin_addr	struct(int)
.	O
s_addr	int
;	O
}	O
int	O
udp_open	(int,int,int,int)->(int)
(	O
int	O
type	enum(int,int,int,int)
,	O
grad_uint32_t	int
ipaddr	int
,	O
int	O
port	array(int)
,	O
int	O
nonblock	int
)	O
{	O
int	O
fd	int
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
s	*(*(char))
;	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
*	O
p	*(struct)
;	O
s	*(*(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
s	*(*(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
htonl	(int)->(int)
(	O
ipaddr	int
)	O
;	O
s	*(*(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	array(int)
)	O
;	O
if	O
(	O
p	*(struct)
=	O
input_find_channel	(*(struct),*(char),*(void))->(*(void))
(	O
radius_input	*(struct)
,	O
"udp"	*(char)
,	O
&	O
s	*(*(char))
)	O
)	O
{	O
char	O
buffer	*(char)
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"socket %s:%d is already assigned for %s"	*(char)
)	O
,	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
ipaddr	int
,	O
buffer	*(char)
)	O
,	O
port	array(int)
,	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
p	*(struct)
->	O
type	enum(int,int,int,int)
]	O
.	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
nonblock	int
)	O
grad_set_nonblocking	(int)->(int)
(	O
fd	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"%s socket"	*(char)
,	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
type	enum(int,int,int,int)
]	O
.	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
s	*(*(char))
,	O
sizeof	O
(	O
s	*(*(char))
)	O
)	O
<	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"%s bind"	*(char)
,	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
type	enum(int,int,int,int)
]	O
.	O
name	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
1	int
;	O
}	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(struct)
)	O
)	O
;	O
p	*(struct)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
p	*(struct)
->	O
addr	int
=	O
s	*(*(char))
;	O
input_register_channel	(*(struct),*(char),int,*(void))->(int)
(	O
radius_input	*(struct)
,	O
"udp"	*(char)
,	O
fd	int
,	O
p	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_counter	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
udp_data	struct(int,struct(short,short,struct(int),array(char)))
*	O
p	*(struct)
=	O
item	*(void)
;	O
if	O
(	O
p	*(struct)
->	O
type	enum(int,int,int,int)
==	O
R_AUTH	int
||	O
p	*(struct)
->	O
type	enum(int,int,int,int)
==	O
R_ACCT	int
)	O
++	O
*	O
(	O
size_t	long
*	O
)	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
radius_count_channels	()->(long)
(	O
)	O
{	O
size_t	long
count	int
=	O
0	int
;	O
input_iterate_channels	(*(struct),*(char),*((*(void),*(void))->(int)),*(void))->(void)
(	O
radius_input	*(struct)
,	O
"udp"	*(char)
,	O
channel_counter	(*(void),*(void))->(int)
,	O
&	O
count	int
)	O
;	O
return	O
count	int
;	O
}	O
static	O
int	O
_opened_auth_sockets	int
;	O
static	O
int	O
_opened_acct_sockets	int
;	O
static	O
int	O
rad_cfg_listen_auth	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
i	int
,	O
errcnt	long
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_BOOLEAN	int
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
bool	int
==	O
0	int
)	O
auth_port	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_NETWORK	int
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
network	struct(int,int)
.	O
netmask	int
!=	O
0xffffffffL	int
)	O
cfg_type_error	(int)->(void)
(	O
CFG_HOST	int
)	O
;	O
}	O
else	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
CFG_HOST	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_HOST	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
&&	O
radius_mode	int
==	O
MODE_DAEMON	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
;	O
int	O
port	array(int)
;	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_NETWORK	int
)	O
{	O
ip	*(struct)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
network	struct(int,int)
.	O
ipaddr	int
;	O
port	array(int)
=	O
auth_port	int
;	O
}	O
else	O
{	O
ip	*(struct)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
host	int
.	O
ipaddr	int
;	O
port	array(int)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
host	int
.	O
port	array(int)
;	O
}	O
if	O
(	O
udp_open	(int,int,int,int)->(int)
(	O
R_AUTH	int
,	O
ip	*(struct)
,	O
port	array(int)
,	O
0	int
)	O
)	O
errcnt	long
++	O
;	O
}	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
)	O
_opened_auth_sockets	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
auth_stmt_begin	(int,*(void),*(void))->(int)
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
_opened_auth_sockets	int
=	O
0	int
;	O
else	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
!	O
_opened_auth_sockets	int
&&	O
auth_port	int
)	O
udp_open	(int,int,int,int)->(int)
(	O
R_AUTH	int
,	O
INADDR_ANY	O
,	O
auth_port	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rad_cfg_listen_acct	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
i	int
,	O
errcnt	long
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_BOOLEAN	int
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
bool	int
==	O
0	int
)	O
acct_port	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_NETWORK	int
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
network	struct(int,int)
.	O
netmask	int
!=	O
0xffffffffL	int
)	O
cfg_type_error	(int)->(void)
(	O
CFG_HOST	int
)	O
;	O
}	O
else	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
CFG_HOST	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_HOST	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
&&	O
radius_mode	int
==	O
MODE_DAEMON	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
;	O
int	O
port	array(int)
;	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
CFG_NETWORK	int
)	O
{	O
ip	*(struct)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
network	struct(int,int)
.	O
ipaddr	int
;	O
port	array(int)
=	O
acct_port	int
;	O
}	O
else	O
{	O
ip	*(struct)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
host	int
.	O
ipaddr	int
;	O
port	array(int)
=	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
host	int
.	O
port	array(int)
;	O
}	O
if	O
(	O
udp_open	(int,int,int,int)->(int)
(	O
R_ACCT	int
,	O
ip	*(struct)
,	O
port	array(int)
,	O
0	int
)	O
)	O
errcnt	long
++	O
;	O
}	O
}	O
_opened_acct_sockets	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
acct_stmt_begin	(int,*(void),*(void))->(int)
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
_opened_acct_sockets	int
=	O
0	int
;	O
else	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
!	O
_opened_acct_sockets	int
&&	O
acct_port	int
)	O
udp_open	(int,int,int,int)->(int)
(	O
R_ACCT	int
,	O
INADDR_ANY	O
,	O
acct_port	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rad_cfg_user	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
RADIUS_USER	struct(*(char),int,int)
*	O
usr	*(struct(*(char),int,int))
=	O
handler_data	*(void)
;	O
if	O
(	O
argc	int
!=	O
2	int
||	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
CFG_STRING	int
)	O
return	O
1	int
;	O
return	O
radius_get_user_ids	(*(struct(*(char),int,int)),*(char))->(int)
(	O
(	O
RADIUS_USER	struct(*(char),int,int)
*	O
)	O
handler_data	*(void)
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
;	O
}	O
int	O
option_stmt_end	(*(void),*(void))->(int)
(	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
exec_user	struct(*(char),int,int)
.	O
username	*(char)
&&	O
radiusd_user	struct(*(char),int,int)
.	O
uid	int
!=	O
0	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
_	O
(	O
"Ignoring exec-program-user"	*(char)
)	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
exec_user	struct(*(char),int,int)
.	O
username	*(char)
)	O
;	O
exec_user	struct(*(char),int,int)
.	O
username	*(char)
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
exec_user	struct(*(char),int,int)
.	O
username	*(char)
==	O
NULL	O
)	O
radius_get_user_ids	(*(struct(*(char),int,int)),*(char))->(int)
(	O
&	O
exec_user	struct(*(char),int,int)
,	O
"daemon"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
option_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"source-ip"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_ipaddr	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
myip	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-threads"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
max_children	long
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-processes"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
max_children	long
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"process-idle-timeout"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
process_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"master-read-timeout"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
radiusd_read_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"master-write-timeout"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
radiusd_write_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"exec-program-user"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_user	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
exec_user	struct(*(char),int,int)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"radiusd-user"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_user	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
radiusd_user	struct(*(char),int,int)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"log-dir"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
grad_log_dir	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"acct-dir"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
grad_acct_dir	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"resolve"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
grad_resolve_hostnames	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"username-chars"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
username_valid_chars	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"usr2delay"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
message_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"account-closed"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_ACCOUNT_CLOSED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expired"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_PASSWORD_EXPIRED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"access-denied"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_ACCESS_DENIED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"realm-quota"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_REALM_QUOTA	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"multiple-login"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_MULTIPLE_LOGIN	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"second-login"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_SECOND_LOGIN	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"timespan-violation"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_TIMESPAN_VIOLATION	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expire-warning"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
message_text	array(*(char))
[	O
MSG_PASSWORD_EXPIRE_WARNING	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
auth_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"port"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_port	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_port	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"listen"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_listen_auth	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"forward"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_forward_auth	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_AUTH	int
]	O
.	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"time-to-live"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_AUTH	int
]	O
.	O
ttl	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_AUTH	int
]	O
.	O
cleanup_delay	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_detail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail-file-name"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_detail_template	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"strip-names"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
strip_names	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"checkrad-assume-logged"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
checkrad_assume_logged	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"reject-malformed-names"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_reject_malformed_names	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expire-warning"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_uint32_t	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
warning_seconds	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"compare-attribute-flag"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_comp_flag	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"trace-rules"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
auth_trace_rules	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"spawn"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
acct_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"port"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_port	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_port	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"listen"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_listen_acct	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"forward"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_forward_acct	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_ACCT	int
]	O
.	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"time-to-live"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_ACCT	int
]	O
.	O
ttl	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
request_class	struct(*(char),int,int,int,*((*(struct(short,short,struct(int),array(char))),*(struct(short,short,struct(int),array(char))),*(void),long,*(*(void)))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(int)),*((*(struct(int,int,long,int,int,*(void),*(void),long,int,struct(short,short,struct`,array(char)),struct(short,short,struct`,array(char)),*(struct`))))->(void)),*((*(void),*(void))->(int)),*((*(void))->(void)),*((int,*(void),*(void),int,*(char))->(void)),*((int,*(void))->(void)),*((int,*(struct(short,short,struct(int),array(char))))->(int)),*((*(void),*(void))->(void)))
[	O
R_ACCT	int
]	O
.	O
cleanup_delay	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_detail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail-file-name"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_detail_template	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"system"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_system	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"compare-attribute-flag"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_comp_flag	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"trace-rules"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
acct_trace_rules	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"spawn"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
proxy_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"max-requests"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
config_syntax	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"option"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
option_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
option_stmt_end	(*(void),*(void))->(int)
}	O
,	O
{	O
"message"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
message_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"logging"	*(char)
,	O
CS_BLOCK	int
,	O
logging_stmt_begin	(int,*(void),*(void))->(int)
,	O
logging_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
logging_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
logging_stmt_end	(*(void),*(void))->(int)
}	O
,	O
{	O
"auth"	*(char)
,	O
CS_BLOCK	int
,	O
auth_stmt_begin	(int,*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
auth_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"acct"	*(char)
,	O
CS_BLOCK	int
,	O
acct_stmt_begin	(int,*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
acct_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"mlc"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
mlc_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"proxy"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
proxy_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"rewrite"	*(char)
,	O
CS_BLOCK	int
,	O
rewrite_stmt_term	(int,*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
rewrite_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"filters"	*(char)
,	O
CS_BLOCK	int
,	O
filters_stmt_term	(int,*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
filters_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
"loadable-modules"	*(char)
,	O
CS_BLOCK	int
,	O
dynload_stmt_term	(int,*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
dynload_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
,	O
}	O
;	O
