void	O
zero_divisor	()->(void)
(	O
void	O
)	O
;	O
object	O
fixnum_add	(int,int)->(int)
(	O
fixnum	O
i	int
,	O
fixnum	O
j	int
)	O
{	O
if	O
(	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
j	int
<=	O
(	O
MOST_POSITIVE_FIX	O
-	O
i	int
)	O
)	O
{	O
return	O
make_fixnum	()->(int)
(	O
i	int
+	O
j	int
)	O
;	O
}	O
MPOP	()->(int)
(	O
return	O
,	O
addss	O
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
MOST_NEGATIVE_FIX	O
-	O
i	int
)	O
<=	O
j	int
)	O
{	O
return	O
make_fixnum	()->(int)
(	O
i	int
+	O
j	int
)	O
;	O
}	O
MPOP	()->(int)
(	O
return	O
,	O
addss	O
,	O
i	int
,	O
j	int
)	O
;	O
}	O
}	O
object	O
fixnum_sub	(int,int)->(int)
(	O
fixnum	O
i	int
,	O
fixnum	O
j	int
)	O
{	O
if	O
(	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
j	int
>=	O
(	O
i	int
-	O
MOST_POSITIVE_FIX	O
)	O
)	O
{	O
return	O
make_fixnum	()->(int)
(	O
i	int
-	O
j	int
)	O
;	O
}	O
MPOP	()->(int)
(	O
return	O
,	O
subss	O
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
MOST_NEGATIVE_FIX	O
-	O
i	int
)	O
<=	O
-	O
j	int
)	O
{	O
return	O
make_fixnum	()->(int)
(	O
i	int
-	O
j	int
)	O
;	O
}	O
MPOP	()->(int)
(	O
return	O
,	O
subss	O
,	O
i	int
,	O
j	int
)	O
;	O
}	O
}	O
inline	O
object	O
fixnum_times	(int,int)->(int)
(	O
fixnum	O
i	int
,	O
fixnum	O
j	int
)	O
{	O
if	O
(	O
i	int
>=	O
0	int
?	O
(	O
j	int
>=	O
0	int
?	O
(	O
!	O
i	int
||	O
j	int
<=	O
(	O
MOST_POSITIVE_FIX	O
/	O
i	int
)	O
)	O
:	O
(	O
j	int
==	O
-	O
1	int
||	O
i	int
<=	O
(	O
MOST_NEGATIVE_FIX	O
/	O
j	int
)	O
)	O
)	O
:	O
(	O
j	int
>=	O
0	int
?	O
(	O
i	int
==	O
-	O
1	int
||	O
j	int
<=	O
(	O
MOST_NEGATIVE_FIX	O
/	O
i	int
)	O
)	O
:	O
(	O
i	int
>	O
MOST_NEGATIVE_FIX	O
&&	O
-	O
i	int
<=	O
(	O
MOST_POSITIVE_FIX	O
/	O
-	O
j	int
)	O
)	O
)	O
)	O
return	O
make_fixnum	()->(int)
(	O
i	int
*	O
j	int
)	O
;	O
else	O
MPOP	()->(int)
(	O
return	O
,	O
mulss	O
,	O
i	int
,	O
j	int
)	O
;	O
}	O
static	O
object	O
number_to_complex	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
z	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_complex	O
)	O
;	O
z	O
->	O
cmp	O
.	O
cmp_real	O
=	O
x	int
;	O
z	O
->	O
cmp	O
.	O
cmp_imag	O
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
return	O
(	O
x	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_plus	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
double	O
dx	double
,	O
dy	double
;	O
object	O
z	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
fixnum_add	(int,int)->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
addsi	O
,	O
fix	()->(int)
(	O
x	int
)	O
,	O
MP	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_plus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
return	O
make_ratio	()->(int)
(	O
z	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_bignum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
addsi	O
,	O
fix	()->(int)
(	O
y	int
)	O
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
addii	O
,	O
MP	()->(int)
(	O
y	int
)	O
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_plus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
return	O
make_ratio	()->(int)
(	O
z	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
z	O
=	O
number_plus	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
)	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_plus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
}	O
SHORTFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
+	O
dy	double
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
}	O
LONGFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
+	O
dy	double
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
COMPLEX	O
:	O
x	int
=	O
number_to_complex	(int)->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_to_complex	(int)->(int)
(	O
y	int
)	O
;	O
z	O
=	O
make_complex	()->(int)
(	O
number_plus	(int,int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
,	O
number_plus	(int,int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
one_plus	(int)->(int)
(	O
object	O
x	int
)	O
{	O
double	O
dx	double
;	O
object	O
z	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
fixnum_add	(int,int)->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
1	int
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
addsi	O
,	O
1	int
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_plus	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
+	O
1.0	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
+	O
1.0	int
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
z	O
=	O
make_complex	()->(int)
(	O
one_plus	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
,	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_minus	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
double	O
dx	double
,	O
dy	double
;	O
object	O
z	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
fixnum_sub	(int,int)->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
subsi	O
,	O
fix	()->(int)
(	O
x	int
)	O
,	O
MP	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_minus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_bignum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
subis	O
,	O
MP	()->(int)
(	O
x	int
)	O
,	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
subii	O
,	O
MP	()->(int)
(	O
x	int
)	O
,	O
MP	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_minus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
z	O
=	O
number_minus	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
)	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_minus	(int,int)->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
}	O
SHORTFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
-	O
dy	double
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
}	O
LONGFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
-	O
dy	double
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
COMPLEX	O
:	O
x	int
=	O
number_to_complex	(int)->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_to_complex	(int)->(int)
(	O
y	int
)	O
;	O
z	O
=	O
make_complex	()->(int)
(	O
number_minus	(int,int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
,	O
number_minus	(int,int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
one_minus	(int)->(int)
(	O
object	O
x	int
)	O
{	O
double	O
dx	double
;	O
object	O
z	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
fixnum_sub	(int,int)->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
1	int
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
addsi	O
,	O
-	O
1	int
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
number_minus	(int,int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
z	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
-	O
1.0	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
-	O
1.0	int
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
z	O
=	O
make_complex	()->(int)
(	O
one_minus	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
,	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_negate	(int)->(int)
(	O
object	O
x	int
)	O
{	O
object	O
z	O
,	O
z1	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	()->(int)
(	O
x	int
)	O
==	O
MOST_NEGATIVE_FIX	O
)	O
return	O
fixnum_add	(int,int)->(int)
(	O
1	int
,	O
MOST_POSITIVE_FIX	O
)	O
;	O
else	O
return	O
(	O
make_fixnum	()->(int)
(	O
-	O
fix	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
case	O
t_bignum	O
:	O
return	O
big_minus	()->(int)
(	O
x	int
)	O
;	O
case	O
t_ratio	O
:	O
z1	O
=	O
number_negate	(int)->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
z	O
=	O
alloc_object	()->(int)
(	O
t_ratio	O
)	O
;	O
z	O
->	O
rat	O
.	O
rat_num	O
=	O
z1	O
;	O
z	O
->	O
rat	O
.	O
rat_den	O
=	O
x	int
->	O
rat	O
.	O
rat_den	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
-	O
sf	()->(int)
(	O
x	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
-	O
lf	()->(int)
(	O
x	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
z	O
=	O
make_complex	()->(int)
(	O
number_negate	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
,	O
number_negate	(int)->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_times	()->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
object	O
z	O
;	O
double	O
dx	double
,	O
dy	double
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
fixnum_times	(int,int)->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
mulsi	O
,	O
fix	()->(int)
(	O
x	int
)	O
,	O
MP	()->(int)
(	O
y	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_bignum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
mulsi	O
,	O
fix	()->(int)
(	O
y	int
)	O
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_bignum	O
:	O
MPOP	()->(int)
(	O
return	O
,	O
mulii	O
,	O
MP	()->(int)
(	O
y	int
)	O
,	O
MP	()->(int)
(	O
x	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
)	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
break	O
;	O
}	O
SHORTFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
*	O
dy	double
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
}	O
LONGFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
*	O
dy	double
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
COMPLEX	O
:	O
{	O
object	O
z1	O
,	O
z2	O
,	O
z11	O
,	O
z12	O
,	O
z21	O
,	O
z22	O
;	O
x	int
=	O
number_to_complex	(int)->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_to_complex	(int)->(int)
(	O
y	int
)	O
;	O
z11	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
z12	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
z21	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
z22	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
z1	O
=	O
number_minus	(int,int)->(int)
(	O
z11	O
,	O
z12	O
)	O
;	O
z2	O
=	O
number_plus	(int,int)->(int)
(	O
z21	O
,	O
z22	O
)	O
;	O
z	O
=	O
make_complex	()->(int)
(	O
z1	O
,	O
z2	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
number_divide	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
object	O
z	O
;	O
double	O
dx	double
,	O
dy	double
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
if	O
(	O
number_zerop	()->(int)
(	O
y	int
)	O
==	O
TRUE	O
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
if	O
(	O
number_minusp	()->(int)
(	O
y	int
)	O
==	O
TRUE	O
)	O
{	O
x	int
=	O
number_negate	(int)->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_negate	(int)->(int)
(	O
y	int
)	O
;	O
}	O
z	O
=	O
make_ratio	()->(int)
(	O
x	int
,	O
y	int
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_ratio	O
:	O
if	O
(	O
number_zerop	()->(int)
(	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
if	O
(	O
number_zerop	()->(int)
(	O
y	int
)	O
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
z	O
=	O
make_ratio	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_ratio	O
:	O
z	O
=	O
make_ratio	()->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
SHORTFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
}	O
SHORTFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_shortfloat	O
)	O
;	O
if	O
(	O
dy	double
==	O
0.0	int
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
sf	()->(int)
(	O
z	O
)	O
=	O
(	O
shortfloat	O
)	O
(	O
dx	double
/	O
dy	double
)	O
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dy	double
=	O
lf	()->(int)
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
COMPLEX	O
;	O
default	O
:	O
dy	double
=	O
number_to_double	()->(int)
(	O
y	int
)	O
;	O
}	O
LONGFLOAT	O
:	O
z	O
=	O
alloc_object	()->(int)
(	O
t_longfloat	O
)	O
;	O
if	O
(	O
dy	double
==	O
0.0	int
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
lf	()->(int)
(	O
z	O
)	O
=	O
dx	double
/	O
dy	double
;	O
return	O
(	O
z	O
)	O
;	O
case	O
t_complex	O
:	O
COMPLEX	O
:	O
{	O
object	O
z1	O
,	O
z2	O
,	O
z3	O
;	O
x	int
=	O
number_to_complex	(int)->(int)
(	O
x	int
)	O
;	O
y	int
=	O
number_to_complex	(int)->(int)
(	O
y	int
)	O
;	O
z1	O
=	O
number_times	()->(int)
(	O
y	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
z2	O
=	O
number_times	()->(int)
(	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
z3	O
=	O
number_plus	(int,int)->(int)
(	O
z1	O
,	O
z2	O
)	O
)	O
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
z1	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
z2	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
z1	O
=	O
number_plus	(int,int)->(int)
(	O
z1	O
,	O
z2	O
)	O
;	O
z	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
;	O
z2	O
=	O
number_times	()->(int)
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
z2	O
=	O
number_minus	(int,int)->(int)
(	O
z	O
,	O
z2	O
)	O
;	O
z1	O
=	O
number_divide	(int,int)->(int)
(	O
z1	O
,	O
z3	O
)	O
;	O
z2	O
=	O
number_divide	(int,int)->(int)
(	O
z2	O
,	O
z3	O
)	O
;	O
z	O
=	O
make_complex	()->(int)
(	O
z1	O
,	O
z2	O
)	O
;	O
return	O
(	O
z	O
)	O
;	O
}	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
object	O
integer_divide1	(int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
fixnum	O
d	int
)	O
{	O
object	O
q	O
;	O
integer_quotient_remainder_1	()->(int)
(	O
x	int
,	O
y	int
,	O
&	O
q	O
,	O
NULL	O
,	O
d	int
)	O
;	O
return	O
(	O
q	O
)	O
;	O
}	O
object	O
integer_divide2	(int,int,int,*(int))->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
fixnum	O
d	int
,	O
object	O
*	O
r	*(int)
)	O
{	O
object	O
q	O
;	O
integer_quotient_remainder_1	()->(int)
(	O
x	int
,	O
y	int
,	O
&	O
q	O
,	O
r	*(int)
,	O
d	int
)	O
;	O
return	O
(	O
q	O
)	O
;	O
}	O
object	O
get_gcd_abs	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
object	O
r	*(int)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_fixnum	O
&&	O
type_of	()->(int)
(	O
y	int
)	O
==	O
t_fixnum	O
)	O
return	O
make_fixnum	()->(int)
(	O
fixnum_gcd	()->(int)
(	O
fix	()->(int)
(	O
x	int
)	O
,	O
fix	()->(int)
(	O
y	int
)	O
)	O
)	O
;	O
if	O
(	O
number_compare	()->(int)
(	O
x	int
,	O
y	int
)	O
<	O
0	int
)	O
{	O
r	*(int)
=	O
x	int
;	O
x	int
=	O
y	int
;	O
y	int
=	O
r	*(int)
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
y	int
)	O
==	O
t_fixnum	O
&&	O
fix	()->(int)
(	O
y	int
)	O
==	O
0	int
)	O
return	O
(	O
x	int
)	O
;	O
integer_quotient_remainder_1	()->(int)
(	O
x	int
,	O
y	int
,	O
NULL	O
,	O
&	O
r	*(int)
,	O
0	int
)	O
;	O
x	int
=	O
y	int
;	O
y	int
=	O
r	*(int)
;	O
}	O
}	O
object	O
get_gcd	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
get_gcd_abs	(int,int)->(int)
(	O
number_abs	()->(int)
(	O
x	int
)	O
,	O
number_abs	()->(int)
(	O
y	int
)	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lplus	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
j	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
{	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
number_plus	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Lminus	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
j	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
if	O
(	O
j	int
==	O
1	int
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
number_negate	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
number_minus	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Ltimes	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
j	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
{	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
1	int
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
number_times	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Ldivide	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
j	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
if	O
(	O
j	int
==	O
1	int
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
number_divide	(int,int)->(int)
(	O
small_fixnum	()->(int)
(	O
1	int
)	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
number_divide	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Lone_plus	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_plus	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lone_minus	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_minus	(int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lconjugate	int
)	O
(	O
void	O
)	O
{	O
object	O
c	O
,	O
i	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
c	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
c	O
)	O
==	O
t_complex	O
)	O
{	O
i	int
=	O
number_negate	(int)->(int)
(	O
c	O
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
vs_push	()->(int)
(	O
i	int
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
make_complex	()->(int)
(	O
c	O
->	O
cmp	O
.	O
cmp_real	O
,	O
i	int
)	O
;	O
vs_popp	O
;	O
}	O
}	O
LFD	(int)->(int)
(	O
Lgcd	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
narg	O
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	O
==	O
0	int
)	O
{	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	O
;	O
i	int
++	O
)	O
check_type_integer	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
number_abs	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
narg	O
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
get_gcd_abs	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
number_abs	()->(int)
(	O
vs_base	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
object	O
get_lcm_abs	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
object	O
g	O
=	O
get_gcd_abs	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
;	O
return	O
number_zerop	()->(int)
(	O
g	O
)	O
?	O
g	O
:	O
number_times	()->(int)
(	O
x	int
,	O
integer_divide1	(int,int,int)->(int)
(	O
y	int
,	O
g	O
,	O
0	int
)	O
)	O
;	O
}	O
object	O
get_lcm	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
get_lcm_abs	(int,int)->(int)
(	O
number_abs	()->(int)
(	O
x	int
)	O
,	O
number_abs	()->(int)
(	O
y	int
)	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Llcm	int
)	O
(	O
void	O
)	O
{	O
fixnum	O
i	int
,	O
narg	O
;	O
narg	O
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	O
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	O
;	O
i	int
++	O
)	O
check_type_integer	()->(int)
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
number_abs	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
narg	O
&&	O
!	O
number_zerop	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
get_lcm_abs	(int,int)->(int)
(	O
vs_base	O
[	O
0	int
]	O
,	O
number_abs	()->(int)
(	O
vs_base	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
void	O
zero_divisor	()->(void)
(	O
void	O
)	O
{	O
FEerror	()->(int)
(	O
"Zero divisor."	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
gcl_init_num_arith	()->(void)
(	O
void	O
)	O
{	O
make_function	()->(int)
(	O
"+"	*(char)
,	O
Lplus	int
)	O
;	O
make_function	()->(int)
(	O
"-"	*(char)
,	O
Lminus	int
)	O
;	O
make_function	()->(int)
(	O
"*"	*(char)
,	O
Ltimes	int
)	O
;	O
make_function	()->(int)
(	O
"/"	*(char)
,	O
Ldivide	int
)	O
;	O
make_function	()->(int)
(	O
"1+"	*(char)
,	O
Lone_plus	int
)	O
;	O
make_function	()->(int)
(	O
"1-"	*(char)
,	O
Lone_minus	int
)	O
;	O
make_function	()->(int)
(	O
"CONJUGATE"	*(char)
,	O
Lconjugate	int
)	O
;	O
make_function	()->(int)
(	O
"GCD"	*(char)
,	O
Lgcd	int
)	O
;	O
make_function	()->(int)
(	O
"LCM"	*(char)
,	O
Llcm	int
)	O
;	O
}	O
