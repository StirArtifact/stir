RCSTAG_CC	O
(	O
"$Id$"	*(char)
)	O
;	O
char	O
*	O
in_prog_pos	*(char)
=	O
NULL	O
;	O
char	O
*	O
buf_ptr	*(char)
=	O
NULL	O
;	O
char	O
*	O
buf_end	*(char)
=	O
NULL	O
;	O
BOOLEAN	char
had_eof	char
=	O
false	int
;	O
char	O
*	O
cur_line	*(char)
=	O
NULL	O
;	O
extern	O
char	O
*	O
skip_horiz_space	(*(char))->(*(char))
(	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
while	O
(	O
(	O
*	O
p	*(char)
==	O
' '	O
)	O
||	O
(	O
*	O
p	*(char)
==	O
TAB	char
)	O
)	O
{	O
p	*(char)
++	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
p	*(char)
;	O
}	O
extern	O
void	O
skip_buffered_space	()->(void)
(	O
void	O
)	O
{	O
while	O
(	O
(	O
*	O
buf_ptr	*(char)
==	O
' '	O
)	O
||	O
(	O
*	O
buf_ptr	*(char)
==	O
TAB	char
)	O
)	O
{	O
buf_ptr	*(char)
++	O
;	O
if	O
(	O
buf_ptr	*(char)
>=	O
buf_end	*(char)
)	O
{	O
fill_buffer	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
static	O
BOOLEAN	char
is_comment_start	(*(char))->(char)
(	O
const	O
char	O
*	O
p	*(char)
)	O
{	O
BOOLEAN	char
ret	char
;	O
if	O
(	O
(	O
*	O
p	*(char)
==	O
'/'	O
)	O
&&	O
(	O
(	O
*	O
(	O
p	*(char)
+	O
1	int
)	O
==	O
'*'	O
)	O
||	O
(	O
*	O
(	O
p	*(char)
+	O
1	int
)	O
==	O
'/'	O
)	O
)	O
)	O
{	O
ret	char
=	O
true	int
;	O
}	O
else	O
{	O
ret	char
=	O
false	int
;	O
}	O
return	O
ret	char
;	O
}	O
extern	O
int	O
current_column	()->(int)
(	O
void	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
int	O
column	int
;	O
if	O
(	O
(	O
buf_ptr	*(char)
>=	O
save_com	struct(*(char),*(char),int,int,int,int)
.	O
ptr	*(char)
)	O
&&	O
(	O
buf_ptr	*(char)
<=	O
save_com	struct(*(char),*(char),int,int,int,int)
.	O
ptr	*(char)
+	O
save_com	struct(*(char),*(char),int,int,int,int)
.	O
len	int
)	O
)	O
{	O
p	*(char)
=	O
save_com	struct(*(char),*(char),int,int,int,int)
.	O
ptr	*(char)
;	O
column	int
=	O
save_com	struct(*(char),*(char),int,int,int,int)
.	O
start_column	int
;	O
}	O
else	O
{	O
p	*(char)
=	O
cur_line	*(char)
;	O
column	int
=	O
1	int
;	O
}	O
while	O
(	O
p	*(char)
<	O
buf_ptr	*(char)
)	O
{	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
EOL	char
:	O
case	O
014	int
:	O
column	int
=	O
1	int
;	O
break	O
;	O
case	O
TAB	char
:	O
column	int
+=	O
settings	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
tabsize	int
-	O
(	O
column	int
-	O
1	int
)	O
%	O
settings	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
tabsize	int
;	O
break	O
;	O
case	O
'\b'	O
:	O
column	int
--	O
;	O
break	O
;	O
default	O
:	O
column	int
++	O
;	O
break	O
;	O
}	O
p	*(char)
++	O
;	O
}	O
return	O
column	int
;	O
}	O
extern	O
file_buffer_ty	struct(*(char),long,*(char))
*	O
read_file	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(char),long,*(char))))
(	O
char	O
*	O
filename	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
static	O
file_buffer_ty	struct(*(char),long,*(char))
fileptr	struct(*(char),long,*(char))
=	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
;	O
ssize_t	long
size	long
=	O
0	int
;	O
size_t	long
size_to_read	long
=	O
0	int
;	O
unsigned	O
int	O
namelen	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
int	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_RDONLY	int
,	O
0777	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"Can't open input file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
<	O
0	int
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"Can't stat input file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
if	O
(	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
==	O
0	int
)	O
{	O
ERROR	O
(	O
_	O
(	O
"Zero-length file %s"	*(char)
)	O
,	O
filename	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
sizeof	O
(	O
int	O
)	O
==	O
2	int
)	O
{	O
if	O
(	O
(	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
<	O
0	int
)	O
||	O
(	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
>	O
(	O
0xffff	int
-	O
1	int
)	O
)	O
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"File %s is too big to read"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
<	O
0	int
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"System problem reading file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
(	O
size_t	long
)	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
>=	O
SSIZE_MAX	O
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"File %s is too big to read"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
=	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
;	O
if	O
(	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
!=	O
0	int
)	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
=	O
xrealloc	(*(void),int)->(*(void))
(	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
,	O
(	O
unsigned	O
)	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
+	O
2	int
)	O
;	O
}	O
else	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
=	O
xmalloc	(int)->(*(void))
(	O
(	O
unsigned	O
)	O
file_stats	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
+	O
2	int
)	O
;	O
}	O
size_to_read	long
=	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
;	O
while	O
(	O
size_to_read	long
>	O
0	int
)	O
{	O
size	long
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
+	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
-	O
size_to_read	long
,	O
size_to_read	long
)	O
;	O
if	O
(	O
size	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
continue	O
;	O
}	O
xfree	(*(void))->(void)
(	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
)	O
;	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"Error reading input file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
size_to_read	long
-=	O
size	long
;	O
}	O
if	O
(	O
close	*((*(void))->(int))
(	O
fd	int
)	O
<	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
)	O
;	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"Error closing input file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
size	long
<	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
)	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
=	O
size	long
;	O
}	O
if	O
(	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
!=	O
NULL	O
)	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
=	O
xrealloc	(*(void),int)->(*(void))
(	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
,	O
(	O
unsigned	O
)	O
namelen	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
=	O
xmalloc	(int)->(*(void))
(	O
namelen	int
+	O
1	int
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
,	O
filename	*(char)
,	O
namelen	int
)	O
;	O
fileptr	struct(*(char),long,*(char))
.	O
name	*(char)
[	O
namelen	int
]	O
=	O
EOS	char
;	O
if	O
(	O
(	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
>	O
0	int
)	O
&&	O
(	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
[	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
-	O
1	int
]	O
!=	O
EOL	char
)	O
)	O
{	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
[	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
]	O
=	O
EOL	char
;	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
++	O
;	O
}	O
fileptr	struct(*(char),long,*(char))
.	O
data	*(char)
[	O
fileptr	struct(*(char),long,*(char))
.	O
size	long
]	O
=	O
EOS	char
;	O
return	O
&	O
fileptr	struct(*(char),long,*(char))
;	O
}	O
file_buffer_ty	struct(*(char),long,*(char))
*	O
read_stdin	()->(*(struct(*(char),long,*(char))))
(	O
void	O
)	O
{	O
static	O
file_buffer_ty	struct(*(char),long,*(char))
stdinptr	struct(*(char),long,*(char))
=	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
;	O
unsigned	O
int	O
size	long
=	O
15	int
*	O
BUFSIZ	int
;	O
int	O
ch	int
=	O
EOF	O
;	O
char	O
*	O
p	*(char)
=	O
NULL	O
;	O
if	O
(	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
!=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
)	O
;	O
}	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
=	O
xmalloc	(int)->(*(void))
(	O
size	long
+	O
1	int
)	O
;	O
stdinptr	struct(*(char),long,*(char))
.	O
size	long
=	O
0	int
;	O
p	*(char)
=	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
;	O
do	O
{	O
while	O
(	O
stdinptr	struct(*(char),long,*(char))
.	O
size	long
<	O
size	long
)	O
{	O
ch	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
break	O
;	O
}	O
*	O
p	*(char)
++	O
=	O
ch	int
;	O
stdinptr	struct(*(char),long,*(char))
.	O
size	long
++	O
;	O
}	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
{	O
size	long
+=	O
(	O
2	int
*	O
BUFSIZ	int
)	O
;	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
=	O
xrealloc	(*(void),int)->(*(void))
(	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
,	O
(	O
unsigned	O
)	O
size	long
)	O
;	O
p	*(char)
=	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
+	O
stdinptr	struct(*(char),long,*(char))
.	O
size	long
;	O
}	O
}	O
while	O
(	O
ch	int
!=	O
EOF	O
)	O
;	O
stdinptr	struct(*(char),long,*(char))
.	O
name	*(char)
=	O
"Standard Input"	*(char)
;	O
stdinptr	struct(*(char),long,*(char))
.	O
data	*(char)
[	O
stdinptr	struct(*(char),long,*(char))
.	O
size	long
]	O
=	O
EOS	char
;	O
return	O
&	O
stdinptr	struct(*(char),long,*(char))
;	O
}	O
void	O
fill_buffer	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
NULL	O
;	O
BOOLEAN	char
finished_a_line	char
=	O
false	int
;	O
if	O
(	O
bp_save	*(char)
!=	O
0	int
)	O
{	O
buf_ptr	*(char)
=	O
bp_save	*(char)
;	O
buf_end	*(char)
=	O
be_save	*(char)
;	O
bp_save	*(char)
=	O
be_save	*(char)
=	O
0	int
;	O
if	O
(	O
buf_ptr	*(char)
<	O
buf_end	*(char)
)	O
{	O
return	O
;	O
}	O
}	O
if	O
(	O
*	O
in_prog_pos	*(char)
==	O
EOS	char
)	O
{	O
buf_ptr	*(char)
=	O
in_prog_pos	*(char)
;	O
cur_line	*(char)
=	O
buf_ptr	*(char)
;	O
had_eof	char
=	O
true	int
;	O
}	O
else	O
{	O
cur_line	*(char)
=	O
in_prog_pos	*(char)
;	O
p	*(char)
=	O
cur_line	*(char)
;	O
finished_a_line	char
=	O
false	int
;	O
do	O
{	O
p	*(char)
=	O
skip_horiz_space	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
is_comment_start	(*(char))->(char)
(	O
p	*(char)
)	O
)	O
{	O
p	*(char)
+=	O
2	int
;	O
p	*(char)
=	O
skip_horiz_space	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(char)
,	O
"*INDENT-OFF*"	*(char)
,	O
12	int
)	O
==	O
0	int
)	O
{	O
inhibit_indenting	(char)->(void)
(	O
true	int
)	O
;	O
}	O
}	O
while	O
(	O
(	O
*	O
p	*(char)
!=	O
EOS	char
)	O
&&	O
*	O
p	*(char)
!=	O
EOL	char
)	O
{	O
p	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
p	*(char)
==	O
EOL	char
)	O
{	O
finished_a_line	char
=	O
true	int
;	O
in_prog_pos	*(char)
=	O
p	*(char)
+	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
p	*(char)
-	O
current_input	*(struct(*(char),long,*(char)))
->	O
data	*(char)
)	O
<	O
current_input	*(struct(*(char),long,*(char)))
->	O
size	long
)	O
{	O
fatal	(*(char),*(char))->(void)
(	O
_	O
(	O
"File %s contains NULL-characters: cannot proceed\n"	*(char)
)	O
,	O
current_input	*(struct(*(char),long,*(char)))
->	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
in_prog_pos	*(char)
=	O
p	*(char)
;	O
finished_a_line	char
=	O
true	int
;	O
}	O
}	O
while	O
(	O
!	O
finished_a_line	char
)	O
;	O
buf_ptr	*(char)
=	O
cur_line	*(char)
;	O
buf_end	*(char)
=	O
in_prog_pos	*(char)
;	O
}	O
}	O
