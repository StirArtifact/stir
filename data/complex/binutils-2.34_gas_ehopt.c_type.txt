struct	O
cie_info	O
{	O
unsigned	O
code_alignment	O
;	O
int	O
z_augmentation	O
;	O
}	O
;	O
static	O
int	O
get_cie_info	O
(	O
struct	O
cie_info	O
*	O
)	O
;	O
static	O
int	O
get_cie_info	O
(	O
struct	O
cie_info	O
*	O
info	*(void)
)	O
{	O
fragS	O
*	O
f	O
;	O
fixS	O
*	O
fix	O
;	O
unsigned	O
int	O
offset	long
;	O
char	O
CIE_id	O
;	O
char	O
augmentation	O
[	O
10	int
]	O
;	O
int	O
iaug	O
;	O
int	O
code_alignment	O
=	O
0	int
;	O
f	O
=	O
seg_info	O
(	O
now_seg	O
)	O
->	O
frchainP	O
->	O
frch_root	O
;	O
fix	O
=	O
seg_info	O
(	O
now_seg	O
)	O
->	O
frchainP	O
->	O
fix_root	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".debug_frame"	*(char)
,	O
12	int
)	O
==	O
0	int
)	O
CIE_id	O
=	O
(	O
char	O
)	O
0xff	int
;	O
else	O
CIE_id	O
=	O
0	int
;	O
offset	long
=	O
4	int
;	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
offset	long
>=	O
f	O
->	O
fr_fix	O
)	O
{	O
offset	long
-=	O
f	O
->	O
fr_fix	O
;	O
f	O
=	O
f	O
->	O
fr_next	O
;	O
}	O
if	O
(	O
f	O
==	O
NULL	O
||	O
f	O
->	O
fr_fix	O
-	O
offset	long
<	O
4	int
||	O
f	O
->	O
fr_literal	O
[	O
offset	long
]	O
!=	O
CIE_id	O
||	O
f	O
->	O
fr_literal	O
[	O
offset	long
+	O
1	int
]	O
!=	O
CIE_id	O
||	O
f	O
->	O
fr_literal	O
[	O
offset	long
+	O
2	int
]	O
!=	O
CIE_id	O
||	O
f	O
->	O
fr_literal	O
[	O
offset	long
+	O
3	int
]	O
!=	O
CIE_id	O
)	O
return	O
0	int
;	O
offset	long
+=	O
4	int
;	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
offset	long
>=	O
f	O
->	O
fr_fix	O
)	O
{	O
offset	long
-=	O
f	O
->	O
fr_fix	O
;	O
f	O
=	O
f	O
->	O
fr_next	O
;	O
}	O
if	O
(	O
f	O
==	O
NULL	O
||	O
f	O
->	O
fr_fix	O
-	O
offset	long
<	O
1	int
||	O
f	O
->	O
fr_literal	O
[	O
offset	long
]	O
!=	O
1	int
)	O
return	O
0	int
;	O
iaug	O
=	O
0	int
;	O
++	O
offset	long
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
offset	long
>=	O
f	O
->	O
fr_fix	O
)	O
{	O
offset	long
-=	O
f	O
->	O
fr_fix	O
;	O
f	O
=	O
f	O
->	O
fr_next	O
;	O
}	O
if	O
(	O
f	O
==	O
NULL	O
)	O
return	O
0	int
;	O
while	O
(	O
offset	long
<	O
f	O
->	O
fr_fix	O
&&	O
f	O
->	O
fr_literal	O
[	O
offset	long
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
size_t	long
)	O
iaug	O
<	O
(	O
sizeof	O
augmentation	O
)	O
-	O
1	int
)	O
{	O
augmentation	O
[	O
iaug	O
]	O
=	O
f	O
->	O
fr_literal	O
[	O
offset	long
]	O
;	O
++	O
iaug	O
;	O
}	O
++	O
offset	long
;	O
}	O
if	O
(	O
offset	long
<	O
f	O
->	O
fr_fix	O
)	O
break	O
;	O
}	O
++	O
offset	long
;	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
offset	long
>=	O
f	O
->	O
fr_fix	O
)	O
{	O
offset	long
-=	O
f	O
->	O
fr_fix	O
;	O
f	O
=	O
f	O
->	O
fr_next	O
;	O
}	O
if	O
(	O
f	O
==	O
NULL	O
)	O
return	O
0	int
;	O
augmentation	O
[	O
iaug	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
augmentation	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
augmentation	O
,	O
"eh"	*(char)
)	O
==	O
0	int
)	O
{	O
while	O
(	O
fix	O
!=	O
NULL	O
&&	O
(	O
fix	O
->	O
fx_frag	O
!=	O
f	O
||	O
fix	O
->	O
fx_where	O
!=	O
offset	long
)	O
)	O
fix	O
=	O
fix	O
->	O
fx_next	O
;	O
if	O
(	O
fix	O
==	O
NULL	O
)	O
offset	long
+=	O
4	int
;	O
else	O
offset	long
+=	O
fix	O
->	O
fx_size	O
;	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
offset	long
>=	O
f	O
->	O
fr_fix	O
)	O
{	O
offset	long
-=	O
f	O
->	O
fr_fix	O
;	O
f	O
=	O
f	O
->	O
fr_next	O
;	O
}	O
if	O
(	O
f	O
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
augmentation	O
[	O
0	int
]	O
!=	O
'z'	O
)	O
return	O
0	int
;	O
code_alignment	O
=	O
f	O
->	O
fr_literal	O
[	O
offset	long
]	O
&	O
0xff	int
;	O
if	O
(	O
(	O
code_alignment	O
&	O
0x80	int
)	O
!=	O
0	int
)	O
code_alignment	O
=	O
0	int
;	O
info	*(void)
->	O
code_alignment	O
=	O
code_alignment	O
;	O
info	*(void)
->	O
z_augmentation	O
=	O
(	O
augmentation	O
[	O
0	int
]	O
==	O
'z'	O
)	O
;	O
return	O
1	int
;	O
}	O
enum	O
frame_state	O
{	O
state_idle	O
,	O
state_saw_size	O
,	O
state_saw_cie_offset	O
,	O
state_saw_pc_begin	O
,	O
state_seeing_aug_size	O
,	O
state_skipping_aug	O
,	O
state_wait_loc4	O
,	O
state_saw_loc4	O
,	O
state_error	O
,	O
}	O
;	O
int	O
check_eh_frame	O
(	O
expressionS	O
*	O
exp	O
,	O
unsigned	O
int	O
*	O
pnbytes	O
)	O
{	O
struct	O
frame_data	O
{	O
enum	O
frame_state	O
state	*(int)
;	O
int	O
cie_info_ok	O
;	O
struct	O
cie_info	O
cie_info	O
;	O
symbolS	O
*	O
size_end_sym	O
;	O
fragS	O
*	O
loc4_frag	O
;	O
int	O
loc4_fix	O
;	O
int	O
aug_size	O
;	O
int	O
aug_shift	O
;	O
}	O
;	O
static	O
struct	O
frame_data	O
eh_frame_data	O
;	O
static	O
struct	O
frame_data	O
debug_frame_data	O
;	O
struct	O
frame_data	O
*	O
d	O
;	O
if	O
(	O
flag_traditional_format	O
)	O
return	O
0	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".eh_frame"	*(char)
,	O
9	int
)	O
==	O
0	int
&&	O
segment_name	O
(	O
now_seg	O
)	O
[	O
9	int
]	O
!=	O
'_'	O
)	O
d	O
=	O
&	O
eh_frame_data	O
;	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".debug_frame"	*(char)
,	O
12	int
)	O
==	O
0	int
)	O
d	O
=	O
&	O
debug_frame_data	O
;	O
else	O
return	O
0	int
;	O
if	O
(	O
d	O
->	O
state	*(int)
>=	O
state_saw_size	O
&&	O
S_IS_DEFINED	O
(	O
d	O
->	O
size_end_sym	O
)	O
)	O
{	O
d	O
->	O
state	*(int)
=	O
state_idle	O
;	O
}	O
switch	O
(	O
d	O
->	O
state	*(int)
)	O
{	O
case	O
state_idle	O
:	O
if	O
(	O
*	O
pnbytes	O
==	O
4	int
)	O
{	O
if	O
(	O
(	O
exp	O
->	O
X_op	O
==	O
O_symbol	O
||	O
exp	O
->	O
X_op	O
==	O
O_subtract	O
)	O
&&	O
!	O
S_IS_DEFINED	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
)	O
{	O
d	O
->	O
state	*(int)
=	O
state_saw_size	O
;	O
d	O
->	O
size_end_sym	O
=	O
exp	O
->	O
X_add_symbol	O
;	O
}	O
}	O
break	O
;	O
case	O
state_saw_size	O
:	O
case	O
state_saw_cie_offset	O
:	O
d	O
->	O
state	*(int)
=	O
(	O
enum	O
frame_state	O
)	O
(	O
d	O
->	O
state	*(int)
+	O
1	int
)	O
;	O
break	O
;	O
case	O
state_saw_pc_begin	O
:	O
if	O
(	O
!	O
d	O
->	O
cie_info_ok	O
&&	O
!	O
(	O
d	O
->	O
cie_info_ok	O
=	O
get_cie_info	O
(	O
&	O
d	O
->	O
cie_info	O
)	O
)	O
)	O
d	O
->	O
state	*(int)
=	O
state_error	O
;	O
else	O
if	O
(	O
d	O
->	O
cie_info	O
.	O
z_augmentation	O
)	O
{	O
d	O
->	O
state	*(int)
=	O
state_seeing_aug_size	O
;	O
d	O
->	O
aug_size	O
=	O
0	int
;	O
d	O
->	O
aug_shift	O
=	O
0	int
;	O
}	O
else	O
d	O
->	O
state	*(int)
=	O
state_wait_loc4	O
;	O
break	O
;	O
case	O
state_seeing_aug_size	O
:	O
if	O
(	O
(	O
int	O
)	O
*	O
pnbytes	O
==	O
-	O
1	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
)	O
{	O
d	O
->	O
aug_size	O
=	O
exp	O
->	O
X_add_number	O
;	O
d	O
->	O
state	*(int)
=	O
state_skipping_aug	O
;	O
}	O
else	O
if	O
(	O
*	O
pnbytes	O
==	O
1	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
)	O
{	O
unsigned	O
char	O
byte	O
=	O
exp	O
->	O
X_add_number	O
;	O
d	O
->	O
aug_size	O
|=	O
(	O
byte	O
&	O
0x7f	int
)	O
<<	O
d	O
->	O
aug_shift	O
;	O
d	O
->	O
aug_shift	O
+=	O
7	int
;	O
if	O
(	O
(	O
byte	O
&	O
0x80	int
)	O
==	O
0	int
)	O
d	O
->	O
state	*(int)
=	O
state_skipping_aug	O
;	O
}	O
else	O
d	O
->	O
state	*(int)
=	O
state_error	O
;	O
if	O
(	O
d	O
->	O
state	*(int)
==	O
state_skipping_aug	O
&&	O
d	O
->	O
aug_size	O
==	O
0	int
)	O
d	O
->	O
state	*(int)
=	O
state_wait_loc4	O
;	O
break	O
;	O
case	O
state_skipping_aug	O
:	O
if	O
(	O
(	O
int	O
)	O
*	O
pnbytes	O
<	O
0	int
)	O
d	O
->	O
state	*(int)
=	O
state_error	O
;	O
else	O
{	O
int	O
left	O
=	O
(	O
d	O
->	O
aug_size	O
-=	O
*	O
pnbytes	O
)	O
;	O
if	O
(	O
left	O
==	O
0	int
)	O
d	O
->	O
state	*(int)
=	O
state_wait_loc4	O
;	O
else	O
if	O
(	O
left	O
<	O
0	int
)	O
d	O
->	O
state	*(int)
=	O
state_error	O
;	O
}	O
break	O
;	O
case	O
state_wait_loc4	O
:	O
if	O
(	O
*	O
pnbytes	O
==	O
1	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
exp	O
->	O
X_add_number	O
==	O
DW_CFA_advance_loc4	O
)	O
{	O
frag_grow	O
(	O
1	int
)	O
;	O
d	O
->	O
state	*(int)
=	O
state_saw_loc4	O
;	O
d	O
->	O
loc4_frag	O
=	O
frag_now	O
;	O
d	O
->	O
loc4_fix	O
=	O
frag_now_fix	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
state_saw_loc4	O
:	O
d	O
->	O
state	*(int)
=	O
state_wait_loc4	O
;	O
if	O
(	O
*	O
pnbytes	O
!=	O
4	int
)	O
break	O
;	O
if	O
(	O
exp	O
->	O
X_op	O
==	O
O_constant	O
)	O
{	O
if	O
(	O
exp	O
->	O
X_add_number	O
<	O
0x40	int
)	O
{	O
d	O
->	O
loc4_frag	O
->	O
fr_literal	O
[	O
d	O
->	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc	O
|	O
exp	O
->	O
X_add_number	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
exp	O
->	O
X_add_number	O
<	O
0x100	int
)	O
{	O
d	O
->	O
loc4_frag	O
->	O
fr_literal	O
[	O
d	O
->	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc1	O
;	O
*	O
pnbytes	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
exp	O
->	O
X_add_number	O
<	O
0x10000	int
)	O
{	O
d	O
->	O
loc4_frag	O
->	O
fr_literal	O
[	O
d	O
->	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc2	O
;	O
*	O
pnbytes	O
=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
exp	O
->	O
X_op	O
==	O
O_subtract	O
&&	O
d	O
->	O
cie_info	O
.	O
code_alignment	O
==	O
1	int
)	O
{	O
frag_var	O
(	O
rs_cfa	O
,	O
4	int
,	O
0	int
,	O
1	int
<<	O
3	int
,	O
make_expr_symbol	O
(	O
exp	O
)	O
,	O
d	O
->	O
loc4_fix	O
,	O
(	O
char	O
*	O
)	O
d	O
->	O
loc4_frag	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
exp	O
->	O
X_op	O
==	O
O_divide	O
||	O
exp	O
->	O
X_op	O
==	O
O_right_shift	O
)	O
&&	O
d	O
->	O
cie_info	O
.	O
code_alignment	O
>	O
1	int
)	O
{	O
if	O
(	O
symbol_symbolS	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
&&	O
symbol_constant_p	O
(	O
exp	O
->	O
X_op_symbol	O
)	O
&&	O
S_GET_SEGMENT	O
(	O
exp	O
->	O
X_op_symbol	O
)	O
==	O
absolute_section	O
&&	O
(	O
(	O
exp	O
->	O
X_op	O
==	O
O_divide	O
?	O
*	O
symbol_X_add_number	O
(	O
exp	O
->	O
X_op_symbol	O
)	O
:	O
(	O
offsetT	O
)	O
1	int
<<	O
*	O
symbol_X_add_number	O
(	O
exp	O
->	O
X_op_symbol	O
)	O
)	O
==	O
(	O
offsetT	O
)	O
d	O
->	O
cie_info	O
.	O
code_alignment	O
)	O
)	O
{	O
expressionS	O
*	O
symval	O
;	O
symval	O
=	O
symbol_get_value_expression	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
;	O
if	O
(	O
symval	O
->	O
X_op	O
==	O
O_subtract	O
)	O
{	O
frag_var	O
(	O
rs_cfa	O
,	O
4	int
,	O
0	int
,	O
d	O
->	O
cie_info	O
.	O
code_alignment	O
<<	O
3	int
,	O
make_expr_symbol	O
(	O
symval	O
)	O
,	O
d	O
->	O
loc4_fix	O
,	O
(	O
char	O
*	O
)	O
d	O
->	O
loc4_frag	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
break	O
;	O
case	O
state_error	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
eh_frame_estimate_size_before_relax	O
(	O
fragS	O
*	O
frag	O
)	O
{	O
offsetT	O
diff	O
;	O
int	O
ca	O
=	O
frag	O
->	O
fr_subtype	O
>>	O
3	int
;	O
int	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
diff	O
=	O
resolve_symbol_value	O
(	O
frag	O
->	O
fr_symbol	O
)	O
;	O
gas_assert	O
(	O
ca	O
>	O
0	int
)	O
;	O
diff	O
/=	O
ca	O
;	O
if	O
(	O
diff	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
-	O
1	int
;	O
else	O
if	O
(	O
diff	O
<	O
0x40	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
0	int
;	O
else	O
if	O
(	O
diff	O
<	O
0x100	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
else	O
if	O
(	O
diff	O
<	O
0x10000	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
2	int
;	O
else	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
4	int
;	O
frag	O
->	O
fr_subtype	O
=	O
(	O
frag	O
->	O
fr_subtype	O
&	O
~	O
7	int
)	O
|	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
&	O
7	int
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
int	O
eh_frame_relax_frag	O
(	O
fragS	O
*	O
frag	O
)	O
{	O
int	O
oldsize	O
,	O
newsize	O
;	O
oldsize	O
=	O
frag	O
->	O
fr_subtype	O
&	O
7	int
;	O
if	O
(	O
oldsize	O
==	O
7	int
)	O
oldsize	O
=	O
-	O
1	int
;	O
newsize	O
=	O
eh_frame_estimate_size_before_relax	O
(	O
frag	O
)	O
;	O
return	O
newsize	O
-	O
oldsize	O
;	O
}	O
void	O
eh_frame_convert_frag	O
(	O
fragS	O
*	O
frag	O
)	O
{	O
offsetT	O
diff	O
;	O
fragS	O
*	O
loc4_frag	O
;	O
int	O
loc4_fix	O
,	O
ca	O
;	O
loc4_frag	O
=	O
(	O
fragS	O
*	O
)	O
frag	O
->	O
fr_opcode	O
;	O
loc4_fix	O
=	O
(	O
int	O
)	O
frag	O
->	O
fr_offset	O
;	O
diff	O
=	O
resolve_symbol_value	O
(	O
frag	O
->	O
fr_symbol	O
)	O
;	O
ca	O
=	O
frag	O
->	O
fr_subtype	O
>>	O
3	int
;	O
gas_assert	O
(	O
ca	O
>	O
0	int
)	O
;	O
diff	O
/=	O
ca	O
;	O
switch	O
(	O
frag	O
->	O
fr_subtype	O
&	O
7	int
)	O
{	O
case	O
0	int
:	O
gas_assert	O
(	O
diff	O
<	O
0x40	int
)	O
;	O
loc4_frag	O
->	O
fr_literal	O
[	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc	O
|	O
diff	O
;	O
break	O
;	O
case	O
1	int
:	O
gas_assert	O
(	O
diff	O
<	O
0x100	int
)	O
;	O
loc4_frag	O
->	O
fr_literal	O
[	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc1	O
;	O
frag	O
->	O
fr_literal	O
[	O
frag	O
->	O
fr_fix	O
]	O
=	O
diff	O
;	O
break	O
;	O
case	O
2	int
:	O
gas_assert	O
(	O
diff	O
<	O
0x10000	int
)	O
;	O
loc4_frag	O
->	O
fr_literal	O
[	O
loc4_fix	O
]	O
=	O
DW_CFA_advance_loc2	O
;	O
md_number_to_chars	O
(	O
frag	O
->	O
fr_literal	O
+	O
frag	O
->	O
fr_fix	O
,	O
diff	O
,	O
2	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
md_number_to_chars	O
(	O
frag	O
->	O
fr_literal	O
+	O
frag	O
->	O
fr_fix	O
,	O
diff	O
,	O
4	int
)	O
;	O
break	O
;	O
case	O
7	int
:	O
gas_assert	O
(	O
diff	O
==	O
0	int
)	O
;	O
frag	O
->	O
fr_fix	O
-=	O
8	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
frag	O
->	O
fr_fix	O
+=	O
frag	O
->	O
fr_subtype	O
&	O
7	int
;	O
frag	O
->	O
fr_type	O
=	O
rs_fill	O
;	O
frag	O
->	O
fr_subtype	O
=	O
0	int
;	O
frag	O
->	O
fr_offset	O
=	O
0	int
;	O
}	O
