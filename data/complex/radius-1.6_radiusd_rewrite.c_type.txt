enum	O
rw_yytokentype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
TYPE	int
=	O
258	int
,	O
IF	int
=	O
259	int
,	O
ELSE	int
=	O
260	int
,	O
RETURN	int
=	O
261	int
,	O
WHILE	int
=	O
262	int
,	O
FOR	int
=	O
263	int
,	O
DO	int
=	O
264	int
,	O
BREAK	int
=	O
265	int
,	O
CONTINUE	int
=	O
266	int
,	O
DELETE	int
=	O
267	int
,	O
STRING	int
=	O
268	int
,	O
IDENT	int
=	O
269	int
,	O
NUMBER	int
=	O
270	int
,	O
REFERENCE	int
=	O
271	int
,	O
VARIABLE	int
=	O
272	int
,	O
FUN	int
=	O
273	int
,	O
BUILTIN	int
=	O
274	int
,	O
ATTR	int
=	O
275	int
,	O
BOGUS	int
=	O
276	int
,	O
OR	int
=	O
277	int
,	O
AND	int
=	O
278	int
,	O
NM	int
=	O
279	int
,	O
MT	int
=	O
280	int
,	O
NE	int
=	O
281	int
,	O
EQ	int
=	O
282	int
,	O
GE	int
=	O
283	int
,	O
GT	int
=	O
284	int
,	O
LE	int
=	O
285	int
,	O
LT	int
=	O
286	int
,	O
SHR	int
=	O
287	int
,	O
SHL	int
=	O
288	int
,	O
TYPECAST	int
=	O
289	int
,	O
NOT	int
=	O
290	int
,	O
UMINUS	int
=	O
291	int
}	O
;	O
typedef	O
long	O
RWSTYPE	long
;	O
typedef	O
struct	O
rw_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(struct`))))))
RWLIST	struct
;	O
struct	O
rw_list	struct(*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`))),*(struct(*(struct`),*(struct`))))))
{	O
RWLIST	struct
(	O
RWLIST	struct
)	O
;	O
}	O
;	O
typedef	O
struct	O
object_t	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))))
OBJECT	struct
;	O
struct	O
object_t	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))))))
{	O
OBJ	O
(	O
OBJECT	struct
)	O
;	O
}	O
;	O
typedef	O
struct	O
{	O
size_t	long
size	int
;	O
void	O
(	O
*	O
free	*((*(void),*(void))->(int))
)	O
(	O
)	O
;	O
OBJECT	struct
*	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
;	O
}	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
typedef	O
int	O
stkoff_t	int
;	O
typedef	O
unsigned	O
int	O
pctr_t	int
;	O
typedef	O
struct	O
{	O
RWSTYPE	long
reg	array(long)
[	O
RW_REG	O
]	O
;	O
char	O
*	O
sA	*(char)
;	O
pctr_t	int
pc	int
;	O
RWSTYPE	long
*	O
stack	*(long)
;	O
int	O
stacksize	int
;	O
int	O
st	int
;	O
int	O
sb	int
;	O
int	O
ht	int
;	O
int	O
nmatch	int
;	O
regmatch_t	struct(long,long)
*	O
pmatch	*(struct(long,long))
;	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
jmp	array(struct(array(long),int,struct(array(long))))
;	O
}	O
RWMACH	struct(array(long),*(char),int,*(long),int,int,int,int,int,*(struct(long,long)),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),array(struct(array(long),int,struct(array(long)))))
;	O
typedef	O
void	O
(	O
*	O
INSTR	*(()->(void))
)	O
(	O
)	O
;	O
typedef	O
struct	O
comp_regex	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)
COMP_REGEX	struct
;	O
struct	O
comp_regex	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)
{	O
OBJ	O
(	O
COMP_REGEX	struct
)	O
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
int	O
nmatch	int
;	O
}	O
;	O
typedef	O
enum	O
{	O
Eq	int
,	O
Ne	int
,	O
Lt	int
,	O
Le	int
,	O
Gt	int
,	O
Ge	int
,	O
BAnd	int
,	O
BXor	int
,	O
BOr	int
,	O
And	int
,	O
Or	int
,	O
Shl	int
,	O
Shr	int
,	O
Add	int
,	O
Sub	int
,	O
Mul	int
,	O
Div	int
,	O
Rem	int
,	O
Max_opcode	int
}	O
Bopcode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
typedef	O
enum	O
{	O
Neg	int
,	O
Not	int
,	O
Max_unary	int
}	O
Uopcode	enum(int,int,int)
;	O
typedef	O
enum	O
{	O
Generic	int
,	O
Nop	int
,	O
Enter	int
,	O
Leave	int
,	O
Stop	int
,	O
Constant	int
,	O
Matchref	int
,	O
Variable	int
,	O
Unary	int
,	O
Binary	int
,	O
Cond	int
,	O
Asgn	int
,	O
Match	int
,	O
Coercion	int
,	O
Expression	int
,	O
Return	int
,	O
Jump	int
,	O
Branch	int
,	O
Target	int
,	O
Call	int
,	O
Builtin	int
,	O
Pop	int
,	O
Pusha	int
,	O
Popa	int
,	O
Attr	int
,	O
Attr_asgn	int
,	O
Attr_check	int
,	O
Attr_delete	int
,	O
Max_mtxtype	int
}	O
Mtxtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
typedef	O
struct	O
parm_t	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),enum(int,int,int),int)
PARAMETER	struct
;	O
struct	O
parm_t	struct(*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),enum(int,int,int),int)
{	O
PARAMETER	struct
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
PARAMETER	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_data_type_t	enum(int,int,int)
datatype	enum(int,int,int)
;	O
stkoff_t	int
offset	long
;	O
}	O
;	O
typedef	O
struct	O
variable	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))
VAR	struct
;	O
struct	O
variable	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char))))
{	O
OBJ	O
(	O
VAR	struct
)	O
;	O
VAR	struct
*	O
dcllink	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
char	O
*	O
name	*(char)
;	O
int	O
level	int
;	O
int	O
offset	long
;	O
grad_data_type_t	enum(int,int,int)
datatype	enum(int,int,int)
;	O
int	O
constant	long
;	O
grad_datum_t	union(int,struct(long,*(char)))
datum	union(int,struct(long,*(char)))
;	O
}	O
;	O
typedef	O
struct	O
function_def	struct(*(struct(*(struct(*(struct`),*(char),enum(int,int,int),int,*(struct`),int,*(struct`),int,struct(*`,long))),*(char),enum(int,int,int),int,*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct`),*(struct`),enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
{	O
struct	O
function_def	struct(*(struct(*(struct(*(struct`),*(char),enum(int,int,int),int,*(struct`),int,*(struct`),int,struct(*`,long))),*(char),enum(int,int,int),int,*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct`),*(struct`),enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
char	O
*	O
name	*(char)
;	O
grad_data_type_t	enum(int,int,int)
rettype	enum(int,int,int)
;	O
pctr_t	int
entry	int
;	O
COMP_REGEX	struct
*	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
int	O
nparm	int
;	O
PARAMETER	struct
*	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
stkoff_t	int
stack_alloc	int
;	O
grad_locus_t	struct(*(char),long)
loc	struct(*(char),long)
;	O
}	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
;	O
typedef	O
struct	O
{	O
INSTR	*(()->(void))
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
;	O
char	O
*	O
name	*(char)
;	O
grad_data_type_t	enum(int,int,int)
rettype	enum(int,int,int)
;	O
char	O
*	O
parms	*(char)
;	O
}	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
;	O
typedef	O
union	O
mtx	O
MTX	union
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
}	O
GEN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
grad_datum_t	union(int,struct(long,*(char)))
datum	union(int,struct(long,*(char)))
;	O
}	O
CONST_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),union(int,struct(long,*(char))))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
num	int
;	O
}	O
MATCHREF_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int)
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
}	O
VAR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
Uopcode	enum(int,int,int)
opcode	enum(int,int,int)
;	O
MTX	union
*	O
arg	*(union)
;	O
}	O
UN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
Bopcode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
opcode	enum(int,int,int)
;	O
MTX	union
*	O
arg	*(union)
[	O
2	int
]	O
;	O
}	O
BIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(*(union)))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
VAR	struct
*	O
lval	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
MTX	union
*	O
arg	*(union)
;	O
}	O
ASGN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
MTX	union
*	O
expr	*(char)
;	O
MTX	union
*	O
if_true	*(union)
;	O
MTX	union
*	O
if_false	*(union)
;	O
}	O
COND_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
negated	int
;	O
MTX	union
*	O
arg	*(union)
;	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
}	O
MATCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
arg	*(union)
;	O
}	O
COERCE_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
expr	*(char)
;	O
}	O
EXPR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
expr	*(char)
;	O
}	O
RET_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
MTX	union
*	O
link	(*(char),*(char))->(int)
;	O
MTX	union
*	O
dest	*(union)
;	O
}	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
int	O
cond	int
;	O
MTX	union
*	O
dest	*(union)
;	O
}	O
BRANCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(union))
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
stkoff_t	int
stacksize	int
;	O
}	O
FRAME_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
pctr_t	int
pc	int
;	O
}	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
pctr_t	int
pc	int
;	O
}	O
NOP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)),int)
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
int	O
nargs	int
;	O
MTX	union
*	O
args	*(struct)
;	O
}	O
CALL_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),int,*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
INSTR	*(()->(void))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
int	O
nargs	int
;	O
MTX	union
*	O
args	*(struct)
;	O
}	O
BTIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(()->(void)),int,*(union))
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
attrno	int
;	O
MTX	union
*	O
index	(*(char),int)->(*(char))
;	O
MTX	union
*	O
rval	*(union)
;	O
}	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
;	O
union	O
mtx	O
{	O
GEN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union))
gen	O
;	O
NOP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)),int)
nop	O
;	O
FRAME_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
frame	O
;	O
CONST_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),union(int,struct(long,*(char))))
cnst	O
;	O
MATCHREF_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int)
ref	O
;	O
VAR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))))
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
UN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int),*(union))
un	O
;	O
BIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(*(union)))
bin	O
;	O
COND_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union),*(union))
cond	int
;	O
ASGN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))),*(union))
asgn	O
;	O
MATCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)))
match	O
;	O
COERCE_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
coerce	O
;	O
RET_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
ret	O
;	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
jump	O
;	O
BRANCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(union))
branch	O
;	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
CALL_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),int,*(union))
call	O
;	O
BTIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(()->(void)),int,*(union))
btin	O
;	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
;	O
typedef	O
struct	O
frame_t	O
FRAME	O
;	O
struct	O
frame_t	O
{	O
OBJ	O
(	O
FRAME	O
)	O
;	O
int	O
level	int
;	O
stkoff_t	int
stack_offset	O
;	O
}	O
;	O
static	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
frame_bkt	O
=	O
{	O
sizeof	O
(	O
FRAME	O
)	O
,	O
NULL	O
}	O
;	O
static	O
FRAME	O
*	O
frame_first	O
,	O
*	O
frame_last	O
;	O
static	O
int	O
errcnt	long
;	O
static	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
function	O
;	O
static	O
grad_symtab_t	struct(int,int,int,*(*(struct(*(struct`),*(char)))),*(()->(int)))
*	O
rewrite_tab	O
;	O
static	O
MTX	union
*	O
mtx_first	O
,	O
*	O
mtx_last	O
;	O
static	O
VAR	struct
*	O
var_first	O
,	O
*	O
var_last	O
;	O
typedef	O
struct	O
loop_t	O
LOOP	O
;	O
struct	O
loop_t	O
{	O
OBJ	O
(	O
LOOP	O
)	O
;	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
lp_break	O
;	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
lp_cont	O
;	O
}	O
;	O
static	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
loop_bkt	O
=	O
{	O
sizeof	O
(	O
LOOP	O
)	O
,	O
NULL	O
}	O
;	O
static	O
LOOP	O
*	O
loop_first	O
,	O
*	O
loop_last	O
;	O
void	O
loop_push	O
(	O
MTX	union
*	O
mtx	O
)	O
;	O
void	O
loop_pop	O
(	O
)	O
;	O
void	O
loop_fixup	O
(	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
list	*(*(struct))
,	O
MTX	union
*	O
target	O
)	O
;	O
void	O
loop_init	O
(	O
)	O
;	O
void	O
loop_free_all	O
(	O
)	O
;	O
void	O
loop_unwind_all	O
(	O
)	O
;	O
static	O
FILE	struct
*	O
infile	O
;	O
static	O
grad_locus_t	struct(*(char),long)
locus	O
;	O
static	O
char	O
*	O
inbuf	O
;	O
static	O
char	O
*	O
curp	O
;	O
static	O
int	O
rw_yyeof	O
;	O
static	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
input_stk	O
;	O
static	O
grad_data_type_t	enum(int,int,int)
return_type	O
=	O
Undefined	int
;	O
static	O
int	O
regcomp_flags	O
=	O
0	int
;	O
static	O
size_t	long
rewrite_stack_size	O
=	O
4096	int
;	O
static	O
RWSTYPE	long
*	O
runtime_stack	O
;	O
static	O
RWMACH	struct(array(long),*(char),int,*(long),int,int,int,int,int,*(struct(long,long)),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),array(struct(array(long),int,struct(array(long)))))
mach	O
;	O
static	O
char	O
*	O
default_gettext_domain	O
;	O
static	O
int	O
rw_yylex	O
(	O
)	O
;	O
static	O
void	O
rw_yysync	O
(	O
)	O
;	O
static	O
int	O
rw_yyerror	O
(	O
char	O
*	O
s	*(*(char))
)	O
;	O
static	O
void	O
frame_init	O
(	O
)	O
;	O
static	O
void	O
frame_push	O
(	O
)	O
;	O
static	O
void	O
frame_pop	O
(	O
)	O
;	O
static	O
void	O
frame_unwind_all	O
(	O
)	O
;	O
static	O
void	O
frame_free_all	O
(	O
)	O
;	O
static	O
void	O
var_init	O
(	O
)	O
;	O
static	O
VAR	struct
*	O
var_alloc	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
char	O
*	O
name	*(char)
,	O
int	O
grow	O
)	O
;	O
static	O
void	O
var_unwind_level	O
(	O
)	O
;	O
static	O
void	O
var_unwind_all	O
(	O
)	O
;	O
static	O
void	O
var_type	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
static	O
void	O
var_free_all	O
(	O
)	O
;	O
static	O
VAR	struct
*	O
var_lookup	O
(	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
void	O
mtx_init	O
(	O
)	O
;	O
static	O
void	O
mtx_free_all	O
(	O
)	O
;	O
static	O
void	O
mtx_unwind_all	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_cur	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_nop	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_jump	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_frame	O
(	O
Mtxtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	int
,	O
stkoff_t	int
stksize	O
)	O
;	O
static	O
MTX	union
*	O
mtx_stop	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_pop	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_return	O
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_alloc	O
(	O
Mtxtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	int
)	O
;	O
static	O
MTX	union
*	O
mtx_const	O
(	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
;	O
static	O
MTX	union
*	O
mtx_ref	O
(	O
int	O
num	int
)	O
;	O
static	O
MTX	union
*	O
mtx_var	O
(	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
static	O
MTX	union
*	O
mtx_asgn	O
(	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
,	O
MTX	union
*	O
arg	*(union)
)	O
;	O
static	O
MTX	union
*	O
mtx_bin	O
(	O
Bopcode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
opcode	enum(int,int,int)
,	O
MTX	union
*	O
arg1	O
,	O
MTX	union
*	O
arg2	O
)	O
;	O
static	O
MTX	union
*	O
mtx_un	O
(	O
Uopcode	enum(int,int,int)
opcode	enum(int,int,int)
,	O
MTX	union
*	O
arg	*(union)
)	O
;	O
static	O
MTX	union
*	O
mtx_match	O
(	O
int	O
negated	int
,	O
MTX	union
*	O
mtx	O
,	O
COMP_REGEX	struct
*	O
)	O
;	O
static	O
MTX	union
*	O
mtx_cond	O
(	O
MTX	union
*	O
cond	int
,	O
MTX	union
*	O
if_true	*(union)
,	O
MTX	union
*	O
if_false	*(union)
)	O
;	O
static	O
MTX	union
*	O
mtx_coerce	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
MTX	union
*	O
arg	*(union)
)	O
;	O
static	O
MTX	union
*	O
mtx_call	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
,	O
MTX	union
*	O
args	*(struct)
)	O
;	O
static	O
MTX	union
*	O
mtx_builtin	O
(	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
bin	O
,	O
MTX	union
*	O
args	*(struct)
)	O
;	O
static	O
MTX	union
*	O
mtx_attr	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_asgn	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
,	O
MTX	union
*	O
rval	*(union)
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_check	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_delete	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
;	O
static	O
MTX	union
*	O
coerce	O
(	O
MTX	union
*	O
arg	*(union)
,	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
;	O
static	O
COMP_REGEX	struct
*	O
rx_alloc	O
(	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
int	O
nmatch	int
)	O
;	O
static	O
void	O
rx_free	O
(	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
static	O
COMP_REGEX	struct
*	O
compile_regexp	O
(	O
char	O
*	O
str	*(char)
)	O
;	O
static	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
function_install	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
;	O
static	O
int	O
function_free	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
;	O
static	O
void	O
function_delete	O
(	O
)	O
;	O
static	O
void	O
function_cleanup	O
(	O
)	O
;	O
static	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
builtin_lookup	O
(	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
int	O
optimize	O
(	O
)	O
;	O
static	O
pctr_t	int
codegen	O
(	O
)	O
;	O
static	O
void	O
code_init	O
(	O
)	O
;	O
static	O
void	O
code_check	O
(	O
)	O
;	O
static	O
void	O
debug_dump_code	O
(	O
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_nom	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_acc	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_abl	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
;	O
static	O
grad_data_type_t	enum(int,int,int)
attr_datatype	O
(	O
grad_dict_attr_t	struct
*	O
)	O
;	O
static	O
void	O
gc	O
(	O
)	O
;	O
static	O
void	O
run	O
(	O
pctr_t	int
pc	int
)	O
;	O
static	O
int	O
run_init	O
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
static	O
int	O
rw_error	O
(	O
const	O
char	O
*	O
msg	*(char)
)	O
;	O
static	O
int	O
rw_error_free	O
(	O
char	O
*	O
msg	*(char)
)	O
;	O
typedef	O
union	O
YYSTYPE	O
{	O
int	O
number	long
;	O
int	O
type	int
;	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
MTX	union
*	O
mtx	O
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
btin	O
;	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
struct	O
{	O
MTX	union
*	O
arg_first	O
;	O
MTX	union
*	O
arg_last	O
;	O
}	O
arg	*(union)
;	O
struct	O
{	O
int	O
nmatch	int
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
}	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
char	O
*	O
string	*(*(char))
;	O
}	O
YYSTYPE	O
;	O
typedef	O
unsigned	O
char	O
rw_yytype_uint8	O
;	O
typedef	O
signed	O
char	O
rw_yytype_int8	O
;	O
typedef	O
unsigned	O
short	O
int	O
rw_yytype_uint16	O
;	O
typedef	O
short	O
int	O
rw_yytype_int16	O
;	O
union	O
rw_yyalloc	O
{	O
rw_yytype_int16	O
rw_yyss	O
;	O
YYSTYPE	O
rw_yyvs	O
;	O
}	O
;	O
static	O
const	O
rw_yytype_uint8	O
rw_yytranslate	O
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
42	int
,	O
29	int
,	O
2	int
,	O
50	int
,	O
51	int
,	O
40	int
,	O
38	int
,	O
49	int
,	O
39	int
,	O
2	int
,	O
41	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
48	int
,	O
2	int
,	O
22	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
28	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
46	int
,	O
27	int
,	O
47	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
43	int
,	O
44	int
,	O
45	int
}	O
;	O
static	O
const	O
rw_yytype_uint16	O
rw_yyprhs	O
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
9	int
,	O
11	int
,	O
14	int
,	O
17	int
,	O
22	int
,	O
26	int
,	O
30	int
,	O
32	int
,	O
35	int
,	O
37	int
,	O
39	int
,	O
41	int
,	O
43	int
,	O
46	int
,	O
50	int
,	O
52	int
,	O
56	int
,	O
59	int
,	O
63	int
,	O
65	int
,	O
69	int
,	O
72	int
,	O
73	int
,	O
75	int
,	O
77	int
,	O
81	int
,	O
83	int
,	O
85	int
,	O
88	int
,	O
92	int
,	O
95	int
,	O
99	int
,	O
105	int
,	O
109	int
,	O
113	int
,	O
114	int
,	O
121	int
,	O
124	int
,	O
127	int
,	O
131	int
,	O
138	int
,	O
140	int
,	O
142	int
,	O
144	int
,	O
148	int
,	O
150	int
,	O
152	int
,	O
154	int
,	O
156	int
,	O
158	int
,	O
162	int
,	O
164	int
,	O
169	int
,	O
172	int
,	O
178	int
,	O
182	int
,	O
189	int
,	O
194	int
,	O
199	int
,	O
203	int
,	O
207	int
,	O
211	int
,	O
215	int
,	O
219	int
,	O
223	int
,	O
227	int
,	O
231	int
,	O
235	int
,	O
239	int
,	O
243	int
,	O
247	int
,	O
250	int
,	O
253	int
,	O
256	int
,	O
260	int
,	O
265	int
,	O
269	int
,	O
273	int
,	O
277	int
,	O
281	int
,	O
285	int
,	O
289	int
,	O
293	int
}	O
;	O
static	O
const	O
rw_yytype_int8	O
rw_yyrhs	O
[	O
]	O
=	O
{	O
53	int
,	O
0	int
,	O
-	O
1	int
,	O
54	int
,	O
-	O
1	int
,	O
55	int
,	O
-	O
1	int
,	O
78	int
,	O
-	O
1	int
,	O
56	int
,	O
-	O
1	int
,	O
55	int
,	O
56	int
,	O
-	O
1	int
,	O
55	int
,	O
1	int
,	O
-	O
1	int
,	O
57	int
,	O
58	int
,	O
71	int
,	O
59	int
,	O
-	O
1	int
,	O
3	int
,	O
14	int
,	O
65	int
,	O
-	O
1	int
,	O
3	int
,	O
18	int
,	O
65	int
,	O
-	O
1	int
,	O
60	int
,	O
-	O
1	int
,	O
60	int
,	O
62	int
,	O
-	O
1	int
,	O
61	int
,	O
-	O
1	int
,	O
46	int
,	O
-	O
1	int
,	O
47	int
,	O
-	O
1	int
,	O
63	int
,	O
-	O
1	int
,	O
62	int
,	O
63	int
,	O
-	O
1	int
,	O
3	int
,	O
64	int
,	O
48	int
,	O
-	O
1	int
,	O
14	int
,	O
-	O
1	int
,	O
64	int
,	O
49	int
,	O
14	int
,	O
-	O
1	int
,	O
50	int
,	O
51	int
,	O
-	O
1	int
,	O
50	int
,	O
66	int
,	O
51	int
,	O
-	O
1	int
,	O
67	int
,	O
-	O
1	int
,	O
66	int
,	O
49	int
,	O
67	int
,	O
-	O
1	int
,	O
3	int
,	O
14	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
69	int
,	O
-	O
1	int
,	O
70	int
,	O
-	O
1	int
,	O
69	int
,	O
49	int
,	O
70	int
,	O
-	O
1	int
,	O
78	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
71	int
,	O
72	int
,	O
-	O
1	int
,	O
58	int
,	O
71	int
,	O
59	int
,	O
-	O
1	int
,	O
78	int
,	O
48	int
,	O
-	O
1	int
,	O
4	int
,	O
77	int
,	O
72	int
,	O
-	O
1	int
,	O
4	int
,	O
77	int
,	O
72	int
,	O
76	int
,	O
72	int
,	O
-	O
1	int
,	O
6	int
,	O
78	int
,	O
48	int
,	O
-	O
1	int
,	O
74	int
,	O
77	int
,	O
72	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
75	int
,	O
72	int
,	O
73	int
,	O
7	int
,	O
77	int
,	O
48	int
,	O
-	O
1	int
,	O
10	int
,	O
48	int
,	O
-	O
1	int
,	O
11	int
,	O
48	int
,	O
-	O
1	int
,	O
12	int
,	O
20	int
,	O
48	int
,	O
-	O
1	int
,	O
12	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
48	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
9	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
15	int
,	O
-	O
1	int
,	O
13	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
14	int
,	O
-	O
1	int
,	O
17	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
20	int
,	O
-	O
1	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
40	int
,	O
20	int
,	O
-	O
1	int
,	O
40	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
20	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
18	int
,	O
50	int
,	O
68	int
,	O
51	int
,	O
-	O
1	int
,	O
19	int
,	O
50	int
,	O
68	int
,	O
51	int
,	O
-	O
1	int
,	O
78	int
,	O
38	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
40	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
41	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
42	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
27	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
29	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
28	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
37	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
36	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
24	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
23	int
,	O
78	int
,	O
-	O
1	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
38	int
,	O
78	int
,	O
-	O
1	int
,	O
44	int
,	O
78	int
,	O
-	O
1	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
50	int
,	O
3	int
,	O
51	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
31	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
30	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
35	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
34	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
33	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
32	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
26	int
,	O
13	int
,	O
-	O
1	int
,	O
78	int
,	O
25	int
,	O
13	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
rw_yytype_uint16	O
rw_yyrline	O
[	O
]	O
=	O
{	O
0	int
,	O
717	int
,	O
717	int
,	O
726	int
,	O
730	int
,	O
754	int
,	O
755	int
,	O
756	int
,	O
773	int
,	O
799	int
,	O
838	int
,	O
849	int
,	O
850	int
,	O
853	int
,	O
856	int
,	O
862	int
,	O
873	int
,	O
874	int
,	O
877	int
,	O
883	int
,	O
888	int
,	O
899	int
,	O
903	int
,	O
909	int
,	O
914	int
,	O
921	int
,	O
931	int
,	O
934	int
,	O
940	int
,	O
945	int
,	O
953	int
,	O
959	int
,	O
960	int
,	O
963	int
,	O
967	int
,	O
972	int
,	O
977	int
,	O
984	int
,	O
989	int
,	O
1005	int
,	O
1005	int
,	O
1024	int
,	O
1038	int
,	O
1051	int
,	O
1055	int
,	O
1061	int
,	O
1068	int
,	O
1075	int
,	O
1083	int
,	O
1094	int
,	O
1101	int
,	O
1109	int
,	O
1113	int
,	O
1117	int
,	O
1123	int
,	O
1127	int
,	O
1131	int
,	O
1135	int
,	O
1139	int
,	O
1143	int
,	O
1147	int
,	O
1151	int
,	O
1155	int
,	O
1159	int
,	O
1163	int
,	O
1167	int
,	O
1171	int
,	O
1175	int
,	O
1179	int
,	O
1183	int
,	O
1187	int
,	O
1191	int
,	O
1195	int
,	O
1199	int
,	O
1203	int
,	O
1207	int
,	O
1211	int
,	O
1215	int
,	O
1219	int
,	O
1223	int
,	O
1227	int
,	O
1231	int
,	O
1235	int
,	O
1239	int
,	O
1243	int
,	O
1247	int
,	O
1251	int
,	O
1260	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
rw_yytname	O
[	O
]	O
=	O
{	O
"$end"	*(char)
,	O
"error"	*(char)
,	O
"$undefined"	*(char)
,	O
"TYPE"	*(char)
,	O
"IF"	*(char)
,	O
"ELSE"	*(char)
,	O
"RETURN"	*(char)
,	O
"WHILE"	*(char)
,	O
"FOR"	*(char)
,	O
"DO"	*(char)
,	O
"BREAK"	*(char)
,	O
"CONTINUE"	*(char)
,	O
"DELETE"	*(char)
,	O
"STRING"	*(char)
,	O
"IDENT"	*(char)
,	O
"NUMBER"	*(char)
,	O
"REFERENCE"	*(char)
,	O
"VARIABLE"	*(char)
,	O
"FUN"	*(char)
,	O
"BUILTIN"	*(char)
,	O
"ATTR"	*(char)
,	O
"BOGUS"	*(char)
,	O
"'='"	*(char)
,	O
"OR"	*(char)
,	O
"AND"	*(char)
,	O
"NM"	*(char)
,	O
"MT"	*(char)
,	O
"'|'"	*(char)
,	O
"'^'"	*(char)
,	O
"'&'"	*(char)
,	O
"NE"	*(char)
,	O
"EQ"	*(char)
,	O
"GE"	*(char)
,	O
"GT"	*(char)
,	O
"LE"	*(char)
,	O
"LT"	*(char)
,	O
"SHR"	*(char)
,	O
"SHL"	*(char)
,	O
"'+'"	*(char)
,	O
"'-'"	*(char)
,	O
"'*'"	*(char)
,	O
"'/'"	*(char)
,	O
"'%'"	*(char)
,	O
"TYPECAST"	*(char)
,	O
"NOT"	*(char)
,	O
"UMINUS"	*(char)
,	O
"'{'"	*(char)
,	O
"'}'"	*(char)
,	O
"';'"	*(char)
,	O
"','"	*(char)
,	O
"'('"	*(char)
,	O
"')'"	*(char)
,	O
"$accept"	*(char)
,	O
"program"	*(char)
,	O
"input"	*(char)
,	O
"dcllist"	*(char)
,	O
"decl"	*(char)
,	O
"fundecl"	*(char)
,	O
"begin"	*(char)
,	O
"end"	*(char)
,	O
"obrace"	*(char)
,	O
"cbrace"	*(char)
,	O
"autodcl"	*(char)
,	O
"autovar"	*(char)
,	O
"varlist"	*(char)
,	O
"dclparm"	*(char)
,	O
"parmlist"	*(char)
,	O
"parm"	*(char)
,	O
"args"	*(char)
,	O
"arglist"	*(char)
,	O
"arg"	*(char)
,	O
"list"	*(char)
,	O
"stmt"	*(char)
,	O
"@1"	*(char)
,	O
"while"	*(char)
,	O
"do"	*(char)
,	O
"else"	*(char)
,	O
"cond"	*(char)
,	O
"expr"	*(char)
,	O
0	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	O
rw_yyr1	O
[	O
]	O
=	O
{	O
0	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
54	int
,	O
55	int
,	O
55	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
57	int
,	O
58	int
,	O
58	int
,	O
59	int
,	O
60	int
,	O
61	int
,	O
62	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
64	int
,	O
65	int
,	O
65	int
,	O
66	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
68	int
,	O
69	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
71	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
73	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
74	int
,	O
75	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	O
rw_yyr2	O
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
0	int
,	O
6	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
4	int
,	O
2	int
,	O
5	int
,	O
3	int
,	O
6	int
,	O
4	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	O
rw_yydefact	O
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
50	int
,	O
53	int
,	O
49	int
,	O
51	int
,	O
52	int
,	O
0	int
,	O
0	int
,	O
55	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
26	int
,	O
26	int
,	O
0	int
,	O
0	int
,	O
76	int
,	O
75	int
,	O
57	int
,	O
77	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
7	int
,	O
6	int
,	O
14	int
,	O
0	int
,	O
11	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
9	int
,	O
10	int
,	O
54	int
,	O
0	int
,	O
27	int
,	O
28	int
,	O
30	int
,	O
0	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
78	int
,	O
0	int
,	O
0	int
,	O
45	int
,	O
46	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
31	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
16	int
,	O
74	int
,	O
73	int
,	O
87	int
,	O
86	int
,	O
68	int
,	O
70	int
,	O
69	int
,	O
81	int
,	O
80	int
,	O
85	int
,	O
84	int
,	O
83	int
,	O
82	int
,	O
72	int
,	O
71	int
,	O
63	int
,	O
64	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
0	int
,	O
21	int
,	O
0	int
,	O
23	int
,	O
61	int
,	O
0	int
,	O
62	int
,	O
56	int
,	O
0	int
,	O
79	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
41	int
,	O
42	int
,	O
0	int
,	O
0	int
,	O
15	int
,	O
8	int
,	O
13	int
,	O
32	int
,	O
0	int
,	O
39	int
,	O
34	int
,	O
19	int
,	O
0	int
,	O
17	int
,	O
25	int
,	O
0	int
,	O
22	int
,	O
29	int
,	O
0	int
,	O
58	int
,	O
0	int
,	O
35	int
,	O
37	int
,	O
43	int
,	O
0	int
,	O
33	int
,	O
38	int
,	O
0	int
,	O
18	int
,	O
0	int
,	O
24	int
,	O
60	int
,	O
48	int
,	O
47	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
20	int
,	O
36	int
,	O
0	int
,	O
0	int
,	O
44	int
,	O
40	int
}	O
;	O
static	O
const	O
rw_yytype_int16	O
rw_yydefgoto	O
[	O
]	O
=	O
{	O
-	O
1	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
81	int
,	O
128	int
,	O
39	int
,	O
129	int
,	O
88	int
,	O
89	int
,	O
135	int
,	O
61	int
,	O
112	int
,	O
113	int
,	O
64	int
,	O
65	int
,	O
66	int
,	O
82	int
,	O
83	int
,	O
150	int
,	O
84	int
,	O
85	int
,	O
157	int
,	O
121	int
,	O
86	int
}	O
;	O
static	O
const	O
rw_yytype_int16	O
rw_yypact	O
[	O
]	O
=	O
{	O
67	int
,	O
17	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
1	int
,	O
-	O
22	int
,	O
12	int
,	O
-	O
20	int
,	O
207	int
,	O
207	int
,	O
44	int
,	O
207	int
,	O
110	int
,	O
65	int
,	O
-	O
84	int
,	O
33	int
,	O
-	O
84	int
,	O
20	int
,	O
432	int
,	O
19	int
,	O
19	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
24	int
,	O
-	O
84	int
,	O
16	int
,	O
235	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
74	int
,	O
207	int
,	O
207	int
,	O
66	int
,	O
90	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
9	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
432	int
,	O
57	int
,	O
61	int
,	O
-	O
84	int
,	O
432	int
,	O
58	int
,	O
432	int
,	O
264	int
,	O
207	int
,	O
207	int
,	O
-	O
84	int
,	O
62	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
68	int
,	O
70	int
,	O
94	int
,	O
169	int
,	O
152	int
,	O
-	O
84	int
,	O
62	int
,	O
169	int
,	O
380	int
,	O
105	int
,	O
74	int
,	O
-	O
84	int
,	O
451	int
,	O
469	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
60	int
,	O
199	int
,	O
482	int
,	O
493	int
,	O
493	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
23	int
,	O
-	O
23	int
,	O
-	O
3	int
,	O
-	O
3	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
107	int
,	O
-	O
84	int
,	O
-	O
29	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
100	int
,	O
293	int
,	O
-	O
84	int
,	O
207	int
,	O
169	int
,	O
406	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
13	int
,	O
152	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
6	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
128	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
322	int
,	O
127	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
126	int
,	O
-	O
84	int
,	O
120	int
,	O
-	O
84	int
,	O
432	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
351	int
,	O
62	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
87	int
,	O
88	int
,	O
-	O
84	int
,	O
-	O
84	int
}	O
;	O
static	O
const	O
rw_yytype_int16	O
rw_yypgoto	O
[	O
]	O
=	O
{	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
121	int
,	O
-	O
84	int
,	O
118	int
,	O
14	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
51	int
,	O
-	O
84	int
,	O
122	int
,	O
-	O
84	int
,	O
4	int
,	O
130	int
,	O
-	O
84	int
,	O
28	int
,	O
64	int
,	O
-	O
53	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
83	int
,	O
0	int
}	O
;	O
static	O
const	O
rw_yytype_int16	O
rw_yytable	O
[	O
]	O
=	O
{	O
20	int
,	O
131	int
,	O
26	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
28	int
,	O
29	int
,	O
110	int
,	O
31	int
,	O
33	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
138	int
,	O
23	int
,	O
139	int
,	O
63	int
,	O
67	int
,	O
67	int
,	O
69	int
,	O
70	int
,	O
24	int
,	O
130	int
,	O
27	int
,	O
21	int
,	O
132	int
,	O
-	O
3	int
,	O
35	int
,	O
22	int
,	O
1	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
90	int
,	O
91	int
,	O
151	int
,	O
152	int
,	O
94	int
,	O
95	int
,	O
96	int
,	O
97	int
,	O
98	int
,	O
99	int
,	O
100	int
,	O
101	int
,	O
102	int
,	O
103	int
,	O
104	int
,	O
105	int
,	O
106	int
,	O
107	int
,	O
108	int
,	O
109	int
,	O
111	int
,	O
146	int
,	O
25	int
,	O
147	int
,	O
30	int
,	O
34	int
,	O
37	int
,	O
72	int
,	O
144	int
,	O
60	int
,	O
1	int
,	O
118	int
,	O
119	int
,	O
130	int
,	O
71	int
,	O
122	int
,	O
163	int
,	O
87	int
,	O
149	int
,	O
92	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
93	int
,	O
161	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
114	int
,	O
116	int
,	O
115	int
,	O
13	int
,	O
120	int
,	O
32	int
,	O
125	int
,	O
67	int
,	O
123	int
,	O
14	int
,	O
124	int
,	O
134	int
,	O
143	int
,	O
137	int
,	O
141	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
110	int
,	O
156	int
,	O
159	int
,	O
160	int
,	O
164	int
,	O
165	int
,	O
38	int
,	O
36	int
,	O
136	int
,	O
148	int
,	O
154	int
,	O
153	int
,	O
140	int
,	O
62	int
,	O
126	int
,	O
0	int
,	O
158	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
68	int
,	O
74	int
,	O
0	int
,	O
75	int
,	O
76	int
,	O
14	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
74	int
,	O
0	int
,	O
75	int
,	O
76	int
,	O
0	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
37	int
,	O
127	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
37	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
73	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
117	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
142	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
155	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
162	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
133	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
145	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
}	O
;	O
static	O
const	O
rw_yytype_int16	O
rw_yycheck	O
[	O
]	O
=	O
{	O
0	int
,	O
84	int
,	O
22	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
10	int
,	O
11	int
,	O
3	int
,	O
13	int
,	O
14	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
49	int
,	O
22	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
50	int
,	O
82	int
,	O
50	int
,	O
14	int
,	O
85	int
,	O
0	int
,	O
1	int
,	O
18	int
,	O
3	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
40	int
,	O
41	int
,	O
48	int
,	O
49	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
51	int
,	O
48	int
,	O
50	int
,	O
50	int
,	O
20	int
,	O
0	int
,	O
46	int
,	O
51	int
,	O
121	int
,	O
50	int
,	O
3	int
,	O
71	int
,	O
72	int
,	O
126	int
,	O
50	int
,	O
75	int
,	O
159	int
,	O
3	int
,	O
131	int
,	O
13	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
13	int
,	O
157	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
51	int
,	O
51	int
,	O
49	int
,	O
44	int
,	O
50	int
,	O
3	int
,	O
20	int
,	O
115	int
,	O
48	int
,	O
50	int
,	O
48	int
,	O
14	int
,	O
120	int
,	O
14	int
,	O
22	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
14	int
,	O
48	int
,	O
48	int
,	O
19	int
,	O
17	int
,	O
88	int
,	O
126	int
,	O
141	int
,	O
138	int
,	O
115	int
,	O
22	int
,	O
81	int
,	O
-	O
1	int
,	O
147	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
25	int
,	O
4	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
,	O
50	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
4	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
,	O
-	O
1	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
46	int
,	O
47	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
46	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
48	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
48	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	O
rw_yystos	O
[	O
]	O
=	O
{	O
0	int
,	O
3	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
44	int
,	O
50	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
78	int
,	O
14	int
,	O
18	int
,	O
22	int
,	O
50	int
,	O
50	int
,	O
22	int
,	O
50	int
,	O
78	int
,	O
78	int
,	O
20	int
,	O
78	int
,	O
3	int
,	O
78	int
,	O
0	int
,	O
1	int
,	O
56	int
,	O
46	int
,	O
58	int
,	O
60	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
50	int
,	O
65	int
,	O
65	int
,	O
78	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
78	int
,	O
68	int
,	O
78	int
,	O
78	int
,	O
50	int
,	O
51	int
,	O
51	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
58	int
,	O
71	int
,	O
72	int
,	O
74	int
,	O
75	int
,	O
78	int
,	O
3	int
,	O
62	int
,	O
63	int
,	O
78	int
,	O
78	int
,	O
13	int
,	O
13	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
3	int
,	O
51	int
,	O
66	int
,	O
67	int
,	O
51	int
,	O
49	int
,	O
51	int
,	O
51	int
,	O
78	int
,	O
78	int
,	O
50	int
,	O
77	int
,	O
78	int
,	O
48	int
,	O
48	int
,	O
20	int
,	O
71	int
,	O
47	int
,	O
59	int
,	O
61	int
,	O
72	int
,	O
77	int
,	O
72	int
,	O
48	int
,	O
14	int
,	O
64	int
,	O
63	int
,	O
14	int
,	O
49	int
,	O
51	int
,	O
70	int
,	O
22	int
,	O
51	int
,	O
78	int
,	O
72	int
,	O
48	int
,	O
48	int
,	O
50	int
,	O
59	int
,	O
72	int
,	O
73	int
,	O
48	int
,	O
49	int
,	O
67	int
,	O
78	int
,	O
51	int
,	O
5	int
,	O
76	int
,	O
78	int
,	O
7	int
,	O
14	int
,	O
72	int
,	O
51	int
,	O
77	int
,	O
48	int
,	O
48	int
}	O
;	O
static	O
void	O
rw_yy_symbol_value_print	O
(	O
FILE	struct
*	O
rw_yyoutput	O
,	O
int	O
rw_yytype	O
,	O
YYSTYPE	O
const	O
*	O
const	O
rw_yyvaluep	O
)	O
{	O
if	O
(	O
!	O
rw_yyvaluep	O
)	O
return	O
;	O
YYUSE	O
(	O
rw_yyoutput	O
)	O
;	O
switch	O
(	O
rw_yytype	O
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
rw_yy_symbol_print	O
(	O
FILE	struct
*	O
rw_yyoutput	O
,	O
int	O
rw_yytype	O
,	O
YYSTYPE	O
const	O
*	O
const	O
rw_yyvaluep	O
)	O
{	O
if	O
(	O
rw_yytype	O
<	O
YYNTOKENS	O
)	O
YYFPRINTF	O
(	O
rw_yyoutput	O
,	O
"token %s ("	*(char)
,	O
rw_yytname	O
[	O
rw_yytype	O
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
rw_yyoutput	O
,	O
"nterm %s ("	*(char)
,	O
rw_yytname	O
[	O
rw_yytype	O
]	O
)	O
;	O
rw_yy_symbol_value_print	O
(	O
rw_yyoutput	O
,	O
rw_yytype	O
,	O
rw_yyvaluep	O
)	O
;	O
YYFPRINTF	O
(	O
rw_yyoutput	O
,	O
")"	*(char)
)	O
;	O
}	O
static	O
void	O
rw_yy_stack_print	O
(	O
rw_yytype_int16	O
*	O
bottom	O
,	O
rw_yytype_int16	O
*	O
top	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack now"	*(char)
)	O
;	O
for	O
(	O
;	O
bottom	O
<=	O
top	O
;	O
++	O
bottom	O
)	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
*	O
bottom	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
rw_yy_reduce_print	O
(	O
YYSTYPE	O
*	O
rw_yyvsp	O
,	O
int	O
rw_yyrule	O
)	O
{	O
int	O
rw_yynrhs	O
=	O
rw_yyr2	O
[	O
rw_yyrule	O
]	O
;	O
int	O
rw_yyi	O
;	O
unsigned	O
long	O
int	O
rw_yylno	O
=	O
rw_yyrline	O
[	O
rw_yyrule	O
]	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reducing stack by rule %d (line %lu):\n"	*(char)
,	O
rw_yyrule	O
-	O
1	int
,	O
rw_yylno	O
)	O
;	O
for	O
(	O
rw_yyi	O
=	O
0	int
;	O
rw_yyi	O
<	O
rw_yynrhs	O
;	O
rw_yyi	O
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   $%d = "	*(char)
,	O
rw_yyi	O
+	O
1	int
)	O
;	O
rw_yy_symbol_print	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
rw_yyrhs	O
[	O
rw_yyprhs	O
[	O
rw_yyrule	O
]	O
+	O
rw_yyi	O
]	O
,	O
&	O
(	O
rw_yyvsp	O
[	O
(	O
rw_yyi	O
+	O
1	int
)	O
-	O
(	O
rw_yynrhs	O
)	O
]	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
int	O
rw_yydebug	O
;	O
static	O
void	O
rw_yydestruct	O
(	O
const	O
char	O
*	O
rw_yymsg	O
,	O
int	O
rw_yytype	O
,	O
YYSTYPE	O
*	O
rw_yyvaluep	O
)	O
{	O
YYUSE	O
(	O
rw_yyvaluep	O
)	O
;	O
if	O
(	O
!	O
rw_yymsg	O
)	O
rw_yymsg	O
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
rw_yymsg	O
,	O
rw_yytype	O
,	O
rw_yyvaluep	O
,	O
rw_yylocationp	O
)	O
;	O
switch	O
(	O
rw_yytype	O
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
rw_yyparse	O
(	O
void	O
)	O
;	O
int	O
rw_yychar	O
;	O
YYSTYPE	O
rw_yylval	O
;	O
int	O
rw_yynerrs	O
;	O
int	O
rw_yyparse	O
(	O
void	O
)	O
{	O
int	O
rw_yystate	O
;	O
int	O
rw_yyn	O
;	O
int	O
rw_yyresult	O
;	O
int	O
rw_yyerrstatus	O
;	O
int	O
rw_yytoken	O
=	O
0	int
;	O
rw_yytype_int16	O
rw_yyssa	O
[	O
YYINITDEPTH	O
]	O
;	O
rw_yytype_int16	O
*	O
rw_yyss	O
=	O
rw_yyssa	O
;	O
rw_yytype_int16	O
*	O
rw_yyssp	O
;	O
YYSTYPE	O
rw_yyvsa	O
[	O
YYINITDEPTH	O
]	O
;	O
YYSTYPE	O
*	O
rw_yyvs	O
=	O
rw_yyvsa	O
;	O
YYSTYPE	O
*	O
rw_yyvsp	O
;	O
YYSIZE_T	O
rw_yystacksize	O
=	O
YYINITDEPTH	O
;	O
YYSTYPE	O
rw_yyval	O
;	O
int	O
rw_yylen	O
=	O
0	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
rw_yystate	O
=	O
0	int
;	O
rw_yyerrstatus	O
=	O
0	int
;	O
rw_yynerrs	O
=	O
0	int
;	O
rw_yychar	O
=	O
YYEMPTY	O
;	O
rw_yyssp	O
=	O
rw_yyss	O
;	O
rw_yyvsp	O
=	O
rw_yyvs	O
;	O
goto	O
rw_yysetstate	O
;	O
rw_yynewstate	O
:	O
rw_yyssp	O
++	O
;	O
rw_yysetstate	O
:	O
*	O
rw_yyssp	O
=	O
rw_yystate	O
;	O
if	O
(	O
rw_yyss	O
+	O
rw_yystacksize	O
-	O
1	int
<=	O
rw_yyssp	O
)	O
{	O
YYSIZE_T	O
rw_yysize	O
=	O
rw_yyssp	O
-	O
rw_yyss	O
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	O
<=	O
rw_yystacksize	O
)	O
goto	O
rw_yyexhaustedlab	O
;	O
rw_yystacksize	O
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	O
<	O
rw_yystacksize	O
)	O
rw_yystacksize	O
=	O
YYMAXDEPTH	O
;	O
{	O
rw_yytype_int16	O
*	O
rw_yyss1	O
=	O
rw_yyss	O
;	O
union	O
rw_yyalloc	O
*	O
rw_yyptr	O
=	O
(	O
union	O
rw_yyalloc	O
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
rw_yystacksize	O
)	O
)	O
;	O
if	O
(	O
!	O
rw_yyptr	O
)	O
goto	O
rw_yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
rw_yyss	O
)	O
;	O
YYSTACK_RELOCATE	O
(	O
rw_yyvs	O
)	O
;	O
if	O
(	O
rw_yyss1	O
!=	O
rw_yyssa	O
)	O
YYSTACK_FREE	O
(	O
rw_yyss1	O
)	O
;	O
}	O
rw_yyssp	O
=	O
rw_yyss	O
+	O
rw_yysize	O
-	O
1	int
;	O
rw_yyvsp	O
=	O
rw_yyvs	O
+	O
rw_yysize	O
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
rw_yystacksize	O
)	O
)	O
;	O
if	O
(	O
rw_yyss	O
+	O
rw_yystacksize	O
-	O
1	int
<=	O
rw_yyssp	O
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
rw_yystate	O
)	O
)	O
;	O
goto	O
rw_yybackup	O
;	O
rw_yybackup	O
:	O
rw_yyn	O
=	O
rw_yypact	O
[	O
rw_yystate	O
]	O
;	O
if	O
(	O
rw_yyn	O
==	O
YYPACT_NINF	O
)	O
goto	O
rw_yydefault	O
;	O
if	O
(	O
rw_yychar	O
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
rw_yychar	O
=	O
YYLEX	O
;	O
}	O
if	O
(	O
rw_yychar	O
<=	O
YYEOF	O
)	O
{	O
rw_yychar	O
=	O
rw_yytoken	O
=	O
YYEOF	O
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
rw_yytoken	O
=	O
YYTRANSLATE	O
(	O
rw_yychar	O
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
rw_yytoken	O
,	O
&	O
rw_yylval	O
,	O
&	O
rw_yylloc	O
)	O
;	O
}	O
rw_yyn	O
+=	O
rw_yytoken	O
;	O
if	O
(	O
rw_yyn	O
<	O
0	int
||	O
YYLAST	O
<	O
rw_yyn	O
||	O
rw_yycheck	O
[	O
rw_yyn	O
]	O
!=	O
rw_yytoken	O
)	O
goto	O
rw_yydefault	O
;	O
rw_yyn	O
=	O
rw_yytable	O
[	O
rw_yyn	O
]	O
;	O
if	O
(	O
rw_yyn	O
<=	O
0	int
)	O
{	O
if	O
(	O
rw_yyn	O
==	O
0	int
||	O
rw_yyn	O
==	O
YYTABLE_NINF	O
)	O
goto	O
rw_yyerrlab	O
;	O
rw_yyn	O
=	O
-	O
rw_yyn	O
;	O
goto	O
rw_yyreduce	O
;	O
}	O
if	O
(	O
rw_yyn	O
==	O
YYFINAL	O
)	O
YYACCEPT	O
;	O
if	O
(	O
rw_yyerrstatus	O
)	O
rw_yyerrstatus	O
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
rw_yytoken	O
,	O
&	O
rw_yylval	O
,	O
&	O
rw_yylloc	O
)	O
;	O
if	O
(	O
rw_yychar	O
!=	O
YYEOF	O
)	O
rw_yychar	O
=	O
YYEMPTY	O
;	O
rw_yystate	O
=	O
rw_yyn	O
;	O
*	O
++	O
rw_yyvsp	O
=	O
rw_yylval	O
;	O
goto	O
rw_yynewstate	O
;	O
rw_yydefault	O
:	O
rw_yyn	O
=	O
rw_yydefact	O
[	O
rw_yystate	O
]	O
;	O
if	O
(	O
rw_yyn	O
==	O
0	int
)	O
goto	O
rw_yyerrlab	O
;	O
goto	O
rw_yyreduce	O
;	O
rw_yyreduce	O
:	O
rw_yylen	O
=	O
rw_yyr2	O
[	O
rw_yyn	O
]	O
;	O
rw_yyval	O
=	O
rw_yyvsp	O
[	O
1	int
-	O
rw_yylen	O
]	O
;	O
YY_REDUCE_PRINT	O
(	O
rw_yyn	O
)	O
;	O
switch	O
(	O
rw_yyn	O
)	O
{	O
case	O
2	int
:	O
{	O
var_free_all	O
(	O
)	O
;	O
loop_free_all	O
(	O
)	O
;	O
frame_free_all	O
(	O
)	O
;	O
mtx_free_all	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
return_type	O
=	O
Undefined	int
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
fmain	O
;	O
if	O
(	O
errcnt	long
)	O
{	O
YYERROR	O
;	O
}	O
mtx_return	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
fmain	O
,	O
0	int
,	O
sizeof	O
(	O
fmain	O
)	O
)	O
;	O
fmain	O
.	O
name	*(char)
=	O
"main"	*(char)
;	O
fmain	O
.	O
rettype	enum(int,int,int)
=	O
return_type	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	O
)	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
;	O
function	O
=	O
&	O
fmain	O
;	O
if	O
(	O
optimize	O
(	O
)	O
==	O
0	int
)	O
{	O
codegen	O
(	O
)	O
;	O
if	O
(	O
errcnt	long
)	O
{	O
YYERROR	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
var_unwind_all	O
(	O
)	O
;	O
loop_unwind_all	O
(	O
)	O
;	O
frame_unwind_all	O
(	O
)	O
;	O
mtx_unwind_all	O
(	O
)	O
;	O
function_delete	O
(	O
)	O
;	O
rw_yysync	O
(	O
)	O
;	O
rw_yyclearin	O
;	O
rw_yyerrok	O
;	O
errcnt	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
if	O
(	O
errcnt	long
)	O
{	O
function_delete	O
(	O
)	O
;	O
YYERROR	O
;	O
}	O
if	O
(	O
optimize	O
(	O
)	O
==	O
0	int
)	O
{	O
codegen	O
(	O
)	O
;	O
if	O
(	O
errcnt	long
)	O
{	O
function_delete	O
(	O
)	O
;	O
YYERROR	O
;	O
}	O
}	O
else	O
{	O
function_delete	O
(	O
)	O
;	O
}	O
var_unwind_all	O
(	O
)	O
;	O
loop_unwind_all	O
(	O
)	O
;	O
frame_unwind_all	O
(	O
)	O
;	O
mtx_unwind_all	O
(	O
)	O
;	O
function_cleanup	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
PARAMETER	struct
*	O
last	O
,	O
*	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
if	O
(	O
errcnt	long
)	O
YYERROR	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
,	O
0	int
,	O
sizeof	O
(	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
)	O
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
name	*(char)
=	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(*(char))
)	O
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
rettype	enum(int,int,int)
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
type	int
)	O
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
entry	int
=	O
0	int
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
loc	struct(*(char),long)
=	O
locus	O
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
nparm	int
=	O
0	int
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
NULL	O
;	O
for	O
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
nparm	int
++	O
;	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
last	O
=	O
NULL	O
;	O
for	O
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
)	O
)	O
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
->	O
datatype	enum(int,int,int)
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
=	O
-	O
(	O
STACK_BASE	O
+	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
nparm	int
-	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
)	O
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
->	O
offset	long
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
last	O
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
if	O
(	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
==	O
NULL	O
)	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
.	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
else	O
last	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
last	O
=	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
}	O
function	O
=	O
function_install	O
(	O
&	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
;	O
}	O
break	O
;	O
case	O
10	int
:	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"redefinition of function `%s'"	*(char)
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
->	O
name	*(char)
)	O
;	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
->	O
loc	struct(*(char),long)
,	O
_	O
(	O
"previously defined here"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
frame_push	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
var_unwind_level	O
(	O
)	O
;	O
frame_pop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
var_type	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
var_alloc	O
(	O
Undefined	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
+	O
1	int
)	O
;	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
->	O
dcllink	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var_alloc	O
(	O
Undefined	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
+	O
1	int
)	O
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
dcllink	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
(	O
rw_yyval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
=	O
var_alloc	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	*(*(char))
)	O
,	O
+	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
arg	*(union)
)	O
.	O
arg_first	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	O
)	O
->	O
gen	O
.	O
arglink	*(union)
=	O
NULL	O
;	O
(	O
rw_yyval	O
.	O
arg	*(union)
)	O
.	O
arg_first	O
=	O
(	O
rw_yyval	O
.	O
arg	*(union)
)	O
.	O
arg_last	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	*(union)
)	O
.	O
arg_last	O
->	O
gen	O
.	O
arglink	*(union)
=	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
;	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	*(union)
)	O
.	O
arg_last	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
;	O
(	O
rw_yyval	O
.	O
arg	*(union)
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	*(union)
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
34	int
:	O
{	O
mtx_stop	O
(	O
)	O
;	O
mtx_pop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
35	int
:	O
{	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_false	*(union)
=	O
mtx_nop	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_cur	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
36	int
:	O
{	O
mtx_stop	O
(	O
)	O
;	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_false	*(union)
=	O
(	O
rw_yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	O
)	O
;	O
(	O
rw_yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	O
)	O
->	O
nop	O
.	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
jump	O
.	O
dest	*(union)
=	O
mtx_nop	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_cur	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
37	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_return	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
38	int
:	O
{	O
MTX	union
*	O
mtx	O
;	O
mtx_stop	O
(	O
)	O
;	O
mtx	O
=	O
mtx_jump	O
(	O
)	O
;	O
mtx	O
->	O
jump	O
.	O
dest	*(union)
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
;	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_false	*(union)
=	O
mtx_nop	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_cur	O
(	O
)	O
;	O
loop_fixup	O
(	O
loop_last	O
->	O
lp_break	O
,	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
)	O
;	O
loop_fixup	O
(	O
loop_last	O
->	O
lp_cont	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
loop_pop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
39	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_nop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
40	int
:	O
{	O
(	O
rw_yyvsp	O
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_false	*(union)
=	O
(	O
rw_yyvsp	O
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_true	*(union)
;	O
(	O
rw_yyvsp	O
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_true	*(union)
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_cur	O
(	O
)	O
;	O
loop_fixup	O
(	O
loop_last	O
->	O
lp_break	O
,	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
)	O
;	O
loop_fixup	O
(	O
loop_last	O
->	O
lp_cont	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
loop_pop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
41	int
:	O
{	O
if	O
(	O
!	O
loop_last	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"nothing to break from"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_jump	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
->	O
jump	O
.	O
link	(*(char),*(char))->(int)
=	O
(	O
MTX	union
*	O
)	O
loop_last	O
->	O
lp_break	O
;	O
loop_last	O
->	O
lp_break	O
=	O
(	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
)	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
42	int
:	O
{	O
if	O
(	O
!	O
loop_last	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"nothing to continue"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_jump	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
->	O
jump	O
.	O
link	(*(char),*(char))->(int)
=	O
(	O
MTX	union
*	O
)	O
loop_last	O
->	O
lp_cont	O
;	O
loop_last	O
->	O
lp_cont	O
=	O
(	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
)	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
43	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_delete	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
44	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_delete	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
45	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_nop	O
(	O
)	O
;	O
loop_push	O
(	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
46	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_nop	O
(	O
)	O
;	O
loop_push	O
(	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
47	int
:	O
{	O
mtx_stop	O
(	O
)	O
;	O
mtx_jump	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_nop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
48	int
:	O
{	O
mtx_stop	O
(	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_cond	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
->	O
cond	int
.	O
if_true	*(union)
=	O
mtx_nop	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
49	int
:	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
val	array(int)
.	O
type	int
=	O
Integer	int
;	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	long
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_const	O
(	O
&	O
val	array(int)
)	O
;	O
}	O
break	O
;	O
case	O
50	int
:	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
val	array(int)
.	O
type	int
=	O
String	int
;	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
size	int
=	O
strlen	(*(char))->(long)
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
;	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
=	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
;	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_const	O
(	O
&	O
val	array(int)
)	O
;	O
}	O
break	O
;	O
case	O
51	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_ref	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	long
)	O
)	O
;	O
}	O
break	O
;	O
case	O
52	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_var	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
)	O
;	O
}	O
break	O
;	O
case	O
53	int
:	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"undefined variable: %s"	*(char)
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
54	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_asgn	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
55	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
56	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
57	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_check	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
58	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_check	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
59	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_asgn	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
NULL	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
60	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_attr_asgn	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
61	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_call	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
62	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_builtin	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
btin	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
63	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Add	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
64	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Sub	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
65	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Mul	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
66	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Div	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
67	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Rem	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
68	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
BOr	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
69	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
BAnd	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
70	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
BXor	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
71	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Shl	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
72	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Shr	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
73	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
And	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
74	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Or	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
75	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_un	O
(	O
Neg	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
76	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
77	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_un	O
(	O
Not	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
78	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
79	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_coerce	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
80	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Eq	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
81	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Ne	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
82	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Lt	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
83	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Le	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
84	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Gt	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
85	int
:	O
{	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_bin	O
(	O
Ge	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
86	int
:	O
{	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
if	O
(	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
compile_regexp	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_match	O
(	O
0	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
}	O
break	O
;	O
case	O
87	int
:	O
{	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
if	O
(	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
compile_regexp	O
(	O
(	O
rw_yyvsp	O
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(*(char))
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	O
.	O
mtx	O
)	O
=	O
mtx_match	O
(	O
1	int
,	O
(	O
rw_yyvsp	O
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	O
)	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
rw_yyr1	O
[	O
rw_yyn	O
]	O
,	O
&	O
rw_yyval	O
,	O
&	O
rw_yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	O
)	O
;	O
rw_yylen	O
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	O
,	O
rw_yyssp	O
)	O
;	O
*	O
++	O
rw_yyvsp	O
=	O
rw_yyval	O
;	O
rw_yyn	O
=	O
rw_yyr1	O
[	O
rw_yyn	O
]	O
;	O
rw_yystate	O
=	O
rw_yypgoto	O
[	O
rw_yyn	O
-	O
YYNTOKENS	O
]	O
+	O
*	O
rw_yyssp	O
;	O
if	O
(	O
0	int
<=	O
rw_yystate	O
&&	O
rw_yystate	O
<=	O
YYLAST	O
&&	O
rw_yycheck	O
[	O
rw_yystate	O
]	O
==	O
*	O
rw_yyssp	O
)	O
rw_yystate	O
=	O
rw_yytable	O
[	O
rw_yystate	O
]	O
;	O
else	O
rw_yystate	O
=	O
rw_yydefgoto	O
[	O
rw_yyn	O
-	O
YYNTOKENS	O
]	O
;	O
goto	O
rw_yynewstate	O
;	O
rw_yyerrlab	O
:	O
if	O
(	O
!	O
rw_yyerrstatus	O
)	O
{	O
++	O
rw_yynerrs	O
;	O
rw_yyerror	O
(	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
rw_yyerrstatus	O
==	O
3	int
)	O
{	O
if	O
(	O
rw_yychar	O
<=	O
YYEOF	O
)	O
{	O
if	O
(	O
rw_yychar	O
==	O
YYEOF	O
)	O
YYABORT	O
;	O
}	O
else	O
{	O
rw_yydestruct	O
(	O
"Error: discarding"	*(char)
,	O
rw_yytoken	O
,	O
&	O
rw_yylval	O
)	O
;	O
rw_yychar	O
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
rw_yyerrlab1	O
;	O
rw_yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
rw_yyerrorlab	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	O
)	O
;	O
rw_yylen	O
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	O
,	O
rw_yyssp	O
)	O
;	O
rw_yystate	O
=	O
*	O
rw_yyssp	O
;	O
goto	O
rw_yyerrlab1	O
;	O
rw_yyerrlab1	O
:	O
rw_yyerrstatus	O
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
rw_yyn	O
=	O
rw_yypact	O
[	O
rw_yystate	O
]	O
;	O
if	O
(	O
rw_yyn	O
!=	O
YYPACT_NINF	O
)	O
{	O
rw_yyn	O
+=	O
YYTERROR	O
;	O
if	O
(	O
0	int
<=	O
rw_yyn	O
&&	O
rw_yyn	O
<=	O
YYLAST	O
&&	O
rw_yycheck	O
[	O
rw_yyn	O
]	O
==	O
YYTERROR	O
)	O
{	O
rw_yyn	O
=	O
rw_yytable	O
[	O
rw_yyn	O
]	O
;	O
if	O
(	O
0	int
<	O
rw_yyn	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
rw_yyssp	O
==	O
rw_yyss	O
)	O
YYABORT	O
;	O
rw_yydestruct	O
(	O
"Error: popping"	*(char)
,	O
rw_yystos	O
[	O
rw_yystate	O
]	O
,	O
rw_yyvsp	O
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
rw_yystate	O
=	O
*	O
rw_yyssp	O
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	O
,	O
rw_yyssp	O
)	O
;	O
}	O
if	O
(	O
rw_yyn	O
==	O
YYFINAL	O
)	O
YYACCEPT	O
;	O
*	O
++	O
rw_yyvsp	O
=	O
rw_yylval	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
rw_yystos	O
[	O
rw_yyn	O
]	O
,	O
rw_yyvsp	O
,	O
rw_yylsp	O
)	O
;	O
rw_yystate	O
=	O
rw_yyn	O
;	O
goto	O
rw_yynewstate	O
;	O
rw_yyacceptlab	O
:	O
rw_yyresult	O
=	O
0	int
;	O
goto	O
rw_yyreturn	O
;	O
rw_yyabortlab	O
:	O
rw_yyresult	O
=	O
1	int
;	O
goto	O
rw_yyreturn	O
;	O
rw_yyexhaustedlab	O
:	O
rw_yyerror	O
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
rw_yyresult	O
=	O
2	int
;	O
rw_yyreturn	O
:	O
if	O
(	O
rw_yychar	O
!=	O
YYEOF	O
&&	O
rw_yychar	O
!=	O
YYEMPTY	O
)	O
rw_yydestruct	O
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
rw_yytoken	O
,	O
&	O
rw_yylval	O
)	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	O
)	O
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	O
,	O
rw_yyssp	O
)	O
;	O
while	O
(	O
rw_yyssp	O
!=	O
rw_yyss	O
)	O
{	O
rw_yydestruct	O
(	O
"Cleanup: popping"	*(char)
,	O
rw_yystos	O
[	O
*	O
rw_yyssp	O
]	O
,	O
rw_yyvsp	O
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
rw_yyss	O
!=	O
rw_yyssa	O
)	O
YYSTACK_FREE	O
(	O
rw_yyss	O
)	O
;	O
return	O
YYID	O
(	O
rw_yyresult	O
)	O
;	O
}	O
int	O
rw_yyerror	O
(	O
char	O
*	O
s	*(*(char))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
"%s"	*(char)
,	O
s	*(*(char))
)	O
;	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
int	O
parse_rewrite	(*(char))->(int)
(	O
char	O
*	O
path	O
)	O
{	O
locus	O
.	O
file	*(char)
=	O
path	O
;	O
infile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
locus	O
.	O
file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
infile	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
|	O
GRAD_LOG_PERROR	O
,	O
_	O
(	O
"can't open file `%s'"	*(char)
)	O
,	O
locus	O
.	O
file	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
2	int
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"Loading file %s"	*(char)
,	O
locus	O
.	O
file	*(char)
)	O
;	O
rw_code_lock	O
(	O
)	O
;	O
rw_yyeof	O
=	O
0	int
;	O
locus	O
.	O
line	long
=	O
1	int
;	O
errcnt	long
=	O
0	int
;	O
regex_init	O
(	O
)	O
;	O
obstack_init	O
(	O
&	O
input_stk	O
)	O
;	O
mtx_init	O
(	O
)	O
;	O
var_init	O
(	O
)	O
;	O
loop_init	O
(	O
)	O
;	O
frame_init	O
(	O
)	O
;	O
frame_push	O
(	O
)	O
;	O
rw_yyparse	O
(	O
)	O
;	O
var_free_all	O
(	O
)	O
;	O
frame_free_all	O
(	O
)	O
;	O
mtx_free_all	O
(	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
input_stk	O
,	O
NULL	O
)	O
;	O
rw_code_unlock	O
(	O
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
parse_rewrite_string	O
(	O
char	O
*	O
str	*(char)
)	O
{	O
rw_code_lock	O
(	O
)	O
;	O
code_check	O
(	O
)	O
;	O
rw_yyeof	O
=	O
0	int
;	O
locus	O
.	O
file	*(char)
=	O
"<string>"	*(char)
;	O
locus	O
.	O
line	long
=	O
1	int
;	O
errcnt	long
=	O
0	int
;	O
regex_init	O
(	O
)	O
;	O
obstack_init	O
(	O
&	O
input_stk	O
)	O
;	O
mtx_init	O
(	O
)	O
;	O
var_init	O
(	O
)	O
;	O
loop_init	O
(	O
)	O
;	O
frame_init	O
(	O
)	O
;	O
frame_push	O
(	O
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
50	int
)	O
)	O
rw_yydebug	O
++	O
;	O
infile	O
=	O
0	int
;	O
inbuf	O
=	O
curp	O
=	O
str	*(char)
;	O
rw_yyparse	O
(	O
)	O
;	O
var_free_all	O
(	O
)	O
;	O
frame_free_all	O
(	O
)	O
;	O
mtx_free_all	O
(	O
)	O
;	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
input_stk	O
,	O
NULL	O
)	O
;	O
rw_code_unlock	O
(	O
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
unput	O
(	O
int	O
c	*(void)
)	O
{	O
if	O
(	O
!	O
c	*(void)
)	O
return	O
0	int
;	O
if	O
(	O
infile	O
)	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	*(void)
,	O
infile	O
)	O
;	O
else	O
if	O
(	O
curp	O
>	O
inbuf	O
)	O
*	O
--	O
curp	O
=	O
c	*(void)
;	O
return	O
c	*(void)
;	O
}	O
static	O
int	O
input	*(void)
(	O
)	O
{	O
if	O
(	O
rw_yyeof	O
)	O
rw_yychar	O
=	O
0	int
;	O
else	O
if	O
(	O
infile	O
)	O
{	O
if	O
(	O
(	O
rw_yychar	O
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infile	O
)	O
)	O
<=	O
0	int
)	O
{	O
rw_yyeof	O
++	O
;	O
rw_yychar	O
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
curp	O
)	O
{	O
rw_yychar	O
=	O
*	O
curp	O
++	O
;	O
if	O
(	O
!	O
rw_yychar	O
)	O
rw_yyeof	O
++	O
;	O
}	O
return	O
rw_yychar	O
;	O
}	O
static	O
int	O
rw_backslash	O
(	O
)	O
;	O
static	O
int	O
c2d	O
(	O
int	O
c	*(void)
)	O
;	O
static	O
int	O
read_number	O
(	O
)	O
;	O
static	O
int	O
read_num	O
(	O
int	O
n	long
,	O
int	O
base	int
)	O
;	O
static	O
char	O
*	O
read_string	O
(	O
)	O
;	O
static	O
char	O
*	O
read_ident	O
(	O
int	O
c	*(void)
)	O
;	O
static	O
char	O
*	O
read_to_delim	O
(	O
int	O
c	*(void)
)	O
;	O
static	O
int	O
skip_to_nl	O
(	O
)	O
;	O
static	O
int	O
c_comment	O
(	O
)	O
;	O
int	O
c2d	O
(	O
int	O
c	*(void)
)	O
{	O
switch	O
(	O
c	*(void)
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
return	O
c	*(void)
-	O
'0'	O
;	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
return	O
c	*(void)
-	O
'A'	O
+	O
16	int
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
return	O
c	*(void)
-	O
'a'	O
+	O
10	int
;	O
}	O
return	O
100	int
;	O
}	O
int	O
read_number	O
(	O
)	O
{	O
int	O
c	*(void)
;	O
int	O
base	int
;	O
int	O
res	O
;	O
c	*(void)
=	O
rw_yychar	O
;	O
if	O
(	O
c	*(void)
==	O
'0'	O
)	O
{	O
if	O
(	O
input	*(void)
(	O
)	O
==	O
'x'	O
||	O
rw_yychar	O
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
}	O
else	O
{	O
base	int
=	O
8	int
;	O
unput	O
(	O
rw_yychar	O
)	O
;	O
}	O
}	O
else	O
base	int
=	O
10	int
;	O
res	O
=	O
read_num	O
(	O
c2d	O
(	O
c	*(void)
)	O
,	O
base	int
)	O
;	O
if	O
(	O
base	int
==	O
10	int
&&	O
rw_yychar	O
==	O
'.'	O
)	O
{	O
int	O
n	long
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
3	int
&&	O
rw_yychar	O
==	O
'.'	O
;	O
n	long
++	O
)	O
{	O
int	O
val	array(int)
;	O
input	*(void)
(	O
)	O
;	O
val	array(int)
=	O
read_num	O
(	O
0	int
,	O
base	int
)	O
;	O
res	O
=	O
(	O
res	O
<<	O
8	int
)	O
+	O
val	array(int)
;	O
}	O
if	O
(	O
n	long
!=	O
3	int
)	O
res	O
<<=	O
8	int
*	O
(	O
3	int
-	O
n	long
)	O
;	O
}	O
return	O
res	O
;	O
}	O
int	O
read_num	O
(	O
int	O
n	long
,	O
int	O
base	int
)	O
{	O
int	O
d	*(char)
;	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
(	O
d	*(char)
=	O
c2d	O
(	O
rw_yychar	O
)	O
)	O
<	O
16	int
)	O
n	long
=	O
n	long
*	O
base	int
+	O
d	*(char)
;	O
unput	O
(	O
rw_yychar	O
)	O
;	O
return	O
n	long
;	O
}	O
int	O
rw_backslash	O
(	O
)	O
{	O
switch	O
(	O
input	*(void)
(	O
)	O
)	O
{	O
case	O
'\\'	O
:	O
return	O
'\\'	O
;	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'e'	O
:	O
return	O
'\033'	O
;	O
case	O
'0'	O
:	O
return	O
read_number	O
(	O
)	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
return	O
read_num	O
(	O
0	int
,	O
16	int
)	O
;	O
case	O
'('	O
:	O
case	O
')'	O
:	O
unput	O
(	O
rw_yychar	O
)	O
;	O
rw_yychar	O
=	O
'\\'	O
;	O
}	O
return	O
rw_yychar	O
;	O
}	O
char	O
*	O
read_string	O
(	O
)	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
rw_yychar	O
!=	O
'"'	O
)	O
{	O
if	O
(	O
rw_yychar	O
==	O
'\\'	O
)	O
rw_yychar	O
=	O
rw_backslash	O
(	O
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
rw_yychar	O
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	O
)	O
;	O
}	O
char	O
*	O
read_to_delim	O
(	O
int	O
c	*(void)
)	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
rw_yychar	O
!=	O
c	*(void)
)	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
rw_yychar	O
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	O
)	O
;	O
}	O
char	O
*	O
read_ident	O
(	O
int	O
c	*(void)
)	O
{	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
c	*(void)
)	O
;	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
isword	O
(	O
rw_yychar	O
)	O
)	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
rw_yychar	O
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	O
,	O
0	int
)	O
;	O
unput	O
(	O
rw_yychar	O
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	O
)	O
;	O
}	O
int	O
skip_to_nl	O
(	O
)	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
rw_yychar	O
!=	O
'\n'	O
)	O
;	O
return	O
unput	O
(	O
rw_yychar	O
)	O
;	O
}	O
int	O
c_comment	O
(	O
)	O
{	O
if	O
(	O
rw_yychar	O
!=	O
'/'	O
)	O
return	O
0	int
;	O
if	O
(	O
input	*(void)
(	O
)	O
==	O
'*'	O
)	O
{	O
size_t	long
keep_line	O
=	O
locus	O
.	O
line	long
;	O
do	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
!=	O
'*'	O
)	O
{	O
if	O
(	O
rw_yychar	O
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"unexpected EOF in comment started at line %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
keep_line	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
rw_yychar	O
==	O
'\n'	O
)	O
locus	O
.	O
line	long
++	O
;	O
}	O
}	O
while	O
(	O
input	*(void)
(	O
)	O
!=	O
'/'	O
)	O
;	O
return	O
1	int
;	O
}	O
unput	O
(	O
rw_yychar	O
)	O
;	O
rw_yychar	O
=	O
'/'	O
;	O
return	O
0	int
;	O
}	O
enum	O
pragma_handler_phase	O
{	O
pragma_begin	O
,	O
pragma_cont	O
,	O
pragma_error	O
,	O
pragma_end	O
}	O
;	O
typedef	O
int	O
(	O
*	O
pragma_handler_fp	O
)	O
(	O
enum	O
pragma_handler_phase	O
)	O
;	O
static	O
int	O
regex_pragma	O
(	O
enum	O
pragma_handler_phase	O
phase	O
)	O
{	O
int	O
disable	O
=	O
0	int
;	O
int	O
bit	O
;	O
char	O
*	O
s	*(*(char))
;	O
static	O
int	O
regexp_accum	O
;	O
switch	O
(	O
phase	O
)	O
{	O
case	O
pragma_begin	O
:	O
regexp_accum	O
=	O
0	int
;	O
return	O
0	int
;	O
case	O
pragma_end	O
:	O
regcomp_flags	O
=	O
regexp_accum	O
;	O
return	O
0	int
;	O
case	O
pragma_error	O
:	O
return	O
0	int
;	O
case	O
pragma_cont	O
:	O
break	O
;	O
}	O
switch	O
(	O
rw_yychar	O
)	O
{	O
case	O
'+'	O
:	O
disable	O
=	O
0	int
;	O
input	*(void)
(	O
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
disable	O
=	O
1	int
;	O
input	*(void)
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
isword	O
(	O
rw_yychar	O
)	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"Malformed pragma"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
s	*(*(char))
=	O
read_ident	O
(	O
rw_yychar	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(*(char))
,	O
"extended"	*(char)
)	O
==	O
0	int
)	O
bit	O
=	O
REG_EXTENDED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(*(char))
,	O
"icase"	*(char)
)	O
==	O
0	int
)	O
bit	O
=	O
REG_ICASE	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(*(char))
,	O
"newline"	*(char)
)	O
==	O
0	int
)	O
bit	O
=	O
REG_NEWLINE	O
;	O
else	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"Unknown regexp flag: %s"	*(char)
)	O
,	O
s	*(*(char))
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
disable	O
)	O
regexp_accum	O
&=	O
~	O
bit	O
;	O
else	O
regexp_accum	O
|=	O
bit	O
;	O
return	O
0	int
;	O
}	O
static	O
pragma_handler_fp	O
find_pragma_handler	O
(	O
char	O
*	O
s	*(*(char))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(*(char))
,	O
"regex"	*(char)
)	O
==	O
0	int
)	O
return	O
regex_pragma	O
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
handle_pragma	O
(	O
)	O
{	O
int	O
rc	O
;	O
pragma_handler_fp	O
pragma_handler	O
;	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	O
)	O
)	O
;	O
if	O
(	O
rw_yychar	O
==	O
0	int
)	O
return	O
;	O
pragma_handler	O
=	O
find_pragma_handler	O
(	O
read_ident	O
(	O
rw_yychar	O
)	O
)	O
;	O
if	O
(	O
pragma_handler	O
)	O
{	O
pragma_handler	O
(	O
pragma_begin	O
)	O
;	O
do	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	O
)	O
)	O
;	O
if	O
(	O
rw_yychar	O
==	O
0	int
||	O
rw_yychar	O
==	O
'\n'	O
)	O
break	O
;	O
rc	O
=	O
pragma_handler	O
(	O
pragma_cont	O
)	O
;	O
}	O
while	O
(	O
rc	O
==	O
0	int
&&	O
rw_yychar	O
!=	O
'\n'	O
&&	O
rw_yychar	O
!=	O
0	int
)	O
;	O
pragma_handler	O
(	O
rc	O
?	O
pragma_error	O
:	O
pragma_end	O
)	O
;	O
}	O
}	O
void	O
sharp_comment	O
(	O
)	O
{	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	O
)	O
)	O
;	O
if	O
(	O
rw_yychar	O
==	O
0	int
)	O
return	O
;	O
else	O
if	O
(	O
rw_yychar	O
==	O
'\n'	O
)	O
{	O
locus	O
.	O
line	long
++	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
isword	O
(	O
rw_yychar	O
)	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
read_ident	O
(	O
rw_yychar	O
)	O
,	O
"pragma"	*(char)
)	O
==	O
0	int
)	O
handle_pragma	O
(	O
)	O
;	O
}	O
skip_to_nl	O
(	O
)	O
;	O
}	O
static	O
grad_keyword_t	struct
rw_kw	O
[	O
]	O
=	O
{	O
{	O
"if"	*(char)
,	O
IF	int
}	O
,	O
{	O
"else"	*(char)
,	O
ELSE	int
}	O
,	O
{	O
"return"	*(char)
,	O
RETURN	int
}	O
,	O
{	O
"for"	*(char)
,	O
FOR	int
}	O
,	O
{	O
"do"	*(char)
,	O
DO	int
}	O
,	O
{	O
"while"	*(char)
,	O
WHILE	int
}	O
,	O
{	O
"break"	*(char)
,	O
BREAK	int
}	O
,	O
{	O
"continue"	*(char)
,	O
CONTINUE	int
}	O
,	O
{	O
"delete"	*(char)
,	O
DELETE	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
rw_yylex	O
(	O
)	O
{	O
int	O
nl	int
;	O
int	O
c	*(void)
;	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
btin	O
;	O
do	O
{	O
nl	int
=	O
0	int
;	O
while	O
(	O
input	*(void)
(	O
)	O
&&	O
isspace	(int)->(int)
(	O
rw_yychar	O
)	O
)	O
if	O
(	O
rw_yychar	O
==	O
'\n'	O
)	O
locus	O
.	O
line	long
++	O
;	O
if	O
(	O
!	O
rw_yychar	O
)	O
return	O
0	int
;	O
if	O
(	O
rw_yychar	O
==	O
'#'	O
)	O
{	O
sharp_comment	O
(	O
)	O
;	O
nl	int
=	O
1	int
;	O
}	O
}	O
while	O
(	O
nl	int
||	O
c_comment	O
(	O
)	O
)	O
;	O
if	O
(	O
rw_yychar	O
==	O
'\\'	O
)	O
{	O
input	*(void)
(	O
)	O
;	O
rw_yylval	O
.	O
number	long
=	O
read_number	O
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"REFERENCE %d"	*(char)
,	O
rw_yylval	O
.	O
number	long
)	O
;	O
return	O
REFERENCE	int
;	O
}	O
if	O
(	O
rw_yychar	O
==	O
'\''	O
)	O
{	O
if	O
(	O
input	*(void)
(	O
)	O
==	O
'\\'	O
)	O
c	*(void)
=	O
rw_backslash	O
(	O
)	O
;	O
else	O
c	*(void)
=	O
rw_yychar	O
;	O
if	O
(	O
input	*(void)
(	O
)	O
!=	O
'\''	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unterminated character constant"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
rw_yylval	O
.	O
number	long
=	O
c	*(void)
;	O
DEBUG_LEX2	O
(	O
"CHAR %d"	*(char)
,	O
c	*(void)
)	O
;	O
return	O
NUMBER	int
;	O
}	O
if	O
(	O
isdigit	(int)->(int)
(	O
rw_yychar	O
)	O
)	O
{	O
rw_yylval	O
.	O
number	long
=	O
read_number	O
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"NUMBER %d"	*(char)
,	O
rw_yylval	O
.	O
number	long
)	O
;	O
return	O
NUMBER	int
;	O
}	O
if	O
(	O
rw_yychar	O
==	O
'"'	O
)	O
{	O
rw_yylval	O
.	O
string	*(*(char))
=	O
read_string	O
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"STRING %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
return	O
STRING	int
;	O
}	O
if	O
(	O
rw_yychar	O
==	O
'%'	O
)	O
{	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
0	int
;	O
char	O
*	O
attr_name	O
;	O
input	*(void)
(	O
)	O
;	O
if	O
(	O
rw_yychar	O
==	O
'['	O
||	O
rw_yychar	O
==	O
'{'	O
)	O
{	O
attr_name	O
=	O
read_to_delim	O
(	O
rw_yychar	O
==	O
'['	O
?	O
']'	O
:	O
'}'	O
)	O
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
grad_attr_name_to_dict	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
attr_name	O
)	O
;	O
}	O
else	O
{	O
unput	O
(	O
rw_yychar	O
)	O
;	O
return	O
'%'	O
;	O
}	O
if	O
(	O
!	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"unknown attribute `%s'"	*(char)
)	O
,	O
attr_name	O
)	O
;	O
errcnt	long
++	O
;	O
return	O
BOGUS	int
;	O
}	O
rw_yylval	O
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
DEBUG_LEX2	O
(	O
"ATTR: %s"	*(char)
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
name	*(char)
)	O
;	O
return	O
ATTR	int
;	O
}	O
if	O
(	O
isword	O
(	O
rw_yychar	O
)	O
)	O
{	O
rw_yylval	O
.	O
string	*(*(char))
=	O
read_ident	O
(	O
rw_yychar	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
rw_yylval	O
.	O
string	*(*(char))
,	O
"integer"	*(char)
)	O
==	O
0	int
)	O
{	O
DEBUG_LEX1	O
(	O
"TYPE(Integer)"	*(char)
)	O
;	O
rw_yylval	O
.	O
type	int
=	O
Integer	int
;	O
return	O
TYPE	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
rw_yylval	O
.	O
string	*(*(char))
,	O
"string"	*(char)
)	O
==	O
0	int
)	O
{	O
DEBUG_LEX1	O
(	O
"TYPE(String)"	*(char)
)	O
;	O
rw_yylval	O
.	O
type	int
=	O
String	int
;	O
return	O
TYPE	int
;	O
}	O
if	O
(	O
(	O
c	*(void)
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
rw_kw	O
,	O
rw_yylval	O
.	O
string	*(*(char))
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
DEBUG_LEX2	O
(	O
"KW: %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
return	O
c	*(void)
;	O
}	O
if	O
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var_lookup	O
(	O
rw_yylval	O
.	O
string	*(*(char))
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"VARIABLE: %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
rw_yylval	O
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
return	O
VARIABLE	int
;	O
}	O
if	O
(	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"FUN %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
rw_yylval	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
return	O
FUN	int
;	O
}	O
if	O
(	O
btin	O
=	O
builtin_lookup	O
(	O
rw_yylval	O
.	O
string	*(*(char))
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"BUILTIN %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
rw_yylval	O
.	O
btin	O
=	O
btin	O
;	O
return	O
BUILTIN	int
;	O
}	O
DEBUG_LEX2	O
(	O
"IDENT: %s"	*(char)
,	O
rw_yylval	O
.	O
string	*(*(char))
)	O
;	O
return	O
IDENT	int
;	O
}	O
if	O
(	O
rw_yychar	O
==	O
'&'	O
||	O
rw_yychar	O
==	O
'|'	O
)	O
{	O
int	O
c	*(void)
=	O
rw_yychar	O
;	O
if	O
(	O
input	*(void)
(	O
)	O
==	O
c	*(void)
)	O
{	O
DEBUG_LEX2	O
(	O
"%s"	*(char)
,	O
rw_yychar	O
==	O
'&'	O
?	O
"AND"	*(char)
:	O
"OR"	*(char)
)	O
;	O
return	O
rw_yychar	O
==	O
'&'	O
?	O
AND	int
:	O
OR	int
;	O
}	O
unput	O
(	O
rw_yychar	O
)	O
;	O
DEBUG_LEX2	O
(	O
"%c"	*(char)
,	O
c	*(void)
)	O
;	O
return	O
c	*(void)
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"<>=!"	*(char)
,	O
rw_yychar	O
)	O
)	O
{	O
int	O
c	*(void)
=	O
rw_yychar	O
;	O
if	O
(	O
input	*(void)
(	O
)	O
==	O
'='	O
)	O
{	O
switch	O
(	O
c	*(void)
)	O
{	O
case	O
'<'	O
:	O
DEBUG_LEX1	O
(	O
"LE"	*(char)
)	O
;	O
return	O
LE	int
;	O
case	O
'>'	O
:	O
DEBUG_LEX1	O
(	O
"GE"	*(char)
)	O
;	O
return	O
GE	int
;	O
case	O
'='	O
:	O
DEBUG_LEX1	O
(	O
"EQ"	*(char)
)	O
;	O
return	O
EQ	int
;	O
case	O
'!'	O
:	O
DEBUG_LEX1	O
(	O
"NE"	*(char)
)	O
;	O
return	O
NE	int
;	O
}	O
}	O
else	O
if	O
(	O
c	*(void)
==	O
rw_yychar	O
)	O
{	O
if	O
(	O
c	*(void)
==	O
'<'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"SHL"	*(char)
)	O
;	O
return	O
SHL	int
;	O
}	O
if	O
(	O
c	*(void)
==	O
'>'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"SHR"	*(char)
)	O
;	O
return	O
SHR	int
;	O
}	O
unput	O
(	O
rw_yychar	O
)	O
;	O
DEBUG_LEX2	O
(	O
"%c"	*(char)
,	O
rw_yychar	O
)	O
;	O
return	O
rw_yychar	O
;	O
}	O
else	O
if	O
(	O
rw_yychar	O
==	O
'~'	O
)	O
{	O
if	O
(	O
c	*(void)
==	O
'='	O
)	O
{	O
DEBUG_LEX1	O
(	O
"MT"	*(char)
)	O
;	O
return	O
MT	int
;	O
}	O
if	O
(	O
c	*(void)
==	O
'!'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"NM"	*(char)
)	O
;	O
return	O
NM	int
;	O
}	O
}	O
unput	O
(	O
rw_yychar	O
)	O
;	O
switch	O
(	O
c	*(void)
)	O
{	O
case	O
'<'	O
:	O
DEBUG_LEX1	O
(	O
"LT"	*(char)
)	O
;	O
return	O
LT	int
;	O
case	O
'>'	O
:	O
DEBUG_LEX1	O
(	O
"GT"	*(char)
)	O
;	O
return	O
GT	int
;	O
case	O
'!'	O
:	O
DEBUG_LEX1	O
(	O
"NOT"	*(char)
)	O
;	O
return	O
NOT	int
;	O
default	O
:	O
return	O
c	*(void)
;	O
}	O
}	O
DEBUG_LEX2	O
(	O
"%c"	*(char)
,	O
rw_yychar	O
)	O
;	O
return	O
rw_yychar	O
;	O
}	O
void	O
rw_yysync	O
(	O
)	O
{	O
while	O
(	O
skip_to_nl	O
(	O
)	O
==	O
'\n'	O
&&	O
!	O
isalpha	(int)->(int)
(	O
input	*(void)
(	O
)	O
)	O
)	O
locus	O
.	O
line	long
++	O
;	O
unput	O
(	O
rw_yychar	O
)	O
;	O
}	O
static	O
RWLIST	struct
*	O
_list_insert	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
RWLIST	struct
*	O
obj	O
,	O
int	O
before	O
)	O
;	O
static	O
RWLIST	struct
*	O
_list_remove	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
obj	O
)	O
;	O
static	O
RWLIST	struct
*	O
_list_append	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
obj	O
)	O
;	O
RWLIST	struct
*	O
_list_append	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
obj	O
)	O
{	O
return	O
rw_list_insert	O
(	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
last	O
,	O
*	O
last	O
,	O
obj	O
,	O
0	int
)	O
;	O
}	O
RWLIST	struct
*	O
_list_insert	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
RWLIST	struct
*	O
obj	O
,	O
int	O
before	O
)	O
{	O
RWLIST	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
!	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
{	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
=	O
obj	O
;	O
if	O
(	O
last	O
)	O
*	O
last	O
=	O
obj	O
;	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
return	O
obj	O
;	O
}	O
if	O
(	O
before	O
)	O
{	O
_list_insert	O
(	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
last	O
,	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
obj	O
,	O
0	int
)	O
;	O
_list_remove	O
(	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
last	O
,	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
;	O
_list_insert	O
(	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
last	O
,	O
obj	O
,	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
0	int
)	O
;	O
return	O
obj	O
;	O
}	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
obj	O
;	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
obj	O
;	O
if	O
(	O
last	O
&&	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
==	O
*	O
last	O
)	O
*	O
last	O
=	O
obj	O
;	O
return	O
obj	O
;	O
}	O
RWLIST	struct
*	O
_list_remove	O
(	O
RWLIST	struct
*	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
RWLIST	struct
*	O
*	O
last	O
,	O
RWLIST	struct
*	O
obj	O
)	O
{	O
RWLIST	struct
*	O
temp	union(long,*(void))
;	O
if	O
(	O
temp	union(long,*(void))
=	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
temp	union(long,*(void))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
else	O
*	O
first	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
=	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
temp	union(long,*(void))
=	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
temp	union(long,*(void))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
else	O
if	O
(	O
last	O
)	O
*	O
last	O
=	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
obj	O
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
obj	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
return	O
obj	O
;	O
}	O
void	O
*	O
obj_alloc	O
(	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
*	O
bucket	O
)	O
;	O
void	O
obj_free_all	O
(	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
*	O
bucket	O
)	O
;	O
void	O
*	O
obj_alloc	O
(	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
*	O
bucket	O
)	O
{	O
OBJECT	struct
*	O
optr	O
;	O
optr	O
=	O
grad_emalloc	(long)->(*(void))
(	O
bucket	O
->	O
size	int
)	O
;	O
optr	O
->	O
alloc	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
bucket	O
->	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
;	O
bucket	O
->	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
optr	O
;	O
return	O
optr	O
;	O
}	O
void	O
obj_free_all	O
(	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
*	O
bucket	O
)	O
{	O
OBJECT	struct
*	O
obj	O
,	O
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
obj	O
=	O
bucket	O
->	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
obj	O
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
obj	O
->	O
alloc	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
bucket	O
->	O
free	*((*(void),*(void))->(int))
)	O
bucket	O
->	O
free	*((*(void),*(void))->(int))
(	O
obj	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
obj	O
)	O
;	O
obj	O
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
bucket	O
->	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
void	O
frame_init	O
(	O
)	O
{	O
frame_bkt	O
.	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
frame_first	O
=	O
frame_last	O
=	O
NULL	O
;	O
}	O
void	O
frame_push	O
(	O
)	O
{	O
FRAME	O
*	O
this_frame	O
=	O
obj_alloc	O
(	O
&	O
frame_bkt	O
)	O
;	O
if	O
(	O
!	O
frame_last	O
)	O
{	O
this_frame	O
->	O
level	int
=	O
0	int
;	O
this_frame	O
->	O
stack_offset	O
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
frame_last	O
->	O
level	int
==	O
0	int
)	O
this_frame	O
->	O
stack_offset	O
=	O
1	int
;	O
else	O
this_frame	O
->	O
stack_offset	O
=	O
frame_last	O
->	O
stack_offset	O
;	O
this_frame	O
->	O
level	int
=	O
frame_last	O
->	O
level	int
+	O
1	int
;	O
}	O
rw_list_append	O
(	O
&	O
frame_first	O
,	O
&	O
frame_last	O
,	O
this_frame	O
)	O
;	O
}	O
void	O
frame_pop	O
(	O
)	O
{	O
rw_list_remove	O
(	O
&	O
frame_first	O
,	O
&	O
frame_last	O
,	O
frame_last	O
)	O
;	O
}	O
void	O
frame_update_alloc	O
(	O
)	O
{	O
FRAME	O
*	O
this_frame	O
=	O
frame_last	O
;	O
if	O
(	O
this_frame	O
->	O
stack_offset	O
>	O
function	O
->	O
stack_alloc	int
)	O
function	O
->	O
stack_alloc	int
=	O
this_frame	O
->	O
stack_offset	O
;	O
}	O
void	O
frame_free_all	O
(	O
)	O
{	O
obj_free_all	O
(	O
&	O
frame_bkt	O
)	O
;	O
frame_first	O
=	O
frame_last	O
=	O
NULL	O
;	O
}	O
void	O
frame_unwind_all	O
(	O
)	O
{	O
while	O
(	O
frame_last	O
)	O
rw_list_remove	O
(	O
&	O
frame_first	O
,	O
&	O
frame_last	O
,	O
frame_last	O
)	O
;	O
frame_push	O
(	O
)	O
;	O
}	O
void	O
loop_init	O
(	O
)	O
{	O
loop_bkt	O
.	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
loop_first	O
=	O
loop_last	O
=	O
NULL	O
;	O
}	O
void	O
loop_free_all	O
(	O
)	O
{	O
obj_free_all	O
(	O
&	O
loop_bkt	O
)	O
;	O
loop_first	O
=	O
loop_last	O
=	O
NULL	O
;	O
}	O
void	O
loop_unwind_all	O
(	O
)	O
{	O
loop_first	O
=	O
loop_last	O
=	O
NULL	O
;	O
}	O
void	O
loop_push	O
(	O
MTX	union
*	O
mtx	O
)	O
{	O
LOOP	O
*	O
this_loop	O
=	O
obj_alloc	O
(	O
&	O
loop_bkt	O
)	O
;	O
rw_list_append	O
(	O
&	O
loop_first	O
,	O
&	O
loop_last	O
,	O
this_loop	O
)	O
;	O
}	O
void	O
loop_pop	O
(	O
)	O
{	O
rw_list_remove	O
(	O
&	O
loop_first	O
,	O
&	O
loop_last	O
,	O
loop_last	O
)	O
;	O
}	O
void	O
loop_fixup	O
(	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
list	*(*(struct))
,	O
MTX	union
*	O
target	O
)	O
{	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
jp	O
;	O
for	O
(	O
jp	O
=	O
list	*(*(struct))
;	O
jp	O
;	O
jp	O
=	O
(	O
JUMP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union))
*	O
)	O
jp	O
->	O
link	(*(char),*(char))->(int)
)	O
jp	O
->	O
dest	*(union)
=	O
target	O
;	O
}	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
var_bucket	O
=	O
{	O
sizeof	O
(	O
VAR	struct
)	O
,	O
NULL	O
}	O
;	O
void	O
var_init	O
(	O
)	O
{	O
var_bucket	O
.	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
var_first	O
=	O
var_last	O
=	O
NULL	O
;	O
}	O
VAR	struct
*	O
var_alloc	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
char	O
*	O
name	*(char)
,	O
int	O
grow	O
)	O
{	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
(	O
VAR	struct
*	O
)	O
obj_alloc	O
(	O
&	O
var_bucket	O
)	O
;	O
rw_list_append	O
(	O
&	O
var_first	O
,	O
&	O
var_last	O
,	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
name	*(char)
=	O
name	*(char)
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
=	O
type	int
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
level	int
=	O
curframe	O
->	O
level	int
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
=	O
curframe	O
->	O
stack_offset	O
;	O
curframe	O
->	O
stack_offset	O
+=	O
grow	O
;	O
return	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
}	O
void	O
var_unwind_level	O
(	O
)	O
{	O
int	O
cnt	O
=	O
0	int
;	O
while	O
(	O
var_last	O
&&	O
var_last	O
->	O
level	int
==	O
curframe	O
->	O
level	int
)	O
{	O
rw_list_remove	O
(	O
&	O
var_first	O
,	O
&	O
var_last	O
,	O
var_last	O
)	O
;	O
cnt	O
++	O
;	O
}	O
if	O
(	O
cnt	O
)	O
frame_update_alloc	O
(	O
)	O
;	O
}	O
void	O
var_unwind_all	O
(	O
)	O
{	O
while	O
(	O
var_last	O
)	O
rw_list_remove	O
(	O
&	O
var_first	O
,	O
&	O
var_last	O
,	O
var_last	O
)	O
;	O
}	O
void	O
var_type	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
{	O
for	O
(	O
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
dcllink	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
=	O
type	int
;	O
}	O
void	O
var_free_all	O
(	O
)	O
{	O
obj_free_all	O
(	O
&	O
var_bucket	O
)	O
;	O
var_first	O
=	O
var_last	O
=	O
NULL	O
;	O
}	O
VAR	struct
*	O
var_lookup	O
(	O
char	O
*	O
name	*(char)
)	O
{	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var_last	O
;	O
while	O
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
&&	O
strcmp	(*(char),*(char))->(int)
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
return	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
}	O
OBUCKET	struct(long,*(()->(void)),*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
mtx_bucket	O
=	O
{	O
sizeof	O
(	O
MTX	union
)	O
,	O
NULL	O
}	O
;	O
void	O
mtx_insert	O
(	O
MTX	union
*	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
MTX	union
*	O
mtx	O
)	O
{	O
MTX	union
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
;	O
rw_list_insert	O
(	O
&	O
mtx_first	O
,	O
&	O
mtx_last	O
,	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
mtx	O
,	O
0	int
)	O
;	O
if	O
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
=	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
gen	O
.	O
uplink	*(union)
)	O
{	O
switch	O
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
gen	O
.	O
type	int
)	O
{	O
case	O
Unary	int
:	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
un	O
.	O
arg	*(union)
=	O
mtx	O
;	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
==	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
=	O
mtx	O
;	O
else	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
bin	O
.	O
arg	*(union)
[	O
1	int
]	O
=	O
mtx	O
;	O
break	O
;	O
case	O
Return	int
:	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
ret	O
.	O
expr	*(char)
=	O
mtx	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
void	O
mtx_init	O
(	O
)	O
{	O
mtx_bucket	O
.	O
alloc_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
mtx_first	O
=	O
mtx_last	O
=	O
NULL	O
;	O
}	O
void	O
mtx_unwind_all	O
(	O
)	O
{	O
while	O
(	O
mtx_last	O
)	O
rw_list_remove	O
(	O
&	O
mtx_first	O
,	O
&	O
mtx_last	O
,	O
mtx_last	O
)	O
;	O
}	O
void	O
mtx_free_all	O
(	O
)	O
{	O
obj_free_all	O
(	O
&	O
mtx_bucket	O
)	O
;	O
mtx_first	O
=	O
mtx_last	O
=	O
NULL	O
;	O
}	O
MTX	union
*	O
mtx_cur	O
(	O
)	O
{	O
return	O
mtx_last	O
;	O
}	O
MTX	union
*	O
mtx_frame	O
(	O
Mtxtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	int
,	O
stkoff_t	int
stksize	O
)	O
{	O
FRAME_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
mtx	O
=	O
(	O
FRAME_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
)	O
mtx_alloc	O
(	O
type	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
stacksize	int
=	O
stksize	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_nop	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Nop	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
return	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_jump	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Jump	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
return	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_stop	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Stop	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
return	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_pop	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Pop	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
return	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_return	O
(	O
MTX	union
*	O
arg	*(union)
)	O
{	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Return	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
ret	O
.	O
expr	*(char)
=	O
arg	*(union)
;	O
arg	*(union)
->	O
gen	O
.	O
uplink	*(union)
=	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_alloc	O
(	O
Mtxtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	int
)	O
{	O
MTX	union
*	O
mtx	O
=	O
obj_alloc	O
(	O
&	O
mtx_bucket	O
)	O
;	O
mtx	O
->	O
gen	O
.	O
type	int
=	O
type	int
;	O
mtx	O
->	O
gen	O
.	O
loc	struct(*(char),long)
=	O
locus	O
;	O
return	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_const	O
(	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
CONST_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),union(int,struct(long,*(char))))
*	O
mtx	O
=	O
(	O
CONST_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),union(int,struct(long,*(char))))
*	O
)	O
mtx_alloc	O
(	O
Constant	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
val	array(int)
->	O
type	int
;	O
mtx	O
->	O
datum	union(int,struct(long,*(char)))
=	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_ref	O
(	O
int	O
num	int
)	O
{	O
MATCHREF_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int)
*	O
mtx	O
=	O
(	O
MATCHREF_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int)
*	O
)	O
mtx_alloc	O
(	O
Matchref	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
String	int
;	O
mtx	O
->	O
num	int
=	O
num	int
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_var	O
(	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
)	O
{	O
VAR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))))
*	O
mtx	O
=	O
(	O
VAR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))))
*	O
)	O
mtx_alloc	O
(	O
Variable	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
;	O
mtx	O
->	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_asgn	O
(	O
VAR	struct
*	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
,	O
MTX	union
*	O
arg	*(union)
)	O
{	O
ASGN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))),*(union))
*	O
mtx	O
=	O
(	O
ASGN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(struct(*`,*`,*`,*`,*`,int,int,enum(int,int,int),int,union`)),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*`)))),*(union))
*	O
)	O
mtx_alloc	O
(	O
Asgn	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
if	O
(	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
!=	O
arg	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
)	O
coerce	O
(	O
arg	*(union)
,	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
)	O
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
datatype	enum(int,int,int)
;	O
mtx	O
->	O
lval	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
=	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
;	O
mtx	O
->	O
arg	*(union)
=	O
arg	*(union)
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
grad_data_type_t	enum(int,int,int)
attr_datatype	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
switch	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	O
:	O
return	O
String	int
;	O
case	O
GRAD_TYPE_DATE	O
:	O
return	O
String	int
;	O
case	O
GRAD_TYPE_INTEGER	O
:	O
case	O
GRAD_TYPE_IPADDR	O
:	O
return	O
Integer	int
;	O
default	O
:	O
grad_insist_fail	O
(	O
"unknown attribute type"	*(char)
)	O
;	O
}	O
}	O
MTX	union
*	O
mtx_attr	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
{	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
mtx	O
=	O
(	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Attr	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
attrno	int
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
attr_datatype	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
;	O
mtx	O
->	O
index	(*(char),int)->(*(char))
=	O
index	(*(char),int)->(*(char))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_attr_check	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
{	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
mtx	O
=	O
(	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Attr_check	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
attrno	int
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
Integer	int
;	O
mtx	O
->	O
index	(*(char),int)->(*(char))
=	O
index	(*(char),int)->(*(char))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
void	O
rw_coercion_warning	O
(	O
grad_data_type_t	enum(int,int,int)
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
grad_data_type_t	enum(int,int,int)
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
char	O
*	O
pref	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_WARN	O
,	O
&	O
locus	O
,	O
_	O
(	O
"%s implicit coercion %s %s"	*(char)
)	O
,	O
pref	O
?	O
pref	O
:	O
""	*(char)
,	O
datatype_str_abl	O
(	O
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
,	O
datatype_str_acc	O
(	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
)	O
;	O
}	O
MTX	union
*	O
mtx_attr_asgn	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
,	O
MTX	union
*	O
rval	*(union)
)	O
{	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
mtx	O
=	O
(	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Attr_asgn	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
attrno	int
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
attr_datatype	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
;	O
if	O
(	O
rval	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
mtx	O
->	O
datatype	enum(int,int,int)
)	O
{	O
rw_coercion_warning	O
(	O
rval	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
,	O
mtx	O
->	O
datatype	enum(int,int,int)
,	O
NULL	O
)	O
;	O
rval	*(union)
=	O
coerce	O
(	O
rval	*(union)
,	O
mtx	O
->	O
datatype	enum(int,int,int)
)	O
;	O
}	O
mtx	O
->	O
index	(*(char),int)->(*(char))
=	O
index	(*(char),int)->(*(char))
;	O
mtx	O
->	O
rval	*(union)
=	O
rval	*(union)
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_attr_delete	O
(	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
MTX	union
*	O
index	(*(char),int)->(*(char))
)	O
{	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
mtx	O
=	O
(	O
ATTR_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Attr_delete	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
attrno	int
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
attr_datatype	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
;	O
mtx	O
->	O
index	(*(char),int)->(*(char))
=	O
index	(*(char),int)->(*(char))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_bin	O
(	O
Bopcode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
opcode	enum(int,int,int)
,	O
MTX	union
*	O
arg1	O
,	O
MTX	union
*	O
arg2	O
)	O
{	O
BIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(*(union)))
*	O
mtx	O
=	O
(	O
BIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(*(union)))
*	O
)	O
mtx_alloc	O
(	O
Binary	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
if	O
(	O
arg1	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
arg2	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
)	O
{	O
rw_coercion_warning	O
(	O
String	int
,	O
Integer	int
,	O
NULL	O
)	O
;	O
if	O
(	O
arg1	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
==	O
String	int
)	O
arg1	O
=	O
coerce	O
(	O
arg1	O
,	O
Integer	int
)	O
;	O
else	O
arg2	O
=	O
coerce	O
(	O
arg2	O
,	O
Integer	int
)	O
;	O
}	O
switch	O
(	O
arg1	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
)	O
{	O
case	O
String	int
:	O
switch	O
(	O
opcode	enum(int,int,int)
)	O
{	O
case	O
Add	int
:	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
String	int
;	O
break	O
;	O
case	O
Eq	int
:	O
case	O
Ne	int
:	O
case	O
Lt	int
:	O
case	O
Le	int
:	O
case	O
Gt	int
:	O
case	O
Ge	int
:	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
Integer	int
;	O
break	O
;	O
default	O
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"operation not applicable to strings"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
break	O
;	O
case	O
Integer	int
:	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
Integer	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"unknown data type"	*(char)
)	O
;	O
}	O
mtx	O
->	O
opcode	enum(int,int,int)
=	O
opcode	enum(int,int,int)
;	O
mtx	O
->	O
arg	*(union)
[	O
0	int
]	O
=	O
arg1	O
;	O
mtx	O
->	O
arg	*(union)
[	O
1	int
]	O
=	O
arg2	O
;	O
arg1	O
->	O
gen	O
.	O
uplink	*(union)
=	O
arg2	O
->	O
gen	O
.	O
uplink	*(union)
=	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_un	O
(	O
Uopcode	enum(int,int,int)
opcode	enum(int,int,int)
,	O
MTX	union
*	O
arg	*(union)
)	O
{	O
UN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int),*(union))
*	O
mtx	O
=	O
(	O
UN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),enum(int,int,int),*(union))
*	O
)	O
mtx_alloc	O
(	O
Unary	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
if	O
(	O
arg	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
Integer	int
)	O
{	O
rw_coercion_warning	O
(	O
String	int
,	O
Integer	int
,	O
NULL	O
)	O
;	O
coerce	O
(	O
arg	*(union)
,	O
Integer	int
)	O
;	O
}	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
Integer	int
;	O
mtx	O
->	O
opcode	enum(int,int,int)
=	O
opcode	enum(int,int,int)
;	O
mtx	O
->	O
arg	*(union)
=	O
arg	*(union)
;	O
arg	*(union)
->	O
gen	O
.	O
uplink	*(union)
=	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_match	O
(	O
int	O
negated	int
,	O
MTX	union
*	O
arg	*(union)
,	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
{	O
MATCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)))
*	O
mtx	O
=	O
(	O
MATCH_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),int,*(union),*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)))
*	O
)	O
mtx_alloc	O
(	O
Match	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
if	O
(	O
arg	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
String	int
)	O
{	O
rw_coercion_warning	O
(	O
Integer	int
,	O
String	int
,	O
NULL	O
)	O
;	O
coerce	O
(	O
arg	*(union)
,	O
String	int
)	O
;	O
}	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
Integer	int
;	O
mtx	O
->	O
negated	int
=	O
negated	int
;	O
mtx	O
->	O
arg	*(union)
=	O
arg	*(union)
;	O
mtx	O
->	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_cond	O
(	O
MTX	union
*	O
cond	int
,	O
MTX	union
*	O
if_true	*(union)
,	O
MTX	union
*	O
if_false	*(union)
)	O
{	O
COND_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union),*(union))
*	O
mtx	O
=	O
(	O
COND_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(union),*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Cond	int
)	O
;	O
mtx_append	O
(	O
mtx	O
)	O
;	O
mtx	O
->	O
expr	*(char)
=	O
cond	int
;	O
mtx	O
->	O
if_true	*(union)
=	O
if_true	*(union)
;	O
mtx	O
->	O
if_false	*(union)
=	O
if_false	*(union)
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_coerce	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
,	O
MTX	union
*	O
arg	*(union)
)	O
{	O
if	O
(	O
type	int
==	O
arg	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
)	O
return	O
mtx_cur	O
(	O
)	O
;	O
return	O
coerce	O
(	O
arg	*(union)
,	O
type	int
)	O
;	O
}	O
MTX	union
*	O
coerce	O
(	O
MTX	union
*	O
arg	*(union)
,	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
{	O
COERCE_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
*	O
mtx	O
=	O
(	O
COERCE_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(union))
*	O
)	O
mtx_alloc	O
(	O
Coercion	int
)	O
;	O
mtx_insert	O
(	O
arg	*(union)
,	O
(	O
MTX	union
*	O
)	O
mtx	O
)	O
;	O
mtx	O
->	O
datatype	enum(int,int,int)
=	O
type	int
;	O
mtx	O
->	O
arg	*(union)
=	O
arg	*(union)
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	O
;	O
}	O
MTX	union
*	O
mtx_call	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
,	O
MTX	union
*	O
args	*(struct)
)	O
{	O
MTX	union
*	O
argp	O
;	O
CALL_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),int,*(union))
*	O
call	O
;	O
PARAMETER	struct
*	O
parmp	O
;	O
int	O
argn	O
;	O
argn	O
=	O
0	int
;	O
argp	O
=	O
args	*(struct)
;	O
parmp	O
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
while	O
(	O
argp	O
&&	O
parmp	O
)	O
{	O
if	O
(	O
argp	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
parmp	O
->	O
datatype	enum(int,int,int)
)	O
{	O
char	O
buf	*(char)
[	O
24	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
_	O
(	O
"(argument %d)"	*(char)
)	O
,	O
argn	O
)	O
;	O
rw_coercion_warning	O
(	O
argp	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
,	O
parmp	O
->	O
datatype	enum(int,int,int)
,	O
buf	*(char)
)	O
;	O
coerce	O
(	O
argp	O
,	O
parmp	O
->	O
datatype	enum(int,int,int)
)	O
;	O
}	O
argn	O
++	O
;	O
argp	O
=	O
argp	O
->	O
gen	O
.	O
arglink	*(union)
;	O
parmp	O
=	O
parmp	O
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
if	O
(	O
argp	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"too many arguments in call to %s"	*(char)
)	O
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
name	*(char)
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
if	O
(	O
parmp	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"too few arguments in call to %s"	*(char)
)	O
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
name	*(char)
)	O
;	O
errcnt	long
++	O
;	O
}	O
call	O
=	O
(	O
CALL_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),int,*(union))
*	O
)	O
mtx_alloc	O
(	O
Call	int
)	O
;	O
mtx_append	O
(	O
(	O
MTX	union
*	O
)	O
call	O
)	O
;	O
call	O
->	O
datatype	enum(int,int,int)
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rettype	enum(int,int,int)
;	O
call	O
->	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
call	O
->	O
args	*(struct)
=	O
args	*(struct)
;	O
call	O
->	O
nargs	int
=	O
argn	O
;	O
return	O
(	O
MTX	union
*	O
)	O
call	O
;	O
}	O
MTX	union
*	O
mtx_builtin	O
(	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
bin	O
,	O
MTX	union
*	O
args	*(struct)
)	O
{	O
MTX	union
*	O
argp	O
;	O
BTIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(()->(void)),int,*(union))
*	O
call	O
;	O
int	O
argn	O
;	O
char	O
*	O
parmp	O
;	O
grad_data_type_t	enum(int,int,int)
type	int
;	O
argn	O
=	O
0	int
;	O
argp	O
=	O
args	*(struct)
;	O
parmp	O
=	O
bin	O
->	O
parms	*(char)
;	O
while	O
(	O
argp	O
&&	O
parmp	O
)	O
{	O
switch	O
(	O
parmp	O
[	O
0	int
]	O
)	O
{	O
case	O
'i'	O
:	O
type	int
=	O
Integer	int
;	O
break	O
;	O
case	O
's'	O
:	O
type	int
=	O
String	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"malformed builtin"	*(char)
)	O
;	O
}	O
if	O
(	O
argp	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
type	int
)	O
{	O
char	O
buf	*(char)
[	O
24	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
_	O
(	O
"(argument %d)"	*(char)
)	O
,	O
argn	O
)	O
;	O
rw_coercion_warning	O
(	O
argp	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
,	O
type	int
,	O
buf	*(char)
)	O
;	O
coerce	O
(	O
argp	O
,	O
type	int
)	O
;	O
}	O
argn	O
++	O
;	O
argp	O
=	O
argp	O
->	O
gen	O
.	O
arglink	*(union)
;	O
parmp	O
++	O
;	O
}	O
if	O
(	O
argp	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"too many arguments in call to %s"	*(char)
)	O
,	O
bin	O
->	O
name	*(char)
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
if	O
(	O
*	O
parmp	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"too few arguments in call to %s"	*(char)
)	O
,	O
bin	O
->	O
name	*(char)
)	O
;	O
errcnt	long
++	O
;	O
}	O
call	O
=	O
(	O
BTIN_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int),*(union),*(union),*(()->(void)),int,*(union))
*	O
)	O
mtx_alloc	O
(	O
Builtin	int
)	O
;	O
mtx_append	O
(	O
(	O
MTX	union
*	O
)	O
call	O
)	O
;	O
call	O
->	O
datatype	enum(int,int,int)
=	O
bin	O
->	O
rettype	enum(int,int,int)
;	O
call	O
->	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
bin	O
->	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
;	O
call	O
->	O
args	*(struct)
=	O
args	*(struct)
;	O
call	O
->	O
nargs	int
=	O
argn	O
;	O
return	O
(	O
MTX	union
*	O
)	O
call	O
;	O
}	O
const	O
char	O
*	O
datatype_str_nom	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"Undefined"	*(char)
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"integer"	*(char)
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"string"	*(char)
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"UNKNOWN"	*(char)
)	O
;	O
}	O
}	O
const	O
char	O
*	O
datatype_str_abl	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"from Undefined"	*(char)
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"from integer"	*(char)
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"from string"	*(char)
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"from UNKNOWN"	*(char)
)	O
;	O
}	O
}	O
const	O
char	O
*	O
datatype_str_acc	O
(	O
grad_data_type_t	enum(int,int,int)
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"to Undefined"	*(char)
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"to integer"	*(char)
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"to string"	*(char)
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"to UNKNOWN"	*(char)
)	O
;	O
}	O
}	O
FILE	struct
*	O
debug_open_file	O
(	O
)	O
{	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
char	O
*	O
path	O
;	O
path	O
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_log_dir	*(char)
,	O
"radius.mtx"	*(char)
)	O
;	O
if	O
(	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
path	O
,	O
"a"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
|	O
GRAD_LOG_PERROR	O
,	O
_	O
(	O
"can't open file `%s'"	*(char)
)	O
,	O
path	O
)	O
;	O
}	O
grad_free	(*(void))->(void)
(	O
path	O
)	O
;	O
return	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
}	O
static	O
void	O
pass1	O
(	O
)	O
;	O
static	O
int	O
pass2_unary	O
(	O
MTX	union
*	O
mtx	O
)	O
;	O
static	O
int	O
pass2_binary	O
(	O
MTX	union
*	O
mtx	O
)	O
;	O
void	O
pass1	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
;	O
MTX	union
*	O
end	*(long)
;	O
mtx	O
=	O
mtx_alloc	O
(	O
Enter	int
)	O
;	O
rw_list_insert	O
(	O
&	O
mtx_first	O
,	O
&	O
mtx_last	O
,	O
mtx_first	O
,	O
mtx	O
,	O
1	int
)	O
;	O
mtx	O
->	O
frame	O
.	O
stacksize	int
=	O
function	O
->	O
stack_alloc	int
;	O
if	O
(	O
mtx_last	O
->	O
gen	O
.	O
type	int
!=	O
Return	int
)	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_WARN	O
,	O
&	O
mtx_last	O
->	O
gen	O
.	O
loc	struct(*(char),long)
,	O
_	O
(	O
"missing return statement"	*(char)
)	O
)	O
;	O
val	array(int)
.	O
type	int
=	O
function	O
->	O
rettype	enum(int,int,int)
;	O
switch	O
(	O
function	O
->	O
rettype	enum(int,int,int)
)	O
{	O
case	O
Integer	int
:	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
=	O
0	int
;	O
break	O
;	O
case	O
String	int
:	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
=	O
""	*(char)
;	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
size	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	*(char)
)	O
;	O
}	O
mtx_const	O
(	O
&	O
val	array(int)
)	O
;	O
mtx_frame	O
(	O
Leave	int
,	O
function	O
->	O
stack_alloc	int
)	O
;	O
}	O
else	O
{	O
mtx_last	O
->	O
gen	O
.	O
type	int
=	O
Leave	int
;	O
mtx_last	O
->	O
frame	O
.	O
stacksize	int
=	O
function	O
->	O
stack_alloc	int
;	O
}	O
end	*(long)
=	O
mtx_alloc	O
(	O
Nop	int
)	O
;	O
rw_list_insert	O
(	O
&	O
mtx_first	O
,	O
&	O
mtx_last	O
,	O
mtx_last	O
,	O
end	*(long)
,	O
1	int
)	O
;	O
for	O
(	O
mtx	O
=	O
mtx_first	O
;	O
mtx	O
;	O
mtx	O
=	O
mtx	O
->	O
gen	O
.	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
if	O
(	O
mtx	O
->	O
gen	O
.	O
type	int
==	O
Return	int
)	O
{	O
if	O
(	O
mtx	O
->	O
ret	O
.	O
expr	*(char)
->	O
gen	O
.	O
datatype	enum(int,int,int)
!=	O
function	O
->	O
rettype	enum(int,int,int)
)	O
{	O
rw_coercion_warning	O
(	O
mtx	O
->	O
ret	O
.	O
expr	*(char)
->	O
gen	O
.	O
datatype	enum(int,int,int)
,	O
function	O
->	O
rettype	enum(int,int,int)
,	O
NULL	O
)	O
;	O
coerce	O
(	O
mtx	O
->	O
ret	O
.	O
expr	*(char)
,	O
function	O
->	O
rettype	enum(int,int,int)
)	O
;	O
}	O
mtx	O
->	O
gen	O
.	O
type	int
=	O
Jump	int
;	O
mtx	O
->	O
jump	O
.	O
dest	*(union)
=	O
end	*(long)
;	O
}	O
}	O
}	O
int	O
pass2_unary	O
(	O
MTX	union
*	O
mtx	O
)	O
{	O
MTX	union
*	O
arg	*(union)
=	O
mtx	O
->	O
un	O
.	O
arg	*(union)
;	O
switch	O
(	O
mtx	O
->	O
un	O
.	O
opcode	enum(int,int,int)
)	O
{	O
case	O
Not	int
:	O
arg	*(union)
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
=	O
!	O
arg	*(union)
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Neg	int
:	O
arg	*(union)
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
=	O
-	O
arg	*(union)
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	*(char)
)	O
;	O
}	O
mtx	O
->	O
gen	O
.	O
type	int
=	O
Constant	int
;	O
mtx	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
=	O
arg	*(union)
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
;	O
mtx_remove	O
(	O
arg	*(union)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
pass2_binary	O
(	O
MTX	union
*	O
mtx	O
)	O
{	O
MTX	union
*	O
arg0	O
=	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
;	O
MTX	union
*	O
arg1	O
=	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
1	int
]	O
;	O
grad_datum_t	union(int,struct(long,*(char)))
dat	O
;	O
switch	O
(	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
)	O
{	O
case	O
Eq	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
==	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Ne	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
!=	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Lt	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
<	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Le	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
<=	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Gt	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
>	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Ge	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
>=	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
BAnd	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
&	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
BOr	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
|	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
BXor	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
^	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
And	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
&&	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Or	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
||	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Shl	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
<<	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Shr	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
>>	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Add	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
+	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Sub	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
-	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Mul	int
:	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
*	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Div	int
:	O
if	O
(	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
arg1	O
->	O
cnst	O
.	O
loc	struct(*(char),long)
,	O
_	O
(	O
"divide by zero"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
/	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
case	O
Rem	int
:	O
if	O
(	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
arg1	O
->	O
cnst	O
.	O
loc	struct(*(char),long)
,	O
_	O
(	O
"divide by zero"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
dat	O
.	O
ival	int
=	O
arg0	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
%	O
arg1	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	*(char)
)	O
;	O
}	O
mtx	O
->	O
gen	O
.	O
type	int
=	O
Constant	int
;	O
mtx	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
=	O
dat	O
;	O
mtx_remove	O
(	O
arg0	O
)	O
;	O
mtx_remove	O
(	O
arg1	O
)	O
;	O
return	O
0	int
;	O
}	O
MTX	union
*	O
mtx_branch	O
(	O
int	O
cond	int
,	O
MTX	union
*	O
target	O
)	O
{	O
MTX	union
*	O
nop	O
=	O
mtx_alloc	O
(	O
Nop	int
)	O
;	O
MTX	union
*	O
mtx	O
=	O
mtx_alloc	O
(	O
Branch	int
)	O
;	O
mtx_insert	O
(	O
target	O
,	O
nop	O
)	O
;	O
mtx	O
->	O
branch	O
.	O
cond	int
=	O
cond	int
;	O
mtx	O
->	O
branch	O
.	O
dest	*(union)
=	O
nop	O
;	O
return	O
mtx	O
;	O
}	O
void	O
mtx_bool	O
(	O
MTX	union
*	O
mtx	O
)	O
{	O
MTX	union
*	O
j_mtx	O
,	O
*	O
p	*(struct)
,	O
*	O
p1	O
;	O
p	*(struct)
=	O
mtx_alloc	O
(	O
Popa	int
)	O
;	O
mtx_insert	O
(	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
,	O
p	*(struct)
)	O
;	O
p1	O
=	O
mtx_alloc	O
(	O
Pusha	int
)	O
;	O
mtx_insert	O
(	O
p	*(struct)
,	O
p1	O
)	O
;	O
p	*(struct)
=	O
mtx_alloc	O
(	O
Pusha	int
)	O
;	O
mtx_insert	O
(	O
p1	O
,	O
p	*(struct)
)	O
;	O
j_mtx	O
=	O
mtx_branch	O
(	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
==	O
Or	int
,	O
mtx	O
)	O
;	O
mtx_insert	O
(	O
p	*(struct)
,	O
j_mtx	O
)	O
;	O
p1	O
=	O
mtx_alloc	O
(	O
Popa	int
)	O
;	O
mtx_insert	O
(	O
j_mtx	O
,	O
p1	O
)	O
;	O
mtx_remove	O
(	O
mtx	O
)	O
;	O
}	O
int	O
pass2	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
,	O
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
int	O
optcnt	O
;	O
int	O
errcnt	long
=	O
0	int
;	O
do	O
{	O
optcnt	O
=	O
0	int
;	O
mtx	O
=	O
mtx_first	O
;	O
while	O
(	O
mtx	O
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
mtx	O
->	O
gen	O
.	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
switch	O
(	O
mtx	O
->	O
gen	O
.	O
type	int
)	O
{	O
case	O
Unary	int
:	O
if	O
(	O
mtx	O
->	O
un	O
.	O
arg	*(union)
->	O
gen	O
.	O
type	int
!=	O
Constant	int
)	O
break	O
;	O
if	O
(	O
pass2_unary	O
(	O
mtx	O
)	O
)	O
errcnt	long
++	O
;	O
else	O
optcnt	O
++	O
;	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
->	O
gen	O
.	O
type	int
==	O
Constant	int
&&	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
1	int
]	O
->	O
gen	O
.	O
type	int
==	O
Constant	int
)	O
{	O
switch	O
(	O
mtx	O
->	O
bin	O
.	O
datatype	enum(int,int,int)
)	O
{	O
case	O
Integer	int
:	O
if	O
(	O
pass2_binary	O
(	O
mtx	O
)	O
)	O
errcnt	long
++	O
;	O
else	O
optcnt	O
++	O
;	O
break	O
;	O
case	O
String	int
:	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
==	O
And	int
||	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
==	O
Or	int
)	O
{	O
mtx_bool	O
(	O
mtx	O
)	O
;	O
}	O
break	O
;	O
case	O
Jump	int
:	O
if	O
(	O
mtx	O
->	O
jump	O
.	O
dest	*(union)
==	O
mtx	O
->	O
jump	O
.	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
mtx_remove	O
(	O
mtx	O
)	O
;	O
break	O
;	O
case	O
Attr	int
:	O
case	O
Attr_asgn	int
:	O
case	O
Attr_check	int
:	O
case	O
Attr_delete	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
mtx	O
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
}	O
while	O
(	O
errcnt	long
==	O
0	int
&&	O
optcnt	O
>	O
0	int
)	O
;	O
return	O
errcnt	long
;	O
}	O
int	O
optimize	O
(	O
)	O
{	O
DEBUG_FUN	O
(	O
)	O
;	O
DEBUG_MTX	O
(	O
"on entry to optimize"	*(char)
)	O
;	O
pass1	O
(	O
)	O
;	O
DEBUG_MTX	O
(	O
"after first pass"	*(char)
)	O
;	O
if	O
(	O
pass2	O
(	O
)	O
)	O
return	O
-	O
1	int
;	O
DEBUG_MTX	O
(	O
"after second pass (immediate computations)"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
INSTR	*(()->(void))
*	O
rw_code	O
;	O
static	O
pctr_t	int
rw_pc	O
;	O
static	O
size_t	long
rw_codesize	O
;	O
void	O
code_check	O
(	O
)	O
{	O
if	O
(	O
rw_code	O
==	O
NULL	O
)	O
{	O
rw_codesize	O
=	O
4096	int
;	O
rw_code	O
=	O
grad_emalloc	(long)->(*(void))
(	O
rw_codesize	O
*	O
sizeof	O
(	O
rw_code	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
}	O
void	O
code_init	O
(	O
)	O
{	O
code_check	O
(	O
)	O
;	O
rw_code	O
[	O
0	int
]	O
=	O
0	int
;	O
rw_pc	O
=	O
1	int
;	O
}	O
static	O
int	O
pushn	O
(	O
RWSTYPE	long
n	long
)	O
;	O
static	O
int	O
cpopn	O
(	O
RWSTYPE	long
*	O
np	O
)	O
;	O
static	O
RWSTYPE	long
popn	O
(	O
)	O
;	O
static	O
void	O
checkpop	O
(	O
int	O
cnt	O
)	O
;	O
static	O
void	O
pushref	O
(	O
char	O
*	O
str	*(char)
,	O
int	O
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
int	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
;	O
static	O
RWSTYPE	long
*	O
heap_reserve	O
(	O
int	O
size	int
)	O
;	O
static	O
void	O
pushs	O
(	O
RWSTYPE	long
*	O
sptr	O
,	O
size_t	long
size	int
,	O
int	O
len	int
)	O
;	O
static	O
void	O
pushstr	O
(	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
len	int
)	O
;	O
static	O
void	O
rw_pushn	O
(	O
)	O
;	O
static	O
void	O
rw_pushs	O
(	O
)	O
;	O
static	O
void	O
rw_pushref	O
(	O
)	O
;	O
static	O
void	O
rw_pushv	O
(	O
)	O
;	O
static	O
void	O
rw_i2s	O
(	O
)	O
;	O
static	O
void	O
rw_s2i	O
(	O
)	O
;	O
static	O
void	O
rw_eq	O
(	O
)	O
;	O
static	O
void	O
rw_ne	O
(	O
)	O
;	O
static	O
void	O
rw_lt	O
(	O
)	O
;	O
static	O
void	O
rw_le	O
(	O
)	O
;	O
static	O
void	O
rw_gt	O
(	O
)	O
;	O
static	O
void	O
rw_ge	O
(	O
)	O
;	O
static	O
void	O
rw_eqs	O
(	O
)	O
;	O
static	O
void	O
rw_nes	O
(	O
)	O
;	O
static	O
void	O
rw_lts	O
(	O
)	O
;	O
static	O
void	O
rw_les	O
(	O
)	O
;	O
static	O
void	O
rw_gts	O
(	O
)	O
;	O
static	O
void	O
rw_ges	O
(	O
)	O
;	O
static	O
void	O
rw_b_xor	O
(	O
)	O
;	O
static	O
void	O
rw_b_and	O
(	O
)	O
;	O
static	O
void	O
rw_b_or	O
(	O
)	O
;	O
static	O
void	O
rw_shl	O
(	O
)	O
;	O
static	O
void	O
rw_shr	O
(	O
)	O
;	O
static	O
void	O
rw_add	O
(	O
)	O
;	O
static	O
void	O
rw_sub	O
(	O
)	O
;	O
static	O
void	O
rw_mul	O
(	O
)	O
;	O
static	O
void	O
rw_div	O
(	O
)	O
;	O
static	O
void	O
rw_rem	O
(	O
)	O
;	O
static	O
void	O
rw_not	O
(	O
)	O
;	O
static	O
void	O
rw_neg	O
(	O
)	O
;	O
static	O
void	O
rw_asgn	O
(	O
)	O
;	O
static	O
void	O
rw_enter	O
(	O
)	O
;	O
static	O
void	O
rw_leave	O
(	O
)	O
;	O
static	O
void	O
rw_match	O
(	O
)	O
;	O
static	O
void	O
rw_jmp	O
(	O
)	O
;	O
static	O
void	O
rw_jne	O
(	O
)	O
;	O
static	O
void	O
rw_je	O
(	O
)	O
;	O
static	O
void	O
rw_adds	O
(	O
)	O
;	O
static	O
void	O
rw_adjstk	O
(	O
)	O
;	O
static	O
void	O
rw_popn	O
(	O
)	O
;	O
static	O
void	O
rw_pusha	O
(	O
)	O
;	O
static	O
void	O
rw_popa	O
(	O
)	O
;	O
static	O
void	O
rw_call	O
(	O
)	O
;	O
static	O
void	O
rw_builtin	O
(	O
)	O
;	O
static	O
void	O
rw_attrs	O
(	O
)	O
;	O
static	O
void	O
rw_attrs0	O
(	O
)	O
;	O
static	O
void	O
rw_attrn	O
(	O
)	O
;	O
static	O
void	O
rw_attrn0	O
(	O
)	O
;	O
static	O
void	O
rw_attrcheck	O
(	O
)	O
;	O
static	O
void	O
rw_attrcheck0	O
(	O
)	O
;	O
static	O
void	O
rw_attrasgn	O
(	O
)	O
;	O
static	O
void	O
rw_attrasgn0	O
(	O
)	O
;	O
static	O
void	O
rw_attr_delete	O
(	O
)	O
;	O
static	O
void	O
rw_attr_delete0	O
(	O
)	O
;	O
INSTR	*(()->(void))
bin_codetab	O
[	O
]	O
=	O
{	O
rw_eq	O
,	O
rw_ne	O
,	O
rw_lt	O
,	O
rw_le	O
,	O
rw_gt	O
,	O
rw_ge	O
,	O
rw_b_and	O
,	O
rw_b_xor	O
,	O
rw_b_or	O
,	O
NULL	O
,	O
NULL	O
,	O
rw_shl	O
,	O
rw_shr	O
,	O
rw_add	O
,	O
rw_sub	O
,	O
rw_mul	O
,	O
rw_div	O
,	O
rw_rem	O
,	O
}	O
;	O
INSTR	*(()->(void))
bin_string_codetab	O
[	O
]	O
=	O
{	O
rw_eqs	O
,	O
rw_nes	O
,	O
rw_lts	O
,	O
rw_les	O
,	O
rw_gts	O
,	O
rw_ges	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
rw_adds	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
INSTR	*(()->(void))
coerce_tab	O
[	O
Max_datatype	O
]	O
[	O
Max_datatype	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
rw_i2s	O
}	O
,	O
{	O
NULL	O
,	O
rw_s2i	O
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
void	O
check_codesize	O
(	O
int	O
delta	O
)	O
;	O
static	O
int	O
code	char
(	O
INSTR	*(()->(void))
instr	O
)	O
;	O
static	O
int	O
data	*(void)
(	O
int	O
val	array(int)
)	O
;	O
static	O
int	O
data_str	O
(	O
char	O
*	O
ptr	*(*(void))
)	O
;	O
static	O
void	O
add_target	O
(	O
NOP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)),int)
*	O
mtx	O
,	O
pctr_t	int
pc	int
)	O
;	O
void	O
add_target	O
(	O
NOP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)),int)
*	O
mtx	O
,	O
pctr_t	int
pc	int
)	O
{	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
=	O
(	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
)	O
mtx_alloc	O
(	O
Target	int
)	O
;	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
(	O
MTX	union
*	O
)	O
mtx	O
->	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
mtx	O
->	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
=	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
->	O
pc	int
=	O
pc	int
;	O
}	O
void	O
fixup_target	O
(	O
NOP_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)),int)
*	O
mtx	O
,	O
pctr_t	int
pc	int
)	O
{	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
for	O
(	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
=	O
(	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
)	O
mtx	O
->	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
;	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
=	O
(	O
TGT_MTX	struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)
*	O
)	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
rw_code	O
[	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
->	O
pc	int
]	O
=	O
(	O
INSTR	*(()->(void))
)	O
pc	int
;	O
mtx	O
->	O
tgt	*(struct(*(union),*(union),*(union),struct(*(char),long),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int))
=	O
NULL	O
;	O
}	O
pctr_t	int
codegen	O
(	O
)	O
{	O
MTX	union
*	O
mtx	O
;	O
function	O
->	O
entry	int
=	O
rw_pc	O
;	O
for	O
(	O
mtx	O
=	O
mtx_first	O
;	O
mtx	O
;	O
mtx	O
=	O
mtx	O
->	O
gen	O
.	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
switch	O
(	O
mtx	O
->	O
gen	O
.	O
type	int
)	O
{	O
case	O
Generic	int
:	O
case	O
Return	int
:	O
default	O
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	O
,	O
"INTERNAL ERROR: codegen stumbled accross generic matrix!"	*(char)
)	O
;	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
case	O
Nop	int
:	O
fixup_target	O
(	O
&	O
mtx	O
->	O
nop	O
,	O
rw_pc	O
)	O
;	O
mtx	O
->	O
nop	O
.	O
pc	int
=	O
rw_pc	O
;	O
break	O
;	O
case	O
Stop	int
:	O
break	O
;	O
case	O
Enter	int
:	O
code	char
(	O
rw_enter	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
frame	O
.	O
stacksize	int
)	O
;	O
break	O
;	O
case	O
Leave	int
:	O
code	char
(	O
rw_leave	O
)	O
;	O
break	O
;	O
case	O
Constant	int
:	O
switch	O
(	O
mtx	O
->	O
cnst	O
.	O
datatype	enum(int,int,int)
)	O
{	O
case	O
Integer	int
:	O
code	char
(	O
rw_pushn	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
)	O
;	O
break	O
;	O
case	O
String	int
:	O
code	char
(	O
rw_pushs	O
)	O
;	O
data_str	O
(	O
mtx	O
->	O
cnst	O
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
Matchref	int
:	O
code	char
(	O
rw_pushref	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
ref	O
.	O
num	int
)	O
;	O
break	O
;	O
case	O
Variable	int
:	O
code	char
(	O
rw_pushv	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
.	O
var	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
)	O
;	O
break	O
;	O
case	O
Unary	int
:	O
switch	O
(	O
mtx	O
->	O
un	O
.	O
opcode	enum(int,int,int)
)	O
{	O
case	O
Not	int
:	O
code	char
(	O
rw_not	O
)	O
;	O
break	O
;	O
case	O
Neg	int
:	O
code	char
(	O
rw_neg	O
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
mtx	O
->	O
bin	O
.	O
arg	*(union)
[	O
0	int
]	O
->	O
gen	O
.	O
datatype	enum(int,int,int)
==	O
String	int
)	O
code	char
(	O
bin_string_codetab	O
[	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
]	O
)	O
;	O
else	O
code	char
(	O
bin_codetab	O
[	O
mtx	O
->	O
bin	O
.	O
opcode	enum(int,int,int)
]	O
)	O
;	O
break	O
;	O
case	O
Cond	int
:	O
code	char
(	O
rw_jne	O
)	O
;	O
add_target	O
(	O
&	O
mtx	O
->	O
cond	int
.	O
if_true	*(union)
->	O
nop	O
,	O
rw_pc	O
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
if	O
(	O
mtx	O
->	O
cond	int
.	O
if_false	*(union)
)	O
{	O
code	char
(	O
rw_jmp	O
)	O
;	O
add_target	O
(	O
&	O
mtx	O
->	O
cond	int
.	O
if_false	*(union)
->	O
nop	O
,	O
rw_pc	O
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
Asgn	int
:	O
code	char
(	O
rw_asgn	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
asgn	O
.	O
lval	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(char),int,int,enum(int,int,int),int,union(int,struct`))),*(char),int,int,enum(int,int,int),int,union(int,struct(long,*(char)))))
->	O
offset	long
)	O
;	O
break	O
;	O
case	O
Match	int
:	O
code	char
(	O
rw_match	O
)	O
;	O
code	char
(	O
(	O
INSTR	*(()->(void))
)	O
mtx	O
->	O
match	O
.	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
if	O
(	O
mtx	O
->	O
match	O
.	O
negated	int
)	O
code	char
(	O
rw_not	O
)	O
;	O
break	O
;	O
case	O
Coercion	int
:	O
code	char
(	O
coerce_tab	O
[	O
mtx	O
->	O
coerce	O
.	O
arg	*(union)
->	O
gen	O
.	O
datatype	enum(int,int,int)
]	O
[	O
mtx	O
->	O
coerce	O
.	O
datatype	enum(int,int,int)
]	O
)	O
;	O
break	O
;	O
case	O
Jump	int
:	O
code	char
(	O
rw_jmp	O
)	O
;	O
add_target	O
(	O
&	O
mtx	O
->	O
jump	O
.	O
dest	*(union)
->	O
nop	O
,	O
rw_pc	O
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
break	O
;	O
case	O
Branch	int
:	O
code	char
(	O
mtx	O
->	O
branch	O
.	O
cond	int
?	O
rw_jne	O
:	O
rw_je	O
)	O
;	O
add_target	O
(	O
&	O
mtx	O
->	O
branch	O
.	O
dest	*(union)
->	O
nop	O
,	O
rw_pc	O
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
break	O
;	O
case	O
Call	int
:	O
code	char
(	O
rw_call	O
)	O
;	O
code	char
(	O
(	O
INSTR	*(()->(void))
)	O
mtx	O
->	O
call	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
entry	int
)	O
;	O
code	char
(	O
rw_adjstk	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
call	O
.	O
nargs	int
)	O
;	O
break	O
;	O
case	O
Builtin	int
:	O
code	char
(	O
rw_builtin	O
)	O
;	O
code	char
(	O
mtx	O
->	O
btin	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
;	O
code	char
(	O
rw_adjstk	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
btin	O
.	O
nargs	int
)	O
;	O
break	O
;	O
case	O
Pop	int
:	O
code	char
(	O
rw_popn	O
)	O
;	O
break	O
;	O
case	O
Popa	int
:	O
code	char
(	O
rw_popa	O
)	O
;	O
break	O
;	O
case	O
Pusha	int
:	O
code	char
(	O
rw_pusha	O
)	O
;	O
break	O
;	O
case	O
Attr	int
:	O
switch	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
datatype	enum(int,int,int)
)	O
{	O
case	O
Integer	int
:	O
if	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
index	(*(char),int)->(*(char))
)	O
code	char
(	O
rw_attrn	O
)	O
;	O
else	O
code	char
(	O
rw_attrn0	O
)	O
;	O
break	O
;	O
case	O
String	int
:	O
if	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
index	(*(char),int)->(*(char))
)	O
code	char
(	O
rw_attrs	O
)	O
;	O
else	O
code	char
(	O
rw_attrs0	O
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	*(char)
)	O
;	O
}	O
data	*(void)
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_check	int
:	O
if	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
index	(*(char),int)->(*(char))
)	O
code	char
(	O
rw_attrcheck	O
)	O
;	O
else	O
code	char
(	O
rw_attrcheck0	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_asgn	int
:	O
if	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
index	(*(char),int)->(*(char))
)	O
code	char
(	O
rw_attrasgn	O
)	O
;	O
else	O
code	char
(	O
rw_attrasgn0	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_delete	int
:	O
if	O
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
index	(*(char),int)->(*(char))
)	O
code	char
(	O
rw_attr_delete	O
)	O
;	O
else	O
code	char
(	O
rw_attr_delete0	O
)	O
;	O
data	*(void)
(	O
mtx	O
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
attrno	int
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
mtx	O
=	O
mtx_first	O
;	O
mtx	O
;	O
mtx	O
=	O
mtx	O
->	O
gen	O
.	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
if	O
(	O
mtx	O
->	O
gen	O
.	O
type	int
==	O
Nop	int
)	O
fixup_target	O
(	O
&	O
mtx	O
->	O
nop	O
,	O
mtx	O
->	O
nop	O
.	O
pc	int
)	O
;	O
}	O
return	O
function	O
->	O
entry	int
;	O
}	O
void	O
check_codesize	O
(	O
int	O
delta	O
)	O
{	O
if	O
(	O
rw_pc	O
+	O
delta	O
>=	O
rw_codesize	O
)	O
{	O
INSTR	*(()->(void))
*	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
(	O
rw_codesize	O
+	O
4096	int
)	O
*	O
sizeof	O
(	O
rw_code	O
[	O
0	int
]	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(struct)
,	O
rw_code	O
,	O
rw_codesize	O
*	O
sizeof	O
(	O
rw_code	O
[	O
0	int
]	O
)	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
rw_code	O
)	O
;	O
rw_code	O
=	O
p	*(struct)
;	O
rw_codesize	O
+=	O
4096	int
;	O
}	O
}	O
int	O
code	char
(	O
INSTR	*(()->(void))
instr	O
)	O
{	O
check_codesize	O
(	O
1	int
)	O
;	O
rw_code	O
[	O
rw_pc	O
]	O
=	O
instr	O
;	O
return	O
rw_pc	O
++	O
;	O
}	O
int	O
data	*(void)
(	O
int	O
val	array(int)
)	O
{	O
return	O
code	char
(	O
(	O
INSTR	*(()->(void))
)	O
(	O
RWSTYPE	long
)	O
val	array(int)
)	O
;	O
}	O
int	O
data_str	O
(	O
char	O
*	O
ptr	*(*(void))
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
ptr	*(*(void))
)	O
+	O
1	int
;	O
RWSTYPE	long
delta	O
=	O
(	O
len	int
+	O
sizeof	O
(	O
rw_code	O
[	O
0	int
]	O
)	O
)	O
/	O
sizeof	O
(	O
rw_code	O
[	O
0	int
]	O
)	O
;	O
check_codesize	O
(	O
delta	O
+	O
1	int
)	O
;	O
rw_code	O
[	O
rw_pc	O
++	O
]	O
=	O
(	O
INSTR	*(()->(void))
)	O
delta	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
rw_code	O
+	O
rw_pc	O
,	O
ptr	*(*(void))
,	O
len	int
)	O
;	O
rw_pc	O
+=	O
delta	O
;	O
return	O
rw_pc	O
;	O
}	O
COMP_REGEX	struct
*	O
rx_alloc	O
(	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
int	O
nmatch	int
)	O
{	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
)	O
;	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
*	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
nmatch	int
=	O
nmatch	int
;	O
rw_list_insert	O
(	O
&	O
function	O
->	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
NULL	O
,	O
function	O
->	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
1	int
)	O
;	O
return	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
}	O
void	O
rx_free	O
(	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
{	O
COMP_REGEX	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
while	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
regfree	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
grad_free	(*(void))->(void)
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
}	O
COMP_REGEX	struct
*	O
compile_regexp	O
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
int	O
nmatch	int
;	O
int	O
rc	O
=	O
regcomp	O
(	O
&	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
str	*(char)
,	O
regcomp_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
{	O
char	O
errbuf	O
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	O
,	O
&	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
errbuf	O
,	O
sizeof	O
(	O
errbuf	O
)	O
)	O
;	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
locus	O
,	O
_	O
(	O
"regexp error: %s"	*(char)
)	O
,	O
errbuf	O
)	O
;	O
return	O
NULL	O
;	O
}	O
nmatch	int
=	O
0	int
;	O
for	O
(	O
p	*(struct)
=	O
str	*(char)
;	O
*	O
p	*(struct)
;	O
)	O
{	O
if	O
(	O
*	O
p	*(struct)
==	O
'\\'	O
)	O
if	O
(	O
p	*(struct)
[	O
1	int
]	O
==	O
'('	O
)	O
{	O
nmatch	int
++	O
;	O
p	*(struct)
+=	O
2	int
;	O
continue	O
;	O
}	O
p	*(struct)
++	O
;	O
}	O
return	O
rx_alloc	O
(	O
&	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
nmatch	int
)	O
;	O
}	O
void	O
function_delete	O
(	O
)	O
{	O
if	O
(	O
function	O
)	O
{	O
grad_symtab_delete	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(struct(*(struct(*`,*`)),*(char))))->(int)
(	O
rewrite_tab	O
,	O
(	O
grad_symbol_t	struct
*	O
)	O
function	O
)	O
;	O
function_cleanup	O
(	O
)	O
;	O
}	O
}	O
void	O
function_cleanup	O
(	O
)	O
{	O
function	O
=	O
NULL	O
;	O
}	O
int	O
pushn	O
(	O
RWSTYPE	long
n	long
)	O
{	O
if	O
(	O
mach	O
.	O
st	int
>=	O
mach	O
.	O
ht	int
)	O
{	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"st=%d, ht=%d"	*(char)
,	O
mach	O
.	O
st	int
,	O
mach	O
.	O
ht	int
)	O
;	O
rw_error	O
(	O
_	O
(	O
"out of pushdown space"	*(char)
)	O
)	O
;	O
}	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
st	int
++	O
]	O
=	O
n	long
;	O
return	O
0	int
;	O
}	O
void	O
pushs	O
(	O
RWSTYPE	long
*	O
sptr	O
,	O
size_t	long
size	int
,	O
int	O
len	int
)	O
{	O
if	O
(	O
mach	O
.	O
ht	int
-	O
len	int
-	O
1	int
<=	O
mach	O
.	O
st	int
)	O
{	O
rw_error	O
(	O
_	O
(	O
"heap overrun"	*(char)
)	O
)	O
;	O
}	O
while	O
(	O
len	int
)	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
ht	int
--	O
]	O
=	O
sptr	O
[	O
--	O
len	int
]	O
;	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
ht	int
--	O
]	O
=	O
size	int
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
(	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
ht	int
+	O
1	int
)	O
)	O
;	O
}	O
void	O
pushstr	O
(	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
len	int
)	O
{	O
RWSTYPE	long
*	O
p	*(struct)
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
len	int
+	O
1	int
)	O
;	O
char	O
*	O
s	*(*(char))
=	O
(	O
char	O
*	O
)	O
(	O
p	*(struct)
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(*(char))
,	O
str	*(char)
,	O
len	int
)	O
;	O
s	*(*(char))
[	O
len	int
]	O
=	O
0	int
;	O
p	*(struct)
[	O
0	int
]	O
=	O
len	int
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
p	*(struct)
)	O
;	O
}	O
RWSTYPE	long
*	O
heap_reserve	O
(	O
int	O
size	int
)	O
{	O
size_t	long
words	O
=	O
B2RW	O
(	O
size	int
)	O
;	O
if	O
(	O
mach	O
.	O
ht	int
-	O
words	O
<=	O
mach	O
.	O
st	int
)	O
{	O
gc	O
(	O
)	O
;	O
if	O
(	O
mach	O
.	O
ht	int
-	O
words	O
<=	O
mach	O
.	O
st	int
)	O
rw_error	O
(	O
_	O
(	O
"heap overrun"	*(char)
)	O
)	O
;	O
}	O
mach	O
.	O
ht	int
-=	O
words	O
;	O
return	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
ht	int
--	O
;	O
}	O
char	O
*	O
temp_space_create	O
(	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
(	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
st	int
)	O
;	O
}	O
size_t	long
temp_space_size	O
(	O
)	O
{	O
return	O
(	O
mach	O
.	O
ht	int
-	O
mach	O
.	O
st	int
)	O
*	O
sizeof	O
(	O
mach	O
.	O
stack	*(long)
[	O
0	int
]	O
)	O
;	O
}	O
void	O
temp_space_copy	O
(	O
char	O
*	O
*	O
baseptr	O
,	O
char	O
*	O
text	*(char)
,	O
size_t	long
size	int
)	O
{	O
size_t	long
len	int
=	O
(	O
size	int
+	O
sizeof	O
(	O
mach	O
.	O
stack	*(long)
[	O
0	int
]	O
)	O
)	O
/	O
sizeof	O
(	O
mach	O
.	O
stack	*(long)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
*	O
baseptr	O
+	O
len	int
>=	O
(	O
char	O
*	O
)	O
(	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
ht	int
)	O
)	O
rw_error	O
(	O
_	O
(	O
"out of heap space"	*(char)
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
*	O
baseptr	O
,	O
text	*(char)
,	O
size	int
)	O
;	O
*	O
baseptr	O
+=	O
size	int
;	O
}	O
RWSTYPE	long
*	O
temp_space_fix	O
(	O
char	O
*	O
end	*(long)
)	O
{	O
size_t	long
len	int
,	O
size	int
;	O
char	O
*	O
base	int
=	O
(	O
char	O
*	O
)	O
(	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
st	int
)	O
;	O
temp_space_copy	O
(	O
&	O
end	*(long)
,	O
""	*(char)
,	O
0	int
)	O
;	O
size	int
=	O
end	*(long)
-	O
base	int
;	O
len	int
=	O
B2RW	O
(	O
size	int
)	O
;	O
mach	O
.	O
ht	int
-=	O
len	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
ht	int
,	O
base	int
,	O
size	int
)	O
;	O
mach	O
.	O
stack	*(long)
[	O
--	O
mach	O
.	O
ht	int
]	O
=	O
strlen	(*(char))->(long)
(	O
base	int
)	O
;	O
return	O
mach	O
.	O
stack	*(long)
+	O
mach	O
.	O
ht	int
--	O
;	O
}	O
int	O
cpopn	O
(	O
RWSTYPE	long
*	O
np	O
)	O
{	O
if	O
(	O
mach	O
.	O
st	int
<=	O
0	int
)	O
{	O
rw_error	O
(	O
_	O
(	O
"out of popup"	*(char)
)	O
)	O
;	O
}	O
*	O
np	O
=	O
mach	O
.	O
stack	*(long)
[	O
--	O
mach	O
.	O
st	int
]	O
;	O
return	O
0	int
;	O
}	O
RWSTYPE	long
popn	O
(	O
)	O
{	O
return	O
mach	O
.	O
stack	*(long)
[	O
--	O
mach	O
.	O
st	int
]	O
;	O
}	O
void	O
mem2string	O
(	O
grad_string_t	struct(long,*(char))
*	O
p	*(struct)
,	O
RWSTYPE	long
*	O
loc	struct(*(char),long)
)	O
{	O
p	*(struct)
->	O
size	int
=	O
loc	struct(*(char),long)
[	O
0	int
]	O
;	O
p	*(struct)
->	O
data	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
loc	struct(*(char),long)
+	O
1	int
)	O
;	O
}	O
void	O
poparr	O
(	O
grad_string_t	struct(long,*(char))
*	O
p	*(struct)
)	O
{	O
mem2string	O
(	O
p	*(struct)
,	O
(	O
RWSTYPE	long
*	O
)	O
popn	O
(	O
)	O
)	O
;	O
}	O
RWSTYPE	long
tos	O
(	O
)	O
{	O
return	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
st	int
-	O
1	int
]	O
;	O
}	O
void	O
checkpop	O
(	O
int	O
cnt	O
)	O
{	O
if	O
(	O
mach	O
.	O
st	int
<	O
cnt	O
)	O
rw_error	O
(	O
_	O
(	O
"out of popup"	*(char)
)	O
)	O
;	O
}	O
void	O
pushref	O
(	O
char	O
*	O
str	*(char)
,	O
int	O
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
int	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
{	O
pushstr	O
(	O
str	*(char)
+	O
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
to	*(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
-	O
from	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
}	O
void	O
enter	O
(	O
int	O
n	long
)	O
{	O
pushn	O
(	O
mach	O
.	O
sb	int
)	O
;	O
mach	O
.	O
sb	int
=	O
mach	O
.	O
st	int
;	O
mach	O
.	O
st	int
+=	O
n	long
;	O
}	O
void	O
leave	O
(	O
)	O
{	O
mach	O
.	O
rA	O
=	O
popn	O
(	O
)	O
;	O
mach	O
.	O
st	int
=	O
mach	O
.	O
sb	int
;	O
mach	O
.	O
sb	int
=	O
popn	O
(	O
)	O
;	O
mach	O
.	O
pc	int
=	O
(	O
pctr_t	int
)	O
popn	O
(	O
)	O
;	O
}	O
RWSTYPE	long
getarg	O
(	O
int	O
num	int
)	O
{	O
return	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
sb	int
-	O
(	O
STACK_BASE	O
+	O
num	int
)	O
]	O
;	O
}	O
static	O
int	O
rw_error	O
(	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
"%s: %s"	*(char)
,	O
_	O
(	O
"rewrite runtime error"	*(char)
)	O
,	O
msg	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
mach	O
.	O
jmp	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
static	O
int	O
rw_error_free	O
(	O
char	O
*	O
msg	*(char)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
"%s: %s"	*(char)
,	O
_	O
(	O
"rewrite runtime error"	*(char)
)	O
,	O
msg	*(char)
)	O
;	O
free	*((*(void),*(void))->(int))
(	O
msg	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
mach	O
.	O
jmp	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
void	O
rw_call	O
(	O
)	O
{	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushn	O
(	O
mach	O
.	O
pc	int
)	O
;	O
mach	O
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_adjstk	O
(	O
)	O
{	O
int	O
delta	O
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
mach	O
.	O
st	int
-=	O
delta	O
;	O
pushn	O
(	O
mach	O
.	O
rA	O
)	O
;	O
}	O
void	O
rw_enter	O
(	O
)	O
{	O
int	O
n	long
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
enter	O
(	O
n	long
)	O
;	O
}	O
void	O
rw_leave	O
(	O
)	O
{	O
leave	O
(	O
)	O
;	O
}	O
void	O
rw_pushn	O
(	O
)	O
{	O
RWSTYPE	long
n	long
=	O
(	O
RWSTYPE	long
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushn	O
(	O
n	long
)	O
;	O
}	O
void	O
rw_pushref	O
(	O
)	O
{	O
int	O
i	O
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushref	O
(	O
mach	O
.	O
sA	*(char)
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
i	O
]	O
.	O
rm_so	long
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
i	O
]	O
.	O
rm_eo	long
)	O
;	O
}	O
void	O
rw_pushv	O
(	O
)	O
{	O
stkoff_t	int
n	long
=	O
(	O
stkoff_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushn	O
(	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
sb	int
+	O
n	long
]	O
)	O
;	O
}	O
void	O
rw_pushs	O
(	O
)	O
{	O
int	O
len	int
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
*	O
sptr	O
=	O
(	O
RWSTYPE	long
*	O
)	O
(	O
rw_code	O
+	O
mach	O
.	O
pc	int
)	O
;	O
mach	O
.	O
pc	int
+=	O
len	int
;	O
pushs	O
(	O
sptr	O
,	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
sptr	O
)	O
,	O
len	int
)	O
;	O
}	O
void	O
rw_asgn	O
(	O
)	O
{	O
stkoff_t	int
off	long
=	O
(	O
stkoff_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
n	long
;	O
cpopn	O
(	O
&	O
n	long
)	O
;	O
mach	O
.	O
stack	*(long)
[	O
mach	O
.	O
sb	int
+	O
off	long
]	O
=	O
n	long
;	O
pushn	O
(	O
n	long
)	O
;	O
}	O
void	O
assert_request_presence	O
(	O
)	O
{	O
if	O
(	O
!	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
rw_error	O
(	O
_	O
(	O
"no request supplied"	*(char)
)	O
)	O
;	O
}	O
void	O
rw_attrcheck0	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushn	O
(	O
grad_avl_find	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
!=	O
NULL	O
)	O
;	O
}	O
void	O
rw_attrcheck	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
index	(*(char),int)->(*(char))
;	O
cpopn	O
(	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
pushn	O
(	O
grad_avl_find_n	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
index	(*(char),int)->(*(char))
)	O
!=	O
NULL	O
)	O
;	O
}	O
void	O
attrasgn_internal	O
(	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
RWSTYPE	long
val	array(int)
)	O
{	O
grad_string_t	struct(long,*(char))
str	*(char)
;	O
assert_request_presence	O
(	O
)	O
;	O
if	O
(	O
!	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avp_create	(int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
;	O
if	O
(	O
!	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
rw_error	O
(	O
_	O
(	O
"can't create A/V pair"	*(char)
)	O
)	O
;	O
grad_avl_add_pair	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
}	O
switch	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	O
:	O
case	O
GRAD_TYPE_DATE	O
:	O
mem2string	O
(	O
&	O
str	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
val	array(int)
)	O
;	O
grad_free	(*(void))->(void)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
)	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
=	O
grad_malloc	(long)->(*(void))
(	O
str	*(char)
.	O
size	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
str	*(char)
.	O
data	*(void)
,	O
str	*(char)
.	O
size	int
)	O
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
[	O
str	*(char)
.	O
size	int
]	O
=	O
0	int
;	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
=	O
str	*(char)
.	O
size	int
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	O
:	O
case	O
GRAD_TYPE_IPADDR	O
:	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
=	O
val	array(int)
;	O
break	O
;	O
}	O
pushn	O
(	O
val	array(int)
)	O
;	O
}	O
void	O
rw_attrasgn0	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
val	array(int)
;	O
cpopn	O
(	O
&	O
val	array(int)
)	O
;	O
attrasgn_internal	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
grad_avl_find	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
,	O
val	array(int)
)	O
;	O
}	O
void	O
rw_attrasgn	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
val	array(int)
;	O
RWSTYPE	long
index	(*(char),int)->(*(char))
;	O
cpopn	O
(	O
&	O
val	array(int)
)	O
;	O
cpopn	O
(	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
attrasgn_internal	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
grad_avl_find_n	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
index	(*(char),int)->(*(char))
)	O
,	O
val	array(int)
)	O
;	O
}	O
void	O
rw_attrs0	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avl_find	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
)	O
==	O
NULL	O
)	O
pushstr	O
(	O
""	*(char)
,	O
0	int
)	O
;	O
else	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
prop	int
&	O
GRAD_AP_ENCRYPT	O
)	O
{	O
char	O
string	*(*(char))
[	O
GRAD_STRING_LENGTH	O
+	O
1	int
]	O
;	O
int	O
len	int
;	O
req_decrypt_password	(*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
string	*(*(char))
,	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
string	*(*(char))
)	O
;	O
pushstr	O
(	O
string	*(*(char))
,	O
len	int
)	O
;	O
}	O
else	O
pushstr	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
)	O
;	O
}	O
void	O
rw_attrn0	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
if	O
(	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avl_find	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
)	O
==	O
NULL	O
)	O
pushn	O
(	O
0	int
)	O
;	O
else	O
pushn	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
)	O
;	O
}	O
void	O
rw_attrs	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
RWSTYPE	long
index	(*(char),int)->(*(char))
;	O
cpopn	O
(	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avl_find_n	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
index	(*(char),int)->(*(char))
)	O
)	O
==	O
NULL	O
)	O
pushstr	O
(	O
""	*(char)
,	O
0	int
)	O
;	O
else	O
pushstr	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
)	O
;	O
}	O
void	O
rw_attrn	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
RWSTYPE	long
index	(*(char),int)->(*(char))
;	O
cpopn	O
(	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_avl_find_n	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,int)->(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
(	O
AVPLIST	O
(	O
&	O
mach	O
)	O
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
index	(*(char),int)->(*(char))
)	O
)	O
==	O
NULL	O
)	O
pushn	O
(	O
0	int
)	O
;	O
else	O
pushn	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
)	O
;	O
}	O
void	O
rw_attr_delete0	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_avl_delete	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),int)->(void)
(	O
&	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
;	O
}	O
void	O
rw_attr_delete	O
(	O
)	O
{	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
(	O
int	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
index	(*(char),int)->(*(char))
;	O
assert_request_presence	O
(	O
)	O
;	O
cpopn	O
(	O
&	O
index	(*(char),int)->(*(char))
)	O
;	O
grad_avl_delete_n	(*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),int,int)->(void)
(	O
&	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
rw_popn	O
(	O
)	O
{	O
RWSTYPE	long
n	long
;	O
cpopn	O
(	O
&	O
n	long
)	O
;	O
}	O
void	O
rw_popa	O
(	O
)	O
{	O
cpopn	O
(	O
&	O
mach	O
.	O
rA	O
)	O
;	O
}	O
void	O
rw_pusha	O
(	O
)	O
{	O
pushn	O
(	O
mach	O
.	O
rA	O
)	O
;	O
}	O
void	O
rw_adds	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
RWSTYPE	long
*	O
p	*(struct)
;	O
char	O
*	O
s	*(*(char))
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
p	*(struct)
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
s1	O
.	O
size	int
+	O
s2	O
.	O
size	int
+	O
1	int
)	O
;	O
s	*(*(char))
=	O
(	O
char	O
*	O
)	O
(	O
p	*(struct)
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(*(char))
,	O
s1	O
.	O
data	*(void)
,	O
s1	O
.	O
size	int
)	O
;	O
s	*(*(char))
+=	O
s1	O
.	O
size	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
s	*(*(char))
,	O
s2	O
.	O
data	*(void)
,	O
s2	O
.	O
size	int
)	O
;	O
s	*(*(char))
+=	O
s2	O
.	O
size	int
;	O
*	O
s	*(*(char))
=	O
0	int
;	O
p	*(struct)
[	O
0	int
]	O
=	O
s1	O
.	O
size	int
+	O
s2	O
.	O
size	int
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
p	*(struct)
)	O
;	O
}	O
void	O
rw_neg	O
(	O
)	O
{	O
checkpop	O
(	O
1	int
)	O
;	O
pushn	O
(	O
-	O
popn	O
(	O
)	O
)	O
;	O
}	O
void	O
rw_b_and	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
&	O
n2	O
)	O
;	O
}	O
void	O
rw_b_or	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
|	O
n2	O
)	O
;	O
}	O
void	O
rw_b_xor	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
^	O
n2	O
)	O
;	O
}	O
void	O
rw_shl	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
<<	O
n2	O
)	O
;	O
}	O
void	O
rw_shr	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
>>	O
n2	O
)	O
;	O
}	O
void	O
rw_add	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
+	O
n2	O
)	O
;	O
}	O
void	O
rw_sub	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
-	O
n2	O
)	O
;	O
}	O
void	O
rw_mul	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
*	O
n2	O
)	O
;	O
}	O
void	O
rw_div	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
if	O
(	O
n2	O
==	O
0	int
)	O
rw_error	O
(	O
_	O
(	O
"division by zero!"	*(char)
)	O
)	O
;	O
pushn	O
(	O
n1	O
/	O
n2	O
)	O
;	O
}	O
void	O
rw_rem	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
if	O
(	O
n2	O
==	O
0	int
)	O
rw_error	O
(	O
_	O
(	O
"division by zero!"	*(char)
)	O
)	O
;	O
pushn	O
(	O
n1	O
%	O
n2	O
)	O
;	O
}	O
void	O
rw_i2s	O
(	O
)	O
{	O
int	O
n	long
=	O
popn	O
(	O
)	O
;	O
char	O
buf	*(char)
[	O
64	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%d"	*(char)
,	O
n	long
)	O
;	O
pushstr	O
(	O
buf	*(char)
,	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
}	O
void	O
rw_s2i	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
popn	O
(	O
)	O
)	O
;	O
pushn	O
(	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
s	*(*(char))
.	O
data	*(void)
,	O
NULL	O
,	O
0	int
)	O
)	O
;	O
}	O
void	O
rw_eq	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
==	O
n2	O
)	O
;	O
}	O
void	O
rw_ne	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
!=	O
n2	O
)	O
;	O
}	O
void	O
rw_lt	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
<	O
n2	O
)	O
;	O
}	O
void	O
rw_le	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
<=	O
n2	O
)	O
;	O
}	O
void	O
rw_gt	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
>	O
n2	O
)	O
;	O
}	O
void	O
rw_ge	O
(	O
)	O
{	O
int	O
n1	O
,	O
n2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
n2	O
=	O
popn	O
(	O
)	O
;	O
n1	O
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
n1	O
>=	O
n2	O
)	O
;	O
}	O
void	O
rw_eqs	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
pushn	O
(	O
s1	O
.	O
size	int
==	O
s2	O
.	O
size	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
s1	O
.	O
size	int
)	O
==	O
0	int
)	O
;	O
}	O
void	O
rw_nes	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
pushn	O
(	O
!	O
(	O
s1	O
.	O
size	int
==	O
s2	O
.	O
size	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
s1	O
.	O
size	int
)	O
==	O
0	int
)	O
)	O
;	O
}	O
void	O
rw_lts	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
size_t	long
size	int
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	O
.	O
size	int
,	O
s2	O
.	O
size	int
)	O
;	O
pushn	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
size	int
<	O
0	int
)	O
||	O
s1	O
.	O
size	int
<	O
s2	O
.	O
size	int
)	O
;	O
}	O
void	O
rw_les	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
size_t	long
size	int
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	O
.	O
size	int
,	O
s2	O
.	O
size	int
)	O
;	O
pushn	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
size	int
<=	O
0	int
)	O
||	O
s1	O
.	O
size	int
<=	O
s2	O
.	O
size	int
)	O
;	O
}	O
void	O
rw_gts	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
size_t	long
size	int
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	O
.	O
size	int
,	O
s2	O
.	O
size	int
)	O
;	O
pushn	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
size	int
>	O
0	int
)	O
||	O
s1	O
.	O
size	int
>	O
s2	O
.	O
size	int
)	O
;	O
}	O
void	O
rw_ges	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s1	O
,	O
s2	O
;	O
size_t	long
size	int
;	O
checkpop	O
(	O
2	int
)	O
;	O
poparr	O
(	O
&	O
s2	O
)	O
;	O
poparr	O
(	O
&	O
s1	O
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	O
.	O
size	int
,	O
s2	O
.	O
size	int
)	O
;	O
pushn	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	O
.	O
data	*(void)
,	O
s2	O
.	O
data	*(void)
,	O
size	int
>=	O
0	int
)	O
||	O
s1	O
.	O
size	int
>=	O
s2	O
.	O
size	int
)	O
;	O
}	O
void	O
rw_not	O
(	O
)	O
{	O
int	O
n	long
;	O
checkpop	O
(	O
1	int
)	O
;	O
n	long
=	O
popn	O
(	O
)	O
;	O
pushn	O
(	O
!	O
n	long
)	O
;	O
}	O
static	O
void	O
need_pmatch	O
(	O
size_t	long
n	long
)	O
{	O
n	long
++	O
;	O
if	O
(	O
mach	O
.	O
nmatch	int
<	O
n	long
)	O
{	O
grad_free	(*(void))->(void)
(	O
mach	O
.	O
pmatch	*(struct(long,long))
)	O
;	O
mach	O
.	O
nmatch	int
=	O
n	long
;	O
mach	O
.	O
pmatch	*(struct(long,long))
=	O
grad_emalloc	(long)->(*(void))
(	O
n	long
*	O
sizeof	O
(	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
)	O
)	O
;	O
}	O
}	O
void	O
rw_match	O
(	O
)	O
{	O
COMP_REGEX	struct
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
(	O
COMP_REGEX	struct
*	O
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
int	O
rc	O
;	O
poparr	O
(	O
&	O
s	*(*(char))
)	O
;	O
need_pmatch	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
nmatch	int
)	O
;	O
mach	O
.	O
sA	*(char)
=	O
s	*(*(char))
.	O
data	*(void)
;	O
rc	O
=	O
regexec	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
mach	O
.	O
sA	*(char)
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
nmatch	int
+	O
1	int
,	O
mach	O
.	O
pmatch	*(struct(long,long))
,	O
0	int
)	O
;	O
if	O
(	O
rc	O
&&	O
GRAD_DEBUG_LEVEL	O
(	O
1	int
)	O
)	O
{	O
char	O
errbuf	O
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	O
,	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
->	O
regex	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
errbuf	O
,	O
sizeof	O
(	O
errbuf	O
)	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_DEBUG	O
,	O
_	O
(	O
"rewrite regex failure: %s. Input: %s"	*(char)
)	O
,	O
errbuf	O
,	O
(	O
char	O
*	O
)	O
mach	O
.	O
rA	O
)	O
;	O
}	O
pushn	O
(	O
rc	O
==	O
0	int
)	O
;	O
}	O
void	O
rw_jmp	O
(	O
)	O
{	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
mach	O
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_jne	O
(	O
)	O
{	O
int	O
n	long
;	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
n	long
=	O
popn	O
(	O
)	O
;	O
if	O
(	O
n	long
!=	O
0	int
)	O
mach	O
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_je	O
(	O
)	O
{	O
int	O
n	long
;	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
n	long
=	O
popn	O
(	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
mach	O
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_builtin	O
(	O
)	O
{	O
INSTR	*(()->(void))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
(	O
INSTR	*(()->(void))
)	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
;	O
pushn	O
(	O
mach	O
.	O
pc	int
)	O
;	O
enter	O
(	O
0	int
)	O
;	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
(	O
)	O
;	O
leave	O
(	O
)	O
;	O
}	O
void	O
run	O
(	O
pctr_t	int
pc	int
)	O
{	O
mach	O
.	O
pc	int
=	O
pc	int
;	O
while	O
(	O
rw_code	O
[	O
mach	O
.	O
pc	int
]	O
)	O
{	O
if	O
(	O
mach	O
.	O
pc	int
>=	O
rw_codesize	O
)	O
rw_error	O
(	O
_	O
(	O
"pc out of range"	*(char)
)	O
)	O
;	O
(	O
*	O
(	O
rw_code	O
[	O
mach	O
.	O
pc	int
++	O
]	O
)	O
)	O
(	O
)	O
;	O
}	O
}	O
void	O
gc	O
(	O
)	O
{	O
}	O
static	O
void	O
bi_length	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushn	O
(	O
s	*(*(char))
.	O
size	int
)	O
;	O
}	O
static	O
void	O
bi_index	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
char	O
*	O
p	*(struct)
;	O
int	O
c	*(void)
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
c	*(void)
=	O
(	O
int	O
)	O
getarg	O
(	O
1	int
)	O
;	O
p	*(struct)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
s	*(*(char))
.	O
data	*(void)
,	O
c	*(void)
,	O
s	*(*(char))
.	O
size	int
)	O
;	O
pushn	O
(	O
p	*(struct)
?	O
p	*(struct)
-	O
s	*(*(char))
.	O
data	*(void)
:	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
bi_rindex	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
int	O
i	O
;	O
int	O
c	*(void)
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
for	O
(	O
i	O
=	O
s	*(*(char))
.	O
size	int
-	O
1	int
;	O
i	O
>=	O
0	int
;	O
i	O
--	O
)	O
if	O
(	O
s	*(*(char))
.	O
data	*(void)
[	O
i	O
]	O
==	O
c	*(void)
)	O
break	O
;	O
pushn	O
(	O
i	O
)	O
;	O
}	O
static	O
void	O
bi_substr	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
src	*(struct(*(char),int,array(int),*(char),long))
;	O
RWSTYPE	long
*	O
p	*(struct)
;	O
char	O
*	O
dest	*(union)
;	O
int	O
start	*(struct(long,long))
,	O
length	short
;	O
mem2string	O
(	O
&	O
src	*(struct(*(char),int,array(int),*(char),long))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
3	int
)	O
)	O
;	O
start	*(struct(long,long))
=	O
getarg	O
(	O
2	int
)	O
;	O
length	short
=	O
getarg	O
(	O
1	int
)	O
;	O
if	O
(	O
length	short
<	O
0	int
)	O
length	short
=	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
size	int
-	O
start	*(struct(long,long))
;	O
p	*(struct)
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
length	short
+	O
1	int
)	O
;	O
dest	*(union)
=	O
(	O
char	O
*	O
)	O
(	O
p	*(struct)
+	O
1	int
)	O
;	O
if	O
(	O
length	short
>	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dest	*(union)
,	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
data	*(void)
+	O
start	*(struct(long,long))
,	O
length	short
)	O
;	O
dest	*(union)
[	O
length	short
]	O
=	O
0	int
;	O
p	*(struct)
[	O
0	int
]	O
=	O
length	short
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
p	*(struct)
)	O
;	O
}	O
static	O
void	O
bi_field	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
str	*(char)
;	O
char	O
*	O
p	*(struct)
,	O
*	O
endp	*(*(char))
;	O
int	O
fn	*((*(void),*(struct(*(struct`),*(char))))->(int))
=	O
getarg	O
(	O
1	int
)	O
;	O
char	O
*	O
s	*(*(char))
=	O
""	*(char)
;	O
int	O
len	int
=	O
1	int
;	O
mem2string	O
(	O
&	O
str	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
endp	*(*(char))
=	O
str	*(char)
.	O
data	*(void)
+	O
str	*(char)
.	O
size	int
;	O
for	O
(	O
p	*(struct)
=	O
str	*(char)
.	O
data	*(void)
;	O
p	*(struct)
<	O
endp	*(*(char))
&&	O
fn	*((*(void),*(struct(*(struct`),*(char))))->(int))
--	O
;	O
)	O
{	O
while	O
(	O
p	*(struct)
<	O
endp	*(*(char))
&&	O
isspace	(int)->(int)
(	O
*	O
p	*(struct)
)	O
)	O
p	*(struct)
++	O
;	O
s	*(*(char))
=	O
p	*(struct)
;	O
len	int
=	O
0	int
;	O
while	O
(	O
p	*(struct)
<	O
endp	*(*(char))
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
p	*(struct)
)	O
)	O
{	O
p	*(struct)
++	O
;	O
len	int
++	O
;	O
}	O
}	O
if	O
(	O
p	*(struct)
==	O
endp	*(*(char))
&&	O
fn	*((*(void),*(struct(*(struct`),*(char))))->(int))
)	O
pushstr	O
(	O
""	*(char)
,	O
0	int
)	O
;	O
else	O
pushstr	O
(	O
s	*(*(char))
,	O
len	int
)	O
;	O
}	O
static	O
void	O
bi_logit	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
msg	*(char)
;	O
mem2string	O
(	O
&	O
msg	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_INFO	O
,	O
"%s"	*(char)
,	O
msg	*(char)
.	O
data	*(void)
)	O
;	O
pushn	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
bi_htonl	O
(	O
)	O
{	O
pushn	O
(	O
htonl	(int)->(int)
(	O
getarg	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_ntohl	O
(	O
)	O
{	O
pushn	O
(	O
ntohl	(int)->(int)
(	O
getarg	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_htons	O
(	O
)	O
{	O
pushn	O
(	O
htons	(short)->(short)
(	O
getarg	O
(	O
1	int
)	O
&	O
0xffff	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_ntohs	O
(	O
)	O
{	O
pushn	O
(	O
ntohs	(short)->(short)
(	O
getarg	O
(	O
1	int
)	O
&	O
0xffff	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_inet_ntoa	O
(	O
)	O
{	O
char	O
buffer	*(char)
[	O
GRAD_IPV4_STRING_LENGTH	O
]	O
;	O
char	O
*	O
s	*(*(char))
=	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
getarg	O
(	O
1	int
)	O
,	O
buffer	*(char)
)	O
;	O
pushstr	O
(	O
s	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
)	O
;	O
}	O
static	O
void	O
bi_inet_aton	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushn	O
(	O
grad_ip_strtoip	(*(char))->(int)
(	O
s	*(*(char))
.	O
data	*(void)
)	O
)	O
;	O
}	O
static	O
void	O
bi_tolower	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
src	*(struct(*(char),int,array(int),*(char),long))
;	O
grad_string_t	struct(long,*(char))
dest	*(union)
;	O
int	O
i	O
;	O
mem2string	O
(	O
&	O
src	*(struct(*(char),int,array(int),*(char),long))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushstr	O
(	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
data	*(void)
,	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
size	int
)	O
;	O
mem2string	O
(	O
&	O
dest	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
tos	O
(	O
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
dest	*(union)
.	O
size	int
;	O
i	O
++	O
)	O
dest	*(union)
.	O
data	*(void)
[	O
i	O
]	O
=	O
tolower	(int)->(int)
(	O
dest	*(union)
.	O
data	*(void)
[	O
i	O
]	O
)	O
;	O
}	O
static	O
void	O
bi_toupper	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
src	*(struct(*(char),int,array(int),*(char),long))
;	O
grad_string_t	struct(long,*(char))
dest	*(union)
;	O
int	O
i	O
;	O
mem2string	O
(	O
&	O
src	*(struct(*(char),int,array(int),*(char),long))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushstr	O
(	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
data	*(void)
,	O
src	*(struct(*(char),int,array(int),*(char),long))
.	O
size	int
)	O
;	O
mem2string	O
(	O
&	O
dest	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
tos	O
(	O
)	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
dest	*(union)
.	O
size	int
;	O
i	O
++	O
)	O
dest	*(union)
.	O
data	*(void)
[	O
i	O
]	O
=	O
toupper	(int)->(int)
(	O
dest	*(union)
.	O
data	*(void)
[	O
i	O
]	O
)	O
;	O
}	O
static	O
void	O
bi_request_code_string	O
(	O
)	O
{	O
int	O
code	char
=	O
(	O
int	O
)	O
getarg	O
(	O
1	int
)	O
;	O
const	O
char	O
*	O
s	*(*(char))
=	O
grad_request_code_to_name	(int)->(*(char))
(	O
code	char
)	O
;	O
pushstr	O
(	O
s	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
)	O
;	O
}	O
static	O
void	O
bi_request_source_ip	O
(	O
)	O
{	O
assert_request_presence	O
(	O
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
ipaddr	int
)	O
;	O
}	O
static	O
void	O
bi_request_source_port	O
(	O
)	O
{	O
assert_request_presence	O
(	O
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
udp_port	short
)	O
;	O
}	O
static	O
void	O
bi_request_id	O
(	O
)	O
{	O
assert_request_presence	O
(	O
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
id	char
)	O
;	O
}	O
static	O
void	O
bi_request_code	O
(	O
)	O
{	O
assert_request_presence	O
(	O
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
code	char
)	O
;	O
}	O
static	O
void	O
bi_nas_name	O
(	O
)	O
{	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
;	O
grad_uint32_t	int
ip	*(struct)
=	O
(	O
grad_uint32_t	int
)	O
getarg	O
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	(int)->(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))
(	O
ip	*(struct)
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
s	*(*(char))
=	O
nas	int
->	O
shortname	array(char)
[	O
0	int
]	O
?	O
nas	int
->	O
shortname	array(char)
:	O
nas	int
->	O
longname	array(char)
;	O
pushstr	O
(	O
s	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	O
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ip	*(struct)
,	O
nasname	O
,	O
sizeof	O
(	O
nasname	O
)	O
)	O
;	O
pushstr	O
(	O
nasname	O
,	O
strlen	(*(char))->(long)
(	O
nasname	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_nas_short_name	O
(	O
)	O
{	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
;	O
grad_uint32_t	int
ip	*(struct)
=	O
(	O
grad_uint32_t	int
)	O
getarg	O
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	(int)->(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))
(	O
ip	*(struct)
)	O
)	O
&&	O
nas	int
->	O
shortname	array(char)
[	O
0	int
]	O
)	O
{	O
pushstr	O
(	O
nas	int
->	O
shortname	array(char)
,	O
strlen	(*(char))->(long)
(	O
nas	int
->	O
shortname	array(char)
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	O
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ip	*(struct)
,	O
nasname	O
,	O
sizeof	O
(	O
nasname	O
)	O
)	O
;	O
pushstr	O
(	O
nasname	O
,	O
strlen	(*(char))->(long)
(	O
nasname	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_nas_full_name	O
(	O
)	O
{	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
;	O
grad_uint32_t	int
ip	*(struct)
=	O
(	O
grad_uint32_t	int
)	O
getarg	O
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	(int)->(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))
(	O
ip	*(struct)
)	O
)	O
!=	O
NULL	O
)	O
{	O
pushstr	O
(	O
nas	int
->	O
longname	array(char)
,	O
strlen	(*(char))->(long)
(	O
nas	int
->	O
longname	array(char)
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	O
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ip	*(struct)
,	O
nasname	O
,	O
sizeof	O
(	O
nasname	O
)	O
)	O
;	O
pushstr	O
(	O
nasname	O
,	O
strlen	(*(char))->(long)
(	O
nasname	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_gethostbyaddr	O
(	O
)	O
{	O
grad_uint32_t	int
ip	*(struct)
=	O
(	O
grad_uint32_t	int
)	O
getarg	O
(	O
1	int
)	O
;	O
char	O
nasname	O
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ip	*(struct)
,	O
nasname	O
,	O
sizeof	O
(	O
nasname	O
)	O
)	O
;	O
pushstr	O
(	O
nasname	O
,	O
strlen	(*(char))->(long)
(	O
nasname	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_gethostbyname	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
s	*(*(char))
.	O
data	*(void)
)	O
)	O
;	O
}	O
static	O
void	O
bi_time	O
(	O
)	O
{	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
time	struct(long,long)
(	O
NULL	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_strftime	O
(	O
)	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
char	O
*	O
base	int
;	O
time_t	long
t	long
=	O
(	O
time_t	long
)	O
getarg	O
(	O
1	int
)	O
;	O
grad_string_t	struct(long,*(char))
fmt	*(char)
;	O
size_t	long
n	long
;	O
mem2string	O
(	O
&	O
fmt	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
;	O
base	int
=	O
temp_space_create	O
(	O
)	O
;	O
n	long
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
base	int
,	O
temp_space_size	O
(	O
)	O
,	O
fmt	*(char)
.	O
data	*(void)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
pushstr	O
(	O
base	int
,	O
n	long
)	O
;	O
}	O
static	O
void	O
rw_regerror	O
(	O
const	O
char	O
*	O
prefix	O
,	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
*	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
int	O
rc	O
)	O
{	O
size_t	long
sz	O
=	O
regerror	O
(	O
rc	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	O
=	O
malloc	(long)->(*(void))
(	O
sz	O
+	O
strlen	(*(char))->(long)
(	O
prefix	O
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
errbuf	O
)	O
rw_error	O
(	O
prefix	O
)	O
;	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
errbuf	O
,	O
prefix	O
)	O
;	O
regerror	O
(	O
rc	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
errbuf	O
+	O
strlen	(*(char))->(long)
(	O
prefix	O
)	O
,	O
sz	O
)	O
;	O
rw_error_free	O
(	O
errbuf	O
)	O
;	O
}	O
}	O
enum	O
subst_segment_type	O
{	O
subst_text	O
,	O
subst_ref	O
,	O
subst_match	O
}	O
;	O
struct	O
subst_segment	O
{	O
enum	O
subst_segment_type	O
type	int
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
ptr	*(*(void))
;	O
size_t	long
len	int
;	O
}	O
text	*(char)
;	O
size_t	long
ref	O
;	O
}	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
;	O
}	O
;	O
static	O
void	O
add_text_segment	O
(	O
grad_list_t	struct
*	O
lst	O
,	O
char	O
*	O
ptr	*(*(void))
,	O
char	O
*	O
end	*(long)
)	O
{	O
struct	O
subst_segment	O
*	O
seg	O
;	O
if	O
(	O
ptr	*(*(void))
>=	O
end	*(long)
)	O
return	O
;	O
seg	O
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
seg	O
)	O
)	O
;	O
seg	O
->	O
type	int
=	O
subst_text	O
;	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
text	*(char)
.	O
ptr	*(*(void))
=	O
ptr	*(*(void))
;	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
text	*(char)
.	O
len	int
=	O
end	*(long)
-	O
ptr	*(*(void))
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
lst	O
,	O
seg	O
)	O
;	O
}	O
static	O
void	O
add_match_segment	O
(	O
grad_list_t	struct
*	O
lst	O
)	O
{	O
struct	O
subst_segment	O
*	O
seg	O
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
seg	O
)	O
)	O
;	O
seg	O
->	O
type	int
=	O
subst_match	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
lst	O
,	O
seg	O
)	O
;	O
}	O
static	O
void	O
add_ref_segment	O
(	O
grad_list_t	struct
*	O
lst	O
,	O
size_t	long
ref	O
)	O
{	O
struct	O
subst_segment	O
*	O
seg	O
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
seg	O
)	O
)	O
;	O
seg	O
->	O
type	int
=	O
subst_ref	O
;	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ref	O
=	O
ref	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
lst	O
,	O
seg	O
)	O
;	O
}	O
grad_list_t	struct
*	O
subst_create	O
(	O
char	O
*	O
text	*(char)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
grad_list_t	struct
*	O
lst	O
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
lst	O
)	O
return	O
lst	O
;	O
p	*(struct)
=	O
text	*(char)
;	O
while	O
(	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
*	O
p	*(struct)
==	O
'\\'	O
&&	O
p	*(struct)
[	O
1	int
]	O
)	O
{	O
if	O
(	O
p	*(struct)
[	O
1	int
]	O
==	O
'&'	O
)	O
{	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
)	O
;	O
text	*(char)
=	O
++	O
p	*(struct)
;	O
p	*(struct)
++	O
;	O
}	O
else	O
if	O
(	O
p	*(struct)
[	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
+	O
1	int
)	O
;	O
p	*(struct)
+=	O
2	int
;	O
text	*(char)
=	O
p	*(struct)
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
p	*(struct)
[	O
1	int
]	O
)	O
)	O
{	O
size_t	long
ref	O
;	O
char	O
*	O
q	O
;	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
)	O
;	O
ref	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(struct)
+	O
1	int
,	O
&	O
q	O
,	O
10	int
)	O
;	O
add_ref_segment	O
(	O
lst	O
,	O
ref	O
)	O
;	O
text	*(char)
=	O
p	*(struct)
=	O
q	O
;	O
}	O
else	O
{	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
)	O
;	O
text	*(char)
=	O
++	O
p	*(struct)
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	*(struct)
==	O
'&'	O
)	O
{	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
)	O
;	O
add_match_segment	O
(	O
lst	O
)	O
;	O
text	*(char)
=	O
++	O
p	*(struct)
;	O
}	O
else	O
p	*(struct)
++	O
;	O
}	O
add_text_segment	O
(	O
lst	O
,	O
text	*(char)
,	O
p	*(struct)
)	O
;	O
return	O
lst	O
;	O
}	O
int	O
seg_free	O
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
ARG_UNUSED	O
)	O
{	O
grad_free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
subst_destroy	O
(	O
grad_list_t	struct
*	O
lst	O
)	O
{	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
lst	O
,	O
seg_free	O
,	O
NULL	O
)	O
;	O
}	O
void	O
subst_run	O
(	O
grad_list_t	struct
*	O
subst	O
,	O
size_t	long
nsub	O
,	O
char	O
*	O
*	O
baseptr	O
,	O
char	O
*	O
arg	*(union)
)	O
{	O
grad_iterator_t	struct
*	O
itr	*((*(void),*(void))->(int))
=	O
grad_iterator_create	(*(struct))->(*(struct))
(	O
subst	O
)	O
;	O
struct	O
subst_segment	O
*	O
seg	O
;	O
for	O
(	O
seg	O
=	O
grad_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
seg	O
;	O
seg	O
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
switch	O
(	O
seg	O
->	O
type	int
)	O
{	O
case	O
subst_text	O
:	O
temp_space_copy	O
(	O
baseptr	O
,	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
text	*(char)
.	O
ptr	*(*(void))
,	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
text	*(char)
.	O
len	int
)	O
;	O
break	O
;	O
case	O
subst_ref	O
:	O
if	O
(	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ref	O
>=	O
nsub	O
)	O
rw_error	O
(	O
_	O
(	O
"Invalid backreference"	*(char)
)	O
)	O
;	O
temp_space_copy	O
(	O
baseptr	O
,	O
arg	*(union)
+	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ref	O
]	O
.	O
rm_so	long
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ref	O
]	O
.	O
rm_eo	long
-	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
seg	O
->	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ref	O
]	O
.	O
rm_so	long
)	O
;	O
break	O
;	O
case	O
subst_match	O
:	O
temp_space_copy	O
(	O
baseptr	O
,	O
arg	*(union)
+	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_so	long
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_eo	long
-	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
}	O
}	O
grad_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
static	O
void	O
bi_gsub	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
re_str	O
;	O
grad_string_t	struct(long,*(char))
repl	O
;	O
grad_string_t	struct(long,*(char))
arg	*(union)
;	O
char	O
*	O
p	*(struct)
;	O
char	O
*	O
base	int
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
grad_list_t	struct
*	O
subst	O
;	O
int	O
rc	O
;	O
mem2string	O
(	O
&	O
re_str	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
3	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
repl	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
arg	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
p	*(struct)
=	O
arg	*(union)
.	O
data	*(void)
;	O
rc	O
=	O
regcomp	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
re_str	O
.	O
data	*(void)
,	O
regcomp_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
rw_regerror	O
(	O
_	O
(	O
"regexp compile error: "	*(char)
)	O
,	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
rc	O
)	O
;	O
need_pmatch	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
)	O
;	O
subst	O
=	O
subst_create	O
(	O
repl	O
.	O
data	*(void)
)	O
;	O
if	O
(	O
!	O
subst	O
)	O
rw_error	O
(	O
_	O
(	O
"gsub: not enough memory"	*(char)
)	O
)	O
;	O
base	int
=	O
temp_space_create	O
(	O
)	O
;	O
while	O
(	O
*	O
p	*(struct)
&&	O
regexec	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
p	*(struct)
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
+	O
1	int
,	O
mach	O
.	O
pmatch	*(struct(long,long))
,	O
0	int
)	O
==	O
0	int
)	O
{	O
temp_space_copy	O
(	O
&	O
base	int
,	O
p	*(struct)
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
subst_run	O
(	O
subst	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
+	O
1	int
,	O
&	O
base	int
,	O
p	*(struct)
)	O
;	O
p	*(struct)
+=	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_eo	long
;	O
if	O
(	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_eo	long
==	O
0	int
)	O
p	*(struct)
++	O
;	O
}	O
temp_space_copy	O
(	O
&	O
base	int
,	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
+	O
1	int
)	O
;	O
subst_destroy	O
(	O
subst	O
)	O
;	O
regfree	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
temp_space_fix	O
(	O
base	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_sub	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
re_str	O
;	O
grad_string_t	struct(long,*(char))
repl	O
;	O
grad_string_t	struct(long,*(char))
arg	*(union)
;	O
char	O
*	O
p	*(struct)
;	O
char	O
*	O
base	int
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
grad_list_t	struct
*	O
subst	O
;	O
int	O
rc	O
;	O
mem2string	O
(	O
&	O
re_str	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
3	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
repl	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
arg	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
rc	O
=	O
regcomp	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
re_str	O
.	O
data	*(void)
,	O
regcomp_flags	O
)	O
;	O
if	O
(	O
rc	O
)	O
rw_regerror	O
(	O
_	O
(	O
"regexp compile error: "	*(char)
)	O
,	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
rc	O
)	O
;	O
need_pmatch	O
(	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
)	O
;	O
subst	O
=	O
subst_create	O
(	O
repl	O
.	O
data	*(void)
)	O
;	O
if	O
(	O
!	O
subst	O
)	O
rw_error	O
(	O
_	O
(	O
"sub: not enough memory"	*(char)
)	O
)	O
;	O
base	int
=	O
temp_space_create	O
(	O
)	O
;	O
p	*(struct)
=	O
arg	*(union)
.	O
data	*(void)
;	O
if	O
(	O
regexec	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
,	O
p	*(struct)
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
+	O
1	int
,	O
mach	O
.	O
pmatch	*(struct(long,long))
,	O
0	int
)	O
==	O
0	int
)	O
{	O
temp_space_copy	O
(	O
&	O
base	int
,	O
p	*(struct)
,	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
subst_run	O
(	O
subst	O
,	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
.	O
re_nsub	long
+	O
1	int
,	O
&	O
base	int
,	O
p	*(struct)
)	O
;	O
p	*(struct)
+=	O
mach	O
.	O
pmatch	*(struct(long,long))
[	O
0	int
]	O
.	O
rm_eo	long
;	O
}	O
temp_space_copy	O
(	O
&	O
base	int
,	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
+	O
1	int
)	O
;	O
subst_destroy	O
(	O
subst	O
)	O
;	O
regfree	O
(	O
&	O
rx	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
temp_space_fix	O
(	O
base	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_qprn	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
arg	*(union)
;	O
char	O
*	O
p	*(struct)
,	O
*	O
s	*(*(char))
,	O
*	O
end	*(long)
;	O
size_t	long
count	int
;	O
RWSTYPE	long
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
mem2string	O
(	O
&	O
arg	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
end	*(long)
=	O
arg	*(union)
.	O
data	*(void)
+	O
arg	*(union)
.	O
size	int
;	O
for	O
(	O
count	int
=	O
0	int
,	O
p	*(struct)
=	O
arg	*(union)
.	O
data	*(void)
;	O
p	*(struct)
<	O
end	*(long)
;	O
p	*(struct)
++	O
)	O
if	O
(	O
!	O
ISPRINT	O
(	O
*	O
p	*(struct)
)	O
)	O
count	int
++	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
arg	*(union)
.	O
size	int
+	O
2	int
*	O
count	int
+	O
1	int
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
[	O
0	int
]	O
=	O
arg	*(union)
.	O
size	int
+	O
2	int
*	O
count	int
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
for	O
(	O
p	*(struct)
=	O
(	O
char	O
*	O
)	O
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
+	O
1	int
)	O
,	O
s	*(*(char))
=	O
arg	*(union)
.	O
data	*(void)
;	O
s	*(*(char))
<	O
end	*(long)
;	O
s	*(*(char))
++	O
)	O
{	O
if	O
(	O
ISPRINT	O
(	O
*	O
s	*(*(char))
)	O
)	O
*	O
p	*(struct)
++	O
=	O
*	O
s	*(*(char))
;	O
else	O
{	O
char	O
buf	*(char)
[	O
3	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
"%02X"	*(char)
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	*(*(char))
)	O
;	O
*	O
p	*(struct)
++	O
=	O
'%'	O
;	O
*	O
p	*(struct)
++	O
=	O
buf	*(char)
[	O
0	int
]	O
;	O
*	O
p	*(struct)
++	O
=	O
buf	*(char)
[	O
1	int
]	O
;	O
}	O
}	O
*	O
p	*(struct)
=	O
0	int
;	O
}	O
static	O
void	O
bi_quote_string	O
(	O
)	O
{	O
int	O
quote	*(int)
;	O
grad_string_t	struct(long,*(char))
arg	*(union)
;	O
RWSTYPE	long
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
char	O
*	O
p	*(struct)
;	O
size_t	long
size	int
;	O
mem2string	O
(	O
&	O
arg	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
size	int
=	O
grad_argcv_quoted_length_n	(*(char),long,*(int))->(long)
(	O
arg	*(union)
.	O
data	*(void)
,	O
arg	*(union)
.	O
size	int
,	O
&	O
quote	*(int)
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
size	int
+	O
1	int
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
[	O
0	int
]	O
=	O
size	int
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
p	*(struct)
=	O
(	O
char	O
*	O
)	O
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
+	O
1	int
)	O
;	O
grad_argcv_quote_copy_n	(*(char),*(char),long)->(void)
(	O
p	*(struct)
,	O
arg	*(union)
.	O
data	*(void)
,	O
arg	*(union)
.	O
size	int
)	O
;	O
}	O
static	O
void	O
bi_unquote_string	O
(	O
)	O
{	O
int	O
quote	*(int)
;	O
grad_string_t	struct(long,*(char))
arg	*(union)
;	O
RWSTYPE	long
*	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
;	O
char	O
*	O
p	*(struct)
;	O
size_t	long
size	int
;	O
mem2string	O
(	O
&	O
arg	*(union)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
=	O
heap_reserve	O
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
arg	*(union)
.	O
size	int
+	O
1	int
)	O
;	O
p	*(struct)
=	O
(	O
char	O
*	O
)	O
(	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
+	O
1	int
)	O
;	O
grad_argcv_unquote_copy	(*(char),*(char),long)->(void)
(	O
p	*(struct)
,	O
arg	*(union)
.	O
data	*(void)
,	O
arg	*(union)
.	O
size	int
)	O
;	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
[	O
0	int
]	O
=	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
;	O
pushn	O
(	O
(	O
RWSTYPE	long
)	O
sp	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int))
)	O
;	O
}	O
static	O
void	O
bi_textdomain	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
pushstr	O
(	O
default_gettext_domain	O
,	O
strlen	(*(char))->(long)
(	O
default_gettext_domain	O
)	O
)	O
;	O
grad_string_replace	(*(*(char)),*(char))->(*(char))
(	O
&	O
default_gettext_domain	O
,	O
s	*(*(char))
.	O
data	*(void)
)	O
;	O
}	O
static	O
void	O
bi_gettext	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
const	O
char	O
*	O
p	*(struct)
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
p	*(struct)
=	O
dgettext	(*(char),*(char))->(*(char))
(	O
default_gettext_domain	O
,	O
s	*(*(char))
.	O
data	*(void)
)	O
;	O
pushstr	O
(	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
)	O
;	O
}	O
static	O
void	O
bi_dgettext	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
domain	*(char)
;	O
grad_string_t	struct(long,*(char))
text	*(char)
;	O
const	O
char	O
*	O
p	*(struct)
;	O
mem2string	O
(	O
&	O
domain	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
text	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
1	int
)	O
)	O
;	O
p	*(struct)
=	O
dgettext	(*(char),*(char))->(*(char))
(	O
domain	*(char)
.	O
data	*(void)
,	O
text	*(char)
.	O
data	*(void)
)	O
;	O
pushstr	O
(	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
)	O
;	O
}	O
static	O
void	O
bi_ngettext	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
grad_string_t	struct(long,*(char))
pl	O
;	O
unsigned	O
long	O
n	long
;	O
const	O
char	O
*	O
p	*(struct)
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
3	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
pl	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
n	long
=	O
(	O
unsigned	O
long	O
)	O
getarg	O
(	O
1	int
)	O
;	O
p	*(struct)
=	O
dngettext	(*(char),*(char),*(char),long)->(*(char))
(	O
default_gettext_domain	O
,	O
s	*(*(char))
.	O
data	*(void)
,	O
pl	O
.	O
data	*(void)
,	O
n	long
)	O
;	O
pushstr	O
(	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
)	O
;	O
}	O
static	O
void	O
bi_dngettext	O
(	O
)	O
{	O
grad_string_t	struct(long,*(char))
domain	*(char)
;	O
grad_string_t	struct(long,*(char))
s	*(*(char))
;	O
grad_string_t	struct(long,*(char))
pl	O
;	O
unsigned	O
long	O
n	long
;	O
const	O
char	O
*	O
p	*(struct)
;	O
mem2string	O
(	O
&	O
domain	*(char)
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
4	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
s	*(*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
3	int
)	O
)	O
;	O
mem2string	O
(	O
&	O
pl	O
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	O
(	O
2	int
)	O
)	O
;	O
n	long
=	O
(	O
unsigned	O
long	O
)	O
getarg	O
(	O
1	int
)	O
;	O
p	*(struct)
=	O
dngettext	(*(char),*(char),*(char),long)->(*(char))
(	O
domain	*(char)
.	O
data	*(void)
,	O
s	*(*(char))
.	O
data	*(void)
,	O
pl	O
.	O
data	*(void)
,	O
n	long
)	O
;	O
pushstr	O
(	O
p	*(struct)
,	O
strlen	(*(char))->(long)
(	O
p	*(struct)
)	O
)	O
;	O
}	O
static	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
builtin	O
[	O
]	O
=	O
{	O
{	O
bi_length	O
,	O
"length"	*(char)
,	O
Integer	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_index	O
,	O
"index"	*(char)
,	O
Integer	int
,	O
"si"	*(char)
}	O
,	O
{	O
bi_rindex	O
,	O
"rindex"	*(char)
,	O
Integer	int
,	O
"si"	*(char)
}	O
,	O
{	O
bi_substr	O
,	O
"substr"	*(char)
,	O
String	int
,	O
"sii"	*(char)
}	O
,	O
{	O
bi_logit	O
,	O
"logit"	*(char)
,	O
Integer	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_field	O
,	O
"field"	*(char)
,	O
String	int
,	O
"si"	*(char)
}	O
,	O
{	O
bi_ntohl	O
,	O
"ntohl"	*(char)
,	O
Integer	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_htonl	O
,	O
"htonl"	*(char)
,	O
Integer	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_ntohs	O
,	O
"ntohs"	*(char)
,	O
Integer	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_htons	O
,	O
"htons"	*(char)
,	O
Integer	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_inet_ntoa	O
,	O
"inet_ntoa"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_inet_aton	O
,	O
"inet_aton"	*(char)
,	O
Integer	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_sub	O
,	O
"sub"	*(char)
,	O
String	int
,	O
"sss"	*(char)
}	O
,	O
{	O
bi_gsub	O
,	O
"gsub"	*(char)
,	O
String	int
,	O
"sss"	*(char)
}	O
,	O
{	O
bi_qprn	O
,	O
"qprn"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_tolower	O
,	O
"tolower"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_toupper	O
,	O
"toupper"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_unquote_string	O
,	O
"unquote_string"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_quote_string	O
,	O
"quote_string"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_request_code_string	O
,	O
"request_code_string"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_gettext	O
,	O
"gettext"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_gettext	O
,	O
"_"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_dgettext	O
,	O
"dgettext"	*(char)
,	O
String	int
,	O
"ss"	*(char)
}	O
,	O
{	O
bi_ngettext	O
,	O
"ngettext"	*(char)
,	O
String	int
,	O
"ssi"	*(char)
}	O
,	O
{	O
bi_dngettext	O
,	O
"dngettext"	*(char)
,	O
String	int
,	O
"sssi"	*(char)
}	O
,	O
{	O
bi_textdomain	O
,	O
"textdomain"	*(char)
,	O
String	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_request_source_ip	O
,	O
"request_source_ip"	*(char)
,	O
Integer	int
,	O
""	*(char)
}	O
,	O
{	O
bi_request_source_port	O
,	O
"request_source_port"	*(char)
,	O
Integer	int
,	O
""	*(char)
}	O
,	O
{	O
bi_request_id	O
,	O
"request_id"	*(char)
,	O
Integer	int
,	O
""	*(char)
}	O
,	O
{	O
bi_request_code	O
,	O
"request_code"	*(char)
,	O
Integer	int
,	O
""	*(char)
}	O
,	O
{	O
bi_nas_name	O
,	O
"nas_name"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_nas_short_name	O
,	O
"nas_short_name"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_nas_full_name	O
,	O
"nas_full_name"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_gethostbyaddr	O
,	O
"gethostbyaddr"	*(char)
,	O
Integer	int
,	O
"s"	*(char)
}	O
,	O
{	O
bi_gethostbyname	O
,	O
"gethostbyname"	*(char)
,	O
String	int
,	O
"i"	*(char)
}	O
,	O
{	O
bi_time	O
,	O
"time"	*(char)
,	O
Integer	int
,	O
""	*(char)
}	O
,	O
{	O
bi_strftime	O
,	O
"strftime"	*(char)
,	O
String	int
,	O
"si"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
builtin_t	struct(*(()->(void)),*(char),enum(int,int,int),*(char))
*	O
builtin_lookup	O
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
builtin	O
[	O
i	O
]	O
.	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
;	O
i	O
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
builtin	O
[	O
i	O
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
&	O
builtin	O
[	O
i	O
]	O
;	O
return	O
NULL	O
;	O
}	O
int	O
function_free	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
{	O
PARAMETER	struct
*	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
,	O
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
rx_free	O
(	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
)	O
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
f	*((*(void),*(struct(*(char),long)),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
while	O
(	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_free	(*(void))->(void)
(	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
)	O
;	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
return	O
0	int
;	O
}	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
function_install	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
{	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
if	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
name	*(char)
)	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
loc	struct(*(char),long)
,	O
_	O
(	O
"redefinition of function %s"	*(char)
)	O
)	O
;	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
&	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
loc	struct(*(char),long)
,	O
_	O
(	O
"previously defined here"	*(char)
)	O
)	O
;	O
errcnt	long
++	O
;	O
return	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
}	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
name	*(char)
)	O
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
rettype	enum(int,int,int)
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rettype	enum(int,int,int)
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
entry	int
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
entry	int
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rx_list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),*(struct(*(struct`),*(struct`),*(struct`),struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int),int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int))
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
nparm	int
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
nparm	int
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
stack_alloc	int
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
stack_alloc	int
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
->	O
loc	struct(*(char),long)
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
loc	struct(*(char),long)
;	O
return	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
}	O
static	O
char	O
pair_print_prefix	O
[	O
]	O
=	O
"    "	*(char)
;	O
static	O
void	O
rw_mach_init	O
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mach	O
,	O
0	int
,	O
sizeof	O
(	O
mach	O
)	O
)	O
;	O
if	O
(	O
!	O
runtime_stack	O
)	O
runtime_stack	O
=	O
grad_emalloc	(long)->(*(void))
(	O
rewrite_stack_size	O
*	O
sizeof	O
(	O
runtime_stack	O
[	O
0	int
]	O
)	O
)	O
;	O
mach	O
.	O
stack	*(long)
=	O
runtime_stack	O
;	O
mach	O
.	O
st	int
=	O
0	int
;	O
mach	O
.	O
ht	int
=	O
rewrite_stack_size	O
-	O
1	int
;	O
grad_string_replace	(*(*(char)),*(char))->(*(char))
(	O
&	O
default_gettext_domain	O
,	O
PACKAGE	O
)	O
;	O
}	O
static	O
void	O
rw_mach_destroy	O
(	O
)	O
{	O
grad_free	(*(void))->(void)
(	O
mach	O
.	O
pmatch	*(struct(long,long))
)	O
;	O
mach	O
.	O
pmatch	*(struct(long,long))
=	O
NULL	O
;	O
}	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
rewrite_check_function	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
grad_data_type_t	enum(int,int,int)
rettype	enum(int,int,int)
,	O
char	O
*	O
typestr	*(char)
)	O
{	O
int	O
i	O
;	O
PARAMETER	struct
*	O
p	*(struct)
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s not defined"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rettype	enum(int,int,int)
!=	O
rettype	enum(int,int,int)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s returns wrong data type"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	O
=	O
0	int
,	O
p	*(struct)
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
parm	*(struct(*(struct(*(struct`),*(struct`),enum(int,int,int),int)),*(struct(*(struct`),*(struct`),enum(int,int,int),int)),enum(int,int,int),int))
;	O
i	O
<	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
nparm	int
;	O
i	O
++	O
,	O
p	*(struct)
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
switch	O
(	O
typestr	*(char)
[	O
i	O
]	O
)	O
{	O
case	O
0	int
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s takes too many arguments"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
NULL	O
;	O
case	O
'i'	O
:	O
if	O
(	O
p	*(struct)
->	O
datatype	enum(int,int,int)
!=	O
Integer	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s: argument %d must be integer"	*(char)
)	O
,	O
name	*(char)
,	O
i	O
+	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
p	*(struct)
->	O
datatype	enum(int,int,int)
!=	O
String	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s: argument %d must be string"	*(char)
)	O
,	O
name	*(char)
,	O
i	O
+	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad datatype"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
typestr	*(char)
[	O
i	O
]	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"function %s takes too few arguments"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
}	O
int	O
run_init	O
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
request	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
{	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
rw_mach_init	O
(	O
)	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
mach	O
.	O
jmp	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
rw_mach_destroy	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
request	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
debug_open_file	O
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"Before rewriting:\n"	*(char)
)	O
;	O
grad_avl_fprint	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
pair_print_prefix	O
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
pushn	O
(	O
0	int
)	O
;	O
run	O
(	O
pc	int
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
debug_open_file	O
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"After rewriting\n"	*(char)
)	O
;	O
grad_avl_fprint	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
pair_print_prefix	O
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
rw_mach_destroy	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
return_value	O
(	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
u_char	char
*	O
p	*(struct)
;	O
switch	O
(	O
val	array(int)
->	O
type	int
)	O
{	O
case	O
Integer	int
:	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
=	O
mach	O
.	O
rA	O
;	O
break	O
;	O
case	O
String	int
:	O
mem2string	O
(	O
&	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
,	O
(	O
RWSTYPE	long
*	O
)	O
mach	O
.	O
rA	O
)	O
;	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
size	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(struct)
,	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
,	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
size	int
)	O
;	O
p	*(struct)
[	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
size	int
]	O
=	O
0	int
;	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
=	O
p	*(struct)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
int	O
evaluate	O
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
if	O
(	O
run_init	O
(	O
pc	int
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
val	array(int)
)	O
return_value	O
(	O
val	array(int)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rewrite_invoke	(enum(int,int,int),*(struct(enum(int,int,int),union(int,struct(long,*`)))),*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char))->(int)
(	O
grad_data_type_t	enum(int,int,int)
rettype	enum(int,int,int)
,	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
,	O
const	O
char	O
*	O
name	*(char)
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
request	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
char	O
*	O
typestr	*(char)
,	O
...	O
)	O
{	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
int	O
nargs	int
;	O
char	O
*	O
s	*(*(char))
;	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
rewrite_check_function	O
(	O
name	*(char)
,	O
rettype	enum(int,int,int)
,	O
typestr	*(char)
)	O
;	O
if	O
(	O
!	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
return	O
-	O
1	int
;	O
rw_mach_init	O
(	O
)	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
mach	O
.	O
jmp	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
rw_mach_destroy	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mach	O
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
request	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
debug_open_file	O
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"Before rewriting:\n"	*(char)
)	O
;	O
grad_avl_fprint	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
pair_print_prefix	O
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
nargs	int
=	O
0	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
typestr	*(char)
)	O
;	O
while	O
(	O
*	O
typestr	*(char)
)	O
{	O
nargs	int
++	O
;	O
switch	O
(	O
*	O
typestr	*(char)
++	O
)	O
{	O
case	O
'i'	O
:	O
pushn	O
(	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
int	O
)	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
s	*(*(char))
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
;	O
pushstr	O
(	O
s	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad datatype"	*(char)
)	O
;	O
}	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
pushn	O
(	O
0	int
)	O
;	O
run	O
(	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
entry	int
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
debug_open_file	O
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"After rewriting\n"	*(char)
)	O
;	O
grad_avl_fprint	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
pair_print_prefix	O
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	O
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
val	array(int)
->	O
type	int
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rettype	enum(int,int,int)
;	O
return_value	O
(	O
val	array(int)
)	O
;	O
rw_mach_destroy	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
rewrite_compile	(*(char))->(*(char))
(	O
char	O
*	O
expr	*(char)
)	O
{	O
int	O
rc	O
;	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
char	O
*	O
name	*(char)
=	O
grad_emalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
expr	*(char)
)	O
+	O
3	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"$%s$"	*(char)
,	O
expr	*(char)
)	O
;	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
{	O
rc	O
=	O
parse_rewrite_string	O
(	O
expr	*(char)
)	O
;	O
if	O
(	O
rc	O
)	O
{	O
grad_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
function	O
->	O
name	*(char)
=	O
name	*(char)
;	O
function_install	O
(	O
function	O
)	O
;	O
}	O
return	O
name	*(char)
;	O
}	O
int	O
rewrite_interpret	(*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(enum(int,int,int),union(int,struct(long,*`)))))->(int)
(	O
char	O
*	O
expr	*(char)
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
pctr_t	int
save_pc	O
=	O
rw_pc	O
;	O
int	O
rc	O
;	O
rc	O
=	O
parse_rewrite_string	O
(	O
expr	*(char)
)	O
;	O
rw_pc	O
=	O
save_pc	O
;	O
if	O
(	O
rc	O
)	O
return	O
rc	O
;	O
val	array(int)
->	O
type	int
=	O
return_type	O
;	O
if	O
(	O
return_type	O
==	O
Undefined	int
)	O
return	O
-	O
1	int
;	O
return	O
evaluate	O
(	O
rw_pc	O
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
val	array(int)
)	O
;	O
}	O
int	O
rewrite_eval	(*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(enum(int,int,int),union(int,struct(long,*`)))))->(int)
(	O
char	O
*	O
symname	O
,	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
*	O
)	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
rewrite_tab	O
,	O
symname	O
)	O
;	O
if	O
(	O
!	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
nparm	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"function %s() requires %d parameter"	*(char)
,	O
"function %s() requires %d parameters"	*(char)
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
nparm	int
)	O
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
name	*(char)
,	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
nparm	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
val	array(int)
)	O
val	array(int)
->	O
type	int
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
rettype	enum(int,int,int)
;	O
return	O
evaluate	O
(	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
->	O
entry	int
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
val	array(int)
)	O
;	O
}	O
static	O
grad_list_t	struct
*	O
source_list	O
;	O
static	O
grad_list_t	struct
*	O
rewrite_load_path	O
;	O
static	O
void	O
rewrite_add_load_path	O
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
rewrite_load_path	O
)	O
rewrite_load_path	O
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
rewrite_load_path	O
,	O
grad_estrdup	(*(char))->(*(char))
(	O
str	*(char)
)	O
)	O
;	O
}	O
void	O
register_source_name	O
(	O
char	O
*	O
path	O
)	O
{	O
if	O
(	O
!	O
source_list	O
)	O
source_list	O
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
source_list	O
,	O
path	O
)	O
;	O
}	O
struct	O
load_data	O
{	O
int	O
rc	O
;	O
char	O
*	O
name	*(char)
;	O
}	O
;	O
static	O
int	O
try_load	O
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	O
=	O
0	int
;	O
struct	O
load_data	O
*	O
lp	O
=	O
data	*(void)
;	O
char	O
*	O
path	O
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
item	*(void)
,	O
lp	O
->	O
name	*(char)
)	O
;	O
lp	O
->	O
rc	O
=	O
parse_rewrite	(*(char))->(int)
(	O
path	O
)	O
;	O
if	O
(	O
lp	O
->	O
rc	O
>=	O
0	int
)	O
{	O
register_source_name	O
(	O
path	O
)	O
;	O
rc	O
=	O
1	int
;	O
}	O
else	O
grad_free	(*(void))->(void)
(	O
path	O
)	O
;	O
return	O
rc	O
;	O
}	O
int	O
rewrite_load_module	O
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
rc	O
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
register_source_name	O
(	O
grad_estrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
;	O
rc	O
=	O
parse_rewrite	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
struct	O
load_data	O
ld	O
;	O
ld	O
.	O
rc	O
=	O
1	int
;	O
ld	O
.	O
name	*(char)
=	O
name	*(char)
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
rewrite_load_path	O
,	O
try_load	O
,	O
&	O
ld	O
)	O
;	O
rc	O
=	O
ld	O
.	O
rc	O
;	O
}	O
return	O
rc	O
;	O
}	O
static	O
int	O
free_path	O
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
ARG_UNUSED	O
)	O
{	O
grad_free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
grad_list_t	struct
*	O
source_candidate_list	O
;	O
int	O
rewrite_stmt_term	(int,*(void),*(void))->(int)
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
{	O
grad_symtab_clear	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))))->(void)
(	O
rewrite_tab	O
)	O
;	O
rw_yydebug	O
=	O
GRAD_DEBUG_LEVEL	O
(	O
50	int
)	O
;	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
source_list	O
,	O
free_path	O
,	O
NULL	O
)	O
;	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
rewrite_load_path	O
,	O
free_path	O
,	O
NULL	O
)	O
;	O
rewrite_add_load_path	O
(	O
grad_config_dir	*(char)
)	O
;	O
rewrite_add_load_path	O
(	O
RADIUS_DATADIR	O
"/rewrite"	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
runtime_stack	O
)	O
;	O
runtime_stack	O
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
rewrite_cfg_add_load_path	O
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	O
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	O
)	O
;	O
return	O
0	int
;	O
}	O
rewrite_add_load_path	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rewrite_cfg_load	O
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	O
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	O
)	O
;	O
return	O
0	int
;	O
}	O
grad_list_append	(*(struct),*(void))->(void)
(	O
source_candidate_list	O
,	O
grad_estrdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
rewrite_before_config_hook	O
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
source_candidate_list	O
,	O
free_path	O
,	O
NULL	O
)	O
;	O
source_candidate_list	O
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
code_init	O
(	O
)	O
;	O
}	O
static	O
int	O
_load_module	O
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
ARG_UNUSED	O
)	O
{	O
if	O
(	O
rewrite_load_module	O
(	O
item	*(void)
)	O
==	O
-	O
2	int
)	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	O
,	O
_	O
(	O
"file not found: %s"	*(char)
)	O
,	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rewrite_load_all	O
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
if	O
(	O
!	O
source_candidate_list	O
)	O
return	O
;	O
if	O
(	O
grad_list_count	(*(struct))->(long)
(	O
source_candidate_list	O
)	O
==	O
0	int
)	O
rewrite_load_module	O
(	O
"rewrite"	*(char)
)	O
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
source_candidate_list	O
,	O
_load_module	O
,	O
NULL	O
)	O
;	O
}	O
void	O
rewrite_init	()->(void)
(	O
)	O
{	O
rewrite_tab	O
=	O
grad_symtab_create	(int,*(()->(int)))->(*(struct(int,int,int,*(*(struct`)),*(()->(int)))))
(	O
sizeof	O
(	O
FUNCTION	struct(*(struct(*(struct(*`,*`,enum(int,int,int),int,*`,int,*`,int,struct`)),*(char),enum(int,int,int),int,*(struct(*`,*`,*`,struct`,int)),int,*(struct(*`,*`,enum(int,int,int),int)),int,struct(*(char),long))),*(char),enum(int,int,int),int,*(struct(*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),*(struct(*`,*`,*`,struct`,int)),struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),int)),int,*(struct(*(struct(*`,*`,enum(int,int,int),int)),*(struct(*`,*`,enum(int,int,int),int)),enum(int,int,int),int)),int,struct(*(char),long))
)	O
,	O
function_free	O
)	O
;	O
radiusd_set_preconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
rewrite_before_config_hook	O
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
rewrite_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"stack-size"	*(char)
,	O
CS_STMT	O
,	O
NULL	O
,	O
cfg_get_number	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
rewrite_stack_size	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"load-path"	*(char)
,	O
CS_STMT	O
,	O
NULL	O
,	O
rewrite_cfg_add_load_path	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"load"	*(char)
,	O
CS_STMT	O
,	O
NULL	O
,	O
rewrite_cfg_load	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
size_t	long
rewrite_get_stack_size	()->(long)
(	O
)	O
{	O
return	O
rewrite_stack_size	O
;	O
}	O
void	O
rewrite_set_stack_size	(long)->(void)
(	O
size_t	long
s	*(*(char))
)	O
{	O
if	O
(	O
s	*(*(char))
==	O
rewrite_stack_size	O
)	O
return	O
;	O
rewrite_stack_size	O
=	O
s	*(*(char))
;	O
grad_free	(*(void))->(void)
(	O
runtime_stack	O
)	O
;	O
runtime_stack	O
=	O
NULL	O
;	O
}	O
void	O
grad_value_free	(*(struct(enum(int,int,int),union(int,struct(long,*`)))))->(void)
(	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
*	O
val	array(int)
)	O
{	O
if	O
(	O
val	array(int)
->	O
type	int
==	O
String	int
)	O
grad_free	(*(void))->(void)
(	O
val	array(int)
->	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
)	O
;	O
}	O
