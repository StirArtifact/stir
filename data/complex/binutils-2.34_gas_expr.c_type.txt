bfd_boolean	int
literal_prefix_dollar_hex	O
=	O
FALSE	O
;	O
static	O
void	O
floating_constant	O
(	O
expressionS	O
*	O
expressionP	O
)	O
;	O
static	O
valueT	O
generic_bignum_to_int32	O
(	O
void	O
)	O
;	O
static	O
valueT	O
generic_bignum_to_int64	O
(	O
void	O
)	O
;	O
static	O
void	O
integer_constant	O
(	O
int	O
radix	O
,	O
expressionS	O
*	O
expressionP	O
)	O
;	O
static	O
void	O
mri_char_constant	O
(	O
expressionS	O
*	O
)	O
;	O
static	O
void	O
clean_up_expression	O
(	O
expressionS	O
*	O
expressionP	O
)	O
;	O
static	O
segT	O
operand	O
(	O
expressionS	O
*	O
,	O
enum	O
expr_mode	O
)	O
;	O
static	O
operatorT	O
operatorf	O
(	O
int	O
*	O
)	O
;	O
struct	O
expr_symbol_line	O
{	O
struct	O
expr_symbol_line	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
symbolS	O
*	O
sym	*(struct)
;	O
const	O
char	O
*	O
file	*(void)
;	O
unsigned	O
int	O
line	O
;	O
}	O
;	O
static	O
struct	O
expr_symbol_line	O
*	O
expr_symbol_lines	O
;	O
symbolS	O
*	O
make_expr_symbol	O
(	O
expressionS	O
*	O
expressionP	O
)	O
{	O
expressionS	O
zero	O
;	O
symbolS	O
*	O
symbolP	O
;	O
struct	O
expr_symbol_line	O
*	O
n	O
;	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_symbol	O
&&	O
expressionP	O
->	O
X_add_number	O
==	O
0	int
)	O
return	O
expressionP	O
->	O
X_add_symbol	O
;	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_big	O
)	O
{	O
if	O
(	O
expressionP	O
->	O
X_add_number	O
>	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"bignum invalid"	*(char)
)	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"floating point number invalid"	*(char)
)	O
)	O
;	O
zero	O
.	O
X_op	O
=	O
O_constant	O
;	O
zero	O
.	O
X_add_number	O
=	O
0	int
;	O
zero	O
.	O
X_unsigned	O
=	O
0	int
;	O
zero	O
.	O
X_extrabit	O
=	O
0	int
;	O
clean_up_expression	O
(	O
&	O
zero	O
)	O
;	O
expressionP	O
=	O
&	O
zero	O
;	O
}	O
symbolP	O
=	O
symbol_create	O
(	O
FAKE_LABEL_NAME	O
,	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_constant	O
?	O
absolute_section	O
:	O
expressionP	O
->	O
X_op	O
==	O
O_register	O
?	O
reg_section	O
:	O
expr_section	O
)	O
,	O
0	int
,	O
&	O
zero_address_frag	O
)	O
;	O
symbol_set_value_expression	O
(	O
symbolP	O
,	O
expressionP	O
)	O
;	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_constant	O
)	O
resolve_symbol_value	O
(	O
symbolP	O
)	O
;	O
n	O
=	O
XNEW	O
(	O
struct	O
expr_symbol_line	O
)	O
;	O
n	O
->	O
sym	*(struct)
=	O
symbolP	O
;	O
n	O
->	O
file	*(void)
=	O
as_where	O
(	O
&	O
n	O
->	O
line	O
)	O
;	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
expr_symbol_lines	O
;	O
expr_symbol_lines	O
=	O
n	O
;	O
return	O
symbolP	O
;	O
}	O
int	O
expr_symbol_where	O
(	O
symbolS	O
*	O
sym	*(struct)
,	O
const	O
char	O
*	O
*	O
pfile	O
,	O
unsigned	O
int	O
*	O
pline	O
)	O
{	O
struct	O
expr_symbol_line	O
*	O
l	O
;	O
for	O
(	O
l	O
=	O
expr_symbol_lines	O
;	O
l	O
!=	O
NULL	O
;	O
l	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
l	O
->	O
sym	*(struct)
==	O
sym	*(struct)
)	O
{	O
*	O
pfile	O
=	O
l	O
->	O
file	*(void)
;	O
*	O
pline	O
=	O
l	O
->	O
line	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
symbolS	O
*	O
expr_build_uconstant	O
(	O
offsetT	O
value	long
)	O
{	O
expressionS	O
e	O
;	O
e	O
.	O
X_op	O
=	O
O_constant	O
;	O
e	O
.	O
X_add_number	O
=	O
value	long
;	O
e	O
.	O
X_unsigned	O
=	O
1	int
;	O
e	O
.	O
X_extrabit	O
=	O
0	int
;	O
return	O
make_expr_symbol	O
(	O
&	O
e	O
)	O
;	O
}	O
symbolS	O
*	O
expr_build_dot	O
(	O
void	O
)	O
{	O
expressionS	O
e	O
;	O
current_location	O
(	O
&	O
e	O
)	O
;	O
return	O
symbol_clone_if_forward_ref	O
(	O
make_expr_symbol	O
(	O
&	O
e	O
)	O
)	O
;	O
}	O
LITTLENUM_TYPE	O
generic_bignum	O
[	O
SIZE_OF_LARGE_NUMBER	O
+	O
6	int
]	O
;	O
FLONUM_TYPE	O
generic_floating_point_number	O
=	O
{	O
&	O
generic_bignum	O
[	O
6	int
]	O
,	O
&	O
generic_bignum	O
[	O
SIZE_OF_LARGE_NUMBER	O
+	O
6	int
-	O
1	int
]	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
void	O
floating_constant	O
(	O
expressionS	O
*	O
expressionP	O
)	O
{	O
int	O
error_code	O
;	O
error_code	O
=	O
atof_generic	O
(	O
&	O
input_line_pointer	O
,	O
"."	*(char)
,	O
EXP_CHARS	O
,	O
&	O
generic_floating_point_number	O
)	O
;	O
if	O
(	O
error_code	O
)	O
{	O
if	O
(	O
error_code	O
==	O
ERROR_EXPONENT_OVERFLOW	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"bad floating-point constant: exponent overflow"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
as_bad	O
(	O
_	O
(	O
"bad floating-point constant: unknown error code=%d"	*(char)
)	O
,	O
error_code	O
)	O
;	O
}	O
}	O
expressionP	O
->	O
X_op	O
=	O
O_big	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
-	O
1	int
;	O
}	O
static	O
valueT	O
generic_bignum_to_int32	O
(	O
void	O
)	O
{	O
valueT	O
number	O
=	O
(	O
(	O
generic_bignum	O
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
generic_bignum	O
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
;	O
number	O
&=	O
0xffffffff	int
;	O
return	O
number	O
;	O
}	O
static	O
valueT	O
generic_bignum_to_int64	O
(	O
void	O
)	O
{	O
valueT	O
number	O
=	O
(	O
(	O
(	O
(	O
(	O
(	O
(	O
(	O
valueT	O
)	O
generic_bignum	O
[	O
3	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	O
)	O
generic_bignum	O
[	O
2	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	O
)	O
generic_bignum	O
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	O
)	O
generic_bignum	O
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
;	O
return	O
number	O
;	O
}	O
static	O
void	O
integer_constant	O
(	O
int	O
radix	O
,	O
expressionS	O
*	O
expressionP	O
)	O
{	O
char	O
*	O
start	O
;	O
char	O
*	O
suffix	O
=	O
NULL	O
;	O
char	O
c	O
;	O
valueT	O
number	O
;	O
short	O
int	O
digit	O
;	O
short	O
int	O
maxdig	O
=	O
0	int
;	O
int	O
too_many_digits	O
=	O
0	int
;	O
char	O
*	O
name	*(char)
;	O
symbolS	O
*	O
symbolP	O
;	O
int	O
small	O
;	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_absent	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	O
||	O
flag_m68k_mri	O
)	O
&&	O
radix	O
==	O
0	int
)	O
{	O
int	O
flt	O
=	O
0	int
;	O
for	O
(	O
suffix	O
=	O
input_line_pointer	O
;	O
ISALNUM	O
(	O
*	O
suffix	O
)	O
;	O
suffix	O
++	O
)	O
{	O
if	O
(	O
*	O
suffix	O
==	O
'e'	O
||	O
*	O
suffix	O
==	O
'E'	O
)	O
flt	O
=	O
1	int
;	O
}	O
if	O
(	O
suffix	O
==	O
input_line_pointer	O
)	O
{	O
radix	O
=	O
10	int
;	O
suffix	O
=	O
NULL	O
;	O
}	O
else	O
{	O
c	O
=	O
*	O
--	O
suffix	O
;	O
c	O
=	O
TOUPPER	O
(	O
c	O
)	O
;	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	O
&&	O
LOCAL_LABELS_FB	O
?	O
*	O
suffix	O
:	O
c	O
)	O
==	O
'B'	O
)	O
radix	O
=	O
2	int
;	O
else	O
if	O
(	O
c	O
==	O
'D'	O
)	O
radix	O
=	O
10	int
;	O
else	O
if	O
(	O
c	O
==	O
'O'	O
||	O
c	O
==	O
'Q'	O
)	O
radix	O
=	O
8	int
;	O
else	O
if	O
(	O
c	O
==	O
'H'	O
)	O
radix	O
=	O
16	int
;	O
else	O
if	O
(	O
suffix	O
[	O
1	int
]	O
==	O
'.'	O
||	O
c	O
==	O
'E'	O
||	O
flt	O
)	O
{	O
floating_constant	O
(	O
expressionP	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
radix	O
=	O
10	int
;	O
suffix	O
=	O
NULL	O
;	O
}	O
}	O
}	O
switch	O
(	O
radix	O
)	O
{	O
case	O
2	int
:	O
maxdig	O
=	O
2	int
;	O
too_many_digits	O
=	O
valuesize	O
+	O
1	int
;	O
break	O
;	O
case	O
8	int
:	O
maxdig	O
=	O
radix	O
=	O
8	int
;	O
too_many_digits	O
=	O
(	O
valuesize	O
+	O
2	int
)	O
/	O
3	int
+	O
1	int
;	O
break	O
;	O
case	O
16	int
:	O
maxdig	O
=	O
radix	O
=	O
16	int
;	O
too_many_digits	O
=	O
(	O
valuesize	O
+	O
3	int
)	O
/	O
4	int
+	O
1	int
;	O
break	O
;	O
case	O
10	int
:	O
maxdig	O
=	O
radix	O
=	O
10	int
;	O
too_many_digits	O
=	O
(	O
valuesize	O
+	O
11	int
)	O
/	O
4	int
;	O
}	O
start	O
=	O
input_line_pointer	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
for	O
(	O
number	O
=	O
0	int
;	O
(	O
digit	O
=	O
hex_value	O
(	O
c	O
)	O
)	O
<	O
maxdig	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
)	O
{	O
number	O
=	O
number	O
*	O
radix	O
+	O
digit	O
;	O
}	O
small	O
=	O
(	O
input_line_pointer	O
-	O
start	O
-	O
1	int
)	O
<	O
too_many_digits	O
;	O
if	O
(	O
radix	O
==	O
16	int
&&	O
c	O
==	O
'_'	O
)	O
{	O
int	O
num_little_digits	O
=	O
0	int
;	O
int	O
i	*(struct)
;	O
input_line_pointer	O
=	O
start	O
;	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
for	O
(	O
c	O
=	O
'_'	O
;	O
c	O
==	O
'_'	O
;	O
num_little_digits	O
+=	O
2	int
)	O
{	O
int	O
ndigit	O
=	O
0	int
;	O
number	O
=	O
0	int
;	O
for	O
(	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
(	O
digit	O
=	O
hex_value	O
(	O
c	O
)	O
)	O
<	O
maxdig	O
;	O
c	O
=	O
*	O
(	O
input_line_pointer	O
++	O
)	O
)	O
{	O
number	O
=	O
number	O
*	O
radix	O
+	O
digit	O
;	O
ndigit	O
++	O
;	O
}	O
if	O
(	O
ndigit	O
>	O
8	int
)	O
as_bad	O
(	O
_	O
(	O
"a bignum with underscores may not have more than 8 hex digits in any word"	*(char)
)	O
)	O
;	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
for	O
(	O
i	*(struct)
=	O
min	O
(	O
num_little_digits	O
+	O
1	int
,	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
;	O
i	*(struct)
>=	O
2	int
;	O
i	*(struct)
--	O
)	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
generic_bignum	O
[	O
i	*(struct)
-	O
2	int
]	O
;	O
generic_bignum	O
[	O
0	int
]	O
=	O
number	O
&	O
0xffffffff	int
;	O
generic_bignum	O
[	O
1	int
]	O
=	O
number	O
>>	O
16	int
;	O
}	O
if	O
(	O
num_little_digits	O
>	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
num_little_digits	O
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
;	O
gas_assert	O
(	O
num_little_digits	O
>=	O
4	int
)	O
;	O
if	O
(	O
num_little_digits	O
!=	O
8	int
)	O
as_bad	O
(	O
_	O
(	O
"a bignum with underscores must have exactly 4 words"	*(char)
)	O
)	O
;	O
while	O
(	O
generic_bignum	O
[	O
num_little_digits	O
-	O
1	int
]	O
==	O
0	int
&&	O
num_little_digits	O
>	O
1	int
)	O
num_little_digits	O
--	O
;	O
if	O
(	O
num_little_digits	O
<=	O
2	int
)	O
{	O
number	O
=	O
generic_bignum_to_int32	O
(	O
)	O
;	O
small	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
num_little_digits	O
<=	O
4	int
)	O
{	O
number	O
=	O
generic_bignum_to_int64	O
(	O
)	O
;	O
small	O
=	O
1	int
;	O
}	O
else	O
{	O
small	O
=	O
0	int
;	O
number	O
=	O
num_little_digits	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
small	O
)	O
{	O
LITTLENUM_TYPE	O
*	O
leader	O
;	O
LITTLENUM_TYPE	O
*	O
pointer	O
;	O
long	O
carry	O
;	O
leader	O
=	O
generic_bignum	O
;	O
generic_bignum	O
[	O
0	int
]	O
=	O
0	int
;	O
generic_bignum	O
[	O
1	int
]	O
=	O
0	int
;	O
generic_bignum	O
[	O
2	int
]	O
=	O
0	int
;	O
generic_bignum	O
[	O
3	int
]	O
=	O
0	int
;	O
input_line_pointer	O
=	O
start	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
for	O
(	O
;	O
(	O
carry	O
=	O
hex_value	O
(	O
c	O
)	O
)	O
<	O
maxdig	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
)	O
{	O
for	O
(	O
pointer	O
=	O
generic_bignum	O
;	O
pointer	O
<=	O
leader	O
;	O
pointer	O
++	O
)	O
{	O
long	O
work	O
;	O
work	O
=	O
carry	O
+	O
radix	O
*	O
*	O
pointer	O
;	O
*	O
pointer	O
=	O
work	O
&	O
LITTLENUM_MASK	O
;	O
carry	O
=	O
work	O
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
carry	O
)	O
{	O
if	O
(	O
leader	O
<	O
generic_bignum	O
+	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
{	O
*	O
++	O
leader	O
=	O
carry	O
;	O
}	O
}	O
}	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
if	O
(	O
leader	O
<	O
generic_bignum	O
+	O
2	int
)	O
{	O
number	O
=	O
generic_bignum_to_int32	O
(	O
)	O
;	O
small	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
leader	O
<	O
generic_bignum	O
+	O
4	int
)	O
{	O
number	O
=	O
generic_bignum_to_int64	O
(	O
)	O
;	O
small	O
=	O
1	int
;	O
}	O
else	O
{	O
number	O
=	O
leader	O
-	O
generic_bignum	O
+	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	O
||	O
flag_m68k_mri	O
)	O
&&	O
suffix	O
!=	O
NULL	O
&&	O
input_line_pointer	O
-	O
1	int
==	O
suffix	O
)	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
if	O
(	O
tc_allow_U_suffix	O
&&	O
(	O
c	O
==	O
'U'	O
||	O
c	O
==	O
'u'	O
)	O
)	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
if	O
(	O
tc_allow_L_suffix	O
)	O
while	O
(	O
c	O
==	O
'L'	O
||	O
c	O
==	O
'l'	O
)	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
if	O
(	O
small	O
)	O
{	O
if	O
(	O
LOCAL_LABELS_FB	O
&&	O
c	O
==	O
'b'	O
)	O
{	O
name	*(char)
=	O
fb_label_name	O
(	O
(	O
int	O
)	O
number	O
,	O
0	int
)	O
;	O
symbolP	O
=	O
symbol_find	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
symbolP	O
!=	O
NULL	O
)	O
&&	O
(	O
S_IS_DEFINED	O
(	O
symbolP	O
)	O
)	O
)	O
{	O
know	O
(	O
SEG_NORMAL	O
(	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
)	O
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbolP	O
;	O
}	O
else	O
{	O
as_bad	O
(	O
_	O
(	O
"backward ref to unknown label \"%d:\""	*(char)
)	O
,	O
(	O
int	O
)	O
number	O
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
}	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
LOCAL_LABELS_FB	O
&&	O
c	O
==	O
'f'	O
)	O
{	O
name	*(char)
=	O
fb_label_name	O
(	O
(	O
int	O
)	O
number	O
,	O
1	int
)	O
;	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
know	O
(	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
==	O
undefined_section	O
||	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
==	O
text_section	O
||	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
==	O
data_section	O
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbolP	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
LOCAL_LABELS_DOLLAR	O
&&	O
c	O
==	O
'$'	O
)	O
{	O
if	O
(	O
dollar_label_defined	O
(	O
(	O
long	O
)	O
number	O
)	O
)	O
{	O
name	*(char)
=	O
dollar_label_name	O
(	O
(	O
long	O
)	O
number	O
,	O
0	int
)	O
;	O
symbolP	O
=	O
symbol_find	O
(	O
name	*(char)
)	O
;	O
know	O
(	O
symbolP	O
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
name	*(char)
=	O
dollar_label_name	O
(	O
(	O
long	O
)	O
number	O
,	O
1	int
)	O
;	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
}	O
expressionP	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbolP	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
number	O
;	O
input_line_pointer	O
--	O
;	O
}	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_big	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
number	O
;	O
input_line_pointer	O
--	O
;	O
}	O
}	O
static	O
void	O
mri_char_constant	O
(	O
expressionS	O
*	O
expressionP	O
)	O
{	O
int	O
i	*(struct)
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'\''	O
&&	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'\''	O
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
return	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
;	O
i	*(struct)
>=	O
0	int
;	O
i	*(struct)
--	O
)	O
{	O
int	O
j	O
;	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
CHARS_PER_LITTLENUM	O
;	O
j	O
++	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'\''	O
)	O
{	O
if	O
(	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'\''	O
)	O
break	O
;	O
++	O
input_line_pointer	O
;	O
}	O
generic_bignum	O
[	O
i	*(struct)
]	O
<<=	O
8	int
;	O
generic_bignum	O
[	O
i	*(struct)
]	O
+=	O
*	O
input_line_pointer	O
;	O
++	O
input_line_pointer	O
;	O
}	O
if	O
(	O
i	*(struct)
<	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
{	O
for	O
(	O
;	O
j	O
<	O
CHARS_PER_LITTLENUM	O
;	O
j	O
++	O
)	O
generic_bignum	O
[	O
i	*(struct)
]	O
<<=	O
8	int
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'\''	O
&&	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'\''	O
)	O
break	O
;	O
}	O
if	O
(	O
i	*(struct)
<	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"character constant too large"	*(char)
)	O
)	O
;	O
i	*(struct)
=	O
0	int
;	O
}	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
{	O
int	O
c	O
;	O
int	O
j	O
;	O
c	O
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
i	*(struct)
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
c	O
;	O
j	O
++	O
)	O
generic_bignum	O
[	O
j	O
]	O
=	O
generic_bignum	O
[	O
i	*(struct)
+	O
j	O
]	O
;	O
i	*(struct)
=	O
c	O
;	O
}	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
if	O
(	O
i	*(struct)
>	O
2	int
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_big	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
i	*(struct)
;	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
if	O
(	O
i	*(struct)
<	O
2	int
)	O
expressionP	O
->	O
X_add_number	O
=	O
generic_bignum	O
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
;	O
else	O
expressionP	O
->	O
X_add_number	O
=	O
(	O
(	O
(	O
generic_bignum	O
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
generic_bignum	O
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
;	O
}	O
++	O
input_line_pointer	O
;	O
}	O
void	O
current_location	O
(	O
expressionS	O
*	O
expressionp	O
)	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
expressionp	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionp	O
->	O
X_add_number	O
=	O
abs_section_offset	O
;	O
}	O
else	O
{	O
expressionp	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionp	O
->	O
X_add_symbol	O
=	O
&	O
dot_symbol	O
;	O
expressionp	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
}	O
static	O
segT	O
operand	O
(	O
expressionS	O
*	O
expressionP	O
,	O
enum	O
expr_mode	O
mode	*(char)
)	O
{	O
char	O
c	O
;	O
symbolS	O
*	O
symbolP	O
;	O
char	O
*	O
name	*(char)
;	O
segT	O
segment	O
;	O
expressionP	O
->	O
X_unsigned	O
=	O
1	int
;	O
expressionP	O
->	O
X_extrabit	O
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
c	O
]	O
)	O
goto	O
eol	O
;	O
switch	O
(	O
c	O
)	O
{	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
input_line_pointer	O
--	O
;	O
integer_constant	O
(	O
(	O
NUMBERS_WITH_SUFFIX	O
||	O
flag_m68k_mri	O
)	O
?	O
0	int
:	O
10	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
if	O
(	O
NUMBERS_WITH_SUFFIX	O
||	O
flag_m68k_mri	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
for	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
input_line_pointer	O
;	O
hex_p	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
)	O
;	O
if	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'h'	O
||	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'H'	O
||	O
*	O
input_line_pointer	O
==	O
'.'	O
)	O
{	O
--	O
input_line_pointer	O
;	O
integer_constant	O
(	O
0	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
}	O
c	O
=	O
*	O
input_line_pointer	O
;	O
switch	O
(	O
c	O
)	O
{	O
case	O
'o'	O
:	O
case	O
'O'	O
:	O
case	O
'q'	O
:	O
case	O
'Q'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
NUMBERS_WITH_SUFFIX	O
||	O
flag_m68k_mri	O
)	O
{	O
integer_constant	O
(	O
0	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
default	O
:	O
default_case	O
:	O
if	O
(	O
c	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
FLT_CHARS	O
,	O
c	O
)	O
)	O
{	O
input_line_pointer	O
++	O
;	O
floating_constant	O
(	O
expressionP	O
)	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
-	O
TOLOWER	O
(	O
c	O
)	O
;	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
if	O
(	O
flag_m68k_mri	O
)	O
goto	O
default_case	O
;	O
input_line_pointer	O
++	O
;	O
integer_constant	O
(	O
16	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
LOCAL_LABELS_FB	O
&&	O
!	O
flag_m68k_mri	O
&&	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'0'	O
&&	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'1'	O
)	O
{	O
input_line_pointer	O
--	O
;	O
integer_constant	O
(	O
10	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
case	O
'B'	O
:	O
if	O
(	O
input_line_pointer	O
[	O
1	int
]	O
==	O
'0'	O
||	O
input_line_pointer	O
[	O
1	int
]	O
==	O
'1'	O
)	O
{	O
input_line_pointer	O
++	O
;	O
integer_constant	O
(	O
2	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
flag_m68k_mri	O
||	O
NUMBERS_WITH_SUFFIX	O
)	O
input_line_pointer	O
++	O
;	O
goto	O
default_case	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
integer_constant	O
(	O
(	O
flag_m68k_mri	O
||	O
NUMBERS_WITH_SUFFIX	O
)	O
?	O
0	int
:	O
8	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
LOCAL_LABELS_FB	O
)	O
{	O
int	O
is_label	O
=	O
1	int
;	O
if	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	O
[	O
1	int
]	O
]	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
FLT_CHARS	O
,	O
'f'	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
cp	O
=	O
input_line_pointer	O
+	O
1	int
;	O
atof_generic	O
(	O
&	O
cp	O
,	O
"."	*(char)
,	O
EXP_CHARS	O
,	O
&	O
generic_floating_point_number	O
)	O
;	O
is_label	O
=	O
(	O
cp	O
==	O
input_line_pointer	O
+	O
1	int
||	O
(	O
cp	O
==	O
input_line_pointer	O
+	O
2	int
&&	O
(	O
cp	O
[	O
-	O
1	int
]	O
==	O
'-'	O
||	O
cp	O
[	O
-	O
1	int
]	O
==	O
'+'	O
)	O
)	O
||	O
*	O
cp	O
==	O
'f'	O
||	O
*	O
cp	O
==	O
'b'	O
)	O
;	O
}	O
if	O
(	O
is_label	O
)	O
{	O
input_line_pointer	O
--	O
;	O
integer_constant	O
(	O
10	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
}	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
if	O
(	O
flag_m68k_mri	O
||	O
NUMBERS_WITH_SUFFIX	O
)	O
{	O
integer_constant	O
(	O
0	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
case	O
'F'	O
:	O
case	O
'r'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
input_line_pointer	O
++	O
;	O
floating_constant	O
(	O
expressionP	O
)	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
-	O
TOLOWER	O
(	O
c	O
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
LOCAL_LABELS_DOLLAR	O
)	O
{	O
integer_constant	O
(	O
10	int
,	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
else	O
goto	O
default_case	O
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
md_need_index_operator	O
(	O
)	O
)	O
goto	O
de_fault	O
;	O
case	O
'('	O
:	O
segment	O
=	O
expr	O
(	O
0	int
,	O
expressionP	O
,	O
mode	*(char)
)	O
;	O
if	O
(	O
(	O
c	O
==	O
'('	O
&&	O
*	O
input_line_pointer	O
!=	O
')'	O
)	O
||	O
(	O
c	O
==	O
'['	O
&&	O
*	O
input_line_pointer	O
!=	O
']'	O
)	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
)	O
as_bad	O
(	O
_	O
(	O
"found '%c', expected: '%c'"	*(char)
)	O
,	O
*	O
input_line_pointer	O
,	O
c	O
==	O
'('	O
?	O
')'	O
:	O
']'	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"missing '%c'"	*(char)
)	O
,	O
c	O
==	O
'('	O
?	O
')'	O
:	O
']'	O
)	O
;	O
}	O
else	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
segment	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
flag_m68k_mri	O
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
*	O
input_line_pointer	O
++	O
;	O
break	O
;	O
}	O
mri_char_constant	O
(	O
expressionP	O
)	O
;	O
break	O
;	O
case	O
'~'	O
:	O
if	O
(	O
is_name_beginner	O
(	O
c	O
)	O
)	O
goto	O
isname	O
;	O
case	O
'!'	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
{	O
unary	O
:	O
operand	O
(	O
expressionP	O
,	O
mode	*(char)
)	O
;	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_constant	O
)	O
{	O
if	O
(	O
c	O
==	O
'-'	O
)	O
{	O
expressionP	O
->	O
X_add_number	O
=	O
-	O
(	O
addressT	O
)	O
expressionP	O
->	O
X_add_number	O
;	O
expressionP	O
->	O
X_unsigned	O
=	O
0	int
;	O
if	O
(	O
expressionP	O
->	O
X_add_number	O
)	O
expressionP	O
->	O
X_extrabit	O
^=	O
1	int
;	O
}	O
else	O
if	O
(	O
c	O
==	O
'~'	O
||	O
c	O
==	O
'"'	O
)	O
expressionP	O
->	O
X_add_number	O
=	O
~	O
expressionP	O
->	O
X_add_number	O
;	O
else	O
if	O
(	O
c	O
==	O
'!'	O
)	O
expressionP	O
->	O
X_add_number	O
=	O
!	O
expressionP	O
->	O
X_add_number	O
;	O
}	O
else	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_big	O
&&	O
expressionP	O
->	O
X_add_number	O
<=	O
0	int
&&	O
c	O
==	O
'-'	O
&&	O
(	O
generic_floating_point_number	O
.	O
sign	O
==	O
'+'	O
||	O
generic_floating_point_number	O
.	O
sign	O
==	O
'P'	O
)	O
)	O
{	O
if	O
(	O
generic_floating_point_number	O
.	O
sign	O
==	O
'+'	O
)	O
generic_floating_point_number	O
.	O
sign	O
=	O
'-'	O
;	O
else	O
generic_floating_point_number	O
.	O
sign	O
=	O
'N'	O
;	O
}	O
else	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_big	O
&&	O
expressionP	O
->	O
X_add_number	O
>	O
0	int
)	O
{	O
int	O
i	*(struct)
;	O
if	O
(	O
c	O
==	O
'~'	O
||	O
c	O
==	O
'-'	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
expressionP	O
->	O
X_add_number	O
;	O
++	O
i	*(struct)
)	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
~	O
generic_bignum	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
expressionP	O
->	O
X_add_number	O
<	O
SIZE_OF_LARGE_NUMBER	O
)	O
{	O
expressionP	O
->	O
X_add_number	O
=	O
SIZE_OF_LARGE_NUMBER	O
;	O
for	O
(	O
;	O
i	*(struct)
<	O
expressionP	O
->	O
X_add_number	O
;	O
++	O
i	*(struct)
)	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
~	O
(	O
LITTLENUM_TYPE	O
)	O
0	int
;	O
}	O
if	O
(	O
c	O
==	O
'-'	O
)	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
expressionP	O
->	O
X_add_number	O
;	O
++	O
i	*(struct)
)	O
{	O
generic_bignum	O
[	O
i	*(struct)
]	O
+=	O
1	int
;	O
if	O
(	O
generic_bignum	O
[	O
i	*(struct)
]	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
c	O
==	O
'!'	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
expressionP	O
->	O
X_add_number	O
;	O
++	O
i	*(struct)
)	O
if	O
(	O
generic_bignum	O
[	O
i	*(struct)
]	O
!=	O
0	int
)	O
break	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
i	*(struct)
>=	O
expressionP	O
->	O
X_add_number	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_unsigned	O
=	O
1	int
;	O
expressionP	O
->	O
X_extrabit	O
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
expressionP	O
->	O
X_op	O
!=	O
O_illegal	O
&&	O
expressionP	O
->	O
X_op	O
!=	O
O_absent	O
)	O
{	O
if	O
(	O
c	O
!=	O
'+'	O
)	O
{	O
expressionP	O
->	O
X_add_symbol	O
=	O
make_expr_symbol	O
(	O
expressionP	O
)	O
;	O
if	O
(	O
c	O
==	O
'-'	O
)	O
expressionP	O
->	O
X_op	O
=	O
O_uminus	O
;	O
else	O
if	O
(	O
c	O
==	O
'~'	O
||	O
c	O
==	O
'"'	O
)	O
expressionP	O
->	O
X_op	O
=	O
O_bit_not	O
;	O
else	O
expressionP	O
->	O
X_op	O
=	O
O_logical_not	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
}	O
else	O
as_warn	O
(	O
_	O
(	O
"Unary operator %c ignored because bad operand follows"	*(char)
)	O
,	O
c	O
)	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
literal_prefix_dollar_hex	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'L'	O
)	O
goto	O
isname	O
;	O
integer_constant	O
(	O
16	int
,	O
expressionP	O
)	O
;	O
}	O
else	O
{	O
goto	O
isname	O
;	O
}	O
break	O
;	O
case	O
'.'	O
:	O
if	O
(	O
!	O
is_part_of_name	O
(	O
*	O
input_line_pointer	O
)	O
)	O
{	O
current_location	O
(	O
expressionP	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
input_line_pointer	O
,	O
"startof."	*(char)
,	O
8	int
)	O
==	O
0	int
&&	O
!	O
is_part_of_name	O
(	O
input_line_pointer	O
[	O
8	int
]	O
)	O
)	O
||	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
input_line_pointer	O
,	O
"sizeof."	*(char)
,	O
7	int
)	O
==	O
0	int
&&	O
!	O
is_part_of_name	O
(	O
input_line_pointer	O
[	O
7	int
]	O
)	O
)	O
)	O
{	O
int	O
start	O
;	O
start	O
=	O
(	O
input_line_pointer	O
[	O
1	int
]	O
==	O
't'	O
||	O
input_line_pointer	O
[	O
1	int
]	O
==	O
'T'	O
)	O
;	O
input_line_pointer	O
+=	O
start	O
?	O
8	int
:	O
7	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_absent	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
'('	O
)	O
as_bad	O
(	O
_	O
(	O
"syntax error in .startof. or .sizeof."	*(char)
)	O
)	O
;	O
else	O
{	O
char	O
*	O
buf	*(void)
;	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
*	O
name	*(char)
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected symbol name"	*(char)
)	O
)	O
;	O
(	O
void	O
)	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
if	O
(	O
c	O
!=	O
')'	O
)	O
ignore_rest_of_line	O
(	O
)	O
;	O
else	O
++	O
input_line_pointer	O
;	O
break	O
;	O
}	O
buf	*(void)
=	O
concat	O
(	O
start	O
?	O
".startof."	*(char)
:	O
".sizeof."	*(char)
,	O
name	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
symbolP	O
=	O
symbol_make	O
(	O
buf	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbolP	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
*	O
input_line_pointer	O
=	O
c	O
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
')'	O
)	O
as_bad	O
(	O
_	O
(	O
"syntax error in .startof. or .sizeof."	*(char)
)	O
)	O
;	O
else	O
++	O
input_line_pointer	O
;	O
}	O
break	O
;	O
}	O
else	O
{	O
goto	O
isname	O
;	O
}	O
case	O
','	O
:	O
eol	O
:	O
expressionP	O
->	O
X_op	O
=	O
O_absent	O
;	O
input_line_pointer	O
--	O
;	O
break	O
;	O
default	O
:	O
de_fault	O
:	O
if	O
(	O
is_name_beginner	O
(	O
c	O
)	O
||	O
c	O
==	O
'"'	O
)	O
{	O
isname	O
:	O
--	O
input_line_pointer	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
{	O
operatorT	O
op	O
=	O
md_operator	O
(	O
name	*(char)
,	O
1	int
,	O
&	O
c	O
)	O
;	O
switch	O
(	O
op	O
)	O
{	O
case	O
O_uminus	O
:	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
c	O
=	O
'-'	O
;	O
goto	O
unary	O
;	O
case	O
O_bit_not	O
:	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
c	O
=	O
'~'	O
;	O
goto	O
unary	O
;	O
case	O
O_logical_not	O
:	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
c	O
=	O
'!'	O
;	O
goto	O
unary	O
;	O
case	O
O_illegal	O
:	O
as_bad	O
(	O
_	O
(	O
"invalid use of operator \"%s\""	*(char)
)	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
op	O
!=	O
O_absent	O
&&	O
op	O
!=	O
O_illegal	O
)	O
{	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
expr	O
(	O
9	int
,	O
expressionP	O
,	O
mode	*(char)
)	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
make_expr_symbol	O
(	O
expressionP	O
)	O
;	O
expressionP	O
->	O
X_op_symbol	O
=	O
NULL	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
expressionP	O
->	O
X_op	O
=	O
op	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
md_parse_name	O
(	O
name	*(char)
,	O
expressionP	O
,	O
mode	*(char)
,	O
&	O
c	O
)	O
)	O
{	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
break	O
;	O
}	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
segment	O
=	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
;	O
if	O
(	O
mode	*(char)
!=	O
expr_defer	O
&&	O
segment	O
==	O
absolute_section	O
&&	O
!	O
S_FORCE_RELOC	O
(	O
symbolP	O
,	O
0	int
)	O
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
S_GET_VALUE	O
(	O
symbolP	O
)	O
;	O
}	O
else	O
if	O
(	O
mode	*(char)
!=	O
expr_defer	O
&&	O
segment	O
==	O
reg_section	O
)	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_register	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
S_GET_VALUE	O
(	O
symbolP	O
)	O
;	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_symbol	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbolP	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
}	O
else	O
{	O
expressionP	O
->	O
X_op	O
=	O
O_absent	O
;	O
--	O
input_line_pointer	O
;	O
md_operand	O
(	O
expressionP	O
)	O
;	O
if	O
(	O
expressionP	O
->	O
X_op	O
==	O
O_absent	O
)	O
{	O
++	O
input_line_pointer	O
;	O
as_bad	O
(	O
_	O
(	O
"bad expression"	*(char)
)	O
)	O
;	O
expressionP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
}	O
break	O
;	O
}	O
clean_up_expression	O
(	O
expressionP	O
)	O
;	O
SKIP_ALL_WHITESPACE	O
(	O
)	O
;	O
know	O
(	O
*	O
input_line_pointer	O
!=	O
' '	O
)	O
;	O
if	O
(	O
expressionP	O
->	O
X_add_symbol	O
)	O
symbol_mark_used	O
(	O
expressionP	O
->	O
X_add_symbol	O
)	O
;	O
if	O
(	O
mode	*(char)
!=	O
expr_defer	O
)	O
{	O
expressionP	O
->	O
X_add_symbol	O
=	O
symbol_clone_if_forward_ref	O
(	O
expressionP	O
->	O
X_add_symbol	O
)	O
;	O
expressionP	O
->	O
X_op_symbol	O
=	O
symbol_clone_if_forward_ref	O
(	O
expressionP	O
->	O
X_op_symbol	O
)	O
;	O
}	O
switch	O
(	O
expressionP	O
->	O
X_op	O
)	O
{	O
default	O
:	O
return	O
absolute_section	O
;	O
case	O
O_symbol	O
:	O
return	O
S_GET_SEGMENT	O
(	O
expressionP	O
->	O
X_add_symbol	O
)	O
;	O
case	O
O_register	O
:	O
return	O
reg_section	O
;	O
}	O
}	O
static	O
void	O
clean_up_expression	O
(	O
expressionS	O
*	O
expressionP	O
)	O
{	O
switch	O
(	O
expressionP	O
->	O
X_op	O
)	O
{	O
case	O
O_illegal	O
:	O
case	O
O_absent	O
:	O
expressionP	O
->	O
X_add_number	O
=	O
0	int
;	O
case	O
O_big	O
:	O
case	O
O_constant	O
:	O
case	O
O_register	O
:	O
expressionP	O
->	O
X_add_symbol	O
=	O
NULL	O
;	O
case	O
O_symbol	O
:	O
case	O
O_uminus	O
:	O
case	O
O_bit_not	O
:	O
expressionP	O
->	O
X_op_symbol	O
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
const	O
operatorT	O
op_encoding	O
[	O
256	int
]	O
=	O
{	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_or_not	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_modulus	O
,	O
O_bit_and	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_multiply	O
,	O
O_add	O
,	O
__	O
,	O
O_subtract	O
,	O
__	O
,	O
O_divide	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_lt	O
,	O
O_SINGLE_EQ	O
,	O
O_gt	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_exclusive_or	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_inclusive_or	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
}	O
;	O
static	O
operator_rankT	O
op_rank	O
[	O
O_max	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
9	int
,	O
9	int
,	O
9	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
5	int
,	O
5	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
3	int
,	O
2	int
,	O
1	int
,	O
}	O
;	O
void	O
expr_set_precedence	O
(	O
void	O
)	O
{	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
op_rank	O
[	O
O_multiply	O
]	O
=	O
MRI_MUL_PRECEDENCE	O
;	O
op_rank	O
[	O
O_divide	O
]	O
=	O
MRI_MUL_PRECEDENCE	O
;	O
op_rank	O
[	O
O_modulus	O
]	O
=	O
MRI_MUL_PRECEDENCE	O
;	O
}	O
else	O
{	O
op_rank	O
[	O
O_multiply	O
]	O
=	O
STANDARD_MUL_PRECEDENCE	O
;	O
op_rank	O
[	O
O_divide	O
]	O
=	O
STANDARD_MUL_PRECEDENCE	O
;	O
op_rank	O
[	O
O_modulus	O
]	O
=	O
STANDARD_MUL_PRECEDENCE	O
;	O
}	O
}	O
void	O
expr_set_rank	O
(	O
operatorT	O
op	O
,	O
operator_rankT	O
rank	O
)	O
{	O
gas_assert	O
(	O
op	O
>=	O
O_md1	O
&&	O
op	O
<	O
ARRAY_SIZE	O
(	O
op_rank	O
)	O
)	O
;	O
op_rank	O
[	O
op	O
]	O
=	O
rank	O
;	O
}	O
void	O
expr_begin	O
(	O
void	O
)	O
{	O
expr_set_precedence	O
(	O
)	O
;	O
{	O
expressionS	O
e	O
;	O
e	O
.	O
X_op	O
=	O
O_max	O
;	O
gas_assert	O
(	O
e	O
.	O
X_op	O
==	O
O_max	O
)	O
;	O
}	O
}	O
static	O
inline	O
operatorT	O
operatorf	O
(	O
int	O
*	O
num_chars	O
)	O
{	O
int	O
c	O
;	O
operatorT	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
c	O
=	O
*	O
input_line_pointer	O
&	O
0xff	int
;	O
*	O
num_chars	O
=	O
1	int
;	O
if	O
(	O
is_end_of_line	O
[	O
c	O
]	O
)	O
return	O
O_illegal	O
;	O
if	O
(	O
is_name_beginner	O
(	O
c	O
)	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
char	O
ec	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
md_operator	O
(	O
name	*(char)
,	O
2	int
,	O
&	O
ec	O
)	O
;	O
switch	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
{	O
case	O
O_absent	O
:	O
*	O
input_line_pointer	O
=	O
ec	O
;	O
input_line_pointer	O
=	O
name	*(char)
;	O
break	O
;	O
case	O
O_uminus	O
:	O
case	O
O_bit_not	O
:	O
case	O
O_logical_not	O
:	O
as_bad	O
(	O
_	O
(	O
"invalid use of operator \"%s\""	*(char)
)	O
,	O
name	*(char)
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_illegal	O
;	O
default	O
:	O
*	O
input_line_pointer	O
=	O
ec	O
;	O
*	O
num_chars	O
=	O
input_line_pointer	O
-	O
name	*(char)
;	O
input_line_pointer	O
=	O
name	*(char)
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
}	O
switch	O
(	O
c	O
)	O
{	O
default	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
op_encoding	O
[	O
c	O
]	O
;	O
if	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
==	O
O_illegal	O
)	O
{	O
char	O
*	O
start	O
=	O
input_line_pointer	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
md_operator	O
(	O
NULL	O
,	O
2	int
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
!=	O
O_illegal	O
)	O
*	O
num_chars	O
=	O
input_line_pointer	O
-	O
start	O
;	O
input_line_pointer	O
=	O
start	O
;	O
}	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
case	O
'<'	O
:	O
switch	O
(	O
input_line_pointer	O
[	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
case	O
'<'	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_left_shift	O
;	O
break	O
;	O
case	O
'>'	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_ne	O
;	O
break	O
;	O
case	O
'='	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_le	O
;	O
break	O
;	O
}	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
case	O
'='	O
:	O
if	O
(	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'='	O
)	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
O_eq	O
;	O
case	O
'>'	O
:	O
switch	O
(	O
input_line_pointer	O
[	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
case	O
'>'	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_right_shift	O
;	O
break	O
;	O
case	O
'='	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
O_ge	O
;	O
break	O
;	O
}	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
case	O
'!'	O
:	O
switch	O
(	O
input_line_pointer	O
[	O
1	int
]	O
)	O
{	O
case	O
'!'	O
:	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
O_bit_exclusive_or	O
;	O
case	O
'='	O
:	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
O_ne	O
;	O
default	O
:	O
if	O
(	O
flag_m68k_mri	O
)	O
return	O
O_bit_inclusive_or	O
;	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
}	O
case	O
'|'	O
:	O
if	O
(	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'|'	O
)	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
O_logical_or	O
;	O
case	O
'&'	O
:	O
if	O
(	O
input_line_pointer	O
[	O
1	int
]	O
!=	O
'&'	O
)	O
return	O
op_encoding	O
[	O
c	O
]	O
;	O
*	O
num_chars	O
=	O
2	int
;	O
return	O
O_logical_and	O
;	O
}	O
}	O
void	O
add_to_result	O
(	O
expressionS	O
*	O
resultP	O
,	O
offsetT	O
amount	O
,	O
int	O
rhs_highbit	O
)	O
{	O
valueT	O
ures	O
=	O
resultP	O
->	O
X_add_number	O
;	O
valueT	O
uamount	O
=	O
amount	O
;	O
resultP	O
->	O
X_add_number	O
+=	O
amount	O
;	O
resultP	O
->	O
X_extrabit	O
^=	O
rhs_highbit	O
;	O
if	O
(	O
ures	O
+	O
uamount	O
<	O
ures	O
)	O
resultP	O
->	O
X_extrabit	O
^=	O
1	int
;	O
}	O
void	O
subtract_from_result	O
(	O
expressionS	O
*	O
resultP	O
,	O
offsetT	O
amount	O
,	O
int	O
rhs_highbit	O
)	O
{	O
valueT	O
ures	O
=	O
resultP	O
->	O
X_add_number	O
;	O
valueT	O
uamount	O
=	O
amount	O
;	O
resultP	O
->	O
X_add_number	O
-=	O
amount	O
;	O
resultP	O
->	O
X_extrabit	O
^=	O
rhs_highbit	O
;	O
if	O
(	O
ures	O
<	O
uamount	O
)	O
resultP	O
->	O
X_extrabit	O
^=	O
1	int
;	O
}	O
segT	O
expr	O
(	O
int	O
rankarg	O
,	O
expressionS	O
*	O
resultP	O
,	O
enum	O
expr_mode	O
mode	*(char)
)	O
{	O
operator_rankT	O
rank	O
=	O
(	O
operator_rankT	O
)	O
rankarg	O
;	O
segT	O
retval	O
;	O
expressionS	O
right	O
;	O
operatorT	O
op_left	O
;	O
operatorT	O
op_right	O
;	O
int	O
op_chars	O
;	O
know	O
(	O
rankarg	O
>=	O
0	int
)	O
;	O
if	O
(	O
rank	O
==	O
0	int
)	O
{	O
dot_value	O
=	O
frag_now_fix	O
(	O
)	O
;	O
dot_frag	O
=	O
frag_now	O
;	O
}	O
retval	O
=	O
operand	O
(	O
resultP	O
,	O
mode	*(char)
)	O
;	O
know	O
(	O
*	O
input_line_pointer	O
!=	O
' '	O
)	O
;	O
op_left	O
=	O
operatorf	O
(	O
&	O
op_chars	O
)	O
;	O
while	O
(	O
op_left	O
!=	O
O_illegal	O
&&	O
op_rank	O
[	O
(	O
int	O
)	O
op_left	O
]	O
>	O
rank	O
)	O
{	O
segT	O
rightseg	O
;	O
offsetT	O
frag_off	O
;	O
input_line_pointer	O
+=	O
op_chars	O
;	O
right	O
.	O
X_md	O
=	O
0	int
;	O
rightseg	O
=	O
expr	O
(	O
op_rank	O
[	O
(	O
int	O
)	O
op_left	O
]	O
,	O
&	O
right	O
,	O
mode	*(char)
)	O
;	O
if	O
(	O
right	O
.	O
X_op	O
==	O
O_absent	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"missing operand; zero assumed"	*(char)
)	O
)	O
;	O
right	O
.	O
X_op	O
=	O
O_constant	O
;	O
right	O
.	O
X_add_number	O
=	O
0	int
;	O
right	O
.	O
X_add_symbol	O
=	O
NULL	O
;	O
right	O
.	O
X_op_symbol	O
=	O
NULL	O
;	O
}	O
know	O
(	O
*	O
input_line_pointer	O
!=	O
' '	O
)	O
;	O
if	O
(	O
op_left	O
==	O
O_index	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
']'	O
)	O
as_bad	O
(	O
"missing right bracket"	*(char)
)	O
;	O
else	O
{	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
}	O
op_right	O
=	O
operatorf	O
(	O
&	O
op_chars	O
)	O
;	O
know	O
(	O
op_right	O
==	O
O_illegal	O
||	O
op_left	O
==	O
O_index	O
||	O
op_rank	O
[	O
(	O
int	O
)	O
op_right	O
]	O
<=	O
op_rank	O
[	O
(	O
int	O
)	O
op_left	O
]	O
)	O
;	O
know	O
(	O
(	O
int	O
)	O
op_left	O
>=	O
(	O
int	O
)	O
O_multiply	O
)	O
;	O
know	O
(	O
(	O
int	O
)	O
op_left	O
<	O
(	O
int	O
)	O
O_max	O
)	O
;	O
if	O
(	O
resultP	O
->	O
X_op	O
==	O
O_big	O
)	O
{	O
if	O
(	O
resultP	O
->	O
X_add_number	O
>	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"left operand is a bignum; integer 0 assumed"	*(char)
)	O
)	O
;	O
else	O
as_warn	O
(	O
_	O
(	O
"left operand is a float; integer 0 assumed"	*(char)
)	O
)	O
;	O
resultP	O
->	O
X_op	O
=	O
O_constant	O
;	O
resultP	O
->	O
X_add_number	O
=	O
0	int
;	O
resultP	O
->	O
X_add_symbol	O
=	O
NULL	O
;	O
resultP	O
->	O
X_op_symbol	O
=	O
NULL	O
;	O
}	O
if	O
(	O
right	O
.	O
X_op	O
==	O
O_big	O
)	O
{	O
if	O
(	O
right	O
.	O
X_add_number	O
>	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"right operand is a bignum; integer 0 assumed"	*(char)
)	O
)	O
;	O
else	O
as_warn	O
(	O
_	O
(	O
"right operand is a float; integer 0 assumed"	*(char)
)	O
)	O
;	O
right	O
.	O
X_op	O
=	O
O_constant	O
;	O
right	O
.	O
X_add_number	O
=	O
0	int
;	O
right	O
.	O
X_add_symbol	O
=	O
NULL	O
;	O
right	O
.	O
X_op_symbol	O
=	O
NULL	O
;	O
}	O
if	O
(	O
mode	*(char)
==	O
expr_defer	O
&&	O
(	O
(	O
resultP	O
->	O
X_add_symbol	O
!=	O
NULL	O
&&	O
S_IS_FORWARD_REF	O
(	O
resultP	O
->	O
X_add_symbol	O
)	O
)	O
||	O
(	O
right	O
.	O
X_add_symbol	O
!=	O
NULL	O
&&	O
S_IS_FORWARD_REF	O
(	O
right	O
.	O
X_add_symbol	O
)	O
)	O
)	O
)	O
goto	O
general	O
;	O
if	O
(	O
op_left	O
==	O
O_add	O
&&	O
right	O
.	O
X_op	O
==	O
O_constant	O
&&	O
(	O
md_register_arithmetic	O
||	O
resultP	O
->	O
X_op	O
!=	O
O_register	O
)	O
)	O
{	O
add_to_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
}	O
else	O
if	O
(	O
op_left	O
==	O
O_subtract	O
&&	O
right	O
.	O
X_op	O
==	O
O_symbol	O
&&	O
resultP	O
->	O
X_op	O
==	O
O_symbol	O
&&	O
retval	O
==	O
rightseg	O
&&	O
(	O
(	O
SEG_NORMAL	O
(	O
rightseg	O
)	O
&&	O
!	O
S_FORCE_RELOC	O
(	O
resultP	O
->	O
X_add_symbol	O
,	O
0	int
)	O
&&	O
!	O
S_FORCE_RELOC	O
(	O
right	O
.	O
X_add_symbol	O
,	O
0	int
)	O
)	O
||	O
right	O
.	O
X_add_symbol	O
==	O
resultP	O
->	O
X_add_symbol	O
)	O
&&	O
frag_offset_fixed_p	O
(	O
symbol_get_frag	O
(	O
resultP	O
->	O
X_add_symbol	O
)	O
,	O
symbol_get_frag	O
(	O
right	O
.	O
X_add_symbol	O
)	O
,	O
&	O
frag_off	O
)	O
)	O
{	O
offsetT	O
symval_diff	O
=	O
S_GET_VALUE	O
(	O
resultP	O
->	O
X_add_symbol	O
)	O
-	O
S_GET_VALUE	O
(	O
right	O
.	O
X_add_symbol	O
)	O
;	O
subtract_from_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
subtract_from_result	O
(	O
resultP	O
,	O
frag_off	O
/	O
OCTETS_PER_BYTE	O
,	O
0	int
)	O
;	O
add_to_result	O
(	O
resultP	O
,	O
symval_diff	O
,	O
symval_diff	O
<	O
0	int
)	O
;	O
resultP	O
->	O
X_op	O
=	O
O_constant	O
;	O
resultP	O
->	O
X_add_symbol	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
op_left	O
==	O
O_subtract	O
&&	O
right	O
.	O
X_op	O
==	O
O_constant	O
&&	O
(	O
md_register_arithmetic	O
||	O
resultP	O
->	O
X_op	O
!=	O
O_register	O
)	O
)	O
{	O
subtract_from_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
}	O
else	O
if	O
(	O
op_left	O
==	O
O_add	O
&&	O
resultP	O
->	O
X_op	O
==	O
O_constant	O
&&	O
(	O
md_register_arithmetic	O
||	O
right	O
.	O
X_op	O
!=	O
O_register	O
)	O
)	O
{	O
resultP	O
->	O
X_op	O
=	O
right	O
.	O
X_op	O
;	O
resultP	O
->	O
X_add_symbol	O
=	O
right	O
.	O
X_add_symbol	O
;	O
resultP	O
->	O
X_op_symbol	O
=	O
right	O
.	O
X_op_symbol	O
;	O
add_to_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
retval	O
=	O
rightseg	O
;	O
}	O
else	O
if	O
(	O
resultP	O
->	O
X_op	O
==	O
O_constant	O
&&	O
right	O
.	O
X_op	O
==	O
O_constant	O
)	O
{	O
offsetT	O
v	O
=	O
right	O
.	O
X_add_number	O
;	O
if	O
(	O
v	O
==	O
0	int
&&	O
(	O
op_left	O
==	O
O_divide	O
||	O
op_left	O
==	O
O_modulus	O
)	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"division by zero"	*(char)
)	O
)	O
;	O
v	O
=	O
1	int
;	O
}	O
if	O
(	O
(	O
valueT	O
)	O
v	O
>=	O
sizeof	O
(	O
valueT	O
)	O
*	O
CHAR_BIT	O
&&	O
(	O
op_left	O
==	O
O_left_shift	O
||	O
op_left	O
==	O
O_right_shift	O
)	O
)	O
{	O
as_warn_value_out_of_range	O
(	O
_	O
(	O
"shift count"	*(char)
)	O
,	O
v	O
,	O
0	int
,	O
sizeof	O
(	O
valueT	O
)	O
*	O
CHAR_BIT	O
-	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
resultP	O
->	O
X_add_number	O
=	O
v	O
=	O
0	int
;	O
}	O
switch	O
(	O
op_left	O
)	O
{	O
default	O
:	O
goto	O
general	O
;	O
case	O
O_multiply	O
:	O
resultP	O
->	O
X_add_number	O
*=	O
v	O
;	O
break	O
;	O
case	O
O_divide	O
:	O
resultP	O
->	O
X_add_number	O
/=	O
v	O
;	O
break	O
;	O
case	O
O_modulus	O
:	O
resultP	O
->	O
X_add_number	O
%=	O
v	O
;	O
break	O
;	O
case	O
O_left_shift	O
:	O
resultP	O
->	O
X_add_number	O
<<=	O
v	O
;	O
break	O
;	O
case	O
O_right_shift	O
:	O
resultP	O
->	O
X_add_number	O
=	O
(	O
offsetT	O
)	O
(	O
(	O
valueT	O
)	O
resultP	O
->	O
X_add_number	O
>>	O
(	O
valueT	O
)	O
v	O
)	O
;	O
break	O
;	O
case	O
O_bit_inclusive_or	O
:	O
resultP	O
->	O
X_add_number	O
|=	O
v	O
;	O
break	O
;	O
case	O
O_bit_or_not	O
:	O
resultP	O
->	O
X_add_number	O
|=	O
~	O
v	O
;	O
break	O
;	O
case	O
O_bit_exclusive_or	O
:	O
resultP	O
->	O
X_add_number	O
^=	O
v	O
;	O
break	O
;	O
case	O
O_bit_and	O
:	O
resultP	O
->	O
X_add_number	O
&=	O
v	O
;	O
break	O
;	O
case	O
O_subtract	O
:	O
subtract_from_result	O
(	O
resultP	O
,	O
v	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
O_eq	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
==	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ne	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
!=	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_lt	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
<	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_le	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
<=	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ge	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
>=	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_gt	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
>	O
v	O
?	O
~	O
(	O
offsetT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_logical_and	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
&&	O
v	O
;	O
break	O
;	O
case	O
O_logical_or	O
:	O
resultP	O
->	O
X_add_number	O
=	O
resultP	O
->	O
X_add_number	O
||	O
v	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
resultP	O
->	O
X_op	O
==	O
O_symbol	O
&&	O
right	O
.	O
X_op	O
==	O
O_symbol	O
&&	O
(	O
op_left	O
==	O
O_add	O
||	O
op_left	O
==	O
O_subtract	O
||	O
(	O
resultP	O
->	O
X_add_number	O
==	O
0	int
&&	O
right	O
.	O
X_add_number	O
==	O
0	int
)	O
)	O
)	O
{	O
resultP	O
->	O
X_op	O
=	O
op_left	O
;	O
resultP	O
->	O
X_op_symbol	O
=	O
right	O
.	O
X_add_symbol	O
;	O
if	O
(	O
op_left	O
==	O
O_add	O
)	O
add_to_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
else	O
if	O
(	O
op_left	O
==	O
O_subtract	O
)	O
{	O
subtract_from_result	O
(	O
resultP	O
,	O
right	O
.	O
X_add_number	O
,	O
right	O
.	O
X_extrabit	O
)	O
;	O
if	O
(	O
retval	O
==	O
rightseg	O
&&	O
SEG_NORMAL	O
(	O
retval	O
)	O
&&	O
!	O
S_FORCE_RELOC	O
(	O
resultP	O
->	O
X_add_symbol	O
,	O
0	int
)	O
&&	O
!	O
S_FORCE_RELOC	O
(	O
right	O
.	O
X_add_symbol	O
,	O
0	int
)	O
)	O
{	O
retval	O
=	O
absolute_section	O
;	O
rightseg	O
=	O
absolute_section	O
;	O
}	O
}	O
}	O
else	O
{	O
general	O
:	O
resultP	O
->	O
X_add_symbol	O
=	O
make_expr_symbol	O
(	O
resultP	O
)	O
;	O
resultP	O
->	O
X_op_symbol	O
=	O
make_expr_symbol	O
(	O
&	O
right	O
)	O
;	O
resultP	O
->	O
X_op	O
=	O
op_left	O
;	O
resultP	O
->	O
X_add_number	O
=	O
0	int
;	O
resultP	O
->	O
X_unsigned	O
=	O
1	int
;	O
resultP	O
->	O
X_extrabit	O
=	O
0	int
;	O
}	O
if	O
(	O
retval	O
!=	O
rightseg	O
)	O
{	O
if	O
(	O
retval	O
==	O
undefined_section	O
)	O
;	O
else	O
if	O
(	O
rightseg	O
==	O
undefined_section	O
)	O
retval	O
=	O
rightseg	O
;	O
else	O
if	O
(	O
retval	O
==	O
expr_section	O
)	O
;	O
else	O
if	O
(	O
rightseg	O
==	O
expr_section	O
)	O
retval	O
=	O
rightseg	O
;	O
else	O
if	O
(	O
retval	O
==	O
reg_section	O
)	O
;	O
else	O
if	O
(	O
rightseg	O
==	O
reg_section	O
)	O
retval	O
=	O
rightseg	O
;	O
else	O
if	O
(	O
rightseg	O
==	O
absolute_section	O
)	O
;	O
else	O
if	O
(	O
retval	O
==	O
absolute_section	O
)	O
retval	O
=	O
rightseg	O
;	O
else	O
if	O
(	O
op_left	O
==	O
O_subtract	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"operation combines symbols in different segments"	*(char)
)	O
)	O
;	O
}	O
op_left	O
=	O
op_right	O
;	O
}	O
if	O
(	O
resultP	O
->	O
X_add_symbol	O
)	O
symbol_mark_used	O
(	O
resultP	O
->	O
X_add_symbol	O
)	O
;	O
if	O
(	O
rank	O
==	O
0	int
&&	O
mode	*(char)
==	O
expr_evaluate	O
)	O
resolve_expression	O
(	O
resultP	O
)	O
;	O
return	O
resultP	O
->	O
X_op	O
==	O
O_constant	O
?	O
absolute_section	O
:	O
retval	O
;	O
}	O
int	O
resolve_expression	O
(	O
expressionS	O
*	O
expressionP	O
)	O
{	O
valueT	O
final_val	O
=	O
expressionP	O
->	O
X_add_number	O
;	O
symbolS	O
*	O
add_symbol	O
=	O
expressionP	O
->	O
X_add_symbol	O
;	O
symbolS	O
*	O
orig_add_symbol	O
=	O
add_symbol	O
;	O
symbolS	O
*	O
op_symbol	O
=	O
expressionP	O
->	O
X_op_symbol	O
;	O
operatorT	O
op	O
=	O
expressionP	O
->	O
X_op	O
;	O
valueT	O
left	O
,	O
right	O
;	O
segT	O
seg_left	O
,	O
seg_right	O
;	O
fragS	O
*	O
frag_left	O
,	O
*	O
frag_right	O
;	O
offsetT	O
frag_off	O
;	O
switch	O
(	O
op	O
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
O_constant	O
:	O
case	O
O_register	O
:	O
left	O
=	O
0	int
;	O
break	O
;	O
case	O
O_symbol	O
:	O
case	O
O_symbol_rva	O
:	O
if	O
(	O
!	O
snapshot_symbol	O
(	O
&	O
add_symbol	O
,	O
&	O
left	O
,	O
&	O
seg_left	O
,	O
&	O
frag_left	O
)	O
)	O
return	O
0	int
;	O
break	O
;	O
case	O
O_uminus	O
:	O
case	O
O_bit_not	O
:	O
case	O
O_logical_not	O
:	O
if	O
(	O
!	O
snapshot_symbol	O
(	O
&	O
add_symbol	O
,	O
&	O
left	O
,	O
&	O
seg_left	O
,	O
&	O
frag_left	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
seg_left	O
!=	O
absolute_section	O
)	O
return	O
0	int
;	O
if	O
(	O
op	O
==	O
O_logical_not	O
)	O
left	O
=	O
!	O
left	O
;	O
else	O
if	O
(	O
op	O
==	O
O_uminus	O
)	O
left	O
=	O
-	O
left	O
;	O
else	O
left	O
=	O
~	O
left	O
;	O
op	O
=	O
O_constant	O
;	O
break	O
;	O
case	O
O_multiply	O
:	O
case	O
O_divide	O
:	O
case	O
O_modulus	O
:	O
case	O
O_left_shift	O
:	O
case	O
O_right_shift	O
:	O
case	O
O_bit_inclusive_or	O
:	O
case	O
O_bit_or_not	O
:	O
case	O
O_bit_exclusive_or	O
:	O
case	O
O_bit_and	O
:	O
case	O
O_add	O
:	O
case	O
O_subtract	O
:	O
case	O
O_eq	O
:	O
case	O
O_ne	O
:	O
case	O
O_lt	O
:	O
case	O
O_le	O
:	O
case	O
O_ge	O
:	O
case	O
O_gt	O
:	O
case	O
O_logical_and	O
:	O
case	O
O_logical_or	O
:	O
if	O
(	O
!	O
snapshot_symbol	O
(	O
&	O
add_symbol	O
,	O
&	O
left	O
,	O
&	O
seg_left	O
,	O
&	O
frag_left	O
)	O
||	O
!	O
snapshot_symbol	O
(	O
&	O
op_symbol	O
,	O
&	O
right	O
,	O
&	O
seg_right	O
,	O
&	O
frag_right	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
op	O
==	O
O_add	O
)	O
{	O
if	O
(	O
seg_right	O
==	O
absolute_section	O
)	O
{	O
final_val	O
+=	O
right	O
;	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
seg_left	O
==	O
absolute_section	O
)	O
{	O
final_val	O
+=	O
left	O
;	O
left	O
=	O
right	O
;	O
seg_left	O
=	O
seg_right	O
;	O
add_symbol	O
=	O
op_symbol	O
;	O
orig_add_symbol	O
=	O
expressionP	O
->	O
X_op_symbol	O
;	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
op	O
==	O
O_subtract	O
)	O
{	O
if	O
(	O
seg_right	O
==	O
absolute_section	O
)	O
{	O
final_val	O
-=	O
right	O
;	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
}	O
frag_off	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
seg_left	O
==	O
absolute_section	O
&&	O
seg_right	O
==	O
absolute_section	O
)	O
&&	O
!	O
(	O
op	O
==	O
O_eq	O
||	O
op	O
==	O
O_ne	O
)	O
&&	O
!	O
(	O
(	O
op	O
==	O
O_subtract	O
||	O
op	O
==	O
O_lt	O
||	O
op	O
==	O
O_le	O
||	O
op	O
==	O
O_ge	O
||	O
op	O
==	O
O_gt	O
)	O
&&	O
seg_left	O
==	O
seg_right	O
&&	O
(	O
finalize_syms	O
||	O
frag_offset_fixed_p	O
(	O
frag_left	O
,	O
frag_right	O
,	O
&	O
frag_off	O
)	O
||	O
(	O
op	O
==	O
O_gt	O
&&	O
frag_gtoffset_p	O
(	O
left	O
,	O
frag_left	O
,	O
right	O
,	O
frag_right	O
,	O
&	O
frag_off	O
)	O
)	O
)	O
&&	O
(	O
seg_left	O
!=	O
reg_section	O
||	O
left	O
==	O
right	O
)	O
&&	O
(	O
seg_left	O
!=	O
undefined_section	O
||	O
add_symbol	O
==	O
op_symbol	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
seg_left	O
==	O
absolute_section	O
&&	O
left	O
==	O
0	int
)	O
||	O
(	O
seg_right	O
==	O
absolute_section	O
&&	O
right	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
op	O
==	O
O_bit_exclusive_or	O
||	O
op	O
==	O
O_bit_inclusive_or	O
)	O
{	O
if	O
(	O
!	O
(	O
seg_right	O
==	O
absolute_section	O
&&	O
right	O
==	O
0	int
)	O
)	O
{	O
seg_left	O
=	O
seg_right	O
;	O
left	O
=	O
right	O
;	O
add_symbol	O
=	O
op_symbol	O
;	O
orig_add_symbol	O
=	O
expressionP	O
->	O
X_op_symbol	O
;	O
}	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_left_shift	O
||	O
op	O
==	O
O_right_shift	O
)	O
{	O
if	O
(	O
!	O
(	O
seg_left	O
==	O
absolute_section	O
&&	O
left	O
==	O
0	int
)	O
)	O
{	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
op	O
!=	O
O_multiply	O
&&	O
op	O
!=	O
O_bit_or_not	O
&&	O
op	O
!=	O
O_bit_and	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_multiply	O
&&	O
seg_left	O
==	O
absolute_section	O
&&	O
left	O
==	O
1	int
)	O
{	O
seg_left	O
=	O
seg_right	O
;	O
left	O
=	O
right	O
;	O
add_symbol	O
=	O
op_symbol	O
;	O
orig_add_symbol	O
=	O
expressionP	O
->	O
X_op_symbol	O
;	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
==	O
O_multiply	O
||	O
op	O
==	O
O_divide	O
)	O
&&	O
seg_right	O
==	O
absolute_section	O
&&	O
right	O
==	O
1	int
)	O
{	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
left	O
==	O
right	O
&&	O
(	O
(	O
seg_left	O
==	O
reg_section	O
&&	O
seg_right	O
==	O
reg_section	O
)	O
||	O
(	O
seg_left	O
==	O
undefined_section	O
&&	O
seg_right	O
==	O
undefined_section	O
&&	O
add_symbol	O
==	O
op_symbol	O
)	O
)	O
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
op	O
==	O
O_bit_and	O
||	O
op	O
==	O
O_bit_inclusive_or	O
)	O
{	O
op	O
=	O
O_symbol	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
op	O
!=	O
O_bit_exclusive_or	O
&&	O
op	O
!=	O
O_bit_or_not	O
)	O
return	O
0	int
;	O
}	O
right	O
+=	O
frag_off	O
/	O
OCTETS_PER_BYTE	O
;	O
switch	O
(	O
op	O
)	O
{	O
case	O
O_add	O
:	O
left	O
+=	O
right	O
;	O
break	O
;	O
case	O
O_subtract	O
:	O
left	O
-=	O
right	O
;	O
break	O
;	O
case	O
O_multiply	O
:	O
left	O
*=	O
right	O
;	O
break	O
;	O
case	O
O_divide	O
:	O
if	O
(	O
right	O
==	O
0	int
)	O
return	O
0	int
;	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
/	O
(	O
offsetT	O
)	O
right	O
;	O
break	O
;	O
case	O
O_modulus	O
:	O
if	O
(	O
right	O
==	O
0	int
)	O
return	O
0	int
;	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
%	O
(	O
offsetT	O
)	O
right	O
;	O
break	O
;	O
case	O
O_left_shift	O
:	O
left	O
<<=	O
right	O
;	O
break	O
;	O
case	O
O_right_shift	O
:	O
left	O
>>=	O
right	O
;	O
break	O
;	O
case	O
O_bit_inclusive_or	O
:	O
left	O
|=	O
right	O
;	O
break	O
;	O
case	O
O_bit_or_not	O
:	O
left	O
|=	O
~	O
right	O
;	O
break	O
;	O
case	O
O_bit_exclusive_or	O
:	O
left	O
^=	O
right	O
;	O
break	O
;	O
case	O
O_bit_and	O
:	O
left	O
&=	O
right	O
;	O
break	O
;	O
case	O
O_eq	O
:	O
case	O
O_ne	O
:	O
left	O
=	O
(	O
left	O
==	O
right	O
&&	O
seg_left	O
==	O
seg_right	O
&&	O
(	O
finalize_syms	O
||	O
frag_left	O
==	O
frag_right	O
)	O
&&	O
(	O
seg_left	O
!=	O
undefined_section	O
||	O
add_symbol	O
==	O
op_symbol	O
)	O
?	O
~	O
(	O
valueT	O
)	O
0	int
:	O
0	int
)	O
;	O
if	O
(	O
op	O
==	O
O_ne	O
)	O
left	O
=	O
~	O
left	O
;	O
break	O
;	O
case	O
O_lt	O
:	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
<	O
(	O
offsetT	O
)	O
right	O
?	O
~	O
(	O
valueT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_le	O
:	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
<=	O
(	O
offsetT	O
)	O
right	O
?	O
~	O
(	O
valueT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ge	O
:	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
>=	O
(	O
offsetT	O
)	O
right	O
?	O
~	O
(	O
valueT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_gt	O
:	O
left	O
=	O
(	O
offsetT	O
)	O
left	O
>	O
(	O
offsetT	O
)	O
right	O
?	O
~	O
(	O
valueT	O
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_logical_and	O
:	O
left	O
=	O
left	O
&&	O
right	O
;	O
break	O
;	O
case	O
O_logical_or	O
:	O
left	O
=	O
left	O
||	O
right	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
op	O
=	O
O_constant	O
;	O
break	O
;	O
}	O
if	O
(	O
op	O
==	O
O_symbol	O
)	O
{	O
if	O
(	O
seg_left	O
==	O
absolute_section	O
)	O
op	O
=	O
O_constant	O
;	O
else	O
if	O
(	O
seg_left	O
==	O
reg_section	O
&&	O
final_val	O
==	O
0	int
)	O
op	O
=	O
O_register	O
;	O
else	O
if	O
(	O
!	O
symbol_same_p	O
(	O
add_symbol	O
,	O
orig_add_symbol	O
)	O
)	O
final_val	O
+=	O
left	O
;	O
expressionP	O
->	O
X_add_symbol	O
=	O
add_symbol	O
;	O
}	O
expressionP	O
->	O
X_op	O
=	O
op	O
;	O
if	O
(	O
op	O
==	O
O_constant	O
||	O
op	O
==	O
O_register	O
)	O
final_val	O
+=	O
left	O
;	O
expressionP	O
->	O
X_add_number	O
=	O
final_val	O
;	O
return	O
1	int
;	O
}	O
char	O
get_symbol_name	O
(	O
char	O
*	O
*	O
ilp_return	O
)	O
{	O
char	O
c	O
;	O
*	O
ilp_return	O
=	O
input_line_pointer	O
;	O
if	O
(	O
is_name_beginner	O
(	O
c	O
=	O
*	O
input_line_pointer	O
++	O
)	O
||	O
(	O
input_from_string	O
&&	O
c	O
==	O
FAKE_LABEL_CHAR	O
)	O
)	O
{	O
while	O
(	O
is_part_of_name	O
(	O
c	O
=	O
*	O
input_line_pointer	O
++	O
)	O
||	O
(	O
input_from_string	O
&&	O
c	O
==	O
FAKE_LABEL_CHAR	O
)	O
)	O
;	O
if	O
(	O
is_name_ender	O
(	O
c	O
)	O
)	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
}	O
else	O
if	O
(	O
c	O
==	O
'"'	O
)	O
{	O
bfd_boolean	int
backslash_seen	O
;	O
*	O
ilp_return	O
=	O
input_line_pointer	O
;	O
do	O
{	O
backslash_seen	O
=	O
c	O
==	O
'\\'	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
}	O
while	O
(	O
c	O
!=	O
0	int
&&	O
(	O
c	O
!=	O
'"'	O
||	O
backslash_seen	O
)	O
)	O
;	O
if	O
(	O
c	O
==	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"missing closing '\"'"	*(char)
)	O
)	O
;	O
}	O
*	O
--	O
input_line_pointer	O
=	O
0	int
;	O
return	O
c	O
;	O
}	O
char	O
restore_line_pointer	O
(	O
char	O
c	O
)	O
{	O
*	O
input_line_pointer	O
=	O
c	O
;	O
if	O
(	O
c	O
==	O
'"'	O
)	O
c	O
=	O
*	O
++	O
input_line_pointer	O
;	O
return	O
c	O
;	O
}	O
unsigned	O
int	O
get_single_number	O
(	O
void	O
)	O
{	O
expressionS	O
exp	O
;	O
operand	O
(	O
&	O
exp	O
,	O
expr_normal	O
)	O
;	O
return	O
exp	O
.	O
X_add_number	O
;	O
}	O
