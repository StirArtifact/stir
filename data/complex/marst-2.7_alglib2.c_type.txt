struct	O
mem	O
*	O
stack_top	O
=	O
NULL	O
;	O
struct	O
dsa	O
*	O
active_dsa	O
=	O
NULL	O
;	O
struct	O
dsa	O
*	O
global_dsa	O
=	O
NULL	O
;	O
int	O
real2int	O
(	O
double	O
x	O
)	O
{	O
x	O
=	O
floor	(double)->(double)
(	O
x	O
+	O
0.5	int
)	O
;	O
if	O
(	O
!	O
(	O
(	O
double	O
)	O
INT_MIN	O
<=	O
x	O
&&	O
x	O
<=	O
(	O
double	O
)	O
INT_MAX	O
)	O
)	O
fault	O
(	O
"real number to be converted out of integer range"	*(char)
)	O
;	O
return	O
(	O
int	O
)	O
x	O
;	O
}	O
double	O
int2real	O
(	O
int	O
x	O
)	O
{	O
return	O
(	O
double	O
)	O
x	O
;	O
}	O
double	O
expr	O
(	O
double	O
x	O
,	O
double	O
r	O
)	O
{	O
double	O
ret	O
;	O
if	O
(	O
x	O
>	O
0.0	int
)	O
ret	O
=	O
pow	(double,double)->(double)
(	O
x	O
,	O
r	O
)	O
;	O
else	O
if	O
(	O
x	O
==	O
0.0	int
&&	O
r	O
>	O
0.0	int
)	O
ret	O
=	O
0.0	int
;	O
else	O
fault	O
(	O
"expr undefined "	*(char)
REAL_FMT	O
,	O
x	O
)	O
;	O
return	O
ret	O
;	O
}	O
int	O
expi	O
(	O
int	O
i	O
,	O
int	O
j	O
)	O
{	O
int	O
ret	O
;	O
unsigned	O
u	O
;	O
if	O
(	O
j	O
<	O
0	int
||	O
(	O
i	O
==	O
0	int
&&	O
j	O
==	O
0	int
)	O
)	O
fault	O
(	O
"expi undefined %d"	*(char)
,	O
j	O
)	O
;	O
ret	O
=	O
1	int
;	O
u	O
=	O
j	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
u	O
&	O
1	int
)	O
ret	O
*=	O
i	O
;	O
if	O
(	O
u	O
>>=	O
1	int
)	O
i	O
*=	O
i	O
;	O
else	O
break	O
;	O
}	O
return	O
ret	O
;	O
}	O
double	O
expn	O
(	O
double	O
x	O
,	O
int	O
n	O
)	O
{	O
double	O
ret	O
;	O
unsigned	O
u	O
;	O
if	O
(	O
n	O
==	O
0	int
&&	O
x	O
==	O
0.0	int
)	O
fault	O
(	O
"expn undefined "	*(char)
REAL_FMT	O
,	O
x	O
)	O
;	O
ret	O
=	O
1.0	int
;	O
u	O
=	O
(	O
n	O
>=	O
0	int
?	O
n	O
:	O
(	O
x	O
=	O
1.0	int
/	O
x	O
,	O
-	O
n	O
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
u	O
&	O
1	int
)	O
ret	O
*=	O
x	O
;	O
if	O
(	O
u	O
>>=	O
1	int
)	O
x	O
*=	O
x	O
;	O
else	O
break	O
;	O
}	O
return	O
ret	O
;	O
}	O
double	O
get_real	O
(	O
struct	O
desc	O
x	O
)	O
{	O
double	O
val	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'r'	O
:	O
val	O
=	O
(	O
x	O
.	O
lval	O
?	O
*	O
x	O
.	O
u	O
.	O
real_ptr	O
:	O
x	O
.	O
u	O
.	O
real_val	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
val	O
=	O
int2real	O
(	O
x	O
.	O
lval	O
?	O
*	O
x	O
.	O
u	O
.	O
int_ptr	O
:	O
x	O
.	O
u	O
.	O
int_val	O
)	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"evaluation of a real formal parameter not possible b"	*(char)
"ecause final actual parameter is not of arithmetic type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
int	O
get_int	O
(	O
struct	O
desc	O
x	O
)	O
{	O
int	O
val	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'r'	O
:	O
val	O
=	O
real2int	O
(	O
x	O
.	O
lval	O
?	O
*	O
x	O
.	O
u	O
.	O
real_ptr	O
:	O
x	O
.	O
u	O
.	O
real_val	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
val	O
=	O
(	O
x	O
.	O
lval	O
?	O
*	O
x	O
.	O
u	O
.	O
int_ptr	O
:	O
x	O
.	O
u	O
.	O
int_val	O
)	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"evaluation of an integer formal parameter not possib"	*(char)
"le because final actual parameter is not of arithmetic "	*(char)
"type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
bool	int
get_bool	O
(	O
struct	O
desc	O
x	O
)	O
{	O
bool	int
val	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'b'	O
:	O
val	O
=	O
(	O
x	O
.	O
lval	O
?	O
*	O
x	O
.	O
u	O
.	O
bool_ptr	O
:	O
x	O
.	O
u	O
.	O
bool_val	O
)	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"evaluation of a Boolean formal parameter not possibl"	*(char)
"e because final actual parameter is not of Boolean type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
struct	O
label	O
get_label	O
(	O
struct	O
desc	O
x	O
)	O
{	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'l'	O
:	O
assert	O
(	O
!	O
x	O
.	O
lval	O
)	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"evaluation of a formal label not possible because fi"	*(char)
"nal actual parameter is not of label type"	*(char)
)	O
;	O
}	O
return	O
x	O
.	O
u	O
.	O
label	O
;	O
}	O
double	O
set_real	O
(	O
struct	O
desc	O
x	O
,	O
double	O
val	O
)	O
{	O
if	O
(	O
!	O
x	O
.	O
lval	O
)	O
fault	O
(	O
"assignment to a real formal parameter called by name no"	*(char)
"t possible because final actual parameter is not a variabl"	*(char)
"e"	*(char)
)	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'r'	O
:	O
*	O
x	O
.	O
u	O
.	O
real_ptr	O
=	O
val	O
;	O
break	O
;	O
case	O
'i'	O
:	O
*	O
x	O
.	O
u	O
.	O
int_ptr	O
=	O
real2int	O
(	O
val	O
)	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"assignment to a real formal parameter called by name"	*(char)
" not possible because final actual parameter is not of "	*(char)
"arithmetic type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
int	O
set_int	O
(	O
struct	O
desc	O
x	O
,	O
int	O
val	O
)	O
{	O
if	O
(	O
!	O
x	O
.	O
lval	O
)	O
fault	O
(	O
"assignment to an integer formal parameter called by nam"	*(char)
"e not possible because final actual parameter is not a var"	*(char)
"iable"	*(char)
)	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'r'	O
:	O
*	O
x	O
.	O
u	O
.	O
real_ptr	O
=	O
int2real	O
(	O
val	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
*	O
x	O
.	O
u	O
.	O
int_ptr	O
=	O
val	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"assignment to an integer formal parameter called by "	*(char)
"name not possible because final actual parameter is not"	*(char)
" of arithmetic type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
bool	int
set_bool	O
(	O
struct	O
desc	O
x	O
,	O
bool	int
val	O
)	O
{	O
if	O
(	O
!	O
x	O
.	O
lval	O
)	O
fault	O
(	O
"assignment to a Boolean formal parameter called by name"	*(char)
" not possible because final actual parameter is not a vari"	*(char)
"able"	*(char)
)	O
;	O
switch	O
(	O
x	O
.	O
type	O
)	O
{	O
case	O
'b'	O
:	O
*	O
x	O
.	O
u	O
.	O
bool_ptr	O
=	O
val	O
;	O
break	O
;	O
default	O
:	O
fault	O
(	O
"assignment to a Boolean formal parameter called by n"	*(char)
"ame not possible because final actual parameter is not "	*(char)
"of Boolean type"	*(char)
)	O
;	O
}	O
return	O
val	O
;	O
}	O
struct	O
arg	O
make_arg	O
(	O
void	O
*	O
arg1	O
,	O
void	O
*	O
arg2	O
)	O
{	O
struct	O
arg	O
arg	O
;	O
arg	O
.	O
arg1	O
=	O
arg1	O
;	O
arg	O
.	O
arg2	O
=	O
arg2	O
;	O
return	O
arg	O
;	O
}	O
struct	O
label	O
make_label	O
(	O
void	O
*	O
jump	O
,	O
int	O
kase	O
)	O
{	O
struct	O
label	O
x	O
;	O
x	O
.	O
jump	O
=	O
jump	O
;	O
x	O
.	O
kase	O
=	O
kase	O
;	O
return	O
x	O
;	O
}	O
void	O
go_to	O
(	O
struct	O
label	O
x	O
)	O
{	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
x	O
.	O
jump	O
,	O
x	O
.	O
kase	O
)	O
;	O
}	O
static	O
void	O
*	O
my_malloc	O
(	O
int	O
size	O
)	O
{	O
void	O
*	O
ptr	O
;	O
assert	O
(	O
size	O
>	O
0	int
)	O
;	O
ptr	O
=	O
malloc	(long)->(*(void))
(	O
size	O
)	O
;	O
if	O
(	O
ptr	O
==	O
NULL	O
)	O
fault	O
(	O
"main storage requested not available"	*(char)
)	O
;	O
return	O
ptr	O
;	O
}	O
static	O
void	O
my_free	O
(	O
void	O
*	O
ptr	O
)	O
{	O
assert	O
(	O
ptr	O
!=	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
ptr	O
)	O
;	O
return	O
;	O
}	O
static	O
void	O
*	O
push_stack	O
(	O
int	O
size	O
)	O
{	O
struct	O
mem	O
*	O
top	O
;	O
assert	O
(	O
size	O
>	O
0	int
)	O
;	O
if	O
(	O
size	O
>	O
INT_MAX	O
-	O
offsetof	O
(	O
struct	O
mem	O
,	O
body	O
)	O
)	O
fault	O
(	O
"main storage requested not available"	*(char)
)	O
;	O
top	O
=	O
my_malloc	O
(	O
offsetof	O
(	O
struct	O
mem	O
,	O
body	O
)	O
+	O
size	O
)	O
;	O
top	O
->	O
size	O
=	O
size	O
;	O
top	O
->	O
ptr	O
=	O
stack_top	O
;	O
stack_top	O
=	O
top	O
;	O
return	O
&	O
top	O
->	O
body	O
;	O
}	O
void	O
pop_stack	O
(	O
struct	O
mem	O
*	O
top	O
)	O
{	O
while	O
(	O
stack_top	O
!=	O
top	O
)	O
{	O
struct	O
mem	O
*	O
ptr	O
;	O
ptr	O
=	O
stack_top	O
;	O
stack_top	O
=	O
stack_top	O
->	O
ptr	O
;	O
my_free	O
(	O
ptr	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
struct	O
dv	O
*	O
copy_dv	O
(	O
int	O
own	O
,	O
struct	O
dv	O
*	O
dope	O
)	O
{	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
assert	O
(	O
1	int
<=	O
dope	O
->	O
n	O
&&	O
dope	O
->	O
n	O
<=	O
9	int
)	O
;	O
size	O
=	O
offsetof	O
(	O
struct	O
dv	O
,	O
d	O
[	O
dope	O
->	O
n	O
]	O
)	O
;	O
dv	O
=	O
own	O
?	O
my_malloc	O
(	O
size	O
)	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dv	O
,	O
dope	O
,	O
size	O
)	O
;	O
return	O
dv	O
;	O
}	O
static	O
struct	O
dv	O
*	O
make_dv	O
(	O
int	O
own	O
,	O
int	O
n	O
,	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
)	O
{	O
struct	O
dv	O
dv	O
;	O
int	O
k	O
;	O
assert	O
(	O
1	int
<=	O
n	O
&&	O
n	O
<=	O
9	int
)	O
;	O
dv	O
.	O
base	O
=	O
NULL	O
;	O
dv	O
.	O
n	O
=	O
n	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
n	O
;	O
k	O
++	O
)	O
{	O
dv	O
.	O
d	O
[	O
k	O
]	O
.	O
lo	O
=	O
va_arg	O
(	O
arg	O
,	O
int	O
)	O
;	O
dv	O
.	O
d	O
[	O
k	O
]	O
.	O
up	O
=	O
va_arg	O
(	O
arg	O
,	O
int	O
)	O
;	O
}	O
return	O
copy_dv	O
(	O
own	O
,	O
&	O
dv	O
)	O
;	O
}	O
static	O
int	O
array_size	O
(	O
int	O
type	O
,	O
struct	O
dv	O
*	O
dv	O
)	O
{	O
int	O
size	O
,	O
k	O
;	O
switch	O
(	O
type	O
)	O
{	O
case	O
'r'	O
:	O
size	O
=	O
sizeof	O
(	O
double	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
size	O
=	O
sizeof	O
(	O
int	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
size	O
=	O
sizeof	O
(	O
bool	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
type	O
!=	O
type	O
)	O
;	O
}	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
dv	O
->	O
n	O
;	O
k	O
++	O
)	O
if	O
(	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
lo	O
>	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
up	O
)	O
return	O
0	int
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
dv	O
->	O
n	O
;	O
k	O
++	O
)	O
{	O
int	O
lo	O
=	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
lo	O
;	O
int	O
up	O
=	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
up	O
;	O
int	O
t	O
;	O
if	O
(	O
lo	O
<	O
0	int
&&	O
up	O
>	O
(	O
INT_MAX	O
+	O
lo	O
)	O
-	O
1	int
)	O
too	O
:	O
fault	O
(	O
"unable to allocate too long array"	*(char)
)	O
;	O
t	O
=	O
up	O
-	O
lo	O
+	O
1	int
;	O
if	O
(	O
size	O
>	O
INT_MAX	O
/	O
t	O
)	O
goto	O
too	O
;	O
size	O
*=	O
t	O
;	O
}	O
return	O
size	O
;	O
}	O
struct	O
dv	O
*	O
alloc_array	O
(	O
int	O
type	O
,	O
int	O
n	O
,	O
...	O
)	O
{	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
va_start	O
(	O
arg	O
,	O
n	O
)	O
;	O
dv	O
=	O
make_dv	O
(	O
0	int
,	O
n	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
size	O
=	O
array_size	O
(	O
type	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
alloc_same	O
(	O
int	O
type	O
,	O
struct	O
dv	O
*	O
dope	O
)	O
{	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
dv	O
=	O
copy_dv	O
(	O
0	int
,	O
dope	O
)	O
;	O
size	O
=	O
array_size	O
(	O
type	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
own_array	O
(	O
int	O
type	O
,	O
int	O
n	O
,	O
...	O
)	O
{	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
va_start	O
(	O
arg	O
,	O
n	O
)	O
;	O
dv	O
=	O
make_dv	O
(	O
1	int
,	O
n	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
size	O
=	O
array_size	O
(	O
type	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
my_malloc	O
(	O
size	O
)	O
;	O
if	O
(	O
size	O
!=	O
0	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
dv	O
->	O
base	O
,	O
0	int
,	O
size	O
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
own_same	O
(	O
int	O
type	O
,	O
struct	O
dv	O
*	O
dope	O
)	O
{	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
dv	O
=	O
copy_dv	O
(	O
1	int
,	O
dope	O
)	O
;	O
size	O
=	O
array_size	O
(	O
type	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
my_malloc	O
(	O
size	O
)	O
;	O
if	O
(	O
size	O
!=	O
0	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
dv	O
->	O
base	O
,	O
0	int
,	O
size	O
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
copy_real	O
(	O
struct	O
arg	O
arg	O
)	O
{	O
struct	O
dv	O
*	O
dope	O
=	O
arg	O
.	O
arg1	O
;	O
int	O
type	O
=	O
(	O
int	O
)	O
arg	O
.	O
arg2	O
;	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
dv	O
=	O
copy_dv	O
(	O
0	int
,	O
dope	O
)	O
;	O
size	O
=	O
array_size	O
(	O
'r'	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
if	O
(	O
type	O
==	O
'r'	O
)	O
{	O
if	O
(	O
size	O
!=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dv	O
->	O
base	O
,	O
dope	O
->	O
base	O
,	O
size	O
)	O
;	O
}	O
else	O
if	O
(	O
type	O
==	O
'i'	O
)	O
{	O
int	O
*	O
s	O
;	O
double	O
*	O
t	O
;	O
for	O
(	O
s	O
=	O
dope	O
->	O
base	O
,	O
t	O
=	O
dv	O
->	O
base	O
;	O
size	O
>	O
0	int
;	O
s	O
++	O
,	O
t	O
++	O
,	O
size	O
-=	O
sizeof	O
(	O
double	O
)	O
)	O
*	O
t	O
=	O
int2real	O
(	O
*	O
s	O
)	O
;	O
}	O
else	O
fault	O
(	O
"creation of a real formal array called by value not pos"	*(char)
"sible because final actual parameter is not an array of ar"	*(char)
"ithmetic type"	*(char)
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
copy_int	O
(	O
struct	O
arg	O
arg	O
)	O
{	O
struct	O
dv	O
*	O
dope	O
=	O
arg	O
.	O
arg1	O
;	O
int	O
type	O
=	O
(	O
int	O
)	O
arg	O
.	O
arg2	O
;	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
dv	O
=	O
copy_dv	O
(	O
0	int
,	O
dope	O
)	O
;	O
size	O
=	O
array_size	O
(	O
'i'	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
if	O
(	O
type	O
==	O
'r'	O
)	O
{	O
double	O
*	O
s	O
;	O
int	O
*	O
t	O
;	O
for	O
(	O
s	O
=	O
dope	O
->	O
base	O
,	O
t	O
=	O
dv	O
->	O
base	O
;	O
size	O
>	O
0	int
;	O
s	O
++	O
,	O
t	O
++	O
,	O
size	O
-=	O
sizeof	O
(	O
int	O
)	O
)	O
*	O
t	O
=	O
real2int	O
(	O
*	O
s	O
)	O
;	O
}	O
else	O
if	O
(	O
type	O
==	O
'i'	O
)	O
{	O
if	O
(	O
size	O
!=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dv	O
->	O
base	O
,	O
dope	O
->	O
base	O
,	O
size	O
)	O
;	O
}	O
else	O
fault	O
(	O
"creation of an integer formal array called by value not"	*(char)
" possible because final actual parameter is not an array o"	*(char)
"f arithmetic type"	*(char)
)	O
;	O
return	O
dv	O
;	O
}	O
struct	O
dv	O
*	O
copy_bool	O
(	O
struct	O
arg	O
arg	O
)	O
{	O
struct	O
dv	O
*	O
dope	O
=	O
arg	O
.	O
arg1	O
;	O
int	O
type	O
=	O
(	O
int	O
)	O
arg	O
.	O
arg2	O
;	O
struct	O
dv	O
*	O
dv	O
;	O
int	O
size	O
;	O
dv	O
=	O
copy_dv	O
(	O
0	int
,	O
dope	O
)	O
;	O
size	O
=	O
array_size	O
(	O
'b'	O
,	O
dv	O
)	O
;	O
dv	O
->	O
base	O
=	O
size	O
==	O
0	int
?	O
NULL	O
:	O
push_stack	O
(	O
size	O
)	O
;	O
if	O
(	O
type	O
==	O
'b'	O
)	O
{	O
if	O
(	O
size	O
!=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dv	O
->	O
base	O
,	O
dope	O
->	O
base	O
,	O
size	O
)	O
;	O
}	O
else	O
fault	O
(	O
"creation of a Boolean formal array called by value not "	*(char)
"possible because final actual parameter is not an array of"	*(char)
" Boolean type"	*(char)
)	O
;	O
return	O
dv	O
;	O
}	O
static	O
int	O
loc_elem	O
(	O
struct	O
dv	O
*	O
dv	O
,	O
int	O
n	O
,	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
)	O
{	O
int	O
loc	O
,	O
k	O
;	O
if	O
(	O
dv	O
->	O
n	O
!=	O
n	O
)	O
fault	O
(	O
"unequal number of dimensions for actual and formal para"	*(char)
"meter array"	*(char)
)	O
;	O
loc	O
=	O
0	int
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
n	O
;	O
k	O
++	O
)	O
{	O
int	O
lo	O
=	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
lo	O
;	O
int	O
up	O
=	O
dv	O
->	O
d	O
[	O
k	O
]	O
.	O
up	O
;	O
int	O
i	O
=	O
va_arg	O
(	O
arg	O
,	O
int	O
)	O
;	O
if	O
(	O
!	O
(	O
lo	O
<=	O
i	O
&&	O
i	O
<=	O
up	O
)	O
)	O
fault	O
(	O
"value of subscript expression not within declared bo"	*(char)
"unds of array"	*(char)
)	O
;	O
loc	O
=	O
(	O
up	O
-	O
lo	O
+	O
1	int
)	O
*	O
loc	O
+	O
(	O
i	O
-	O
lo	O
)	O
;	O
}	O
return	O
loc	O
;	O
}	O
double	O
*	O
loc_real	O
(	O
struct	O
dv	O
*	O
dv	O
,	O
int	O
n	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
int	O
loc	O
;	O
va_start	O
(	O
arg	O
,	O
n	O
)	O
;	O
loc	O
=	O
loc_elem	O
(	O
dv	O
,	O
n	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
return	O
(	O
double	O
*	O
)	O
dv	O
->	O
base	O
+	O
loc	O
;	O
}	O
int	O
*	O
loc_int	O
(	O
struct	O
dv	O
*	O
dv	O
,	O
int	O
n	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
int	O
loc	O
;	O
va_start	O
(	O
arg	O
,	O
n	O
)	O
;	O
loc	O
=	O
loc_elem	O
(	O
dv	O
,	O
n	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
return	O
(	O
int	O
*	O
)	O
dv	O
->	O
base	O
+	O
loc	O
;	O
}	O
bool	int
*	O
loc_bool	O
(	O
struct	O
dv	O
*	O
dv	O
,	O
int	O
n	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
int	O
loc	O
;	O
va_start	O
(	O
arg	O
,	O
n	O
)	O
;	O
loc	O
=	O
loc_elem	O
(	O
dv	O
,	O
n	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
return	O
(	O
bool	int
*	O
)	O
dv	O
->	O
base	O
+	O
loc	O
;	O
}	O
static	O
FILE	struct
*	O
stream	O
[	O
CHANNEL_MAX	O
]	O
;	O
static	O
int	O
status	O
[	O
CHANNEL_MAX	O
]	O
;	O
void	O
fault	O
(	O
char	O
*	O
fmt	O
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
arg	O
;	O
struct	O
dsa	O
*	O
dsa	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"fault: "	*(char)
)	O
;	O
va_start	O
(	O
arg	O
,	O
fmt	O
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	O
,	O
arg	O
)	O
;	O
va_end	O
(	O
arg	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
for	O
(	O
dsa	O
=	O
active_dsa	O
;	O
dsa	O
!=	O
NULL	O
;	O
dsa	O
=	O
dsa	O
->	O
parent	O
)	O
{	O
if	O
(	O
dsa	O
->	O
parent	O
==	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"main program"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"procedure %s"	*(char)
,	O
dsa	O
->	O
proc	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
", file %s, line %d\n"	*(char)
,	O
dsa	O
->	O
file	O
,	O
dsa	O
->	O
line	O
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
int	O
k	O
;	O
for	O
(	O
k	O
=	O
0	int
;	O
k	O
<	O
CHANNEL_MAX	O
;	O
k	O
++	O
)	O
if	O
(	O
status	O
[	O
k	O
]	O
==	O
'w'	O
)	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
k	O
]	O
)	O
;	O
}	O
exit	(int)->(void)
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
static	O
void	O
connect	O
(	O
int	O
channel	O
,	O
int	O
mode	O
)	O
{	O
if	O
(	O
!	O
(	O
0	int
<=	O
channel	O
&&	O
channel	O
<	O
CHANNEL_MAX	O
)	O
)	O
fault	O
(	O
"channel number %d out of range"	*(char)
,	O
channel	O
)	O
;	O
assert	O
(	O
mode	O
==	O
'r'	O
||	O
mode	O
==	O
'w'	O
)	O
;	O
if	O
(	O
status	O
[	O
channel	O
]	O
!=	O
mode	O
)	O
{	O
if	O
(	O
channel	O
==	O
0	int
)	O
{	O
if	O
(	O
mode	O
==	O
'w'	O
)	O
fault	O
(	O
"output to standard input channel not allowed"	*(char)
)	O
;	O
if	O
(	O
status	O
[	O
channel	O
]	O
==	O
0	int
)	O
{	O
stream	O
[	O
channel	O
]	O
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
status	O
[	O
channel	O
]	O
=	O
'r'	O
;	O
}	O
}	O
else	O
if	O
(	O
channel	O
==	O
1	int
)	O
{	O
if	O
(	O
mode	O
==	O
'r'	O
)	O
fault	O
(	O
"input from standard output channel not allowed"	*(char)
)	O
;	O
if	O
(	O
status	O
[	O
channel	O
]	O
==	O
0	int
)	O
{	O
stream	O
[	O
channel	O
]	O
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
status	O
[	O
channel	O
]	O
=	O
'w'	O
;	O
}	O
}	O
else	O
{	O
char	O
dd_name	O
[	O
15	int
+	O
1	int
]	O
,	O
*	O
filename	O
;	O
if	O
(	O
status	O
[	O
channel	O
]	O
!=	O
0	int
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
channel	O
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
dd_name	O
,	O
"FILE_%d"	*(char)
,	O
channel	O
)	O
;	O
filename	O
=	O
getenv	(*(char))->(*(char))
(	O
dd_name	O
)	O
;	O
if	O
(	O
filename	O
==	O
NULL	O
)	O
filename	O
=	O
dd_name	O
;	O
stream	O
[	O
channel	O
]	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	O
,	O
mode	O
==	O
'w'	O
?	O
"w"	*(char)
:	O
"r"	*(char)
)	O
;	O
if	O
(	O
stream	O
[	O
channel	O
]	O
==	O
NULL	O
)	O
fault	O
(	O
"unable to connect channel %d to file `%s' for %s "	*(char)
"- %s"	*(char)
,	O
channel	O
,	O
filename	O
,	O
mode	O
==	O
'w'	O
?	O
"output"	*(char)
:	O
"input"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
status	O
[	O
channel	O
]	O
=	O
mode	O
;	O
}	O
}	O
return	O
;	O
}	O
int	O
inchar	O
(	O
int	O
channel	O
)	O
{	O
int	O
c	O
;	O
connect	O
(	O
channel	O
,	O
'r'	O
)	O
;	O
c	O
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
channel	O
]	O
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
channel	O
]	O
)	O
)	O
fault	O
(	O
"unable to input from channel %d - %s"	*(char)
,	O
channel	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
channel	O
]	O
)	O
)	O
fault	O
(	O
"unable to input from channel %d - input request beyond "	*(char)
"end of data"	*(char)
,	O
channel	O
)	O
;	O
return	O
c	O
;	O
}	O
void	O
outchar	O
(	O
int	O
channel	O
,	O
int	O
c	O
)	O
{	O
connect	O
(	O
channel	O
,	O
'w'	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	O
,	O
stream	O
[	O
channel	O
]	O
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	O
[	O
channel	O
]	O
)	O
)	O
fault	O
(	O
"unable to output to channel %d - %s"	*(char)
,	O
channel	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
void	O
outstring	O
(	O
int	O
channel	O
,	O
char	O
*	O
str	O
)	O
{	O
connect	O
(	O
channel	O
,	O
'w'	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	O
[	O
channel	O
]	O
,	O
"%s"	*(char)
,	O
str	O
)	O
;	O
return	O
;	O
}	O
static	O
char	O
*	O
input_data	O
(	O
int	O
channel	O
)	O
{	O
static	O
char	O
str	O
[	O
255	int
+	O
1	int
]	O
;	O
int	O
len	O
=	O
0	int
,	O
c	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	O
=	O
inchar	O
(	O
channel	O
)	O
;	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c	O
)	O
)	O
break	O
;	O
}	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
c	O
)	O
)	O
{	O
if	O
(	O
len	O
==	O
sizeof	O
(	O
str	O
)	O
-	O
1	int
)	O
{	O
str	O
[	O
len	O
]	O
=	O
'\0'	O
;	O
fault	O
(	O
"input data item `%.12s...' too long"	*(char)
,	O
str	O
)	O
;	O
}	O
str	O
[	O
len	O
++	O
]	O
=	O
(	O
char	O
)	O
c	O
;	O
c	O
=	O
inchar	O
(	O
channel	O
)	O
;	O
}	O
str	O
[	O
len	O
]	O
=	O
'\0'	O
;	O
return	O
str	O
;	O
}	O
int	O
ininteger	O
(	O
int	O
channel	O
)	O
{	O
int	O
x	O
;	O
char	O
*	O
str	O
,	O
*	O
ptr	O
;	O
str	O
=	O
input_data	O
(	O
channel	O
)	O
;	O
x	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	O
,	O
&	O
ptr	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
ptr	O
!=	O
'\0'	O
)	O
fault	O
(	O
"unable to convert `%s' to integer number"	*(char)
,	O
str	O
)	O
;	O
return	O
x	O
;	O
}	O
void	O
outinteger	O
(	O
int	O
channel	O
,	O
int	O
val	O
)	O
{	O
connect	O
(	O
channel	O
,	O
'w'	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	O
[	O
channel	O
]	O
,	O
"%d "	*(char)
,	O
val	O
)	O
;	O
return	O
;	O
}	O
double	O
inreal	O
(	O
int	O
channel	O
)	O
{	O
double	O
x	O
;	O
char	O
*	O
str	O
,	O
*	O
ptr	O
;	O
str	O
=	O
input_data	O
(	O
channel	O
)	O
;	O
x	O
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
str	O
,	O
&	O
ptr	O
)	O
;	O
if	O
(	O
*	O
ptr	O
!=	O
'\0'	O
)	O
fault	O
(	O
"unable to convert `%s' to real number"	*(char)
,	O
str	O
)	O
;	O
return	O
x	O
;	O
}	O
void	O
outreal	O
(	O
int	O
channel	O
,	O
double	O
val	O
)	O
{	O
connect	O
(	O
channel	O
,	O
'w'	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	O
[	O
channel	O
]	O
,	O
REAL_FMT	O
" "	*(char)
,	O
val	O
)	O
;	O
return	O
;	O
}	O
