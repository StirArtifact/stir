struct	O
hash_control	O
*	O
macro_hash	O
;	O
int	O
macro_defined	O
;	O
static	O
int	O
macro_alternate	O
;	O
static	O
int	O
macro_mri	O
;	O
static	O
int	O
macro_strip_at	O
;	O
static	O
size_t	long
(	O
*	O
macro_expr	O
)	O
(	O
const	O
char	O
*	O
,	O
size_t	long
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
,	O
offsetT	O
*	O
)	O
;	O
static	O
int	O
macro_number	O
;	O
void	O
macro_init	O
(	O
int	O
alternate	O
,	O
int	O
mri	O
,	O
int	O
strip_at	O
,	O
size_t	long
(	O
*	O
exp	O
)	O
(	O
const	O
char	O
*	O
,	O
size_t	long
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
,	O
offsetT	O
*	O
)	O
)	O
{	O
macro_hash	O
=	O
hash_new	O
(	O
)	O
;	O
macro_defined	O
=	O
0	int
;	O
macro_alternate	O
=	O
alternate	O
;	O
macro_mri	O
=	O
mri	O
;	O
macro_strip_at	O
=	O
strip_at	O
;	O
macro_expr	O
=	O
exp	O
;	O
}	O
void	O
macro_set_alternate	O
(	O
int	O
alternate	O
)	O
{	O
macro_alternate	O
=	O
alternate	O
;	O
}	O
void	O
macro_mri_mode	O
(	O
int	O
mri	O
)	O
{	O
macro_mri	O
=	O
mri	O
;	O
}	O
int	O
buffer_and_nest	O
(	O
const	O
char	O
*	O
from	O
,	O
const	O
char	O
*	O
to	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
ptr	*(*(char))
,	O
size_t	long
(	O
*	O
get_line	O
)	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
)	O
)	O
{	O
size_t	long
from_len	O
;	O
size_t	long
to_len	O
=	O
strlen	(*(char))->(long)
(	O
to	O
)	O
;	O
int	O
depth	O
=	O
1	int
;	O
size_t	long
line_start	O
=	O
ptr	*(*(char))
->	O
len	long
;	O
size_t	long
more	O
=	O
get_line	O
(	O
ptr	*(*(char))
)	O
;	O
if	O
(	O
to_len	O
==	O
4	int
&&	O
strcasecmp	(*(char),*(char))->(int)
(	O
to	O
,	O
"ENDR"	*(char)
)	O
==	O
0	int
)	O
{	O
from	O
=	O
NULL	O
;	O
from_len	O
=	O
0	int
;	O
}	O
else	O
from_len	O
=	O
strlen	(*(char))->(long)
(	O
from	O
)	O
;	O
while	O
(	O
more	O
)	O
{	O
size_t	long
i	*(struct)
=	O
line_start	O
;	O
bfd_boolean	int
had_colon	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
LABELS_WITHOUT_COLONS	O
)	O
{	O
while	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
i	*(struct)
++	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
i	*(struct)
>=	O
ptr	*(*(char))
->	O
len	long
||	O
!	O
is_name_beginner	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
break	O
;	O
i	*(struct)
++	O
;	O
while	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
is_part_of_name	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
i	*(struct)
++	O
;	O
if	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
is_name_ender	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
i	*(struct)
++	O
;	O
while	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
i	*(struct)
++	O
;	O
if	O
(	O
i	*(struct)
>=	O
ptr	*(*(char))
->	O
len	long
||	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
!=	O
':'	O
)	O
{	O
if	O
(	O
LABELS_WITHOUT_COLONS	O
&&	O
!	O
had_colon	O
)	O
break	O
;	O
i	*(struct)
=	O
line_start	O
;	O
break	O
;	O
}	O
i	*(struct)
++	O
;	O
line_start	O
=	O
i	*(struct)
;	O
had_colon	O
=	O
TRUE	int
;	O
}	O
while	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
)	O
)	O
i	*(struct)
++	O
;	O
if	O
(	O
i	*(struct)
<	O
ptr	*(*(char))
->	O
len	long
&&	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
==	O
'.'	O
||	O
NO_PSEUDO_DOT	O
||	O
macro_mri	O
)	O
)	O
{	O
if	O
(	O
!	O
flag_m68k_mri	O
&&	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
]	O
==	O
'.'	O
)	O
i	*(struct)
++	O
;	O
if	O
(	O
from	O
==	O
NULL	O
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"IRPC"	*(char)
,	O
from_len	O
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"IRP"	*(char)
,	O
from_len	O
=	O
3	int
)	O
!=	O
0	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"IREPC"	*(char)
,	O
from_len	O
=	O
5	int
)	O
!=	O
0	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"IREP"	*(char)
,	O
from_len	O
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"REPT"	*(char)
,	O
from_len	O
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"REP"	*(char)
,	O
from_len	O
=	O
3	int
)	O
!=	O
0	int
)	O
from_len	O
=	O
0	int
;	O
if	O
(	O
(	O
from	O
!=	O
NULL	O
?	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
from	O
,	O
from_len	O
)	O
==	O
0	int
:	O
from_len	O
>	O
0	int
)	O
&&	O
(	O
ptr	*(*(char))
->	O
len	long
==	O
(	O
i	*(struct)
+	O
from_len	O
)	O
||	O
!	O
(	O
is_part_of_name	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
+	O
from_len	O
]	O
)	O
||	O
is_name_ender	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
+	O
from_len	O
]	O
)	O
)	O
)	O
)	O
depth	O
++	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
to	O
,	O
to_len	O
)	O
==	O
0	int
&&	O
(	O
ptr	*(*(char))
->	O
len	long
==	O
(	O
i	*(struct)
+	O
to_len	O
)	O
||	O
!	O
(	O
is_part_of_name	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
+	O
to_len	O
]	O
)	O
||	O
is_name_ender	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
i	*(struct)
+	O
to_len	O
]	O
)	O
)	O
)	O
)	O
{	O
depth	O
--	O
;	O
if	O
(	O
depth	O
==	O
0	int
)	O
{	O
ptr	*(*(char))
->	O
len	long
=	O
line_start	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
,	O
"linefile"	*(char)
,	O
8	int
)	O
==	O
0	int
)	O
{	O
char	O
saved_eol_char	O
=	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
ptr	*(*(char))
->	O
len	long
]	O
;	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
ptr	*(*(char))
->	O
len	long
]	O
=	O
'\0'	O
;	O
temp_ilp	O
(	O
ptr	*(*(char))
->	O
ptr	*(*(char))
+	O
i	*(struct)
+	O
8	int
)	O
;	O
s_app_line	O
(	O
0	int
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
ptr	*(*(char))
->	O
ptr	*(*(char))
[	O
ptr	*(*(char))
->	O
len	long
]	O
=	O
saved_eol_char	O
;	O
ptr	*(*(char))
->	O
len	long
=	O
line_start	O
;	O
}	O
}	O
sb_add_char	O
(	O
ptr	*(*(char))
,	O
more	O
)	O
;	O
line_start	O
=	O
ptr	*(*(char))
->	O
len	long
;	O
more	O
=	O
get_line	O
(	O
ptr	*(*(char))
)	O
;	O
}	O
return	O
depth	O
==	O
0	int
;	O
}	O
static	O
size_t	long
get_token	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
name	*(char)
)	O
{	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
is_name_beginner	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
{	O
sb_add_char	O
(	O
name	*(char)
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
is_part_of_name	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
{	O
sb_add_char	O
(	O
name	*(char)
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
}	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
is_name_ender	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
{	O
sb_add_char	O
(	O
name	*(char)
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
macro_alternate	O
&&	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'&'	O
)	O
idx	O
++	O
;	O
return	O
idx	O
;	O
}	O
static	O
size_t	long
getstring	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
acc	O
)	O
{	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'"'	O
||	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'<'	O
&&	O
(	O
macro_alternate	O
||	O
macro_mri	O
)	O
)	O
||	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'\''	O
&&	O
macro_alternate	O
)	O
)	O
)	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'<'	O
)	O
{	O
int	O
nest	O
=	O
0	int
;	O
idx	O
++	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'>'	O
||	O
nest	O
)	O
)	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'!'	O
)	O
{	O
idx	O
++	O
;	O
sb_add_char	O
(	O
acc	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'>'	O
)	O
nest	O
--	O
;	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'<'	O
)	O
nest	O
++	O
;	O
sb_add_char	O
(	O
acc	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
}	O
}	O
idx	O
++	O
;	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'"'	O
||	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'\''	O
)	O
{	O
char	O
tchar	O
=	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
;	O
int	O
escaped	O
=	O
0	int
;	O
idx	O
++	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
)	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
escaped	O
^=	O
1	int
;	O
else	O
escaped	O
=	O
0	int
;	O
if	O
(	O
macro_alternate	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'!'	O
)	O
{	O
idx	O
++	O
;	O
sb_add_char	O
(	O
acc	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
;	O
idx	O
++	O
;	O
}	O
else	O
if	O
(	O
escaped	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
tchar	O
)	O
{	O
sb_add_char	O
(	O
acc	O
,	O
tchar	O
)	O
;	O
idx	O
++	O
;	O
}	O
else	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
tchar	O
)	O
{	O
idx	O
++	O
;	O
if	O
(	O
idx	O
>=	O
in	O
->	O
len	long
||	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
tchar	O
)	O
break	O
;	O
}	O
sb_add_char	O
(	O
acc	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
;	O
idx	O
++	O
;	O
}	O
}	O
}	O
}	O
return	O
idx	O
;	O
}	O
static	O
size_t	long
get_any_string	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
out	O
)	O
{	O
sb_reset	O
(	O
out	O
)	O
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
)	O
{	O
if	O
(	O
in	O
->	O
len	long
>	O
idx	O
+	O
2	int
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
+	O
1	int
]	O
==	O
'\''	O
&&	O
ISBASE	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
{	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
!	O
ISSEP	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'%'	O
&&	O
macro_alternate	O
)	O
{	O
offsetT	O
val	int
;	O
char	O
buf	*(void)
[	O
64	int
]	O
;	O
idx	O
=	O
(	O
*	O
macro_expr	O
)	O
(	O
_	O
(	O
"% operator needs absolute expression"	*(char)
)	O
,	O
idx	O
+	O
1	int
,	O
in	O
,	O
&	O
val	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%"	*(char)
BFD_VMA_FMT	O
"d"	*(char)
,	O
val	int
)	O
;	O
sb_add_string	O
(	O
out	O
,	O
buf	*(void)
)	O
;	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'"'	O
||	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'<'	O
&&	O
(	O
macro_alternate	O
||	O
macro_mri	O
)	O
)	O
||	O
(	O
macro_alternate	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'\''	O
)	O
)	O
{	O
if	O
(	O
macro_alternate	O
&&	O
!	O
macro_strip_at	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'<'	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
'"'	O
)	O
;	O
idx	O
=	O
getstring	O
(	O
idx	O
,	O
in	O
,	O
out	O
)	O
;	O
sb_add_char	O
(	O
out	O
,	O
'"'	O
)	O
;	O
}	O
else	O
{	O
idx	O
=	O
getstring	O
(	O
idx	O
,	O
in	O
,	O
out	O
)	O
;	O
}	O
}	O
else	O
{	O
char	O
*	O
br_buf	O
=	O
XNEWVEC	O
(	O
char	O
,	O
1	int
)	O
;	O
char	O
*	O
in_br	O
=	O
br_buf	O
;	O
*	O
in_br	O
=	O
'\0'	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
(	O
*	O
in_br	O
||	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
' '	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'\t'	O
)	O
)	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
','	O
&&	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'<'	O
||	O
(	O
!	O
macro_alternate	O
&&	O
!	O
macro_mri	O
)	O
)	O
)	O
{	O
char	O
tchar	O
=	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
;	O
switch	O
(	O
tchar	O
)	O
{	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
tchar	O
)	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
++	O
]	O
)	O
;	O
if	O
(	O
idx	O
==	O
in	O
->	O
len	long
)	O
{	O
free	(*(void))->(void)
(	O
br_buf	O
)	O
;	O
return	O
idx	O
;	O
}	O
break	O
;	O
case	O
'('	O
:	O
case	O
'['	O
:	O
if	O
(	O
in_br	O
>	O
br_buf	O
)	O
--	O
in_br	O
;	O
else	O
{	O
br_buf	O
=	O
XNEWVEC	O
(	O
char	O
,	O
strlen	(*(char))->(long)
(	O
in_br	O
)	O
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
br_buf	O
+	O
1	int
,	O
in_br	O
)	O
;	O
free	(*(void))->(void)
(	O
in_br	O
)	O
;	O
in_br	O
=	O
br_buf	O
;	O
}	O
*	O
in_br	O
=	O
tchar	O
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
*	O
in_br	O
==	O
'('	O
)	O
++	O
in_br	O
;	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
*	O
in_br	O
==	O
'['	O
)	O
++	O
in_br	O
;	O
break	O
;	O
}	O
sb_add_char	O
(	O
out	O
,	O
tchar	O
)	O
;	O
++	O
idx	O
;	O
}	O
free	(*(void))->(void)
(	O
br_buf	O
)	O
;	O
}	O
}	O
return	O
idx	O
;	O
}	O
static	O
formal_entry	O
*	O
new_formal	O
(	O
void	O
)	O
{	O
formal_entry	O
*	O
formal	O
;	O
formal	O
=	O
XNEW	O
(	O
formal_entry	O
)	O
;	O
sb_new	O
(	O
&	O
formal	O
->	O
name	*(char)
)	O
;	O
sb_new	O
(	O
&	O
formal	O
->	O
def	O
)	O
;	O
sb_new	O
(	O
&	O
formal	O
->	O
actual	O
)	O
;	O
formal	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
NULL	O
;	O
formal	O
->	O
type	char
=	O
FORMAL_OPTIONAL	O
;	O
return	O
formal	O
;	O
}	O
static	O
void	O
del_formal	O
(	O
formal_entry	O
*	O
formal	O
)	O
{	O
sb_kill	O
(	O
&	O
formal	O
->	O
actual	O
)	O
;	O
sb_kill	O
(	O
&	O
formal	O
->	O
def	O
)	O
;	O
sb_kill	O
(	O
&	O
formal	O
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
formal	O
)	O
;	O
}	O
static	O
size_t	long
do_formals	O
(	O
macro_entry	O
*	O
macro	O
,	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
)	O
{	O
formal_entry	O
*	O
*	O
p	*(void)
=	O
&	O
macro	O
->	O
formals	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
)	O
{	O
formal_entry	O
*	O
formal	O
=	O
new_formal	O
(	O
)	O
;	O
size_t	long
cidx	O
;	O
idx	O
=	O
get_token	O
(	O
idx	O
,	O
in	O
,	O
&	O
formal	O
->	O
name	*(char)
)	O
;	O
if	O
(	O
formal	O
->	O
name	*(char)
.	O
len	long
==	O
0	int
)	O
{	O
if	O
(	O
macro	O
->	O
formal_count	O
)	O
--	O
idx	O
;	O
del_formal	O
(	O
formal	O
)	O
;	O
break	O
;	O
}	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
name	*(char)
=	O
sb_terminate	O
(	O
&	O
formal	O
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
macro_mri	O
&&	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
':'	O
&&	O
(	O
!	O
is_name_beginner	O
(	O
':'	O
)	O
||	O
idx	O
+	O
1	int
>=	O
in	O
->	O
len	long
||	O
!	O
is_part_of_name	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
+	O
1	int
]	O
)	O
)	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
qual	O
;	O
sb_new	O
(	O
&	O
qual	O
)	O
;	O
idx	O
=	O
get_token	O
(	O
sb_skip_white	O
(	O
idx	O
+	O
1	int
,	O
in	O
)	O
,	O
in	O
,	O
&	O
qual	O
)	O
;	O
sb_terminate	O
(	O
&	O
qual	O
)	O
;	O
if	O
(	O
qual	O
.	O
len	long
==	O
0	int
)	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
,	O
_	O
(	O
"Missing parameter qualifier for `%s' in macro `%s'"	*(char)
)	O
,	O
name	*(char)
,	O
macro	O
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
qual	O
.	O
ptr	*(*(char))
,	O
"req"	*(char)
)	O
==	O
0	int
)	O
formal	O
->	O
type	char
=	O
FORMAL_REQUIRED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
qual	O
.	O
ptr	*(*(char))
,	O
"vararg"	*(char)
)	O
==	O
0	int
)	O
formal	O
->	O
type	char
=	O
FORMAL_VARARG	O
;	O
else	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
,	O
_	O
(	O
"`%s' is not a valid parameter qualifier for `%s' in macro `%s'"	*(char)
)	O
,	O
qual	O
.	O
ptr	*(*(char))
,	O
name	*(char)
,	O
macro	O
->	O
name	*(char)
)	O
;	O
sb_kill	O
(	O
&	O
qual	O
)	O
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
}	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'='	O
)	O
{	O
idx	O
=	O
get_any_string	O
(	O
idx	O
+	O
1	int
,	O
in	O
,	O
&	O
formal	O
->	O
def	O
)	O
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
if	O
(	O
formal	O
->	O
type	char
==	O
FORMAL_REQUIRED	O
)	O
{	O
sb_reset	O
(	O
&	O
formal	O
->	O
def	O
)	O
;	O
as_warn_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
,	O
_	O
(	O
"Pointless default value for required parameter `%s' in macro `%s'"	*(char)
)	O
,	O
name	*(char)
,	O
macro	O
->	O
name	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
hash_find	O
(	O
macro	O
->	O
formal_hash	O
,	O
name	*(char)
)	O
)	O
hash_jam	O
(	O
macro	O
->	O
formal_hash	O
,	O
name	*(char)
,	O
formal	O
)	O
;	O
else	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
,	O
_	O
(	O
"A parameter named `%s' already exists for macro `%s'"	*(char)
)	O
,	O
name	*(char)
,	O
macro	O
->	O
name	*(char)
)	O
;	O
formal	O
->	O
index	(*(char),int)->(*(char))
=	O
macro	O
->	O
formal_count	O
++	O
;	O
*	O
p	*(void)
=	O
formal	O
;	O
p	*(void)
=	O
&	O
formal	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
if	O
(	O
formal	O
->	O
type	char
==	O
FORMAL_VARARG	O
)	O
break	O
;	O
cidx	O
=	O
idx	O
;	O
idx	O
=	O
sb_skip_comma	O
(	O
idx	O
,	O
in	O
)	O
;	O
if	O
(	O
idx	O
!=	O
cidx	O
&&	O
idx	O
>=	O
in	O
->	O
len	long
)	O
{	O
idx	O
=	O
cidx	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
macro_mri	O
)	O
{	O
formal_entry	O
*	O
formal	O
=	O
new_formal	O
(	O
)	O
;	O
if	O
(	O
macro_strip_at	O
)	O
name	*(char)
=	O
"$NARG"	*(char)
;	O
else	O
name	*(char)
=	O
"NARG"	*(char)
;	O
sb_add_string	O
(	O
&	O
formal	O
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
hash_find	O
(	O
macro	O
->	O
formal_hash	O
,	O
name	*(char)
)	O
)	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
,	O
_	O
(	O
"Reserved word `%s' used as parameter in macro `%s'"	*(char)
)	O
,	O
name	*(char)
,	O
macro	O
->	O
name	*(char)
)	O
;	O
hash_jam	O
(	O
macro	O
->	O
formal_hash	O
,	O
name	*(char)
,	O
formal	O
)	O
;	O
formal	O
->	O
index	(*(char),int)->(*(char))
=	O
NARG_INDEX	O
;	O
*	O
p	*(void)
=	O
formal	O
;	O
}	O
return	O
idx	O
;	O
}	O
static	O
void	O
free_macro	O
(	O
macro_entry	O
*	O
macro	O
)	O
{	O
formal_entry	O
*	O
formal	O
;	O
for	O
(	O
formal	O
=	O
macro	O
->	O
formals	O
;	O
formal	O
;	O
)	O
{	O
formal_entry	O
*	O
f	O
;	O
f	O
=	O
formal	O
;	O
formal	O
=	O
formal	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
del_formal	O
(	O
f	O
)	O
;	O
}	O
hash_die	O
(	O
macro	O
->	O
formal_hash	O
)	O
;	O
sb_kill	O
(	O
&	O
macro	O
->	O
sub	O
)	O
;	O
free	(*(void))->(void)
(	O
macro	O
)	O
;	O
}	O
const	O
char	O
*	O
define_macro	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
label	O
,	O
size_t	long
(	O
*	O
get_line	O
)	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
)	O
,	O
const	O
char	O
*	O
file	*(void)
,	O
unsigned	O
int	O
line	O
,	O
const	O
char	O
*	O
*	O
namep	O
)	O
{	O
macro_entry	O
*	O
macro	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
name	*(char)
;	O
const	O
char	O
*	O
error	O
=	O
NULL	O
;	O
macro	O
=	O
XNEW	O
(	O
macro_entry	O
)	O
;	O
sb_new	O
(	O
&	O
macro	O
->	O
sub	O
)	O
;	O
sb_new	O
(	O
&	O
name	*(char)
)	O
;	O
macro	O
->	O
file	*(void)
=	O
file	*(void)
;	O
macro	O
->	O
line	O
=	O
line	O
;	O
macro	O
->	O
formal_count	O
=	O
0	int
;	O
macro	O
->	O
formals	O
=	O
0	int
;	O
macro	O
->	O
formal_hash	O
=	O
hash_new_sized	O
(	O
7	int
)	O
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	O
(	O
"MACRO"	*(char)
,	O
"ENDM"	*(char)
,	O
&	O
macro	O
->	O
sub	O
,	O
get_line	O
)	O
)	O
error	O
=	O
_	O
(	O
"unexpected end of file in macro `%s' definition"	*(char)
)	O
;	O
if	O
(	O
label	O
!=	O
NULL	O
&&	O
label	O
->	O
len	long
!=	O
0	int
)	O
{	O
sb_add_sb	O
(	O
&	O
name	*(char)
,	O
label	O
)	O
;	O
macro	O
->	O
name	*(char)
=	O
sb_terminate	O
(	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'('	O
)	O
{	O
idx	O
=	O
do_formals	O
(	O
macro	O
,	O
idx	O
+	O
1	int
,	O
in	O
)	O
;	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
')'	O
)	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
+	O
1	int
,	O
in	O
)	O
;	O
else	O
if	O
(	O
!	O
error	O
)	O
error	O
=	O
_	O
(	O
"missing `)' after formals in macro definition `%s'"	*(char)
)	O
;	O
}	O
else	O
{	O
idx	O
=	O
do_formals	O
(	O
macro	O
,	O
idx	O
,	O
in	O
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
cidx	O
;	O
idx	O
=	O
get_token	O
(	O
idx	O
,	O
in	O
,	O
&	O
name	*(char)
)	O
;	O
macro	O
->	O
name	*(char)
=	O
sb_terminate	O
(	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
name	*(char)
.	O
len	long
==	O
0	int
)	O
error	O
=	O
_	O
(	O
"Missing macro name"	*(char)
)	O
;	O
cidx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
idx	O
=	O
sb_skip_comma	O
(	O
cidx	O
,	O
in	O
)	O
;	O
if	O
(	O
idx	O
==	O
cidx	O
||	O
idx	O
<	O
in	O
->	O
len	long
)	O
idx	O
=	O
do_formals	O
(	O
macro	O
,	O
idx	O
,	O
in	O
)	O
;	O
else	O
idx	O
=	O
cidx	O
;	O
}	O
if	O
(	O
!	O
error	O
&&	O
idx	O
<	O
in	O
->	O
len	long
)	O
error	O
=	O
_	O
(	O
"Bad parameter list for macro `%s'"	*(char)
)	O
;	O
for	O
(	O
idx	O
=	O
0	int
;	O
idx	O
<	O
name	*(char)
.	O
len	long
;	O
idx	O
++	O
)	O
name	*(char)
.	O
ptr	*(*(char))
[	O
idx	O
]	O
=	O
TOLOWER	O
(	O
name	*(char)
.	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
;	O
if	O
(	O
hash_find	O
(	O
macro_hash	O
,	O
macro	O
->	O
name	*(char)
)	O
)	O
error	O
=	O
_	O
(	O
"Macro `%s' was already defined"	*(char)
)	O
;	O
if	O
(	O
!	O
error	O
)	O
error	O
=	O
hash_jam	O
(	O
macro_hash	O
,	O
macro	O
->	O
name	*(char)
,	O
(	O
void	O
*	O
)	O
macro	O
)	O
;	O
if	O
(	O
namep	O
!=	O
NULL	O
)	O
*	O
namep	O
=	O
macro	O
->	O
name	*(char)
;	O
if	O
(	O
!	O
error	O
)	O
macro_defined	O
=	O
1	int
;	O
else	O
free_macro	O
(	O
macro	O
)	O
;	O
return	O
error	O
;	O
}	O
static	O
size_t	long
get_apost_token	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
name	*(char)
,	O
int	O
kind	O
)	O
{	O
idx	O
=	O
get_token	O
(	O
idx	O
,	O
in	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
kind	O
&&	O
(	O
!	O
macro_mri	O
||	O
macro_strip_at	O
)	O
&&	O
(	O
!	O
macro_strip_at	O
||	O
kind	O
==	O
'@'	O
)	O
)	O
idx	O
++	O
;	O
return	O
idx	O
;	O
}	O
static	O
size_t	long
sub_actual	O
(	O
size_t	long
start	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
t	O
,	O
struct	O
hash_control	O
*	O
formal_hash	O
,	O
int	O
kind	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
out	O
,	O
int	O
copyifnotthere	O
)	O
{	O
size_t	long
src	O
;	O
formal_entry	O
*	O
ptr	*(*(char))
;	O
src	O
=	O
get_apost_token	O
(	O
start	O
,	O
in	O
,	O
t	O
,	O
kind	O
)	O
;	O
if	O
(	O
macro_strip_at	O
&&	O
kind	O
==	O
'@'	O
&&	O
(	O
src	O
==	O
start	O
||	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
-	O
1	int
]	O
!=	O
'@'	O
)	O
)	O
ptr	*(*(char))
=	O
NULL	O
;	O
else	O
ptr	*(*(char))
=	O
(	O
formal_entry	O
*	O
)	O
hash_find	O
(	O
formal_hash	O
,	O
sb_terminate	O
(	O
t	O
)	O
)	O
;	O
if	O
(	O
ptr	*(*(char))
)	O
{	O
if	O
(	O
ptr	*(*(char))
->	O
actual	O
.	O
len	long
)	O
{	O
sb_add_sb	O
(	O
out	O
,	O
&	O
ptr	*(*(char))
->	O
actual	O
)	O
;	O
}	O
else	O
{	O
sb_add_sb	O
(	O
out	O
,	O
&	O
ptr	*(*(char))
->	O
def	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
kind	O
==	O
'&'	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
'&'	O
)	O
;	O
sb_add_sb	O
(	O
out	O
,	O
t	O
)	O
;	O
if	O
(	O
src	O
!=	O
start	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
-	O
1	int
]	O
==	O
'&'	O
)	O
sb_add_char	O
(	O
out	O
,	O
'&'	O
)	O
;	O
}	O
else	O
if	O
(	O
copyifnotthere	O
)	O
{	O
sb_add_sb	O
(	O
out	O
,	O
t	O
)	O
;	O
}	O
else	O
{	O
sb_add_char	O
(	O
out	O
,	O
'\\'	O
)	O
;	O
sb_add_sb	O
(	O
out	O
,	O
t	O
)	O
;	O
}	O
return	O
src	O
;	O
}	O
static	O
const	O
char	O
*	O
macro_expand_body	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
out	O
,	O
formal_entry	O
*	O
formals	O
,	O
struct	O
hash_control	O
*	O
formal_hash	O
,	O
const	O
macro_entry	O
*	O
macro	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
t	O
;	O
size_t	long
src	O
=	O
0	int
;	O
int	O
inquote	O
=	O
0	int
,	O
macro_line	O
=	O
0	int
;	O
formal_entry	O
*	O
loclist	O
=	O
NULL	O
;	O
const	O
char	O
*	O
err	O
=	O
NULL	O
;	O
sb_new	O
(	O
&	O
t	O
)	O
;	O
while	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
!	O
err	O
)	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'&'	O
)	O
{	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
if	O
(	O
macro_mri	O
)	O
{	O
if	O
(	O
src	O
+	O
1	int
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
+	O
1	int
]	O
==	O
'&'	O
)	O
src	O
=	O
sub_actual	O
(	O
src	O
+	O
2	int
,	O
in	O
,	O
&	O
t	O
,	O
formal_hash	O
,	O
'\''	O
,	O
out	O
,	O
1	int
)	O
;	O
else	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
++	O
]	O
)	O
;	O
}	O
else	O
{	O
src	O
=	O
sub_actual	O
(	O
src	O
+	O
1	int
,	O
in	O
,	O
&	O
t	O
,	O
formal_hash	O
,	O
'&'	O
,	O
out	O
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'\\'	O
)	O
{	O
src	O
++	O
;	O
if	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'('	O
)	O
{	O
src	O
++	O
;	O
while	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
!=	O
')'	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
++	O
]	O
)	O
;	O
}	O
if	O
(	O
src	O
<	O
in	O
->	O
len	long
)	O
src	O
++	O
;	O
else	O
if	O
(	O
!	O
macro	O
)	O
err	O
=	O
_	O
(	O
"missing `)'"	*(char)
)	O
;	O
else	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
+	O
macro_line	O
,	O
_	O
(	O
"missing `)'"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'@'	O
)	O
{	O
char	O
buffer	O
[	O
12	int
]	O
;	O
src	O
++	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buffer	O
,	O
"%d"	*(char)
,	O
macro_number	O
)	O
;	O
sb_add_string	O
(	O
out	O
,	O
buffer	O
)	O
;	O
}	O
else	O
if	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'&'	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
'\\'	O
)	O
;	O
sb_add_char	O
(	O
out	O
,	O
'&'	O
)	O
;	O
src	O
++	O
;	O
}	O
else	O
if	O
(	O
macro_mri	O
&&	O
src	O
<	O
in	O
->	O
len	long
&&	O
ISALNUM	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
)	O
)	O
{	O
int	O
ind	O
;	O
formal_entry	O
*	O
f	O
;	O
if	O
(	O
ISDIGIT	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
)	O
)	O
ind	O
=	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
-	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
)	O
)	O
ind	O
=	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
-	O
'A'	O
+	O
10	int
;	O
else	O
ind	O
=	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
-	O
'a'	O
+	O
10	int
;	O
++	O
src	O
;	O
for	O
(	O
f	O
=	O
formals	O
;	O
f	O
!=	O
NULL	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
f	O
->	O
index	(*(char),int)->(*(char))
==	O
ind	O
-	O
1	int
)	O
{	O
if	O
(	O
f	O
->	O
actual	O
.	O
len	long
!=	O
0	int
)	O
sb_add_sb	O
(	O
out	O
,	O
&	O
f	O
->	O
actual	O
)	O
;	O
else	O
sb_add_sb	O
(	O
out	O
,	O
&	O
f	O
->	O
def	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
src	O
=	O
sub_actual	O
(	O
src	O
,	O
in	O
,	O
&	O
t	O
,	O
formal_hash	O
,	O
'\''	O
,	O
out	O
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
macro_alternate	O
||	O
macro_mri	O
)	O
&&	O
is_name_beginner	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
)	O
&&	O
(	O
!	O
inquote	O
||	O
!	O
macro_strip_at	O
||	O
(	O
src	O
>	O
0	int
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
-	O
1	int
]	O
==	O
'@'	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
macro	O
||	O
src	O
+	O
5	int
>=	O
in	O
->	O
len	long
||	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
in	O
->	O
ptr	*(*(char))
+	O
src	O
,	O
"LOCAL"	*(char)
,	O
5	int
)	O
!=	O
0	int
||	O
!	O
ISWHITE	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
+	O
5	int
]	O
)	O
||	O
inquote	O
)	O
{	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
src	O
=	O
sub_actual	O
(	O
src	O
,	O
in	O
,	O
&	O
t	O
,	O
formal_hash	O
,	O
(	O
macro_strip_at	O
&&	O
inquote	O
)	O
?	O
'@'	O
:	O
'\''	O
,	O
out	O
,	O
1	int
)	O
;	O
}	O
else	O
{	O
src	O
=	O
sb_skip_white	O
(	O
src	O
+	O
5	int
,	O
in	O
)	O
;	O
while	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
!=	O
'\n'	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
formal_entry	O
*	O
f	O
=	O
new_formal	O
(	O
)	O
;	O
src	O
=	O
get_token	O
(	O
src	O
,	O
in	O
,	O
&	O
f	O
->	O
name	*(char)
)	O
;	O
name	*(char)
=	O
sb_terminate	O
(	O
&	O
f	O
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
hash_find	O
(	O
formal_hash	O
,	O
name	*(char)
)	O
)	O
{	O
static	O
int	O
loccnt	O
;	O
char	O
buf	*(void)
[	O
20	int
]	O
;	O
f	O
->	O
index	(*(char),int)->(*(char))
=	O
LOCAL_INDEX	O
;	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
loclist	O
;	O
loclist	O
=	O
f	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
IS_ELF	O
?	O
".LL%04x"	*(char)
:	O
"LL%04x"	*(char)
,	O
++	O
loccnt	O
)	O
;	O
sb_add_string	O
(	O
&	O
f	O
->	O
actual	O
,	O
buf	*(void)
)	O
;	O
err	O
=	O
hash_jam	O
(	O
formal_hash	O
,	O
name	*(char)
,	O
f	O
)	O
;	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
break	O
;	O
}	O
else	O
{	O
as_bad_where	O
(	O
macro	O
->	O
file	*(void)
,	O
macro	O
->	O
line	O
+	O
macro_line	O
,	O
_	O
(	O
"`%s' was already used as parameter (or another local) name"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
del_formal	O
(	O
f	O
)	O
;	O
}	O
src	O
=	O
sb_skip_comma	O
(	O
src	O
,	O
in	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'"'	O
||	O
(	O
macro_mri	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'\''	O
)	O
)	O
{	O
inquote	O
=	O
!	O
inquote	O
;	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
++	O
]	O
)	O
;	O
}	O
else	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'@'	O
&&	O
macro_strip_at	O
)	O
{	O
++	O
src	O
;	O
if	O
(	O
src	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'@'	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
'@'	O
)	O
;	O
++	O
src	O
;	O
}	O
}	O
else	O
if	O
(	O
macro_mri	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'='	O
&&	O
src	O
+	O
1	int
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
+	O
1	int
]	O
==	O
'='	O
)	O
{	O
formal_entry	O
*	O
ptr	*(*(char))
;	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
src	O
=	O
get_token	O
(	O
src	O
+	O
2	int
,	O
in	O
,	O
&	O
t	O
)	O
;	O
ptr	*(*(char))
=	O
(	O
formal_entry	O
*	O
)	O
hash_find	O
(	O
formal_hash	O
,	O
sb_terminate	O
(	O
&	O
t	O
)	O
)	O
;	O
if	O
(	O
ptr	*(*(char))
==	O
NULL	O
)	O
{	O
sb_add_char	O
(	O
out	O
,	O
'='	O
)	O
;	O
sb_add_char	O
(	O
out	O
,	O
'='	O
)	O
;	O
sb_add_sb	O
(	O
out	O
,	O
&	O
t	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ptr	*(*(char))
->	O
actual	O
.	O
len	long
)	O
{	O
sb_add_string	O
(	O
out	O
,	O
"-1"	*(char)
)	O
;	O
}	O
else	O
{	O
sb_add_char	O
(	O
out	O
,	O
'0'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
]	O
==	O
'\n'	O
)	O
++	O
macro_line	O
;	O
sb_add_char	O
(	O
out	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
src	O
++	O
]	O
)	O
;	O
}	O
}	O
sb_kill	O
(	O
&	O
t	O
)	O
;	O
while	O
(	O
loclist	O
!=	O
NULL	O
)	O
{	O
formal_entry	O
*	O
f	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
f	O
=	O
loclist	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
name	*(char)
=	O
sb_terminate	O
(	O
&	O
loclist	O
->	O
name	*(char)
)	O
;	O
hash_delete	O
(	O
formal_hash	O
,	O
name	*(char)
,	O
f	O
==	O
NULL	O
)	O
;	O
del_formal	O
(	O
loclist	O
)	O
;	O
loclist	O
=	O
f	O
;	O
}	O
return	O
err	O
;	O
}	O
static	O
const	O
char	O
*	O
macro_expand	O
(	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
macro_entry	O
*	O
m	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
out	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
t	O
;	O
formal_entry	O
*	O
ptr	*(*(char))
;	O
formal_entry	O
*	O
f	O
;	O
int	O
is_keyword	O
=	O
0	int
;	O
int	O
narg	O
=	O
0	int
;	O
const	O
char	O
*	O
err	O
=	O
NULL	O
;	O
sb_new	O
(	O
&	O
t	O
)	O
;	O
for	O
(	O
f	O
=	O
m	O
->	O
formals	O
;	O
f	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
sb_reset	O
(	O
&	O
f	O
->	O
actual	O
)	O
;	O
f	O
=	O
m	O
->	O
formals	O
;	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
f	O
->	O
index	(*(char),int)->(*(char))
<	O
0	int
)	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
if	O
(	O
macro_mri	O
)	O
{	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'.'	O
)	O
{	O
idx	O
++	O
;	O
if	O
(	O
idx	O
<	O
in	O
->	O
len	long
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
' '	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'\t'	O
)	O
{	O
formal_entry	O
*	O
n	O
=	O
new_formal	O
(	O
)	O
;	O
n	O
->	O
index	(*(char),int)->(*(char))
=	O
QUAL_INDEX	O
;	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
m	O
->	O
formals	O
;	O
m	O
->	O
formals	O
=	O
n	O
;	O
idx	O
=	O
get_any_string	O
(	O
idx	O
,	O
in	O
,	O
&	O
n	O
->	O
actual	O
)	O
;	O
}	O
}	O
}	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
)	O
{	O
size_t	long
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
;	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
=	O
idx	O
;	O
while	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
<	O
in	O
->	O
len	long
&&	O
!	O
ISSEP	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
]	O
)	O
&&	O
!	O
(	O
macro_mri	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
]	O
==	O
'\''	O
)	O
&&	O
(	O
!	O
macro_alternate	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
]	O
!=	O
'='	O
)	O
)	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
++	O
;	O
if	O
(	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
<	O
in	O
->	O
len	long
&&	O
!	O
macro_alternate	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
scan	*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(char))->(int))
]	O
==	O
'='	O
)	O
{	O
is_keyword	O
=	O
1	int
;	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
idx	O
=	O
get_token	O
(	O
idx	O
,	O
in	O
,	O
&	O
t	O
)	O
;	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
!=	O
'='	O
)	O
{	O
err	O
=	O
_	O
(	O
"confusion in formal parameters"	*(char)
)	O
;	O
break	O
;	O
}	O
ptr	*(*(char))
=	O
(	O
formal_entry	O
*	O
)	O
hash_find	O
(	O
m	O
->	O
formal_hash	O
,	O
sb_terminate	O
(	O
&	O
t	O
)	O
)	O
;	O
if	O
(	O
!	O
ptr	*(*(char))
)	O
{	O
as_bad	O
(	O
_	O
(	O
"Parameter named `%s' does not exist for macro `%s'"	*(char)
)	O
,	O
t	O
.	O
ptr	*(*(char))
,	O
m	O
->	O
name	*(char)
)	O
;	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
idx	O
=	O
get_any_string	O
(	O
idx	O
+	O
1	int
,	O
in	O
,	O
&	O
t	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ptr	*(*(char))
->	O
actual	O
.	O
len	long
)	O
{	O
as_warn	O
(	O
_	O
(	O
"Value for parameter `%s' of macro `%s' was already specified"	*(char)
)	O
,	O
ptr	*(*(char))
->	O
name	*(char)
.	O
ptr	*(*(char))
,	O
m	O
->	O
name	*(char)
)	O
;	O
sb_reset	O
(	O
&	O
ptr	*(*(char))
->	O
actual	O
)	O
;	O
}	O
idx	O
=	O
get_any_string	O
(	O
idx	O
+	O
1	int
,	O
in	O
,	O
&	O
ptr	*(*(char))
->	O
actual	O
)	O
;	O
if	O
(	O
ptr	*(*(char))
->	O
actual	O
.	O
len	long
>	O
0	int
)	O
++	O
narg	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_keyword	O
)	O
{	O
err	O
=	O
_	O
(	O
"can't mix positional and keyword arguments"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
f	O
)	O
{	O
formal_entry	O
*	O
*	O
pf	O
;	O
int	O
c	O
;	O
if	O
(	O
!	O
macro_mri	O
)	O
{	O
err	O
=	O
_	O
(	O
"too many positional arguments"	*(char)
)	O
;	O
break	O
;	O
}	O
f	O
=	O
new_formal	O
(	O
)	O
;	O
c	O
=	O
-	O
1	int
;	O
for	O
(	O
pf	O
=	O
&	O
m	O
->	O
formals	O
;	O
*	O
pf	O
!=	O
NULL	O
;	O
pf	O
=	O
&	O
(	O
*	O
pf	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
(	O
*	O
pf	O
)	O
->	O
index	(*(char),int)->(*(char))
>=	O
c	O
)	O
c	O
=	O
(	O
*	O
pf	O
)	O
->	O
index	(*(char),int)->(*(char))
+	O
1	int
;	O
if	O
(	O
c	O
==	O
-	O
1	int
)	O
c	O
=	O
0	int
;	O
*	O
pf	O
=	O
f	O
;	O
f	O
->	O
index	(*(char),int)->(*(char))
=	O
c	O
;	O
}	O
if	O
(	O
f	O
->	O
type	char
!=	O
FORMAL_VARARG	O
)	O
idx	O
=	O
get_any_string	O
(	O
idx	O
,	O
in	O
,	O
&	O
f	O
->	O
actual	O
)	O
;	O
else	O
{	O
sb_add_buffer	O
(	O
&	O
f	O
->	O
actual	O
,	O
in	O
->	O
ptr	*(*(char))
+	O
idx	O
,	O
in	O
->	O
len	long
-	O
idx	O
)	O
;	O
idx	O
=	O
in	O
->	O
len	long
;	O
}	O
if	O
(	O
f	O
->	O
actual	O
.	O
len	long
>	O
0	int
)	O
++	O
narg	O
;	O
do	O
{	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
while	O
(	O
f	O
!=	O
NULL	O
&&	O
f	O
->	O
index	(*(char),int)->(*(char))
<	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
macro_mri	O
)	O
idx	O
=	O
sb_skip_comma	O
(	O
idx	O
,	O
in	O
)	O
;	O
else	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
','	O
)	O
++	O
idx	O
;	O
if	O
(	O
ISWHITE	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
err	O
)	O
{	O
for	O
(	O
ptr	*(*(char))
=	O
m	O
->	O
formals	O
;	O
ptr	*(*(char))
;	O
ptr	*(*(char))
=	O
ptr	*(*(char))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
ptr	*(*(char))
->	O
type	char
==	O
FORMAL_REQUIRED	O
&&	O
ptr	*(*(char))
->	O
actual	O
.	O
len	long
==	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"Missing value for required parameter `%s' of macro `%s'"	*(char)
)	O
,	O
ptr	*(*(char))
->	O
name	*(char)
.	O
ptr	*(*(char))
,	O
m	O
->	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
macro_mri	O
)	O
{	O
char	O
buffer	O
[	O
20	int
]	O
;	O
sb_reset	O
(	O
&	O
t	O
)	O
;	O
sb_add_string	O
(	O
&	O
t	O
,	O
macro_strip_at	O
?	O
"$NARG"	*(char)
:	O
"NARG"	*(char)
)	O
;	O
ptr	*(*(char))
=	O
(	O
formal_entry	O
*	O
)	O
hash_find	O
(	O
m	O
->	O
formal_hash	O
,	O
sb_terminate	O
(	O
&	O
t	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buffer	O
,	O
"%d"	*(char)
,	O
narg	O
)	O
;	O
sb_add_string	O
(	O
&	O
ptr	*(*(char))
->	O
actual	O
,	O
buffer	O
)	O
;	O
}	O
err	O
=	O
macro_expand_body	O
(	O
&	O
m	O
->	O
sub	O
,	O
out	O
,	O
m	O
->	O
formals	O
,	O
m	O
->	O
formal_hash	O
,	O
m	O
)	O
;	O
}	O
if	O
(	O
macro_mri	O
)	O
{	O
formal_entry	O
*	O
*	O
pf	O
;	O
pf	O
=	O
&	O
m	O
->	O
formals	O
;	O
while	O
(	O
*	O
pf	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
*	O
pf	O
)	O
->	O
name	*(char)
.	O
len	long
!=	O
0	int
)	O
pf	O
=	O
&	O
(	O
*	O
pf	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
else	O
{	O
f	O
=	O
(	O
*	O
pf	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
del_formal	O
(	O
*	O
pf	O
)	O
;	O
*	O
pf	O
=	O
f	O
;	O
}	O
}	O
}	O
sb_kill	O
(	O
&	O
t	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
macro_number	O
++	O
;	O
return	O
err	O
;	O
}	O
int	O
check_macro	O
(	O
const	O
char	O
*	O
line	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
expand	O
,	O
const	O
char	O
*	O
*	O
error	O
,	O
macro_entry	O
*	O
*	O
info	*(void)
)	O
{	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
char	O
*	O
copy	int
,	O
*	O
cls	O
;	O
macro_entry	O
*	O
macro	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
line_sb	O
;	O
if	O
(	O
!	O
is_name_beginner	O
(	O
*	O
line	O
)	O
&&	O
(	O
!	O
macro_mri	O
||	O
*	O
line	O
!=	O
'.'	O
)	O
)	O
return	O
0	int
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
line	O
+	O
1	int
;	O
while	O
(	O
is_part_of_name	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
++	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
is_name_ender	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
++	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
copy	int
=	O
xmemdup0	O
(	O
line	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
line	O
)	O
;	O
for	O
(	O
cls	O
=	O
copy	int
;	O
*	O
cls	O
!=	O
'\0'	O
;	O
cls	O
++	O
)	O
*	O
cls	O
=	O
TOLOWER	O
(	O
*	O
cls	O
)	O
;	O
macro	O
=	O
(	O
macro_entry	O
*	O
)	O
hash_find	O
(	O
macro_hash	O
,	O
copy	int
)	O
;	O
free	(*(void))->(void)
(	O
copy	int
)	O
;	O
if	O
(	O
macro	O
==	O
NULL	O
)	O
return	O
0	int
;	O
sb_new	O
(	O
&	O
line_sb	O
)	O
;	O
while	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
'\0'	O
&&	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
'\n'	O
&&	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
'\r'	O
)	O
sb_add_char	O
(	O
&	O
line_sb	O
,	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
)	O
;	O
sb_new	O
(	O
expand	O
)	O
;	O
*	O
error	O
=	O
macro_expand	O
(	O
0	int
,	O
&	O
line_sb	O
,	O
macro	O
,	O
expand	O
)	O
;	O
sb_kill	O
(	O
&	O
line_sb	O
)	O
;	O
if	O
(	O
info	*(void)
)	O
*	O
info	*(void)
=	O
macro	O
;	O
return	O
1	int
;	O
}	O
void	O
delete_macro	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
copy	int
;	O
size_t	long
i	*(struct)
,	O
len	long
;	O
macro_entry	O
*	O
macro	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
len	long
;	O
++	O
i	*(struct)
)	O
copy	int
[	O
i	*(struct)
]	O
=	O
TOLOWER	O
(	O
name	*(char)
[	O
i	*(struct)
]	O
)	O
;	O
copy	int
[	O
i	*(struct)
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
macro	O
=	O
(	O
macro_entry	O
*	O
)	O
hash_find	O
(	O
macro_hash	O
,	O
copy	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
hash_jam	O
(	O
macro_hash	O
,	O
copy	int
,	O
NULL	O
)	O
;	O
free_macro	O
(	O
macro	O
)	O
;	O
}	O
else	O
as_warn	O
(	O
_	O
(	O
"Attempt to purge non-existing macro `%s'"	*(char)
)	O
,	O
copy	int
)	O
;	O
free	(*(void))->(void)
(	O
copy	int
)	O
;	O
}	O
const	O
char	O
*	O
expand_irp	O
(	O
int	O
irpc	O
,	O
size_t	long
idx	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
in	O
,	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
out	O
,	O
size_t	long
(	O
*	O
get_line	O
)	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
)	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
sub	O
;	O
formal_entry	O
f	O
;	O
struct	O
hash_control	O
*	O
h	O
;	O
const	O
char	O
*	O
err	O
;	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
sb_new	O
(	O
&	O
sub	O
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	O
(	O
NULL	O
,	O
"ENDR"	*(char)
,	O
&	O
sub	O
,	O
get_line	O
)	O
)	O
return	O
_	O
(	O
"unexpected end of file in irp or irpc"	*(char)
)	O
;	O
sb_new	O
(	O
&	O
f	O
.	O
name	*(char)
)	O
;	O
sb_new	O
(	O
&	O
f	O
.	O
def	O
)	O
;	O
sb_new	O
(	O
&	O
f	O
.	O
actual	O
)	O
;	O
idx	O
=	O
get_token	O
(	O
idx	O
,	O
in	O
,	O
&	O
f	O
.	O
name	*(char)
)	O
;	O
if	O
(	O
f	O
.	O
name	*(char)
.	O
len	long
==	O
0	int
)	O
return	O
_	O
(	O
"missing model parameter"	*(char)
)	O
;	O
h	O
=	O
hash_new	O
(	O
)	O
;	O
err	O
=	O
hash_jam	O
(	O
h	O
,	O
sb_terminate	O
(	O
&	O
f	O
.	O
name	*(char)
)	O
,	O
&	O
f	O
)	O
;	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
return	O
err	O
;	O
f	O
.	O
index	(*(char),int)->(*(char))
=	O
1	int
;	O
f	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
NULL	O
;	O
f	O
.	O
type	char
=	O
FORMAL_OPTIONAL	O
;	O
sb_reset	O
(	O
out	O
)	O
;	O
idx	O
=	O
sb_skip_comma	O
(	O
idx	O
,	O
in	O
)	O
;	O
if	O
(	O
idx	O
>=	O
in	O
->	O
len	long
)	O
{	O
err	O
=	O
macro_expand_body	O
(	O
&	O
sub	O
,	O
out	O
,	O
&	O
f	O
,	O
h	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
bfd_boolean	int
in_quotes	O
=	O
FALSE	O
;	O
if	O
(	O
irpc	O
&&	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'"'	O
)	O
{	O
in_quotes	O
=	O
TRUE	int
;	O
++	O
idx	O
;	O
}	O
while	O
(	O
idx	O
<	O
in	O
->	O
len	long
)	O
{	O
if	O
(	O
!	O
irpc	O
)	O
idx	O
=	O
get_any_string	O
(	O
idx	O
,	O
in	O
,	O
&	O
f	O
.	O
actual	O
)	O
;	O
else	O
{	O
if	O
(	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
==	O
'"'	O
)	O
{	O
size_t	long
nxt	O
;	O
if	O
(	O
irpc	O
)	O
in_quotes	O
=	O
!	O
in_quotes	O
;	O
nxt	O
=	O
sb_skip_white	O
(	O
idx	O
+	O
1	int
,	O
in	O
)	O
;	O
if	O
(	O
nxt	O
>=	O
in	O
->	O
len	long
)	O
{	O
idx	O
=	O
nxt	O
;	O
break	O
;	O
}	O
}	O
sb_reset	O
(	O
&	O
f	O
.	O
actual	O
)	O
;	O
sb_add_char	O
(	O
&	O
f	O
.	O
actual	O
,	O
in	O
->	O
ptr	*(*(char))
[	O
idx	O
]	O
)	O
;	O
++	O
idx	O
;	O
}	O
err	O
=	O
macro_expand_body	O
(	O
&	O
sub	O
,	O
out	O
,	O
&	O
f	O
,	O
h	O
,	O
0	int
)	O
;	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
irpc	O
)	O
idx	O
=	O
sb_skip_comma	O
(	O
idx	O
,	O
in	O
)	O
;	O
else	O
if	O
(	O
!	O
in_quotes	O
)	O
idx	O
=	O
sb_skip_white	O
(	O
idx	O
,	O
in	O
)	O
;	O
}	O
}	O
hash_die	O
(	O
h	O
)	O
;	O
sb_kill	O
(	O
&	O
f	O
.	O
actual	O
)	O
;	O
sb_kill	O
(	O
&	O
f	O
.	O
def	O
)	O
;	O
sb_kill	O
(	O
&	O
f	O
.	O
name	*(char)
)	O
;	O
sb_kill	O
(	O
&	O
sub	O
)	O
;	O
return	O
err	O
;	O
}	O
