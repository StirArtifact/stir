static	O
void	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
asn1_node	*(struct)
node	*(struct)
,	O
char	O
*	O
ErrorDescription	*(char)
)	O
{	O
if	O
(	O
ErrorDescription	*(char)
==	O
NULL	O
)	O
return	O
;	O
Estrcpy	O
(	O
ErrorDescription	*(char)
,	O
":: value of element '"	*(char)
)	O
;	O
_asn1_hierarchical_name	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char),int)->(void)
(	O
node	*(struct)
,	O
ErrorDescription	*(char)
+	O
strlen	(*(char))->(long)
(	O
ErrorDescription	*(char)
)	O
,	O
ASN1_MAX_ERROR_DESCRIPTION_SIZE	int
-	O
40	int
)	O
;	O
Estrcat	O
(	O
ErrorDescription	*(char)
,	O
"' not found"	*(char)
)	O
;	O
}	O
void	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
unsigned	O
long	O
int	O
len	int
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
k	int
;	O
unsigned	O
char	O
temp	array(char)
[	O
ASN1_MAX_LENGTH_SIZE	int
]	O
;	O
if	O
(	O
len	int
<	O
128	int
)	O
{	O
if	O
(	O
der	*(char)
!=	O
NULL	O
)	O
der	*(char)
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
len	int
;	O
*	O
der_len	int
=	O
1	int
;	O
}	O
else	O
{	O
k	int
=	O
0	int
;	O
while	O
(	O
len	int
)	O
{	O
temp	array(char)
[	O
k	int
++	O
]	O
=	O
len	int
&	O
0xFF	int
;	O
len	int
=	O
len	int
>>	O
8	int
;	O
}	O
*	O
der_len	int
=	O
k	int
+	O
1	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
)	O
{	O
der	*(char)
[	O
0	int
]	O
=	O
(	O
(	O
unsigned	O
char	O
)	O
k	int
&	O
0x7F	int
)	O
+	O
128	int
;	O
while	O
(	O
k	int
--	O
)	O
der	*(char)
[	O
*	O
der_len	int
-	O
1	int
-	O
k	int
]	O
=	O
temp	array(char)
[	O
k	int
]	O
;	O
}	O
}	O
}	O
static	O
void	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
unsigned	O
char	O
class	int
,	O
unsigned	O
int	O
tag_value	int
,	O
unsigned	O
char	O
ans	array(char)
[	O
ASN1_MAX_TAG_SIZE	int
]	O
,	O
int	O
*	O
ans_len	*(int)
)	O
{	O
int	O
k	int
;	O
unsigned	O
char	O
temp	array(char)
[	O
ASN1_MAX_TAG_SIZE	int
]	O
;	O
if	O
(	O
tag_value	int
<	O
31	int
)	O
{	O
ans	array(char)
[	O
0	int
]	O
=	O
(	O
class	int
&	O
0xE0	int
)	O
+	O
(	O
(	O
unsigned	O
char	O
)	O
(	O
tag_value	int
&	O
0x1F	int
)	O
)	O
;	O
*	O
ans_len	*(int)
=	O
1	int
;	O
}	O
else	O
{	O
ans	array(char)
[	O
0	int
]	O
=	O
(	O
class	int
&	O
0xE0	int
)	O
+	O
31	int
;	O
k	int
=	O
0	int
;	O
while	O
(	O
tag_value	int
!=	O
0	int
)	O
{	O
temp	array(char)
[	O
k	int
++	O
]	O
=	O
tag_value	int
&	O
0x7F	int
;	O
tag_value	int
>>=	O
7	int
;	O
if	O
(	O
k	int
>	O
ASN1_MAX_TAG_SIZE	int
-	O
1	int
)	O
break	O
;	O
}	O
*	O
ans_len	*(int)
=	O
k	int
+	O
1	int
;	O
while	O
(	O
k	int
--	O
)	O
ans	array(char)
[	O
*	O
ans_len	*(int)
-	O
1	int
-	O
k	int
]	O
=	O
temp	array(char)
[	O
k	int
]	O
+	O
128	int
;	O
ans	array(char)
[	O
*	O
ans_len	*(int)
-	O
1	int
]	O
-=	O
128	int
;	O
}	O
}	O
void	O
asn1_octet_der	(*(char),int,*(char),*(int))->(void)
(	O
const	O
unsigned	O
char	O
*	O
str	*(*(char))
,	O
int	O
str_len	*(int)
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
||	O
str_len	*(int)
<	O
0	int
)	O
return	O
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
str_len	*(int)
,	O
der	*(char)
,	O
&	O
len_len	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len_len	int
,	O
str	*(*(char))
,	O
str_len	*(int)
)	O
;	O
*	O
der_len	int
=	O
str_len	*(int)
+	O
len_len	int
;	O
}	O
int	O
asn1_encode_simple_der	(int,*(char),int,*(char),*(int))->(int)
(	O
unsigned	O
int	O
etype	*(int)
,	O
const	O
unsigned	O
char	O
*	O
str	*(*(char))
,	O
unsigned	O
int	O
str_len	*(int)
,	O
unsigned	O
char	O
*	O
tl	*(char)
,	O
unsigned	O
int	O
*	O
tl_len	*(int)
)	O
{	O
int	O
tag_len	int
,	O
len_len	int
;	O
unsigned	O
tlen	int
;	O
unsigned	O
char	O
der_tag	array(char)
[	O
ASN1_MAX_TAG_SIZE	int
]	O
;	O
unsigned	O
char	O
der_length	array(char)
[	O
ASN1_MAX_LENGTH_SIZE	int
]	O
;	O
unsigned	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
str	*(*(char))
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
if	O
(	O
ETYPE_OK	O
(	O
etype	*(int)
)	O
==	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
if	O
(	O
ETYPE_CLASS	O
(	O
etype	*(int)
)	O
!=	O
ASN1_CLASS_UNIVERSAL	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
ETYPE_CLASS	O
(	O
etype	*(int)
)	O
,	O
ETYPE_TAG	O
(	O
etype	*(int)
)	O
,	O
der_tag	array(char)
,	O
&	O
tag_len	int
)	O
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
str_len	*(int)
,	O
der_length	array(char)
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
tag_len	int
<=	O
0	int
||	O
len_len	int
<=	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
tlen	int
=	O
tag_len	int
+	O
len_len	int
;	O
if	O
(	O
*	O
tl_len	*(int)
<	O
tlen	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
p	*(char)
=	O
tl	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
der_tag	array(char)
,	O
tag_len	int
)	O
;	O
p	*(char)
+=	O
tag_len	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
der_length	array(char)
,	O
len_len	int
)	O
;	O
*	O
tl_len	*(int)
=	O
tlen	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_time_der	(*(char),int,*(char),*(int))->(int)
(	O
unsigned	O
char	O
*	O
str	*(*(char))
,	O
int	O
str_len	*(int)
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
;	O
int	O
max_len	int
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
max_len	int
=	O
*	O
der_len	int
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
str_len	*(int)
,	O
(	O
max_len	int
>	O
0	int
)	O
?	O
der	*(char)
:	O
NULL	O
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
(	O
len_len	int
+	O
str_len	*(int)
)	O
<=	O
max_len	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len_len	int
,	O
str	*(*(char))
,	O
str_len	*(int)
)	O
;	O
*	O
der_len	int
=	O
len_len	int
+	O
str_len	*(int)
;	O
if	O
(	O
(	O
*	O
der_len	int
)	O
>	O
max_len	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
void	O
encode_val	(long,*(char),int,*(int))->(void)
(	O
uint64_t	long
val	long
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
max_len	int
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
first	int
,	O
k	int
;	O
unsigned	O
char	O
bit7	char
;	O
first	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
sizeof	O
(	O
val	long
)	O
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
bit7	char
=	O
(	O
val	long
>>	O
(	O
k	int
*	O
7	int
)	O
)	O
&	O
0x7F	int
;	O
if	O
(	O
bit7	char
||	O
first	int
||	O
!	O
k	int
)	O
{	O
if	O
(	O
k	int
)	O
bit7	char
|=	O
0x80	int
;	O
if	O
(	O
max_len	int
>	O
(	O
*	O
der_len	int
)	O
)	O
der	*(char)
[	O
*	O
der_len	int
]	O
=	O
bit7	char
;	O
(	O
*	O
der_len	int
)	O
++	O
;	O
first	int
=	O
1	int
;	O
}	O
}	O
}	O
static	O
int	O
_asn1_object_id_der	(*(char),*(char),*(int))->(int)
(	O
const	O
char	O
*	O
str	*(*(char))
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
,	O
counter	int
,	O
max_len	int
;	O
char	O
*	O
temp	array(char)
,	O
*	O
n_end	*(char)
,	O
*	O
n_start	*(char)
;	O
uint64_t	long
val	long
,	O
val1	long
=	O
0	int
;	O
int	O
str_len	*(int)
=	O
_asn1_strlen	O
(	O
str	*(*(char))
)	O
;	O
max_len	int
=	O
*	O
der_len	int
;	O
*	O
der_len	int
=	O
0	int
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
&&	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
temp	array(char)
=	O
malloc	(long)->(*(void))
(	O
str_len	*(int)
+	O
2	int
)	O
;	O
if	O
(	O
temp	array(char)
==	O
NULL	O
)	O
return	O
ASN1_MEM_ALLOC_ERROR	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
temp	array(char)
,	O
str	*(*(char))
,	O
str_len	*(int)
)	O
;	O
temp	array(char)
[	O
str_len	*(int)
]	O
=	O
'.'	O
;	O
temp	array(char)
[	O
str_len	*(int)
+	O
1	int
]	O
=	O
0	int
;	O
counter	int
=	O
0	int
;	O
n_start	*(char)
=	O
temp	array(char)
;	O
while	O
(	O
(	O
n_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
n_start	*(char)
,	O
'.'	O
)	O
)	O
)	O
{	O
*	O
n_end	*(char)
=	O
0	int
;	O
val	long
=	O
_asn1_strtou64	O
(	O
n_start	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
1	int
)	O
{	O
val1	long
=	O
val	long
;	O
}	O
else	O
if	O
(	O
counter	int
==	O
2	int
)	O
{	O
uint64_t	long
val0	long
;	O
if	O
(	O
val1	long
>	O
2	int
)	O
{	O
free	(*(void))->(void)
(	O
temp	array(char)
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
else	O
if	O
(	O
(	O
val1	long
==	O
0	int
||	O
val1	long
==	O
1	int
)	O
&&	O
val	long
>	O
39	int
)	O
{	O
free	(*(void))->(void)
(	O
temp	array(char)
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
val0	long
=	O
40	int
*	O
val1	long
+	O
val	long
;	O
encode_val	(long,*(char),int,*(int))->(void)
(	O
val0	long
,	O
der	*(char)
,	O
max_len	int
,	O
der_len	int
)	O
;	O
}	O
else	O
{	O
encode_val	(long,*(char),int,*(int))->(void)
(	O
val	long
,	O
der	*(char)
,	O
max_len	int
,	O
der_len	int
)	O
;	O
}	O
n_start	*(char)
=	O
n_end	*(char)
+	O
1	int
;	O
}	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
*	O
der_len	int
,	O
NULL	O
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
max_len	int
>=	O
(	O
*	O
der_len	int
+	O
len_len	int
)	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len_len	int
,	O
der	*(char)
,	O
*	O
der_len	int
)	O
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
*	O
der_len	int
,	O
der	*(char)
,	O
&	O
len_len	int
)	O
;	O
}	O
*	O
der_len	int
+=	O
len_len	int
;	O
free	(*(void))->(void)
(	O
temp	array(char)
)	O
;	O
if	O
(	O
max_len	int
<	O
(	O
*	O
der_len	int
)	O
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_object_id_der	(*(char),*(char),*(int),int)->(int)
(	O
const	O
char	O
*	O
str	*(*(char))
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
,	O
unsigned	O
flags	int
)	O
{	O
unsigned	O
char	O
tag_der	array(char)
[	O
MAX_TAG_LEN	int
]	O
;	O
int	O
tag_len	int
=	O
0	int
,	O
r	int
;	O
int	O
max_len	int
=	O
*	O
der_len	int
;	O
*	O
der_len	int
=	O
0	int
;	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
ETYPE_CLASS	O
(	O
ASN1_ETYPE_OBJECT_ID	int
)	O
,	O
ETYPE_TAG	O
(	O
ASN1_ETYPE_OBJECT_ID	int
)	O
,	O
tag_der	array(char)
,	O
&	O
tag_len	int
)	O
;	O
if	O
(	O
max_len	int
>	O
tag_len	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
,	O
tag_der	array(char)
,	O
tag_len	int
)	O
;	O
}	O
max_len	int
-=	O
tag_len	int
;	O
der	*(char)
+=	O
tag_len	int
;	O
r	int
=	O
_asn1_object_id_der	(*(char),*(char),*(int))->(int)
(	O
str	*(*(char))
,	O
der	*(char)
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
r	int
==	O
ASN1_MEM_ERROR	int
||	O
r	int
==	O
ASN1_SUCCESS	int
)	O
{	O
*	O
der_len	int
=	O
max_len	int
+	O
tag_len	int
;	O
}	O
return	O
r	int
;	O
}	O
static	O
const	O
unsigned	O
char	O
bit_mask	array(char)
[	O
]	O
=	O
{	O
0xFF	int
,	O
0xFE	int
,	O
0xFC	int
,	O
0xF8	int
,	O
0xF0	int
,	O
0xE0	int
,	O
0xC0	int
,	O
0x80	int
}	O
;	O
void	O
asn1_bit_der	(*(char),int,*(char),*(int))->(void)
(	O
const	O
unsigned	O
char	O
*	O
str	*(*(char))
,	O
int	O
bit_len	int
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
,	O
len_byte	int
,	O
len_pad	int
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
)	O
return	O
;	O
len_byte	int
=	O
bit_len	int
>>	O
3	int
;	O
len_pad	int
=	O
8	int
-	O
(	O
bit_len	int
&	O
7	int
)	O
;	O
if	O
(	O
len_pad	int
==	O
8	int
)	O
len_pad	int
=	O
0	int
;	O
else	O
len_byte	int
++	O
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
len_byte	int
+	O
1	int
,	O
der	*(char)
,	O
&	O
len_len	int
)	O
;	O
der	*(char)
[	O
len_len	int
]	O
=	O
len_pad	int
;	O
if	O
(	O
str	*(*(char))
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len_len	int
+	O
1	int
,	O
str	*(*(char))
,	O
len_byte	int
)	O
;	O
der	*(char)
[	O
len_len	int
+	O
len_byte	int
]	O
&=	O
bit_mask	array(char)
[	O
len_pad	int
]	O
;	O
*	O
der_len	int
=	O
len_byte	int
+	O
len_len	int
+	O
1	int
;	O
}	O
static	O
int	O
_asn1_complete_explicit_tag	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char),*(int),*(int))->(int)
(	O
asn1_node	*(struct)
node	*(struct)
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
counter	int
,	O
int	O
*	O
max_len	int
)	O
{	O
asn1_node	*(struct)
p	*(char)
;	O
int	O
is_tag_implicit	int
,	O
len2	int
,	O
len3	int
;	O
unsigned	O
char	O
temp	array(char)
[	O
SIZEOF_UNSIGNED_INT	int
]	O
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
&&	O
*	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
is_tag_implicit	int
=	O
0	int
;	O
if	O
(	O
node	*(struct)
->	O
type	int
&	O
CONST_TAG	O
)	O
{	O
p	*(char)
=	O
node	*(struct)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
while	O
(	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
p	*(char)
&&	O
p	*(char)
!=	O
node	*(struct)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
->	O
left	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
{	O
if	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_EXPLICIT	O
)	O
{	O
len2	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(char)
->	O
name	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
_asn1_set_name	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))
(	O
p	*(char)
,	O
NULL	O
)	O
;	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
*	O
counter	int
-	O
len2	int
,	O
temp	array(char)
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len3	int
<=	O
(	O
*	O
max_len	int
)	O
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
+	O
len3	int
,	O
der	*(char)
+	O
len2	int
,	O
*	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
,	O
temp	array(char)
,	O
len3	int
)	O
;	O
}	O
*	O
max_len	int
-=	O
len3	int
;	O
*	O
counter	int
+=	O
len3	int
;	O
is_tag_implicit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
is_tag_implicit	int
=	O
1	int
;	O
}	O
}	O
}	O
p	*(char)
=	O
p	*(char)
->	O
left	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
}	O
}	O
if	O
(	O
*	O
max_len	int
<	O
0	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
const	O
tag_and_class_st	struct(int,int,*(char))
_asn1_tags	array(struct(int,int,*(char)))
[	O
]	O
=	O
{	O
[	O
ASN1_ETYPE_GENERALSTRING	int
]	O
=	O
{	O
ASN1_TAG_GENERALSTRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:GENERALSTRING"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_NUMERIC_STRING	int
]	O
=	O
{	O
ASN1_TAG_NUMERIC_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:NUMERIC_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_IA5_STRING	int
]	O
=	O
{	O
ASN1_TAG_IA5_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:IA5_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_TELETEX_STRING	int
]	O
=	O
{	O
ASN1_TAG_TELETEX_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:TELETEX_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_PRINTABLE_STRING	int
]	O
=	O
{	O
ASN1_TAG_PRINTABLE_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:PRINTABLE_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_UNIVERSAL_STRING	int
]	O
=	O
{	O
ASN1_TAG_UNIVERSAL_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UNIVERSAL_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_BMP_STRING	int
]	O
=	O
{	O
ASN1_TAG_BMP_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BMP_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_UTF8_STRING	int
]	O
=	O
{	O
ASN1_TAG_UTF8_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UTF8_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_VISIBLE_STRING	int
]	O
=	O
{	O
ASN1_TAG_VISIBLE_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:VISIBLE_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_OCTET_STRING	int
]	O
=	O
{	O
ASN1_TAG_OCTET_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:OCT_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_BIT_STRING	int
]	O
=	O
{	O
ASN1_TAG_BIT_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BIT_STR"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_OBJECT_ID	int
]	O
=	O
{	O
ASN1_TAG_OBJECT_ID	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:OBJ_ID"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_NULL	int
]	O
=	O
{	O
ASN1_TAG_NULL	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:NULL"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_BOOLEAN	int
]	O
=	O
{	O
ASN1_TAG_BOOLEAN	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BOOLEAN"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_INTEGER	int
]	O
=	O
{	O
ASN1_TAG_INTEGER	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:INTEGER"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_ENUMERATED	int
]	O
=	O
{	O
ASN1_TAG_ENUMERATED	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:ENUMERATED"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_SEQUENCE	int
]	O
=	O
{	O
ASN1_TAG_SEQUENCE	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SEQUENCE"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_SEQUENCE_OF	int
]	O
=	O
{	O
ASN1_TAG_SEQUENCE	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SEQ_OF"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_SET	int
]	O
=	O
{	O
ASN1_TAG_SET	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SET"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_SET_OF	int
]	O
=	O
{	O
ASN1_TAG_SET	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SET_OF"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_GENERALIZED_TIME	int
]	O
=	O
{	O
ASN1_TAG_GENERALIZEDTime	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:GENERALIZED_TIME"	*(char)
}	O
,	O
[	O
ASN1_ETYPE_UTC_TIME	int
]	O
=	O
{	O
ASN1_TAG_UTCTime	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UTC_TIME"	*(char)
}	O
,	O
}	O
;	O
unsigned	O
int	O
_asn1_tags_size	int
=	O
sizeof	O
(	O
_asn1_tags	array(struct(int,int,*(char)))
)	O
/	O
sizeof	O
(	O
_asn1_tags	array(struct(int,int,*(char)))
[	O
0	int
]	O
)	O
;	O
static	O
int	O
_asn1_insert_tag_der	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char),*(int),*(int))->(int)
(	O
asn1_node	*(struct)
node	*(struct)
,	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
*	O
counter	int
,	O
int	O
*	O
max_len	int
)	O
{	O
asn1_node	*(struct)
p	*(char)
;	O
int	O
tag_len	int
,	O
is_tag_implicit	int
;	O
unsigned	O
char	O
class	int
,	O
class_implicit	char
=	O
0	int
,	O
temp	array(char)
[	O
MAX	O
(	O
SIZEOF_UNSIGNED_INT	int
*	O
3	int
+	O
1	int
,	O
LTOSTR_MAX_SIZE	int
)	O
]	O
;	O
unsigned	O
long	O
tag_implicit	long
=	O
0	int
;	O
unsigned	O
char	O
tag_der	array(char)
[	O
MAX_TAG_LEN	int
]	O
;	O
is_tag_implicit	int
=	O
0	int
;	O
if	O
(	O
node	*(struct)
->	O
type	int
&	O
CONST_TAG	O
)	O
{	O
p	*(char)
=	O
node	*(struct)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
p	*(char)
)	O
{	O
if	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_APPLICATION	O
)	O
class	int
=	O
ASN1_CLASS_APPLICATION	int
;	O
else	O
if	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_UNIVERSAL	O
)	O
class	int
=	O
ASN1_CLASS_UNIVERSAL	int
;	O
else	O
if	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_PRIVATE	O
)	O
class	int
=	O
ASN1_CLASS_PRIVATE	int
;	O
else	O
class	int
=	O
ASN1_CLASS_CONTEXT_SPECIFIC	int
;	O
if	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_EXPLICIT	O
)	O
{	O
if	O
(	O
is_tag_implicit	int
)	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
class_implicit	char
,	O
tag_implicit	long
,	O
tag_der	array(char)
,	O
&	O
tag_len	int
)	O
;	O
else	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
class	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
_asn1_strtoul	O
(	O
p	*(char)
->	O
value	*(void)
,	O
NULL	O
,	O
10	int
)	O
,	O
tag_der	array(char)
,	O
&	O
tag_len	int
)	O
;	O
*	O
max_len	int
-=	O
tag_len	int
;	O
if	O
(	O
der	*(char)
&&	O
*	O
max_len	int
>=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
*	O
counter	int
,	O
tag_der	array(char)
,	O
tag_len	int
)	O
;	O
*	O
counter	int
+=	O
tag_len	int
;	O
_asn1_ltostr	(long,array(char))->(*(char))
(	O
*	O
counter	int
,	O
(	O
char	O
*	O
)	O
temp	array(char)
)	O
;	O
_asn1_set_name	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))
(	O
p	*(char)
,	O
(	O
const	O
char	O
*	O
)	O
temp	array(char)
)	O
;	O
is_tag_implicit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
if	O
(	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE_OF	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET_OF	int
)	O
)	O
class	int
|=	O
ASN1_CLASS_STRUCTURED	int
;	O
class_implicit	char
=	O
class	int
;	O
tag_implicit	long
=	O
_asn1_strtoul	O
(	O
p	*(char)
->	O
value	*(void)
,	O
NULL	O
,	O
10	int
)	O
;	O
is_tag_implicit	int
=	O
1	int
;	O
}	O
}	O
}	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
}	O
}	O
if	O
(	O
is_tag_implicit	int
)	O
{	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
class_implicit	char
,	O
tag_implicit	long
,	O
tag_der	array(char)
,	O
&	O
tag_len	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
type	int
=	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
CASE_HANDLED_ETYPES	O
:	O
_asn1_tag_der	(char,int,array(char),*(int))->(void)
(	O
_asn1_tags	array(struct(int,int,*(char)))
[	O
type	int
]	O
.	O
class	int
,	O
_asn1_tags	array(struct(int,int,*(char)))
[	O
type	int
]	O
.	O
tag	*(long)
,	O
tag_der	array(char)
,	O
&	O
tag_len	int
)	O
;	O
break	O
;	O
case	O
ASN1_ETYPE_TAG	int
:	O
case	O
ASN1_ETYPE_CHOICE	int
:	O
case	O
ASN1_ETYPE_ANY	int
:	O
tag_len	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
return	O
ASN1_GENERIC_ERROR	int
;	O
}	O
}	O
*	O
max_len	int
-=	O
tag_len	int
;	O
if	O
(	O
der	*(char)
&&	O
*	O
max_len	int
>=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
*	O
counter	int
,	O
tag_der	array(char)
,	O
tag_len	int
)	O
;	O
*	O
counter	int
+=	O
tag_len	int
;	O
if	O
(	O
*	O
max_len	int
<	O
0	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_ordering_set	(*(char),int,*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(int)
(	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
der_len	int
,	O
asn1_node	*(struct)
node	*(struct)
)	O
{	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
{	O
int	O
end	*(int)
;	O
unsigned	O
long	O
value	*(void)
;	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
*	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
,	O
*	O
prev	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
}	O
;	O
int	O
counter	int
,	O
len	int
,	O
len2	int
;	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
*	O
first	int
,	O
*	O
last	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
,	O
*	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
,	O
*	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
asn1_node	*(struct)
p	*(char)
;	O
unsigned	O
char	O
class	int
,	O
*	O
temp	array(char)
;	O
unsigned	O
long	O
tag	*(long)
,	O
t	long
;	O
int	O
err	long
;	O
counter	int
=	O
0	int
;	O
if	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
!=	O
ASN1_ETYPE_SET	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	*(char)
=	O
node	*(struct)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
p	*(char)
&&	O
(	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
)	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
(	O
p	*(char)
==	O
NULL	O
)	O
||	O
(	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
==	O
NULL	O
)	O
)	O
return	O
ASN1_SUCCESS	int
;	O
first	int
=	O
last	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
while	O
(	O
p	*(char)
)	O
{	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
)	O
)	O
;	O
if	O
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
NULL	O
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
prev	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
last	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
if	O
(	O
first	int
==	O
NULL	O
)	O
first	int
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
else	O
last	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
last	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
err	long
=	O
asn1_get_tag_der	(*(char),int,*(char),*(int),*(long))->(int)
(	O
der	*(char)
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	*(long)
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
t	long
=	O
(	O
(	O
unsigned	O
int	O
)	O
class	int
)	O
<<	O
24	int
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
=	O
t	long
|	O
tag	*(long)
;	O
counter	int
+=	O
len2	int
;	O
len2	int
=	O
asn1_get_length_der	(*(char),int,*(int))->(long)
(	O
der	*(char)
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
len	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
+=	O
len	int
+	O
len2	int
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
=	O
counter	int
;	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
}	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
first	int
;	O
while	O
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
)	O
{	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
counter	int
=	O
0	int
;	O
while	O
(	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
>	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
)	O
{	O
temp	array(char)
=	O
malloc	(long)->(*(void))
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
counter	int
)	O
;	O
if	O
(	O
temp	array(char)
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
temp	array(char)
,	O
der	*(char)
+	O
counter	int
,	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
counter	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
counter	int
,	O
der	*(char)
+	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
,	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
counter	int
+	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
,	O
temp	array(char)
,	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
counter	int
)	O
;	O
free	(*(void))->(void)
(	O
temp	array(char)
)	O
;	O
tag	*(long)
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
=	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
;	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
value	*(void)
=	O
tag	*(long)
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
=	O
counter	int
+	O
(	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
-	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
)	O
;	O
}	O
counter	int
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
end	*(int)
;	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
p2_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
}	O
if	O
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
!=	O
first	int
)	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
prev	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
NULL	O
;	O
else	O
first	int
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
)	O
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
first	int
;	O
}	O
return	O
ASN1_SUCCESS	int
;	O
error	int
:	O
while	O
(	O
first	int
!=	O
NULL	O
)	O
{	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
first	int
;	O
first	int
=	O
first	int
->	O
next	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
)	O
;	O
}	O
return	O
err	long
;	O
}	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
{	O
unsigned	O
char	O
*	O
ptr	*(void)
;	O
int	O
size	long
;	O
}	O
;	O
static	O
int	O
setof_compar	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
_e1	*(void)
,	O
const	O
void	O
*	O
_e2	*(void)
)	O
{	O
unsigned	O
length	int
;	O
const	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
*	O
e1	*(struct(*(char),int))
=	O
_e1	*(void)
,	O
*	O
e2	*(struct(*(char),int))
=	O
_e2	*(void)
;	O
int	O
rval	int
;	O
length	int
=	O
MIN	O
(	O
e1	*(struct(*(char),int))
->	O
size	long
,	O
e2	*(struct(*(char),int))
->	O
size	long
)	O
;	O
rval	int
=	O
memcmp	(*(void),*(void),long)->(int)
(	O
e1	*(struct(*(char),int))
->	O
ptr	*(void)
,	O
e2	*(struct(*(char),int))
->	O
ptr	*(void)
,	O
length	int
)	O
;	O
if	O
(	O
rval	int
==	O
0	int
&&	O
e1	*(struct(*(char),int))
->	O
size	long
!=	O
e2	*(struct(*(char),int))
->	O
size	long
)	O
{	O
if	O
(	O
e1	*(struct(*(char),int))
->	O
size	long
>	O
e2	*(struct(*(char),int))
->	O
size	long
)	O
rval	int
=	O
1	int
;	O
else	O
if	O
(	O
e2	*(struct(*(char),int))
->	O
size	long
>	O
e1	*(struct(*(char),int))
->	O
size	long
)	O
rval	int
=	O
-	O
1	int
;	O
}	O
return	O
rval	int
;	O
}	O
static	O
int	O
_asn1_ordering_set_of	(*(char),int,*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(int)
(	O
unsigned	O
char	O
*	O
der	*(char)
,	O
int	O
der_len	int
,	O
asn1_node	*(struct)
node	*(struct)
)	O
{	O
int	O
counter	int
,	O
len	int
,	O
len2	int
;	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
*	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
NULL	O
,	O
*	O
tlist	*(struct(*(char),int))
;	O
unsigned	O
list_size	int
=	O
0	int
;	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
*	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
;	O
asn1_node	*(struct)
p	*(char)
;	O
unsigned	O
char	O
class	int
;	O
unsigned	O
i	int
;	O
unsigned	O
char	O
*	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
int	O
err	long
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
counter	int
=	O
0	int
;	O
if	O
(	O
type_field	(int)->(int)
(	O
node	*(struct)
->	O
type	int
)	O
!=	O
ASN1_ETYPE_SET_OF	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	*(char)
=	O
node	*(struct)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
p	*(char)
&&	O
(	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
)	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
(	O
p	*(char)
==	O
NULL	O
)	O
||	O
(	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
==	O
NULL	O
)	O
)	O
return	O
ASN1_SUCCESS	int
;	O
while	O
(	O
p	*(char)
)	O
{	O
list_size	int
++	O
;	O
tlist	*(struct(*(char),int))
=	O
realloc	(*(void),long)->(*(void))
(	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
,	O
list_size	int
*	O
sizeof	O
(	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
)	O
)	O
;	O
if	O
(	O
tlist	*(struct(*(char),int))
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
=	O
tlist	*(struct(*(char),int))
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
&	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
[	O
list_size	int
-	O
1	int
]	O
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
ptr	*(void)
=	O
der	*(char)
+	O
counter	int
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
size	long
=	O
0	int
;	O
if	O
(	O
der_len	int
-	O
counter	int
>	O
0	int
)	O
{	O
err	long
=	O
asn1_get_tag_der	(*(char),int,*(char),*(int),*(long))->(int)
(	O
der	*(char)
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
class	int
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
counter	int
+=	O
len	int
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
size	long
+=	O
len	int
;	O
len2	int
=	O
asn1_get_length_der	(*(char),int,*(int))->(long)
(	O
der	*(char)
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
len	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
+=	O
len	int
+	O
len2	int
;	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
size	long
+=	O
len	int
+	O
len2	int
;	O
}	O
else	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
}	O
if	O
(	O
counter	int
>	O
der_len	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
,	O
list_size	int
,	O
sizeof	O
(	O
struct	O
vet	struct(int,long,*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))),*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`))))))
)	O
,	O
setof_compar	(*(void),*(void))->(int)
)	O
;	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
malloc	(long)->(*(void))
(	O
der_len	int
)	O
;	O
if	O
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_size	int
;	O
i	int
++	O
)	O
{	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
=	O
&	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
[	O
i	int
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
+	O
counter	int
,	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
ptr	*(void)
,	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
size	long
)	O
;	O
counter	int
+=	O
p_vet	*(struct(int,long,*(struct(int,long,*(struct`),*(struct`))),*(struct(int,long,*(struct`),*(struct`)))))
->	O
size	long
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
,	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
der_len	int
)	O
;	O
free	(*(void))->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
err	long
=	O
ASN1_SUCCESS	int
;	O
error	int
:	O
free	(*(void))->(void)
(	O
list	*(struct(*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(*(struct`),*(struct`)))))
)	O
;	O
return	O
err	long
;	O
}	O
int	O
asn1_der_coding	(*(struct),*(char),*(void),*(int),*(char))->(int)
(	O
asn1_node_const	*(struct)
element	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
,	O
void	O
*	O
ider	*(void)
,	O
int	O
*	O
len	int
,	O
char	O
*	O
ErrorDescription	*(char)
)	O
{	O
asn1_node	*(struct)
node	*(struct)
,	O
p	*(char)
,	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
unsigned	O
char	O
temp	array(char)
[	O
MAX	O
(	O
LTOSTR_MAX_SIZE	int
,	O
SIZEOF_UNSIGNED_LONG_INT	int
*	O
3	int
+	O
1	int
)	O
]	O
;	O
int	O
counter	int
,	O
counter_old	int
,	O
len2	int
,	O
len3	int
,	O
move	int
,	O
max_len	int
,	O
max_len_old	int
;	O
int	O
err	long
;	O
unsigned	O
char	O
*	O
der	*(char)
=	O
ider	*(void)
;	O
if	O
(	O
ErrorDescription	*(char)
)	O
ErrorDescription	*(char)
[	O
0	int
]	O
=	O
0	int
;	O
node	*(struct)
=	O
asn1_find_node	(*(struct),*(char))->(*(struct))
(	O
element	*(*(struct))
,	O
name	*(char)
)	O
;	O
if	O
(	O
node	*(struct)
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
node	*(struct)
=	O
_asn1_copy_structure3	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))
(	O
node	*(struct)
)	O
;	O
if	O
(	O
node	*(struct)
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
max_len	int
=	O
*	O
len	int
;	O
if	O
(	O
der	*(char)
==	O
NULL	O
&&	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
counter	int
=	O
0	int
;	O
move	int
=	O
DOWN	int
;	O
p	*(char)
=	O
node	*(struct)
;	O
while	O
(	O
1	int
)	O
{	O
counter_old	int
=	O
counter	int
;	O
max_len_old	int
=	O
max_len	int
;	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	*(char)
->	O
start	*(int)
=	O
counter	int
;	O
err	long
=	O
_asn1_insert_tag_der	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char),*(int),*(int))->(int)
(	O
p	*(char)
,	O
der	*(char)
,	O
&	O
counter	int
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
}	O
switch	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
)	O
{	O
case	O
ASN1_ETYPE_NULL	int
:	O
max_len	int
--	O
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
der	*(char)
[	O
counter	int
]	O
=	O
0	int
;	O
counter	int
++	O
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_BOOLEAN	int
:	O
if	O
(	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
2	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
der	*(char)
[	O
counter	int
++	O
]	O
=	O
1	int
;	O
if	O
(	O
p	*(char)
->	O
value	*(void)
[	O
0	int
]	O
==	O
'F'	O
)	O
der	*(char)
[	O
counter	int
++	O
]	O
=	O
0	int
;	O
else	O
der	*(char)
[	O
counter	int
++	O
]	O
=	O
0xFF	int
;	O
}	O
else	O
counter	int
+=	O
2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_INTEGER	int
:	O
case	O
ASN1_ETYPE_ENUMERATED	int
:	O
if	O
(	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	(*(char),int,*(int))->(long)
(	O
p	*(char)
->	O
value	*(void)
,	O
p	*(char)
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
+	O
len3	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
counter	int
,	O
p	*(char)
->	O
value	*(void)
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OBJECT_ID	int
:	O
if	O
(	O
(	O
p	*(char)
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
max_len	int
;	O
err	long
=	O
_asn1_object_id_der	(*(char),*(char),*(int))->(int)
(	O
(	O
char	O
*	O
)	O
p	*(char)
->	O
value	*(void)
,	O
der	*(char)
+	O
counter	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
max_len	int
-=	O
len2	int
;	O
counter	int
+=	O
len2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_GENERALIZED_TIME	int
:	O
case	O
ASN1_ETYPE_UTC_TIME	int
:	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
max_len	int
;	O
err	long
=	O
_asn1_time_der	(*(char),int,*(char),*(int))->(int)
(	O
p	*(char)
->	O
value	*(void)
,	O
p	*(char)
->	O
value_len	int
,	O
der	*(char)
+	O
counter	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
max_len	int
-=	O
len2	int
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OCTET_STRING	int
:	O
case	O
ASN1_ETYPE_GENERALSTRING	int
:	O
case	O
ASN1_ETYPE_NUMERIC_STRING	int
:	O
case	O
ASN1_ETYPE_IA5_STRING	int
:	O
case	O
ASN1_ETYPE_TELETEX_STRING	int
:	O
case	O
ASN1_ETYPE_PRINTABLE_STRING	int
:	O
case	O
ASN1_ETYPE_UNIVERSAL_STRING	int
:	O
case	O
ASN1_ETYPE_BMP_STRING	int
:	O
case	O
ASN1_ETYPE_UTF8_STRING	int
:	O
case	O
ASN1_ETYPE_VISIBLE_STRING	int
:	O
case	O
ASN1_ETYPE_BIT_STRING	int
:	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	(*(char),int,*(int))->(long)
(	O
p	*(char)
->	O
value	*(void)
,	O
p	*(char)
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
+	O
len3	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
counter	int
,	O
p	*(char)
->	O
value	*(void)
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE	int
:	O
case	O
ASN1_ETYPE_SET	int
:	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	*(char)
->	O
tmp_ival	int
=	O
counter	int
;	O
if	O
(	O
p	*(char)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
==	O
NULL	O
)	O
{	O
move	int
=	O
UP	int
;	O
continue	O
;	O
}	O
else	O
{	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
=	O
p	*(char)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
&&	O
(	O
type_field	(int)->(int)
(	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
)	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
=	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
{	O
p	*(char)
=	O
p2	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
move	int
=	O
UP	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
len2	int
=	O
p	*(char)
->	O
tmp_ival	int
;	O
p	*(char)
->	O
tmp_ival	int
=	O
0	int
;	O
if	O
(	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET	int
)	O
&&	O
(	O
max_len	int
>=	O
0	int
)	O
)	O
{	O
err	long
=	O
_asn1_ordering_set	(*(char),int,*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(int)
(	O
der	*(char)
+	O
len2	int
,	O
counter	int
-	O
len2	int
,	O
p	*(char)
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
}	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
counter	int
-	O
len2	int
,	O
temp	array(char)
,	O
&	O
len3	int
)	O
;	O
max_len	int
-=	O
len3	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
+	O
len3	int
,	O
der	*(char)
+	O
len2	int
,	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
,	O
temp	array(char)
,	O
len3	int
)	O
;	O
}	O
counter	int
+=	O
len3	int
;	O
move	int
=	O
RIGHT	int
;	O
}	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE_OF	int
:	O
case	O
ASN1_ETYPE_SET_OF	int
:	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	*(char)
->	O
tmp_ival	int
=	O
counter	int
;	O
p	*(char)
=	O
p	*(char)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
while	O
(	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
if	O
(	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
{	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
else	O
p	*(char)
=	O
_asn1_find_up	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))
(	O
p	*(char)
)	O
;	O
move	int
=	O
UP	int
;	O
}	O
if	O
(	O
move	int
==	O
UP	int
)	O
{	O
len2	int
=	O
p	*(char)
->	O
tmp_ival	int
;	O
p	*(char)
->	O
tmp_ival	int
=	O
0	int
;	O
if	O
(	O
(	O
type_field	(int)->(int)
(	O
p	*(char)
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET_OF	int
)	O
&&	O
(	O
counter	int
-	O
len2	int
>	O
0	int
)	O
&&	O
(	O
max_len	int
>=	O
0	int
)	O
)	O
{	O
err	long
=	O
_asn1_ordering_set_of	(*(char),int,*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(int)
(	O
der	*(char)
+	O
len2	int
,	O
counter	int
-	O
len2	int
,	O
p	*(char)
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
}	O
asn1_length_der	(long,*(char),*(int))->(void)
(	O
counter	int
-	O
len2	int
,	O
temp	array(char)
,	O
&	O
len3	int
)	O
;	O
max_len	int
-=	O
len3	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
+	O
len3	int
,	O
der	*(char)
+	O
len2	int
,	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
len2	int
,	O
temp	array(char)
,	O
len3	int
)	O
;	O
}	O
counter	int
+=	O
len3	int
;	O
move	int
=	O
RIGHT	int
;	O
}	O
break	O
;	O
case	O
ASN1_ETYPE_ANY	int
:	O
if	O
(	O
p	*(char)
->	O
value	*(void)
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char))->(void)
(	O
p	*(char)
,	O
ErrorDescription	*(char)
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	(*(char),int,*(int))->(long)
(	O
p	*(char)
->	O
value	*(void)
,	O
p	*(char)
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
;	O
if	O
(	O
der	*(char)
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
der	*(char)
+	O
counter	int
,	O
p	*(char)
->	O
value	*(void)
+	O
len3	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
default	O
:	O
move	int
=	O
(	O
move	int
==	O
UP	int
)	O
?	O
RIGHT	int
:	O
DOWN	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
move	int
!=	O
DOWN	int
)	O
&&	O
(	O
counter	int
!=	O
counter_old	int
)	O
)	O
{	O
p	*(char)
->	O
end	*(int)
=	O
counter	int
-	O
1	int
;	O
err	long
=	O
_asn1_complete_explicit_tag	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)),*(char),*(int),*(int))->(int)
(	O
p	*(char)
,	O
der	*(char)
,	O
&	O
counter	int
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
}	O
if	O
(	O
p	*(char)
==	O
node	*(struct)
&&	O
move	int
!=	O
DOWN	int
)	O
break	O
;	O
if	O
(	O
move	int
==	O
DOWN	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
p	*(char)
=	O
p	*(char)
->	O
down	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
else	O
move	int
=	O
RIGHT	int
;	O
}	O
if	O
(	O
move	int
==	O
RIGHT	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
)	O
p	*(char)
=	O
p	*(char)
->	O
right	*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),*(struct(array(char),int,int,*(char),int,*(struct`),*(struct`),*(struct`),array(char),int,int,int)),array(char),int,int,int))
;	O
else	O
move	int
=	O
UP	int
;	O
}	O
if	O
(	O
move	int
==	O
UP	int
)	O
p	*(char)
=	O
_asn1_find_up	(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))->(*(struct(array(char),int,int,*(char),int,*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),*(struct(array(char),int,int,*`,int,*`,*`,*`,array(char),int,int,int)),array(char),int,int,int)))
(	O
p	*(char)
)	O
;	O
}	O
*	O
len	int
=	O
counter	int
;	O
if	O
(	O
max_len	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_MEM_ERROR	int
;	O
goto	O
error	int
;	O
}	O
err	long
=	O
ASN1_SUCCESS	int
;	O
error	int
:	O
asn1_delete_structure	(*(*(struct)))->(int)
(	O
&	O
node	*(struct)
)	O
;	O
return	O
err	long
;	O
}	O
