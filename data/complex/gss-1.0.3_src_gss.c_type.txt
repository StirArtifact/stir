const	O
char	O
version_etc_copyright	array(char)
[	O
]	O
=	O
"Copyright %s %d Simon Josefsson."	*(char)
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
GSS_ATTR_NO_RETRUN	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s OPTIONS...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Command line interface to GSS, used to explain error codes.\n\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"  -h, --help        Print help and exit.\n  -V, --version     Print version and exit.\n  -l, --list-mechanisms\n                    List information about supported mechanisms\n                    in a human readable format.\n  -m, --major=LONG  Describe a `major status' error code value.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"  -a, --accept-sec-context[=MECH]\n                    Accept a security context as server.\n                    If MECH is not specified, no credentials\n                    will be acquired.  Use \"*\" to use library\n                    default mechanism.\n  -i, --init-sec-context=MECH\n                    Initialize a security context as client.\n                    MECH is the SASL name of mechanism, use -l\n                    to list supported mechanisms.\n  -n, --server-name=SERVICE@HOSTNAME\n                    For -i and -a, set the name of the remote host.\n                    For example, \"imap@mail.example.com\".\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"  -q, --quiet       Silent operation (default=off).\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
emit_bug_reporting_address	()->(void)
(	O
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
int	O
describe_major	(int,long)->(int)
(	O
unsigned	O
int	O
quiet	int
,	O
long	O
major	long
)	O
{	O
gss_buffer_desc	struct(long,*(void))
status_string	*(struct(long,*(void)))
;	O
OM_uint32	int
message_context	*(int)
=	O
0	int
;	O
OM_uint32	int
maj	int
=	O
0	int
,	O
min	int
;	O
size_t	long
i	int
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"GSS-API major status code %ld (0x%lx).\n\n"	*(char)
)	O
,	O
major	long
,	O
major	long
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   MSB                               "	*(char)
"                                  LSB\n"	*(char)
"   +-----------------+---------------"	*(char)
"--+---------------------------------+\n"	*(char)
"   |  Calling Error  |  Routine Error"	*(char)
"  |       Supplementary Info        |\n   | "	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%ld "	*(char)
,	O
(	O
major	long
>>	O
(	O
31	int
-	O
i	int
)	O
)	O
&	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
"| "	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%ld "	*(char)
,	O
(	O
major	long
>>	O
(	O
23	int
-	O
i	int
)	O
)	O
&	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
"| "	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
16	int
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%ld "	*(char)
,	O
(	O
major	long
>>	O
(	O
15	int
-	O
i	int
)	O
)	O
&	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"|\n"	*(char)
"   +-----------------+---------------"	*(char)
"--+---------------------------------+\n"	*(char)
"Bit 31            24  23            1"	*(char)
"6  15                             0\n\n"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
)	O
{	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Masked routine error %ld (0x%lx) shifted "	*(char)
"into %ld (0x%lx):\n"	*(char)
)	O
,	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
,	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
,	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
>>	O
GSS_C_ROUTINE_ERROR_OFFSET	int
,	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
>>	O
GSS_C_ROUTINE_ERROR_OFFSET	int
)	O
;	O
message_context	*(int)
=	O
0	int
;	O
do	O
{	O
maj	int
=	O
gss_display_status	(*(int),int,int,*(struct(int,*(void))),*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
GSS_ROUTINE_ERROR	O
(	O
major	long
)	O
,	O
GSS_C_GSS_CODE	int
,	O
GSS_C_NO_OID	O
,	O
&	O
message_context	*(int)
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"displaying status code failed (%d)"	*(char)
)	O
,	O
maj	int
)	O
;	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%.*s\n"	*(char)
,	O
(	O
int	O
)	O
status_string	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
status_string	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
gss_release_buffer	(*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
}	O
while	O
(	O
message_context	*(int)
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
)	O
{	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Masked calling error %ld (0x%lx) shifted into %ld (0x%lx):\n"	*(char)
)	O
,	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
,	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
,	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
>>	O
GSS_C_CALLING_ERROR_OFFSET	int
,	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
>>	O
GSS_C_CALLING_ERROR_OFFSET	int
)	O
;	O
message_context	*(int)
=	O
0	int
;	O
do	O
{	O
maj	int
=	O
gss_display_status	(*(int),int,int,*(struct(int,*(void))),*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
GSS_CALLING_ERROR	O
(	O
major	long
)	O
,	O
GSS_C_GSS_CODE	int
,	O
GSS_C_NO_OID	O
,	O
&	O
message_context	*(int)
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"displaying status code failed (%d)"	*(char)
)	O
,	O
maj	int
)	O
;	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%.*s\n"	*(char)
,	O
(	O
int	O
)	O
status_string	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
status_string	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
gss_release_buffer	(*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
}	O
while	O
(	O
message_context	*(int)
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
)	O
{	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Masked supplementary info %ld (0x%lx) shifted "	*(char)
"into %ld (0x%lx):\n"	*(char)
)	O
,	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
,	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
,	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
>>	O
GSS_C_SUPPLEMENTARY_OFFSET	int
,	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
>>	O
GSS_C_SUPPLEMENTARY_OFFSET	int
)	O
;	O
message_context	*(int)
=	O
0	int
;	O
do	O
{	O
maj	int
=	O
gss_display_status	(*(int),int,int,*(struct(int,*(void))),*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
GSS_SUPPLEMENTARY_INFO	O
(	O
major	long
)	O
,	O
GSS_C_GSS_CODE	int
,	O
GSS_C_NO_OID	O
,	O
&	O
message_context	*(int)
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"displaying status code failed (%d)"	*(char)
)	O
,	O
maj	int
)	O
;	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%.*s\n"	*(char)
,	O
(	O
int	O
)	O
status_string	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
status_string	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
gss_release_buffer	(*(int),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
&	O
status_string	*(struct(long,*(void)))
)	O
;	O
}	O
while	O
(	O
message_context	*(int)
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
major	long
==	O
GSS_S_COMPLETE	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"No error\n"	*(char)
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
list_mechanisms	(int)->(int)
(	O
unsigned	O
quiet	int
)	O
{	O
OM_uint32	int
maj	int
,	O
min	int
;	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
mech_set	*(*(struct(long,*(struct(int,*`)))))
;	O
size_t	long
i	int
;	O
gss_buffer_desc	struct(long,*(void))
sasl_mech_name	*(struct(long,*(void)))
;	O
gss_buffer_desc	struct(long,*(void))
mech_name	*(struct(long,*(void)))
;	O
gss_buffer_desc	struct(long,*(void))
mech_description	*(struct(long,*(void)))
;	O
maj	int
=	O
gss_indicate_mechs	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
&	O
min	int
,	O
&	O
mech_set	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"indicating mechanisms failed (%d)"	*(char)
)	O
,	O
maj	int
)	O
;	O
return	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
"Found %lu supported mechanisms.\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mech_set	*(*(struct(long,*(struct(int,*`)))))
->	O
count	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mech_set	*(*(struct(long,*(struct(int,*`)))))
->	O
count	long
;	O
i	int
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nMechanism %lu:\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
i	int
)	O
;	O
maj	int
=	O
gss_inquire_saslname_for_mech	(*(int),*(struct(int,*(void))),*(struct(long,*(void))),*(struct(long,*(void))),*(struct(long,*(void))))->(int)
(	O
&	O
min	int
,	O
mech_set	*(*(struct(long,*(struct(int,*`)))))
->	O
elements	*(void)
++	O
,	O
&	O
sasl_mech_name	*(struct(long,*(void)))
,	O
&	O
mech_name	*(struct(long,*(void)))
,	O
&	O
mech_description	*(struct(long,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"inquiring information about mechanism failed (%d)"	*(char)
)	O
,	O
maj	int
)	O
;	O
continue	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\tMechanism name: %.*s\n"	*(char)
,	O
(	O
int	O
)	O
mech_name	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
mech_name	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tMechanism description: %.*s\n"	*(char)
,	O
(	O
int	O
)	O
mech_description	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
mech_description	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tSASL Mechanism name: %.*s\n"	*(char)
,	O
(	O
int	O
)	O
sasl_mech_name	*(struct(long,*(void)))
.	O
length	int
,	O
(	O
char	O
*	O
)	O
sasl_mech_name	*(struct(long,*(void)))
.	O
value	*(void)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
ssize_t	long
gettrimline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
char	O
*	O
*	O
line	*(*(char))
,	O
size_t	long
*	O
n	*(long)
,	O
FILE	struct
*	O
fh	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
ssize_t	long
s	long
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
line	*(*(char))
,	O
n	*(long)
,	O
fh	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
s	long
>=	O
2	int
)	O
{	O
if	O
(	O
(	O
*	O
line	*(*(char))
)	O
[	O
strlen	(*(char))->(long)
(	O
*	O
line	*(*(char))
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
(	O
*	O
line	*(*(char))
)	O
[	O
strlen	(*(char))->(long)
(	O
*	O
line	*(*(char))
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
*	O
line	*(*(char))
)	O
[	O
strlen	(*(char))->(long)
(	O
*	O
line	*(*(char))
)	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
(	O
*	O
line	*(*(char))
)	O
[	O
strlen	(*(char))->(long)
(	O
*	O
line	*(*(char))
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
s	long
;	O
}	O
static	O
int	O
init_sec_context	(int,*(char),*(char))->(int)
(	O
unsigned	O
quiet	int
,	O
const	O
char	O
*	O
mech	*(char)
,	O
const	O
char	O
*	O
server	*(char)
)	O
{	O
OM_uint32	int
maj	int
,	O
min	int
;	O
gss_ctx_id_t	*(struct)
ctx	*(struct(int,array(char)))
=	O
GSS_C_NO_CONTEXT	O
;	O
gss_name_t	*(struct)
servername	*(struct)
=	O
GSS_C_NO_NAME	O
;	O
gss_buffer_desc	struct(long,*(void))
inbuf_desc	struct(long,*(void))
;	O
gss_buffer_t	*(struct(long,*(void)))
inbuf	*(struct(long,*(void)))
=	O
GSS_C_NO_BUFFER	O
;	O
gss_buffer_desc	struct(long,*(void))
bufdesc	struct(long,*(void))
;	O
gss_buffer_desc	struct(long,*(void))
sasl_mech_name	*(struct(long,*(void)))
;	O
gss_OID	*(struct(int,*(void)))
mech_type	*(struct(int,*(void)))
;	O
size_t	long
outlen	long
;	O
char	O
*	O
out	*(char)
;	O
ssize_t	long
s	long
;	O
char	O
*	O
line	*(*(char))
=	O
NULL	O
;	O
size_t	long
n	*(long)
=	O
0	int
;	O
bool	bool
ok	bool
;	O
OM_uint32	int
ret_flags	*(int)
;	O
sasl_mech_name	*(struct(long,*(void)))
.	O
length	int
=	O
strlen	(*(char))->(long)
(	O
mech	*(char)
)	O
;	O
sasl_mech_name	*(struct(long,*(void)))
.	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
mech	*(char)
;	O
maj	int
=	O
gss_inquire_mech_for_saslname	(*(int),*(struct(long,*(void))),*(*(struct(int,*(void)))))->(int)
(	O
&	O
min	int
,	O
&	O
sasl_mech_name	*(struct(long,*(void)))
,	O
&	O
mech_type	*(struct(int,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"inquiring mechanism for SASL name (%d/%d)"	*(char)
)	O
,	O
maj	int
,	O
min	int
)	O
;	O
if	O
(	O
server	*(char)
)	O
{	O
gss_buffer_desc	struct(long,*(void))
namebuf	struct(long,*(void))
;	O
namebuf	struct(long,*(void))
.	O
length	int
=	O
strlen	(*(char))->(long)
(	O
server	*(char)
)	O
;	O
namebuf	struct(long,*(void))
.	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
server	*(char)
;	O
maj	int
=	O
gss_import_name	(*(int),*(struct(long,*(void))),*(struct(int,*(void))),*(*(struct)))->(int)
(	O
&	O
min	int
,	O
&	O
namebuf	struct(long,*(void))
,	O
GSS_C_NT_HOSTBASED_SERVICE	*(struct(int,*(void)))
,	O
&	O
servername	*(struct)
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"could not import server name \"%s\" (%d/%d)"	*(char)
)	O
,	O
server	*(char)
,	O
maj	int
,	O
min	int
)	O
;	O
}	O
do	O
{	O
maj	int
=	O
gss_init_sec_context	(*(int),*(struct),*(*(struct)),*(struct),*(struct(int,*(void))),int,int,*(struct(int,struct(long,*(void)),int,struct(long,*(void)),struct(long,*(void)))),*(struct(long,*(void))),*(*(struct(int,*(void)))),*(struct(long,*(void))),*(int),*(int))->(int)
(	O
&	O
min	int
,	O
GSS_C_NO_CREDENTIAL	O
,	O
&	O
ctx	*(struct(int,array(char)))
,	O
servername	*(struct)
,	O
mech_type	*(struct(int,*(void)))
,	O
GSS_C_MUTUAL_FLAG	int
|	O
GSS_C_REPLAY_FLAG	int
|	O
GSS_C_SEQUENCE_FLAG	int
,	O
0	int
,	O
GSS_C_NO_CHANNEL_BINDINGS	O
,	O
inbuf	*(struct(long,*(void)))
,	O
NULL	O
,	O
&	O
bufdesc	struct(long,*(void))
,	O
&	O
ret_flags	*(int)
,	O
NULL	O
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"initializing security context failed (%d/%d)"	*(char)
)	O
,	O
maj	int
,	O
min	int
)	O
;	O
outlen	long
=	O
base64_encode_alloc	(*(char),long,*(*(char)))->(long)
(	O
bufdesc	struct(long,*(void))
.	O
value	*(void)
,	O
bufdesc	struct(long,*(void))
.	O
length	int
,	O
&	O
out	*(char)
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
&&	O
outlen	long
==	O
0	int
&&	O
bufdesc	struct(long,*(void))
.	O
length	int
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"base64 input too long"	*(char)
)	O
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"malloc"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
if	O
(	O
maj	int
==	O
GSS_S_COMPLETE	int
&&	O
bufdesc	struct(long,*(void))
.	O
length	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Context has been initialized.\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_COMPLETE	int
)	O
printf	(*(char))->(int)
(	O
"Context has been initialized.  Final context token:\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
&&	O
(	O
ret_flags	*(int)
&	O
GSS_C_PROT_READY_FLAG	int
)	O
)	O
printf	(*(char))->(int)
(	O
"Context token (protection is available):\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
)	O
printf	(*(char))->(int)
(	O
"Context token:\n"	*(char)
)	O
;	O
}	O
if	O
(	O
bufdesc	struct(long,*(void))
.	O
length	int
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
out	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
out	*(char)
)	O
;	O
if	O
(	O
maj	int
==	O
GSS_S_COMPLETE	int
)	O
break	O
;	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
"Input context token:\n"	*(char)
)	O
;	O
s	long
=	O
gettrimline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	*(*(char))
,	O
&	O
n	*(long)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
s	long
==	O
-	O
1	int
&&	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"getline"	*(char)
)	O
)	O
;	O
if	O
(	O
s	long
==	O
-	O
1	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"end of file"	*(char)
)	O
)	O
;	O
ok	bool
=	O
base64_decode_alloc	O
(	O
line	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
line	*(*(char))
)	O
,	O
&	O
out	*(char)
,	O
&	O
outlen	long
)	O
;	O
if	O
(	O
!	O
ok	bool
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"base64 fail"	*(char)
)	O
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"malloc"	*(char)
)	O
)	O
;	O
inbuf_desc	struct(long,*(void))
.	O
value	*(void)
=	O
out	*(char)
;	O
inbuf_desc	struct(long,*(void))
.	O
length	int
=	O
outlen	long
;	O
inbuf	*(struct(long,*(void)))
=	O
&	O
inbuf_desc	struct(long,*(void))
;	O
}	O
while	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
accept_sec_context	(int,*(char),*(char))->(int)
(	O
unsigned	O
quiet	int
,	O
const	O
char	O
*	O
mech	*(char)
,	O
const	O
char	O
*	O
server	*(char)
)	O
{	O
OM_uint32	int
maj	int
,	O
min	int
;	O
gss_ctx_id_t	*(struct)
ctx	*(struct(int,array(char)))
=	O
GSS_C_NO_CONTEXT	O
;	O
gss_cred_id_t	*(struct)
cred	*(struct)
=	O
GSS_C_NO_CREDENTIAL	O
;	O
gss_name_t	*(struct)
client	*(struct)
=	O
GSS_C_NO_NAME	O
;	O
gss_buffer_desc	struct(long,*(void))
bufdesc	struct(long,*(void))
,	O
bufdesc2	struct(long,*(void))
;	O
gss_OID	*(struct(int,*(void)))
mech_type	*(struct(int,*(void)))
=	O
GSS_C_NO_OID	O
;	O
char	O
*	O
out	*(char)
;	O
size_t	long
outlen	long
;	O
ssize_t	long
s	long
;	O
char	O
*	O
line	*(*(char))
=	O
NULL	O
;	O
size_t	long
n	*(long)
=	O
0	int
;	O
bool	bool
ok	bool
;	O
OM_uint32	int
ret_flags	*(int)
;	O
if	O
(	O
mech	*(char)
||	O
server	*(char)
)	O
{	O
gss_name_t	*(struct)
servername	*(struct)
=	O
GSS_C_NO_NAME	O
;	O
gss_OID_set	*(struct(long,*(struct(int,*(void)))))
mech_types	*(*(struct(long,*(struct(int,*`)))))
=	O
GSS_C_NULL_OID_SET	O
;	O
if	O
(	O
mech	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
mech	*(char)
,	O
"*"	*(char)
)	O
!=	O
0	int
)	O
{	O
gss_buffer_desc	struct(long,*(void))
sasl_mech_name	*(struct(long,*(void)))
;	O
sasl_mech_name	*(struct(long,*(void)))
.	O
length	int
=	O
strlen	(*(char))->(long)
(	O
mech	*(char)
)	O
;	O
sasl_mech_name	*(struct(long,*(void)))
.	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
mech	*(char)
;	O
printf	(*(char))->(int)
(	O
"Inquiring mechanism OID for SASL name \"%s\"...\n"	*(char)
,	O
mech	*(char)
)	O
;	O
maj	int
=	O
gss_inquire_mech_for_saslname	(*(int),*(struct(long,*(void))),*(*(struct(int,*(void)))))->(int)
(	O
&	O
min	int
,	O
&	O
sasl_mech_name	*(struct(long,*(void)))
,	O
&	O
mech_type	*(struct(int,*(void)))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"inquiring mechanism for SASL name (%d/%d)"	*(char)
)	O
,	O
maj	int
,	O
min	int
)	O
;	O
}	O
if	O
(	O
server	*(char)
)	O
{	O
gss_buffer_desc	struct(long,*(void))
namebuf	struct(long,*(void))
;	O
namebuf	struct(long,*(void))
.	O
length	int
=	O
strlen	(*(char))->(long)
(	O
server	*(char)
)	O
;	O
namebuf	struct(long,*(void))
.	O
value	*(void)
=	O
(	O
void	O
*	O
)	O
server	*(char)
;	O
printf	(*(char))->(int)
(	O
"Importing name \"%s\"...\n"	*(char)
,	O
server	*(char)
)	O
;	O
maj	int
=	O
gss_import_name	(*(int),*(struct(long,*(void))),*(struct(int,*(void))),*(*(struct)))->(int)
(	O
&	O
min	int
,	O
&	O
namebuf	struct(long,*(void))
,	O
GSS_C_NT_HOSTBASED_SERVICE	*(struct(int,*(void)))
,	O
&	O
servername	*(struct)
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"could not import server name \"%s\" (%d/%d)"	*(char)
)	O
,	O
server	*(char)
,	O
maj	int
,	O
min	int
)	O
;	O
}	O
if	O
(	O
mech_type	*(struct(int,*(void)))
!=	O
GSS_C_NO_OID	O
)	O
{	O
maj	int
=	O
gss_create_empty_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
&	O
min	int
,	O
&	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"gss_create_empty_oid_set (%d/%d)"	*(char)
,	O
maj	int
,	O
min	int
)	O
;	O
maj	int
=	O
gss_add_oid_set_member	(*(int),*(struct(int,*(void))),*(*(struct(long,*(struct`)))))->(int)
(	O
&	O
min	int
,	O
mech_type	*(struct(int,*(void)))
,	O
&	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"gss_add_oid_set_member (%d/%d)"	*(char)
,	O
maj	int
,	O
min	int
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"Acquiring credentials...\n"	*(char)
)	O
;	O
maj	int
=	O
gss_acquire_cred	(*(int),*(struct),int,*(struct(long,*(struct(int,*`)))),int,*(*(struct)),*(*(struct(long,*(struct`)))),*(int))->(int)
(	O
&	O
min	int
,	O
servername	*(struct)
,	O
0	int
,	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
,	O
GSS_C_ACCEPT	int
,	O
&	O
cred	*(struct)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"could not acquire server credentials (%d/%d)"	*(char)
)	O
,	O
maj	int
,	O
min	int
)	O
;	O
if	O
(	O
mech_type	*(struct(int,*(void)))
!=	O
GSS_C_NO_OID	O
)	O
{	O
maj	int
=	O
gss_release_oid_set	(*(int),*(*(struct(long,*(struct`)))))->(int)
(	O
&	O
min	int
,	O
&	O
mech_types	*(*(struct(long,*(struct(int,*`)))))
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"gss_release_oid_set (%d/%d)"	*(char)
,	O
maj	int
,	O
min	int
)	O
;	O
}	O
}	O
do	O
{	O
if	O
(	O
!	O
quiet	int
)	O
printf	(*(char))->(int)
(	O
"Input context token:\n"	*(char)
)	O
;	O
s	long
=	O
gettrimline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line	*(*(char))
,	O
&	O
n	*(long)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
s	long
==	O
-	O
1	int
&&	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"getline"	*(char)
)	O
)	O
;	O
if	O
(	O
s	long
==	O
-	O
1	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"end of file"	*(char)
)	O
)	O
;	O
ok	bool
=	O
base64_decode_alloc	O
(	O
line	*(*(char))
,	O
strlen	(*(char))->(long)
(	O
line	*(*(char))
)	O
,	O
&	O
out	*(char)
,	O
&	O
outlen	long
)	O
;	O
if	O
(	O
!	O
ok	bool
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"base64 fail"	*(char)
)	O
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"malloc"	*(char)
)	O
)	O
;	O
bufdesc	struct(long,*(void))
.	O
value	*(void)
=	O
out	*(char)
;	O
bufdesc	struct(long,*(void))
.	O
length	int
=	O
outlen	long
;	O
maj	int
=	O
gss_accept_sec_context	(*(int),*(*(struct)),*(struct),*(struct(long,*(void))),*(struct(int,struct(long,*(void)),int,struct(long,*(void)),struct(long,*(void)))),*(*(struct)),*(*(struct(int,*(void)))),*(struct(long,*(void))),*(int),*(int),*(*(struct)))->(int)
(	O
&	O
min	int
,	O
&	O
ctx	*(struct(int,array(char)))
,	O
cred	*(struct)
,	O
&	O
bufdesc	struct(long,*(void))
,	O
GSS_C_NO_CHANNEL_BINDINGS	O
,	O
&	O
client	*(struct)
,	O
&	O
mech_type	*(struct(int,*(void)))
,	O
&	O
bufdesc2	struct(long,*(void))
,	O
&	O
ret_flags	*(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"accepting security context failed (%d/%d)"	*(char)
)	O
,	O
maj	int
,	O
min	int
)	O
;	O
outlen	long
=	O
base64_encode_alloc	(*(char),long,*(*(char)))->(long)
(	O
bufdesc2	struct(long,*(void))
.	O
value	*(void)
,	O
bufdesc2	struct(long,*(void))
.	O
length	int
,	O
&	O
out	*(char)
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
&&	O
outlen	long
==	O
0	int
&&	O
bufdesc2	struct(long,*(void))
.	O
length	int
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"base64 input too long"	*(char)
)	O
)	O
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"malloc"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
if	O
(	O
maj	int
==	O
GSS_S_COMPLETE	int
&&	O
bufdesc2	struct(long,*(void))
.	O
length	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Context has been accepted.\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_COMPLETE	int
)	O
printf	(*(char))->(int)
(	O
"Context has been accepted.  Final context token:\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
&&	O
(	O
ret_flags	*(int)
&	O
GSS_C_PROT_READY_FLAG	int
)	O
)	O
printf	(*(char))->(int)
(	O
"Context token (protection is available):\n"	*(char)
)	O
;	O
else	O
if	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
)	O
printf	(*(char))->(int)
(	O
"Context token:\n"	*(char)
)	O
;	O
}	O
if	O
(	O
bufdesc2	struct(long,*(void))
.	O
length	int
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
out	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
out	*(char)
)	O
;	O
}	O
while	O
(	O
maj	int
==	O
GSS_S_CONTINUE_NEEDED	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
gengetopt_args_info	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
;	O
int	O
rc	int
=	O
0	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
if	O
(	O
cmdline_parser	(int,*(*(char)),*(struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
)	O
!=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
version_given	int
)	O
{	O
version_etc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gss"	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
VERSION	*(char)
,	O
"Simon Josefsson"	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
help_given	int
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
else	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
major_given	int
)	O
rc	int
=	O
describe_major	(int,long)->(int)
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
quiet_given	int
,	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
major_arg	long
)	O
;	O
else	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
list_mechanisms_given	int
)	O
rc	int
=	O
list_mechanisms	(int)->(int)
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
quiet_given	int
)	O
;	O
else	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
init_sec_context_given	int
)	O
rc	int
=	O
init_sec_context	(int,*(char),*(char))->(int)
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
quiet_given	int
,	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
init_sec_context_arg	*(char)
,	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
server_name_arg	*(char)
)	O
;	O
else	O
if	O
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
accept_sec_context_given	int
)	O
rc	int
=	O
accept_sec_context	(int,*(char),*(char))->(int)
(	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
quiet_given	int
,	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
accept_sec_context_arg	*(char)
,	O
args	struct(*(char),*(char),long,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,*(char),int,int,int,int,int,int,int,int)
.	O
server_name_arg	*(char)
)	O
;	O
else	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
return	O
rc	int
;	O
}	O
