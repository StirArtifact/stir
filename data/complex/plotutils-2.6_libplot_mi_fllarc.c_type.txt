static	O
void	O
miFillArcSliceD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
static	O
void	O
miFillArcSliceI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
static	O
void	O
miFillEllipseD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
static	O
void	O
miFillEllipseI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
static	O
void	O
miEllipseAngleToSlope	(int,int,int,*(int),*(int),*(double),*(double))->(void)
(	O
int	O
angle	double
,	O
unsigned	O
int	O
width	array(short)
,	O
unsigned	O
int	O
height	int
,	O
int	O
*	O
dxp	*(int)
,	O
int	O
*	O
dyp	*(int)
,	O
double	O
*	O
d_dxp	*(double)
,	O
double	O
*	O
d_dyp	*(double)
)	O
;	O
static	O
void	O
miFillArcDSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,double,double,double,double,double)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miFillArcD	struct(int,int,int,int,int,double,double,double,double,double)
*	O
info	*(struct(*(char),char,char,char))
)	O
;	O
static	O
void	O
miFillArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miFillArc	struct(int,int,int,int,int,int,int,int,int,int)
*	O
info	*(struct(*(char),char,char,char))
)	O
;	O
static	O
void	O
miFillArcSliceSetup	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miArcSlice	struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))
*	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
;	O
static	O
void	O
miGetArcEdge	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int)),int,enum(int,int),enum(int,int))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miSliceEdge	struct(int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int))
,	O
int	O
k	int
,	O
bool	enum(int,int)
top	enum(int,int)
,	O
bool	enum(int,int)
left	enum(int,int)
)	O
;	O
static	O
void	O
miGetPieEdge	(*(struct(int,int,int,int,int,int)),int,*(struct(int,int,int,int,int,int)),enum(int,int),enum(int,int))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
int	O
angle	double
,	O
miSliceEdge	struct(int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int))
,	O
bool	enum(int,int)
top	enum(int,int)
,	O
bool	enum(int,int)
left	enum(int,int)
)	O
;	O
static	O
void	O
miFillArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miFillArc	struct(int,int,int,int,int,int,int,int,int,int)
*	O
info	*(struct(*(char),char,char,char))
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
y	double
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
dy	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
yorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
y	double
+	O
info	*(struct(*(char),char,char,char))
->	O
y	double
;	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
+	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
;	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
=	O
1	int
-	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
=	O
8	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
=	O
8	int
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
=	O
info	*(struct(*(char),char,char,char))
->	O
y	double
<<	O
3	int
;	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
y	double
++	O
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
+=	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
-	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
y	double
<<	O
3	int
)	O
;	O
}	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
<<	O
3	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
<<	O
3	int
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
=	O
info	*(struct(*(char),char,char,char))
->	O
y	double
*	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
;	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
dy	int
)	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
-=	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
>>	O
1	int
;	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
>>	O
3	int
)	O
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
y	double
++	O
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
+=	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
>>	O
1	int
)	O
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
-	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
;	O
}	O
}	O
}	O
static	O
void	O
miFillArcDSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,double,double,double,double,double)))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miFillArcD	struct(int,int,int,int,int,double,double,double,double,double)
*	O
info	*(struct(*(char),char,char,char))
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
y	double
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
dy	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
yorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
y	double
+	O
info	*(struct(*(char),char,char,char))
->	O
y	double
;	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
+	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
;	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
=	O
1	int
-	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
;	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
=	O
(	O
(	O
double	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
*	O
8	int
)	O
;	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
=	O
(	O
(	O
double	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
*	O
8	int
)	O
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
=	O
info	*(struct(*(char),char,char,char))
->	O
y	double
*	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
;	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
dy	int
)	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
-=	O
(	O
0.5	int
*	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
)	O
;	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
-	O
(	O
0.125	int
*	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
)	O
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
y	double
++	O
;	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
+=	O
info	*(struct(*(char),char,char,char))
->	O
ym	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
=	O
-	O
0.5	int
*	O
info	*(struct(*(char),char,char,char))
->	O
xm	int
;	O
info	*(struct(*(char),char,char,char))
->	O
e	int
=	O
info	*(struct(*(char),char,char,char))
->	O
xk	int
-	O
info	*(struct(*(char),char,char,char))
->	O
yk	int
;	O
}	O
}	O
static	O
void	O
miGetArcEdge	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int)),int,enum(int,int),enum(int,int))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miSliceEdge	struct(int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int))
,	O
int	O
k	int
,	O
bool	enum(int,int)
top	enum(int,int)
,	O
bool	enum(int,int)
left	enum(int,int)
)	O
{	O
int	O
xady	int
,	O
y	double
;	O
y	double
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
;	O
if	O
(	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
==	O
0	int
)	O
y	double
++	O
;	O
if	O
(	O
!	O
top	enum(int,int)
)	O
{	O
y	double
=	O
-	O
y	double
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
y	double
--	O
;	O
}	O
xady	int
=	O
k	int
+	O
y	double
*	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
;	O
if	O
(	O
xady	int
<=	O
0	int
)	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
=	O
-	O
(	O
(	O
-	O
xady	int
)	O
/	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
+	O
1	int
)	O
;	O
else	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
=	O
(	O
xady	int
-	O
1	int
)	O
/	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
e	int
=	O
xady	int
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
*	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
;	O
if	O
(	O
(	O
top	enum(int,int)
&&	O
(	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
<	O
0	int
)	O
)	O
||	O
(	O
!	O
top	enum(int,int)
&&	O
(	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
>	O
0	int
)	O
)	O
)	O
edge	*(struct(int,int,int,int,int,int))
->	O
e	int
=	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
e	int
+	O
1	int
;	O
if	O
(	O
left	enum(int,int)
)	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
++	O
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
+=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
if	O
(	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
>	O
0	int
)	O
{	O
edge	*(struct(int,int,int,int,int,int))
->	O
deltax	double
=	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
=	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
/	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
=	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
%	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
;	O
}	O
else	O
{	O
edge	*(struct(int,int,int,int,int,int))
->	O
deltax	double
=	O
-	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
=	O
-	O
(	O
(	O
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
)	O
/	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
)	O
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
=	O
(	O
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
)	O
%	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
;	O
}	O
if	O
(	O
!	O
top	enum(int,int)
)	O
{	O
edge	*(struct(int,int,int,int,int,int))
->	O
deltax	double
=	O
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
deltax	double
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
=	O
-	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
;	O
}	O
}	O
static	O
void	O
miEllipseAngleToSlope	(int,int,int,*(int),*(int),*(double),*(double))->(void)
(	O
int	O
angle	double
,	O
unsigned	O
int	O
width	array(short)
,	O
unsigned	O
int	O
height	int
,	O
int	O
*	O
dxp	*(int)
,	O
int	O
*	O
dyp	*(int)
,	O
double	O
*	O
d_dxp	*(double)
,	O
double	O
*	O
d_dyp	*(double)
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
double	O
d_dx	double
,	O
d_dy	double
,	O
scale	double
;	O
bool	enum(int,int)
negative_dx	enum(int,int)
,	O
negative_dy	enum(int,int)
;	O
switch	O
(	O
angle	double
)	O
{	O
case	O
0	int
:	O
*	O
dxp	*(int)
=	O
-	O
1	int
;	O
*	O
dyp	*(int)
=	O
0	int
;	O
if	O
(	O
d_dxp	*(double)
)	O
{	O
*	O
d_dxp	*(double)
=	O
0.5	int
*	O
(	O
int	O
)	O
width	array(short)
;	O
*	O
d_dyp	*(double)
=	O
0	int
;	O
}	O
break	O
;	O
case	O
QUADRANT	O
:	O
*	O
dxp	*(int)
=	O
0	int
;	O
*	O
dyp	*(int)
=	O
1	int
;	O
if	O
(	O
d_dxp	*(double)
)	O
{	O
*	O
d_dxp	*(double)
=	O
0	int
;	O
*	O
d_dyp	*(double)
=	O
-	O
0.5	int
*	O
(	O
int	O
)	O
height	int
;	O
}	O
break	O
;	O
case	O
HALFCIRCLE	O
:	O
*	O
dxp	*(int)
=	O
1	int
;	O
*	O
dyp	*(int)
=	O
0	int
;	O
if	O
(	O
d_dxp	*(double)
)	O
{	O
*	O
d_dxp	*(double)
=	O
-	O
0.5	int
*	O
(	O
int	O
)	O
width	array(short)
;	O
*	O
d_dyp	*(double)
=	O
0	int
;	O
}	O
break	O
;	O
case	O
QUADRANT3	O
:	O
*	O
dxp	*(int)
=	O
0	int
;	O
*	O
dyp	*(int)
=	O
-	O
1	int
;	O
if	O
(	O
d_dxp	*(double)
)	O
{	O
*	O
d_dxp	*(double)
=	O
0	int
;	O
*	O
d_dyp	*(double)
=	O
0.5	int
*	O
(	O
int	O
)	O
height	int
;	O
}	O
break	O
;	O
default	O
:	O
d_dx	double
=	O
Dcos	O
(	O
angle	double
)	O
*	O
(	O
int	O
)	O
width	array(short)
;	O
d_dy	double
=	O
Dsin	O
(	O
angle	double
)	O
*	O
(	O
int	O
)	O
height	int
;	O
if	O
(	O
d_dxp	*(double)
)	O
{	O
*	O
d_dxp	*(double)
=	O
0.5	int
*	O
d_dx	double
;	O
*	O
d_dyp	*(double)
=	O
-	O
0.5	int
*	O
d_dy	double
;	O
}	O
negative_dx	enum(int,int)
=	O
false	int
;	O
if	O
(	O
d_dx	double
<	O
0.0	int
)	O
{	O
d_dx	double
=	O
-	O
d_dx	double
;	O
negative_dx	enum(int,int)
=	O
true	int
;	O
}	O
negative_dy	enum(int,int)
=	O
false	int
;	O
if	O
(	O
d_dy	double
<	O
0.0	int
)	O
{	O
d_dy	double
=	O
-	O
d_dy	double
;	O
negative_dy	enum(int,int)
=	O
true	int
;	O
}	O
scale	double
=	O
d_dx	double
;	O
if	O
(	O
d_dy	double
>	O
d_dx	double
)	O
scale	double
=	O
d_dy	double
;	O
dx	int
=	O
IFLOOR	O
(	O
(	O
d_dx	double
*	O
32768	int
)	O
/	O
scale	double
+	O
0.5	int
)	O
;	O
if	O
(	O
negative_dx	enum(int,int)
)	O
dx	int
=	O
-	O
dx	int
;	O
*	O
dxp	*(int)
=	O
dx	int
;	O
dy	int
=	O
IFLOOR	O
(	O
(	O
d_dy	double
*	O
32768	int
)	O
/	O
scale	double
+	O
0.5	int
)	O
;	O
if	O
(	O
negative_dy	enum(int,int)
)	O
dy	int
=	O
-	O
dy	int
;	O
*	O
dyp	*(int)
=	O
dy	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miGetPieEdge	(*(struct(int,int,int,int,int,int)),int,*(struct(int,int,int,int,int,int)),enum(int,int),enum(int,int))->(void)
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
int	O
angle	double
,	O
miSliceEdge	struct(int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int))
,	O
bool	enum(int,int)
top	enum(int,int)
,	O
bool	enum(int,int)
left	enum(int,int)
)	O
{	O
int	O
k	int
;	O
int	O
dx	int
,	O
dy	int
;	O
miEllipseAngleToSlope	(int,int,int,*(int),*(int),*(double),*(double))->(void)
(	O
angle	double
,	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
,	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
,	O
&	O
dx	int
,	O
&	O
dy	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
=	O
left	enum(int,int)
?	O
INT_MIN	O
:	O
INT_MAX	O
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
e	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
if	O
(	O
left	enum(int,int)
&&	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
)	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
++	O
;	O
else	O
if	O
(	O
!	O
left	enum(int,int)
&&	O
!	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
)	O
edge	*(struct(int,int,int,int,int,int))
->	O
x	double
--	O
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
stepx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
e	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
}	O
k	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
?	O
dx	int
:	O
0	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
k	int
+=	O
dy	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dx	int
=	O
dx	int
<<	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int))
->	O
dy	int
=	O
dy	int
<<	O
1	int
;	O
miGetArcEdge	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int)),int,enum(int,int),enum(int,int))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
edge	*(struct(int,int,int,int,int,int))
,	O
k	int
,	O
top	enum(int,int)
,	O
left	enum(int,int)
)	O
;	O
}	O
static	O
void	O
miFillArcSliceSetup	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miArcSlice	struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))
*	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
{	O
int	O
angle1	int
,	O
angle2	int
;	O
angle1	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle1	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
<	O
0	int
)	O
{	O
angle2	int
=	O
angle1	int
;	O
angle1	int
+=	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
;	O
}	O
else	O
angle2	int
=	O
angle1	int
+	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
;	O
while	O
(	O
angle1	int
<	O
0	int
)	O
angle1	int
+=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle1	int
>=	O
FULLCIRCLE	O
)	O
angle1	int
-=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle2	int
<	O
0	int
)	O
angle2	int
+=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
angle2	int
-=	O
FULLCIRCLE	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
max_top_y	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
1	int
-	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
max_bot_y	int
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
max_top_y	int
-	O
1	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
flip_top	enum(int,int)
=	O
false	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
flip_bot	enum(int,int)
=	O
false	int
;	O
switch	O
(	O
pGC	*(struct)
->	O
arcMode	int
)	O
{	O
case	O
MI_ARC_CHORD	int
:	O
default	O
:	O
{	O
double	O
w2	double
,	O
h2	double
,	O
x1	double
,	O
y1	(double)->(double)
,	O
x2	double
,	O
y2	double
,	O
dx	int
,	O
dy	int
,	O
scale	double
;	O
int	O
signdx	int
,	O
signdy	int
,	O
y	double
,	O
k	int
;	O
bool	enum(int,int)
isInt1	enum(int,int)
=	O
true	int
,	O
isInt2	enum(int,int)
=	O
true	int
;	O
w2	double
=	O
0.5	int
*	O
(	O
double	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
;	O
h2	double
=	O
0.5	int
*	O
(	O
double	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
||	O
(	O
angle1	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
x1	double
=	O
angle1	int
?	O
-	O
w2	double
:	O
w2	double
;	O
y1	(double)->(double)
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle1	int
==	O
QUADRANT	O
)	O
||	O
(	O
angle1	int
==	O
QUADRANT3	O
)	O
)	O
{	O
x1	double
=	O
0.0	int
;	O
y1	(double)->(double)
=	O
(	O
angle1	int
==	O
QUADRANT	O
)	O
?	O
h2	double
:	O
-	O
h2	double
;	O
}	O
else	O
{	O
isInt1	enum(int,int)
=	O
false	int
;	O
x1	double
=	O
Dcos	O
(	O
angle1	int
)	O
*	O
w2	double
;	O
y1	(double)->(double)
=	O
Dsin	O
(	O
angle1	int
)	O
*	O
h2	double
;	O
}	O
if	O
(	O
(	O
angle2	int
==	O
0	int
)	O
||	O
(	O
angle2	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
x2	double
=	O
angle2	int
?	O
-	O
w2	double
:	O
w2	double
;	O
y2	double
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle2	int
==	O
QUADRANT	O
)	O
||	O
(	O
angle2	int
==	O
QUADRANT3	O
)	O
)	O
{	O
x2	double
=	O
0.0	int
;	O
y2	double
=	O
(	O
angle2	int
==	O
QUADRANT	O
)	O
?	O
h2	double
:	O
-	O
h2	double
;	O
}	O
else	O
{	O
isInt2	enum(int,int)
=	O
false	int
;	O
x2	double
=	O
Dcos	O
(	O
angle2	int
)	O
*	O
w2	double
;	O
y2	double
=	O
Dsin	O
(	O
angle2	int
)	O
*	O
h2	double
;	O
}	O
dx	int
=	O
x2	double
-	O
x1	double
;	O
dy	int
=	O
y2	double
-	O
y1	(double)->(double)
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
{	O
y1	(double)->(double)
-=	O
0.5	int
;	O
y2	double
-=	O
0.5	int
;	O
}	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
{	O
x1	double
+=	O
0.5	int
;	O
x2	double
+=	O
0.5	int
;	O
}	O
if	O
(	O
dy	int
<	O
0.0	int
)	O
{	O
dy	int
=	O
-	O
dy	int
;	O
signdy	int
=	O
-	O
1	int
;	O
}	O
else	O
signdy	int
=	O
1	int
;	O
if	O
(	O
dx	int
<	O
0.0	int
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
signdx	int
=	O
-	O
1	int
;	O
}	O
else	O
signdx	int
=	O
1	int
;	O
if	O
(	O
isInt1	enum(int,int)
&&	O
isInt2	enum(int,int)
)	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
dx	int
*	O
2	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
dy	int
*	O
2	int
)	O
;	O
}	O
else	O
{	O
scale	double
=	O
(	O
dx	int
>	O
dy	int
)	O
?	O
dx	int
:	O
dy	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
IFLOOR	O
(	O
(	O
dx	int
*	O
32768	int
)	O
/	O
scale	double
+	O
.5	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dy	int
=	O
IFLOOR	O
(	O
(	O
dy	int
*	O
32768	int
)	O
/	O
scale	double
+	O
.5	int
)	O
;	O
}	O
if	O
(	O
!	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dy	int
)	O
{	O
if	O
(	O
signdx	int
<	O
0	int
)	O
{	O
y	double
=	O
IFLOOR	O
(	O
y1	(double)->(double)
+	O
1.0	int
)	O
;	O
if	O
(	O
y	double
>=	O
0	int
)	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
y	double
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
}	O
else	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
max_bot_y	int
=	O
-	O
y	double
-	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
y	double
=	O
IFLOOR	O
(	O
y1	(double)->(double)
)	O
;	O
if	O
(	O
y	double
>=	O
0	int
)	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
max_top_y	int
=	O
y	double
;	O
else	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
-	O
y	double
-	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
;	O
}	O
}	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
=	O
true	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
x	double
=	O
INT_MAX	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
stepx	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
e	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
-	O
1	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
=	O
false	int
;	O
}	O
else	O
if	O
(	O
!	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
)	O
{	O
if	O
(	O
signdy	int
<	O
0	int
)	O
x1	double
-=	O
1.0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
x	double
=	O
ICEIL	O
(	O
x1	double
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
=	O
(	O
signdy	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
x	double
+=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
stepx	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
e	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
-	O
1	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
=	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
;	O
}	O
else	O
{	O
if	O
(	O
signdx	int
<	O
0	int
)	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
-	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
;	O
if	O
(	O
signdy	int
<	O
0	int
)	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
-	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
;	O
k	int
=	O
ICEIL	O
(	O
(	O
(	O
x1	double
+	O
x2	double
)	O
*	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dy	int
-	O
(	O
y1	(double)->(double)
+	O
y2	double
)	O
*	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
)	O
/	O
2.0	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
.	O
dx	int
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dx	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
.	O
dy	int
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
.	O
dy	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
=	O
(	O
signdy	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
=	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
miGetArcEdge	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int)),int,enum(int,int),enum(int,int))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
,	O
k	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
,	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
?	O
false	int
:	O
true	int
)	O
)	O
;	O
miGetArcEdge	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int)),int,enum(int,int),enum(int,int))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
,	O
k	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
MI_ARC_PIE_SLICE	int
:	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
=	O
(	O
angle1	int
<	O
HALFCIRCLE	O
?	O
true	int
:	O
false	int
)	O
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
=	O
(	O
angle2	int
<=	O
HALFCIRCLE	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
(	O
angle2	int
==	O
0	int
)	O
||	O
(	O
angle1	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
if	O
(	O
angle2	int
?	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
:	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
)	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
;	O
else	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
||	O
(	O
angle2	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
;	O
if	O
(	O
angle1	int
?	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
:	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
)	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
else	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
==	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
)	O
{	O
if	O
(	O
angle2	int
<	O
angle1	int
)	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
flip_top	enum(int,int)
=	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
flip_bot	enum(int,int)
=	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
?	O
false	int
:	O
true	int
)	O
;	O
}	O
else	O
if	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
)	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
1	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
}	O
else	O
{	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_bot_y	int
=	O
0	int
;	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
min_top_y	int
=	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
}	O
}	O
miGetPieEdge	(*(struct(int,int,int,int,int,int)),int,*(struct(int,int,int,int,int,int)),enum(int,int),enum(int,int))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
angle1	int
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1	struct(int,int,int,int,int,int)
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
,	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge1_top	enum(int,int)
?	O
false	int
:	O
true	int
)	O
)	O
;	O
miGetPieEdge	(*(struct(int,int,int,int,int,int)),int,*(struct(int,int,int,int,int,int)),enum(int,int),enum(int,int))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
angle2	int
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2	struct(int,int,int,int,int,int)
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
->	O
edge2_top	enum(int,int)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miFillEllipseI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
{	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
int	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
;	O
int	O
slw	int
;	O
miFillArc	struct(int,int,int,int,int,int,int,int,int,int)
info	*(struct(*(char),char,char,char))
;	O
miPoint	struct(int,int)
*	O
points_upper	*(struct(int,int))
,	O
*	O
points_lower	*(struct(int,int))
,	O
*	O
pts_upper	*(struct(int,int))
,	O
*	O
pts_lower	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths_upper	*(int)
,	O
*	O
widths_lower	*(int)
,	O
*	O
wids_upper	*(int)
,	O
*	O
wids_lower	*(int)
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
points_upper	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
widths_upper	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
pts_upper	*(struct(int,int))
=	O
points_upper	*(struct(int,int))
;	O
wids_upper	*(int)
=	O
widths_upper	*(int)
;	O
points_lower	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
widths_lower	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
pts_lower	*(struct(int,int))
=	O
points_lower	*(struct(int,int))
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
;	O
wids_lower	*(int)
=	O
widths_lower	*(int)
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
;	O
miFillArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int)))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
)	O
;	O
MIFILLARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
ADDSPANS	O
(	O
pts_upper	*(struct(int,int))
,	O
pts_lower	*(struct(int,int))
,	O
wids_upper	*(int)
,	O
wids_lower	*(int)
,	O
x	double
,	O
y	double
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xorg	int
,	O
yorg	int
,	O
dy	int
)	O
;	O
}	O
numUpperSpans	int
=	O
pts_upper	*(struct(int,int))
-	O
points_upper	*(struct(int,int))
;	O
numLowerSpans	int
=	O
points_lower	*(struct(int,int))
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
-	O
pts_lower	*(struct(int,int))
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	*(struct(int,int))
,	O
widths_upper	*(int)
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	*(struct(int,int))
+	O
1	int
,	O
wids_lower	*(int)
+	O
1	int
)	O
free	(*(void))->(void)
(	O
points_lower	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
widths_lower	*(int)
)	O
;	O
}	O
static	O
void	O
miFillEllipseD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
{	O
int	O
x	double
,	O
y	double
;	O
int	O
xorg	int
,	O
yorg	int
,	O
dx	int
,	O
dy	int
,	O
slw	int
;	O
double	O
e	int
,	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
;	O
miFillArcD	struct(int,int,int,int,int,double,double,double,double,double)
info	*(struct(*(char),char,char,char))
;	O
miPoint	struct(int,int)
*	O
points_upper	*(struct(int,int))
,	O
*	O
points_lower	*(struct(int,int))
,	O
*	O
pts_upper	*(struct(int,int))
,	O
*	O
pts_lower	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths_upper	*(int)
,	O
*	O
widths_lower	*(int)
,	O
*	O
wids_upper	*(int)
,	O
*	O
wids_lower	*(int)
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
points_upper	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
widths_upper	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
pts_upper	*(struct(int,int))
=	O
points_upper	*(struct(int,int))
;	O
wids_upper	*(int)
=	O
widths_upper	*(int)
;	O
points_lower	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
widths_lower	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
;	O
pts_lower	*(struct(int,int))
=	O
points_lower	*(struct(int,int))
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
;	O
wids_lower	*(int)
=	O
widths_lower	*(int)
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
;	O
miFillArcDSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,double,double,double,double,double)))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
)	O
;	O
MIFILLARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
ADDSPANS	O
(	O
pts_upper	*(struct(int,int))
,	O
pts_lower	*(struct(int,int))
,	O
wids_upper	*(int)
,	O
wids_lower	*(int)
,	O
x	double
,	O
y	double
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xorg	int
,	O
yorg	int
,	O
dy	int
)	O
;	O
}	O
numUpperSpans	int
=	O
pts_upper	*(struct(int,int))
-	O
points_upper	*(struct(int,int))
;	O
numLowerSpans	int
=	O
points_lower	*(struct(int,int))
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
-	O
1	int
)	O
-	O
pts_lower	*(struct(int,int))
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	*(struct(int,int))
,	O
widths_upper	*(int)
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	*(struct(int,int))
+	O
1	int
,	O
wids_lower	*(int)
+	O
1	int
)	O
free	(*(void))->(void)
(	O
points_lower	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
widths_lower	*(int)
)	O
;	O
}	O
static	O
void	O
miFillArcSliceI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
{	O
int	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
,	O
slw	int
,	O
orig_slw	int
;	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
miFillArc	struct(int,int,int,int,int,int,int,int,int,int)
info	*(struct(*(char),char,char,char))
;	O
miArcSlice	struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
;	O
int	O
ya	int
,	O
xl	int
,	O
xr	int
;	O
miPoint	struct(int,int)
*	O
points_upper	*(struct(int,int))
,	O
*	O
points_lower	*(struct(int,int))
,	O
*	O
pts_upper	*(struct(int,int))
,	O
*	O
pts_lower	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths_upper	*(int)
,	O
*	O
widths_lower	*(int)
,	O
*	O
wids_upper	*(int)
,	O
*	O
wids_lower	*(int)
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
miFillArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int)))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
)	O
;	O
miFillArcSliceSetup	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))))->(void)
(	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
;	O
MIFILLARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
slw	int
=	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
if	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_top	enum(int,int)
||	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_bot	enum(int,int)
)	O
slw	int
+=	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
+	O
1	int
;	O
orig_slw	int
=	O
slw	int
;	O
points_upper	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
slw	int
)	O
;	O
widths_upper	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_upper	*(struct(int,int))
=	O
points_upper	*(struct(int,int))
;	O
wids_upper	*(int)
=	O
widths_upper	*(int)
;	O
points_lower	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
slw	int
)	O
;	O
widths_lower	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_lower	*(struct(int,int))
=	O
points_lower	*(struct(int,int))
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
wids_lower	*(int)
=	O
widths_lower	*(int)
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
edge1	struct(int,int,int,int,int,int)
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
edge2	struct(int,int,int,int,int,int)
)	O
;	O
if	O
(	O
MIFILLSLICEUPPER	O
(	O
y	double
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
)	O
{	O
bool	enum(int,int)
lower	enum(int,int)
=	O
false	int
;	O
ya	int
=	O
yorg	int
-	O
y	double
;	O
MIARCSLICEUPPER	O
(	O
xl	int
,	O
xr	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_upper	*(struct(int,int))
,	O
wids_upper	*(int)
,	O
lower	enum(int,int)
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_top	enum(int,int)
)	O
}	O
if	O
(	O
MIFILLSLICELOWER	O
(	O
y	double
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
)	O
{	O
bool	enum(int,int)
lower	enum(int,int)
=	O
true	int
;	O
ya	int
=	O
yorg	int
+	O
y	double
+	O
dy	int
;	O
MIARCSLICELOWER	O
(	O
xl	int
,	O
xr	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_lower	*(struct(int,int))
,	O
wids_lower	*(int)
,	O
lower	enum(int,int)
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_bot	enum(int,int)
)	O
}	O
}	O
numUpperSpans	int
=	O
pts_upper	*(struct(int,int))
-	O
points_upper	*(struct(int,int))
;	O
numLowerSpans	int
=	O
points_lower	*(struct(int,int))
+	O
(	O
orig_slw	int
-	O
1	int
)	O
-	O
pts_lower	*(struct(int,int))
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	*(struct(int,int))
,	O
widths_upper	*(int)
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	*(struct(int,int))
+	O
1	int
,	O
wids_lower	*(int)
+	O
1	int
)	O
free	(*(void))->(void)
(	O
points_lower	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
widths_lower	*(int)
)	O
;	O
}	O
static	O
void	O
miFillArcSliceD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
)	O
{	O
int	O
x	double
,	O
y	double
;	O
int	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
,	O
slw	int
,	O
orig_slw	int
;	O
double	O
e	int
,	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
;	O
miFillArcD	struct(int,int,int,int,int,double,double,double,double,double)
info	*(struct(*(char),char,char,char))
;	O
miArcSlice	struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
;	O
int	O
ya	int
,	O
xl	int
,	O
xr	int
;	O
miPoint	struct(int,int)
*	O
points_upper	*(struct(int,int))
,	O
*	O
points_lower	*(struct(int,int))
,	O
*	O
pts_upper	*(struct(int,int))
,	O
*	O
pts_lower	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths_upper	*(int)
,	O
*	O
widths_lower	*(int)
,	O
*	O
wids_upper	*(int)
,	O
*	O
wids_lower	*(int)
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
miFillArcDSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,double,double,double,double,double)))->(void)
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
)	O
;	O
miFillArcSliceSetup	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int))))->(void)
(	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
;	O
MIFILLARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
slw	int
=	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
if	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_top	enum(int,int)
||	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_bot	enum(int,int)
)	O
slw	int
+=	O
(	O
int	O
)	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
+	O
1	int
;	O
orig_slw	int
=	O
slw	int
;	O
points_upper	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
slw	int
)	O
;	O
widths_upper	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_upper	*(struct(int,int))
=	O
points_upper	*(struct(int,int))
;	O
wids_upper	*(int)
=	O
widths_upper	*(int)
;	O
points_lower	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
slw	int
)	O
;	O
widths_lower	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_lower	*(struct(int,int))
=	O
points_lower	*(struct(int,int))
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
wids_lower	*(int)
=	O
widths_lower	*(int)
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
edge1	struct(int,int,int,int,int,int)
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
edge2	struct(int,int,int,int,int,int)
)	O
;	O
if	O
(	O
MIFILLSLICEUPPER	O
(	O
y	double
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
)	O
{	O
bool	enum(int,int)
lower	enum(int,int)
=	O
false	int
;	O
ya	int
=	O
yorg	int
-	O
y	double
;	O
MIARCSLICEUPPER	O
(	O
xl	int
,	O
xr	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_upper	*(struct(int,int))
,	O
wids_upper	*(int)
,	O
lower	enum(int,int)
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_top	enum(int,int)
)	O
}	O
if	O
(	O
MIFILLSLICELOWER	O
(	O
y	double
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
)	O
)	O
{	O
bool	enum(int,int)
lower	enum(int,int)
=	O
true	int
;	O
ya	int
=	O
yorg	int
+	O
y	double
+	O
dy	int
;	O
MIARCSLICELOWER	O
(	O
xl	int
,	O
xr	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_lower	*(struct(int,int))
,	O
wids_lower	*(int)
,	O
lower	enum(int,int)
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	*(struct(struct(int,int,int,int,int,int),struct(int,int,int,int,int,int),int,int,int,int,enum(int,int),enum(int,int),enum(int,int),enum(int,int)))
.	O
flip_bot	enum(int,int)
)	O
}	O
}	O
numUpperSpans	int
=	O
pts_upper	*(struct(int,int))
-	O
points_upper	*(struct(int,int))
;	O
numLowerSpans	int
=	O
points_lower	*(struct(int,int))
+	O
(	O
orig_slw	int
-	O
1	int
)	O
-	O
pts_lower	*(struct(int,int))
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	*(struct(int,int))
,	O
widths_upper	*(int)
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	*(struct(int,int))
+	O
1	int
,	O
wids_lower	*(int)
+	O
1	int
)	O
free	(*(void))->(void)
(	O
points_lower	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
widths_lower	*(int)
)	O
;	O
}	O
void	O
miFillArcs_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
narcs	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parcs	*(struct(int,int,int,int,int,int))
)	O
{	O
int	O
i	int
;	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
;	O
for	O
(	O
i	int
=	O
narcs	int
,	O
arc	*(struct(int,int,int,int,int,int))
=	O
parcs	*(struct(int,int,int,int,int,int))
;	O
--	O
i	int
>=	O
0	int
;	O
arc	*(struct(int,int,int,int,int,int))
++	O
)	O
{	O
if	O
(	O
MI_FILLED_ARC_IS_EMPTY	O
(	O
arc	*(struct(int,int,int,int,int,int))
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
||	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
<=	O
-	O
FULLCIRCLE	O
)	O
)	O
{	O
if	O
(	O
MI_CAN_FILL_ARC	O
(	O
arc	*(struct(int,int,int,int,int,int))
)	O
)	O
miFillEllipseI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
else	O
miFillEllipseD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
MI_CAN_FILL_ARC	O
(	O
arc	*(struct(int,int,int,int,int,int))
)	O
)	O
miFillArcSliceI	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
else	O
miFillArcSliceD	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
)	O
;	O
}	O
}	O
}	O
