extern	O
char	O
*	O
program_name	*(char)
;	O
enum	O
sect_e	enum(int,int,int)
{	O
info	int
=	O
0	int
,	O
ea	int
=	O
1	int
,	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
=	O
2	int
}	O
;	O
static	O
void	O
syntax_error	(*(char),int,*(char))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
unsigned	O
int	O
linenum	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
TEXINFO_PRINTFLIKE	O
(	O
3	int
,	O
4	int
)	O
;	O
static	O
int	O
lookup_action	(*(char))->(int)
(	O
const	O
char	O
*	O
actname	*(char)
)	O
;	O
int	O
compile	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(int),*(int))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
suppress_info	*(int)
,	O
int	O
*	O
suppress_ea	*(int)
)	O
{	O
int	O
error	*(char)
=	O
0	int
;	O
char	O
rescan	char
=	O
0	int
;	O
unsigned	O
int	O
lnum	int
=	O
0	int
;	O
int	O
c	int
=	O
0	int
;	O
enum	O
{	O
start_of_line	int
,	O
start_of_comment	int
,	O
in_line_comment	int
,	O
in_trailing_comment	int
,	O
get_keyseq	int
,	O
got_keyseq	int
,	O
get_action	int
,	O
got_action	int
,	O
get_varname	int
,	O
got_varname	int
,	O
get_equals	int
,	O
got_equals	int
,	O
get_value	int
}	O
state	*(int)
=	O
start_of_line	int
;	O
enum	O
sect_e	enum(int,int,int)
section	enum(int,int,int)
=	O
info	int
;	O
enum	O
{	O
normal	int
,	O
slosh	int
,	O
control	int
,	O
octal	int
,	O
special_key	int
}	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
char	O
meta	char
=	O
0	int
;	O
char	O
ocnt	char
=	O
0	int
;	O
char	O
oval	char
=	O
0	int
;	O
char	O
comment	array(char)
[	O
10	int
]	O
;	O
unsigned	O
int	O
clen	int
=	O
0	int
;	O
int	O
seq	array(int)
[	O
20	int
]	O
;	O
unsigned	O
int	O
slen	int
=	O
0	int
;	O
char	O
act	array(char)
[	O
80	int
]	O
;	O
unsigned	O
int	O
alen	int
=	O
0	int
;	O
char	O
varn	array(char)
[	O
80	int
]	O
;	O
unsigned	O
int	O
varlen	int
=	O
0	int
;	O
char	O
val	int
[	O
80	int
]	O
;	O
unsigned	O
int	O
vallen	int
=	O
0	int
;	O
while	O
(	O
!	O
error	*(char)
&&	O
(	O
rescan	char
||	O
(	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
)	O
{	O
rescan	char
=	O
0	int
;	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
start_of_line	int
:	O
lnum	int
++	O
;	O
if	O
(	O
c	int
==	O
'#'	O
)	O
state	*(int)
=	O
start_of_comment	int
;	O
else	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
{	O
switch	O
(	O
section	enum(int,int,int)
)	O
{	O
case	O
info	int
:	O
case	O
ea	int
:	O
state	*(int)
=	O
get_keyseq	int
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
slen	int
=	O
0	int
;	O
break	O
;	O
case	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
:	O
state	*(int)
=	O
get_varname	int
;	O
varlen	int
=	O
0	int
;	O
break	O
;	O
}	O
rescan	char
=	O
1	int
;	O
}	O
break	O
;	O
case	O
start_of_comment	int
:	O
clen	int
=	O
0	int
;	O
state	*(int)
=	O
in_line_comment	int
;	O
case	O
in_line_comment	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
state	*(int)
=	O
start_of_line	int
;	O
comment	array(char)
[	O
clen	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
comment	array(char)
,	O
"info"	*(char)
)	O
==	O
0	int
)	O
section	enum(int,int,int)
=	O
info	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
comment	array(char)
,	O
"echo-area"	*(char)
)	O
==	O
0	int
)	O
section	enum(int,int,int)
=	O
ea	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
comment	array(char)
,	O
"var"	*(char)
)	O
==	O
0	int
)	O
section	enum(int,int,int)
=	O
var	*(struct(*(char),*(char),*(void),*(*(char)),int))
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
comment	array(char)
,	O
"stop"	*(char)
)	O
==	O
0	int
&&	O
(	O
section	enum(int,int,int)
==	O
info	int
||	O
section	enum(int,int,int)
==	O
ea	int
)	O
)	O
{	O
if	O
(	O
section	enum(int,int,int)
==	O
info	int
)	O
*	O
suppress_info	*(int)
=	O
1	int
;	O
else	O
*	O
suppress_ea	*(int)
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
clen	int
<	O
sizeof	O
comment	array(char)
-	O
1	int
)	O
comment	array(char)
[	O
clen	int
++	O
]	O
=	O
c	int
;	O
break	O
;	O
case	O
in_trailing_comment	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	*(int)
=	O
start_of_line	int
;	O
break	O
;	O
case	O
get_keyseq	int
:	O
switch	O
(	O
seqstate	enum(int,int,int,int,int)
)	O
{	O
case	O
normal	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
{	O
state	*(int)
=	O
got_keyseq	int
;	O
rescan	char
=	O
1	int
;	O
if	O
(	O
slen	int
==	O
0	int
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"missing key sequence"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
seqstate	enum(int,int,int,int,int)
=	O
slosh	int
;	O
else	O
if	O
(	O
c	int
==	O
'^'	O
)	O
seqstate	enum(int,int,int,int,int)
=	O
control	int
;	O
else	O
To_seq	O
(	O
c	int
)	O
;	O
break	O
;	O
case	O
slosh	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
seqstate	enum(int,int,int,int,int)
=	O
octal	int
;	O
oval	char
=	O
c	int
-	O
'0'	O
;	O
ocnt	char
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
To_seq	O
(	O
'\b'	O
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
'e'	O
:	O
To_seq	O
(	O
'\033'	O
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
'n'	O
:	O
To_seq	O
(	O
'\n'	O
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
'r'	O
:	O
To_seq	O
(	O
'\r'	O
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
't'	O
:	O
To_seq	O
(	O
'\t'	O
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
'm'	O
:	O
meta	char
=	O
1	int
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
'k'	O
:	O
seqstate	enum(int,int,int,int,int)
=	O
special_key	int
;	O
break	O
;	O
default	O
:	O
To_seq	O
(	O
c	int
)	O
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
octal	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
if	O
(	O
++	O
ocnt	char
<=	O
3	int
)	O
oval	char
=	O
oval	char
*	O
8	int
+	O
c	int
-	O
'0'	O
;	O
if	O
(	O
ocnt	char
==	O
3	int
)	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
default	O
:	O
ocnt	char
=	O
4	int
;	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
rescan	char
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
seqstate	enum(int,int,int,int,int)
!=	O
octal	int
)	O
{	O
if	O
(	O
oval	char
)	O
To_seq	O
(	O
oval	char
)	O
;	O
else	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"NUL character (\\000) not permitted"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
special_key	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'u'	O
:	O
To_seq	O
(	O
KEY_UP_ARROW	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
To_seq	O
(	O
KEY_DOWN_ARROW	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
To_seq	O
(	O
KEY_RIGHT_ARROW	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
To_seq	O
(	O
KEY_LEFT_ARROW	int
)	O
;	O
break	O
;	O
case	O
'U'	O
:	O
To_seq	O
(	O
KEY_PAGE_UP	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
To_seq	O
(	O
KEY_PAGE_DOWN	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
To_seq	O
(	O
KEY_HOME	int
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
To_seq	O
(	O
KEY_END	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
To_seq	O
(	O
KEY_DELETE	int
)	O
;	O
break	O
;	O
default	O
:	O
To_seq	O
(	O
c	int
)	O
;	O
rescan	char
=	O
1	int
;	O
break	O
;	O
}	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
case	O
control	int
:	O
if	O
(	O
CONTROL	O
(	O
c	int
)	O
)	O
To_seq	O
(	O
CONTROL	O
(	O
c	int
)	O
)	O
;	O
else	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"NUL character (^%c) not permitted"	*(char)
)	O
,	O
c	int
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
seqstate	enum(int,int,int,int,int)
=	O
normal	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
got_keyseq	int
:	O
if	O
(	O
isspace	(int)->(int)
(	O
c	int
)	O
&&	O
c	int
!=	O
'\n'	O
)	O
break	O
;	O
state	*(int)
=	O
get_action	int
;	O
alen	int
=	O
0	int
;	O
case	O
get_action	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
{	O
int	O
a	int
;	O
state	*(int)
=	O
got_action	int
;	O
rescan	char
=	O
1	int
;	O
if	O
(	O
alen	int
==	O
0	int
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"missing action name"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
else	O
{	O
int	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(int)
(	O
Keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
int	O
*	O
,	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
*	O
)	O
;	O
act	array(char)
[	O
alen	int
]	O
=	O
'\0'	O
;	O
a	int
=	O
lookup_action	(*(char))->(int)
(	O
act	array(char)
)	O
;	O
if	O
(	O
a	int
==	O
A_info_menu_digit	int
)	O
{	O
if	O
(	O
seq	array(int)
[	O
0	int
]	O
!=	O
'1'	O
||	O
seq	array(int)
[	O
1	int
]	O
!=	O
'\0'	O
||	O
section	enum(int,int,int)
!=	O
info	int
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"cannot bind key sequence to menu-digit"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
;	O
int	O
i	int
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
&	O
function_doc_array	array(struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char)))
[	O
a	int
]	O
;	O
for	O
(	O
i	int
=	O
'1'	O
;	O
i	int
<=	O
'9'	O
;	O
i	int
++	O
)	O
{	O
seq	array(int)
[	O
0	int
]	O
=	O
i	int
;	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(int)
(	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
seq	array(int)
,	O
&	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
a	int
==	O
-	O
1	int
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"unknown action `%s'"	*(char)
)	O
,	O
act	array(char)
)	O
;	O
}	O
else	O
{	O
KEYMAP_ENTRY	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
;	O
static	O
InfoCommand	struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char))
invalid_function	struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct(char,union`)),*(int))),*(char))
=	O
{	O
0	int
}	O
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
type	enum(int,int,int,int)
=	O
ISFUNC	int
;	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
.	O
value	union(*(struct(*(()->(void)),*(char),*(struct(*`,*`,*`)),*(char))),*(struct(char,union(*(struct`),*(struct`)))))
.	O
function	*(struct(*(()->(void)),*(char),*(struct(*(struct`),*(struct`),*(int))),*(char)))
=	O
a	int
!=	O
A_INVALID	int
?	O
&	O
function_doc_array	array(struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char)))
[	O
a	int
]	O
:	O
&	O
invalid_function	struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct(char,union`)),*(int))),*(char))
;	O
To_seq	O
(	O
0	int
)	O
;	O
if	O
(	O
section	enum(int,int,int)
==	O
info	int
)	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(int)
(	O
info_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
seq	array(int)
,	O
&	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
)	O
;	O
else	O
keymap_bind_keyseq	(*(struct(char,union(*(struct`),*(struct`)))),*(int),*(struct(char,union(*(struct`),*(struct`)))))->(int)
(	O
echo_area_keymap	*(struct(char,union(*(struct(*`,*`,*`,*`)),*(struct(char,union`)))))
,	O
seq	array(int)
,	O
&	O
ke	struct(char,union(*(struct(*(()->(void)),*(char),*(struct`),*(char))),*(struct(char,union(*`,*`)))))
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
alen	int
<	O
sizeof	O
act	array(char)
-	O
1	int
)	O
act	array(char)
[	O
alen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"action name too long"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
break	O
;	O
case	O
got_action	int
:	O
if	O
(	O
c	int
==	O
'#'	O
)	O
state	*(int)
=	O
in_trailing_comment	int
;	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	*(int)
=	O
start_of_line	int
;	O
else	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"extra characters following action `%s'"	*(char)
)	O
,	O
act	array(char)
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_varname	int
:	O
if	O
(	O
c	int
==	O
'='	O
)	O
{	O
if	O
(	O
varlen	int
==	O
0	int
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"missing variable name"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
state	*(int)
=	O
get_value	int
;	O
vallen	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"missing `=' immediately after variable name"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
else	O
if	O
(	O
varlen	int
<	O
sizeof	O
varn	array(char)
-	O
1	int
)	O
varn	array(char)
[	O
varlen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"variable name too long"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_value	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
VARIABLE_ALIST	struct(*(char),*(char),*(void),*(*(char)),int)
*	O
v	*(struct(*(char),*(char),*(void),*(*(char)),int))
;	O
state	*(int)
=	O
start_of_line	int
;	O
varn	array(char)
[	O
varlen	int
]	O
=	O
'\0'	O
;	O
val	int
[	O
vallen	int
]	O
=	O
'\0'	O
;	O
v	*(struct(*(char),*(char),*(void),*(*(char)),int))
=	O
variable_by_name	(*(char))->(*(struct(*(char),*(char),*(void),*(*(char)),int)))
(	O
varn	array(char)
)	O
;	O
if	O
(	O
!	O
v	*(struct(*(char),*(char),*(void),*(*(char)),int))
)	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"%s: no such variable"	*(char)
)	O
,	O
varn	array(char)
)	O
;	O
else	O
if	O
(	O
!	O
set_variable_to_value	(*(struct(*(char),*(char),*(void),*(*(char)),int)),*(char),int)->(int)
(	O
v	*(struct(*(char),*(char),*(void),*(*(char)),int))
,	O
val	int
,	O
SET_IN_CONFIG_FILE	int
)	O
)	O
info_error	(*(char))->(void)
(	O
_	O
(	O
"value %s is not valid for variable %s"	*(char)
)	O
,	O
val	int
,	O
varn	array(char)
)	O
;	O
}	O
else	O
if	O
(	O
vallen	int
<	O
sizeof	O
val	int
-	O
1	int
)	O
val	int
[	O
vallen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	(*(char),int,*(char))->(void)
(	O
filename	*(char)
,	O
lnum	int
,	O
_	O
(	O
"value too long"	*(char)
)	O
)	O
;	O
error	*(char)
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_equals	int
:	O
case	O
got_equals	int
:	O
case	O
got_varname	int
:	O
break	O
;	O
}	O
}	O
return	O
!	O
error	*(char)
;	O
}	O
static	O
int	O
lookup_action	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"invalid"	*(char)
)	O
)	O
return	O
A_INVALID	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
function_doc_array	array(struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char)))
[	O
i	int
]	O
.	O
func_name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
function_doc_array	array(struct(*(()->(void)),*(char),*(struct(*(struct(*`,*`,*`)),*(struct),*(int))),*(char)))
[	O
i	int
]	O
.	O
func_name	*(char)
,	O
name	*(char)
)	O
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
syntax_error	(*(char),int,*(char))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
unsigned	O
int	O
linenum	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
program_name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\"%s\", line %u: "	*(char)
)	O
,	O
filename	*(char)
,	O
linenum	int
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
