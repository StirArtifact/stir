struct	O
cmdname	struct(*(char),int)
{	O
char	O
*	O
cn_name	*(char)
;	O
int	O
cn_action	int
;	O
}	O
;	O
struct	O
cmdname	struct(*(char),int)
cmdnames	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"back-bracket"	*(char)
,	O
A_B_BRACKET	int
}	O
,	O
{	O
"back-line"	*(char)
,	O
A_B_LINE	int
}	O
,	O
{	O
"back-line-force"	*(char)
,	O
A_BF_LINE	int
}	O
,	O
{	O
"back-screen"	*(char)
,	O
A_B_SCREEN	int
}	O
,	O
{	O
"back-scroll"	*(char)
,	O
A_B_SCROLL	int
}	O
,	O
{	O
"back-search"	*(char)
,	O
A_B_SEARCH	int
}	O
,	O
{	O
"back-window"	*(char)
,	O
A_B_WINDOW	int
}	O
,	O
{	O
"clear-mark"	*(char)
,	O
A_CLRMARK	int
}	O
,	O
{	O
"debug"	*(char)
,	O
A_DEBUG	int
}	O
,	O
{	O
"digit"	*(char)
,	O
A_DIGIT	int
}	O
,	O
{	O
"display-flag"	*(char)
,	O
A_DISP_OPTION	int
}	O
,	O
{	O
"display-option"	*(char)
,	O
A_DISP_OPTION	int
}	O
,	O
{	O
"end"	*(char)
,	O
A_GOEND	int
}	O
,	O
{	O
"end-scroll"	*(char)
,	O
A_RRSHIFT	int
}	O
,	O
{	O
"examine"	*(char)
,	O
A_EXAMINE	int
}	O
,	O
{	O
"filter"	*(char)
,	O
A_FILTER	int
}	O
,	O
{	O
"first-cmd"	*(char)
,	O
A_FIRSTCMD	int
}	O
,	O
{	O
"firstcmd"	*(char)
,	O
A_FIRSTCMD	int
}	O
,	O
{	O
"flush-repaint"	*(char)
,	O
A_FREPAINT	int
}	O
,	O
{	O
"forw-bracket"	*(char)
,	O
A_F_BRACKET	int
}	O
,	O
{	O
"forw-forever"	*(char)
,	O
A_F_FOREVER	int
}	O
,	O
{	O
"forw-until-hilite"	*(char)
,	O
A_F_UNTIL_HILITE	int
}	O
,	O
{	O
"forw-line"	*(char)
,	O
A_F_LINE	int
}	O
,	O
{	O
"forw-line-force"	*(char)
,	O
A_FF_LINE	int
}	O
,	O
{	O
"forw-screen"	*(char)
,	O
A_F_SCREEN	int
}	O
,	O
{	O
"forw-screen-force"	*(char)
,	O
A_FF_SCREEN	int
}	O
,	O
{	O
"forw-scroll"	*(char)
,	O
A_F_SCROLL	int
}	O
,	O
{	O
"forw-search"	*(char)
,	O
A_F_SEARCH	int
}	O
,	O
{	O
"forw-window"	*(char)
,	O
A_F_WINDOW	int
}	O
,	O
{	O
"goto-end"	*(char)
,	O
A_GOEND	int
}	O
,	O
{	O
"goto-end-buffered"	*(char)
,	O
A_GOEND_BUF	int
}	O
,	O
{	O
"goto-line"	*(char)
,	O
A_GOLINE	int
}	O
,	O
{	O
"goto-mark"	*(char)
,	O
A_GOMARK	int
}	O
,	O
{	O
"help"	*(char)
,	O
A_HELP	int
}	O
,	O
{	O
"index-file"	*(char)
,	O
A_INDEX_FILE	int
}	O
,	O
{	O
"invalid"	*(char)
,	O
A_UINVALID	int
}	O
,	O
{	O
"left-scroll"	*(char)
,	O
A_LSHIFT	int
}	O
,	O
{	O
"next-file"	*(char)
,	O
A_NEXT_FILE	int
}	O
,	O
{	O
"next-tag"	*(char)
,	O
A_NEXT_TAG	int
}	O
,	O
{	O
"noaction"	*(char)
,	O
A_NOACTION	int
}	O
,	O
{	O
"no-scroll"	*(char)
,	O
A_LLSHIFT	int
}	O
,	O
{	O
"percent"	*(char)
,	O
A_PERCENT	int
}	O
,	O
{	O
"pipe"	*(char)
,	O
A_PIPE	int
}	O
,	O
{	O
"prev-file"	*(char)
,	O
A_PREV_FILE	int
}	O
,	O
{	O
"prev-tag"	*(char)
,	O
A_PREV_TAG	int
}	O
,	O
{	O
"quit"	*(char)
,	O
A_QUIT	int
}	O
,	O
{	O
"remove-file"	*(char)
,	O
A_REMOVE_FILE	int
}	O
,	O
{	O
"repaint"	*(char)
,	O
A_REPAINT	int
}	O
,	O
{	O
"repaint-flush"	*(char)
,	O
A_FREPAINT	int
}	O
,	O
{	O
"repeat-search"	*(char)
,	O
A_AGAIN_SEARCH	int
}	O
,	O
{	O
"repeat-search-all"	*(char)
,	O
A_T_AGAIN_SEARCH	int
}	O
,	O
{	O
"reverse-search"	*(char)
,	O
A_REVERSE_SEARCH	int
}	O
,	O
{	O
"reverse-search-all"	*(char)
,	O
A_T_REVERSE_SEARCH	int
}	O
,	O
{	O
"right-scroll"	*(char)
,	O
A_RSHIFT	int
}	O
,	O
{	O
"set-mark"	*(char)
,	O
A_SETMARK	int
}	O
,	O
{	O
"set-mark-bottom"	*(char)
,	O
A_SETMARKBOT	int
}	O
,	O
{	O
"shell"	*(char)
,	O
A_SHELL	int
}	O
,	O
{	O
"status"	*(char)
,	O
A_STAT	int
}	O
,	O
{	O
"toggle-flag"	*(char)
,	O
A_OPT_TOGGLE	int
}	O
,	O
{	O
"toggle-option"	*(char)
,	O
A_OPT_TOGGLE	int
}	O
,	O
{	O
"undo-hilite"	*(char)
,	O
A_UNDO_SEARCH	int
}	O
,	O
{	O
"version"	*(char)
,	O
A_VERSION	int
}	O
,	O
{	O
"visual"	*(char)
,	O
A_VISUAL	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
struct	O
cmdname	struct(*(char),int)
editnames	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"back-complete"	*(char)
,	O
EC_B_COMPLETE	int
}	O
,	O
{	O
"backspace"	*(char)
,	O
EC_BACKSPACE	int
}	O
,	O
{	O
"delete"	*(char)
,	O
EC_DELETE	int
}	O
,	O
{	O
"down"	*(char)
,	O
EC_DOWN	int
}	O
,	O
{	O
"end"	*(char)
,	O
EC_END	int
}	O
,	O
{	O
"expand"	*(char)
,	O
EC_EXPAND	int
}	O
,	O
{	O
"forw-complete"	*(char)
,	O
EC_F_COMPLETE	int
}	O
,	O
{	O
"home"	*(char)
,	O
EC_HOME	int
}	O
,	O
{	O
"insert"	*(char)
,	O
EC_INSERT	int
}	O
,	O
{	O
"invalid"	*(char)
,	O
EC_UINVALID	int
}	O
,	O
{	O
"kill-line"	*(char)
,	O
EC_LINEKILL	int
}	O
,	O
{	O
"abort"	*(char)
,	O
EC_ABORT	int
}	O
,	O
{	O
"left"	*(char)
,	O
EC_LEFT	int
}	O
,	O
{	O
"literal"	*(char)
,	O
EC_LITERAL	int
}	O
,	O
{	O
"right"	*(char)
,	O
EC_RIGHT	int
}	O
,	O
{	O
"up"	*(char)
,	O
EC_UP	int
}	O
,	O
{	O
"word-backspace"	*(char)
,	O
EC_W_BACKSPACE	int
}	O
,	O
{	O
"word-delete"	*(char)
,	O
EC_W_DELETE	int
}	O
,	O
{	O
"word-left"	*(char)
,	O
EC_W_LEFT	int
}	O
,	O
{	O
"word-right"	*(char)
,	O
EC_W_RIGHT	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
struct	O
table	*(struct(long,long))
{	O
struct	O
cmdname	struct(*(char),int)
*	O
names	*(struct(*(char),int))
;	O
char	O
*	O
pbuffer	*(char)
;	O
char	O
buffer	array(char)
[	O
MAX_USERCMD	int
]	O
;	O
}	O
;	O
struct	O
table	*(struct(long,long))
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
struct	O
table	*(struct(long,long))
edittable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
struct	O
table	*(struct(long,long))
vartable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
struct	O
table	*(struct(long,long))
*	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
=	O
&	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
char	O
fileheader	array(char)
[	O
]	O
=	O
{	O
C0_LESSKEY_MAGIC	char
,	O
C1_LESSKEY_MAGIC	char
,	O
C2_LESSKEY_MAGIC	char
,	O
C3_LESSKEY_MAGIC	char
}	O
;	O
char	O
filetrailer	array(char)
[	O
]	O
=	O
{	O
C0_END_LESSKEY_MAGIC	char
,	O
C1_END_LESSKEY_MAGIC	char
,	O
C2_END_LESSKEY_MAGIC	char
}	O
;	O
char	O
cmdsection	array(char)
[	O
1	int
]	O
=	O
{	O
CMD_SECTION	char
}	O
;	O
char	O
editsection	array(char)
[	O
1	int
]	O
=	O
{	O
EDIT_SECTION	char
}	O
;	O
char	O
varsection	array(char)
[	O
1	int
]	O
=	O
{	O
VAR_SECTION	char
}	O
;	O
char	O
endsection	array(char)
[	O
1	int
]	O
=	O
{	O
END_SECTION	char
}	O
;	O
char	O
*	O
infile	*(char)
=	O
NULL	O
;	O
char	O
*	O
outfile	*(char)
=	O
NULL	O
;	O
int	O
linenum	long
;	O
int	O
errors	int
;	O
extern	O
char	O
version	array(char)
[	O
]	O
;	O
void	O
usage	()->(void)
(	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: lesskey [-o output] [input]\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
char	O
*	O
mkpathname	(*(char),*(char))->(*(char))
(	O
dirname	*(char)
,	O
filename	*(char)
)	O
char	O
*	O
dirname	*(char)
;	O
char	O
*	O
filename	*(char)
;	O
{	O
char	O
*	O
pathname	*(char)
;	O
pathname	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
2	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pathname	*(char)
,	O
dirname	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
pathname	*(char)
,	O
PATHNAME_SEP	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
pathname	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
(	O
pathname	*(char)
)	O
;	O
}	O
char	O
*	O
homefile	(*(char))->(*(char))
(	O
filename	*(char)
)	O
char	O
*	O
filename	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
pathname	*(char)
;	O
if	O
(	O
(	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
!=	O
NULL	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
pathname	*(char)
=	O
mkpathname	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
filename	*(char)
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"cannot find $HOME - using current directory\n"	*(char)
)	O
;	O
pathname	*(char)
=	O
mkpathname	(*(char),*(char))->(*(char))
(	O
"."	*(char)
,	O
filename	*(char)
)	O
;	O
}	O
return	O
(	O
pathname	*(char)
)	O
;	O
}	O
void	O
parse_args	(int,*(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
{	O
char	O
*	O
arg	*(char)
;	O
outfile	*(char)
=	O
NULL	O
;	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
arg	*(char)
=	O
*	O
++	O
argv	*(*(char))
;	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
!=	O
'-'	O
)	O
break	O
;	O
if	O
(	O
arg	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
arg	*(char)
[	O
1	int
]	O
==	O
'-'	O
&&	O
arg	*(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
{	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
break	O
;	O
}	O
switch	O
(	O
arg	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	*(char)
,	O
"--output"	*(char)
,	O
8	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
arg	*(char)
[	O
8	int
]	O
==	O
'\0'	O
)	O
outfile	*(char)
=	O
&	O
arg	*(char)
[	O
8	int
]	O
;	O
else	O
if	O
(	O
arg	*(char)
[	O
8	int
]	O
==	O
'='	O
)	O
outfile	*(char)
=	O
&	O
arg	*(char)
[	O
9	int
]	O
;	O
else	O
usage	()->(void)
(	O
)	O
;	O
goto	O
opt_o	(int,*(char))->(void)
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"--version"	*(char)
)	O
==	O
0	int
)	O
{	O
goto	O
opt_V	O
;	O
}	O
usage	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
outfile	*(char)
=	O
&	O
argv	*(*(char))
[	O
0	int
]	O
[	O
2	int
]	O
;	O
opt_o	(int,*(char))->(void)
:	O
if	O
(	O
*	O
outfile	*(char)
==	O
'\0'	O
)	O
{	O
if	O
(	O
--	O
argc	int
<=	O
0	int
)	O
usage	()->(void)
(	O
)	O
;	O
outfile	*(char)
=	O
*	O
(	O
++	O
argv	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
opt_V	O
:	O
printf	(*(char))->(int)
(	O
"lesskey  version %s\n"	*(char)
,	O
version	array(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
>	O
1	int
)	O
usage	()->(void)
(	O
)	O
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
infile	*(char)
=	O
*	O
argv	*(*(char))
;	O
else	O
infile	*(char)
=	O
homefile	(*(char))->(*(char))
(	O
DEF_LESSKEYINFILE	*(char)
)	O
;	O
}	O
void	O
init_tables	()->(void)
(	O
)	O
{	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
names	*(struct(*(char),int))
=	O
cmdnames	array(struct(*(char),int))
;	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
=	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
;	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
names	*(struct(*(char),int))
=	O
editnames	array(struct(*(char),int))
;	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
=	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
;	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
names	*(struct(*(char),int))
=	O
NULL	O
;	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
=	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
;	O
}	O
char	O
*	O
tstr	(*(*(char)),int)->(*(char))
(	O
pp	*(*(char))
,	O
xlate	int
)	O
char	O
*	O
*	O
pp	*(*(char))
;	O
int	O
xlate	int
;	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
ch	long
;	O
int	O
i	int
;	O
static	O
char	O
buf	*(char)
[	O
10	int
]	O
;	O
static	O
char	O
tstr_control_k	array(char)
[	O
]	O
=	O
{	O
SK_SPECIAL_KEY	O
,	O
SK_CONTROL_K	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
'\0'	O
}	O
;	O
p	*(char)
=	O
*	O
pp	*(*(char))
;	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
'\\'	O
:	O
++	O
p	*(char)
;	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
ch	long
=	O
0	int
;	O
i	int
=	O
0	int
;	O
do	O
ch	long
=	O
8	int
*	O
ch	long
+	O
(	O
*	O
p	*(char)
-	O
'0'	O
)	O
;	O
while	O
(	O
*	O
++	O
p	*(char)
>=	O
'0'	O
&&	O
*	O
p	*(char)
<=	O
'7'	O
&&	O
++	O
i	int
<	O
3	int
)	O
;	O
*	O
pp	*(*(char))
=	O
p	*(char)
;	O
if	O
(	O
xlate	int
&&	O
ch	long
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array(char)
;	O
buf	*(char)
[	O
0	int
]	O
=	O
ch	long
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
case	O
'b'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
return	O
(	O
"\b"	*(char)
)	O
;	O
case	O
'e'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
ESC	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
case	O
'n'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
return	O
(	O
"\n"	*(char)
)	O
;	O
case	O
'r'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
return	O
(	O
"\r"	*(char)
)	O
;	O
case	O
't'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
return	O
(	O
"\t"	*(char)
)	O
;	O
case	O
'k'	O
:	O
if	O
(	O
xlate	int
)	O
{	O
switch	O
(	O
*	O
++	O
p	*(char)
)	O
{	O
case	O
'u'	O
:	O
ch	long
=	O
SK_UP_ARROW	int
;	O
break	O
;	O
case	O
'd'	O
:	O
ch	long
=	O
SK_DOWN_ARROW	int
;	O
break	O
;	O
case	O
'r'	O
:	O
ch	long
=	O
SK_RIGHT_ARROW	int
;	O
break	O
;	O
case	O
'l'	O
:	O
ch	long
=	O
SK_LEFT_ARROW	int
;	O
break	O
;	O
case	O
'U'	O
:	O
ch	long
=	O
SK_PAGE_UP	int
;	O
break	O
;	O
case	O
'D'	O
:	O
ch	long
=	O
SK_PAGE_DOWN	int
;	O
break	O
;	O
case	O
'h'	O
:	O
ch	long
=	O
SK_HOME	int
;	O
break	O
;	O
case	O
'e'	O
:	O
ch	long
=	O
SK_END	int
;	O
break	O
;	O
case	O
'x'	O
:	O
ch	long
=	O
SK_DELETE	int
;	O
break	O
;	O
default	O
:	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"illegal char after \\k"	*(char)
,	O
NULL_PARG	O
)	O
;	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
return	O
(	O
""	*(char)
)	O
;	O
}	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
SK_SPECIAL_KEY	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
ch	long
;	O
buf	*(char)
[	O
2	int
]	O
=	O
6	int
;	O
buf	*(char)
[	O
3	int
]	O
=	O
1	int
;	O
buf	*(char)
[	O
4	int
]	O
=	O
1	int
;	O
buf	*(char)
[	O
5	int
]	O
=	O
1	int
;	O
buf	*(char)
[	O
6	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
default	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
*	O
p	*(char)
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
xlate	int
&&	O
buf	*(char)
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array(char)
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
case	O
'^'	O
:	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
2	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
CONTROL	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array(char)
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
*	O
pp	*(*(char))
=	O
p	*(char)
+	O
1	int
;	O
buf	*(char)
[	O
0	int
]	O
=	O
*	O
p	*(char)
;	O
buf	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
xlate	int
&&	O
buf	*(char)
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array(char)
;	O
return	O
(	O
buf	*(char)
)	O
;	O
}	O
public	O
char	O
*	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
while	O
(	O
*	O
s	*(char)
==	O
' '	O
||	O
*	O
s	*(char)
==	O
'\t'	O
)	O
s	*(char)
++	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
public	O
char	O
*	O
skipnsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
&&	O
*	O
s	*(char)
!=	O
' '	O
&&	O
*	O
s	*(char)
!=	O
'\t'	O
)	O
s	*(char)
++	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
char	O
*	O
clean_line	(*(char))->(*(char))
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
int	O
i	int
;	O
s	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
s	*(char)
[	O
i	int
]	O
!=	O
'\n'	O
&&	O
s	*(char)
[	O
i	int
]	O
!=	O
'\r'	O
&&	O
s	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
if	O
(	O
s	*(char)
[	O
i	int
]	O
==	O
'#'	O
&&	O
(	O
i	int
==	O
0	int
||	O
s	*(char)
[	O
i	int
-	O
1	int
]	O
!=	O
'\\'	O
)	O
)	O
break	O
;	O
s	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
void	O
add_cmd_char	(int)->(void)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
pbuffer	*(char)
>=	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
buffer	array(char)
+	O
MAX_USERCMD	int
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"too many commands"	*(char)
,	O
NULL_PARG	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
*	O
(	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
pbuffer	*(char)
)	O
++	O
=	O
c	int
;	O
}	O
void	O
add_cmd_str	(*(char))->(void)
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
'\0'	O
;	O
s	*(char)
++	O
)	O
add_cmd_char	(int)->(void)
(	O
*	O
s	*(char)
)	O
;	O
}	O
int	O
control_line	(*(char))->(int)
(	O
s	*(char)
)	O
char	O
*	O
s	*(char)
;	O
{	O
if	O
(	O
PREFIX	O
(	O
s	*(char)
,	O
"#line-edit"	*(char)
)	O
)	O
{	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
=	O
&	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	*(char)
,	O
"#command"	*(char)
)	O
)	O
{	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
=	O
&	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	*(char)
,	O
"#env"	*(char)
)	O
)	O
{	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
=	O
&	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	*(char)
,	O
"#stop"	*(char)
)	O
)	O
{	O
add_cmd_char	(int)->(void)
(	O
'\0'	O
)	O
;	O
add_cmd_char	(int)->(void)
(	O
A_END_LIST	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
fd	int
,	O
buf	*(char)
,	O
len	int
)	O
FILE	struct
*	O
fd	int
;	O
char	O
*	O
buf	*(char)
;	O
int	O
len	int
;	O
{	O
while	O
(	O
len	int
--	O
>	O
0	int
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
buf	*(char)
++	O
;	O
}	O
}	O
void	O
fputint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
fd	int
,	O
val	int
)	O
FILE	struct
*	O
fd	int
;	O
unsigned	O
int	O
val	int
;	O
{	O
char	O
c	int
;	O
if	O
(	O
val	int
>=	O
KRADIX	int
*	O
KRADIX	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"error: integer too big (%d > %d)\n"	*(char)
,	O
val	int
,	O
KRADIX	int
*	O
KRADIX	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
c	int
=	O
val	int
%	O
KRADIX	int
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
c	int
=	O
val	int
/	O
KRADIX	int
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
}	O
int	O
findaction	(*(char))->(int)
(	O
actname	*(char)
)	O
char	O
*	O
actname	*(char)
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
names	*(struct(*(char),int))
[	O
i	int
]	O
.	O
cn_name	*(char)
!=	O
NULL	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
names	*(struct(*(char),int))
[	O
i	int
]	O
.	O
cn_name	*(char)
,	O
actname	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
->	O
names	*(struct(*(char),int))
[	O
i	int
]	O
.	O
cn_action	int
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"unknown action"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
A_INVALID	int
)	O
;	O
}	O
void	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
s	*(char)
,	O
parg	union(*(char),int,long)
)	O
char	O
*	O
s	*(char)
;	O
PARG	union(*(char),int,long)
*	O
parg	union(*(char),int,long)
;	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"line %d: %s\n"	*(char)
,	O
linenum	long
,	O
s	*(char)
)	O
;	O
errors	int
++	O
;	O
(	O
void	O
)	O
parg	union(*(char),int,long)
;	O
}	O
void	O
parse_cmdline	(*(char))->(void)
(	O
p	*(char)
)	O
char	O
*	O
p	*(char)
;	O
{	O
int	O
cmdlen	int
;	O
char	O
*	O
actname	*(char)
;	O
int	O
action	int
;	O
char	O
*	O
s	*(char)
;	O
char	O
c	int
;	O
cmdlen	int
=	O
0	int
;	O
do	O
{	O
s	*(char)
=	O
tstr	(*(*(char)),int)->(*(char))
(	O
&	O
p	*(char)
,	O
1	int
)	O
;	O
cmdlen	int
+=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
if	O
(	O
cmdlen	int
>	O
MAX_CMDLEN	int
)	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"command too long"	*(char)
,	O
NULL_PARG	O
)	O
;	O
else	O
add_cmd_str	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
}	O
while	O
(	O
*	O
p	*(char)
!=	O
' '	O
&&	O
*	O
p	*(char)
!=	O
'\t'	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
;	O
add_cmd_char	(int)->(void)
(	O
'\0'	O
)	O
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"missing action"	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
actname	*(char)
=	O
p	*(char)
;	O
p	*(char)
=	O
skipnsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
c	int
=	O
*	O
p	*(char)
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
action	int
=	O
findaction	(*(char))->(int)
(	O
actname	*(char)
)	O
;	O
*	O
p	*(char)
=	O
c	int
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
{	O
add_cmd_char	(int)->(void)
(	O
action	int
)	O
;	O
}	O
else	O
{	O
add_cmd_char	(int)->(void)
(	O
action	int
|	O
A_EXTRA	int
)	O
;	O
while	O
(	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
add_cmd_str	(*(char))->(void)
(	O
tstr	(*(*(char)),int)->(*(char))
(	O
&	O
p	*(char)
,	O
0	int
)	O
)	O
;	O
add_cmd_char	(int)->(void)
(	O
'\0'	O
)	O
;	O
}	O
}	O
void	O
parse_varline	(*(char))->(void)
(	O
p	*(char)
)	O
char	O
*	O
p	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
do	O
{	O
s	*(char)
=	O
tstr	(*(*(char)),int)->(*(char))
(	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
add_cmd_str	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
}	O
while	O
(	O
*	O
p	*(char)
!=	O
' '	O
&&	O
*	O
p	*(char)
!=	O
'\t'	O
&&	O
*	O
p	*(char)
!=	O
'='	O
&&	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
;	O
add_cmd_char	(int)->(void)
(	O
'\0'	O
)	O
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
++	O
!=	O
'='	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"missing ="	*(char)
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
add_cmd_char	(int)->(void)
(	O
EV_OK	int
|	O
A_EXTRA	int
)	O
;	O
p	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
while	O
(	O
*	O
p	*(char)
!=	O
'\0'	O
)	O
{	O
s	*(char)
=	O
tstr	(*(*(char)),int)->(*(char))
(	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
add_cmd_str	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
}	O
add_cmd_char	(int)->(void)
(	O
'\0'	O
)	O
;	O
}	O
void	O
parse_line	(*(char))->(void)
(	O
line	*(char)
)	O
char	O
*	O
line	*(char)
;	O
{	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
control_line	(*(char))->(int)
(	O
line	*(char)
)	O
)	O
return	O
;	O
p	*(char)
=	O
clean_line	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
'\0'	O
)	O
return	O
;	O
if	O
(	O
currtable	*(struct(*(struct(*(char),int)),*(char),array(char)))
==	O
&	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
)	O
parse_varline	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
else	O
parse_cmdline	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	*(*(char))
[	O
]	O
;	O
{	O
FILE	struct
*	O
desc	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
line	*(char)
[	O
1024	int
]	O
;	O
parse_args	(int,*(*(char)))->(void)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
init_tables	()->(void)
(	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
infile	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
desc	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
if	O
(	O
(	O
desc	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
infile	*(char)
,	O
"r"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
perror	(*(char))->(void)
(	O
infile	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
}	O
errors	int
=	O
0	int
;	O
linenum	long
=	O
0	int
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
desc	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
NULL	O
)	O
{	O
++	O
linenum	long
;	O
parse_line	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
}	O
if	O
(	O
errors	int
>	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d errors; no output produced\n"	*(char)
,	O
errors	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
outfile	*(char)
==	O
NULL	O
)	O
outfile	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LESSKEY"	*(char)
)	O
;	O
if	O
(	O
outfile	*(char)
==	O
NULL	O
)	O
outfile	*(char)
=	O
homefile	(*(char))->(*(char))
(	O
LESSKEYFILE	*(char)
)	O
;	O
if	O
(	O
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outfile	*(char)
,	O
"wb"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
perror	(*(char))->(void)
(	O
outfile	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fileheader	array(char)
,	O
sizeof	O
(	O
fileheader	array(char)
)	O
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
cmdsection	array(char)
,	O
sizeof	O
(	O
cmdsection	array(char)
)	O
)	O
;	O
fputint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
,	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
cmdtable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
editsection	array(char)
,	O
sizeof	O
(	O
editsection	array(char)
)	O
)	O
;	O
fputint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
,	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
edittable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
varsection	array(char)
,	O
sizeof	O
(	O
varsection	array(char)
)	O
)	O
;	O
fputint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
,	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
pbuffer	*(char)
-	O
vartable	struct(*(struct(*(char),int)),*(char),array(char))
.	O
buffer	array(char)
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
endsection	array(char)
,	O
sizeof	O
(	O
endsection	array(char)
)	O
)	O
;	O
fputbytes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int)->(void)
(	O
out	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
filetrailer	array(char)
,	O
sizeof	O
(	O
filetrailer	array(char)
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
