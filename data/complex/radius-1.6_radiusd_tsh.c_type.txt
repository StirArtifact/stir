static	O
int	O
interactive	int
;	O
static	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
test_req	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
;	O
static	O
char	O
*	O
tsh_ps1	*(char)
=	O
"(radiusd) "	*(char)
;	O
static	O
char	O
*	O
tsh_ps2	*(char)
=	O
"[radiusd] "	*(char)
;	O
static	O
char	O
*	O
tsh_readline	(*(char))->(*(char))
(	O
const	O
char	O
*	O
prompt	*(char)
)	O
;	O
static	O
void	O
tsh_help	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_query_nas	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_run_rewrite	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_source_rewrite	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_timespan	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_debug	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_quit	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_req_define	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_req_print	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
static	O
void	O
tsh_rewrite_stack	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
typedef	O
void	O
(	O
*	O
tsh_command	*((int,*(*(char)),*(char))->(void))
)	O
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
;	O
struct	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
{	O
char	O
*	O
shortname	array(char)
;	O
char	O
*	O
longname	array(char)
;	O
char	O
*	O
usage	*(char)
;	O
char	O
*	O
doc	*(char)
;	O
tsh_command	*((int,*(*(char)),*(char))->(void))
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
;	O
}	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
[	O
]	O
=	O
{	O
{	O
"h"	*(char)
,	O
"help"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Print this help screen"	*(char)
)	O
,	O
tsh_help	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"q"	*(char)
,	O
"query-nas"	*(char)
,	O
N_	O
(	O
"NAS LOGIN SID PORT [IP]"	*(char)
)	O
,	O
N_	O
(	O
"Query the given NAS"	*(char)
)	O
,	O
tsh_query_nas	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"rs"	*(char)
,	O
"rewrite-stack"	*(char)
,	O
N_	O
(	O
"[NUMBER]"	*(char)
)	O
,	O
N_	O
(	O
"Print or set the Rewrite stack size"	*(char)
)	O
,	O
tsh_rewrite_stack	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"r"	*(char)
,	O
"run-rewrite"	*(char)
,	O
N_	O
(	O
"FUNCTION(args..)"	*(char)
)	O
,	O
N_	O
(	O
"Run given Rewrite function"	*(char)
)	O
,	O
tsh_run_rewrite	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"s"	*(char)
,	O
"source"	*(char)
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Source the given Rewrite file"	*(char)
)	O
,	O
tsh_source_rewrite	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"t"	*(char)
,	O
"timespan"	*(char)
,	O
N_	O
(	O
"TIMESPAN [DOW [HH [MM]]]"	*(char)
)	O
,	O
N_	O
(	O
"Check the timespan interval"	*(char)
)	O
,	O
tsh_timespan	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"d"	*(char)
,	O
"debug"	*(char)
,	O
N_	O
(	O
"LEVEL"	*(char)
)	O
,	O
N_	O
(	O
"Set debugging level"	*(char)
)	O
,	O
tsh_debug	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"rd"	*(char)
,	O
"request-define"	*(char)
,	O
N_	O
(	O
"[PAIR [,PAIR]]"	*(char)
)	O
,	O
N_	O
(	O
"Define a request"	*(char)
)	O
,	O
tsh_req_define	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"rp"	*(char)
,	O
"request-print"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Print the request"	*(char)
)	O
,	O
tsh_req_print	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
"quit"	*(char)
,	O
"quit"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Quit the shell"	*(char)
)	O
,	O
tsh_quit	(int,*(*(char)),*(char))->(void)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
print_doc	(int,*(char))->(void)
(	O
int	O
n	long
,	O
char	O
*	O
s	*(*(char))
)	O
{	O
if	O
(	O
n	long
>	O
OPT_DOC_COL	int
)	O
{	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
n	long
=	O
0	int
;	O
}	O
do	O
{	O
char	O
*	O
p	*(struct)
;	O
char	O
*	O
space	*(char)
=	O
NULL	O
;	O
for	O
(	O
;	O
n	long
<	O
OPT_DOC_COL	int
;	O
n	long
++	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
for	O
(	O
p	*(struct)
=	O
s	*(*(char))
;	O
*	O
p	*(struct)
&&	O
p	*(struct)
<	O
s	*(*(char))
+	O
(	O
RMARGIN	int
-	O
OPT_DOC_COL	int
)	O
;	O
p	*(struct)
++	O
)	O
if	O
(	O
isspace	(int)->(int)
(	O
*	O
p	*(struct)
)	O
)	O
space	*(char)
=	O
p	*(struct)
;	O
if	O
(	O
!	O
space	*(char)
||	O
p	*(struct)
<	O
s	*(*(char))
+	O
(	O
RMARGIN	int
-	O
OPT_DOC_COL	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
s	*(*(char))
)	O
;	O
s	*(*(char))
+=	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
;	O
}	O
else	O
{	O
for	O
(	O
;	O
s	*(*(char))
<	O
space	*(char)
;	O
s	*(*(char))
++	O
)	O
putchar	(int)->(int)
(	O
*	O
s	*(*(char))
)	O
;	O
for	O
(	O
;	O
*	O
s	*(*(char))
&&	O
isspace	(int)->(int)
(	O
*	O
s	*(*(char))
)	O
;	O
s	*(*(char))
++	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
n	long
=	O
1	int
;	O
}	O
while	O
(	O
*	O
s	*(*(char))
)	O
;	O
}	O
static	O
void	O
tsh_help	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
struct	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
*	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
;	O
int	O
n	long
;	O
for	O
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
=	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
;	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
;	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
++	O
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
)	O
;	O
n	long
=	O
printf	(*(char))->(int)
(	O
"%-8.8s%s"	*(char)
,	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
,	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
longname	array(char)
)	O
;	O
if	O
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
usage	*(char)
)	O
n	long
+=	O
printf	(*(char))->(int)
(	O
" %s"	*(char)
,	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
usage	*(char)
)	O
;	O
print_doc	(int,*(char))->(void)
(	O
n	long
,	O
gettext	(*(char))->(*(char))
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
doc	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
void	O
tsh_query_nas	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	int
;	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
;	O
if	O
(	O
argc	int
<	O
5	int
||	O
argc	int
>	O
6	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
nas	int
=	O
grad_nas_lookup_name	(*(char))->(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
nas	int
)	O
{	O
if	O
(	O
nas	int
->	O
netdef	struct(int,int)
.	O
netmask	int
!=	O
0xffffffffL	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s is a network name\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
;	O
}	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
nas_address	int
=	O
nas	int
->	O
netdef	struct(int,int)
.	O
ipaddr	int
;	O
}	O
else	O
{	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
nas_address	int
=	O
grad_ip_gethostaddr	(*(char))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
nas_address	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown nas\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
orig_login	array(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
sizeof	O
(	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
orig_login	array(char)
)	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
session_id	array(char)
,	O
argv	*(*(char))
[	O
3	int
]	O
,	O
sizeof	O
(	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
session_id	array(char)
)	O
)	O
;	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
nas_port	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
4	int
]	O
)	O
;	O
if	O
(	O
argc	int
==	O
6	int
)	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
.	O
framed_address	int
=	O
grad_ip_strtoip	(*(char))->(int)
(	O
argv	*(*(char))
[	O
5	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
checkrad	(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
nas	int
,	O
&	O
ut	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
)	O
;	O
}	O
static	O
void	O
tsh_rewrite_stack	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
1	int
)	O
printf	(*(char))->(int)
(	O
"%lu\n"	*(char)
,	O
(	O
long	O
unsigned	O
)	O
rewrite_get_stack_size	()->(long)
(	O
)	O
)	O
;	O
else	O
{	O
char	O
*	O
p	*(struct)
;	O
size_t	long
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: argument is not a number\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
rewrite_set_stack_size	(long)->(void)
(	O
n	long
)	O
;	O
}	O
}	O
static	O
void	O
tsh_run_rewrite	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
*	O
cmd	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
cmd	*(char)
)	O
)	O
cmd	*(char)
++	O
;	O
while	O
(	O
*	O
cmd	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
cmd	*(char)
)	O
)	O
cmd	*(char)
++	O
;	O
if	O
(	O
rewrite_interpret	(*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(enum(int,int,int),union(int,struct(long,*`)))))->(int)
(	O
cmd	*(char)
,	O
&	O
test_req	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
,	O
&	O
val	array(int)
)	O
)	O
printf	(*(char))->(int)
(	O
"?\n"	*(char)
)	O
;	O
else	O
{	O
switch	O
(	O
val	array(int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
Integer	int
:	O
printf	(*(char))->(int)
(	O
"%d (%u)"	*(char)
,	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
,	O
(	O
unsigned	O
)	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
ival	int
)	O
;	O
break	O
;	O
case	O
String	int
:	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
)	O
;	O
break	O
;	O
case	O
Undefined	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Undefined"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
grad_value_free	(*(struct(enum(int,int,int),union(int,struct(long,*`)))))->(void)
(	O
&	O
val	array(int)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
tsh_source_rewrite	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
rewrite_load_module	()->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
)	O
;	O
}	O
static	O
void	O
tsh_timespan	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
time_t	long
t	long
;	O
TIMESPAN	struct
*	O
ts	*(struct(*(struct(*(struct`),int,int)),int,int))
;	O
char	O
*	O
p	*(struct)
;	O
unsigned	O
rest	*(char)
;	O
int	O
i	int
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
int	O
diff	int
,	O
dow	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
5	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
time	struct(long,long)
(	O
&	O
t	long
)	O
;	O
localtime_r	(*(long),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
switch	O
(	O
argc	int
)	O
{	O
default	O
:	O
return	O
;	O
case	O
5	int
:	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
4	int
]	O
)	O
;	O
case	O
4	int
:	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
3	int
]	O
)	O
;	O
case	O
3	int
:	O
dow	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
diff	int
=	O
dow	int
-	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_wday	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_wday	int
=	O
dow	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
+=	O
diff	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_yday	int
+=	O
diff	int
;	O
t	long
=	O
mktime	(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
break	O
;	O
case	O
2	int
:	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"ctime: %s"	*(char)
,	O
ctime	(*(long))->(*(char))
(	O
&	O
t	long
)	O
)	O
;	O
if	O
(	O
ts_parse	(*(*(struct(*(struct`),int,int))),*(char),*(*(char)))->(int)
(	O
&	O
ts	*(struct(*(struct(*(struct`),int,int)),int,int))
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
p	*(struct)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"bad timestring near %s\n"	*(char)
,	O
p	*(struct)
)	O
;	O
}	O
else	O
{	O
int	O
l	int
=	O
ts_match	(*(struct(*(struct(*`,int,int)),int,int)),*(long),*(int))->(int)
(	O
ts	*(struct(*(struct(*(struct`),int,int)),int,int))
,	O
&	O
t	long
,	O
&	O
rest	*(char)
)	O
;	O
if	O
(	O
l	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"inside %s: %d seconds left\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rest	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"OUTSIDE %s: %d seconds to wait\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
rest	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
tsh_debug	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: wrong number of arguments\n"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
--	O
argc	int
)	O
grad_set_debug_levels	(*(char))->(void)
(	O
*	O
++	O
argv	*(*(char))
)	O
;	O
}	O
static	O
void	O
tsh_req_define	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
char	O
*	O
errp	*(*(char))
;	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
NULL	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
while	O
(	O
*	O
cmd	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
cmd	*(char)
)	O
)	O
cmd	*(char)
++	O
;	O
while	O
(	O
*	O
cmd	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
cmd	*(char)
)	O
)	O
cmd	*(char)
++	O
;	O
if	O
(	O
userparse	(*(char),*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(*(char)))->(int)
(	O
cmd	*(char)
,	O
&	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
&	O
errp	*(*(char))
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
"%s"	*(char)
,	O
errp	*(*(char))
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
interactive	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Enter the pair list. End with end of file\n"	*(char)
)	O
)	O
;	O
while	O
(	O
(	O
cmd	*(char)
=	O
grad_readline	(*(char))->(*(char))
(	O
tsh_ps2	*(char)
)	O
)	O
!=	O
NULL	O
&&	O
cmd	*(char)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
userparse	(*(char),*(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))),*(*(char)))->(int)
(	O
cmd	*(char)
,	O
&	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
&	O
errp	*(*(char))
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
"%s"	*(char)
,	O
errp	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
return	O
;	O
}	O
free	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
}	O
}	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
test_req	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
.	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
test_req	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
.	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
static	O
void	O
tsh_req_print	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
grad_avl_fprint	()->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"    "	*(char)
,	O
1	int
,	O
test_req	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
.	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
}	O
static	O
void	O
tsh_quit	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
ARG_UNUSED	O
,	O
char	O
*	O
cmd	*(char)
ARG_UNUSED	O
)	O
{	O
grad_write_history_file	()->(int)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
static	O
struct	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
*	O
tsh_find_entry	(*(char))->(*(struct(*(char),*(char),*(char),*(char),*((int,*`,*`)->(void)))))
(	O
char	O
*	O
cmd	*(char)
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
cmd	*(char)
)	O
;	O
struct	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
*	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
;	O
for	O
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
=	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
;	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
;	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
++	O
)	O
{	O
int	O
ll	int
=	O
0	int
,	O
sl	struct(int,int,*(char))
=	O
0	int
;	O
sl	struct(int,int,*(char))
=	O
strlen	(*(char))->(long)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
)	O
;	O
ll	int
=	O
strlen	(*(char))->(long)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
longname	array(char)
)	O
;	O
if	O
(	O
(	O
sl	struct(int,int,*(char))
>	O
ll	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
,	O
cmd	*(char)
,	O
sl	struct(int,int,*(char))
)	O
)	O
||	O
(	O
sl	struct(int,int,*(char))
==	O
len	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
shortname	array(char)
,	O
cmd	*(char)
)	O
)	O
||	O
(	O
sl	struct(int,int,*(char))
<	O
len	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
longname	array(char)
,	O
cmd	*(char)
,	O
len	int
)	O
)	O
)	O
return	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
tsh_command	*((int,*(*(char)),*(char))->(void))
tsh_find_function	(*(char))->(*((int,*(*(char)),*(char))->(void)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
command_table	struct(*(char),*(char),*(char),*(char),*((int,*(*(char)),*(char))->(void)))
*	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'?'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
name	*(char)
=	O
"help"	*(char)
;	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
=	O
tsh_find_entry	(*(char))->(*(struct(*(char),*(char),*(char),*(char),*((int,*`,*`)->(void)))))
(	O
name	*(char)
)	O
;	O
return	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
?	O
cp	*(struct(*(char),*(char),*(char),*(char),*((int,*(*`),*(char))->(void))))
->	O
handler	*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int))
:	O
NULL	O
;	O
}	O
static	O
void	O
tsh_run_function	(int,*(*(char)),*(char))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
tsh_command	*((int,*(*(char)),*(char))->(void))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
return	O
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
tsh_find_function	(*(char))->(*((int,*(*(char)),*(char))->(void)))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
(	O
argc	int
,	O
argv	*(*(char))
,	O
cmd	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Bad command\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
tsh_run_command	(*(char))->(void)
(	O
char	O
*	O
cmd	*(char)
)	O
{	O
int	O
argc	int
=	O
0	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
while	O
(	O
*	O
cmd	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
cmd	*(char)
)	O
)	O
cmd	*(char)
++	O
;	O
if	O
(	O
!	O
cmd	*(char)
||	O
cmd	*(char)
[	O
0	int
]	O
==	O
'#'	O
)	O
return	O
;	O
if	O
(	O
grad_argcv_get	(*(char),*(char),*(char),*(int),*(*(*(char))))->(int)
(	O
cmd	*(char)
,	O
"="	*(char)
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
==	O
0	int
)	O
{	O
grad_add_history	(*(char))->(void)
(	O
cmd	*(char)
)	O
;	O
tsh_run_function	(int,*(*(char)),*(char))->(void)
(	O
argc	int
,	O
argv	*(*(char))
,	O
cmd	*(char)
)	O
;	O
}	O
grad_argcv_free	(int,*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
}	O
int	O
tsh	()->(int)
(	O
)	O
{	O
char	O
*	O
cmd	*(char)
;	O
interactive	int
=	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
if	O
(	O
interactive	int
)	O
printf	(*(char))->(int)
(	O
"** TEST SHELL **\n"	*(char)
)	O
;	O
grad_readline_init	(*(char),int,*((*(char),int,int)->(*(*(char)))))->(void)
(	O
"radiusd"	*(char)
,	O
interactive	int
,	O
tsh_command_completion	O
)	O
;	O
grad_read_history_file	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
cmd	*(char)
=	O
grad_readline	(*(char))->(*(char))
(	O
tsh_ps1	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
tsh_run_command	(*(char))->(void)
(	O
cmd	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
}	O
tsh_quit	(int,*(*(char)),*(char))->(void)
(	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
