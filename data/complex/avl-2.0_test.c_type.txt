enum	O
insert_order	enum(int,int,int,int,int,int,int,int)
{	O
INS_RANDOM	int
,	O
INS_ASCENDING	int
,	O
INS_DESCENDING	int
,	O
INS_BALANCED	int
,	O
INS_ZIGZAG	int
,	O
INS_ASCENDING_SHIFTED	int
,	O
INS_CUSTOM	int
,	O
INS_CNT	int
}	O
;	O
enum	O
delete_order	enum(int,int,int,int,int)
{	O
DEL_RANDOM	int
,	O
DEL_REVERSE	int
,	O
DEL_SAME	int
,	O
DEL_CUSTOM	int
,	O
DEL_CNT	int
}	O
;	O
enum	O
mt_policy	enum(int,int,int,int,int)
{	O
MT_TRACK	int
,	O
MT_NO_TRACK	int
,	O
MT_FAIL_COUNT	int
,	O
MT_FAIL_PERCENT	int
,	O
MT_SUBALLOC	int
}	O
;	O
struct	O
option	struct(*(char),int,int)
{	O
const	O
char	O
*	O
long_name	*(char)
;	O
int	O
short_name	int
;	O
int	O
has_arg	int
;	O
}	O
;	O
enum	O
test	enum(int,int,int)
{	O
TST_CORRECTNESS	int
,	O
TST_OVERFLOW	int
,	O
TST_NULL	int
}	O
;	O
struct	O
test_options	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
{	O
enum	O
test	enum(int,int,int)
test	enum(int,int,int)
;	O
enum	O
insert_order	enum(int,int,int,int,int,int,int,int)
insert_order	enum(int,int,int,int,int,int,int,int)
;	O
enum	O
delete_order	enum(int,int,int,int,int)
delete_order	enum(int,int,int,int,int)
;	O
enum	O
mt_policy	enum(int,int,int,int,int)
alloc_policy	enum(int,int,int,int,int)
;	O
int	O
alloc_arg	array(int)
[	O
2	int
]	O
;	O
int	O
alloc_incr	int
;	O
int	O
node_cnt	int
;	O
int	O
iter_cnt	int
;	O
int	O
seed_given	int
;	O
unsigned	O
seed	int
;	O
int	O
verbosity	int
;	O
int	O
nonstop	int
;	O
}	O
;	O
char	O
*	O
pgm_name	*(char)
;	O
int	O
compare_ints	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
pa	*(void)
,	O
const	O
void	O
*	O
pb	*(void)
,	O
void	O
*	O
param	*(void)
)	O
{	O
const	O
int	O
*	O
a	*(int)
=	O
pa	*(void)
;	O
const	O
int	O
*	O
b	*(int)
=	O
pb	*(void)
;	O
if	O
(	O
*	O
a	*(int)
<	O
*	O
b	*(int)
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
a	*(int)
>	O
*	O
b	*(int)
)	O
return	O
+	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
fail	(*(char))->(void)
(	O
const	O
char	O
*	O
message	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: "	*(char)
,	O
pgm_name	*(char)
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
message	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
message	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
block	*(void)
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
block	*(void)
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
fail	(*(char))->(void)
(	O
"out of memory"	*(char)
)	O
;	O
return	O
block	*(void)
;	O
}	O
struct	O
block	*(void)
{	O
struct	O
block	*(void)
*	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
int	O
idx	int
;	O
size_t	long
size	long
;	O
size_t	long
used	long
;	O
void	O
*	O
content	*(void)
;	O
}	O
;	O
enum	O
mt_arg_index	enum(int,int,int,int)
{	O
MT_COUNT	int
=	O
0	int
,	O
MT_PERCENT	int
=	O
0	int
,	O
MT_BLOCK_SIZE	int
=	O
0	int
,	O
MT_ALIGN	int
=	O
1	int
}	O
;	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
{	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
;	O
enum	O
mt_policy	enum(int,int,int,int,int)
policy	enum(int,int,int,int,int)
;	O
int	O
arg	array(int)
[	O
2	int
]	O
;	O
int	O
verbosity	int
;	O
struct	O
block	*(void)
*	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
*	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
int	O
alloc_idx	int
;	O
int	O
block_cnt	int
;	O
}	O
;	O
static	O
void	O
*	O
mt_allocate	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))
(	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
*	O
,	O
size_t	long
)	O
;	O
static	O
void	O
mt_free	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)
(	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
*	O
,	O
void	O
*	O
)	O
;	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt_create	(enum(int,int,int,int,int),array(int),int)->(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)))
(	O
enum	O
mt_policy	enum(int,int,int,int,int)
policy	enum(int,int,int,int,int)
,	O
int	O
arg	array(int)
[	O
2	int
]	O
,	O
int	O
verbosity	int
)	O
{	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
.	O
libavl_malloc	*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void)))
=	O
mt_allocate	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
.	O
libavl_free	*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void))
=	O
mt_free	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
=	O
policy	enum(int,int,int,int,int)
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
0	int
]	O
=	O
arg	array(int)
[	O
0	int
]	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
1	int
]	O
=	O
arg	array(int)
[	O
1	int
]	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
=	O
verbosity	int
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
NULL	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
alloc_idx	int
=	O
0	int
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
block_cnt	int
=	O
0	int
;	O
return	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
;	O
}	O
void	O
mt_destroy	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)))->(void)
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
{	O
assert	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
!=	O
NULL	O
)	O
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
block_cnt	int
==	O
0	int
)	O
{	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
!=	O
MT_NO_TRACK	int
&&	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
>=	O
1	int
)	O
printf	(*(char))->(int)
(	O
"  No memory leaks.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
struct	O
block	*(void)
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
*	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
!=	O
MT_SUBALLOC	int
)	O
printf	(*(char))->(int)
(	O
"  Memory leaks detected:\n"	*(char)
)	O
;	O
for	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
!=	O
NULL	O
;	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
)	O
{	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
!=	O
MT_SUBALLOC	int
)	O
printf	(*(char))->(int)
(	O
"    block #%d: %lu bytes\n"	*(char)
,	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
size	long
)	O
;	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
free	(*(void))->(void)
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
;	O
}	O
void	O
*	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
{	O
return	O
&	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
;	O
}	O
static	O
void	O
*	O
new_block	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(*(void))
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size_t	long
size	long
)	O
{	O
struct	O
block	*(void)
*	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
)	O
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
NULL	O
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
idx	int
=	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
alloc_idx	int
++	O
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
size	long
=	O
size	long
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
used	long
=	O
0	int
;	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
==	O
NULL	O
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
else	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
>=	O
3	int
)	O
printf	(*(char))->(int)
(	O
"    block #%d: allocated %lu bytes\n"	*(char)
,	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
block_cnt	int
++	O
;	O
return	O
new	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
;	O
}	O
static	O
void	O
reject_request	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(void)
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
>=	O
2	int
)	O
printf	(*(char))->(int)
(	O
"    block #%d: rejected request for %lu bytes\n"	*(char)
,	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
alloc_idx	int
++	O
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
}	O
static	O
void	O
*	O
mt_allocate	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))
(	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
*	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
,	O
size_t	long
size	long
)	O
{	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
=	O
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
)	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
NULL	O
;	O
switch	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
)	O
{	O
case	O
MT_TRACK	int
:	O
return	O
new_block	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(*(void))
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size	long
)	O
;	O
case	O
MT_NO_TRACK	int
:	O
return	O
xmalloc	(long)->(*(void))
(	O
size	long
)	O
;	O
case	O
MT_FAIL_COUNT	int
:	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_COUNT	int
]	O
==	O
0	int
)	O
{	O
reject_request	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(void)
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size	long
)	O
;	O
return	O
NULL	O
;	O
}	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_COUNT	int
]	O
--	O
;	O
return	O
new_block	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(*(void))
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size	long
)	O
;	O
case	O
MT_FAIL_PERCENT	int
:	O
if	O
(	O
rand	()->(int)
(	O
)	O
/	O
(	O
RAND_MAX	int
/	O
100	int
+	O
1	int
)	O
<	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_PERCENT	int
]	O
)	O
{	O
reject_request	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(void)
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size	long
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
return	O
new_block	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(*(void))
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
size	long
)	O
;	O
case	O
MT_SUBALLOC	int
:	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
==	O
NULL	O
||	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
used	long
+	O
size	long
>	O
(	O
size_t	long
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_BLOCK_SIZE	int
]	O
)	O
new_block	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)),long)->(*(void))
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
,	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_BLOCK_SIZE	int
]	O
)	O
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
used	long
+	O
size	long
<=	O
(	O
size_t	long
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_BLOCK_SIZE	int
]	O
)	O
{	O
void	O
*	O
p	*(void)
=	O
(	O
char	O
*	O
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
+	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
used	long
;	O
size	long
=	O
(	O
(	O
size	long
+	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_ALIGN	int
]	O
-	O
1	int
)	O
/	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_ALIGN	int
]	O
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
arg	array(int)
[	O
MT_ALIGN	int
]	O
)	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
used	long
+=	O
size	long
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
>=	O
3	int
)	O
printf	(*(char))->(int)
(	O
"    block #%d: suballocated %lu bytes\n"	*(char)
,	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
return	O
p	*(void)
;	O
}	O
else	O
fail	(*(char))->(void)
(	O
"blocksize %lu too small for %lu-byte allocation"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
size	long
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
mt_free	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)
(	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
*	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
,	O
void	O
*	O
block	*(void)
)	O
{	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
=	O
(	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
)	O
allocator	*(struct(*((*(struct`),long)->(*(void))),*((*(struct`),*(void))->(void))))
;	O
struct	O
block	*(void)
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
*	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
block	*(void)
==	O
NULL	O
||	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
==	O
MT_NO_TRACK	int
)	O
{	O
free	(*(void))->(void)
(	O
block	*(void)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
policy	enum(int,int,int,int,int)
==	O
MT_SUBALLOC	int
)	O
return	O
;	O
for	O
(	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
NULL	O
,	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
)	O
{	O
if	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
==	O
block	*(void)
)	O
{	O
struct	O
block	*(void)
*	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
==	O
NULL	O
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
head	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
else	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
==	O
NULL	O
)	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
tail	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
prev	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
if	O
(	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
verbosity	int
>=	O
4	int
)	O
printf	(*(char))->(int)
(	O
"    block #%d: freed %lu bytes\n"	*(char)
,	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
size	long
)	O
;	O
free	(*(void))->(void)
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
->	O
content	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
)	O
;	O
mt	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
->	O
block_cnt	int
--	O
;	O
return	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"    attempt to free unknown block %p (already freed?)\n"	*(char)
,	O
block	*(void)
)	O
;	O
}	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
{	O
const	O
struct	O
option	struct(*(char),int,int)
*	O
options	*(struct(*(char),int,int))
;	O
char	O
*	O
*	O
arg_next	*(*(char))
;	O
char	O
*	O
short_next	*(char)
;	O
}	O
;	O
static	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
option_init	(*(struct(*(char),int,int)),*(*(char)))->(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))))
(	O
const	O
struct	O
option	struct(*(char),int,int)
*	O
options	*(struct(*(char),int,int))
,	O
char	O
*	O
*	O
args	array(struct(int,int,*(void),*(void)))
)	O
{	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
;	O
assert	O
(	O
options	*(struct(*(char),int,int))
!=	O
NULL	O
&&	O
args	array(struct(int,int,*(void),*(void)))
!=	O
NULL	O
)	O
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
)	O
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
options	*(struct(*(char),int,int))
=	O
options	*(struct(*(char),int,int))
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
=	O
args	array(struct(int,int,*(void),*(void)))
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
=	O
NULL	O
;	O
return	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
;	O
}	O
static	O
int	O
handle_short_option	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
char	O
*	O
*	O
argp	*(*(char))
)	O
{	O
const	O
struct	O
option	struct(*(char),int,int)
*	O
o	*(struct(*(char),int,int))
;	O
assert	O
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
!=	O
NULL	O
&&	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
!=	O
NULL	O
&&	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
!=	O
'\0'	O
&&	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
options	*(struct(*(char),int,int))
!=	O
NULL	O
)	O
;	O
for	O
(	O
o	*(struct(*(char),int,int))
=	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
options	*(struct(*(char),int,int))
;	O
;	O
o	*(struct(*(char),int,int))
++	O
)	O
if	O
(	O
o	*(struct(*(char),int,int))
->	O
long_name	*(char)
==	O
NULL	O
)	O
fail	(*(char))->(void)
(	O
"unknown option `-%c'; use --help for help"	*(char)
,	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
)	O
;	O
else	O
if	O
(	O
o	*(struct(*(char),int,int))
->	O
short_name	int
==	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
)	O
break	O
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
++	O
;	O
if	O
(	O
o	*(struct(*(char),int,int))
->	O
has_arg	int
)	O
{	O
if	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
==	O
NULL	O
||	O
*	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
==	O
'-'	O
)	O
fail	(*(char))->(void)
(	O
"`-%c' requires an argument; use --help for help"	*(char)
)	O
;	O
*	O
argp	*(*(char))
=	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
++	O
;	O
}	O
return	O
o	*(struct(*(char),int,int))
->	O
short_name	int
;	O
}	O
static	O
int	O
handle_long_option	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
char	O
*	O
*	O
argp	*(*(char))
)	O
{	O
const	O
struct	O
option	struct(*(char),int,int)
*	O
o	*(struct(*(char),int,int))
;	O
char	O
name	array(char)
[	O
16	int
]	O
;	O
const	O
char	O
*	O
arg	array(int)
;	O
assert	O
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
!=	O
NULL	O
&&	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
!=	O
NULL	O
&&	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
!=	O
NULL	O
&&	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
options	*(struct(*(char),int,int))
!=	O
NULL	O
&&	O
argp	*(*(char))
!=	O
NULL	O
)	O
;	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
+	O
2	int
;	O
const	O
char	O
*	O
q	*(char)
=	O
p	*(void)
+	O
strcspn	(*(char),*(char))->(long)
(	O
p	*(void)
,	O
"="	*(char)
)	O
;	O
size_t	long
name_len	long
=	O
q	*(char)
-	O
p	*(void)
;	O
if	O
(	O
name_len	long
>	O
(	O
sizeof	O
name	array(char)
)	O
-	O
1	int
)	O
name_len	long
=	O
(	O
sizeof	O
name	array(char)
)	O
-	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
name	array(char)
,	O
p	*(void)
,	O
name_len	long
)	O
;	O
name	array(char)
[	O
name_len	long
]	O
=	O
'\0'	O
;	O
arg	array(int)
=	O
(	O
*	O
q	*(char)
==	O
'='	O
)	O
?	O
q	*(char)
+	O
1	int
:	O
NULL	O
;	O
}	O
for	O
(	O
o	*(struct(*(char),int,int))
=	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
options	*(struct(*(char),int,int))
;	O
;	O
o	*(struct(*(char),int,int))
++	O
)	O
if	O
(	O
o	*(struct(*(char),int,int))
->	O
long_name	*(char)
==	O
NULL	O
)	O
fail	(*(char))->(void)
(	O
"unknown option --%s; use --help for help"	*(char)
,	O
name	array(char)
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
name	array(char)
,	O
o	*(struct(*(char),int,int))
->	O
long_name	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
(	O
arg	array(int)
!=	O
NULL	O
)	O
!=	O
(	O
o	*(struct(*(char),int,int))
->	O
has_arg	int
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
arg	array(int)
!=	O
NULL	O
)	O
fail	(*(char))->(void)
(	O
"--%s can't take an argument; use --help for help"	*(char)
,	O
name	array(char)
)	O
;	O
else	O
fail	(*(char))->(void)
(	O
"--%s requires an argument; use --help for help"	*(char)
,	O
name	array(char)
)	O
;	O
}	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
++	O
;	O
*	O
argp	*(*(char))
=	O
(	O
char	O
*	O
)	O
arg	array(int)
;	O
return	O
o	*(struct(*(char),int,int))
->	O
short_name	int
;	O
}	O
static	O
int	O
option_get	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
char	O
*	O
*	O
argp	*(*(char))
)	O
{	O
assert	O
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
!=	O
NULL	O
&&	O
argp	*(*(char))
!=	O
NULL	O
)	O
;	O
*	O
argp	*(*(char))
=	O
NULL	O
;	O
if	O
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
!=	O
'\0'	O
)	O
return	O
handle_short_option	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
argp	*(*(char))
)	O
;	O
else	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
)	O
[	O
0	int
]	O
!=	O
'-'	O
)	O
fail	(*(char))->(void)
(	O
"non-option arguments encountered; use --help for help"	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
)	O
[	O
1	int
]	O
==	O
'\0'	O
)	O
fail	(*(char))->(void)
(	O
"unknown option `-'; use --help for help"	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
)	O
[	O
1	int
]	O
==	O
'-'	O
)	O
return	O
handle_long_option	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
argp	*(*(char))
)	O
;	O
else	O
{	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
short_next	*(char)
=	O
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
+	O
1	int
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
->	O
arg_next	*(*(char))
++	O
;	O
return	O
handle_short_option	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
argp	*(*(char))
)	O
;	O
}	O
}	O
size_t	long
match_len	(*(char),*(char))->(long)
(	O
const	O
char	O
*	O
a	*(int)
,	O
const	O
char	O
*	O
b	*(int)
)	O
{	O
size_t	long
cnt	long
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
*	O
a	*(int)
==	O
*	O
b	*(int)
&&	O
*	O
a	*(int)
!=	O
'\0'	O
;	O
a	*(int)
++	O
,	O
b	*(int)
++	O
)	O
cnt	long
++	O
;	O
return	O
(	O
*	O
a	*(int)
!=	O
*	O
b	*(int)
&&	O
*	O
a	*(int)
!=	O
'\0'	O
&&	O
*	O
b	*(int)
!=	O
'\0'	O
)	O
?	O
0	int
:	O
cnt	long
;	O
}	O
static	O
int	O
stoi	(*(char))->(int)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
long	O
x	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
s	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
return	O
x	long
>=	O
INT_MIN	O
&&	O
x	long
<=	O
INT_MAX	O
?	O
x	long
:	O
0	int
;	O
}	O
static	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
help	array(*(char))
[	O
]	O
=	O
{	O
"bst-test, unit test for GNU libavl.\n\n"	*(char)
,	O
"Usage: %s [OPTION]...\n\n"	*(char)
,	O
"In the option descriptions below, CAPITAL denote arguments.\n"	*(char)
,	O
"If a long option shows an argument as mandatory, then it is\n"	*(char)
,	O
"mandatory for the equivalent short option also.  See the GNU\n"	*(char)
,	O
"libavl manual for more information.\n\n"	*(char)
,	O
"-t, --test=TEST     Sets test to perform.  TEST is one of:\n"	*(char)
,	O
"                      correctness insert/delete/... (default)\n"	*(char)
,	O
"                      overflow    stack overflow test\n"	*(char)
,	O
"                      benchmark   benchmark test\n"	*(char)
,	O
"                      null        no test\n"	*(char)
,	O
"-s, --size=TREE-SIZE  Sets tree size in nodes (default 16).\n"	*(char)
,	O
"-r, --repeat=COUNT  Repeats operation COUNT times (default 16).\n"	*(char)
,	O
"-i, --insert=ORDER  Sets the insertion order.  ORDER is one of:\n"	*(char)
,	O
"                      random      random permutation (default)\n"	*(char)
,	O
"                      ascending   ascending order 0...n-1\n"	*(char)
,	O
"                      descending  descending order n-1...0\n"	*(char)
,	O
"                      balanced    balanced tree order\n"	*(char)
,	O
"                      zigzag      zig-zag tree\n"	*(char)
,	O
"                      asc-shifted n/2...n-1, 0...n/2-1\n"	*(char)
,	O
"                      custom      custom, read from stdin\n"	*(char)
,	O
"-d, --delete=ORDER  Sets the deletion order.  ORDER is one of:\n"	*(char)
,	O
"                      random   random permutation (default)\n"	*(char)
,	O
"                      reverse  reverse order of insertion\n"	*(char)
,	O
"                      same     same as insertion order\n"	*(char)
,	O
"                      custom   custom, read from stdin\n"	*(char)
,	O
"-a, --alloc=POLICY  Sets allocation policy.  POLICY is one of:\n"	*(char)
,	O
"                      track     track memory leaks (default)\n"	*(char)
,	O
"                      no-track  turn off leak detection\n"	*(char)
,	O
"                      fail-CNT  fail after CNT allocations\n"	*(char)
,	O
"                      fail%%PCT  fail random PCT%% of allocations\n"	*(char)
,	O
"                      sub-B,A   divide B-byte blocks in A-byte units\n"	*(char)
,	O
"                    (Ignored for `benchmark' test.)\n"	*(char)
,	O
"-A, --incr=INC      Fail policies: arg increment per repetition.\n"	*(char)
,	O
"-S, --seed=SEED     Sets initial number seed to SEED.\n"	*(char)
,	O
"                    (default based on system time)\n"	*(char)
,	O
"-n, --nonstop       Don't stop after a single error.\n"	*(char)
,	O
"-q, --quiet         Turns down verbosity level.\n"	*(char)
,	O
"-v, --verbose       Turns up verbosity level.\n"	*(char)
,	O
"-h, --help          Displays this help screen.\n"	*(char)
,	O
"-V, --version       Reports version and copyright information.\n"	*(char)
,	O
NULL	O
,	O
}	O
;	O
const	O
char	O
*	O
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
help	array(*(char))
;	O
*	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
++	O
)	O
printf	(*(char))->(int)
(	O
*	O
p	*(void)
,	O
pgm_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
parse_command_line	(*(*(char)),*(struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)))->(void)
(	O
char	O
*	O
*	O
args	array(struct(int,int,*(void),*(void)))
,	O
struct	O
test_options	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
*	O
options	*(struct(*(char),int,int))
)	O
{	O
static	O
const	O
struct	O
option	struct(*(char),int,int)
option_tab	array(struct(*(char),int,int))
[	O
]	O
=	O
{	O
{	O
"test"	*(char)
,	O
't'	O
,	O
1	int
}	O
,	O
{	O
"insert"	*(char)
,	O
'i'	O
,	O
1	int
}	O
,	O
{	O
"delete"	*(char)
,	O
'd'	O
,	O
1	int
}	O
,	O
{	O
"alloc"	*(char)
,	O
'a'	O
,	O
1	int
}	O
,	O
{	O
"incr"	*(char)
,	O
'A'	O
,	O
1	int
}	O
,	O
{	O
"size"	*(char)
,	O
's'	O
,	O
1	int
}	O
,	O
{	O
"repeat"	*(char)
,	O
'r'	O
,	O
1	int
}	O
,	O
{	O
"operation"	*(char)
,	O
'o'	O
,	O
1	int
}	O
,	O
{	O
"seed"	*(char)
,	O
'S'	O
,	O
1	int
}	O
,	O
{	O
"nonstop"	*(char)
,	O
'n'	O
,	O
0	int
}	O
,	O
{	O
"quiet"	*(char)
,	O
'q'	O
,	O
0	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
0	int
}	O
,	O
{	O
"help"	*(char)
,	O
'h'	O
,	O
0	int
}	O
,	O
{	O
"version"	*(char)
,	O
'V'	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
struct	O
option_state	struct(*(struct(*(char),int,int)),*(*(char)),*(char))
*	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
;	O
options	*(struct(*(char),int,int))
->	O
test	enum(int,int,int)
=	O
TST_CORRECTNESS	int
;	O
options	*(struct(*(char),int,int))
->	O
insert_order	enum(int,int,int,int,int,int,int,int)
=	O
INS_RANDOM	int
;	O
options	*(struct(*(char),int,int))
->	O
delete_order	enum(int,int,int,int,int)
=	O
DEL_RANDOM	int
;	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_TRACK	int
;	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
0	int
]	O
=	O
0	int
;	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
1	int
]	O
=	O
0	int
;	O
options	*(struct(*(char),int,int))
->	O
alloc_incr	int
=	O
0	int
;	O
options	*(struct(*(char),int,int))
->	O
node_cnt	int
=	O
15	int
;	O
options	*(struct(*(char),int,int))
->	O
iter_cnt	int
=	O
15	int
;	O
options	*(struct(*(char),int,int))
->	O
seed_given	int
=	O
0	int
;	O
options	*(struct(*(char),int,int))
->	O
verbosity	int
=	O
0	int
;	O
options	*(struct(*(char),int,int))
->	O
nonstop	int
=	O
0	int
;	O
if	O
(	O
*	O
args	array(struct(int,int,*(void),*(void)))
==	O
NULL	O
)	O
return	O
;	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
=	O
option_init	(*(struct(*(char),int,int)),*(*(char)))->(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))))
(	O
option_tab	array(struct(*(char),int,int))
,	O
args	array(struct(int,int,*(void),*(void)))
+	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
arg	array(int)
;	O
int	O
id	int
=	O
option_get	(*(struct(*(struct(*`,int,int)),*(*(char)),*(char))),*(*(char)))->(int)
(	O
state	*(struct(*(struct(*(char),int,int)),*(*(char)),*(char)))
,	O
&	O
arg	array(int)
)	O
;	O
if	O
(	O
id	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
id	int
)	O
{	O
case	O
't'	O
:	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"correctness"	*(char)
)	O
>=	O
3	int
)	O
options	*(struct(*(char),int,int))
->	O
test	enum(int,int,int)
=	O
TST_CORRECTNESS	int
;	O
else	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"overflow"	*(char)
)	O
>=	O
3	int
)	O
options	*(struct(*(char),int,int))
->	O
test	enum(int,int,int)
=	O
TST_OVERFLOW	int
;	O
else	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"null"	*(char)
)	O
>=	O
3	int
)	O
options	*(struct(*(char),int,int))
->	O
test	enum(int,int,int)
=	O
TST_NULL	int
;	O
else	O
fail	(*(char))->(void)
(	O
"unknown test \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
{	O
static	O
const	O
char	O
*	O
orders	array(*(char))
[	O
INS_CNT	int
]	O
=	O
{	O
"random"	*(char)
,	O
"ascending"	*(char)
,	O
"descending"	*(char)
,	O
"balanced"	*(char)
,	O
"zigzag"	*(char)
,	O
"asc-shifted"	*(char)
,	O
"custom"	*(char)
,	O
}	O
;	O
const	O
char	O
*	O
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
assert	O
(	O
sizeof	O
orders	array(*(char))
/	O
sizeof	O
*	O
orders	array(*(char))
==	O
INS_CNT	int
)	O
;	O
for	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
orders	array(*(char))
;	O
;	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
++	O
)	O
if	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
>=	O
orders	array(*(char))
+	O
INS_CNT	int
)	O
fail	(*(char))->(void)
(	O
"unknown order \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
else	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
arg	array(int)
)	O
>=	O
3	int
)	O
{	O
options	*(struct(*(char),int,int))
->	O
insert_order	enum(int,int,int,int,int,int,int,int)
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
-	O
orders	array(*(char))
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
'd'	O
:	O
{	O
static	O
const	O
char	O
*	O
orders	array(*(char))
[	O
DEL_CNT	int
]	O
=	O
{	O
"random"	*(char)
,	O
"reverse"	*(char)
,	O
"same"	*(char)
,	O
"custom"	*(char)
,	O
}	O
;	O
const	O
char	O
*	O
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
;	O
assert	O
(	O
sizeof	O
orders	array(*(char))
/	O
sizeof	O
*	O
orders	array(*(char))
==	O
DEL_CNT	int
)	O
;	O
for	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
=	O
orders	array(*(char))
;	O
;	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
++	O
)	O
if	O
(	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
>=	O
orders	array(*(char))
+	O
DEL_CNT	int
)	O
fail	(*(char))->(void)
(	O
"unknown order \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
else	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
*	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
,	O
arg	array(int)
)	O
>=	O
3	int
)	O
{	O
options	*(struct(*(char),int,int))
->	O
delete_order	enum(int,int,int,int,int)
=	O
iter	*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void)))
-	O
orders	array(*(char))
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"track"	*(char)
)	O
>=	O
3	int
)	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_TRACK	int
;	O
else	O
if	O
(	O
match_len	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"no-track"	*(char)
)	O
>=	O
3	int
)	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_NO_TRACK	int
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	array(int)
,	O
"fail"	*(char)
,	O
3	int
)	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
arg	array(int)
+	O
strcspn	(*(char),*(char))->(long)
(	O
arg	array(int)
,	O
"-%"	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'-'	O
)	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_FAIL_COUNT	int
;	O
else	O
if	O
(	O
*	O
p	*(void)
==	O
'%'	O
)	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_FAIL_PERCENT	int
;	O
else	O
fail	(*(char))->(void)
(	O
"invalid allocation policy \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
0	int
]	O
=	O
stoi	(*(char))->(int)
(	O
p	*(void)
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	array(int)
,	O
"suballoc"	*(char)
,	O
3	int
)	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
arg	array(int)
,	O
'-'	O
)	O
;	O
const	O
char	O
*	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
arg	array(int)
,	O
','	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
||	O
q	*(char)
==	O
NULL	O
)	O
fail	(*(char))->(void)
(	O
"invalid allocation policy \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
options	*(struct(*(char),int,int))
->	O
alloc_policy	enum(int,int,int,int,int)
=	O
MT_SUBALLOC	int
;	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
0	int
]	O
=	O
stoi	(*(char))->(int)
(	O
p	*(void)
+	O
1	int
)	O
;	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
1	int
]	O
=	O
stoi	(*(char))->(int)
(	O
q	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
MT_BLOCK_SIZE	int
]	O
<	O
32	int
)	O
fail	(*(char))->(void)
(	O
"block size too small"	*(char)
)	O
;	O
else	O
if	O
(	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
MT_ALIGN	int
]	O
>	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
MT_BLOCK_SIZE	int
]	O
)	O
fail	(*(char))->(void)
(	O
"alignment cannot be greater than block size"	*(char)
)	O
;	O
else	O
if	O
(	O
options	*(struct(*(char),int,int))
->	O
alloc_arg	array(int)
[	O
MT_ALIGN	int
]	O
<	O
1	int
)	O
fail	(*(char))->(void)
(	O
"alignment must be at least 1"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'A'	O
:	O
options	*(struct(*(char),int,int))
->	O
alloc_incr	int
=	O
stoi	(*(char))->(int)
(	O
arg	array(int)
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
options	*(struct(*(char),int,int))
->	O
node_cnt	int
=	O
stoi	(*(char))->(int)
(	O
arg	array(int)
)	O
;	O
if	O
(	O
options	*(struct(*(char),int,int))
->	O
node_cnt	int
<	O
1	int
)	O
fail	(*(char))->(void)
(	O
"bad tree size \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
options	*(struct(*(char),int,int))
->	O
iter_cnt	int
=	O
stoi	(*(char))->(int)
(	O
arg	array(int)
)	O
;	O
if	O
(	O
options	*(struct(*(char),int,int))
->	O
iter_cnt	int
<	O
1	int
)	O
fail	(*(char))->(void)
(	O
"bad repeat count \"%s\""	*(char)
,	O
arg	array(int)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
options	*(struct(*(char),int,int))
->	O
seed_given	int
=	O
1	int
;	O
options	*(struct(*(char),int,int))
->	O
seed	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	array(int)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
options	*(struct(*(char),int,int))
->	O
nonstop	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
options	*(struct(*(char),int,int))
->	O
verbosity	int
--	O
;	O
break	O
;	O
case	O
'v'	O
:	O
options	*(struct(*(char),int,int))
->	O
verbosity	int
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"GNU libavl 2.0\n"	*(char)
"Copyright (C) 1998-2002 Free Software Foundation, Inc.\n"	*(char)
"This program comes with NO WARRANTY, not even for\n"	*(char)
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	*(char)
"You may redistribute copies under the terms of the\n"	*(char)
"GNU General Public License.  For more information on\n"	*(char)
"these matters, see the file named COPYING.\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
permuted_integers	(array(int),long)->(void)
(	O
int	O
array	array(int)
[	O
]	O
,	O
size_t	long
n	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
array	array(int)
[	O
i	long
]	O
=	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
size_t	long
j	long
=	O
i	long
+	O
(	O
unsigned	O
)	O
rand	()->(int)
(	O
)	O
/	O
(	O
RAND_MAX	int
/	O
(	O
n	int
-	O
i	long
)	O
+	O
1	int
)	O
;	O
int	O
t	int
=	O
array	array(int)
[	O
j	long
]	O
;	O
array	array(int)
[	O
j	long
]	O
=	O
array	array(int)
[	O
i	long
]	O
;	O
array	array(int)
[	O
i	long
]	O
=	O
t	int
;	O
}	O
}	O
static	O
void	O
gen_balanced_tree	(int,int,*(*(int)))->(void)
(	O
int	O
min	int
,	O
int	O
max	int
,	O
int	O
*	O
*	O
array	array(int)
)	O
{	O
int	O
i	long
;	O
if	O
(	O
min	int
>	O
max	int
)	O
return	O
;	O
i	long
=	O
(	O
min	int
+	O
max	int
+	O
1	int
)	O
/	O
2	int
;	O
*	O
(	O
*	O
array	array(int)
)	O
++	O
=	O
i	long
;	O
gen_balanced_tree	(int,int,*(*(int)))->(void)
(	O
min	int
,	O
i	long
-	O
1	int
,	O
array	array(int)
)	O
;	O
gen_balanced_tree	(int,int,*(*(int)))->(void)
(	O
i	long
+	O
1	int
,	O
max	int
,	O
array	array(int)
)	O
;	O
}	O
static	O
void	O
gen_insertions	(long,enum(int,int,int,int,int,int,int,int),array(int))->(void)
(	O
size_t	long
n	int
,	O
enum	O
insert_order	enum(int,int,int,int,int,int,int,int)
insert_order	enum(int,int,int,int,int,int,int,int)
,	O
int	O
insert	array(int)
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
switch	O
(	O
insert_order	enum(int,int,int,int,int,int,int,int)
)	O
{	O
case	O
INS_RANDOM	int
:	O
permuted_integers	(array(int),long)->(void)
(	O
insert	array(int)
,	O
n	int
)	O
;	O
break	O
;	O
case	O
INS_ASCENDING	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
insert	array(int)
[	O
i	long
]	O
=	O
i	long
;	O
break	O
;	O
case	O
INS_DESCENDING	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
insert	array(int)
[	O
i	long
]	O
=	O
n	int
-	O
i	long
-	O
1	int
;	O
break	O
;	O
case	O
INS_BALANCED	int
:	O
gen_balanced_tree	(int,int,*(*(int)))->(void)
(	O
0	int
,	O
n	int
-	O
1	int
,	O
&	O
insert	array(int)
)	O
;	O
break	O
;	O
case	O
INS_ZIGZAG	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
i	long
%	O
2	int
==	O
0	int
)	O
insert	array(int)
[	O
i	long
]	O
=	O
i	long
/	O
2	int
;	O
else	O
insert	array(int)
[	O
i	long
]	O
=	O
n	int
-	O
i	long
/	O
2	int
-	O
1	int
;	O
break	O
;	O
case	O
INS_ASCENDING_SHIFTED	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
insert	array(int)
[	O
i	long
]	O
=	O
i	long
+	O
n	int
/	O
2	int
;	O
if	O
(	O
(	O
size_t	long
)	O
insert	array(int)
[	O
i	long
]	O
>=	O
n	int
)	O
insert	array(int)
[	O
i	long
]	O
-=	O
n	int
;	O
}	O
break	O
;	O
case	O
INS_CUSTOM	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
scanf	(*(char))->(int)
(	O
"%d"	*(char)
,	O
&	O
insert	array(int)
[	O
i	long
]	O
)	O
==	O
0	int
)	O
fail	(*(char))->(void)
(	O
"error reading insertion order from stdin"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
gen_deletions	(long,enum(int,int,int,int,int),*(int),*(int))->(void)
(	O
size_t	long
n	int
,	O
enum	O
delete_order	enum(int,int,int,int,int)
delete_order	enum(int,int,int,int,int)
,	O
const	O
int	O
*	O
insert	array(int)
,	O
int	O
*	O
delete	array(int)
)	O
{	O
size_t	long
i	long
;	O
switch	O
(	O
delete_order	enum(int,int,int,int,int)
)	O
{	O
case	O
DEL_RANDOM	int
:	O
permuted_integers	(array(int),long)->(void)
(	O
delete	array(int)
,	O
n	int
)	O
;	O
break	O
;	O
case	O
DEL_REVERSE	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
delete	array(int)
[	O
i	long
]	O
=	O
insert	array(int)
[	O
n	int
-	O
i	long
-	O
1	int
]	O
;	O
break	O
;	O
case	O
DEL_SAME	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
delete	array(int)
[	O
i	long
]	O
=	O
insert	array(int)
[	O
i	long
]	O
;	O
break	O
;	O
case	O
DEL_CUSTOM	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
scanf	(*(char))->(int)
(	O
"%d"	*(char)
,	O
&	O
delete	array(int)
[	O
i	long
]	O
)	O
==	O
0	int
)	O
fail	(*(char))->(void)
(	O
"error reading deletion order from stdin"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
unsigned	O
time_seed	()->(int)
(	O
void	O
)	O
{	O
time_t	long
timeval	long
;	O
unsigned	O
char	O
*	O
ptr	*(char)
;	O
unsigned	O
seed	int
;	O
size_t	long
i	long
;	O
timeval	long
=	O
time	(*(long))->(long)
(	O
NULL	O
)	O
;	O
ptr	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
timeval	long
;	O
seed	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sizeof	O
timeval	long
;	O
i	long
++	O
)	O
seed	int
=	O
seed	int
*	O
(	O
UCHAR_MAX	O
+	O
2u	int
)	O
+	O
ptr	*(char)
[	O
i	long
]	O
;	O
return	O
seed	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
struct	O
test_options	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
;	O
int	O
*	O
insert	array(int)
,	O
*	O
delete	array(int)
;	O
int	O
success	int
;	O
pgm_name	*(char)
=	O
argv	array(*(char))
[	O
0	int
]	O
!=	O
NULL	O
&&	O
argv	array(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'\0'	O
?	O
argv	array(*(char))
[	O
0	int
]	O
:	O
"bst-test"	*(char)
;	O
parse_command_line	(*(*(char)),*(struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)))->(void)
(	O
argv	array(*(char))
,	O
&	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
>=	O
0	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"bst-test for GNU libavl 2.0; use --help to get help.\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
seed_given	int
)	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
seed	int
=	O
time_seed	()->(int)
(	O
)	O
%	O
32768u	int
;	O
insert	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
insert	array(int)
*	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
)	O
;	O
delete	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
delete	array(int)
*	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
)	O
;	O
success	int
=	O
1	int
;	O
while	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
iter_cnt	int
--	O
)	O
{	O
struct	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
*	O
alloc	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
;	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
>=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Testing seed=%u"	*(char)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
seed	int
)	O
;	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_incr	int
)	O
printf	(*(char))->(int)
(	O
", alloc arg=%d"	*(char)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_arg	array(int)
[	O
0	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"...\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
srand	(int)->(void)
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
seed	int
)	O
;	O
gen_insertions	(long,enum(int,int,int,int,int,int,int,int),array(int))->(void)
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
insert_order	enum(int,int,int,int,int,int,int,int)
,	O
insert	array(int)
)	O
;	O
srand	(int)->(void)
(	O
++	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
seed	int
)	O
;	O
gen_deletions	(long,enum(int,int,int,int,int),*(int),*(int))->(void)
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
delete_order	enum(int,int,int,int,int)
,	O
insert	array(int)
,	O
delete	array(int)
)	O
;	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
>=	O
1	int
)	O
{	O
int	O
i	long
;	O
printf	(*(char))->(int)
(	O
"  Insertion order:"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
;	O
i	long
++	O
)	O
printf	(*(char))->(int)
(	O
" %d"	*(char)
,	O
insert	array(int)
[	O
i	long
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
".\n"	*(char)
)	O
;	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
test	enum(int,int,int)
==	O
TST_CORRECTNESS	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Deletion order:"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
;	O
i	long
++	O
)	O
printf	(*(char))->(int)
(	O
" %d"	*(char)
,	O
delete	array(int)
[	O
i	long
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
".\n"	*(char)
)	O
;	O
}	O
}	O
alloc	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
=	O
mt_create	(enum(int,int,int,int,int),array(int),int)->(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)))
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_policy	enum(int,int,int,int,int)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_arg	array(int)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
)	O
;	O
{	O
int	O
okay	int
;	O
struct	O
libavl_allocator	struct(*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),long)->(*(void))),*((*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),*(void))->(void)))
*	O
a	*(int)
=	O
mt_allocator	struct(struct(*((*(struct(*`,*`)),long)->(*(void))),*((*(struct(*`,*`)),*(void))->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),*(struct(*(struct(*(struct`),int,long,long,*(void))),int,long,long,*(void))),int,int)
(	O
alloc	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
;	O
switch	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
test	enum(int,int,int)
)	O
{	O
case	O
TST_CORRECTNESS	int
:	O
okay	int
=	O
test_correctness	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),array(int),array(int),int,int)->(int)
(	O
a	*(int)
,	O
insert	array(int)
,	O
delete	array(int)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
)	O
;	O
break	O
;	O
case	O
TST_OVERFLOW	int
:	O
okay	int
=	O
test_overflow	(*(struct(*((*`,long)->(*`)),*((*`,*`)->(void)))),array(int),int,int)->(int)
(	O
a	*(int)
,	O
insert	array(int)
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
node_cnt	int
,	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
)	O
;	O
break	O
;	O
case	O
TST_NULL	int
:	O
okay	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
okay	int
)	O
{	O
if	O
(	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
verbosity	int
>=	O
1	int
)	O
printf	(*(char))->(int)
(	O
"  No errors.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
success	int
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"  Error!\n"	*(char)
)	O
;	O
}	O
}	O
mt_destroy	(*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*`,int,long,long,*`)),*(struct(*`,int,long,long,*`)),int,int)))->(void)
(	O
alloc	*(struct(struct(*((*`,long)->(*`)),*((*`,*`)->(void))),enum(int,int,int,int,int),array(int),int,*(struct(*(struct`),int,long,long,*(void))),*(struct(*(struct`),int,long,long,*(void))),int,int))
)	O
;	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_arg	array(int)
[	O
0	int
]	O
+=	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
alloc_incr	int
;	O
if	O
(	O
!	O
success	int
&&	O
!	O
opts	struct(enum(int,int,int),enum(int,int,int,int,int,int,int,int),enum(int,int,int,int,int),enum(int,int,int,int,int),array(int),int,int,int,int,int,int,int)
.	O
nonstop	int
)	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
delete	array(int)
)	O
;	O
free	(*(void))->(void)
(	O
insert	array(int)
)	O
;	O
return	O
success	int
?	O
EXIT_SUCCESS	int
:	O
EXIT_FAILURE	int
;	O
}	O
