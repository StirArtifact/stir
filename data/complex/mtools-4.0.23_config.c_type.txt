static	O
char	O
buffer	array(char)
[	O
MAX_LINE_LEN	int
+	O
1	int
]	O
;	O
static	O
char	O
*	O
pos	array(char)
;	O
static	O
char	O
*	O
token	*(char)
;	O
static	O
size_t	long
token_length	long
;	O
static	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
int	O
linenumber	int
;	O
static	O
int	O
lastTokenLinenumber	int
;	O
static	O
const	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
static	O
int	O
file_nr	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
flag_mask	int
;	O
static	O
unsigned	O
int	O
cur_devs	int
;	O
static	O
int	O
cur_dev	int
;	O
static	O
int	O
trusted	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
nr_dev	int
;	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
static	O
int	O
token_nr	int
;	O
static	O
char	O
default_drive	char
=	O
'\0'	O
;	O
unsigned	O
int	O
mtools_skip_check	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_fat_compatibility	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_ignore_short_case	int
=	O
0	int
;	O
uint8_t	char
mtools_rate_0	char
=	O
0	int
;	O
uint8_t	char
mtools_rate_any	char
=	O
0	int
;	O
unsigned	O
int	O
mtools_no_vfat	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_numeric_tail	int
=	O
1	int
;	O
unsigned	O
int	O
mtools_dotted_dir	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_twenty_four_hour_clock	int
=	O
1	int
;	O
unsigned	O
int	O
mtools_lock_timeout	int
=	O
30	int
;	O
unsigned	O
int	O
mtools_default_codepage	int
=	O
850	int
;	O
const	O
char	O
*	O
mtools_date_string	*(char)
=	O
"yyyy-mm-dd"	*(char)
;	O
char	O
*	O
country_string	*(char)
=	O
0	int
;	O
typedef	O
struct	O
switches_l	struct(*(char),*(char),enum(int,int,int,int,int))
{	O
const	O
char	O
*	O
name	*(char)
;	O
caddr_t	*(char)
address	long
;	O
enum	O
{	O
T_INT	int
,	O
T_STRING	int
,	O
T_UINT	int
,	O
T_UINT8	int
,	O
T_UINT16	int
}	O
type	enum(int,int,int,int)
;	O
}	O
switches_t	struct(*(char),*(char),enum(int,int,int,int,int))
;	O
static	O
switches_t	struct(*(char),*(char),enum(int,int,int,int,int))
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"MTOOLS_LOWER_CASE"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_ignore_short_case	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_FAT_COMPATIBILITY"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_fat_compatibility	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_SKIP_CHECK"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_skip_check	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_NO_VFAT"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_no_vfat	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_RATE_0"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_rate_0	char
,	O
T_UINT8	int
}	O
,	O
{	O
"MTOOLS_RATE_ANY"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_rate_any	char
,	O
T_UINT8	int
}	O
,	O
{	O
"MTOOLS_NAME_NUMERIC_TAIL"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_numeric_tail	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_DOTTED_DIR"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_dotted_dir	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_TWENTY_FOUR_HOUR_CLOCK"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_twenty_four_hour_clock	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_DATE_STRING"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_date_string	*(char)
,	O
T_STRING	int
}	O
,	O
{	O
"MTOOLS_LOCK_TIMEOUT"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_lock_timeout	int
,	O
T_UINT	int
}	O
,	O
{	O
"DEFAULT_CODEPAGE"	*(char)
,	O
(	O
caddr_t	*(char)
)	O
&	O
mtools_default_codepage	int
,	O
T_UINT	int
}	O
}	O
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
int	O
flag	*(int)
;	O
}	O
flags_t	struct(*(char),int)
;	O
static	O
flags_t	struct(*(char),int)
openflags	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"sync"	*(char)
,	O
O_SYNC	int
}	O
,	O
{	O
"nodelay"	*(char)
,	O
O_NDELAY	O
}	O
,	O
{	O
"exclusive"	*(char)
,	O
O_EXCL	int
}	O
,	O
{	O
"none"	*(char)
,	O
0	int
}	O
}	O
;	O
static	O
flags_t	struct(*(char),int)
misc_flags	int
[	O
]	O
=	O
{	O
{	O
"use_xdf"	*(char)
,	O
USE_XDF_FLAG	int
}	O
,	O
{	O
"scsi"	*(char)
,	O
SCSI_FLAG	int
}	O
,	O
{	O
"nolock"	*(char)
,	O
NOLOCK_FLAG	int
}	O
,	O
{	O
"mformat_only"	*(char)
,	O
MFORMAT_ONLY_FLAG	int
}	O
,	O
{	O
"filter"	*(char)
,	O
FILTER_FLAG	int
}	O
,	O
{	O
"privileged"	*(char)
,	O
PRIV_FLAG	int
}	O
,	O
{	O
"vold"	*(char)
,	O
VOLD_FLAG	int
}	O
,	O
{	O
"remote"	*(char)
,	O
FLOPPYD_FLAG	int
}	O
,	O
{	O
"swap"	*(char)
,	O
SWAP_FLAG	int
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
signed	O
char	O
fat_bits	int
;	O
unsigned	O
int	O
tracks	int
;	O
unsigned	O
short	O
heads	short
;	O
unsigned	O
short	O
sectors	short
;	O
}	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
]	O
=	O
{	O
{	O
"hd514"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"high-density-5-1/4"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"1.2m"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"hd312"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"high-density-3-1/2"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"1.44m"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"dd312"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"double-density-3-1/2"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"720k"	*(char)
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"dd514"	*(char)
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"double-density-5-1/4"	*(char)
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"360k"	*(char)
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"320k"	*(char)
,	O
12	int
,	O
40	int
,	O
2	int
,	O
8	int
}	O
,	O
{	O
"180k"	*(char)
,	O
12	int
,	O
40	int
,	O
1	int
,	O
9	int
}	O
,	O
{	O
"160k"	*(char)
,	O
12	int
,	O
40	int
,	O
1	int
,	O
8	int
}	O
}	O
;	O
static	O
switches_t	struct(*(char),*(char),enum(int,int,int,int,int))
dswitches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"FILE"	*(char)
,	O
OFFS	O
(	O
name	*(char)
)	O
,	O
T_STRING	int
}	O
,	O
{	O
"OFFSET"	*(char)
,	O
OFFS	O
(	O
offset	long
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"PARTITION"	*(char)
,	O
OFFS	O
(	O
partition	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"FAT"	*(char)
,	O
OFFS	O
(	O
fat_bits	int
)	O
,	O
T_INT	int
}	O
,	O
{	O
"FAT_BITS"	*(char)
,	O
OFFS	O
(	O
fat_bits	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"MODE"	*(char)
,	O
OFFS	O
(	O
mode	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"TRACKS"	*(char)
,	O
OFFS	O
(	O
tracks	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"CYLINDERS"	*(char)
,	O
OFFS	O
(	O
tracks	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"HEADS"	*(char)
,	O
OFFS	O
(	O
heads	short
)	O
,	O
T_UINT16	int
}	O
,	O
{	O
"SECTORS"	*(char)
,	O
OFFS	O
(	O
sectors	short
)	O
,	O
T_UINT16	int
}	O
,	O
{	O
"HIDDEN"	*(char)
,	O
OFFS	O
(	O
hidden	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"PRECMD"	*(char)
,	O
OFFS	O
(	O
precmd	*(char)
)	O
,	O
T_STRING	int
}	O
,	O
{	O
"BLOCKSIZE"	*(char)
,	O
OFFS	O
(	O
blocksize	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"CODEPAGE"	*(char)
,	O
OFFS	O
(	O
codepage	int
)	O
,	O
T_UINT	int
}	O
}	O
;	O
static	O
void	O
maintain_default_drive	(char)->(void)
(	O
char	O
drive	char
)	O
{	O
if	O
(	O
default_drive	char
==	O
':'	O
)	O
return	O
;	O
if	O
(	O
default_drive	char
==	O
'\0'	O
||	O
default_drive	char
>	O
drive	char
)	O
default_drive	char
=	O
drive	char
;	O
}	O
char	O
get_default_drive	()->(char)
(	O
void	O
)	O
{	O
if	O
(	O
default_drive	char
!=	O
'\0'	O
)	O
return	O
default_drive	char
;	O
else	O
return	O
'A'	O
;	O
}	O
static	O
void	O
syntax	(*(char),int)->(void)
(	O
const	O
char	O
*	O
msg	*(char)
,	O
int	O
thisLine	int
)	O
NORETURN	O
;	O
static	O
void	O
syntax	(*(char),int)->(void)
(	O
const	O
char	O
*	O
msg	*(char)
,	O
int	O
thisLine	int
)	O
{	O
char	O
drive	char
=	O
'\0'	O
;	O
if	O
(	O
thisLine	int
)	O
lastTokenLinenumber	int
=	O
linenumber	int
;	O
if	O
(	O
cur_dev	int
>=	O
0	int
)	O
drive	char
=	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Syntax error at line %d "	*(char)
,	O
lastTokenLinenumber	int
)	O
;	O
if	O
(	O
drive	char
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"for drive %c: "	*(char)
,	O
drive	char
)	O
;	O
if	O
(	O
token	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"column %ld "	*(char)
,	O
(	O
long	O
)	O
(	O
token	*(char)
-	O
buffer	array(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"in file %s: %s\n"	*(char)
,	O
filename	*(char)
,	O
msg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
static	O
void	O
get_env_conf	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
/	O
sizeof	O
(	O
*	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
;	O
i	int
++	O
)	O
{	O
s	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
if	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_INT	int
)	O
*	O
(	O
(	O
int	O
*	O
)	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
int	O
)	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
s	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT	int
)	O
*	O
(	O
(	O
unsigned	O
int	O
*	O
)	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
unsigned	O
int	O
)	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
s	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT8	int
)	O
*	O
(	O
(	O
uint8_t	char
*	O
)	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
uint8_t	char
)	O
strtou8	(*(char),*(*(char)),int)->(char)
(	O
s	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT16	int
)	O
*	O
(	O
(	O
uint16_t	short
*	O
)	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
uint16_t	short
)	O
strtou8	(*(char),*(*(char)),int)->(char)
(	O
s	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_STRING	int
)	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
)	O
=	O
s	*(char)
;	O
}	O
}	O
}	O
static	O
int	O
mtools_getline	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
||	O
!	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buffer	array(char)
,	O
MAX_LINE_LEN	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
-	O
1	int
;	O
linenumber	int
++	O
;	O
pos	array(char)
=	O
buffer	array(char)
;	O
token_nr	int
=	O
0	int
;	O
buffer	array(char)
[	O
MAX_LINE_LEN	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
buffer	array(char)
)	O
==	O
MAX_LINE_LEN	int
)	O
syntax	(*(char),int)->(void)
(	O
"line too long"	*(char)
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
skip_junk	(int)->(void)
(	O
int	O
expect	int
)	O
{	O
lastTokenLinenumber	int
=	O
linenumber	int
;	O
while	O
(	O
!	O
pos	array(char)
||	O
!	O
*	O
pos	array(char)
||	O
strchr	(*(char),int)->(*(char))
(	O
" #\n\t"	*(char)
,	O
*	O
pos	array(char)
)	O
)	O
{	O
if	O
(	O
!	O
pos	array(char)
||	O
!	O
*	O
pos	array(char)
||	O
*	O
pos	array(char)
==	O
'#'	O
)	O
{	O
if	O
(	O
mtools_getline	()->(int)
(	O
)	O
)	O
{	O
pos	array(char)
=	O
0	int
;	O
if	O
(	O
expect	int
)	O
syntax	(*(char),int)->(void)
(	O
"end of file unexpected"	*(char)
,	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
pos	array(char)
++	O
;	O
}	O
token_nr	int
++	O
;	O
}	O
static	O
char	O
*	O
get_next_token	()->(*(char))
(	O
void	O
)	O
{	O
skip_junk	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
!	O
pos	array(char)
)	O
{	O
token_length	long
=	O
0	int
;	O
token	*(char)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
token	*(char)
=	O
pos	array(char)
;	O
token_length	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
token	*(char)
,	O
" \t\n#:="	*(char)
)	O
;	O
pos	array(char)
+=	O
token_length	long
;	O
return	O
token	*(char)
;	O
}	O
static	O
int	O
match_token	(*(char))->(int)
(	O
const	O
char	O
*	O
template	*(char)
)	O
{	O
return	O
(	O
strlen	(*(char))->(long)
(	O
template	*(char)
)	O
==	O
token_length	long
&&	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
template	*(char)
,	O
token	*(char)
,	O
token_length	long
)	O
)	O
;	O
}	O
static	O
void	O
expect_char	(char)->(void)
(	O
char	O
c	char
)	O
{	O
char	O
buf	*(char)
[	O
11	int
]	O
;	O
skip_junk	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
*	O
pos	array(char)
!=	O
c	char
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"expected %c"	*(char)
,	O
c	char
)	O
;	O
syntax	(*(char),int)->(void)
(	O
buf	*(char)
,	O
1	int
)	O
;	O
}	O
pos	array(char)
++	O
;	O
}	O
static	O
char	O
*	O
get_string	()->(*(char))
(	O
void	O
)	O
{	O
char	O
*	O
end	*(char)
,	O
*	O
str	*(char)
;	O
skip_junk	(int)->(void)
(	O
1	int
)	O
;	O
if	O
(	O
*	O
pos	array(char)
!=	O
'"'	O
)	O
syntax	(*(char),int)->(void)
(	O
" \" expected"	*(char)
,	O
0	int
)	O
;	O
str	*(char)
=	O
pos	array(char)
+	O
1	int
;	O
end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
str	*(char)
,	O
'\"'	O
)	O
;	O
if	O
(	O
!	O
end	*(char)
)	O
syntax	(*(char),int)->(void)
(	O
"unterminated string constant"	*(char)
,	O
1	int
)	O
;	O
*	O
end	*(char)
=	O
'\0'	O
;	O
pos	array(char)
=	O
end	*(char)
+	O
1	int
;	O
return	O
str	*(char)
;	O
}	O
static	O
unsigned	O
long	O
get_unumber	(long)->(long)
(	O
unsigned	O
long	O
max	long
)	O
{	O
char	O
*	O
last	*(char)
;	O
unsigned	O
long	O
n	int
;	O
skip_junk	(int)->(void)
(	O
1	int
)	O
;	O
last	*(char)
=	O
pos	array(char)
;	O
n	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
pos	array(char)
,	O
&	O
pos	array(char)
,	O
0	int
)	O
;	O
if	O
(	O
last	*(char)
==	O
pos	array(char)
)	O
syntax	(*(char),int)->(void)
(	O
"numeral expected"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
n	int
>	O
max	long
)	O
syntax	(*(char),int)->(void)
(	O
"number too big"	*(char)
,	O
0	int
)	O
;	O
pos	array(char)
++	O
;	O
token_nr	int
++	O
;	O
return	O
n	int
;	O
}	O
static	O
int	O
get_number	()->(int)
(	O
void	O
)	O
{	O
char	O
*	O
last	*(char)
;	O
int	O
n	int
;	O
skip_junk	(int)->(void)
(	O
1	int
)	O
;	O
last	*(char)
=	O
pos	array(char)
;	O
n	int
=	O
(	O
int	O
)	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
pos	array(char)
,	O
&	O
pos	array(char)
,	O
0	int
)	O
;	O
if	O
(	O
last	*(char)
==	O
pos	array(char)
)	O
syntax	(*(char),int)->(void)
(	O
"numeral expected"	*(char)
,	O
0	int
)	O
;	O
pos	array(char)
++	O
;	O
token_nr	int
++	O
;	O
return	O
n	int
;	O
}	O
static	O
void	O
purge	(char,int)->(void)
(	O
char	O
drive	char
,	O
int	O
fn	int
)	O
{	O
unsigned	O
int	O
i	int
,	O
j	int
;	O
drive	char
=	O
ch_toupper	(char)->(char)
(	O
drive	char
)	O
;	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
cur_devs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
i	int
]	O
.	O
drive	char
!=	O
drive	char
||	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
i	int
]	O
.	O
file_nr	int
==	O
fn	int
)	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
j	int
++	O
]	O
=	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
i	int
]	O
;	O
}	O
cur_devs	int
=	O
j	int
;	O
}	O
static	O
void	O
grow	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
cur_devs	int
>=	O
nr_dev	int
-	O
2	int
)	O
{	O
nr_dev	int
=	O
(	O
cur_devs	int
+	O
2	int
)	O
<<	O
1	int
;	O
if	O
(	O
!	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
=	O
Grow	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
nr_dev	int
,	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
)	O
)	O
)	O
{	O
printOom	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
init_drive	()->(void)
(	O
void	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
)	O
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
ssize	char
=	O
2	int
;	O
}	O
static	O
void	O
prepend	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	int
;	O
grow	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
cur_devs	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
i	int
]	O
=	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
i	int
-	O
1	int
]	O
;	O
cur_dev	int
=	O
0	int
;	O
cur_devs	int
++	O
;	O
init_drive	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
append	()->(void)
(	O
void	O
)	O
{	O
grow	()->(void)
(	O
)	O
;	O
cur_dev	int
=	O
cur_devs	int
;	O
cur_devs	int
++	O
;	O
init_drive	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
finish_drive_clause	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
cur_dev	int
==	O
-	O
1	int
)	O
{	O
trusted	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
)	O
syntax	(*(char),int)->(void)
(	O
"missing filename"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
||	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
||	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
)	O
{	O
if	O
(	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
||	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
||	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
)	O
syntax	(*(char),int)->(void)
(	O
"incomplete geometry: either indicate all of track/heads/sectors or none of them"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&	O
(	O
MFORMAT_ONLY_FLAG	int
|	O
FILTER_FLAG	int
)	O
)	O
)	O
syntax	(*(char),int)->(void)
(	O
"if you supply a geometry, you also must supply one of the `mformat_only' or `filter' flags"	*(char)
,	O
0	int
)	O
;	O
}	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
file_nr	int
=	O
file_nr	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
cfg_filename	*(char)
=	O
filename	*(char)
;	O
if	O
(	O
!	O
(	O
flag_mask	int
&	O
PRIV_FLAG	int
)	O
&&	O
IS_SCSI	O
(	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
)	O
)	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
misc_flags	int
|=	O
PRIV_FLAG	int
;	O
if	O
(	O
!	O
trusted	int
&&	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&	O
PRIV_FLAG	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: privileged flag ignored for drive %c: defined in file %s\n"	*(char)
,	O
toupper	(int)->(int)
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
,	O
filename	*(char)
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&=	O
~	O
PRIV_FLAG	int
;	O
}	O
trusted	int
=	O
0	int
;	O
cur_dev	int
=	O
-	O
1	int
;	O
}	O
static	O
int	O
set_var	(*(struct(*(char),*(char),enum(int,int,int,int,int))),int,*(char))->(int)
(	O
struct	O
switches_l	struct(*(char),*(char),enum(int,int,int,int,int))
*	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
,	O
int	O
nr	int
,	O
caddr_t	*(char)
base_address	*(char)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nr	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	(*(char))->(int)
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
{	O
expect_char	(char)->(void)
(	O
'='	O
)	O
;	O
if	O
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT	int
)	O
*	O
(	O
(	O
unsigned	O
int	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
+	O
base_address	*(char)
)	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
get_unumber	(long)->(long)
(	O
UINT_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT8	int
)	O
*	O
(	O
(	O
uint8_t	char
*	O
)	O
(	O
(	O
long	O
)	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
+	O
base_address	*(char)
)	O
)	O
=	O
(	O
uint8_t	char
)	O
get_unumber	(long)->(long)
(	O
UINT8_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_UINT16	int
)	O
*	O
(	O
(	O
uint16_t	short
*	O
)	O
(	O
(	O
long	O
)	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
+	O
base_address	*(char)
)	O
)	O
=	O
(	O
uint16_t	short
)	O
get_unumber	(long)->(long)
(	O
UINT16_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_INT	int
)	O
*	O
(	O
(	O
int	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
+	O
base_address	*(char)
)	O
)	O
=	O
get_number	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
T_STRING	int
)	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	*(struct(*(char),*(char),enum(int,int,int,int,int)))
[	O
i	int
]	O
.	O
address	long
+	O
base_address	*(char)
)	O
)	O
=	O
strdup	(*(char))->(*(char))
(	O
get_string	()->(*(char))
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_openflags	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
openflags	array(struct(*(char),int))
)	O
/	O
sizeof	O
(	O
*	O
openflags	array(struct(*(char),int))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	(*(char))->(int)
(	O
openflags	array(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
{	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
|=	O
openflags	array(struct(*(char),int))
[	O
i	int
]	O
.	O
flag	*(int)
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_misc_flags	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
misc_flags	int
)	O
/	O
sizeof	O
(	O
*	O
misc_flags	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	(*(char))->(int)
(	O
misc_flags	int
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
{	O
flag_mask	int
|=	O
misc_flags	int
[	O
i	int
]	O
.	O
flag	*(int)
;	O
skip_junk	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
pos	array(char)
&&	O
*	O
pos	array(char)
==	O
'='	O
)	O
{	O
pos	array(char)
++	O
;	O
switch	O
(	O
get_number	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
1	int
:	O
break	O
;	O
default	O
:	O
syntax	(*(char),int)->(void)
(	O
"expected 0 or 1"	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
misc_flags	int
|=	O
misc_flags	int
[	O
i	int
]	O
.	O
flag	*(int)
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_def_format	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
default_formats	array(struct(*(char),char,int,short,short))
)	O
/	O
sizeof	O
(	O
*	O
default_formats	array(struct(*(char),char,int,short,short))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	(*(char))->(int)
(	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
ssize	char
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
ssize	char
=	O
2	int
;	O
if	O
(	O
!	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
tracks	int
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
tracks	int
=	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
i	int
]	O
.	O
tracks	int
;	O
if	O
(	O
!	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
heads	short
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
heads	short
=	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
i	int
]	O
.	O
heads	short
;	O
if	O
(	O
!	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
sectors	short
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
sectors	short
=	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
i	int
]	O
.	O
sectors	short
;	O
if	O
(	O
!	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
fat_bits	int
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
fat_bits	int
=	O
default_formats	array(struct(*(char),char,int,short,short))
[	O
i	int
]	O
.	O
fat_bits	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
parse_one	(int)->(int)
(	O
int	O
privilege	int
)	O
;	O
void	O
set_cmd_line_image	(*(char))->(void)
(	O
char	O
*	O
img	*(char)
)	O
{	O
char	O
*	O
ofsp	*(char)
;	O
prepend	()->(void)
(	O
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
':'	O
;	O
default_drive	char
=	O
':'	O
;	O
ofsp	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
img	*(char)
,	O
"@@"	*(char)
)	O
;	O
if	O
(	O
ofsp	*(char)
==	O
NULL	O
)	O
{	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
img	*(char)
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
0	int
;	O
}	O
else	O
{	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
=	O
strndup	(*(char),long)->(*(char))
(	O
img	*(char)
,	O
ofsp	*(char)
-	O
img	*(char)
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
str_to_offset	(*(char))->(long)
(	O
ofsp	*(char)
+	O
2	int
)	O
;	O
}	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
fat_bits	int
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
,	O
'|'	O
)	O
)	O
{	O
char	O
*	O
pipechar	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
,	O
'|'	O
)	O
;	O
*	O
pipechar	*(char)
=	O
0	int
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buffer	array(char)
,	O
pipechar	*(char)
+	O
1	int
,	O
MAX_LINE_LEN	int
)	O
;	O
buffer	array(char)
[	O
MAX_LINE_LEN	int
]	O
=	O
'\0'	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
filename	*(char)
=	O
"{command line}"	*(char)
;	O
linenumber	int
=	O
0	int
;	O
lastTokenLinenumber	int
=	O
0	int
;	O
pos	array(char)
=	O
buffer	array(char)
;	O
token	*(char)
=	O
0	int
;	O
while	O
(	O
parse_one	(int)->(int)
(	O
0	int
)	O
)	O
;	O
}	O
}	O
static	O
uint16_t	short
tou16	(int,*(char))->(short)
(	O
int	O
in	int
,	O
const	O
char	O
*	O
comment	*(char)
)	O
{	O
if	O
(	O
in	int
>	O
UINT16_MAX	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Number of %s %d too big\n"	*(char)
,	O
comment	*(char)
,	O
in	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
in	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Number of %s %d negative\n"	*(char)
,	O
comment	*(char)
,	O
in	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
(	O
uint16_t	short
)	O
in	int
;	O
}	O
static	O
void	O
parse_old_device_line	(char)->(void)
(	O
char	O
drive	char
)	O
{	O
char	O
name	*(char)
[	O
MAXPATHLEN	O
]	O
;	O
int	O
items	int
;	O
long	O
offset	long
;	O
int	O
heads	short
,	O
sectors	short
;	O
finish_drive_clause	()->(void)
(	O
)	O
;	O
purge	(char,int)->(void)
(	O
drive	char
,	O
file_nr	int
)	O
;	O
append	()->(void)
(	O
)	O
;	O
items	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
token	*(char)
,	O
"%c %s %i %i %i %i %li"	*(char)
,	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
,	O
name	*(char)
,	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
fat_bits	int
,	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
,	O
&	O
heads	short
,	O
&	O
sectors	short
,	O
&	O
offset	long
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
tou16	(int,*(char))->(short)
(	O
heads	short
,	O
"heads"	*(char)
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
tou16	(int,*(char))->(short)
(	O
sectors	short
,	O
"sectors"	*(char)
)	O
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
(	O
off_t	long
)	O
offset	long
;	O
switch	O
(	O
items	int
)	O
{	O
case	O
2	int
:	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
fat_bits	int
=	O
0	int
;	O
case	O
3	int
:	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
=	O
0	int
;	O
case	O
6	int
:	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
0	int
;	O
default	O
:	O
break	O
;	O
case	O
0	int
:	O
case	O
1	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
syntax	(*(char),int)->(void)
(	O
"bad number of parameters"	*(char)
,	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
tracks	int
)	O
{	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
}	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
ch_toupper	(char)->(char)
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
maintain_default_drive	(char)->(void)
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
if	O
(	O
!	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
)	O
{	O
printOom	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
misc_flags	int
|=	O
MFORMAT_ONLY_FLAG	int
;	O
finish_drive_clause	()->(void)
(	O
)	O
;	O
pos	array(char)
=	O
0	int
;	O
}	O
static	O
int	O
parse_one	(int)->(int)
(	O
int	O
privilege	int
)	O
{	O
int	O
action	int
=	O
0	int
;	O
get_next_token	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
token	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
(	O
match_token	(*(char))->(int)
(	O
"drive"	*(char)
)	O
&&	O
(	O
(	O
action	int
=	O
1	int
)	O
)	O
)	O
||	O
(	O
match_token	(*(char))->(int)
(	O
"drive+"	*(char)
)	O
&&	O
(	O
(	O
action	int
=	O
2	int
)	O
)	O
)	O
||	O
(	O
match_token	(*(char))->(int)
(	O
"+drive"	*(char)
)	O
&&	O
(	O
(	O
action	int
=	O
3	int
)	O
)	O
)	O
||	O
(	O
match_token	(*(char))->(int)
(	O
"clear_drive"	*(char)
)	O
&&	O
(	O
(	O
action	int
=	O
4	int
)	O
)	O
)	O
)	O
{	O
finish_drive_clause	()->(void)
(	O
)	O
;	O
get_next_token	()->(*(char))
(	O
)	O
;	O
if	O
(	O
token_length	long
!=	O
1	int
)	O
syntax	(*(char),int)->(void)
(	O
"drive letter expected"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
action	int
==	O
1	int
||	O
action	int
==	O
4	int
)	O
purge	(char,int)->(void)
(	O
token	*(char)
[	O
0	int
]	O
,	O
file_nr	int
)	O
;	O
if	O
(	O
action	int
==	O
4	int
)	O
return	O
1	int
;	O
if	O
(	O
action	int
==	O
3	int
)	O
prepend	()->(void)
(	O
)	O
;	O
else	O
append	()->(void)
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
+	O
cur_dev	int
)	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
;	O
trusted	int
=	O
privilege	int
;	O
flag_mask	int
=	O
0	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
ch_toupper	(char)->(char)
(	O
token	*(char)
[	O
0	int
]	O
)	O
;	O
maintain_default_drive	(char)->(void)
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
expect_char	(char)->(void)
(	O
':'	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
token_nr	int
==	O
1	int
&&	O
token_length	long
==	O
1	int
)	O
{	O
parse_old_device_line	(char)->(void)
(	O
token	*(char)
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
cur_dev	int
<	O
0	int
||	O
(	O
set_var	(*(struct(*(char),*(char),enum(int,int,int,int,int))),int,*(char))->(int)
(	O
dswitches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
,	O
sizeof	O
(	O
dswitches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
/	O
sizeof	O
(	O
*	O
dswitches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
,	O
(	O
caddr_t	*(char)
)	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
)	O
&&	O
set_openflags	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
)	O
&&	O
set_misc_flags	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
)	O
&&	O
set_def_format	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))))->(int)
(	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_dev	int
]	O
)	O
)	O
)	O
&&	O
set_var	(*(struct(*(char),*(char),enum(int,int,int,int,int))),int,*(char))->(int)
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
,	O
sizeof	O
(	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
/	O
sizeof	O
(	O
*	O
global_switches	array(struct(*(char),*(char),enum(int,int,int,int,int)))
)	O
,	O
0	int
)	O
)	O
syntax	(*(char),int)->(void)
(	O
"unrecognized keyword"	*(char)
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
parse	(*(char),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
privilege	int
)	O
{	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"File descriptor already set!\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
0	int
;	O
file_nr	int
++	O
;	O
filename	*(char)
=	O
name	*(char)
;	O
linenumber	int
=	O
0	int
;	O
lastTokenLinenumber	int
=	O
0	int
;	O
pos	array(char)
=	O
0	int
;	O
token	*(char)
=	O
0	int
;	O
cur_dev	int
=	O
-	O
1	int
;	O
while	O
(	O
parse_one	(int)->(int)
(	O
privilege	int
)	O
)	O
;	O
finish_drive_clause	()->(void)
(	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
filename	*(char)
=	O
NULL	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
void	O
read_config	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
homedir	*(char)
;	O
char	O
*	O
envConfFile	*(char)
;	O
static	O
char	O
conf_file	array(char)
[	O
MAXPATHLEN	O
+	O
sizeof	O
(	O
CFG_FILE1	*(char)
)	O
]	O
;	O
file_nr	int
=	O
0	int
;	O
cur_devs	int
=	O
nr_const_devices	int
;	O
nr_dev	int
=	O
nr_const_devices	int
+	O
2	int
;	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
=	O
NewArray	O
(	O
nr_dev	int
,	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
)	O
;	O
if	O
(	O
!	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
{	O
printOom	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nr_const_devices	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
const_devices	array(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
nr_const_devices	int
*	O
sizeof	O
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
)	O
)	O
;	O
(	O
void	O
)	O
(	O
(	O
parse	(*(char),int)->(int)
(	O
CONF_FILE	*(char)
,	O
1	int
)	O
|	O
parse	(*(char),int)->(int)
(	O
LOCAL_CONF_FILE	*(char)
,	O
1	int
)	O
|	O
parse	(*(char),int)->(int)
(	O
SYS_CONF_FILE	O
,	O
1	int
)	O
)	O
||	O
(	O
parse	(*(char),int)->(int)
(	O
OLD_CONF_FILE	*(char)
,	O
1	int
)	O
|	O
parse	(*(char),int)->(int)
(	O
OLD_LOCAL_CONF_FILE	*(char)
,	O
1	int
)	O
)	O
)	O
;	O
homedir	*(char)
=	O
get_homedir	()->(*(char))
(	O
)	O
;	O
if	O
(	O
homedir	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
conf_file	array(char)
,	O
homedir	*(char)
,	O
MAXPATHLEN	O
)	O
;	O
conf_file	array(char)
[	O
MAXPATHLEN	O
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
conf_file	array(char)
,	O
CFG_FILE1	*(char)
)	O
;	O
parse	(*(char),int)->(int)
(	O
conf_file	array(char)
,	O
0	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
&	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
[	O
cur_devs	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
)	O
)	O
;	O
envConfFile	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"MTOOLSRC"	*(char)
)	O
;	O
if	O
(	O
envConfFile	*(char)
)	O
parse	(*(char),int)->(int)
(	O
envConfFile	*(char)
,	O
0	int
)	O
;	O
get_env_conf	()->(void)
(	O
)	O
;	O
if	O
(	O
mtools_skip_check	int
)	O
mtools_fat_compatibility	int
=	O
1	int
;	O
}	O
void	O
mtoolstest	(int,*(*(char)),int)->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
type	enum(int,int,int,int)
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mtoolstest	(int,*(*(char)),int)->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
type	enum(int,int,int,int)
UNUSEDP	O
)	O
{	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
char	O
drive	char
=	O
'\0'	O
;	O
if	O
(	O
argc	int
>	O
1	int
&&	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
&&	O
argv	*(*(char))
[	O
1	int
]	O
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
drive	char
=	O
ch_toupper	(char)->(char)
(	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
for	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
=	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
name	*(char)
;	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
++	O
)	O
{	O
if	O
(	O
drive	char
&&	O
drive	char
!=	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
drive	char
)	O
continue	O
;	O
printf	(*(char))->(int)
(	O
"drive %c:\n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
drive	char
)	O
;	O
printf	(*(char))->(int)
(	O
"\t#fn=%d mode=%d "	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
file_nr	int
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
cfg_filename	*(char)
)	O
printf	(*(char))->(int)
(	O
"defined in %s\n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
cfg_filename	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"builtin\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\tfile=\"%s\" fat_bits=%d \n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
name	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
fat_bits	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\ttracks=%d heads=%d sectors=%d hidden=%d\n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
tracks	int
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
heads	short
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
sectors	short
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
hidden	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\toffset=0x%lx\n"	*(char)
,	O
(	O
long	O
)	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
offset	long
)	O
;	O
printf	(*(char))->(int)
(	O
"\tpartition=%d\n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
misc_flags	int
)	O
printf	(*(char))->(int)
(	O
"\t"	*(char)
)	O
;	O
if	O
(	O
DO_SWAP	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"swap "	*(char)
)	O
;	O
if	O
(	O
IS_SCSI	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"scsi "	*(char)
)	O
;	O
if	O
(	O
IS_PRIVILEGED	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"privileged"	*(char)
)	O
;	O
if	O
(	O
IS_MFORMAT_ONLY	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"mformat_only "	*(char)
)	O
;	O
if	O
(	O
SHOULD_USE_VOLD	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"vold "	*(char)
)	O
;	O
if	O
(	O
SHOULD_USE_XDF	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
printf	(*(char))->(int)
(	O
"use_xdf "	*(char)
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
misc_flags	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
)	O
printf	(*(char))->(int)
(	O
"\t"	*(char)
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
&	O
O_SYNC	int
)	O
printf	(*(char))->(int)
(	O
"sync "	*(char)
)	O
;	O
if	O
(	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
&	O
O_NDELAY	O
)	O
)	O
printf	(*(char))->(int)
(	O
"nodelay "	*(char)
)	O
;	O
if	O
(	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
&	O
O_EXCL	int
)	O
)	O
printf	(*(char))->(int)
(	O
"exclusive "	*(char)
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
mode	int
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
precmd	*(char)
)	O
printf	(*(char))->(int)
(	O
"\tprecmd=%s\n"	*(char)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
precmd	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"mtools_fat_compatibility=%d\n"	*(char)
,	O
mtools_fat_compatibility	int
)	O
;	O
printf	(*(char))->(int)
(	O
"mtools_skip_check=%d\n"	*(char)
,	O
mtools_skip_check	int
)	O
;	O
printf	(*(char))->(int)
(	O
"mtools_lower_case=%d\n"	*(char)
,	O
mtools_ignore_short_case	int
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
