static	O
void	O
yyprint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),short,union(struct(*(char),long),*(char),*(struct),int,*(struct)))->(void)
(	O
FILE	struct
*	O
output	*(char)
,	O
unsigned	O
short	O
toknum	short
,	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
val	*(char)
)	O
{	O
switch	O
(	O
toknum	short
)	O
{	O
case	O
TYPE	int
:	O
case	O
IDENT	int
:	O
case	O
STRING	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(char)
,	O
"[%lu] %s"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
val	*(char)
.	O
string	*(char)
.	O
len	long
,	O
val	*(char)
.	O
string	*(char)
.	O
ptr	*(*(void))
)	O
;	O
break	O
;	O
case	O
EOL	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(char)
,	O
"\\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
mu_isprint	O
(	O
toknum	short
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(char)
,	O
"'%c'"	*(char)
,	O
toknum	short
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(char)
,	O
"tok(%d)"	*(char)
,	O
toknum	short
)	O
;	O
break	O
;	O
}	O
}	O
static	O
mu_list_t	*(struct)
arg_list	*(struct)
;	O
enum	O
node_type	enum(int,int,int,int,int)
{	O
true_node	int
,	O
functional_node	int
,	O
binary_node	int
,	O
negation_node	int
,	O
suffix_node	int
}	O
;	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
{	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
string	*(char)
;	O
unsigned	O
number	long
;	O
int	O
c	char
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
builtin_t	*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int))
)	O
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
{	O
enum	O
node_type	enum(int,int,int,int,int)
type	int
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
union	O
{	O
struct	O
{	O
builtin_t	*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int))
fun	*((*(char),*(void))->(int))
;	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
;	O
}	O
function	struct(*((*(union(*`,int,int,struct`)))->(int)),*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
arg	*(char)
;	O
struct	O
{	O
int	O
op	int
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
arg1	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
arg2	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
;	O
}	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
;	O
struct	O
mimetypes_string	struct(*(char),long)
suffix	*(char)
;	O
}	O
v	array(*(char))
;	O
}	O
;	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
enum	O
node_type	enum(int,int,int,int,int)
type	int
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_binary_node	(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
int	O
op	int
,	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
left	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
,	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
rigth	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_negation_node	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
p	*(char)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_suffix_node	(*(struct(*(char),long)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
suffix	*(char)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_functional_node	(*(char),*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
char	O
*	O
ident	*(char)
,	O
mu_list_t	*(struct)
list	*(struct)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
static	O
int	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
root	*(*(struct))
)	O
;	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
{	O
char	O
*	O
type	int
;	O
int	O
priority	int
;	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
;	O
static	O
mu_list_t	*(struct)
rule_list	*(struct)
;	O
static	O
size_t	long
errors	long
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
mimetypes_yyalloc	union(short,union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long))))),struct(struct(*(char),int,int),struct(*(char),int,int)))
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
yyvs_alloc	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
;	O
YYLTYPE	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
11	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
12	int
,	O
13	int
,	O
2	int
,	O
10	int
,	O
9	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyprhs	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
11	int
,	O
12	int
,	O
16	int
,	O
18	int
,	O
20	int
,	O
21	int
,	O
23	int
,	O
25	int
,	O
28	int
,	O
32	int
,	O
36	int
,	O
39	int
,	O
43	int
,	O
45	int
,	O
47	int
,	O
49	int
,	O
54	int
,	O
55	int
,	O
57	int
,	O
62	int
,	O
64	int
,	O
68	int
,	O
70	int
}	O
;	O
static	O
const	O
yytype_int8	char
yyrhs	array(char)
[	O
]	O
=	O
{	O
15	int
,	O
0	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
16	int
,	O
6	int
,	O
17	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
3	int
,	O
18	int
,	O
22	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
19	int
,	O
-	O
1	int
,	O
20	int
,	O
-	O
1	int
,	O
19	int
,	O
19	int
,	O
-	O
1	int
,	O
19	int
,	O
9	int
,	O
19	int
,	O
-	O
1	int
,	O
19	int
,	O
10	int
,	O
19	int
,	O
-	O
1	int
,	O
11	int
,	O
20	int
,	O
-	O
1	int
,	O
12	int
,	O
19	int
,	O
13	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
8	int
,	O
12	int
,	O
24	int
,	O
13	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
21	int
,	O
-	O
1	int
,	O
4	int
,	O
12	int
,	O
24	int
,	O
13	int
,	O
-	O
1	int
,	O
25	int
,	O
-	O
1	int
,	O
24	int
,	O
9	int
,	O
25	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_uint16	short
yyrline	array(short)
[	O
]	O
=	O
{	O
0	int
,	O
152	int
,	O
152	int
,	O
155	int
,	O
156	int
,	O
159	int
,	O
160	int
,	O
176	int
,	O
180	int
,	O
192	int
,	O
195	int
,	O
198	int
,	O
199	int
,	O
206	int
,	O
213	int
,	O
222	int
,	O
226	int
,	O
230	int
,	O
234	int
,	O
235	int
,	O
241	int
,	O
259	int
,	O
262	int
,	O
265	int
,	O
277	int
,	O
283	int
,	O
290	int
,	O
291	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
yytname	array(*(char))
[	O
]	O
=	O
{	O
"$end"	*(char)
,	O
"error"	*(char)
,	O
"$undefined"	*(char)
,	O
"TYPE"	*(char)
,	O
"IDENT"	*(char)
,	O
"STRING"	*(char)
,	O
"EOL"	*(char)
,	O
"BOGUS"	*(char)
,	O
"PRIORITY"	*(char)
,	O
"','"	*(char)
,	O
"'+'"	*(char)
,	O
"'!'"	*(char)
,	O
"'('"	*(char)
,	O
"')'"	*(char)
,	O
"$accept"	*(char)
,	O
"input"	*(char)
,	O
"list"	*(char)
,	O
"rule_line"	*(char)
,	O
"maybe_rule"	*(char)
,	O
"rule"	*(char)
,	O
"stmt"	*(char)
,	O
"priority"	*(char)
,	O
"maybe_priority"	*(char)
,	O
"function"	*(char)
,	O
"arglist"	*(char)
,	O
"arg"	*(char)
,	O
YY_NULL	int
}	O
;	O
static	O
const	O
yytype_uint16	short
yytoknum	array(short)
[	O
]	O
=	O
{	O
0	int
,	O
256	int
,	O
257	int
,	O
258	int
,	O
259	int
,	O
260	int
,	O
261	int
,	O
262	int
,	O
263	int
,	O
44	int
,	O
43	int
,	O
33	int
,	O
40	int
,	O
41	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mimetypes_yyr1	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
19	int
,	O
19	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
20	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
24	int
,	O
25	int
,	O
25	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mimetypes_yyr2	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
4	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
8	int
,	O
9	int
,	O
7	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
0	int
,	O
17	int
,	O
19	int
,	O
0	int
,	O
0	int
,	O
21	int
,	O
10	int
,	O
11	int
,	O
18	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
15	int
,	O
0	int
,	O
0	int
,	O
22	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
4	int
,	O
26	int
,	O
27	int
,	O
0	int
,	O
24	int
,	O
16	int
,	O
0	int
,	O
13	int
,	O
14	int
,	O
0	int
,	O
23	int
,	O
0	int
,	O
25	int
,	O
20	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array(char)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
12	int
,	O
26	int
,	O
14	int
,	O
22	int
,	O
23	int
,	O
15	int
,	O
30	int
,	O
31	int
}	O
;	O
static	O
const	O
yytype_int8	char
mimetypes_yypact	array(char)
[	O
]	O
=	O
{	O
51	int
,	O
-	O
8	int
,	O
38	int
,	O
-	O
8	int
,	O
16	int
,	O
-	O
5	int
,	O
-	O
8	int
,	O
5	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
38	int
,	O
38	int
,	O
10	int
,	O
20	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
51	int
,	O
-	O
3	int
,	O
-	O
8	int
,	O
1	int
,	O
8	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
38	int
,	O
38	int
,	O
29	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
6	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
3	int
,	O
29	int
,	O
38	int
,	O
-	O
3	int
,	O
-	O
8	int
,	O
6	int
,	O
-	O
8	int
,	O
-	O
8	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array(char)
[	O
]	O
=	O
{	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
4	int
,	O
-	O
8	int
,	O
-	O
2	int
,	O
18	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
8	int
,	O
-	O
7	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_int8	char
mimetypes_yytable	array(char)
[	O
]	O
=	O
{	O
13	int
,	O
17	int
,	O
28	int
,	O
36	int
,	O
29	int
,	O
7	int
,	O
8	int
,	O
37	int
,	O
9	int
,	O
20	int
,	O
24	int
,	O
25	int
,	O
10	int
,	O
11	int
,	O
32	int
,	O
36	int
,	O
16	int
,	O
18	int
,	O
21	int
,	O
40	int
,	O
33	int
,	O
27	int
,	O
34	int
,	O
35	int
,	O
7	int
,	O
8	int
,	O
38	int
,	O
9	int
,	O
19	int
,	O
24	int
,	O
25	int
,	O
10	int
,	O
11	int
,	O
7	int
,	O
8	int
,	O
39	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
25	int
,	O
10	int
,	O
11	int
,	O
7	int
,	O
8	int
,	O
0	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
-	O
5	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
0	int
,	O
-	O
5	int
,	O
3	int
}	O
;	O
static	O
const	O
yytype_int8	char
mimetypes_yycheck	array(char)
[	O
]	O
=	O
{	O
2	int
,	O
6	int
,	O
5	int
,	O
9	int
,	O
7	int
,	O
4	int
,	O
5	int
,	O
13	int
,	O
7	int
,	O
11	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
9	int
,	O
0	int
,	O
12	int
,	O
8	int
,	O
13	int
,	O
12	int
,	O
17	int
,	O
24	int
,	O
25	int
,	O
4	int
,	O
5	int
,	O
33	int
,	O
7	int
,	O
10	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
4	int
,	O
5	int
,	O
36	int
,	O
7	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
4	int
,	O
5	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
1	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
1	int
,	O
3	int
,	O
7	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
4	int
,	O
5	int
,	O
7	int
,	O
11	int
,	O
12	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
23	int
,	O
0	int
,	O
6	int
,	O
12	int
,	O
20	int
,	O
19	int
,	O
8	int
,	O
21	int
,	O
22	int
,	O
9	int
,	O
10	int
,	O
19	int
,	O
17	int
,	O
5	int
,	O
7	int
,	O
24	int
,	O
25	int
,	O
13	int
,	O
12	int
,	O
19	int
,	O
19	int
,	O
9	int
,	O
13	int
,	O
24	int
,	O
25	int
,	O
13	int
}	O
;	O
static	O
void	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
const	O
*	O
const	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
FILE	struct
*	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
YYUSE	O
(	O
yyo	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
)	O
return	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
yytype	int
<	O
YYNTOKENS	int
)	O
YYPRINT	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yytoknum	array(short)
[	O
yytype	int
]	O
,	O
*	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
FILE	struct
*	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
const	O
*	O
const	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
if	O
(	O
yytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"token %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"nterm %s ("	*(char)
,	O
yytname	array(*(char))
[	O
yytype	int
]	O
)	O
;	O
YY_LOCATION_PRINT	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": "	*(char)
)	O
;	O
yy_symbol_value_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yytype	int
,	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
")"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_stack_print	(*(short),*(short))->(void)
(	O
yytype_int16	short
*	O
yybottom	*(short)
,	O
yytype_int16	short
*	O
yytop	*(short)
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack now"	*(char)
)	O
;	O
for	O
(	O
;	O
yybottom	*(short)
<=	O
yytop	*(short)
;	O
yybottom	*(short)
++	O
)	O
{	O
int	O
yybot	int
=	O
*	O
yybottom	*(short)
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %d"	*(char)
,	O
yybot	int
)	O
;	O
}	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
yy_reduce_print	(*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))),int)->(void)
(	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
*	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
int	O
mimetypes_yyrule	int
)	O
{	O
int	O
yynrhs	int
=	O
mimetypes_yyr2	array(char)
[	O
mimetypes_yyrule	int
]	O
;	O
int	O
yyi	int
;	O
unsigned	O
long	O
int	O
yylno	long
=	O
yyrline	array(short)
[	O
mimetypes_yyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reducing stack by rule %d (line %lu):\n"	*(char)
,	O
mimetypes_yyrule	int
-	O
1	int
,	O
yylno	long
)	O
;	O
for	O
(	O
yyi	int
=	O
0	int
;	O
yyi	int
<	O
yynrhs	int
;	O
yyi	int
++	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   $%d = "	*(char)
,	O
yyi	int
+	O
1	int
)	O
;	O
yy_symbol_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
yyrhs	array(char)
[	O
yyprhs	array(char)
[	O
mimetypes_yyrule	int
]	O
+	O
yyi	int
]	O
,	O
&	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
int	O
mimetypes_yydebug	int
;	O
static	O
void	O
yydestruct	(*(char),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
const	O
char	O
*	O
yymsg	*(char)
,	O
int	O
yytype	int
,	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
*	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
YYLTYPE	O
*	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
YYUSE	O
(	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
)	O
;	O
YYUSE	O
(	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
yymsg	*(char)
)	O
yymsg	*(char)
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	*(char)
,	O
yytype	int
,	O
yyvaluep	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
yylocationp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
mimetypes_yychar	int
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
YYLTYPE	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
mimetypes_yynerrs	int
;	O
int	O
mimetypes_yyparse	()->(int)
(	O
void	O
)	O
{	O
int	O
mimetypes_yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array(short)
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	*(short)
;	O
yytype_int16	short
*	O
yyssp	*(short)
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
yyvsa	array(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long))))))
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
*	O
yyvs	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
*	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
;	O
YYLTYPE	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
YYINITDEPTH	int
]	O
;	O
YYLTYPE	O
*	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
YYLTYPE	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
3	int
]	O
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	union(struct(*(char),long),*(char),*(struct),int,*(struct))
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
;	O
YYLTYPE	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
int	O
mimetypes_yylen	int
=	O
0	int
;	O
yyssp	*(short)
=	O
yyss	*(short)
=	O
yyssa	array(short)
;	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
yyvs	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
yyvsa	array(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long))))))
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yylsa	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
mimetypes_yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
mimetypes_yynerrs	int
=	O
0	int
;	O
mimetypes_yychar	int
=	O
YYEMPTY	O
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
0	int
]	O
=	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	*(short)
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	*(short)
=	O
mimetypes_yystate	int
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	*(short)
-	O
yyss	*(short)
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	*(short)
=	O
yyss	*(short)
;	O
union	O
mimetypes_yyalloc	union(short,union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long))))),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
yyptr	*(union(short,union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`))),struct(struct(*(char),int,int),struct(*(char),int,int))))
=	O
(	O
union	O
mimetypes_yyalloc	union(short,union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long))))),struct(struct(*(char),int,int),struct(*(char),int,int)))
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	*(union(short,union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`))),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	*(short)
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
,	O
yyvs	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyls_alloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
yyss1	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss1	*(short)
)	O
;	O
}	O
yyssp	*(short)
=	O
yyss	*(short)
+	O
yysize	long
-	O
1	int
;	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
yyvs	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
+	O
yysize	long
-	O
1	int
;	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyls	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
mimetypes_yystate	int
)	O
)	O
;	O
if	O
(	O
mimetypes_yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
mimetypes_yypact	array(char)
[	O
mimetypes_yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
mimetypes_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
mimetypes_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
mimetypes_yychar	int
<=	O
YYEOF	int
)	O
{	O
mimetypes_yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mimetypes_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
yytoken	int
,	O
&	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
,	O
&	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
mimetypes_yycheck	array(char)
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
mimetypes_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yytoken	int
,	O
&	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
,	O
&	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mimetypes_yychar	int
=	O
YYEMPTY	O
;	O
mimetypes_yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array(char)
[	O
mimetypes_yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
mimetypes_yylen	int
=	O
mimetypes_yyr2	array(char)
[	O
yyn	int
]	O
;	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
=	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
1	int
-	O
mimetypes_yylen	int
]	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
-	O
mimetypes_yylen	int
)	O
,	O
mimetypes_yylen	int
)	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
6	int
:	O
{	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
*	O
p	*(char)
=	O
mimetypes_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
rule_list	*(struct)
)	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
rule_list	*(struct)
)	O
;	O
p	*(char)
->	O
type	int
=	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(char)
)	O
.	O
ptr	*(*(void))
;	O
p	*(char)
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
p	*(char)
->	O
priority	int
=	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
result	*(struct)
)	O
;	O
mu_locus_point_copy	(*(struct(*(char),int,int)),*(struct(*(char),int,int)))->(int)
(	O
&	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
)	O
;	O
mu_locus_point_copy	(*(struct(*(char),int,int)),*(struct(*(char),int,int)))->(int)
(	O
&	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
)	O
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
rule_list	*(struct)
,	O
p	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
errors	long
++	O
;	O
if	O
(	O
arg_list	*(struct)
)	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
arg_list	*(struct)
)	O
;	O
lex_next_rule	()->(void)
(	O
)	O
;	O
yyerrok	O
;	O
yyclearin	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
true_node	int
,	O
&	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_binary_node	(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
L_OR	int
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_binary_node	(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
L_OR	int
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_binary_node	(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
L_AND	int
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_negation_node	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_suffix_node	(*(struct(*(char),long)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
&	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(char)
)	O
,	O
&	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
size_t	long
count	long
=	O
0	int
;	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
arg	*(char)
;	O
mu_list_count	(*(struct),*(long))->(int)
(	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
&	O
count	long
)	O
;	O
if	O
(	O
count	long
!=	O
1	int
)	O
{	O
mimetypes_yyerror	(*(char))->(int)
(	O
_	O
(	O
"priority takes single numberic argument"	*(char)
)	O
)	O
;	O
YYERROR	O
;	O
}	O
mu_list_head	(*(struct),*(*(void)))->(int)
(	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
arg	*(char)
)	O
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
result	*(struct)
)	O
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
->	O
ptr	*(*(void))
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
result	*(struct)
)	O
=	O
100	int
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
beg	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
.	O
beg	struct(*(char),int,int)
;	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
.	O
end	struct(*(char),int,int)
=	O
(	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
)	O
.	O
end	struct(*(char),int,int)
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
=	O
make_functional_node	(*(char),*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
string	*(char)
)	O
.	O
ptr	*(*(void))
,	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
&	O
lr	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
if	O
(	O
!	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
arg_list	*(struct)
)	O
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
list	*(struct)
)	O
=	O
arg_list	*(struct)
;	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
list	*(struct)
)	O
,	O
mimetypes_string_dup	(*(struct(*(char),long)))->(*(struct(*(char),long)))
(	O
&	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
mu_list_append	(*(struct),*(void))->(int)
(	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
,	O
mimetypes_string_dup	(*(struct(*(char),long)))->(*(struct(*(char),long)))
(	O
&	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	*(char)
)	O
)	O
)	O
;	O
(	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
.	O
list	*(struct)
)	O
=	O
(	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
YYERROR	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
mimetypes_yyr1	array(char)
[	O
yyn	int
]	O
,	O
&	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
,	O
&	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
YYPOPSTACK	O
(	O
mimetypes_yylen	int
)	O
;	O
mimetypes_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
*	O
++	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
mimetypes_yyval	union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
yyn	int
=	O
mimetypes_yyr1	array(char)
[	O
yyn	int
]	O
;	O
mimetypes_yystate	int
=	O
yypgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	*(short)
;	O
if	O
(	O
0	int
<=	O
mimetypes_yystate	int
&&	O
mimetypes_yystate	int
<=	O
YYLAST	int
&&	O
mimetypes_yycheck	array(char)
[	O
mimetypes_yystate	int
]	O
==	O
*	O
yyssp	*(short)
)	O
mimetypes_yystate	int
=	O
mimetypes_yytable	array(char)
[	O
mimetypes_yystate	int
]	O
;	O
else	O
mimetypes_yystate	int
=	O
yydefgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
mimetypes_yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
mimetypes_yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
mimetypes_yynerrs	int
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
}	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
mimetypes_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
mimetypes_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	(*(char),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: discarding"	*(char)
,	O
yytoken	int
,	O
&	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
,	O
&	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
mimetypes_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
-	O
mimetypes_yylen	int
]	O
;	O
YYPOPSTACK	O
(	O
mimetypes_yylen	int
)	O
;	O
mimetypes_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
mimetypes_yystate	int
=	O
*	O
yyssp	*(short)
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
mimetypes_yypact	array(char)
[	O
mimetypes_yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
mimetypes_yycheck	array(char)
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
mimetypes_yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	*(short)
==	O
yyss	*(short)
)	O
YYABORT	O
;	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
1	int
]	O
=	O
*	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
yydestruct	(*(char),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Error: popping"	*(char)
,	O
yystos	array(char)
[	O
mimetypes_yystate	int
]	O
,	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
mimetypes_yystate	int
=	O
*	O
yyssp	*(short)
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
[	O
2	int
]	O
=	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
yyerror_range	array(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
2	int
)	O
;	O
*	O
++	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
yyloc	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yystos	array(char)
[	O
yyn	int
]	O
,	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
mimetypes_yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
mimetypes_yyerror	(*(char))->(int)
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
mimetypes_yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mimetypes_yychar	int
)	O
;	O
yydestruct	(*(char),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
yytoken	int
,	O
&	O
mimetypes_yylval	union(struct(*(char),long),*(char),*(struct),int,*(struct))
,	O
&	O
mimetypes_yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
}	O
YYPOPSTACK	O
(	O
mimetypes_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
while	O
(	O
yyssp	*(short)
!=	O
yyss	*(short)
)	O
{	O
yydestruct	(*(char),int,*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct`,union`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
"Cleanup: popping"	*(char)
,	O
yystos	array(char)
[	O
*	O
yyssp	*(short)
]	O
,	O
yyvsp	*(union(struct(*(char),long),*(char),*(struct),int,*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
,	O
yylsp	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss	*(short)
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
int	O
mimetypes_parse	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mimetypes_open	(*(char))->(int)
(	O
name	*(char)
)	O
)	O
return	O
1	int
;	O
mimetypes_yydebug	int
=	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_APP	int
,	O
MU_DEBUG_TRACE3	int
)	O
;	O
rc	int
=	O
mimetypes_yyparse	()->(int)
(	O
)	O
;	O
mimetypes_close	()->(void)
(	O
)	O
;	O
return	O
rc	int
||	O
errors	long
;	O
}	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
enum	O
node_type	enum(int,int,int,int,int)
type	int
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
p	*(char)
=	O
mimetypes_malloc	(long)->(*(void))
(	O
sizeof	O
*	O
p	*(char)
)	O
;	O
p	*(char)
->	O
type	int
=	O
type	int
;	O
mu_locus_range_init	(*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(void)
(	O
&	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
mu_locus_range_copy	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
&	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
return	O
p	*(char)
;	O
}	O
static	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_binary_node	(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
int	O
op	int
,	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
left	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
,	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
right	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
binary_node	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
op	int
=	O
op	int
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
arg1	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
=	O
left	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
arg2	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
=	O
right	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long))))
;	O
return	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_negation_node	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
p	*(char)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
negation_node	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
arg	*(char)
=	O
p	*(char)
;	O
return	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_suffix_node	(*(struct(*(char),long)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
suffix	*(char)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
suffix_node	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
suffix	*(char)
=	O
*	O
suffix	*(char)
;	O
return	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
struct	O
builtin_tab	struct(*(char),*(char),*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int)))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
args	*(long)
;	O
builtin_t	*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int))
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
;	O
}	O
;	O
static	O
int	O
b_match	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
return	O
fnmatch	(*(char),*(char),int)->(int)
(	O
args	*(long)
[	O
0	int
]	O
.	O
string	*(char)
->	O
ptr	*(*(void))
,	O
mimeview_file	*(char)
,	O
0	int
)	O
==	O
0	int
;	O
}	O
static	O
int	O
b_ascii	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
int	O
i	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
;	O
i	long
++	O
)	O
{	O
unsigned	O
char	O
c	char
;	O
size_t	long
n	*(long)
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
&	O
c	char
,	O
1	int
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
||	O
n	*(long)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
ISASCII	O
(	O
c	char
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
b_printable	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
int	O
i	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
;	O
i	long
++	O
)	O
{	O
unsigned	O
char	O
c	char
;	O
size_t	long
n	*(long)
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
&	O
c	char
,	O
1	int
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
||	O
n	*(long)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
ISPRINT	O
(	O
c	char
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
b_string	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
str	*(char)
=	O
args	*(long)
[	O
1	int
]	O
.	O
string	*(char)
;	O
int	O
i	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
str	*(char)
->	O
len	long
;	O
i	long
++	O
)	O
{	O
char	O
c	char
;	O
size_t	long
n	*(long)
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
&	O
c	char
,	O
1	int
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
||	O
n	*(long)
==	O
0	int
||	O
c	char
!=	O
str	*(char)
->	O
ptr	*(*(void))
[	O
i	long
]	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
b_istring	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
int	O
i	long
;	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
str	*(char)
=	O
args	*(long)
[	O
1	int
]	O
.	O
string	*(char)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
str	*(char)
->	O
len	long
;	O
i	long
++	O
)	O
{	O
char	O
c	char
;	O
size_t	long
n	*(long)
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
&	O
c	char
,	O
1	int
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
||	O
n	*(long)
==	O
0	int
||	O
mu_tolower	O
(	O
c	char
)	O
!=	O
mu_tolower	O
(	O
str	*(char)
->	O
ptr	*(*(void))
[	O
i	long
]	O
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
compare_bytes	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))),*(void),*(void),long)->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
,	O
void	O
*	O
sample	*(void)
,	O
void	O
*	O
buf	*(char)
,	O
size_t	long
size	long
)	O
{	O
int	O
rc	int
;	O
size_t	long
n	*(long)
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
buf	*(char)
,	O
size	long
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_read"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
n	*(long)
!=	O
size	long
)	O
return	O
0	int
;	O
return	O
memcmp	(*(void),*(void),long)->(int)
(	O
sample	*(void)
,	O
buf	*(char)
,	O
size	long
)	O
==	O
0	int
;	O
}	O
static	O
int	O
b_char	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
char	O
val	*(char)
=	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
;	O
char	O
buf	*(char)
;	O
return	O
compare_bytes	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))),*(void),*(void),long)->(int)
(	O
args	*(long)
,	O
&	O
val	*(char)
,	O
&	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
b_short	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
uint16_t	short
val	*(char)
=	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
;	O
uint16_t	short
buf	*(char)
;	O
return	O
compare_bytes	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))),*(void),*(void),long)->(int)
(	O
args	*(long)
,	O
&	O
val	*(char)
,	O
&	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
b_int	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
uint32_t	int
val	*(char)
=	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
;	O
uint32_t	int
buf	*(char)
;	O
return	O
compare_bytes	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))),*(void),*(void),long)->(int)
(	O
args	*(long)
,	O
&	O
val	*(char)
,	O
&	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
b_locale	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
abort	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
b_contains	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
size_t	long
i	long
,	O
count	long
;	O
char	O
*	O
buf	*(char)
;	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
str	*(char)
=	O
args	*(long)
[	O
2	int
]	O
.	O
string	*(char)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
buf	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
)	O
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
buf	*(char)
,	O
args	*(long)
[	O
1	int
]	O
.	O
number	long
,	O
&	O
count	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_read"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
}	O
else	O
if	O
(	O
count	long
>	O
str	*(char)
->	O
len	long
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
count	long
-	O
str	*(char)
->	O
len	long
;	O
i	long
++	O
)	O
if	O
(	O
buf	*(char)
[	O
i	long
]	O
==	O
str	*(char)
->	O
ptr	*(*(void))
[	O
0	int
]	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
buf	*(char)
+	O
i	long
,	O
str	*(char)
->	O
ptr	*(*(void))
,	O
str	*(char)
->	O
len	long
)	O
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
b_regex	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
(	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
)	O
{	O
size_t	long
count	long
;	O
int	O
rc	int
;	O
char	O
buf	*(char)
[	O
MIME_MAX_BUFFER	int
]	O
;	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
args	*(long)
[	O
0	int
]	O
.	O
number	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mimeview_stream	*(struct)
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
-	O
1	int
,	O
&	O
count	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_read"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
buf	*(char)
[	O
count	long
]	O
=	O
0	int
;	O
return	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
args	*(long)
[	O
1	int
]	O
.	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
buf	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
;	O
}	O
static	O
struct	O
builtin_tab	struct(*(char),*(char),*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int)))
builtin_tab	struct(*(char),*(char),*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int)))
[	O
]	O
=	O
{	O
{	O
"match"	*(char)
,	O
"s"	*(char)
,	O
b_match	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"ascii"	*(char)
,	O
"dd"	*(char)
,	O
b_ascii	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"printable"	*(char)
,	O
"dd"	*(char)
,	O
b_printable	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"regex"	*(char)
,	O
"dx"	*(char)
,	O
b_regex	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"string"	*(char)
,	O
"ds"	*(char)
,	O
b_string	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"istring"	*(char)
,	O
"ds"	*(char)
,	O
b_istring	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"char"	*(char)
,	O
"dc"	*(char)
,	O
b_char	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"short"	*(char)
,	O
"dd"	*(char)
,	O
b_short	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"int"	*(char)
,	O
"dd"	*(char)
,	O
b_int	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"locale"	*(char)
,	O
"s"	*(char)
,	O
b_locale	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
"contains"	*(char)
,	O
"dds"	*(char)
,	O
b_contains	(*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
make_functional_node	(*(char),*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
char	O
*	O
ident	*(char)
,	O
mu_list_t	*(struct)
list	*(struct)
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
size_t	long
count	long
,	O
i	long
;	O
struct	O
builtin_tab	struct(*(char),*(char),*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int)))
*	O
p	*(char)
;	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
union	O
argument	union(*(struct(*(char),long)),int,int,struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
args	*(long)
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
int	O
rc	int
;	O
for	O
(	O
p	*(char)
=	O
builtin_tab	struct(*(char),*(char),*((*(union(*(struct`),int,int,struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int))))->(int)))
;	O
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
!	O
p	*(char)
->	O
name	*(char)
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
_	O
(	O
"%s: unknown function"	*(char)
)	O
,	O
ident	*(char)
)	O
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ident	*(char)
,	O
p	*(char)
->	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
}	O
mu_list_count	(*(struct),*(long))->(int)
(	O
list	*(struct)
,	O
&	O
count	long
)	O
;	O
i	long
=	O
strlen	(*(char))->(long)
(	O
p	*(char)
->	O
args	*(long)
)	O
;	O
if	O
(	O
count	long
<	O
i	long
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
_	O
(	O
"too few arguments in call to `%s'"	*(char)
)	O
,	O
ident	*(char)
)	O
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
count	long
>	O
i	long
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
_	O
(	O
"too many arguments in call to `%s'"	*(char)
)	O
,	O
ident	*(char)
)	O
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
args	*(long)
=	O
mimetypes_malloc	(long)->(*(void))
(	O
count	long
*	O
sizeof	O
*	O
args	*(long)
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
list	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
,	O
i	long
++	O
)	O
{	O
struct	O
mimetypes_string	struct(*(char),long)
*	O
data	*(void)
;	O
char	O
*	O
tmp	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
data	*(void)
)	O
;	O
switch	O
(	O
p	*(char)
->	O
args	*(long)
[	O
i	long
]	O
)	O
{	O
case	O
'd'	O
:	O
args	*(long)
[	O
i	long
]	O
.	O
number	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
data	*(void)
->	O
ptr	*(*(void))
,	O
&	O
tmp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
tmp	*(char)
)	O
goto	O
err	int
;	O
break	O
;	O
case	O
's'	O
:	O
args	*(long)
[	O
i	long
]	O
.	O
string	*(char)
=	O
data	*(void)
;	O
break	O
;	O
case	O
'x'	O
:	O
{	O
char	O
*	O
s	*(char)
;	O
rc	int
=	O
mu_c_str_unescape_trans	(*(char),*(char),*(*(char)))->(int)
(	O
data	*(void)
->	O
ptr	*(*(void))
,	O
"\\\\\"\"a\ab\bf\fn\nr\rt\tv\v"	*(char)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_c_str_unescape_trans"	*(char)
,	O
data	*(void)
->	O
ptr	*(*(void))
,	O
rc	int
)	O
;	O
return	O
NULL	O
;	O
}	O
rc	int
=	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
args	*(long)
[	O
i	long
]	O
.	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
s	*(char)
,	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
errbuf	array(char)
[	O
512	int
]	O
;	O
regerror	(int,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long)->(long)
(	O
rc	int
,	O
&	O
args	*(long)
[	O
i	long
]	O
.	O
rx	*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
,	O
errbuf	array(char)
,	O
sizeof	O
errbuf	array(char)
)	O
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
errbuf	array(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
break	O
;	O
case	O
'c'	O
:	O
args	*(long)
[	O
i	long
]	O
.	O
c	char
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
data	*(void)
->	O
ptr	*(*(void))
,	O
&	O
tmp	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
tmp	*(char)
)	O
goto	O
err	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
make_node	(enum(int,int,int,int,int),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))
(	O
functional_node	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
function	struct(*((*(union(*`,int,int,struct`)))->(int)),*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))
.	O
fun	*((*(char),*(void))->(int))
=	O
p	*(char)
->	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
;	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
v	array(*(char))
.	O
function	struct(*((*(union(*`,int,int,struct`)))->(int)),*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))
.	O
args	*(long)
=	O
args	*(long)
;	O
return	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
err	int
:	O
{	O
char	O
*	O
s	*(char)
;	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
_	O
(	O
"argument %lu has wrong type in call to `%s'"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
i	long
,	O
ident	*(char)
)	O
;	O
mimetypes_yyerror	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
static	O
int	O
check_suffix	(*(char))->(int)
(	O
char	O
*	O
suf	*(char)
)	O
{	O
char	O
*	O
p	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
mimeview_file	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
0	int
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
+	O
1	int
,	O
suf	*(char)
)	O
==	O
0	int
;	O
}	O
void	O
mime_debug	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
int	O
lev	int
,	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
const	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_APP	int
,	O
lev	int
)	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
==	O
0	int
)	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%s:%u"	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_file	*(char)
)	O
)	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%s:%u.%u-%s:%u.%u"	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_col	int
)	O
;	O
else	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
!=	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_line	int
)	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%s:%u.%u-%u.%u"	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_col	int
)	O
;	O
else	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
!=	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_col	int
)	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%s:%u.%u-%u"	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
end	struct(*(char),int,int)
.	O
mu_col	int
)	O
;	O
else	O
mu_debug_log_begin	(*(char))->(void)
(	O
"%s:%u.%u"	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_file	*(char)
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_line	int
,	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
->	O
beg	struct(*(char),int,int)
.	O
mu_col	int
)	O
;	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
mu_strerr	*(struct)
,	O
": "	*(char)
,	O
2	int
,	O
NULL	O
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
mu_stream_vprintf	(*(struct),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
mu_strerr	*(struct)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
mu_debug_log_nl	()->(void)
(	O
)	O
;	O
}	O
}	O
static	O
int	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
struct	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
*	O
root	*(*(struct))
)	O
{	O
int	O
result	*(struct)
;	O
switch	O
(	O
root	*(*(struct))
->	O
type	int
)	O
{	O
case	O
true_node	int
:	O
result	*(struct)
=	O
1	int
;	O
break	O
;	O
case	O
functional_node	int
:	O
result	*(struct)
=	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
function	struct(*((*(union(*`,int,int,struct`)))->(int)),*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))
.	O
fun	*((*(char),*(void))->(int))
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
function	struct(*((*(union(*`,int,int,struct`)))->(int)),*(union(*(struct(*`,long)),int,int,struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))))
.	O
args	*(long)
)	O
;	O
break	O
;	O
case	O
binary_node	int
:	O
result	*(struct)
=	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
arg1	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
;	O
switch	O
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
op	int
)	O
{	O
case	O
L_OR	int
:	O
if	O
(	O
!	O
result	*(struct)
)	O
result	*(struct)
|=	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
arg2	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
;	O
break	O
;	O
case	O
L_AND	int
:	O
if	O
(	O
result	*(struct)
)	O
result	*(struct)
&=	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
bin	struct(int,*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))),*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)))))
.	O
arg2	*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int))))
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
negation_node	int
:	O
result	*(struct)
=	O
!	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
suffix_node	int
:	O
result	*(struct)
=	O
check_suffix	(*(char))->(int)
(	O
root	*(*(struct))
->	O
v	array(*(char))
.	O
suffix	*(char)
.	O
ptr	*(*(void))
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
mime_debug	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_DEBUG_TRACE2	int
,	O
&	O
root	*(*(struct))
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
"result %s"	*(char)
,	O
result	*(struct)
?	O
"true"	*(char)
:	O
"false"	*(char)
)	O
;	O
return	O
result	*(struct)
;	O
}	O
static	O
int	O
evaluate	(*(*(void)),long,*(void))->(int)
(	O
void	O
*	O
*	O
itmv	*(*(void))
,	O
size_t	long
itmc	long
,	O
void	O
*	O
call_data	*(void)
)	O
{	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
*	O
p	*(char)
=	O
itmv	*(*(void))
[	O
0	int
]	O
;	O
if	O
(	O
eval_rule	(*(struct(enum(int,int,int,int,int),struct(struct(*`,int,int),struct(*`,int,int)),union(struct(*`,*`),*(struct`),struct(int,*`,*`),struct(*`,long)))))->(int)
(	O
p	*(char)
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
)	O
{	O
itmv	*(*(void))
[	O
0	int
]	O
=	O
p	*(char)
;	O
mime_debug	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_DEBUG_TRACE1	int
,	O
&	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
"rule %s matches"	*(char)
,	O
p	*(char)
->	O
type	int
)	O
;	O
return	O
MU_LIST_MAP_OK	int
;	O
}	O
return	O
MU_LIST_MAP_SKIP	int
;	O
}	O
static	O
int	O
rule_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
const	O
void	O
*	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
)	O
{	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
const	O
*	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
;	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
const	O
*	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
=	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
;	O
if	O
(	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
priority	int
==	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
priority	int
)	O
{	O
if	O
(	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	int
==	O
true_node	int
&&	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	int
!=	O
true_node	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	int
==	O
true_node	int
&&	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
type	int
!=	O
true_node	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
type	int
,	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
type	int
)	O
;	O
}	O
return	O
arule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
priority	int
-	O
brule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
priority	int
;	O
}	O
const	O
char	O
*	O
get_file_type	()->(*(char))
(	O
)	O
{	O
mu_list_t	*(struct)
res	*(int)
=	O
NULL	O
;	O
const	O
char	O
*	O
type	int
=	O
NULL	O
;	O
mu_list_map	(*(struct),*((*(*(void)),long,*(void))->(int)),*(void),long,*(*(struct)))->(int)
(	O
rule_list	*(struct)
,	O
evaluate	(*(*(void)),long,*(void))->(int)
,	O
NULL	O
,	O
1	int
,	O
&	O
res	*(int)
)	O
;	O
if	O
(	O
!	O
mu_list_is_empty	(*(struct))->(int)
(	O
res	*(int)
)	O
)	O
{	O
struct	O
rule_tab	struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),union(struct(*((*`)->(int)),*(union`)),*(struct(enum(int,int,int,int,int),struct`,union`)),struct(int,*(struct`),*(struct`)),struct(*(char),long)))))
*	O
rule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
;	O
mu_list_sort	(*(struct),*((*(void),*(void))->(int)))->(void)
(	O
res	*(int)
,	O
rule_cmp	(*(void),*(void))->(int)
)	O
;	O
mu_list_head	(*(struct),*(*(void)))->(int)
(	O
res	*(int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
rule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
)	O
;	O
mime_debug	(int,*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
MU_DEBUG_TRACE0	int
,	O
&	O
rule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
"selected rule %s"	*(char)
,	O
rule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
type	int
)	O
;	O
type	int
=	O
rule	*(struct(*(char),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int,int,int),struct(struct`,struct`),union(struct`,*`,struct`,struct`)))))
->	O
type	int
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(int)
)	O
;	O
return	O
type	int
;	O
}	O
