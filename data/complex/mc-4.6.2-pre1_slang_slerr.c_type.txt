void	O
(	O
*	O
_pSLinterpreter_Error_Hook	*((int)->(void))
)	O
(	O
int	O
)	O
;	O
void	O
(	O
*	O
SLang_VMessage_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
(	O
char	O
*	O
,	O
va_list	array(struct(int,int,*(void),*(void)))
)	O
;	O
void	O
(	O
*	O
SLang_Error_Hook	*((*(char))->(void))
)	O
(	O
char	O
*	O
)	O
;	O
void	O
(	O
*	O
SLang_Exit_Error_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
(	O
char	O
*	O
,	O
va_list	array(struct(int,int,*(void),*(void)))
)	O
;	O
void	O
(	O
*	O
SLang_Dump_Routine	*((*(char))->(void))
)	O
(	O
char	O
*	O
)	O
;	O
volatile	O
int	O
_pSLang_Error	int
=	O
0	int
;	O
volatile	O
int	O
SLKeyBoard_Quit	int
=	O
0	int
;	O
typedef	O
struct	O
_Exception_Type	struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))))
Exception_Type	struct
;	O
struct	O
_Exception_Type	struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))),*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))))))
{	O
int	O
error_code	int
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
description	*(char)
;	O
Exception_Type	struct
*	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
Exception_Type	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
Exception_Type	struct
*	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
;	O
static	O
Exception_Type	struct
*	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
static	O
Exception_Type	struct
Exception_Root_Buf	struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
=	O
{	O
-	O
1	int
,	O
"AnyError"	*(char)
,	O
"All Errors"	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
SL_Any_Error	int
=	O
-	O
1	int
;	O
int	O
SL_Unknown_Error	int
=	O
6	int
;	O
int	O
SL_Internal_Error	int
=	O
5	int
;	O
int	O
SL_OS_Error	int
=	O
1	int
;	O
int	O
SL_Malloc_Error	int
=	O
2	int
;	O
int	O
SL_Import_Error	int
=	O
7	int
;	O
int	O
SL_RunTime_Error	int
=	O
3	int
;	O
int	O
SL_InvalidParm_Error	int
=	O
4	int
;	O
int	O
SL_TypeMismatch_Error	int
=	O
8	int
;	O
int	O
SL_UserBreak_Error	int
=	O
9	int
;	O
int	O
SL_Stack_Error	int
=	O
10	int
;	O
int	O
SL_StackOverflow_Error	int
=	O
12	int
;	O
int	O
SL_StackUnderflow_Error	int
=	O
11	int
;	O
int	O
SL_ReadOnly_Error	int
=	O
13	int
;	O
int	O
SL_VariableUninitialized_Error	int
=	O
14	int
;	O
int	O
SL_NumArgs_Error	int
=	O
15	int
;	O
int	O
SL_Index_Error	int
=	O
16	int
;	O
int	O
SL_Usage_Error	int
=	O
17	int
;	O
int	O
SL_Application_Error	int
=	O
18	int
;	O
int	O
SL_NotImplemented_Error	int
=	O
19	int
;	O
int	O
SL_LimitExceeded_Error	int
=	O
20	int
;	O
int	O
SL_Forbidden_Error	int
=	O
21	int
;	O
int	O
SL_Math_Error	int
=	O
22	int
;	O
int	O
SL_DivideByZero_Error	int
=	O
23	int
;	O
int	O
SL_ArithOverflow_Error	int
=	O
24	int
;	O
int	O
SL_ArithUnderflow_Error	int
=	O
25	int
;	O
int	O
SL_Domain_Error	int
=	O
26	int
;	O
int	O
SL_IO_Error	int
=	O
27	int
;	O
int	O
SL_Write_Error	int
=	O
28	int
;	O
int	O
SL_Read_Error	int
=	O
29	int
;	O
int	O
SL_Open_Error	int
=	O
30	int
;	O
int	O
SL_Data_Error	int
=	O
31	int
;	O
int	O
SL_Unicode_Error	int
=	O
32	int
;	O
int	O
SL_InvalidUTF8_Error	int
=	O
33	int
;	O
int	O
SL_Namespace_Error	int
=	O
34	int
;	O
int	O
SL_Parse_Error	int
=	O
35	int
;	O
int	O
SL_Syntax_Error	int
=	O
36	int
;	O
int	O
SL_DuplicateDefinition_Error	int
=	O
37	int
;	O
int	O
SL_UndefinedName_Error	int
=	O
38	int
;	O
typedef	O
struct	O
{	O
int	O
*	O
errcode_ptr	*(int)
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
description	*(char)
;	O
int	O
*	O
base_class_ptr	*(int)
;	O
}	O
BuiltIn_Exception_Table_Type	struct(*(int),*(char),*(char),*(int))
;	O
static	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct(*(int),*(char),*(char),*(int))
BuiltIn_Exception_Table	array(struct(*(int),*(char),*(char),*(int)))
[	O
]	O
=	O
{	O
{	O
&	O
SL_OS_Error	int
,	O
"OSError"	*(char)
,	O
"OS Error"	*(char)
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Malloc_Error	int
,	O
"MallocError"	*(char)
,	O
"Not enough memory"	*(char)
,	O
&	O
SL_OS_Error	int
}	O
,	O
{	O
&	O
SL_RunTime_Error	int
,	O
"RunTimeError"	*(char)
,	O
"Run-Time Error"	*(char)
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_InvalidParm_Error	int
,	O
"InvalidParmError"	*(char)
,	O
"Invalid Parameter"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Internal_Error	int
,	O
"InternalError"	*(char)
,	O
"Internal Error"	*(char)
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Unknown_Error	int
,	O
"UnknownError"	*(char)
,	O
"Unknown Error"	*(char)
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Import_Error	int
,	O
"ImportError"	*(char)
,	O
"Import Error"	*(char)
,	O
&	O
SL_OS_Error	int
}	O
,	O
{	O
&	O
SL_TypeMismatch_Error	int
,	O
"TypeMismatchError"	*(char)
,	O
"Type Mismatch"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_UserBreak_Error	int
,	O
"UserBreakError"	*(char)
,	O
"User Break"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Stack_Error	int
,	O
"StackError"	*(char)
,	O
"Stack Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_StackUnderflow_Error	int
,	O
"StackUnderflowError"	*(char)
,	O
"Stack Underflow Error"	*(char)
,	O
&	O
SL_Stack_Error	int
}	O
,	O
{	O
&	O
SL_StackOverflow_Error	int
,	O
"StackOverflowError"	*(char)
,	O
"Stack Overflow Error"	*(char)
,	O
&	O
SL_Stack_Error	int
}	O
,	O
{	O
&	O
SL_ReadOnly_Error	int
,	O
"ReadOnlyError"	*(char)
,	O
"Read-Only Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_VariableUninitialized_Error	int
,	O
"VariableUninitializedError"	*(char)
,	O
"Variable Uninitialized Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_NumArgs_Error	int
,	O
"NumArgsError"	*(char)
,	O
"Invalid Number of Arguments"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Index_Error	int
,	O
"IndexError"	*(char)
,	O
"Invalid Index"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Usage_Error	int
,	O
"UsageError"	*(char)
,	O
"Illegal Usage"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Application_Error	int
,	O
"ApplicationError"	*(char)
,	O
"Application Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_NotImplemented_Error	int
,	O
"NotImplementedError"	*(char)
,	O
"Not Implemented"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_LimitExceeded_Error	int
,	O
"LimitExceededError"	*(char)
,	O
"Limit Exceeded"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Forbidden_Error	int
,	O
"ForbiddenError"	*(char)
,	O
"Operation Forbidden"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Math_Error	int
,	O
"MathError"	*(char)
,	O
"Math Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_DivideByZero_Error	int
,	O
"DivideByZeroError"	*(char)
,	O
"Divide by Zero"	*(char)
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_ArithOverflow_Error	int
,	O
"ArithOverflowError"	*(char)
,	O
"Arithmetic Overflow"	*(char)
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_ArithUnderflow_Error	int
,	O
"ArithUnderflowError"	*(char)
,	O
"Arithmetic Underflow"	*(char)
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_Domain_Error	int
,	O
"DomainError"	*(char)
,	O
"Domain Error"	*(char)
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_IO_Error	int
,	O
"IOError"	*(char)
,	O
"I/O Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Write_Error	int
,	O
"WriteError"	*(char)
,	O
"Write failed"	*(char)
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Read_Error	int
,	O
"ReadError"	*(char)
,	O
"Read failed"	*(char)
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Open_Error	int
,	O
"OpenError"	*(char)
,	O
"Open failed"	*(char)
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Data_Error	int
,	O
"DataError"	*(char)
,	O
"Data Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Unicode_Error	int
,	O
"UnicodeError"	*(char)
,	O
"Unicode Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_InvalidUTF8_Error	int
,	O
"UTF8Error"	*(char)
,	O
"Invalid UTF8"	*(char)
,	O
&	O
SL_Unicode_Error	int
}	O
,	O
{	O
&	O
SL_Namespace_Error	int
,	O
"NamespaceError"	*(char)
,	O
"Namespace Error"	*(char)
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Parse_Error	int
,	O
"ParseError"	*(char)
,	O
"Parse Error"	*(char)
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Syntax_Error	int
,	O
"SyntaxError"	*(char)
,	O
"Syntax Error"	*(char)
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
&	O
SL_DuplicateDefinition_Error	int
,	O
"DuplicateDefinitionError"	*(char)
,	O
"Duplicate Definition"	*(char)
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
&	O
SL_UndefinedName_Error	int
,	O
"UndefinedNameError"	*(char)
,	O
"Undefined Name"	*(char)
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
Exception_Type	struct
*	O
find_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),int)->(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
(	O
Exception_Type	struct
*	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
error_code	int
)	O
{	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
error_code	int
==	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
)	O
return	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
find_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),int)->(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
error_code	int
)	O
;	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
return	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
return	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
int	O
is_exception_ancestor	(int,int)->(int)
(	O
int	O
a	*(char)
,	O
int	O
b	*(char)
)	O
{	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
a	*(char)
==	O
b	*(char)
)	O
return	O
1	int
;	O
if	O
(	O
NULL	O
==	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
find_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),int)->(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
(	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
a	*(char)
)	O
)	O
)	O
return	O
0	int
;	O
while	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
==	O
b	*(char)
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
SLerr_exception_eqs	(int,int)->(int)
(	O
int	O
a	*(char)
,	O
int	O
b	*(char)
)	O
{	O
if	O
(	O
is_exception_ancestor	(int,int)->(int)
(	O
a	*(char)
,	O
b	*(char)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
free_this_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
!=	O
NULL	O
)	O
SLang_free_slstring	(*(char))->(void)
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
!=	O
NULL	O
)	O
SLang_free_slstring	(*(char))->(void)
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
static	O
int	O
Next_Exception_Code	int
;	O
int	O
(	O
*	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
)	O
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
desc	*(char)
,	O
int	O
error_code	int
)	O
;	O
int	O
_pSLerr_init_interp_exceptions	()->(int)
(	O
void	O
)	O
{	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct(*(int),*(char),*(char),*(int))
*	O
b	*(char)
;	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
==	O
NULL	O
)	O
return	O
0	int
;	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
Exception_Root_Buf	struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
;	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
)	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
,	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
=	O
BuiltIn_Exception_Table	array(struct(*(int),*(char),*(char),*(int)))
;	O
while	O
(	O
b	*(char)
->	O
errcode_ptr	*(int)
!=	O
NULL	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
)	O
(	O
b	*(char)
->	O
name	*(char)
,	O
b	*(char)
->	O
description	*(char)
,	O
*	O
b	*(char)
->	O
errcode_ptr	*(int)
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
SLerr_new_exception	(int,*(char),*(char))->(int)
(	O
int	O
baseclass	int
,	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
descript	*(char)
)	O
{	O
Exception_Type	struct
*	O
base	int
;	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	()->(int)
(	O
)	O
)	O
return	O
-	O
1	int
;	O
base	int
=	O
find_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),int)->(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
(	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
baseclass	int
)	O
;	O
if	O
(	O
base	int
==	O
NULL	O
)	O
{	O
SLang_verror	(int,*(char))->(void)
(	O
SL_InvalidParm_Error	int
,	O
"Base class for new exception not found"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
(	O
Exception_Type	struct
*	O
)	O
SLcalloc	(int,int)->(*(char))
(	O
1	int
,	O
sizeof	O
(	O
Exception_Type	struct
)	O
)	O
;	O
if	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
=	O
SLang_create_slstring	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
=	O
SLang_create_slstring	(*(char))->(*(char))
(	O
descript	*(char)
)	O
)	O
)	O
)	O
{	O
free_this_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
=	O
Next_Exception_Code	int
;	O
if	O
(	O
(	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
!=	O
NULL	O
)	O
&&	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	*((*(char),*(char),int)->(int))
)	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
,	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
)	O
)	O
)	O
{	O
free_this_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
base	int
;	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
base	int
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
base	int
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
Next_Exception_Code	int
++	O
;	O
return	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
error_code	int
;	O
}	O
static	O
int	O
init_exceptions	()->(int)
(	O
void	O
)	O
{	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct(*(int),*(char),*(char),*(int))
*	O
b	*(char)
;	O
if	O
(	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
return	O
0	int
;	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
Exception_Root_Buf	struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
;	O
Next_Exception_Code	int
=	O
1	int
;	O
b	*(char)
=	O
BuiltIn_Exception_Table	array(struct(*(int),*(char),*(char),*(int)))
;	O
while	O
(	O
b	*(char)
->	O
errcode_ptr	*(int)
!=	O
NULL	O
)	O
{	O
int	O
err_code	int
;	O
err_code	int
=	O
SLerr_new_exception	(int,*(char),*(char))->(int)
(	O
*	O
b	*(char)
->	O
base_class_ptr	*(int)
,	O
b	*(char)
->	O
name	*(char)
,	O
b	*(char)
->	O
description	*(char)
)	O
;	O
if	O
(	O
err_code	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
*	O
b	*(char)
->	O
errcode_ptr	*(int)
=	O
err_code	int
;	O
b	*(char)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
free_exceptions	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
Exception_Type	struct
*	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
while	O
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
{	O
Exception_Type	struct
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
if	O
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
free_exceptions	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
free_this_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
}	O
static	O
void	O
deinit_exceptions	()->(void)
(	O
void	O
)	O
{	O
Exception_Type	struct
*	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
free_exceptions	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))->(void)
(	O
root	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
subclasses	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
Next_Exception_Code	int
=	O
0	int
;	O
}	O
char	O
*	O
SLerr_strerror	(int)->(*(char))
(	O
int	O
err_code	int
)	O
{	O
Exception_Type	struct
*	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
err_code	int
==	O
0	int
)	O
err_code	int
=	O
_pSLang_Error	int
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	()->(int)
(	O
)	O
)	O
return	O
"Unable to initialize SLerr module"	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
=	O
find_exception	(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))),int)->(*(struct(int,*(char),*(char),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)),*(struct(int,*`,*`,*`,*`,*`)))))
(	O
Exception_Root	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
err_code	int
)	O
)	O
)	O
return	O
"Invalid/Unknown Error Code"	*(char)
;	O
return	O
e	*(struct(int,*(char),*(char),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`))),*(struct(int,*(char),*(char),*(struct`),*(struct`),*(struct`)))))
->	O
description	*(char)
;	O
}	O
typedef	O
struct	O
_Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*(char),int,*(struct`))))))
{	O
char	O
*	O
msg	*(char)
;	O
int	O
msg_type	int
;	O
struct	O
_Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*(char),int,*(struct`))))))
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
;	O
typedef	O
struct	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
tail	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
}	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
;	O
static	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
;	O
static	O
void	O
free_error_msg	(*(struct(*(char),int,*(struct(*`,int,*`)))))->(void)
(	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
)	O
{	O
if	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
!=	O
NULL	O
)	O
SLang_free_slstring	(*(char))->(void)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
)	O
;	O
}	O
static	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
allocate_error_msg	(*(char),int)->(*(struct(*(char),int,*(struct(*`,int,*`)))))
(	O
char	O
*	O
msg	*(char)
,	O
int	O
msg_type	int
)	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
if	O
(	O
NULL	O
==	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
(	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
)	O
SLcalloc	(int,int)->(*(char))
(	O
1	int
,	O
sizeof	O
(	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
msg	*(char)
)	O
&&	O
(	O
NULL	O
==	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
=	O
SLang_create_slstring	(*(char))->(*(char))
(	O
msg	*(char)
)	O
)	O
)	O
)	O
{	O
free_error_msg	(*(struct(*(char),int,*(struct(*`,int,*`)))))->(void)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
)	O
;	O
return	O
NULL	O
;	O
}	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg_type	int
=	O
msg_type	int
;	O
return	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
}	O
static	O
void	O
free_queued_messages	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
if	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
while	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m1	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
free_error_msg	(*(struct(*(char),int,*(struct(*`,int,*`)))))->(void)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
)	O
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m1	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
}	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
tail	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
static	O
void	O
delete_msg_queue	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
{	O
if	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
free_queued_messages	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
;	O
}	O
static	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
create_msg_queue	()->(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))
(	O
void	O
)	O
{	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
;	O
if	O
(	O
NULL	O
==	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
=	O
(	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
)	O
SLcalloc	(int,int)->(*(char))
(	O
1	int
,	O
sizeof	O
(	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
return	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
;	O
}	O
static	O
int	O
queue_message	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))),*(char),int)->(int)
(	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
,	O
char	O
*	O
msg	*(char)
,	O
int	O
msg_type	int
)	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
if	O
(	O
NULL	O
==	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
allocate_error_msg	(*(char),int)->(*(struct(*(char),int,*(struct(*`,int,*`)))))
(	O
msg	*(char)
,	O
msg_type	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
tail	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
!=	O
NULL	O
)	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
tail	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
if	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
==	O
NULL	O
)	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
tail	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_error	(int,*(char))->(void)
(	O
int	O
msg_type	int
,	O
char	O
*	O
err	*(*(struct(int,int,*(char))))
)	O
{	O
unsigned	O
int	O
len	int
;	O
switch	O
(	O
msg_type	int
)	O
{	O
case	O
_SLERR_MSG_ERROR	int
:	O
if	O
(	O
SLang_Error_Hook	*((*(char))->(void))
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Error_Hook	*((*(char))->(void))
)	O
(	O
err	*(*(struct(int,int,*(char))))
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
_SLERR_MSG_TRACEBACK	int
:	O
case	O
_SLERR_MSG_WARNING	int
:	O
if	O
(	O
SLang_Dump_Routine	*((*(char))->(void))
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Dump_Routine	*((*(char))->(void))
)	O
(	O
err	*(*(struct(int,int,*(char))))
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
len	int
=	O
strlen	(*(char))->(long)
(	O
err	*(*(struct(int,int,*(char))))
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
err	*(*(struct(int,int,*(char))))
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
(	O
err	*(*(struct(int,int,*(char))))
[	O
len	int
-	O
1	int
]	O
!=	O
'\n'	O
)	O
&&	O
(	O
msg_type	int
!=	O
_SLERR_MSG_TRACEBACK	int
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
print_queue	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	()->(int)
(	O
)	O
)	O
print_error	(int,*(char))->(void)
(	O
_SLERR_MSG_ERROR	int
,	O
"Unable to initialize SLerr module"	*(char)
)	O
;	O
if	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
=	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
;	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
while	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m_next	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
if	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
!=	O
NULL	O
)	O
print_error	(int,*(char))->(void)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg_type	int
,	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
)	O
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m_next	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
}	O
free_queued_messages	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
;	O
}	O
}	O
char	O
*	O
_pSLerr_get_error_from_queue	()->(*(char))
(	O
void	O
)	O
{	O
Error_Queue_Type	struct(*(struct(*(char),int,*(struct(*`,int,*`)))),*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
;	O
Error_Message_Type	struct(*(char),int,*(struct(*(char),int,*(struct(*`,int,*`)))))
*	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
;	O
unsigned	O
int	O
len	int
;	O
char	O
*	O
err	*(*(struct(int,int,*(char))))
,	O
*	O
err1	*(char)
,	O
*	O
err_max	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
=	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
)	O
return	O
NULL	O
;	O
len	int
=	O
0	int
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
while	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg_type	int
==	O
_SLERR_MSG_ERROR	int
)	O
len	int
+=	O
1	int
+	O
strlen	(*(char))->(long)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
)	O
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
if	O
(	O
len	int
)	O
len	int
--	O
;	O
if	O
(	O
NULL	O
==	O
(	O
err	*(*(struct(int,int,*(char))))
=	O
_pSLallocate_slstring	(int)->(*(char))
(	O
len	int
)	O
)	O
)	O
return	O
NULL	O
;	O
err_max	*(char)
=	O
err	*(*(struct(int,int,*(char))))
+	O
len	int
;	O
err1	*(char)
=	O
err	*(*(struct(int,int,*(char))))
;	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
q	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
->	O
head	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
while	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
!=	O
NULL	O
)	O
{	O
if	O
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg_type	int
==	O
_SLERR_MSG_ERROR	int
)	O
{	O
unsigned	O
int	O
dlen	int
=	O
strlen	(*(char))->(long)
(	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
err1	*(char)
,	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
msg	*(char)
)	O
;	O
err1	*(char)
+=	O
dlen	int
;	O
if	O
(	O
err1	*(char)
!=	O
err_max	*(char)
)	O
*	O
err1	*(char)
++	O
=	O
'\n'	O
;	O
}	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
=	O
m	*(struct(*(char),int,*(struct(*(char),int,*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`),char)),char))
;	O
}	O
*	O
err1	*(char)
=	O
0	int
;	O
return	O
_pSLcreate_via_alloced_slstring	(*(char),int)->(*(char))
(	O
err	*(*(struct(int,int,*(char))))
,	O
len	int
)	O
;	O
}	O
void	O
_pSLerr_print_message_queue	()->(void)
(	O
void	O
)	O
{	O
print_queue	()->(void)
(	O
)	O
;	O
}	O
static	O
volatile	O
int	O
Suspend_Error_Messages	int
=	O
0	int
;	O
int	O
_pSLerr_resume_messages	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
Suspend_Error_Messages	int
==	O
0	int
)	O
return	O
0	int
;	O
Suspend_Error_Messages	int
--	O
;	O
if	O
(	O
Suspend_Error_Messages	int
==	O
0	int
)	O
print_queue	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_pSLerr_suspend_messages	()->(int)
(	O
void	O
)	O
{	O
Suspend_Error_Messages	int
++	O
;	O
return	O
0	int
;	O
}	O
void	O
_pSLerr_free_queued_messages	()->(void)
(	O
void	O
)	O
{	O
free_queued_messages	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
;	O
}	O
void	O
SLang_verror	(int,*(char))->(void)
(	O
int	O
err_code	int
,	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
err	*(*(struct(int,int,*(char))))
[	O
4096	int
]	O
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	()->(int)
(	O
)	O
)	O
{	O
print_queue	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
err_code	int
==	O
0	int
)	O
err_code	int
=	O
SL_INTRINSIC_ERROR	O
;	O
if	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
SLang_set_error	(int)->(int)
(	O
err_code	int
)	O
;	O
if	O
(	O
fmt	*(char)
==	O
NULL	O
)	O
return	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
(	O
void	O
)	O
SLvsnprintf	(*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
err	*(*(struct(int,int,*(char))))
,	O
sizeof	O
(	O
err	*(*(struct(int,int,*(char))))
)	O
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
Suspend_Error_Messages	int
)	O
(	O
void	O
)	O
queue_message	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))),*(char),int)->(int)
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
,	O
err	*(*(struct(int,int,*(char))))
,	O
_SLERR_MSG_ERROR	int
)	O
;	O
else	O
print_error	(int,*(char))->(void)
(	O
_SLERR_MSG_ERROR	int
,	O
err	*(*(struct(int,int,*(char))))
)	O
;	O
}	O
int	O
_pSLerr_traceback_msg	(*(char))->(int)
(	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
msg	*(char)
[	O
4096	int
]	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
(	O
void	O
)	O
SLvsnprintf	(*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
msg	*(char)
,	O
sizeof	O
(	O
msg	*(char)
)	O
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
queue_message	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))),*(char),int)->(int)
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
,	O
msg	*(char)
,	O
_SLERR_MSG_TRACEBACK	int
)	O
;	O
}	O
void	O
SLang_exit_error	(*(char))->(void)
(	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
print_queue	()->(void)
(	O
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
if	O
(	O
SLang_Exit_Error_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Exit_Error_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fmt	*(char)
!=	O
NULL	O
)	O
{	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
int	O
SLang_set_error	(int)->(int)
(	O
int	O
error	*(struct(int,int,*(char)))
)	O
{	O
if	O
(	O
(	O
error	*(struct(int,int,*(char)))
==	O
0	int
)	O
||	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
)	O
_pSLang_Error	int
=	O
error	*(struct(int,int,*(char)))
;	O
if	O
(	O
_pSLinterpreter_Error_Hook	*((int)->(void))
!=	O
NULL	O
)	O
(	O
*	O
_pSLinterpreter_Error_Hook	*((int)->(void))
)	O
(	O
_pSLang_Error	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
SLang_get_error	()->(int)
(	O
void	O
)	O
{	O
return	O
_pSLang_Error	int
;	O
}	O
void	O
SLang_vmessage	(*(char))->(void)
(	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
fmt	*(char)
==	O
NULL	O
)	O
return	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
if	O
(	O
SLang_VMessage_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
!=	O
NULL	O
)	O
(	O
*	O
SLang_VMessage_Hook	*((*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
else	O
{	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
_pSLerr_dump_msg	(*(char))->(void)
(	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
char	O
buf	*(char)
[	O
1024	int
]	O
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
if	O
(	O
SLang_Dump_Routine	*((*(char))->(void))
!=	O
NULL	O
)	O
{	O
(	O
void	O
)	O
SLvsnprintf	(*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
(	O
*	O
SLang_Dump_Routine	*((*(char))->(void))
)	O
(	O
buf	*(char)
)	O
;	O
}	O
else	O
{	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
int	O
_pSLerr_init	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
==	O
NULL	O
)	O
{	O
Suspend_Error_Messages	int
=	O
0	int
;	O
if	O
(	O
NULL	O
==	O
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
=	O
create_msg_queue	()->(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))
(	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
-	O
1	int
==	O
init_exceptions	()->(int)
(	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
_pSLerr_deinit	()->(void)
(	O
void	O
)	O
{	O
deinit_exceptions	()->(void)
(	O
)	O
;	O
delete_msg_queue	(*(struct(*(struct(*`,int,*`)),*(struct(*`,int,*`)))))->(void)
(	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
)	O
;	O
Suspend_Error_Messages	int
=	O
0	int
;	O
Default_Error_Queue	*(struct(*(struct(*(char),int,*(struct`))),*(struct(*(char),int,*(struct`)))))
=	O
NULL	O
;	O
}	O
