static	O
int	O
rec_int_check_descriptor	(*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_key	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
orig_record	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_types	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_mandatory	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_unique	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_prohibit	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_sex_constraints	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_check_record_allowed	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
int	O
rec_int_merge_remote	(*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
;	O
static	O
bool	bool
rec_int_rec_type_p	(*(char))->(bool)
(	O
const	O
char	O
*	O
str	*(char)
)	O
;	O
int	O
rec_int_check_db	(*(struct),bool,bool,*(struct))->(int)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
bool	bool
check_descriptors_p	bool
,	O
bool	bool
remote_descriptors_p	bool
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
ret	int
;	O
size_t	long
db_size	long
;	O
size_t	long
n_rset	long
;	O
rec_rset_t	*(struct)
rset	*(struct)
;	O
ret	int
=	O
0	int
;	O
db_size	long
=	O
rec_db_size	(*(struct))->(long)
(	O
db	*(struct)
)	O
;	O
for	O
(	O
n_rset	long
=	O
0	int
;	O
n_rset	long
<	O
db_size	long
;	O
n_rset	long
++	O
)	O
{	O
rset	*(struct)
=	O
rec_db_get_rset	(*(struct),long)->(*(struct))
(	O
db	*(struct)
,	O
n_rset	long
)	O
;	O
ret	int
=	O
ret	int
+	O
rec_int_check_rset	(*(struct),*(struct),bool,bool,*(struct))->(int)
(	O
db	*(struct)
,	O
rset	*(struct)
,	O
check_descriptors_p	bool
,	O
remote_descriptors_p	bool
,	O
errors	*(struct)
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
rec_int_check_rset	(*(struct),*(struct),bool,bool,*(struct))->(int)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
bool	bool
check_descriptor_p	bool
,	O
bool	bool
remote_descriptor_p	bool
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
;	O
rec_record_t	*(struct)
record	*(struct)
;	O
rec_record_t	*(struct)
descriptor	*(struct)
;	O
size_t	long
num_records	long
,	O
min_records	long
,	O
max_records	long
;	O
res	int
=	O
0	int
;	O
if	O
(	O
remote_descriptor_p	bool
&&	O
(	O
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
)	O
)	O
{	O
descriptor	*(struct)
=	O
rec_record_dup	(*(struct))->(*(struct))
(	O
descriptor	*(struct)
)	O
;	O
res	int
=	O
rec_int_merge_remote	(*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
errors	*(struct)
)	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
return	O
res	int
;	O
}	O
}	O
if	O
(	O
check_descriptor_p	bool
)	O
{	O
res	int
+=	O
rec_int_check_descriptor	(*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
errors	*(struct)
)	O
;	O
}	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
return	O
res	int
;	O
}	O
num_records	long
=	O
rec_rset_num_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
;	O
min_records	long
=	O
rec_rset_min_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
;	O
max_records	long
=	O
rec_rset_max_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
min_records	long
==	O
max_records	long
)	O
{	O
if	O
(	O
num_records	long
!=	O
min_records	long
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s: error: the number of records of type %s should be %zd.\n"	*(char)
)	O
,	O
rec_rset_source	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
rec_rset_type	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
min_records	long
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
num_records	long
>	O
rec_rset_max_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s: error: too many records of type %s. Maximum allowed are %zd.\n"	*(char)
)	O
,	O
rec_rset_source	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
rec_rset_type	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
rec_rset_max_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
num_records	long
<	O
rec_rset_min_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s: error: too few records of type %s. Minimum allowed are %zd.\n"	*(char)
)	O
,	O
rec_rset_source	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
rec_rset_type	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
,	O
rec_rset_min_records	(*(struct))->(long)
(	O
rset	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_rset_mset	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record	*(struct)
,	O
NULL	O
)	O
)	O
{	O
res	int
+=	O
rec_int_check_record	(*(struct),*(struct),*(struct),*(struct),*(struct))->(int)
(	O
db	*(struct)
,	O
rset	*(struct)
,	O
record	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
;	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
if	O
(	O
remote_descriptor_p	bool
)	O
{	O
rec_rset_set_descriptor	(*(struct),*(struct))->(void)
(	O
rset	*(struct)
,	O
descriptor	*(struct)
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
rec_int_check_record	(*(struct),*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
orig_record	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
res	int
=	O
rec_int_check_record_key	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
orig_record	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_types	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
db	*(struct)
,	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_mandatory	(*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_unique	(*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_prohibit	(*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_sex_constraints	(*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
+	O
rec_int_check_record_allowed	(*(struct),*(struct),*(struct))->(int)
(	O
rset	*(struct)
,	O
record	*(struct)
,	O
errors	*(struct)
)	O
;	O
return	O
res	int
;	O
}	O
bool	bool
rec_int_check_field_type	(*(struct),*(struct),*(struct),*(struct))->(bool)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_field_t	*(struct)
field	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
bool	bool
res	int
=	O
true	int
;	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
;	O
char	O
*	O
errors_str	*(char)
;	O
res	int
=	O
true	int
;	O
type	enum(int,int,int,int)
=	O
rec_rset_get_field_type	(*(struct),*(char))->(*(struct))
(	O
rset	*(struct)
,	O
rec_field_name	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type	enum(int,int,int,int)
)	O
==	O
REC_TYPE_REC	int
)	O
{	O
const	O
char	O
*	O
rset_type	*(char)
=	O
rec_type_rec	(*(struct))->(*(char))
(	O
type	enum(int,int,int,int)
)	O
;	O
rec_rset_t	*(struct)
rset	*(struct)
=	O
rec_db_get_rset_by_type	(*(struct),*(char))->(*(struct))
(	O
db	*(struct)
,	O
rset_type	*(char)
)	O
;	O
if	O
(	O
rset	*(struct)
)	O
{	O
const	O
char	O
*	O
key	*(char)
=	O
rec_rset_key	(*(struct))->(*(char))
(	O
rset	*(struct)
)	O
;	O
rec_type_t	*(struct)
key_type	*(struct)
=	O
rec_rset_get_field_type	(*(struct),*(char))->(*(struct))
(	O
rset	*(struct)
,	O
key	*(char)
)	O
;	O
if	O
(	O
key_type	*(struct)
)	O
{	O
if	O
(	O
!	O
rec_type_check	(*(struct),*(char),*(*(char)))->(bool)
(	O
key_type	*(struct)
,	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
&	O
errors_str	*(char)
)	O
)	O
{	O
if	O
(	O
errors	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
"%s:%s: error: %s\n"	*(char)
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
errors_str	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
errors_str	*(char)
)	O
;	O
res	int
=	O
false	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
rec_type_check	(*(struct),*(char),*(*(char)))->(bool)
(	O
type	enum(int,int,int,int)
,	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
&	O
errors_str	*(char)
)	O
)	O
{	O
if	O
(	O
errors	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
"%s:%s: error: %s\n"	*(char)
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
errors_str	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
errors_str	*(char)
)	O
;	O
res	int
=	O
false	int
;	O
}	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
rec_fex_t	*(struct)
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
rec_record_t	*(struct)
record	*(struct)
,	O
const	O
char	O
*	O
fname	*(char)
)	O
{	O
size_t	long
i	long
,	O
j	long
=	O
0	int
;	O
size_t	long
num_fields	long
=	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
record	*(struct)
,	O
fname	*(char)
)	O
;	O
rec_fex_t	*(struct)
res	int
=	O
rec_fex_new	(*(char),enum(int,int,int))->(*(struct))
(	O
NULL	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
!	O
res	int
)	O
return	O
NULL	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fields	long
;	O
i	long
++	O
)	O
{	O
rec_field_t	*(struct)
field	*(struct)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
record	*(struct)
,	O
fname	*(char)
,	O
i	long
)	O
;	O
rec_fex_t	*(struct)
fex	*(struct)
=	O
rec_fex_new	(*(char),enum(int,int,int))->(*(struct))
(	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
!	O
fex	*(struct)
)	O
continue	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
rec_fex_size	(*(struct))->(long)
(	O
fex	*(struct)
)	O
;	O
j	long
++	O
)	O
{	O
rec_fex_elem_t	*(struct)
elem	*(struct)
=	O
rec_fex_get	(*(struct),long)->(*(struct))
(	O
fex	*(struct)
,	O
j	long
)	O
;	O
char	O
*	O
field_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
rec_fex_elem_field_name	(*(struct))->(*(char))
(	O
elem	*(struct)
)	O
)	O
;	O
if	O
(	O
!	O
field_name	*(char)
||	O
!	O
rec_fex_append	(*(struct),*(char),int,int)->(*(struct))
(	O
res	int
,	O
field_name	*(char)
,	O
rec_fex_elem_min	(*(struct))->(int)
(	O
elem	*(struct)
)	O
,	O
rec_fex_elem_max	(*(struct))->(int)
(	O
elem	*(struct)
)	O
)	O
)	O
return	O
NULL	O
;	O
}	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex	*(struct)
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_types	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rec_db_t	*(struct)
db	*(struct)
,	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
rec_field_t	*(struct)
field	*(struct)
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
;	O
res	int
=	O
0	int
;	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_record_mset	(*(struct))->(*(struct))
(	O
record	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	*(struct)
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_int_check_field_type	(*(struct),*(struct),*(struct),*(struct))->(bool)
(	O
db	*(struct)
,	O
rset	*(struct)
,	O
field	*(struct)
,	O
errors	*(struct)
)	O
)	O
{	O
res	int
++	O
;	O
}	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_mandatory	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
rec_fex_t	*(struct)
fex_mandatory	*(struct)
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	*(struct)
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
fex_mandatory	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_mandatory	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"out of memory\n"	*(char)
)	O
,	O
""	*(char)
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	(*(struct))->(long)
(	O
fex_mandatory	*(struct)
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	*(char)
=	O
rec_fex_elem_field_name	(*(struct))->(*(char))
(	O
rec_fex_get	(*(struct),long)->(*(struct))
(	O
fex_mandatory	*(struct)
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
record	*(struct)
,	O
fname	*(char)
)	O
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: mandatory field '%s' not found in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
fname	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_mandatory	*(struct)
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_allowed	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
rec_fex_t	*(struct)
fex_allowed	*(struct)
=	O
NULL	O
;	O
rec_fex_t	*(struct)
fex_mandatory	*(struct)
=	O
NULL	O
;	O
rec_fex_t	*(struct)
fex_key	*(struct)
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
rec_record_t	*(struct)
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
fex_allowed	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_ALLOWED	int
)	O
)	O
;	O
fex_mandatory	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
;	O
fex_key	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_allowed	*(struct)
||	O
!	O
fex_mandatory	*(struct)
||	O
!	O
fex_key	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"out of memory\n"	*(char)
)	O
,	O
""	*(char)
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
rec_fex_size	(*(struct))->(long)
(	O
fex_allowed	*(struct)
)	O
==	O
0	int
)	O
goto	O
cleanup	O
;	O
rec_field_t	*(struct)
field	*(struct)
=	O
NULL	O
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_record_mset	(*(struct))->(*(struct))
(	O
record	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	*(struct)
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
field_name	*(char)
=	O
rec_field_name	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
;	O
if	O
(	O
!	O
(	O
rec_fex_member_p	(*(struct),*(char),int,int)->(bool)
(	O
fex_allowed	*(struct)
,	O
field_name	*(char)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
||	O
rec_fex_member_p	(*(struct),*(char),int,int)->(bool)
(	O
fex_mandatory	*(struct)
,	O
field_name	*(char)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
||	O
rec_fex_member_p	(*(struct),*(char),int,int)->(bool)
(	O
fex_key	*(struct)
,	O
field_name	*(char)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: field '%s' not allowed in this record set\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
field_name	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
}	O
cleanup	O
:	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_allowed	*(struct)
)	O
;	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_mandatory	*(struct)
)	O
;	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_key	*(struct)
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_unique	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
rec_fex_t	*(struct)
fex_unique	*(struct)
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	*(struct)
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
fex_unique	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_UNIQUE	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_unique	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"out of memory\n"	*(char)
)	O
,	O
""	*(char)
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	(*(struct))->(long)
(	O
fex_unique	*(struct)
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	*(char)
=	O
rec_fex_elem_field_name	(*(struct))->(*(char))
(	O
rec_fex_get	(*(struct),long)->(*(struct))
(	O
fex_unique	*(struct)
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
record	*(struct)
,	O
fname	*(char)
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: field '%s' should be unique in this record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
fname	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_unique	*(struct)
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_prohibit	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
rec_fex_t	*(struct)
fex_prohibit	*(struct)
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	*(struct)
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
fex_prohibit	*(struct)
=	O
rec_int_collect_field_list	(*(struct),*(char))->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_PROHIBIT	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_prohibit	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"out of memory\n"	*(char)
)	O
,	O
""	*(char)
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	(*(struct))->(long)
(	O
fex_prohibit	*(struct)
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	*(char)
=	O
rec_fex_elem_field_name	(*(struct))->(*(char))
(	O
rec_fex_get	(*(struct),long)->(*(struct))
(	O
fex_prohibit	*(struct)
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
record	*(struct)
,	O
fname	*(char)
)	O
>	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: prohibited field '%s' found in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
fname	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex_prohibit	*(struct)
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_sex_constraints	(*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
=	O
0	int
;	O
size_t	long
num_constraints	long
=	O
rec_rset_num_sex_constraints	(*(struct))->(long)
(	O
rset	*(struct)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_constraints	long
;	O
i	long
++	O
)	O
{	O
bool	bool
status	*(bool)
=	O
false	int
;	O
rec_sex_t	*(struct)
sex	*(struct)
=	O
rec_rset_sex_constraint	(*(struct),long)->(*(struct))
(	O
rset	*(struct)
,	O
i	long
)	O
;	O
if	O
(	O
!	O
rec_sex_eval	(*(struct),*(struct),*(bool))->(bool)
(	O
sex	*(struct)
,	O
record	*(struct)
,	O
&	O
status	*(bool)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: %%constraint[%d] violated in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
i	long
)	O
;	O
res	int
++	O
;	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_key	(*(struct),*(struct),*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_record_t	*(struct)
orig_record	*(struct)
,	O
rec_record_t	*(struct)
record	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
rec_record_t	*(struct)
descriptor	*(struct)
;	O
rec_record_t	*(struct)
other_record	*(struct)
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
;	O
char	O
*	O
key_field_name	*(char)
;	O
rec_field_t	*(struct)
field	*(struct)
;	O
rec_field_t	*(struct)
key	*(char)
;	O
rec_field_t	*(struct)
other_key	*(struct)
;	O
bool	bool
duplicated_key	bool
;	O
size_t	long
i	long
;	O
size_t	long
num_fields	long
;	O
res	int
=	O
0	int
;	O
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
;	O
i	long
++	O
)	O
{	O
field	*(struct)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
,	O
i	long
)	O
;	O
key_field_name	*(char)
=	O
rec_parse_field_name_str	(*(char))->(*(char))
(	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
if	O
(	O
key_field_name	*(char)
)	O
{	O
num_fields	long
=	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
record	*(struct)
,	O
key_field_name	*(char)
)	O
;	O
if	O
(	O
num_fields	long
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: key field '%s' not found in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
if	O
(	O
num_fields	long
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: multiple key fields '%s' in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
record	*(struct)
)	O
,	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
{	O
key	*(char)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
record	*(struct)
,	O
key_field_name	*(char)
,	O
0	int
)	O
;	O
duplicated_key	bool
=	O
false	int
;	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_rset_mset	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
other_record	*(struct)
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
other_record	*(struct)
!=	O
orig_record	*(struct)
)	O
{	O
other_key	*(struct)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
other_record	*(struct)
,	O
key_field_name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
other_key	*(struct)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
rec_field_value	(*(struct))->(*(char))
(	O
other_key	*(struct)
)	O
,	O
rec_field_value	(*(struct))->(*(char))
(	O
key	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
duplicated_key	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
if	O
(	O
duplicated_key	bool
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: duplicated key value in field '%s' in record\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
orig_record	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
orig_record	*(struct)
)	O
,	O
rec_field_name	(*(struct))->(*(char))
(	O
key	*(char)
)	O
)	O
;	O
res	int
++	O
;	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
key_field_name	*(char)
)	O
;	O
}	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_descriptor	(*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
rec_record_t	*(struct)
descriptor	*(struct)
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
;	O
rec_field_t	*(struct)
field	*(struct)
;	O
const	O
char	O
*	O
field_name	*(char)
;	O
const	O
char	O
*	O
field_value	*(char)
;	O
rec_fex_t	*(struct)
fex	*(struct)
;	O
const	O
char	O
*	O
auto_field_name	*(char)
;	O
size_t	long
i	long
;	O
rec_type_t	*(struct)
type	enum(int,int,int,int)
;	O
char	O
*	O
type_name	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(void)
=	O
NULL	O
;	O
res	int
=	O
0	int
;	O
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: missing %%rec field in record descriptor\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: too many %%rec fields in record descriptor\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
field	*(struct)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
rec_int_rec_type_p	(*(char))->(bool)
(	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: invalid record type %s\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: only one %%key field is allowed in a record descriptor\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_SIZE	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: only one %%size field is allowed in a record descriptor\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	(*(struct),*(char))->(long)
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: only one %%sort field is allowed in a record descriptor\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_record_mset	(*(struct))->(*(struct))
(	O
descriptor	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	*(struct)
,	O
NULL	O
)	O
)	O
{	O
field_name	*(char)
=	O
rec_field_name	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
;	O
field_value	*(char)
=	O
rec_field_value	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
;	O
if	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_TYPE	int
)	O
)	O
)	O
{	O
p	*(void)
=	O
field_value	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_FNAME_RE	*(char)
"(,"	*(char)
REC_FNAME_RE	*(char)
")*"	*(char)
,	O
NULL	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: expected a comma-separated list of fields before the type specification\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_type_descr_p	(*(char))->(bool)
(	O
p	*(void)
)	O
)	O
{	O
q	*(void)
=	O
p	*(void)
;	O
if	O
(	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
q	*(void)
,	O
"^"	*(char)
REC_TYPE_NAME_RE	*(char)
"[ \t\n]*$"	*(char)
,	O
NULL	O
)	O
)	O
{	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_TYPE_NAME_RE	*(char)
,	O
&	O
type_name	*(char)
)	O
;	O
if	O
(	O
!	O
rec_type_reg_get	(*(struct),*(char))->(*(struct))
(	O
rec_rset_get_type_reg	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
,	O
type_name	*(char)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: the referred type %s does not exist\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
type_name	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: invalid type specification\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_TYPEDEF	int
)	O
)	O
)	O
{	O
p	*(void)
=	O
field_value	*(char)
;	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_TYPE_NAME_RE	*(char)
,	O
NULL	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: expected a type name before the type specification\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
rec_skip_blanks	(*(*(char)))->(void)
(	O
&	O
p	*(void)
)	O
;	O
if	O
(	O
!	O
rec_type_descr_p	(*(char))->(bool)
(	O
p	*(void)
)	O
)	O
{	O
q	*(void)
=	O
p	*(void)
;	O
if	O
(	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
q	*(void)
,	O
"^"	*(char)
REC_TYPE_NAME_RE	*(char)
"[ \t\n]*$"	*(char)
,	O
NULL	O
)	O
)	O
{	O
rec_parse_regexp	(*(*(char)),*(char),*(*(char)))->(bool)
(	O
&	O
p	*(void)
,	O
"^"	*(char)
REC_TYPE_NAME_RE	*(char)
,	O
&	O
type_name	*(char)
)	O
;	O
if	O
(	O
!	O
rec_type_reg_get	(*(struct),*(char))->(*(struct))
(	O
rec_rset_get_type_reg	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
,	O
type_name	*(char)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: the referred type %s does not exist\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
type_name	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: invalid typedef specification\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_CONSTRAINT	int
)	O
)	O
)	O
{	O
rec_sex_t	*(struct)
sex	*(struct)
=	O
rec_sex_new	(bool)->(*(struct))
(	O
false	int
)	O
;	O
if	O
(	O
sex	*(struct)
)	O
{	O
if	O
(	O
rec_sex_compile	(*(struct),*(char))->(bool)
(	O
sex	*(struct)
,	O
field_value	*(char)
)	O
)	O
{	O
rec_sex_destroy	(*(struct))->(void)
(	O
sex	*(struct)
)	O
;	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: value for %s[%zd] is not a valid selection expression\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_field_name	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_record_get_field_index_by_name	(*(struct),*(struct))->(long)
(	O
descriptor	*(struct)
,	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
res	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
||	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_UNIQUE	int
)	O
)	O
||	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_PROHIBIT	int
)	O
)	O
||	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_AUTO	int
)	O
)	O
||	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
||	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_ALLOWED	int
)	O
)	O
)	O
{	O
fex	*(struct)
=	O
rec_fex_new	(*(char),enum(int,int,int))->(*(struct))
(	O
field_value	*(char)
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
fex	*(struct)
)	O
{	O
rec_fex_destroy	(*(struct))->(void)
(	O
fex	*(struct)
)	O
;	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: value for %s[%zd] is not a list of field names\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_field_name	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_record_get_field_index_by_name	(*(struct),*(struct))->(long)
(	O
descriptor	*(struct)
,	O
field	*(struct)
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_SIZE	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_match	(*(char),*(char))->(bool)
(	O
field_value	*(char)
,	O
REC_INT_SIZE_RE	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: value for %s should be a number optionally preceded by >, <, >= or <=.\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
field	*(struct)
)	O
,	O
field_name	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
if	O
(	O
(	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
field_name	*(char)
,	O
FNAME	O
(	O
REC_FIELD_AUTO	int
)	O
)	O
)	O
&&	O
(	O
fex	*(struct)
=	O
rec_fex_new	(*(char),enum(int,int,int))->(*(struct))
(	O
field_value	*(char)
,	O
REC_FEX_SIMPLE	int
)	O
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	(*(struct))->(long)
(	O
fex	*(struct)
)	O
;	O
i	long
++	O
)	O
{	O
auto_field_name	*(char)
=	O
rec_fex_elem_field_name	(*(struct))->(*(char))
(	O
rec_fex_get	(*(struct),long)->(*(struct))
(	O
fex	*(struct)
,	O
i	long
)	O
)	O
;	O
type	enum(int,int,int,int)
=	O
rec_rset_get_field_type	(*(struct),*(char))->(*(struct))
(	O
rset	*(struct)
,	O
auto_field_name	*(char)
)	O
;	O
if	O
(	O
(	O
!	O
type	enum(int,int,int,int)
)	O
||	O
!	O
(	O
(	O
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type	enum(int,int,int,int)
)	O
==	O
REC_TYPE_INT	int
)	O
||	O
(	O
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type	enum(int,int,int,int)
)	O
==	O
REC_TYPE_RANGE	int
)	O
||	O
(	O
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type	enum(int,int,int,int)
)	O
==	O
REC_TYPE_UUID	int
)	O
||	O
(	O
rec_type_kind	(*(struct))->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
type	enum(int,int,int,int)
)	O
==	O
REC_TYPE_DATE	int
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: auto-incremented field %s should be of type int, range, uuid or date\n"	*(char)
)	O
,	O
rec_record_source	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
rec_record_location_str	(*(struct))->(*(char))
(	O
descriptor	*(struct)
)	O
,	O
auto_field_name	*(char)
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
rec_int_merge_remote	(*(struct),*(struct))->(int)
(	O
rec_rset_t	*(struct)
rset	*(struct)
,	O
rec_buf_t	*(struct)
errors	*(struct)
)	O
{	O
int	O
res	int
;	O
rec_parser_t	*(struct)
parser	*(struct)
;	O
rec_record_t	*(struct)
descriptor	*(struct)
;	O
rec_db_t	*(struct)
remote_db	*(struct)
;	O
rec_rset_t	*(struct)
remote_rset	*(struct)
;	O
rec_field_t	*(struct)
remote_field	*(struct)
;	O
rec_mset_iterator_t	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
;	O
rec_record_t	*(struct)
remote_descriptor	*(struct)
;	O
rec_field_t	*(struct)
rec_field	*(struct)
;	O
char	O
*	O
rec_type	*(char)
;	O
char	O
*	O
rec_url	*(char)
=	O
NULL	O
;	O
char	O
*	O
rec_file	*(char)
=	O
NULL	O
;	O
char	O
*	O
rec_source	*(char)
=	O
NULL	O
;	O
FILE	struct
*	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
tmpfile_name	array(char)
[	O
14	int
]	O
;	O
res	int
=	O
0	int
;	O
tmpfile_name	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
rset	*(struct)
)	O
;	O
if	O
(	O
descriptor	*(struct)
)	O
{	O
rec_field	*(struct)
=	O
rec_record_get_field_by_name	(*(struct),*(char),long)->(*(struct))
(	O
descriptor	*(struct)
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
rec_int_rec_type_p	(*(char))->(bool)
(	O
rec_field_value	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
)	O
)	O
{	O
return	O
0	int
;	O
}	O
rec_type	*(char)
=	O
rec_extract_type	(*(char))->(*(char))
(	O
rec_field_value	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
)	O
;	O
rec_file	*(char)
=	O
rec_extract_file	(*(char))->(*(char))
(	O
rec_field_value	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
)	O
;	O
rec_url	*(char)
=	O
rec_extract_url	(*(char))->(*(char))
(	O
rec_field_value	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
)	O
;	O
if	O
(	O
rec_file	*(char)
||	O
rec_url	*(char)
)	O
{	O
if	O
(	O
rec_url	*(char)
)	O
{	O
goto	O
exit	(int)->(void)
;	O
}	O
else	O
{	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
rec_file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: could not read external descriptor from file %s.\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_file	*(char)
)	O
;	O
res	int
++	O
;	O
goto	O
exit	(int)->(void)
;	O
}	O
rec_source	*(char)
=	O
rec_file	*(char)
;	O
}	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
parser	*(struct)
=	O
rec_parser_new	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(*(struct))
(	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
rec_source	*(char)
)	O
;	O
if	O
(	O
!	O
rec_parse_db	(*(struct),*(*(struct)))->(bool)
(	O
parser	*(struct)
,	O
&	O
remote_db	*(struct)
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: %s does not contain valid rec data.\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_source	*(char)
)	O
;	O
res	int
++	O
;	O
goto	O
exit	(int)->(void)
;	O
}	O
rec_parser_destroy	(*(struct))->(void)
(	O
parser	*(struct)
)	O
;	O
remote_rset	*(struct)
=	O
rec_db_get_rset_by_type	(*(struct),*(char))->(*(struct))
(	O
remote_db	*(struct)
,	O
rec_type	*(char)
)	O
;	O
if	O
(	O
!	O
remote_rset	*(struct)
)	O
{	O
ADD_ERROR	O
(	O
errors	*(struct)
,	O
_	O
(	O
"%s:%s: error: %s does not contain information for type %s.\n"	*(char)
)	O
,	O
rec_field_source	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_field_location_str	(*(struct))->(*(char))
(	O
rec_field	*(struct)
)	O
,	O
rec_source	*(char)
,	O
rec_type	*(char)
)	O
;	O
res	int
++	O
;	O
goto	O
exit	(int)->(void)
;	O
}	O
remote_descriptor	*(struct)
=	O
rec_rset_descriptor	(*(struct))->(*(struct))
(	O
remote_rset	*(struct)
)	O
;	O
if	O
(	O
!	O
remote_descriptor	*(struct)
)	O
{	O
goto	O
exit	(int)->(void)
;	O
}	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
=	O
rec_mset_iterator	(*(struct))->(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long)))
(	O
rec_record_mset	(*(struct))->(*(struct))
(	O
remote_descriptor	*(struct)
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))),int,*(*(void)),*(*(struct)))->(bool)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
remote_field	*(struct)
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_field_name_equal_p	(*(char),*(char))->(bool)
(	O
rec_field_name	(*(struct))->(*(char))
(	O
remote_field	*(struct)
)	O
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
)	O
{	O
rec_mset_append	(*(struct),int,*(void),int)->(*(struct))
(	O
rec_record_mset	(*(struct))->(*(struct))
(	O
descriptor	*(struct)
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
rec_field_dup	(*(struct))->(*(struct))
(	O
remote_field	*(struct)
)	O
,	O
MSET_ANY	int
)	O
;	O
}	O
}	O
rec_mset_iterator_free	(*(struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))))->(void)
(	O
&	O
iter	struct(*(struct),struct(*(void),*(void),long,*(void),*(void),long,long))
)	O
;	O
rec_rset_set_descriptor	(*(struct),*(struct))->(void)
(	O
rset	*(struct)
,	O
rec_record_dup	(*(struct))->(*(struct))
(	O
descriptor	*(struct)
)	O
)	O
;	O
rec_db_destroy	(*(struct))->(void)
(	O
remote_db	*(struct)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
external_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
exit	(int)->(void)
:	O
if	O
(	O
rec_url	*(char)
&&	O
(	O
tmpfile_name	array(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
{	O
remove	(*(char))->(int)
(	O
tmpfile_name	array(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
rec_url	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
rec_file	*(char)
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bool	bool
rec_int_rec_type_p	(*(char))->(bool)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
return	O
rec_match	(*(char),*(char))->(bool)
(	O
str	*(char)
,	O
"^[ \t]*"	*(char)
REC_RECORD_TYPE_RE	O
"[ \n\t]*"	*(char)
"("	*(char)
"("	*(char)
REC_URL_REGEXP	*(char)
")"	*(char)
"|"	*(char)
"("	*(char)
REC_FILE_REGEXP	*(char)
")"	*(char)
"[ \t]*)?"	*(char)
"$"	*(char)
)	O
;	O
}	O
