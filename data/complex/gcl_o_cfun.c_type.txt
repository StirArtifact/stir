object	(*(int))->(int)
sSPinit	int
,	O
sSPmemory	O
;	O
object	(*(int))->(int)
make_cfun	(*(()->(void)),int,int,*(char),int)->(int)
(	O
void	O
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
data	int
,	O
char	O
*	O
start	*(char)
,	O
int	O
size	int
)	O
{	O
object	(*(int))->(int)
cf	O
;	O
cf	O
=	O
alloc_object	()->(int)
(	O
t_cfun	O
)	O
;	O
cf	O
->	O
cf	O
.	O
cf_self	O
=	O
self	*(()->(void))
;	O
cf	O
->	O
cf	O
.	O
cf_name	O
=	O
name	int
;	O
cf	O
->	O
cf	O
.	O
cf_data	O
=	O
data	int
;	O
if	O
(	O
data	int
&&	O
type_of	()->(int)
(	O
data	int
)	O
==	O
t_cfdata	O
)	O
{	O
data	int
->	O
cfd	O
.	O
cfd_start	O
=	O
start	*(char)
;	O
data	int
->	O
cfd	O
.	O
cfd_size	O
=	O
size	int
;	O
}	O
else	O
if	O
(	O
size	int
)	O
FEerror	()->(int)
(	O
"Bad call to make_cfun"	*(char)
,	O
0	int
)	O
;	O
return	O
(	O
cf	O
)	O
;	O
}	O
object	(*(int))->(int)
make_sfun	(int,(*(int))->(int),int,int)->(int)
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
sfn	O
;	O
sfn	O
=	O
alloc_object	()->(int)
(	O
t_sfun	O
)	O
;	O
if	O
(	O
argd	int
>	O
15	int
)	O
sfn	O
->	O
d	O
.	O
t	O
=	O
(	O
int	O
)	O
t_gfun	O
;	O
sfn	O
->	O
sfn	O
.	O
sfn_self	O
=	O
self	*(()->(void))
;	O
sfn	O
->	O
sfn	O
.	O
sfn_name	O
=	O
name	int
;	O
sfn	O
->	O
sfn	O
.	O
sfn_data	O
=	O
data	int
;	O
sfn	O
->	O
sfn	O
.	O
sfn_argd	O
=	O
argd	int
;	O
return	O
(	O
sfn	O
)	O
;	O
}	O
static	O
object	(*(int))->(int)
make_vfun	(int,(*(int))->(int),int,int)->(int)
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
vfn	O
;	O
vfn	O
=	O
alloc_object	()->(int)
(	O
t_vfun	O
)	O
;	O
vfn	O
->	O
vfn	O
.	O
vfn_self	O
=	O
self	*(()->(void))
;	O
vfn	O
->	O
vfn	O
.	O
vfn_name	O
=	O
name	int
;	O
vfn	O
->	O
vfn	O
.	O
vfn_minargs	O
=	O
VFUN_MIN_ARGS	O
(	O
argd	int
)	O
;	O
vfn	O
->	O
vfn	O
.	O
vfn_maxargs	O
=	O
VFUN_MAX_ARGS	O
(	O
argd	int
)	O
;	O
vfn	O
->	O
vfn	O
.	O
vfn_data	O
=	O
data	int
;	O
return	O
(	O
vfn	O
)	O
;	O
}	O
object	(*(int))->(int)
make_cclosure_new	(*(()->(void)),int,int,int)->(int)
(	O
void	O
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
env	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
cc	O
;	O
cc	O
=	O
alloc_object	()->(int)
(	O
t_cclosure	O
)	O
;	O
cc	O
->	O
cc	O
.	O
cc_self	O
=	O
self	*(()->(void))
;	O
cc	O
->	O
cc	O
.	O
cc_name	O
=	O
name	int
;	O
cc	O
->	O
cc	O
.	O
cc_env	O
=	O
env	int
;	O
cc	O
->	O
cc	O
.	O
cc_data	O
=	O
data	int
;	O
cc	O
->	O
cc	O
.	O
cc_turbo	O
=	O
NULL	O
;	O
turbo_closure	()->(int)
(	O
cc	O
)	O
;	O
return	O
(	O
cc	O
)	O
;	O
}	O
object	(*(int))->(int)
make_cclosure	(*(()->(void)),int,int,int,*(char),int)->(int)
(	O
void	O
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
env	int
,	O
object	(*(int))->(int)
data	int
,	O
char	O
*	O
start	*(char)
,	O
int	O
size	int
)	O
{	O
if	O
(	O
data	int
&&	O
type_of	()->(int)
(	O
data	int
)	O
==	O
t_cfdata	O
)	O
{	O
data	int
->	O
cfd	O
.	O
cfd_start	O
=	O
start	*(char)
;	O
data	int
->	O
cfd	O
.	O
cfd_size	O
=	O
size	int
;	O
}	O
else	O
if	O
(	O
size	int
)	O
FEerror	()->(int)
(	O
"Bad call to make_cclosure"	*(char)
,	O
0	int
)	O
;	O
return	O
make_cclosure_new	(*(()->(void)),int,int,int)->(int)
(	O
self	*(()->(void))
,	O
name	int
,	O
env	int
,	O
data	int
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MC"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmc	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
address	O
)	O
,	O
""	*(char)
)	O
{	O
dcheck_type	O
(	O
name	int
,	O
t_symbol	O
)	O
;	O
dcheck_type	O
(	O
address	O
,	O
t_fixnum	O
)	O
;	O
dcheck_type	O
(	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
,	O
t_cfdata	O
)	O
;	O
name	int
=	O
make_cclosure_new	(*(()->(void)),int,int,int)->(int)
(	O
PADDR	O
(	O
address	O
)	O
,	O
name	int
,	O
Cnil	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
;	O
RETURN1	()->(int)
(	O
name	int
)	O
;	O
}	O
static	O
object	(*(int))->(int)
MFsfun	(int,(*(int))->(int),int,int)->(int)
(	O
object	(*(int))->(int)
sym	int
,	O
object	(*(int))->(int)
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
sfn	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
&&	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
)	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
sfn	O
=	O
make_sfun	(int,(*(int))->(int),int,int)->(int)
(	O
sym	int
,	O
self	*(()->(void))
,	O
argd	int
,	O
data	int
)	O
;	O
sym	int
=	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
sfn	O
)	O
;	O
sym	int
->	O
s	*(char)
.	O
s_gfdef	O
=	O
sfn	O
;	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MFSFUN"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmfsfun	O
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
address	O
,	O
object	(*(int))->(int)
argd	int
)	O
,	O
""	*(char)
)	O
{	O
dcheck_type	O
(	O
address	O
,	O
t_fixnum	O
)	O
;	O
return	O
MFsfun	(int,(*(int))->(int),int,int)->(int)
(	O
name	int
,	O
PADDR	O
(	O
address	O
)	O
,	O
fix	()->(int)
(	O
argd	int
)	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
;	O
RETURN1	()->(int)
(	O
name	int
)	O
;	O
}	O
static	O
object	(*(int))->(int)
MFvfun	(int,(*(int))->(int),int,int)->(int)
(	O
object	(*(int))->(int)
sym	int
,	O
object	(*(int))->(int)
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
vfn	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
&&	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
)	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
dcheck_type	O
(	O
data	int
,	O
t_cfdata	O
)	O
;	O
vfn	O
=	O
make_vfun	(int,(*(int))->(int),int,int)->(int)
(	O
sym	int
,	O
self	*(()->(void))
,	O
argd	int
,	O
data	int
)	O
;	O
sym	int
=	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
vfn	O
)	O
;	O
sym	int
->	O
s	*(char)
.	O
s_gfdef	O
=	O
vfn	O
;	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MFVFUN"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmfvfun	O
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
address	O
,	O
object	(*(int))->(int)
argd	int
)	O
,	O
""	*(char)
)	O
{	O
MFvfun	(int,(*(int))->(int),int,int)->(int)
(	O
name	int
,	O
PADDR	O
(	O
address	O
)	O
,	O
fix	()->(int)
(	O
argd	int
)	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
;	O
RETURN1	()->(int)
(	O
name	int
)	O
;	O
}	O
static	O
object	(*(int))->(int)
MFvfun_key	(int,(*(int))->(int),int,int,*(struct))->(int)
(	O
object	(*(int))->(int)
sym	int
,	O
object	(*(int))->(int)
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
data	int
,	O
struct	O
key	O
*	O
keys	*(struct)
)	O
{	O
if	O
(	O
data	int
)	O
set_key_struct	()->(int)
(	O
keys	*(struct)
,	O
data	int
)	O
;	O
return	O
MFvfun	(int,(*(int))->(int),int,int)->(int)
(	O
sym	int
,	O
self	*(()->(void))
,	O
argd	int
,	O
data	int
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MFVFUN-KEY"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmfvfun_key	O
,	O
SI	O
,	O
4	int
,	O
4	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
symbol	O
,	O
object	(*(int))->(int)
address	O
,	O
object	(*(int))->(int)
argd	int
,	O
object	(*(int))->(int)
keys	*(struct)
)	O
,	O
""	*(char)
)	O
{	O
MFvfun_key	(int,(*(int))->(int),int,int,*(struct))->(int)
(	O
symbol	O
,	O
PADDR	O
(	O
address	O
)	O
,	O
fix	()->(int)
(	O
argd	int
)	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
,	O
PADDR	O
(	O
keys	*(struct)
)	O
)	O
;	O
RETURN1	()->(int)
(	O
symbol	O
)	O
;	O
}	O
static	O
object	(*(int))->(int)
MFnew	(int,*(()->(void)),int)->(int)
(	O
object	(*(int))->(int)
sym	int
,	O
void	O
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
cf	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
&&	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
)	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
cf	O
=	O
alloc_object	()->(int)
(	O
t_cfun	O
)	O
;	O
cf	O
->	O
cf	O
.	O
cf_self	O
=	O
self	*(()->(void))
;	O
cf	O
->	O
cf	O
.	O
cf_name	O
=	O
sym	int
;	O
cf	O
->	O
cf	O
.	O
cf_data	O
=	O
data	int
;	O
sym	int
=	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
cf	O
)	O
;	O
sym	int
->	O
s	*(char)
.	O
s_gfdef	O
=	O
cf	O
;	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MF"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmf	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
addr	O
)	O
,	O
""	*(char)
)	O
{	O
MFnew	(int,*(()->(void)),int)->(int)
(	O
name	int
,	O
PADDR	O
(	O
addr	O
)	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
;	O
RETURN1	()->(int)
(	O
name	int
)	O
;	O
}	O
static	O
object	(*(int))->(int)
MM	(int,*(()->(void)),*(char),int,int)->(int)
(	O
object	(*(int))->(int)
sym	int
,	O
void	O
(	O
*	O
self	*(()->(void))
)	O
(	O
)	O
,	O
char	O
*	O
start	*(char)
,	O
int	O
size	int
,	O
object	(*(int))->(int)
data	int
)	O
{	O
object	(*(int))->(int)
cf	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
&&	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
)	O
sym	int
->	O
s	*(char)
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
cf	O
=	O
alloc_object	()->(int)
(	O
t_cfun	O
)	O
;	O
cf	O
->	O
cf	O
.	O
cf_self	O
=	O
self	*(()->(void))
;	O
cf	O
->	O
cf	O
.	O
cf_name	O
=	O
sym	int
;	O
cf	O
->	O
cf	O
.	O
cf_data	O
=	O
data	int
;	O
data	int
->	O
cfd	O
.	O
cfd_start	O
=	O
start	*(char)
;	O
data	int
->	O
cfd	O
.	O
cfd_size	O
=	O
size	int
;	O
sym	int
=	O
clear_compiler_properties	()->(int)
(	O
sym	int
,	O
cf	O
)	O
;	O
sym	int
->	O
s	*(char)
.	O
s_gfdef	O
=	O
cf	O
;	O
sym	int
->	O
s	*(char)
.	O
s_mflag	O
=	O
TRUE	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"MM"	*(char)
,	O
object	(*(int))->(int)
,	O
fSmm	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
name	int
,	O
object	(*(int))->(int)
addr	O
)	O
,	O
""	*(char)
)	O
{	O
MM	(int,*(()->(void)),*(char),int,int)->(int)
(	O
name	int
,	O
PADDR	O
(	O
addr	O
)	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
->	O
cfd	O
.	O
cfd_start	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
->	O
cfd	O
.	O
cfd_size	O
,	O
sSPmemory	O
->	O
s	*(char)
.	O
s_dbind	O
)	O
;	O
RETURN1	()->(int)
(	O
name	int
)	O
;	O
}	O
object	(*(int))->(int)
make_function_internal	(*(char),*(()->(void)))->(int)
(	O
char	O
*	O
s	*(char)
,	O
void	O
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
)	O
{	O
object	(*(int))->(int)
x	O
;	O
vs_mark	O
;	O
x	O
=	O
make_ordinary	()->(int)
(	O
s	*(char)
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_gfdef	O
=	O
make_cfun	(*(()->(void)),int,int,*(char),int)->(int)
(	O
f	*(()->(void))
,	O
x	O
,	O
Cnil	O
,	O
NULL	O
,	O
0	int
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
vs_reset	O
;	O
return	O
(	O
x	O
)	O
;	O
}	O
object	(*(int))->(int)
make_si_sfun_internal	(*(char),(*(int))->(int),int)->(int)
(	O
char	O
*	O
s	*(char)
,	O
object	(*(int))->(int)
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
,	O
int	O
argd	int
)	O
{	O
object	(*(int))->(int)
x	O
=	O
make_si_ordinary	()->(int)
(	O
s	*(char)
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_gfdef	O
=	O
make_sfun	(int,(*(int))->(int),int,int)->(int)
(	O
x	O
,	O
f	*(()->(void))
,	O
argd	int
,	O
Cnil	O
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
return	O
(	O
x	O
)	O
;	O
}	O
object	(*(int))->(int)
make_si_function_internal	(*(char),*(()->(void)))->(int)
(	O
char	O
*	O
s	*(char)
,	O
void	O
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
)	O
{	O
object	(*(int))->(int)
x	O
;	O
vs_mark	O
;	O
x	O
=	O
make_si_ordinary	()->(int)
(	O
s	*(char)
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_gfdef	O
=	O
make_cfun	(*(()->(void)),int,int,*(char),int)->(int)
(	O
f	*(()->(void))
,	O
x	O
,	O
Cnil	O
,	O
NULL	O
,	O
0	int
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_mflag	O
=	O
FALSE	O
;	O
vs_reset	O
;	O
return	O
(	O
x	O
)	O
;	O
}	O
object	(*(int))->(int)
make_special_form_internal	(*(char),*(()->(void)))->(int)
(	O
char	O
*	O
s	*(char)
,	O
void	O
(	O
*	O
f	*(()->(void))
)	O
(	O
)	O
)	O
{	O
object	(*(int))->(int)
x	O
;	O
x	O
=	O
make_ordinary	()->(int)
(	O
s	*(char)
)	O
;	O
x	O
->	O
s	*(char)
.	O
s_sfdef	O
=	O
f	*(()->(void))
;	O
return	O
(	O
x	O
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"COMPILED-FUNCTION-NAME"	*(char)
,	O
object	(*(int))->(int)
,	O
fScompiled_function_name	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
fun	int
)	O
,	O
""	*(char)
)	O
{	O
switch	O
(	O
type_of	()->(int)
(	O
fun	int
)	O
)	O
{	O
case	O
t_cfun	O
:	O
case	O
t_afun	O
:	O
case	O
t_closure	O
:	O
case	O
t_sfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_cclosure	O
:	O
case	O
t_gfun	O
:	O
fun	int
=	O
fun	int
->	O
cf	O
.	O
cf_name	O
;	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"~S is not a compiled-function."	*(char)
,	O
1	int
,	O
fun	int
)	O
;	O
}	O
RETURN1	()->(int)
(	O
fun	int
)	O
;	O
}	O
void	O
turbo_closure	()->(int)
(	O
object	(*(int))->(int)
fun	int
)	O
{	O
object	(*(int))->(int)
l	O
,	O
*	O
block	O
;	O
int	O
n	int
;	O
if	O
(	O
1	int
)	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
l	O
=	O
fun	int
->	O
cc	O
.	O
cc_env	O
;	O
!	O
endp	()->(int)
(	O
l	O
)	O
;	O
n	int
++	O
,	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
)	O
;	O
{	O
block	O
=	O
AR_ALLOC	()->(int)
(	O
alloc_relblock	O
,	O
(	O
1	int
+	O
n	int
)	O
,	O
object	(*(int))->(int)
)	O
;	O
*	O
block	O
=	O
make_fixnum	()->(int)
(	O
n	int
)	O
;	O
fun	int
->	O
cc	O
.	O
cc_turbo	O
=	O
block	O
+	O
1	int
;	O
for	O
(	O
n	int
=	O
0	int
,	O
l	O
=	O
fun	int
->	O
cc	O
.	O
cc_env	O
;	O
!	O
endp	()->(int)
(	O
l	O
)	O
;	O
n	int
++	O
,	O
l	O
=	O
l	O
->	O
c	O
.	O
c_cdr	O
)	O
fun	int
->	O
cc	O
.	O
cc_turbo	O
[	O
n	int
]	O
=	O
l	O
;	O
}	O
END_NO_INTERRUPT	O
;	O
}	O
}	O
DEFUN_NEW	()->(int)
(	O
"TURBO-CLOSURE"	*(char)
,	O
object	(*(int))->(int)
,	O
fSturbo_closure	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
funobj	O
)	O
,	O
""	*(char)
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
funobj	O
)	O
==	O
t_cclosure	O
)	O
turbo_closure	()->(int)
(	O
funobj	O
)	O
;	O
RETURN1	()->(int)
(	O
funobj	O
)	O
;	O
}	O
void	O
gcl_init_cfun	()->(void)
(	O
void	O
)	O
{	O
}	O
