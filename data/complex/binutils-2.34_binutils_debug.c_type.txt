struct	O
debug_handle	O
{	O
struct	O
debug_unit	O
*	O
units	O
;	O
struct	O
debug_unit	O
*	O
current_unit	O
;	O
struct	O
debug_file	O
*	O
current_file	O
;	O
struct	O
debug_function	O
*	O
current_function	O
;	O
struct	O
debug_block	O
*	O
current_block	O
;	O
struct	O
debug_lineno	O
*	O
current_lineno	O
;	O
unsigned	O
int	O
mark	O
;	O
unsigned	O
int	O
class_id	O
;	O
unsigned	O
int	O
base_id	O
;	O
struct	O
debug_lineno	O
*	O
current_write_lineno	O
;	O
unsigned	O
int	O
current_write_lineno_index	O
;	O
struct	O
debug_class_id	O
*	O
id_list	O
;	O
struct	O
debug_type_compare_list	O
*	O
compare_list	O
;	O
}	O
;	O
struct	O
debug_unit	O
{	O
struct	O
debug_unit	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_file	O
*	O
files	O
;	O
struct	O
debug_lineno	O
*	O
linenos	O
;	O
}	O
;	O
struct	O
debug_file	O
{	O
struct	O
debug_file	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
filename	*(char)
;	O
struct	O
debug_namespace	O
*	O
globals	O
;	O
}	O
;	O
struct	O
debug_type_s	O
{	O
enum	O
debug_type_kind	O
kind	O
;	O
unsigned	O
int	O
size	int
;	O
debug_type	O
pointer	O
;	O
union	O
{	O
struct	O
debug_indirect_type	O
*	O
kindirect	O
;	O
bfd_boolean	int
kint	O
;	O
struct	O
debug_class_type	O
*	O
kclass	O
;	O
struct	O
debug_enum_type	O
*	O
kenum	O
;	O
struct	O
debug_type_s	O
*	O
kpointer	O
;	O
struct	O
debug_function_type	O
*	O
kfunction	O
;	O
struct	O
debug_type_s	O
*	O
kreference	O
;	O
struct	O
debug_range_type	O
*	O
krange	O
;	O
struct	O
debug_array_type	O
*	O
karray	O
;	O
struct	O
debug_set_type	O
*	O
kset	O
;	O
struct	O
debug_offset_type	O
*	O
koffset	O
;	O
struct	O
debug_method_type	O
*	O
kmethod	O
;	O
struct	O
debug_type_s	O
*	O
kconst	O
;	O
struct	O
debug_type_s	O
*	O
kvolatile	O
;	O
struct	O
debug_named_type	O
*	O
knamed	O
;	O
}	O
u	union(long,*(struct))
;	O
}	O
;	O
struct	O
debug_indirect_type	O
{	O
debug_type	O
*	O
slot	O
;	O
const	O
char	O
*	O
tag	O
;	O
}	O
;	O
struct	O
debug_class_type	O
{	O
debug_field	O
*	O
fields	O
;	O
unsigned	O
int	O
mark	O
;	O
unsigned	O
int	O
id	int
;	O
debug_baseclass	O
*	O
baseclasses	O
;	O
debug_method	O
*	O
methods	O
;	O
debug_type	O
vptrbase	O
;	O
}	O
;	O
struct	O
debug_enum_type	O
{	O
const	O
char	O
*	O
*	O
names	O
;	O
bfd_signed_vma	long
*	O
values	O
;	O
}	O
;	O
struct	O
debug_function_type	O
{	O
debug_type	O
return_type	O
;	O
debug_type	O
*	O
arg_types	O
;	O
bfd_boolean	int
varargs	O
;	O
}	O
;	O
struct	O
debug_range_type	O
{	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_signed_vma	long
lower	O
;	O
bfd_signed_vma	long
upper	O
;	O
}	O
;	O
struct	O
debug_array_type	O
{	O
debug_type	O
element_type	O
;	O
debug_type	O
range_type	O
;	O
bfd_signed_vma	long
lower	O
;	O
bfd_signed_vma	long
upper	O
;	O
bfd_boolean	int
stringp	O
;	O
}	O
;	O
struct	O
debug_set_type	O
{	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_boolean	int
bitstringp	O
;	O
}	O
;	O
struct	O
debug_offset_type	O
{	O
debug_type	O
base_type	O
;	O
debug_type	O
target_type	O
;	O
}	O
;	O
struct	O
debug_method_type	O
{	O
debug_type	O
return_type	O
;	O
debug_type	O
domain_type	O
;	O
debug_type	O
*	O
arg_types	O
;	O
bfd_boolean	int
varargs	O
;	O
}	O
;	O
struct	O
debug_named_type	O
{	O
struct	O
debug_name	O
*	O
name	*(char)
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
}	O
;	O
struct	O
debug_field_s	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
;	O
enum	O
debug_visibility	O
visibility	O
;	O
bfd_boolean	int
static_member	O
;	O
union	O
{	O
struct	O
{	O
unsigned	O
int	O
bitpos	int
;	O
unsigned	O
int	O
bitsize	int
;	O
}	O
f	O
;	O
struct	O
{	O
const	O
char	O
*	O
physname	O
;	O
}	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
u	union(long,*(struct))
;	O
}	O
;	O
struct	O
debug_baseclass_s	O
{	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
;	O
unsigned	O
int	O
bitpos	int
;	O
bfd_boolean	int
is_virtual	O
;	O
enum	O
debug_visibility	O
visibility	O
;	O
}	O
;	O
struct	O
debug_method_s	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
debug_method_variant_s	O
*	O
*	O
variants	O
;	O
}	O
;	O
struct	O
debug_method_variant_s	O
{	O
const	O
char	O
*	O
physname	O
;	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
;	O
enum	O
debug_visibility	O
visibility	O
;	O
bfd_boolean	int
constp	O
;	O
bfd_boolean	int
volatilep	O
;	O
bfd_vma	long
voffset	O
;	O
struct	O
debug_type_s	O
*	O
context	O
;	O
}	O
;	O
struct	O
debug_variable	O
{	O
enum	O
debug_var_kind	O
kind	O
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_vma	long
val	array(int)
;	O
}	O
;	O
struct	O
debug_function	O
{	O
debug_type	O
return_type	O
;	O
struct	O
debug_parameter	O
*	O
parameters	O
;	O
struct	O
debug_block	O
*	O
blocks	O
;	O
}	O
;	O
struct	O
debug_parameter	O
{	O
struct	O
debug_parameter	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
name	*(char)
;	O
debug_type	O
type	enum(int,int,int,int)
;	O
enum	O
debug_parm_kind	O
kind	O
;	O
bfd_vma	long
val	array(int)
;	O
}	O
;	O
struct	O
debug_typed_constant	O
{	O
debug_type	O
type	enum(int,int,int,int)
;	O
bfd_vma	long
val	array(int)
;	O
}	O
;	O
struct	O
debug_block	O
{	O
struct	O
debug_block	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_block	O
*	O
parent	O
;	O
struct	O
debug_block	O
*	O
children	O
;	O
bfd_vma	long
start	O
;	O
bfd_vma	long
end	*(*(char))
;	O
struct	O
debug_namespace	O
*	O
locals	O
;	O
}	O
;	O
struct	O
debug_lineno	O
{	O
struct	O
debug_lineno	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_file	O
*	O
file	*(void)
;	O
unsigned	O
long	O
linenos	O
[	O
DEBUG_LINENO_COUNT	O
]	O
;	O
bfd_vma	long
addrs	O
[	O
DEBUG_LINENO_COUNT	O
]	O
;	O
}	O
;	O
struct	O
debug_namespace	O
{	O
struct	O
debug_name	O
*	O
list	O
;	O
struct	O
debug_name	O
*	O
*	O
tail	O
;	O
}	O
;	O
enum	O
debug_object_kind	O
{	O
DEBUG_OBJECT_TYPE	O
,	O
DEBUG_OBJECT_TAG	O
,	O
DEBUG_OBJECT_VARIABLE	O
,	O
DEBUG_OBJECT_FUNCTION	O
,	O
DEBUG_OBJECT_INT_CONSTANT	O
,	O
DEBUG_OBJECT_FLOAT_CONSTANT	O
,	O
DEBUG_OBJECT_TYPED_CONSTANT	O
}	O
;	O
enum	O
debug_object_linkage	O
{	O
DEBUG_LINKAGE_AUTOMATIC	O
,	O
DEBUG_LINKAGE_STATIC	O
,	O
DEBUG_LINKAGE_GLOBAL	O
,	O
DEBUG_LINKAGE_NONE	O
}	O
;	O
struct	O
debug_name	O
{	O
struct	O
debug_name	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
int	O
mark	O
;	O
enum	O
debug_object_kind	O
kind	O
;	O
enum	O
debug_object_linkage	O
linkage	O
;	O
union	O
{	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
;	O
struct	O
debug_type_s	O
*	O
tag	O
;	O
struct	O
debug_variable	O
*	O
variable	O
;	O
struct	O
debug_function	O
*	O
function	O
;	O
bfd_vma	long
int_constant	O
;	O
double	O
float_constant	O
;	O
struct	O
debug_typed_constant	O
*	O
typed_constant	O
;	O
}	O
u	union(long,*(struct))
;	O
}	O
;	O
struct	O
debug_class_id	O
{	O
struct	O
debug_class_id	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
tag	O
;	O
}	O
;	O
struct	O
debug_type_compare_list	O
{	O
struct	O
debug_type_compare_list	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_type_s	O
*	O
t1	O
;	O
struct	O
debug_type_s	O
*	O
t2	O
;	O
}	O
;	O
struct	O
debug_type_real_list	O
{	O
struct	O
debug_type_real_list	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
}	O
;	O
static	O
void	O
debug_error	O
(	O
const	O
char	O
*	O
)	O
;	O
static	O
struct	O
debug_name	O
*	O
debug_add_to_namespace	O
(	O
struct	O
debug_handle	O
*	O
,	O
struct	O
debug_namespace	O
*	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_kind	O
,	O
enum	O
debug_object_linkage	O
)	O
;	O
static	O
struct	O
debug_name	O
*	O
debug_add_to_current_namespace	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_kind	O
,	O
enum	O
debug_object_linkage	O
)	O
;	O
static	O
struct	O
debug_type_s	O
*	O
debug_make_type	O
(	O
struct	O
debug_handle	O
*	O
,	O
enum	O
debug_type_kind	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
struct	O
debug_type_s	O
*	O
debug_get_real_type	O
(	O
void	O
*	O
,	O
debug_type	O
,	O
struct	O
debug_type_real_list	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_name	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
struct	O
debug_name	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_type	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
struct	O
debug_type_s	O
*	O
,	O
struct	O
debug_name	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_class_type	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
struct	O
debug_type_s	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_function	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_linkage	O
,	O
struct	O
debug_function	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_block	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
struct	O
debug_block	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_linenos	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
,	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
debug_set_class_id	O
(	O
struct	O
debug_handle	O
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
debug_type_s	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_type_samep	O
(	O
struct	O
debug_handle	O
*	O
,	O
struct	O
debug_type_s	O
*	O
,	O
struct	O
debug_type_s	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_class_type_samep	O
(	O
struct	O
debug_handle	O
*	O
,	O
struct	O
debug_type_s	O
*	O
,	O
struct	O
debug_type_s	O
*	O
)	O
;	O
static	O
void	O
debug_error	O
(	O
const	O
char	O
*	O
message	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
message	*(char)
)	O
;	O
}	O
static	O
struct	O
debug_name	O
*	O
debug_add_to_namespace	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
ATTRIBUTE_UNUSED	O
,	O
struct	O
debug_namespace	O
*	O
*	O
nsp	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_object_kind	O
kind	O
,	O
enum	O
debug_object_linkage	O
linkage	O
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
struct	O
debug_namespace	O
*	O
ns	O
;	O
n	O
=	O
(	O
struct	O
debug_name	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
n	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
n	O
,	O
0	int
,	O
sizeof	O
*	O
n	O
)	O
;	O
n	O
->	O
name	*(char)
=	O
name	*(char)
;	O
n	O
->	O
kind	O
=	O
kind	O
;	O
n	O
->	O
linkage	O
=	O
linkage	O
;	O
ns	O
=	O
*	O
nsp	O
;	O
if	O
(	O
ns	O
==	O
NULL	O
)	O
{	O
ns	O
=	O
(	O
struct	O
debug_namespace	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
ns	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ns	O
,	O
0	int
,	O
sizeof	O
*	O
ns	O
)	O
;	O
ns	O
->	O
tail	O
=	O
&	O
ns	O
->	O
list	O
;	O
*	O
nsp	O
=	O
ns	O
;	O
}	O
*	O
ns	O
->	O
tail	O
=	O
n	O
;	O
ns	O
->	O
tail	O
=	O
&	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
return	O
n	O
;	O
}	O
static	O
struct	O
debug_name	O
*	O
debug_add_to_current_namespace	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_object_kind	O
kind	O
,	O
enum	O
debug_object_linkage	O
linkage	O
)	O
{	O
struct	O
debug_namespace	O
*	O
*	O
nsp	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_file	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_add_to_current_namespace: no current file"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
current_block	O
!=	O
NULL	O
)	O
nsp	O
=	O
&	O
info	*(void)
->	O
current_block	O
->	O
locals	O
;	O
else	O
nsp	O
=	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
;	O
return	O
debug_add_to_namespace	O
(	O
info	*(void)
,	O
nsp	O
,	O
name	*(char)
,	O
kind	O
,	O
linkage	O
)	O
;	O
}	O
void	O
*	O
debug_init	O
(	O
void	O
)	O
{	O
struct	O
debug_handle	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
,	O
0	int
,	O
sizeof	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
;	O
return	O
(	O
void	O
*	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
bfd_boolean	int
debug_set_filename	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_file	O
*	O
nfile	O
;	O
struct	O
debug_unit	O
*	O
nunit	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
""	*(char)
;	O
nfile	O
=	O
(	O
struct	O
debug_file	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
nfile	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
nfile	O
,	O
0	int
,	O
sizeof	O
*	O
nfile	O
)	O
;	O
nfile	O
->	O
filename	*(char)
=	O
name	*(char)
;	O
nunit	O
=	O
(	O
struct	O
debug_unit	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
nunit	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
nunit	O
,	O
0	int
,	O
sizeof	O
*	O
nunit	O
)	O
;	O
nunit	O
->	O
files	O
=	O
nfile	O
;	O
info	*(void)
->	O
current_file	O
=	O
nfile	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
!=	O
NULL	O
)	O
info	*(void)
->	O
current_unit	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
nunit	O
;	O
else	O
{	O
assert	O
(	O
info	*(void)
->	O
units	O
==	O
NULL	O
)	O
;	O
info	*(void)
->	O
units	O
=	O
nunit	O
;	O
}	O
info	*(void)
->	O
current_unit	O
=	O
nunit	O
;	O
info	*(void)
->	O
current_function	O
=	O
NULL	O
;	O
info	*(void)
->	O
current_block	O
=	O
NULL	O
;	O
info	*(void)
->	O
current_lineno	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_source	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_file	O
*	O
f	O
,	O
*	O
*	O
pf	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
""	*(char)
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_start_source: no debug_set_filename call"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
f	O
=	O
info	*(void)
->	O
current_unit	O
->	O
files	O
;	O
f	O
!=	O
NULL	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
filename_cmp	O
(	O
f	O
->	O
filename	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
info	*(void)
->	O
current_file	O
=	O
f	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
f	O
=	O
(	O
struct	O
debug_file	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
f	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	O
,	O
0	int
,	O
sizeof	O
*	O
f	O
)	O
;	O
f	O
->	O
filename	*(char)
=	O
name	*(char)
;	O
for	O
(	O
pf	O
=	O
&	O
info	*(void)
->	O
current_file	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
*	O
pf	O
!=	O
NULL	O
;	O
pf	O
=	O
&	O
(	O
*	O
pf	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
;	O
*	O
pf	O
=	O
f	O
;	O
info	*(void)
->	O
current_file	O
=	O
f	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_function	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
return_type	O
,	O
bfd_boolean	int
global	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_function	O
*	O
f	O
;	O
struct	O
debug_block	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
struct	O
debug_name	O
*	O
n	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
""	*(char)
;	O
if	O
(	O
return_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_record_function: no debug_set_filename call"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
f	O
=	O
(	O
struct	O
debug_function	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
f	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	O
,	O
0	int
,	O
sizeof	O
*	O
f	O
)	O
;	O
f	O
->	O
return_type	O
=	O
return_type	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
(	O
struct	O
debug_block	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
0	int
,	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
=	O
addr	*(void)
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
end	*(*(char))
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
f	O
->	O
blocks	O
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
info	*(void)
->	O
current_function	O
=	O
f	O
;	O
info	*(void)
->	O
current_block	O
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
n	O
=	O
debug_add_to_namespace	O
(	O
info	*(void)
,	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
,	O
name	*(char)
,	O
DEBUG_OBJECT_FUNCTION	O
,	O
(	O
global	O
?	O
DEBUG_LINKAGE_GLOBAL	O
:	O
DEBUG_LINKAGE_STATIC	O
)	O
)	O
;	O
if	O
(	O
n	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
->	O
u	union(long,*(struct))
.	O
function	O
=	O
f	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_parameter	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
enum	O
debug_parm_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_parameter	O
*	O
p	*(void)
,	O
*	O
*	O
pp	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_function	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_record_parameter: no current function"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
p	*(void)
=	O
(	O
struct	O
debug_parameter	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
p	*(void)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
0	int
,	O
sizeof	O
*	O
p	*(void)
)	O
;	O
p	*(void)
->	O
name	*(char)
=	O
name	*(char)
;	O
p	*(void)
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
p	*(void)
->	O
kind	O
=	O
kind	O
;	O
p	*(void)
->	O
val	array(int)
=	O
val	array(int)
;	O
for	O
(	O
pp	O
=	O
&	O
info	*(void)
->	O
current_function	O
->	O
parameters	O
;	O
*	O
pp	O
!=	O
NULL	O
;	O
pp	O
=	O
&	O
(	O
*	O
pp	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
;	O
*	O
pp	O
=	O
p	*(void)
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_end_function	O
(	O
void	O
*	O
handle	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_block	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_function	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_end_function: no current function"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
current_block	O
->	O
parent	O
!=	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_end_function: some blocks were not closed"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
info	*(void)
->	O
current_block	O
->	O
end	*(*(char))
=	O
addr	*(void)
;	O
info	*(void)
->	O
current_function	O
=	O
NULL	O
;	O
info	*(void)
->	O
current_block	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_block	O
(	O
void	O
*	O
handle	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_block	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
*	O
*	O
pb	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_block	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_start_block: no current block"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
(	O
struct	O
debug_block	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
0	int
,	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
parent	O
=	O
info	*(void)
->	O
current_block	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
=	O
addr	*(void)
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
end	*(*(char))
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
for	O
(	O
pb	O
=	O
&	O
info	*(void)
->	O
current_block	O
->	O
children	O
;	O
*	O
pb	O
!=	O
NULL	O
;	O
pb	O
=	O
&	O
(	O
*	O
pb	O
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
;	O
*	O
pb	O
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
info	*(void)
->	O
current_block	O
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_end_block	O
(	O
void	O
*	O
handle	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_block	O
*	O
parent	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_block	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_end_block: no current block"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
parent	O
=	O
info	*(void)
->	O
current_block	O
->	O
parent	O
;	O
if	O
(	O
parent	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_end_block: attempt to close top level block"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
info	*(void)
->	O
current_block	O
->	O
end	*(*(char))
=	O
addr	*(void)
;	O
info	*(void)
->	O
current_block	O
=	O
parent	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_line	O
(	O
void	O
*	O
handle	O
,	O
unsigned	O
long	O
lineno	*(struct(int,union(*(struct),long)))
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_lineno	O
*	O
l	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_record_line: no current unit"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
l	O
=	O
info	*(void)
->	O
current_lineno	O
;	O
if	O
(	O
l	O
!=	O
NULL	O
&&	O
l	O
->	O
file	*(void)
==	O
info	*(void)
->	O
current_file	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
DEBUG_LINENO_COUNT	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
l	O
->	O
linenos	O
[	O
i	*(struct)
]	O
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
{	O
l	O
->	O
linenos	O
[	O
i	*(struct)
]	O
=	O
lineno	*(struct(int,union(*(struct),long)))
;	O
l	O
->	O
addrs	O
[	O
i	*(struct)
]	O
=	O
addr	*(void)
;	O
return	O
TRUE	int
;	O
}	O
}	O
}	O
l	O
=	O
(	O
struct	O
debug_lineno	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
l	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
l	O
,	O
0	int
,	O
sizeof	O
*	O
l	O
)	O
;	O
l	O
->	O
file	*(void)
=	O
info	*(void)
->	O
current_file	O
;	O
l	O
->	O
linenos	O
[	O
0	int
]	O
=	O
lineno	*(struct(int,union(*(struct),long)))
;	O
l	O
->	O
addrs	O
[	O
0	int
]	O
=	O
addr	*(void)
;	O
for	O
(	O
i	*(struct)
=	O
1	int
;	O
i	*(struct)
<	O
DEBUG_LINENO_COUNT	O
;	O
i	*(struct)
++	O
)	O
l	O
->	O
linenos	O
[	O
i	*(struct)
]	O
=	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
;	O
if	O
(	O
info	*(void)
->	O
current_lineno	O
!=	O
NULL	O
)	O
info	*(void)
->	O
current_lineno	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
l	O
;	O
else	O
info	*(void)
->	O
current_unit	O
->	O
linenos	O
=	O
l	O
;	O
info	*(void)
->	O
current_lineno	O
=	O
l	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_common_block	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_start_common_block: not implemented"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
bfd_boolean	int
debug_end_common_block	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_end_common_block: not implemented"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
bfd_boolean	int
debug_record_int_const	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_name	O
*	O
n	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
=	O
debug_add_to_current_namespace	O
(	O
info	*(void)
,	O
name	*(char)
,	O
DEBUG_OBJECT_INT_CONSTANT	O
,	O
DEBUG_LINKAGE_NONE	O
)	O
;	O
if	O
(	O
n	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
->	O
u	union(long,*(struct))
.	O
int_constant	O
=	O
val	array(int)
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_float_const	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
double	O
val	array(int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_name	O
*	O
n	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
=	O
debug_add_to_current_namespace	O
(	O
info	*(void)
,	O
name	*(char)
,	O
DEBUG_OBJECT_FLOAT_CONSTANT	O
,	O
DEBUG_LINKAGE_NONE	O
)	O
;	O
if	O
(	O
n	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
->	O
u	union(long,*(struct))
.	O
float_constant	O
=	O
val	array(int)
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_typed_const	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_name	O
*	O
n	O
;	O
struct	O
debug_typed_constant	O
*	O
tc	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
=	O
debug_add_to_current_namespace	O
(	O
info	*(void)
,	O
name	*(char)
,	O
DEBUG_OBJECT_TYPED_CONSTANT	O
,	O
DEBUG_LINKAGE_NONE	O
)	O
;	O
if	O
(	O
n	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
tc	O
=	O
(	O
struct	O
debug_typed_constant	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
tc	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
tc	O
,	O
0	int
,	O
sizeof	O
*	O
tc	O
)	O
;	O
tc	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
tc	O
->	O
val	array(int)
=	O
val	array(int)
;	O
n	O
->	O
u	union(long,*(struct))
.	O
typed_constant	O
=	O
tc	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_label	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
,	O
debug_type	O
type	enum(int,int,int,int)
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
addr	*(void)
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_record_label: not implemented"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
bfd_boolean	int
debug_record_variable	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
enum	O
debug_var_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_namespace	O
*	O
*	O
nsp	O
;	O
enum	O
debug_object_linkage	O
linkage	O
;	O
struct	O
debug_name	O
*	O
n	O
;	O
struct	O
debug_variable	O
*	O
v	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_file	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_record_variable: no current file"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
kind	O
==	O
DEBUG_GLOBAL	O
||	O
kind	O
==	O
DEBUG_STATIC	O
)	O
{	O
nsp	O
=	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_GLOBAL	O
)	O
linkage	O
=	O
DEBUG_LINKAGE_GLOBAL	O
;	O
else	O
linkage	O
=	O
DEBUG_LINKAGE_STATIC	O
;	O
}	O
else	O
{	O
if	O
(	O
info	*(void)
->	O
current_block	O
==	O
NULL	O
)	O
nsp	O
=	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
;	O
else	O
nsp	O
=	O
&	O
info	*(void)
->	O
current_block	O
->	O
locals	O
;	O
linkage	O
=	O
DEBUG_LINKAGE_AUTOMATIC	O
;	O
}	O
n	O
=	O
debug_add_to_namespace	O
(	O
info	*(void)
,	O
nsp	O
,	O
name	*(char)
,	O
DEBUG_OBJECT_VARIABLE	O
,	O
linkage	O
)	O
;	O
if	O
(	O
n	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
v	O
=	O
(	O
struct	O
debug_variable	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
v	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
v	O
,	O
0	int
,	O
sizeof	O
*	O
v	O
)	O
;	O
v	O
->	O
kind	O
=	O
kind	O
;	O
v	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
v	O
->	O
val	array(int)
=	O
val	array(int)
;	O
n	O
->	O
u	union(long,*(struct))
.	O
variable	O
=	O
v	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
struct	O
debug_type_s	O
*	O
debug_make_type	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_type_kind	O
kind	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_type_s	O
*	O
t	O
;	O
t	O
=	O
(	O
struct	O
debug_type_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
t	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
t	O
,	O
0	int
,	O
sizeof	O
*	O
t	O
)	O
;	O
t	O
->	O
kind	O
=	O
kind	O
;	O
t	O
->	O
size	int
=	O
size	int
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_indirect_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
*	O
slot	O
,	O
const	O
char	O
*	O
tag	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_indirect_type	O
*	O
i	*(struct)
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_INDIRECT	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
i	*(struct)
=	O
(	O
struct	O
debug_indirect_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
i	*(struct)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
i	*(struct)
,	O
0	int
,	O
sizeof	O
*	O
i	*(struct)
)	O
;	O
i	*(struct)
->	O
slot	O
=	O
slot	O
;	O
i	*(struct)
->	O
tag	O
=	O
tag	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kindirect	O
=	O
i	*(struct)
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_void_type	O
(	O
void	O
*	O
handle	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
return	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_VOID	O
,	O
0	int
)	O
;	O
}	O
debug_type	O
debug_make_int_type	O
(	O
void	O
*	O
handle	O
,	O
unsigned	O
int	O
size	int
,	O
bfd_boolean	int
unsignedp	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_INT	O
,	O
size	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kint	O
=	O
unsignedp	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_float_type	O
(	O
void	O
*	O
handle	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
return	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_FLOAT	O
,	O
size	int
)	O
;	O
}	O
debug_type	O
debug_make_bool_type	O
(	O
void	O
*	O
handle	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
return	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_BOOL	O
,	O
size	int
)	O
;	O
}	O
debug_type	O
debug_make_complex_type	O
(	O
void	O
*	O
handle	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
return	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_COMPLEX	O
,	O
size	int
)	O
;	O
}	O
debug_type	O
debug_make_struct_type	O
(	O
void	O
*	O
handle	O
,	O
bfd_boolean	int
structp	O
,	O
bfd_vma	long
size	int
,	O
debug_field	O
*	O
fields	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_class_type	O
*	O
c	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
structp	O
?	O
DEBUG_KIND_STRUCT	O
:	O
DEBUG_KIND_UNION	O
,	O
size	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
c	O
=	O
(	O
struct	O
debug_class_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
c	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
c	O
,	O
0	int
,	O
sizeof	O
*	O
c	O
)	O
;	O
c	O
->	O
fields	O
=	O
fields	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kclass	O
=	O
c	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_object_type	O
(	O
void	O
*	O
handle	O
,	O
bfd_boolean	int
structp	O
,	O
bfd_vma	long
size	int
,	O
debug_field	O
*	O
fields	O
,	O
debug_baseclass	O
*	O
baseclasses	O
,	O
debug_method	O
*	O
methods	O
,	O
debug_type	O
vptrbase	O
,	O
bfd_boolean	int
ownvptr	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_class_type	O
*	O
c	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
structp	O
?	O
DEBUG_KIND_CLASS	O
:	O
DEBUG_KIND_UNION_CLASS	O
,	O
size	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
c	O
=	O
(	O
struct	O
debug_class_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
c	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
c	O
,	O
0	int
,	O
sizeof	O
*	O
c	O
)	O
;	O
c	O
->	O
fields	O
=	O
fields	O
;	O
c	O
->	O
baseclasses	O
=	O
baseclasses	O
;	O
c	O
->	O
methods	O
=	O
methods	O
;	O
if	O
(	O
ownvptr	O
)	O
c	O
->	O
vptrbase	O
=	O
t	O
;	O
else	O
c	O
->	O
vptrbase	O
=	O
vptrbase	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kclass	O
=	O
c	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_enum_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
*	O
names	O
,	O
bfd_signed_vma	long
*	O
values	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_enum_type	O
*	O
e	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_ENUM	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
e	O
=	O
(	O
struct	O
debug_enum_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
e	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
e	O
,	O
0	int
,	O
sizeof	O
*	O
e	O
)	O
;	O
e	O
->	O
names	O
=	O
names	O
;	O
e	O
->	O
values	O
=	O
values	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kenum	O
=	O
e	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_pointer_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
pointer	O
!=	O
DEBUG_TYPE_NULL	O
)	O
return	O
type	enum(int,int,int,int)
->	O
pointer	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_POINTER	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kpointer	O
=	O
type	enum(int,int,int,int)
;	O
type	enum(int,int,int,int)
->	O
pointer	O
=	O
t	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_function_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
debug_type	O
*	O
arg_types	O
,	O
bfd_boolean	int
varargs	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_function_type	O
*	O
f	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_FUNCTION	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
f	O
=	O
(	O
struct	O
debug_function_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
f	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	O
,	O
0	int
,	O
sizeof	O
*	O
f	O
)	O
;	O
f	O
->	O
return_type	O
=	O
type	enum(int,int,int,int)
;	O
f	O
->	O
arg_types	O
=	O
arg_types	O
;	O
f	O
->	O
varargs	O
=	O
varargs	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
=	O
f	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_reference_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_REFERENCE	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kreference	O
=	O
type	enum(int,int,int,int)
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_range_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_signed_vma	long
lower	O
,	O
bfd_signed_vma	long
upper	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_range_type	O
*	O
r	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_RANGE	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
r	O
=	O
(	O
struct	O
debug_range_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
r	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
r	O
,	O
0	int
,	O
sizeof	O
*	O
r	O
)	O
;	O
r	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
r	O
->	O
lower	O
=	O
lower	O
;	O
r	O
->	O
upper	O
=	O
upper	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
krange	O
=	O
r	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_array_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
element_type	O
,	O
debug_type	O
range_type	O
,	O
bfd_signed_vma	long
lower	O
,	O
bfd_signed_vma	long
upper	O
,	O
bfd_boolean	int
stringp	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_array_type	O
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
element_type	O
==	O
NULL	O
||	O
range_type	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_ARRAY	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
(	O
struct	O
debug_array_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
0	int
,	O
sizeof	O
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
element_type	O
=	O
element_type	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
range_type	O
=	O
range_type	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
lower	O
=	O
lower	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
upper	O
=	O
upper	O
;	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
stringp	O
=	O
stringp	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
karray	O
=	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_set_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_boolean	int
bitstringp	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_set_type	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_SET	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
(	O
struct	O
debug_set_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
0	int
,	O
sizeof	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
->	O
bitstringp	O
=	O
bitstringp	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kset	O
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_offset_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
base_type	O
,	O
debug_type	O
target_type	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_offset_type	O
*	O
o	O
;	O
if	O
(	O
base_type	O
==	O
NULL	O
||	O
target_type	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_OFFSET	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
o	O
=	O
(	O
struct	O
debug_offset_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
o	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
o	O
,	O
0	int
,	O
sizeof	O
*	O
o	O
)	O
;	O
o	O
->	O
base_type	O
=	O
base_type	O
;	O
o	O
->	O
target_type	O
=	O
target_type	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
koffset	O
=	O
o	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_method_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
return_type	O
,	O
debug_type	O
domain_type	O
,	O
debug_type	O
*	O
arg_types	O
,	O
bfd_boolean	int
varargs	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_method_type	O
*	O
m	O
;	O
if	O
(	O
return_type	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_METHOD	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
m	O
=	O
(	O
struct	O
debug_method_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
m	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
m	O
,	O
0	int
,	O
sizeof	O
*	O
m	O
)	O
;	O
m	O
->	O
return_type	O
=	O
return_type	O
;	O
m	O
->	O
domain_type	O
=	O
domain_type	O
;	O
m	O
->	O
arg_types	O
=	O
arg_types	O
;	O
m	O
->	O
varargs	O
=	O
varargs	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
=	O
m	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_const_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_CONST	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kconst	O
=	O
type	enum(int,int,int,int)
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_volatile_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_VOLATILE	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	O
->	O
u	union(long,*(struct))
.	O
kvolatile	O
=	O
type	enum(int,int,int,int)
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_make_undefined_tagged_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_type_kind	O
kind	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
DEBUG_KIND_STRUCT	O
:	O
case	O
DEBUG_KIND_UNION	O
:	O
case	O
DEBUG_KIND_CLASS	O
:	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
case	O
DEBUG_KIND_ENUM	O
:	O
break	O
;	O
default	O
:	O
debug_error	O
(	O
_	O
(	O
"debug_make_undefined_type: unsupported kind"	*(char)
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
kind	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
return	O
debug_tag_type	O
(	O
handle	O
,	O
name	*(char)
,	O
t	O
)	O
;	O
}	O
debug_baseclass	O
debug_make_baseclass	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_vma	long
bitpos	int
,	O
bfd_boolean	int
is_virtual	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
debug_baseclass_s	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
(	O
struct	O
debug_baseclass_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
0	int
,	O
sizeof	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
bitpos	int
=	O
bitpos	int
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
is_virtual	O
=	O
is_virtual	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
visibility	O
=	O
visibility	O
;	O
return	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
debug_field	O
debug_make_field	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_vma	long
bitpos	int
,	O
bfd_vma	long
bitsize	int
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
debug_field_s	O
*	O
f	O
;	O
f	O
=	O
(	O
struct	O
debug_field_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
f	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	O
,	O
0	int
,	O
sizeof	O
*	O
f	O
)	O
;	O
f	O
->	O
name	*(char)
=	O
name	*(char)
;	O
f	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
f	O
->	O
static_member	O
=	O
FALSE	O
;	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
=	O
bitpos	int
;	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
=	O
bitsize	int
;	O
f	O
->	O
visibility	O
=	O
visibility	O
;	O
return	O
f	O
;	O
}	O
debug_field	O
debug_make_static_member	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
physname	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
debug_field_s	O
*	O
f	O
;	O
f	O
=	O
(	O
struct	O
debug_field_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
f	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
f	O
,	O
0	int
,	O
sizeof	O
*	O
f	O
)	O
;	O
f	O
->	O
name	*(char)
=	O
name	*(char)
;	O
f	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
f	O
->	O
static_member	O
=	O
TRUE	int
;	O
f	O
->	O
u	union(long,*(struct))
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
physname	O
=	O
physname	O
;	O
f	O
->	O
visibility	O
=	O
visibility	O
;	O
return	O
f	O
;	O
}	O
debug_method	O
debug_make_method	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_method_variant	O
*	O
variants	O
)	O
{	O
struct	O
debug_method_s	O
*	O
m	O
;	O
m	O
=	O
(	O
struct	O
debug_method_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
m	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
m	O
,	O
0	int
,	O
sizeof	O
*	O
m	O
)	O
;	O
m	O
->	O
name	*(char)
=	O
name	*(char)
;	O
m	O
->	O
variants	O
=	O
variants	O
;	O
return	O
m	O
;	O
}	O
debug_method_variant	O
debug_make_method_variant	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
physname	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
,	O
bfd_vma	long
voffset	O
,	O
debug_type	O
context	O
)	O
{	O
struct	O
debug_method_variant_s	O
*	O
m	O
;	O
m	O
=	O
(	O
struct	O
debug_method_variant_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
m	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
m	O
,	O
0	int
,	O
sizeof	O
*	O
m	O
)	O
;	O
m	O
->	O
physname	O
=	O
physname	O
;	O
m	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
m	O
->	O
visibility	O
=	O
visibility	O
;	O
m	O
->	O
constp	O
=	O
constp	O
;	O
m	O
->	O
volatilep	O
=	O
volatilep	O
;	O
m	O
->	O
voffset	O
=	O
voffset	O
;	O
m	O
->	O
context	O
=	O
context	O
;	O
return	O
m	O
;	O
}	O
debug_method_variant	O
debug_make_static_method_variant	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
physname	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
)	O
{	O
struct	O
debug_method_variant_s	O
*	O
m	O
;	O
m	O
=	O
(	O
struct	O
debug_method_variant_s	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
m	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
m	O
,	O
0	int
,	O
sizeof	O
*	O
m	O
)	O
;	O
m	O
->	O
physname	O
=	O
physname	O
;	O
m	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
m	O
->	O
visibility	O
=	O
visibility	O
;	O
m	O
->	O
constp	O
=	O
constp	O
;	O
m	O
->	O
volatilep	O
=	O
volatilep	O
;	O
m	O
->	O
voffset	O
=	O
VOFFSET_STATIC_METHOD	O
;	O
return	O
m	O
;	O
}	O
debug_type	O
debug_name_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_named_type	O
*	O
n	O
;	O
struct	O
debug_name	O
*	O
nm	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
||	O
info	*(void)
->	O
current_file	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_name_type: no current file"	*(char)
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_NAMED	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
n	O
=	O
(	O
struct	O
debug_named_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
n	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
n	O
,	O
0	int
,	O
sizeof	O
*	O
n	O
)	O
;	O
n	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
t	O
->	O
u	union(long,*(struct))
.	O
knamed	O
=	O
n	O
;	O
nm	O
=	O
debug_add_to_namespace	O
(	O
info	*(void)
,	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
,	O
name	*(char)
,	O
DEBUG_OBJECT_TYPE	O
,	O
DEBUG_LINKAGE_NONE	O
)	O
;	O
if	O
(	O
nm	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
nm	O
->	O
u	union(long,*(struct))
.	O
type	enum(int,int,int,int)
=	O
t	O
;	O
n	O
->	O
name	*(char)
=	O
nm	O
;	O
return	O
t	O
;	O
}	O
debug_type	O
debug_tag_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_type_s	O
*	O
t	O
;	O
struct	O
debug_named_type	O
*	O
n	O
;	O
struct	O
debug_name	O
*	O
nm	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
info	*(void)
->	O
current_file	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_tag_type: no current file"	*(char)
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
type	enum(int,int,int,int)
;	O
debug_error	O
(	O
_	O
(	O
"debug_tag_type: extra tag attempted"	*(char)
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	O
=	O
debug_make_type	O
(	O
info	*(void)
,	O
DEBUG_KIND_TAGGED	O
,	O
0	int
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
n	O
=	O
(	O
struct	O
debug_named_type	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
n	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
n	O
,	O
0	int
,	O
sizeof	O
*	O
n	O
)	O
;	O
n	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
t	O
->	O
u	union(long,*(struct))
.	O
knamed	O
=	O
n	O
;	O
nm	O
=	O
debug_add_to_namespace	O
(	O
info	*(void)
,	O
&	O
info	*(void)
->	O
current_file	O
->	O
globals	O
,	O
name	*(char)
,	O
DEBUG_OBJECT_TAG	O
,	O
DEBUG_LINKAGE_NONE	O
)	O
;	O
if	O
(	O
nm	O
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
nm	O
->	O
u	union(long,*(struct))
.	O
tag	O
=	O
t	O
;	O
n	O
->	O
name	*(char)
=	O
nm	O
;	O
return	O
t	O
;	O
}	O
bfd_boolean	int
debug_record_type_size	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
unsigned	O
int	O
size	int
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
size	int
!=	O
0	int
&&	O
type	enum(int,int,int,int)
->	O
size	int
!=	O
size	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Warning: changing type size from %d to %d\n"	*(char)
)	O
,	O
type	enum(int,int,int,int)
->	O
size	int
,	O
size	int
)	O
;	O
type	enum(int,int,int,int)
->	O
size	int
=	O
size	int
;	O
return	O
TRUE	int
;	O
}	O
debug_type	O
debug_find_named_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_block	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
struct	O
debug_file	O
*	O
f	O
;	O
if	O
(	O
info	*(void)
->	O
current_unit	O
==	O
NULL	O
)	O
{	O
debug_error	O
(	O
_	O
(	O
"debug_find_named_type: no current compilation unit"	*(char)
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
for	O
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
info	*(void)
->	O
current_block	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
parent	O
)	O
{	O
if	O
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
locals	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
for	O
(	O
n	O
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
locals	O
->	O
list	O
;	O
n	O
!=	O
NULL	O
;	O
n	O
=	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
n	O
->	O
kind	O
==	O
DEBUG_OBJECT_TYPE	O
&&	O
n	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
name	*(char)
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
n	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
n	O
->	O
u	union(long,*(struct))
.	O
type	enum(int,int,int,int)
;	O
}	O
}	O
}	O
for	O
(	O
f	O
=	O
info	*(void)
->	O
current_unit	O
->	O
files	O
;	O
f	O
!=	O
NULL	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
f	O
->	O
globals	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
for	O
(	O
n	O
=	O
f	O
->	O
globals	O
->	O
list	O
;	O
n	O
!=	O
NULL	O
;	O
n	O
=	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
n	O
->	O
kind	O
==	O
DEBUG_OBJECT_TYPE	O
&&	O
n	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
name	*(char)
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
n	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
n	O
->	O
u	union(long,*(struct))
.	O
type	enum(int,int,int,int)
;	O
}	O
}	O
}	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
debug_type	O
debug_find_tagged_type	O
(	O
void	O
*	O
handle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_type_kind	O
kind	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_unit	O
*	O
u	union(long,*(struct))
;	O
for	O
(	O
u	union(long,*(struct))
=	O
info	*(void)
->	O
units	O
;	O
u	union(long,*(struct))
!=	O
NULL	O
;	O
u	union(long,*(struct))
=	O
u	union(long,*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
struct	O
debug_file	O
*	O
f	O
;	O
for	O
(	O
f	O
=	O
u	union(long,*(struct))
->	O
files	O
;	O
f	O
!=	O
NULL	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
if	O
(	O
f	O
->	O
globals	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
n	O
=	O
f	O
->	O
globals	O
->	O
list	O
;	O
n	O
!=	O
NULL	O
;	O
n	O
=	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
n	O
->	O
kind	O
==	O
DEBUG_OBJECT_TAG	O
&&	O
(	O
kind	O
==	O
DEBUG_KIND_ILLEGAL	O
||	O
n	O
->	O
u	union(long,*(struct))
.	O
tag	O
->	O
kind	O
==	O
kind	O
)	O
&&	O
n	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
name	*(char)
[	O
0	int
]	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
n	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
n	O
->	O
u	union(long,*(struct))
.	O
tag	O
;	O
}	O
}	O
}	O
}	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
static	O
struct	O
debug_type_s	O
*	O
debug_get_real_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
struct	O
debug_type_real_list	O
*	O
list	O
)	O
{	O
struct	O
debug_type_real_list	O
*	O
l	O
;	O
struct	O
debug_type_real_list	O
rl	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
type	enum(int,int,int,int)
;	O
case	O
DEBUG_KIND_INDIRECT	O
:	O
case	O
DEBUG_KIND_NAMED	O
:	O
case	O
DEBUG_KIND_TAGGED	O
:	O
break	O
;	O
}	O
for	O
(	O
l	O
=	O
list	O
;	O
l	O
!=	O
NULL	O
;	O
l	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
l	O
->	O
t	O
==	O
type	enum(int,int,int,int)
||	O
l	O
==	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"debug_get_real_type: circular debug information for %s\n"	*(char)
)	O
,	O
debug_get_type_name	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
rl	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
list	O
;	O
rl	O
.	O
t	O
=	O
type	enum(int,int,int,int)
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
case	O
DEBUG_KIND_INDIRECT	O
:	O
if	O
(	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
!=	O
NULL	O
)	O
return	O
debug_get_real_type	O
(	O
handle	O
,	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
,	O
&	O
rl	O
)	O
;	O
return	O
type	enum(int,int,int,int)
;	O
case	O
DEBUG_KIND_NAMED	O
:	O
case	O
DEBUG_KIND_TAGGED	O
:	O
return	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
,	O
&	O
rl	O
)	O
;	O
}	O
}	O
enum	O
debug_type_kind	O
debug_get_type_kind	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_KIND_ILLEGAL	O
;	O
type	enum(int,int,int,int)
=	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_KIND_ILLEGAL	O
;	O
return	O
type	enum(int,int,int,int)
->	O
kind	O
;	O
}	O
const	O
char	O
*	O
debug_get_type_name	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_INDIRECT	O
)	O
{	O
if	O
(	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
!=	O
NULL	O
)	O
return	O
debug_get_type_name	O
(	O
handle	O
,	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
)	O
;	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
tag	O
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_NAMED	O
||	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
)	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
;	O
return	O
NULL	O
;	O
}	O
bfd_vma	long
debug_get_type_size	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
size	int
!=	O
0	int
)	O
return	O
type	enum(int,int,int,int)
->	O
size	int
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
DEBUG_KIND_INDIRECT	O
:	O
if	O
(	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
!=	O
NULL	O
)	O
return	O
debug_get_type_size	O
(	O
handle	O
,	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
)	O
;	O
return	O
0	int
;	O
case	O
DEBUG_KIND_NAMED	O
:	O
case	O
DEBUG_KIND_TAGGED	O
:	O
return	O
debug_get_type_size	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
)	O
;	O
}	O
}	O
debug_type	O
debug_get_return_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
type	enum(int,int,int,int)
=	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
DEBUG_TYPE_NULL	O
;	O
case	O
DEBUG_KIND_FUNCTION	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
return_type	O
;	O
case	O
DEBUG_KIND_METHOD	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
return_type	O
;	O
}	O
}	O
const	O
debug_type	O
*	O
debug_get_parameter_types	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
,	O
bfd_boolean	int
*	O
pvarargs	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum(int,int,int,int)
=	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_FUNCTION	O
:	O
*	O
pvarargs	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
varargs	O
;	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
;	O
case	O
DEBUG_KIND_METHOD	O
:	O
*	O
pvarargs	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
varargs	O
;	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
;	O
}	O
}	O
debug_type	O
debug_get_target_type	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum(int,int,int,int)
=	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_POINTER	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kpointer	O
;	O
case	O
DEBUG_KIND_REFERENCE	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kreference	O
;	O
case	O
DEBUG_KIND_CONST	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kconst	O
;	O
case	O
DEBUG_KIND_VOLATILE	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kvolatile	O
;	O
}	O
}	O
const	O
debug_field	O
*	O
debug_get_fields	O
(	O
void	O
*	O
handle	O
,	O
debug_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum(int,int,int,int)
=	O
debug_get_real_type	O
(	O
handle	O
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_STRUCT	O
:	O
case	O
DEBUG_KIND_UNION	O
:	O
case	O
DEBUG_KIND_CLASS	O
:	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
return	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
;	O
}	O
}	O
debug_type	O
debug_get_field_type	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
field	O
->	O
type	enum(int,int,int,int)
;	O
}	O
const	O
char	O
*	O
debug_get_field_name	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
field	O
->	O
name	*(char)
;	O
}	O
bfd_vma	long
debug_get_field_bitpos	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
||	O
field	O
->	O
static_member	O
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
field	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
;	O
}	O
bfd_vma	long
debug_get_field_bitsize	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
||	O
field	O
->	O
static_member	O
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
field	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
;	O
}	O
enum	O
debug_visibility	O
debug_get_field_visibility	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
)	O
return	O
DEBUG_VISIBILITY_IGNORE	O
;	O
return	O
field	O
->	O
visibility	O
;	O
}	O
const	O
char	O
*	O
debug_get_field_physname	O
(	O
void	O
*	O
handle	O
ATTRIBUTE_UNUSED	O
,	O
debug_field	O
field	O
)	O
{	O
if	O
(	O
field	O
==	O
NULL	O
||	O
!	O
field	O
->	O
static_member	O
)	O
return	O
NULL	O
;	O
return	O
field	O
->	O
u	union(long,*(struct))
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
physname	O
;	O
}	O
bfd_boolean	int
debug_write	O
(	O
void	O
*	O
handle	O
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
)	O
{	O
struct	O
debug_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
debug_handle	O
*	O
)	O
handle	O
;	O
struct	O
debug_unit	O
*	O
u	union(long,*(struct))
;	O
++	O
info	*(void)
->	O
mark	O
;	O
info	*(void)
->	O
base_id	O
=	O
info	*(void)
->	O
class_id	O
;	O
info	*(void)
->	O
id_list	O
=	O
NULL	O
;	O
for	O
(	O
u	union(long,*(struct))
=	O
info	*(void)
->	O
units	O
;	O
u	union(long,*(struct))
!=	O
NULL	O
;	O
u	union(long,*(struct))
=	O
u	union(long,*(struct))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
struct	O
debug_file	O
*	O
f	O
;	O
bfd_boolean	int
first_file	O
;	O
info	*(void)
->	O
current_write_lineno	O
=	O
u	union(long,*(struct))
->	O
linenos	O
;	O
info	*(void)
->	O
current_write_lineno_index	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_compilation_unit	O
)	O
(	O
fhandle	O
,	O
u	union(long,*(struct))
->	O
files	O
->	O
filename	*(char)
)	O
)	O
return	O
FALSE	O
;	O
first_file	O
=	O
TRUE	int
;	O
for	O
(	O
f	O
=	O
u	union(long,*(struct))
->	O
files	O
;	O
f	O
!=	O
NULL	O
;	O
f	O
=	O
f	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
if	O
(	O
first_file	O
)	O
first_file	O
=	O
FALSE	O
;	O
else	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_source	O
)	O
(	O
fhandle	O
,	O
f	O
->	O
filename	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
f	O
->	O
globals	O
!=	O
NULL	O
)	O
for	O
(	O
n	O
=	O
f	O
->	O
globals	O
->	O
list	O
;	O
n	O
!=	O
NULL	O
;	O
n	O
=	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
!	O
debug_write_name	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
debug_write_linenos	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_write_name	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
struct	O
debug_name	O
*	O
n	O
)	O
{	O
switch	O
(	O
n	O
->	O
kind	O
)	O
{	O
case	O
DEBUG_OBJECT_TYPE	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
type	enum(int,int,int,int)
,	O
n	O
)	O
||	O
!	O
(	O
*	O
fns	O
->	O
typdef	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	int
;	O
case	O
DEBUG_OBJECT_TAG	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
tag	O
,	O
n	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
tag	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
)	O
;	O
case	O
DEBUG_OBJECT_VARIABLE	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
variable	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
variable	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
,	O
n	O
->	O
u	union(long,*(struct))
.	O
variable	O
->	O
kind	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
variable	O
->	O
val	array(int)
)	O
;	O
case	O
DEBUG_OBJECT_FUNCTION	O
:	O
return	O
debug_write_function	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
->	O
name	*(char)
,	O
n	O
->	O
linkage	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
function	O
)	O
;	O
case	O
DEBUG_OBJECT_INT_CONSTANT	O
:	O
return	O
(	O
*	O
fns	O
->	O
int_constant	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
,	O
n	O
->	O
u	union(long,*(struct))
.	O
int_constant	O
)	O
;	O
case	O
DEBUG_OBJECT_FLOAT_CONSTANT	O
:	O
return	O
(	O
*	O
fns	O
->	O
float_constant	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
,	O
n	O
->	O
u	union(long,*(struct))
.	O
float_constant	O
)	O
;	O
case	O
DEBUG_OBJECT_TYPED_CONSTANT	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
->	O
u	union(long,*(struct))
.	O
typed_constant	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
typed_constant	O
)	O
(	O
fhandle	O
,	O
n	O
->	O
name	*(char)
,	O
n	O
->	O
u	union(long,*(struct))
.	O
typed_constant	O
->	O
val	array(int)
)	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
debug_write_type	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
,	O
struct	O
debug_name	O
*	O
name	*(char)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
int	O
is	O
;	O
const	O
char	O
*	O
tag	O
=	O
NULL	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
(	O
*	O
fns	O
->	O
empty_type	O
)	O
(	O
fhandle	O
)	O
;	O
if	O
(	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_NAMED	O
||	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
)	O
&&	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
mark	O
==	O
info	*(void)
->	O
mark	O
||	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
&&	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
!=	O
name	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_NAMED	O
)	O
return	O
(	O
*	O
fns	O
->	O
typedef_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
)	O
;	O
else	O
{	O
struct	O
debug_type_s	O
*	O
real	O
;	O
unsigned	O
int	O
id	int
;	O
real	O
=	O
debug_get_real_type	O
(	O
(	O
void	O
*	O
)	O
info	*(void)
,	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
;	O
if	O
(	O
real	O
==	O
NULL	O
)	O
return	O
(	O
*	O
fns	O
->	O
empty_type	O
)	O
(	O
fhandle	O
)	O
;	O
id	int
=	O
0	int
;	O
if	O
(	O
(	O
real	O
->	O
kind	O
==	O
DEBUG_KIND_STRUCT	O
||	O
real	O
->	O
kind	O
==	O
DEBUG_KIND_UNION	O
||	O
real	O
->	O
kind	O
==	O
DEBUG_KIND_CLASS	O
||	O
real	O
->	O
kind	O
==	O
DEBUG_KIND_UNION_CLASS	O
)	O
&&	O
real	O
->	O
u	union(long,*(struct))
.	O
kclass	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
real	O
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
<=	O
info	*(void)
->	O
base_id	O
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	O
(	O
info	*(void)
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
,	O
real	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
id	int
=	O
real	O
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
;	O
}	O
return	O
(	O
*	O
fns	O
->	O
tag_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
,	O
id	int
,	O
real	O
->	O
kind	O
)	O
;	O
}	O
}	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
name	*(char)
->	O
mark	O
=	O
info	*(void)
->	O
mark	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
type	enum(int,int,int,int)
->	O
kind	O
!=	O
DEBUG_KIND_NAMED	O
&&	O
type	enum(int,int,int,int)
->	O
kind	O
!=	O
DEBUG_KIND_TAGGED	O
)	O
{	O
assert	O
(	O
name	*(char)
->	O
kind	O
==	O
DEBUG_OBJECT_TAG	O
)	O
;	O
tag	O
=	O
name	*(char)
->	O
name	*(char)
;	O
}	O
switch	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
{	O
case	O
DEBUG_KIND_ILLEGAL	O
:	O
debug_error	O
(	O
_	O
(	O
"debug_write_type: illegal type encountered"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
case	O
DEBUG_KIND_INDIRECT	O
:	O
return	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
*	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
,	O
name	*(char)
)	O
;	O
case	O
DEBUG_KIND_VOID	O
:	O
return	O
(	O
*	O
fns	O
->	O
void_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_INT	O
:	O
return	O
(	O
*	O
fns	O
->	O
int_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
size	int
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kint	O
)	O
;	O
case	O
DEBUG_KIND_FLOAT	O
:	O
return	O
(	O
*	O
fns	O
->	O
float_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_COMPLEX	O
:	O
return	O
(	O
*	O
fns	O
->	O
complex_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_BOOL	O
:	O
return	O
(	O
*	O
fns	O
->	O
bool_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_STRUCT	O
:	O
case	O
DEBUG_KIND_UNION	O
:	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
<=	O
info	*(void)
->	O
base_id	O
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	O
(	O
info	*(void)
,	O
tag	O
,	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
mark	O
==	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
mark	O
)	O
{	O
assert	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
>	O
info	*(void)
->	O
base_id	O
)	O
;	O
return	O
(	O
*	O
fns	O
->	O
tag_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
,	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
;	O
}	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
mark	O
=	O
info	*(void)
->	O
mark	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_struct_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
!=	O
NULL	O
?	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
:	O
0	int
)	O
,	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_STRUCT	O
,	O
type	enum(int,int,int,int)
->	O
size	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
!=	O
NULL	O
&&	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
struct	O
debug_field_s	O
*	O
f	O
;	O
f	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
f	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
||	O
!	O
(	O
*	O
fns	O
->	O
struct_field	O
)	O
(	O
fhandle	O
,	O
f	O
->	O
name	*(char)
,	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
,	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
,	O
f	O
->	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
return	O
(	O
*	O
fns	O
->	O
end_struct_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_CLASS	O
:	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
return	O
debug_write_class_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
,	O
tag	O
)	O
;	O
case	O
DEBUG_KIND_ENUM	O
:	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kenum	O
==	O
NULL	O
)	O
return	O
(	O
*	O
fns	O
->	O
enum_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
(	O
const	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
bfd_signed_vma	long
*	O
)	O
NULL	O
)	O
;	O
return	O
(	O
*	O
fns	O
->	O
enum_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
names	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
values	O
)	O
;	O
case	O
DEBUG_KIND_POINTER	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kpointer	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
pointer_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_FUNCTION	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
return_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
==	O
NULL	O
)	O
is	O
=	O
-	O
1	int
;	O
else	O
{	O
for	O
(	O
is	O
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
[	O
is	O
]	O
!=	O
NULL	O
;	O
is	O
++	O
)	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
[	O
is	O
]	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
(	O
*	O
fns	O
->	O
function_type	O
)	O
(	O
fhandle	O
,	O
is	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
varargs	O
)	O
;	O
case	O
DEBUG_KIND_REFERENCE	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kreference	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
reference_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_RANGE	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
range_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
lower	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
upper	O
)	O
;	O
case	O
DEBUG_KIND_ARRAY	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
element_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
||	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
range_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
array_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
lower	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
upper	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
stringp	O
)	O
;	O
case	O
DEBUG_KIND_SET	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
set_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
bitstringp	O
)	O
;	O
case	O
DEBUG_KIND_OFFSET	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
base_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
||	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
target_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
offset_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_METHOD	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
return_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
==	O
NULL	O
)	O
is	O
=	O
-	O
1	int
;	O
else	O
{	O
for	O
(	O
is	O
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
[	O
is	O
]	O
!=	O
NULL	O
;	O
is	O
++	O
)	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
[	O
is	O
]	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
domain_type	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
domain_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
(	O
*	O
fns	O
->	O
method_type	O
)	O
(	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
domain_type	O
!=	O
NULL	O
,	O
is	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
varargs	O
)	O
;	O
case	O
DEBUG_KIND_CONST	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kconst	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
const_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_VOLATILE	O
:	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kvolatile	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
*	O
fns	O
->	O
volatile_type	O
)	O
(	O
fhandle	O
)	O
;	O
case	O
DEBUG_KIND_NAMED	O
:	O
return	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
;	O
case	O
DEBUG_KIND_TAGGED	O
:	O
return	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
)	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
debug_write_class_type	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
,	O
const	O
char	O
*	O
tag	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
unsigned	O
int	O
id	int
;	O
struct	O
debug_type_s	O
*	O
vptrbase	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
==	O
NULL	O
)	O
{	O
id	int
=	O
0	int
;	O
vptrbase	O
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
<=	O
info	*(void)
->	O
base_id	O
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	O
(	O
info	*(void)
,	O
tag	O
,	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
info	*(void)
->	O
mark	O
==	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
mark	O
)	O
{	O
assert	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
>	O
info	*(void)
->	O
base_id	O
)	O
;	O
return	O
(	O
*	O
fns	O
->	O
tag_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
,	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
;	O
}	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
mark	O
=	O
info	*(void)
->	O
mark	O
;	O
id	int
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
;	O
vptrbase	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
vptrbase	O
;	O
if	O
(	O
vptrbase	O
!=	O
NULL	O
&&	O
vptrbase	O
!=	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
vptrbase	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_class_type	O
)	O
(	O
fhandle	O
,	O
tag	O
,	O
id	int
,	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_CLASS	O
,	O
type	enum(int,int,int,int)
->	O
size	int
,	O
vptrbase	O
!=	O
NULL	O
,	O
vptrbase	O
==	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
struct	O
debug_field_s	O
*	O
f	O
;	O
f	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
fields	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
f	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
f	O
->	O
static_member	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_static_member	O
)	O
(	O
fhandle	O
,	O
f	O
->	O
name	*(char)
,	O
f	O
->	O
u	union(long,*(struct))
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
physname	O
,	O
f	O
->	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
struct_field	O
)	O
(	O
fhandle	O
,	O
f	O
->	O
name	*(char)
,	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
,	O
f	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
,	O
f	O
->	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
baseclasses	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
baseclasses	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
struct	O
debug_baseclass_s	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
baseclasses	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_baseclass	O
)	O
(	O
fhandle	O
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
bitpos	int
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
is_virtual	O
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
methods	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
methods	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
struct	O
debug_method_s	O
*	O
m	O
;	O
unsigned	O
int	O
j	O
;	O
m	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
methods	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_start_method	O
)	O
(	O
fhandle	O
,	O
m	O
->	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
m	O
->	O
variants	O
[	O
j	O
]	O
!=	O
NULL	O
;	O
j	O
++	O
)	O
{	O
struct	O
debug_method_variant_s	O
*	O
v	O
;	O
v	O
=	O
m	O
->	O
variants	O
[	O
j	O
]	O
;	O
if	O
(	O
v	O
->	O
context	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
v	O
->	O
context	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
v	O
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
v	O
->	O
voffset	O
!=	O
VOFFSET_STATIC_METHOD	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_method_variant	O
)	O
(	O
fhandle	O
,	O
v	O
->	O
physname	O
,	O
v	O
->	O
visibility	O
,	O
v	O
->	O
constp	O
,	O
v	O
->	O
volatilep	O
,	O
v	O
->	O
voffset	O
,	O
v	O
->	O
context	O
!=	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_static_method_variant	O
)	O
(	O
fhandle	O
,	O
v	O
->	O
physname	O
,	O
v	O
->	O
visibility	O
,	O
v	O
->	O
constp	O
,	O
v	O
->	O
volatilep	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
class_end_method	O
)	O
(	O
fhandle	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
return	O
(	O
*	O
fns	O
->	O
end_class_type	O
)	O
(	O
fhandle	O
)	O
;	O
}	O
static	O
bfd_boolean	int
debug_write_function	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_object_linkage	O
linkage	O
,	O
struct	O
debug_function	O
*	O
function	O
)	O
{	O
struct	O
debug_parameter	O
*	O
p	*(void)
;	O
struct	O
debug_block	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
!	O
debug_write_linenos	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
function	O
->	O
blocks	O
->	O
start	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
function	O
->	O
return_type	O
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_function	O
)	O
(	O
fhandle	O
,	O
name	*(char)
,	O
linkage	O
==	O
DEBUG_LINKAGE_GLOBAL	O
)	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
p	*(void)
=	O
function	O
->	O
parameters	O
;	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
!	O
debug_write_type	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
p	*(void)
->	O
type	enum(int,int,int,int)
,	O
(	O
struct	O
debug_name	O
*	O
)	O
NULL	O
)	O
||	O
!	O
(	O
*	O
fns	O
->	O
function_parameter	O
)	O
(	O
fhandle	O
,	O
p	*(void)
->	O
name	*(char)
,	O
p	*(void)
->	O
kind	O
,	O
p	*(void)
->	O
val	array(int)
)	O
)	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
function	O
->	O
blocks	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
!	O
debug_write_block	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
(	O
*	O
fns	O
->	O
end_function	O
)	O
(	O
fhandle	O
)	O
;	O
}	O
static	O
bfd_boolean	int
debug_write_block	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
struct	O
debug_block	O
*	O
block	O
)	O
{	O
struct	O
debug_name	O
*	O
n	O
;	O
struct	O
debug_block	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
!	O
debug_write_linenos	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
block	O
->	O
start	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
block	O
->	O
locals	O
!=	O
NULL	O
||	O
block	O
->	O
parent	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
start_block	O
)	O
(	O
fhandle	O
,	O
block	O
->	O
start	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
block	O
->	O
locals	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
n	O
=	O
block	O
->	O
locals	O
->	O
list	O
;	O
n	O
!=	O
NULL	O
;	O
n	O
=	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
!	O
debug_write_name	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
n	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
for	O
(	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
block	O
->	O
children	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
;	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
!	O
debug_write_block	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
debug_write_linenos	O
(	O
info	*(void)
,	O
fns	O
,	O
fhandle	O
,	O
block	O
->	O
end	*(*(char))
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
block	O
->	O
locals	O
!=	O
NULL	O
||	O
block	O
->	O
parent	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
end_block	O
)	O
(	O
fhandle	O
,	O
block	O
->	O
end	*(*(char))
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_write_linenos	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
struct	O
debug_write_fns	O
*	O
fns	O
,	O
void	O
*	O
fhandle	O
,	O
bfd_vma	long
address	long
)	O
{	O
while	O
(	O
info	*(void)
->	O
current_write_lineno	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_lineno	O
*	O
l	O
;	O
l	O
=	O
info	*(void)
->	O
current_write_lineno	O
;	O
while	O
(	O
info	*(void)
->	O
current_write_lineno_index	O
<	O
DEBUG_LINENO_COUNT	O
)	O
{	O
if	O
(	O
l	O
->	O
linenos	O
[	O
info	*(void)
->	O
current_write_lineno_index	O
]	O
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
l	O
->	O
addrs	O
[	O
info	*(void)
->	O
current_write_lineno_index	O
]	O
>=	O
address	long
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	O
->	O
lineno	*(struct(int,union(*(struct),long)))
)	O
(	O
fhandle	O
,	O
l	O
->	O
file	*(void)
->	O
filename	*(char)
,	O
l	O
->	O
linenos	O
[	O
info	*(void)
->	O
current_write_lineno_index	O
]	O
,	O
l	O
->	O
addrs	O
[	O
info	*(void)
->	O
current_write_lineno_index	O
]	O
)	O
)	O
return	O
FALSE	O
;	O
++	O
info	*(void)
->	O
current_write_lineno_index	O
;	O
}	O
info	*(void)
->	O
current_write_lineno	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
info	*(void)
->	O
current_write_lineno_index	O
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_set_class_id	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
struct	O
debug_type_s	O
*	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
debug_class_type	O
*	O
c	O
;	O
struct	O
debug_class_id	O
*	O
l	O
;	O
assert	O
(	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_STRUCT	O
||	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_UNION	O
||	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_CLASS	O
||	O
type	enum(int,int,int,int)
->	O
kind	O
==	O
DEBUG_KIND_UNION_CLASS	O
)	O
;	O
c	O
=	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
;	O
if	O
(	O
c	O
->	O
id	int
>	O
info	*(void)
->	O
base_id	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
l	O
=	O
info	*(void)
->	O
id_list	O
;	O
l	O
!=	O
NULL	O
;	O
l	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
l	O
->	O
type	enum(int,int,int,int)
->	O
kind	O
!=	O
type	enum(int,int,int,int)
->	O
kind	O
)	O
continue	O
;	O
if	O
(	O
tag	O
==	O
NULL	O
)	O
{	O
if	O
(	O
l	O
->	O
tag	O
!=	O
NULL	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
l	O
->	O
tag	O
==	O
NULL	O
||	O
l	O
->	O
tag	O
[	O
0	int
]	O
!=	O
tag	O
[	O
0	int
]	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
l	O
->	O
tag	O
,	O
tag	O
)	O
!=	O
0	int
)	O
continue	O
;	O
}	O
if	O
(	O
debug_type_samep	O
(	O
info	*(void)
,	O
l	O
->	O
type	enum(int,int,int,int)
,	O
type	enum(int,int,int,int)
)	O
)	O
{	O
c	O
->	O
id	int
=	O
l	O
->	O
type	enum(int,int,int,int)
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
;	O
return	O
TRUE	int
;	O
}	O
}	O
++	O
info	*(void)
->	O
class_id	O
;	O
c	O
->	O
id	int
=	O
info	*(void)
->	O
class_id	O
;	O
l	O
=	O
(	O
struct	O
debug_class_id	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
l	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
l	O
,	O
0	int
,	O
sizeof	O
*	O
l	O
)	O
;	O
l	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
l	O
->	O
tag	O
=	O
tag	O
;	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
id_list	O
;	O
info	*(void)
->	O
id_list	O
=	O
l	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_type_samep	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
struct	O
debug_type_s	O
*	O
t1	O
,	O
struct	O
debug_type_s	O
*	O
t2	O
)	O
{	O
struct	O
debug_type_compare_list	O
*	O
l	O
;	O
struct	O
debug_type_compare_list	O
top	O
;	O
bfd_boolean	int
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
if	O
(	O
t1	O
==	O
NULL	O
)	O
return	O
t2	O
==	O
NULL	O
;	O
if	O
(	O
t2	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
while	O
(	O
t1	O
->	O
kind	O
==	O
DEBUG_KIND_INDIRECT	O
)	O
{	O
t1	O
=	O
*	O
t1	O
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
;	O
if	O
(	O
t1	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
t2	O
->	O
kind	O
==	O
DEBUG_KIND_INDIRECT	O
)	O
{	O
t2	O
=	O
*	O
t2	O
->	O
u	union(long,*(struct))
.	O
kindirect	O
->	O
slot	O
;	O
if	O
(	O
t2	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
t1	O
==	O
t2	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
t1	O
->	O
kind	O
==	O
DEBUG_KIND_NAMED	O
&&	O
t2	O
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
)	O
return	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
,	O
t2	O
)	O
;	O
else	O
if	O
(	O
t1	O
->	O
kind	O
==	O
DEBUG_KIND_TAGGED	O
&&	O
t2	O
->	O
kind	O
==	O
DEBUG_KIND_NAMED	O
)	O
return	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
t1	O
->	O
kind	O
!=	O
t2	O
->	O
kind	O
||	O
t1	O
->	O
size	int
!=	O
t2	O
->	O
size	int
)	O
return	O
FALSE	O
;	O
switch	O
(	O
t1	O
->	O
kind	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
DEBUG_KIND_VOID	O
:	O
case	O
DEBUG_KIND_FLOAT	O
:	O
case	O
DEBUG_KIND_COMPLEX	O
:	O
case	O
DEBUG_KIND_BOOL	O
:	O
return	O
TRUE	int
;	O
case	O
DEBUG_KIND_INT	O
:	O
return	O
t1	O
->	O
u	union(long,*(struct))
.	O
kint	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
kint	O
;	O
}	O
for	O
(	O
l	O
=	O
info	*(void)
->	O
compare_list	O
;	O
l	O
!=	O
NULL	O
;	O
l	O
=	O
l	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
l	O
->	O
t1	O
==	O
t1	O
&&	O
l	O
->	O
t2	O
==	O
t2	O
)	O
return	O
TRUE	int
;	O
}	O
top	O
.	O
t1	O
=	O
t1	O
;	O
top	O
.	O
t2	O
=	O
t2	O
;	O
top	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
compare_list	O
;	O
info	*(void)
->	O
compare_list	O
=	O
&	O
top	O
;	O
switch	O
(	O
t1	O
->	O
kind	O
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
case	O
DEBUG_KIND_STRUCT	O
:	O
case	O
DEBUG_KIND_UNION	O
:	O
case	O
DEBUG_KIND_CLASS	O
:	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kclass	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kclass	O
==	O
NULL	O
;	O
else	O
if	O
(	O
t2	O
->	O
u	union(long,*(struct))
.	O
kclass	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
else	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
>	O
info	*(void)
->	O
base_id	O
&&	O
t1	O
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
kclass	O
->	O
id	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
else	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_class_type_samep	O
(	O
info	*(void)
,	O
t1	O
,	O
t2	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_ENUM	O
:	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kenum	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kenum	O
==	O
NULL	O
;	O
else	O
if	O
(	O
t2	O
->	O
u	union(long,*(struct))
.	O
kenum	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
else	O
{	O
const	O
char	O
*	O
*	O
pn1	O
,	O
*	O
*	O
pn2	O
;	O
bfd_signed_vma	long
*	O
pv1	O
,	O
*	O
pv2	O
;	O
pn1	O
=	O
t1	O
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
names	O
;	O
pn2	O
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
names	O
;	O
pv1	O
=	O
t1	O
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
values	O
;	O
pv2	O
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kenum	O
->	O
values	O
;	O
while	O
(	O
*	O
pn1	O
!=	O
NULL	O
&&	O
*	O
pn2	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
*	O
pn1	O
!=	O
*	O
*	O
pn2	O
||	O
*	O
pv1	O
!=	O
*	O
pv2	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
pn1	O
,	O
*	O
pn2	O
)	O
!=	O
0	int
)	O
break	O
;	O
++	O
pn1	O
;	O
++	O
pn2	O
;	O
++	O
pv1	O
;	O
++	O
pv2	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
*	O
pn1	O
==	O
NULL	O
&&	O
*	O
pn2	O
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_POINTER	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kpointer	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kpointer	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_FUNCTION	O
:	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
varargs	O
!=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
varargs	O
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
return_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
return_type	O
)	O
||	O
(	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
==	O
NULL	O
)	O
!=	O
(	O
t2	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
==	O
NULL	O
)	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
else	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
else	O
{	O
struct	O
debug_type_s	O
*	O
*	O
a1	O
,	O
*	O
*	O
a2	O
;	O
a1	O
=	O
t1	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
;	O
a2	O
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kfunction	O
->	O
arg_types	O
;	O
while	O
(	O
*	O
a1	O
!=	O
NULL	O
&&	O
*	O
a2	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
*	O
a1	O
,	O
*	O
a2	O
)	O
)	O
break	O
;	O
++	O
a1	O
;	O
++	O
a2	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
*	O
a1	O
==	O
NULL	O
&&	O
*	O
a2	O
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_REFERENCE	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kreference	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kreference	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_RANGE	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
lower	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
lower	O
&&	O
t1	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
upper	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
upper	O
&&	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
type	enum(int,int,int,int)
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
krange	O
->	O
type	enum(int,int,int,int)
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_ARRAY	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
lower	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
lower	O
&&	O
t1	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
upper	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
upper	O
&&	O
t1	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
stringp	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
stringp	O
&&	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
element_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
karray	O
->	O
element_type	O
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_SET	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
bitstringp	O
==	O
t2	O
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
bitstringp	O
&&	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
type	enum(int,int,int,int)
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kset	O
->	O
type	enum(int,int,int,int)
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_OFFSET	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
base_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
base_type	O
)	O
&&	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
target_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
koffset	O
->	O
target_type	O
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_METHOD	O
:	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
varargs	O
!=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
varargs	O
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
return_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
return_type	O
)	O
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
domain_type	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
domain_type	O
)	O
||	O
(	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
==	O
NULL	O
)	O
!=	O
(	O
t2	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
==	O
NULL	O
)	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
else	O
if	O
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
==	O
NULL	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
else	O
{	O
struct	O
debug_type_s	O
*	O
*	O
a1	O
,	O
*	O
*	O
a2	O
;	O
a1	O
=	O
t1	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
;	O
a2	O
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kmethod	O
->	O
arg_types	O
;	O
while	O
(	O
*	O
a1	O
!=	O
NULL	O
&&	O
*	O
a2	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
*	O
a1	O
,	O
*	O
a2	O
)	O
)	O
break	O
;	O
++	O
a1	O
;	O
++	O
a2	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
*	O
a1	O
==	O
NULL	O
&&	O
*	O
a2	O
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_CONST	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kconst	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kconst	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_VOLATILE	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
kvolatile	O
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
kvolatile	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_NAMED	O
:	O
case	O
DEBUG_KIND_TAGGED	O
:	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t1	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
name	*(char)
->	O
name	*(char)
)	O
==	O
0	int
&&	O
debug_type_samep	O
(	O
info	*(void)
,	O
t1	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
,	O
t2	O
->	O
u	union(long,*(struct))
.	O
knamed	O
->	O
type	enum(int,int,int,int)
)	O
)	O
;	O
break	O
;	O
}	O
info	*(void)
->	O
compare_list	O
=	O
top	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
bfd_boolean	int
debug_class_type_samep	O
(	O
struct	O
debug_handle	O
*	O
info	*(void)
,	O
struct	O
debug_type_s	O
*	O
t1	O
,	O
struct	O
debug_type_s	O
*	O
t2	O
)	O
{	O
struct	O
debug_class_type	O
*	O
c1	O
,	O
*	O
c2	O
;	O
c1	O
=	O
t1	O
->	O
u	union(long,*(struct))
.	O
kclass	O
;	O
c2	O
=	O
t2	O
->	O
u	union(long,*(struct))
.	O
kclass	O
;	O
if	O
(	O
(	O
c1	O
->	O
fields	O
==	O
NULL	O
)	O
!=	O
(	O
c2	O
->	O
fields	O
==	O
NULL	O
)	O
||	O
(	O
c1	O
->	O
baseclasses	O
==	O
NULL	O
)	O
!=	O
(	O
c2	O
->	O
baseclasses	O
==	O
NULL	O
)	O
||	O
(	O
c1	O
->	O
methods	O
==	O
NULL	O
)	O
!=	O
(	O
c2	O
->	O
methods	O
==	O
NULL	O
)	O
||	O
(	O
c1	O
->	O
vptrbase	O
==	O
NULL	O
)	O
!=	O
(	O
c2	O
->	O
vptrbase	O
==	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
c1	O
->	O
fields	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_field_s	O
*	O
*	O
pf1	O
,	O
*	O
*	O
pf2	O
;	O
for	O
(	O
pf1	O
=	O
c1	O
->	O
fields	O
,	O
pf2	O
=	O
c2	O
->	O
fields	O
;	O
*	O
pf1	O
!=	O
NULL	O
&&	O
*	O
pf2	O
!=	O
NULL	O
;	O
pf1	O
++	O
,	O
pf2	O
++	O
)	O
{	O
struct	O
debug_field_s	O
*	O
f1	O
,	O
*	O
f2	O
;	O
f1	O
=	O
*	O
pf1	O
;	O
f2	O
=	O
*	O
pf2	O
;	O
if	O
(	O
f1	O
->	O
name	*(char)
[	O
0	int
]	O
!=	O
f2	O
->	O
name	*(char)
[	O
0	int
]	O
||	O
f1	O
->	O
visibility	O
!=	O
f2	O
->	O
visibility	O
||	O
f1	O
->	O
static_member	O
!=	O
f2	O
->	O
static_member	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
f1	O
->	O
static_member	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
f1	O
->	O
u	union(long,*(struct))
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
physname	O
,	O
f2	O
->	O
u	union(long,*(struct))
.	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
physname	O
)	O
!=	O
0	int
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
f1	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
!=	O
f2	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitpos	int
||	O
f1	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
!=	O
f2	O
->	O
u	union(long,*(struct))
.	O
f	O
.	O
bitsize	int
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
f1	O
->	O
name	*(char)
,	O
f2	O
->	O
name	*(char)
)	O
!=	O
0	int
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
debug_get_real_type	O
(	O
(	O
void	O
*	O
)	O
info	*(void)
,	O
f1	O
->	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
,	O
debug_get_real_type	O
(	O
(	O
void	O
*	O
)	O
info	*(void)
,	O
f2	O
->	O
type	enum(int,int,int,int)
,	O
NULL	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
pf1	O
!=	O
NULL	O
||	O
*	O
pf2	O
!=	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
c1	O
->	O
vptrbase	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
c1	O
->	O
vptrbase	O
,	O
c2	O
->	O
vptrbase	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
c1	O
->	O
baseclasses	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_baseclass_s	O
*	O
*	O
pb1	O
,	O
*	O
*	O
pb2	O
;	O
for	O
(	O
pb1	O
=	O
c1	O
->	O
baseclasses	O
,	O
pb2	O
=	O
c2	O
->	O
baseclasses	O
;	O
*	O
pb1	O
!=	O
NULL	O
&&	O
*	O
pb2	O
!=	O
NULL	O
;	O
++	O
pb1	O
,	O
++	O
pb2	O
)	O
{	O
struct	O
debug_baseclass_s	O
*	O
b1	O
,	O
*	O
b2	O
;	O
b1	O
=	O
*	O
pb1	O
;	O
b2	O
=	O
*	O
pb2	O
;	O
if	O
(	O
b1	O
->	O
bitpos	int
!=	O
b2	O
->	O
bitpos	int
||	O
b1	O
->	O
is_virtual	O
!=	O
b2	O
->	O
is_virtual	O
||	O
b1	O
->	O
visibility	O
!=	O
b2	O
->	O
visibility	O
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
b1	O
->	O
type	enum(int,int,int,int)
,	O
b2	O
->	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
pb1	O
!=	O
NULL	O
||	O
*	O
pb2	O
!=	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
c1	O
->	O
methods	O
!=	O
NULL	O
)	O
{	O
struct	O
debug_method_s	O
*	O
*	O
pm1	O
,	O
*	O
*	O
pm2	O
;	O
for	O
(	O
pm1	O
=	O
c1	O
->	O
methods	O
,	O
pm2	O
=	O
c2	O
->	O
methods	O
;	O
*	O
pm1	O
!=	O
NULL	O
&&	O
*	O
pm2	O
!=	O
NULL	O
;	O
++	O
pm1	O
,	O
++	O
pm2	O
)	O
{	O
struct	O
debug_method_s	O
*	O
m1	O
,	O
*	O
m2	O
;	O
m1	O
=	O
*	O
pm1	O
;	O
m2	O
=	O
*	O
pm2	O
;	O
if	O
(	O
m1	O
->	O
name	*(char)
[	O
0	int
]	O
!=	O
m2	O
->	O
name	*(char)
[	O
0	int
]	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
m1	O
->	O
name	*(char)
,	O
m2	O
->	O
name	*(char)
)	O
!=	O
0	int
||	O
(	O
m1	O
->	O
variants	O
==	O
NULL	O
)	O
!=	O
(	O
m2	O
->	O
variants	O
==	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
m1	O
->	O
variants	O
==	O
NULL	O
)	O
{	O
struct	O
debug_method_variant_s	O
*	O
*	O
pv1	O
,	O
*	O
*	O
pv2	O
;	O
for	O
(	O
pv1	O
=	O
m1	O
->	O
variants	O
,	O
pv2	O
=	O
m2	O
->	O
variants	O
;	O
*	O
pv1	O
!=	O
NULL	O
&&	O
*	O
pv2	O
!=	O
NULL	O
;	O
++	O
pv1	O
,	O
++	O
pv2	O
)	O
{	O
struct	O
debug_method_variant_s	O
*	O
v1	O
,	O
*	O
v2	O
;	O
v1	O
=	O
*	O
pv1	O
;	O
v2	O
=	O
*	O
pv2	O
;	O
if	O
(	O
v1	O
->	O
physname	O
[	O
0	int
]	O
!=	O
v2	O
->	O
physname	O
[	O
0	int
]	O
||	O
v1	O
->	O
visibility	O
!=	O
v2	O
->	O
visibility	O
||	O
v1	O
->	O
constp	O
!=	O
v2	O
->	O
constp	O
||	O
v1	O
->	O
volatilep	O
!=	O
v2	O
->	O
volatilep	O
||	O
v1	O
->	O
voffset	O
!=	O
v2	O
->	O
voffset	O
||	O
(	O
v1	O
->	O
context	O
==	O
NULL	O
)	O
!=	O
(	O
v2	O
->	O
context	O
==	O
NULL	O
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
v1	O
->	O
physname	O
,	O
v2	O
->	O
physname	O
)	O
!=	O
0	int
||	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
v1	O
->	O
type	enum(int,int,int,int)
,	O
v2	O
->	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
v1	O
->	O
context	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	O
(	O
info	*(void)
,	O
v1	O
->	O
context	O
,	O
v2	O
->	O
context	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
*	O
pv1	O
!=	O
NULL	O
||	O
*	O
pv2	O
!=	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
*	O
pm1	O
!=	O
NULL	O
||	O
*	O
pm2	O
!=	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
