static	O
void	O
show_copyright	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
show_version	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
show_help	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
show_debug_help	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
show_debug_flags	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
socket_connect_to	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
const	O
char	O
*	O
host_name	*(char)
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
static	O
void	O
socket_listen_at	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
const	O
char	O
*	O
host_name	*(char)
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
static	O
void	O
socket_close_connection	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
static	O
void	O
socket_stop_listening	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
enum	O
{	O
OPT_BOARDSIZE	int
=	O
127	int
,	O
OPT_HANDICAPSTONES	int
,	O
OPT_COLOR	int
,	O
OPT_KOMI	int
,	O
OPT_CLOCK_TIME	int
,	O
OPT_CLOCK_BYO_TIME	int
,	O
OPT_CLOCK_BYO_PERIOD	int
,	O
OPT_AUTOLEVEL	int
,	O
OPT_MODE	int
,	O
OPT_INFILE	int
,	O
OPT_OUTFILE	int
,	O
OPT_QUIET	int
,	O
OPT_GTP_INPUT	int
,	O
OPT_GTP_CONNECT	int
,	O
OPT_GTP_LISTEN	int
,	O
OPT_GTP_DUMP_COMMANDS	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
,	O
OPT_GTP_VERSION	int
,	O
OPT_SHOWCOPYRIGHT	int
,	O
OPT_REPLAY_GAME	int
,	O
OPT_DECIDE_STRING	int
,	O
OPT_DECIDE_CONNECTION	int
,	O
OPT_DECIDE_OWL	int
,	O
OPT_DECIDE_DRAGON_DATA	int
,	O
OPT_DECIDE_SEMEAI	int
,	O
OPT_DECIDE_SURROUNDED	int
,	O
OPT_DECIDE_TACTICAL_SEMEAI	int
,	O
OPT_DECIDE_ORACLE	int
,	O
OPT_EXPERIMENTAL_SEMEAI	int
,	O
OPT_EXPERIMENTAL_OWL_EXT	int
,	O
OPT_SEMEAI_NODE_LIMIT	int
,	O
OPT_EXPERIMENTAL_CONNECTIONS	int
,	O
OPT_ALTERNATE_CONNECTIONS	int
,	O
OPT_WITH_BREAK_IN	int
,	O
OPT_WITHOUT_BREAK_IN	int
,	O
OPT_COSMIC_GNUGO	int
,	O
OPT_NO_COSMIC_GNUGO	int
,	O
OPT_LARGE_SCALE	int
,	O
OPT_NO_LARGE_SCALE	int
,	O
OPT_OPTIONS	int
,	O
OPT_STANDARD_SEMEAI	int
,	O
OPT_STANDARD_CONNECTIONS	int
,	O
OPT_PRINT_LEVELS	int
,	O
OPT_DECIDE_POSITION	int
,	O
OPT_DECIDE_EYE	int
,	O
OPT_DECIDE_COMBINATION	int
,	O
OPT_BRANCH_DEPTH	int
,	O
OPT_BACKFILL2_DEPTH	int
,	O
OPT_BREAK_CHAIN_DEPTH	int
,	O
OPT_SUPERSTRING_DEPTH	int
,	O
OPT_AA_DEPTH	int
,	O
OPT_DEBUG_FLAGS	int
,	O
OPT_OWL_DISTRUST	int
,	O
OPT_OWL_BRANCH	int
,	O
OPT_OWL_READING	int
,	O
OPT_OWL_NODE_LIMIT	int
,	O
OPT_NOFUSEKIDB	int
,	O
OPT_NOFUSEKI	int
,	O
OPT_NOJOSEKIDB	int
,	O
OPT_LEVEL	int
,	O
OPT_MIN_LEVEL	int
,	O
OPT_MAX_LEVEL	int
,	O
OPT_LIMIT_SEARCH	int
,	O
OPT_SHOWTIME	int
,	O
OPT_SHOWSCORE	int
,	O
OPT_DEBUG_INFLUENCE	int
,	O
OPT_SCORE	int
,	O
OPT_PRINTSGF	int
,	O
OPT_PROFILE_PATTERNS	int
,	O
OPT_CHINESE_RULES	int
,	O
OPT_OWL_THREATS	int
,	O
OPT_NO_OWL_THREATS	int
,	O
OPT_JAPANESE_RULES	int
,	O
OPT_FORBID_SUICIDE	int
,	O
OPT_ALLOW_SUICIDE	int
,	O
OPT_ALLOW_ALL_SUICIDE	int
,	O
OPT_SIMPLE_KO	int
,	O
OPT_NO_KO	int
,	O
OPT_POSITIONAL_SUPERKO	int
,	O
OPT_SITUATIONAL_SUPERKO	int
,	O
OPT_CAPTURE_ALL_DEAD	int
,	O
OPT_PLAY_OUT_AFTERMATH	int
,	O
OPT_MIRROR	int
,	O
OPT_MIRROR_LIMIT	int
,	O
OPT_METAMACHINE	int
,	O
OPT_RESIGN_ALLOWED	int
,	O
OPT_NEVER_RESIGN	int
,	O
OPT_MONTE_CARLO	int
,	O
OPT_MC_GAMES_PER_LEVEL	int
,	O
OPT_MC_PATTERNS	int
,	O
OPT_MC_LIST_PATTERNS	int
,	O
OPT_MC_LOAD_PATTERNS	int
}	O
;	O
enum	O
mode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
MODE_UNKNOWN	int
=	O
0	int
,	O
MODE_ASCII	int
,	O
MODE_GTP	int
,	O
MODE_GMP	int
,	O
MODE_SGMP	int
,	O
MODE_SGF	int
,	O
MODE_LOAD_AND_ANALYZE	int
,	O
MODE_LOAD_AND_SCORE	int
,	O
MODE_LOAD_AND_PRINT	int
,	O
MODE_SOLO	int
,	O
MODE_REPLAY	int
,	O
MODE_DECIDE_STRING	int
,	O
MODE_DECIDE_CONNECTION	int
,	O
MODE_DECIDE_OWL	int
,	O
MODE_DECIDE_DRAGON_DATA	int
,	O
MODE_DECIDE_SEMEAI	int
,	O
MODE_DECIDE_TACTICAL_SEMEAI	int
,	O
MODE_DECIDE_POSITION	int
,	O
MODE_DECIDE_EYE	int
,	O
MODE_DECIDE_COMBINATION	int
,	O
MODE_DECIDE_SURROUNDED	int
,	O
MODE_DECIDE_ORACLE	int
}	O
;	O
static	O
struct	O
gg_option	struct(*(char),int,*(int),int)
const	O
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"mode"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MODE	int
}	O
,	O
{	O
"replay"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_REPLAY_GAME	int
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_QUIET	int
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_QUIET	int
}	O
,	O
{	O
"gtp-input"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INPUT	int
}	O
,	O
{	O
"gtp-connect"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_CONNECT	int
}	O
,	O
{	O
"gtp-listen"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_LISTEN	int
}	O
,	O
{	O
"gtp-dump-commands"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_DUMP_COMMANDS	int
}	O
,	O
{	O
"orientation"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
}	O
,	O
{	O
"gtp-initial-orientation"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
}	O
,	O
{	O
"gtp-version"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_VERSION	int
}	O
,	O
{	O
"infile"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"until"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"outfile"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"output-flags"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"boardsize"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_BOARDSIZE	int
}	O
,	O
{	O
"color"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_COLOR	int
}	O
,	O
{	O
"handicap"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_HANDICAPSTONES	int
}	O
,	O
{	O
"komi"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_KOMI	int
}	O
,	O
{	O
"help"	*(char)
,	O
optional_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"copyright"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWCOPYRIGHT	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"allpats"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"printboard"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"printeyes"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"debug"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"debug-flags"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_DEBUG_FLAGS	int
}	O
,	O
{	O
"depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"backfill-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"branch-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_BRANCH_DEPTH	int
}	O
,	O
{	O
"backfill2-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_BACKFILL2_DEPTH	int
}	O
,	O
{	O
"break-chain-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_BREAK_CHAIN_DEPTH	int
}	O
,	O
{	O
"superstring-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_SUPERSTRING_DEPTH	int
}	O
,	O
{	O
"fourlib-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"ko-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"aa-depth"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_AA_DEPTH	int
}	O
,	O
{	O
"owl-distrust"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_DISTRUST	int
}	O
,	O
{	O
"owl-branch"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_BRANCH	int
}	O
,	O
{	O
"owl-reading"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_READING	int
}	O
,	O
{	O
"owl-node-limit"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_NODE_LIMIT	int
}	O
,	O
{	O
"print-levels"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_PRINT_LEVELS	int
}	O
,	O
{	O
"level"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_LEVEL	int
}	O
,	O
{	O
"min-level"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MIN_LEVEL	int
}	O
,	O
{	O
"max-level"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MAX_LEVEL	int
}	O
,	O
{	O
"limit-search"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_LIMIT_SEARCH	int
}	O
,	O
{	O
"clock"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_TIME	int
}	O
,	O
{	O
"byo-time"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_BYO_TIME	int
}	O
,	O
{	O
"byo-period"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_BYO_PERIOD	int
}	O
,	O
{	O
"autolevel"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_AUTOLEVEL	int
}	O
,	O
{	O
"chinese-rules"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_CHINESE_RULES	int
}	O
,	O
{	O
"japanese-rules"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_JAPANESE_RULES	int
}	O
,	O
{	O
"experimental-semeai"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_SEMEAI	int
}	O
,	O
{	O
"experimental-owl-ext"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_OWL_EXT	int
}	O
,	O
{	O
"semeai-node-limit"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_SEMEAI_NODE_LIMIT	int
}	O
,	O
{	O
"experimental-connections"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_CONNECTIONS	int
}	O
,	O
{	O
"standard-connections"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_STANDARD_CONNECTIONS	int
}	O
,	O
{	O
"standard-semeai"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_STANDARD_SEMEAI	int
}	O
,	O
{	O
"alternate-connections"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALTERNATE_CONNECTIONS	int
}	O
,	O
{	O
"with-break-in"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_WITH_BREAK_IN	int
}	O
,	O
{	O
"without-break-in"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_WITHOUT_BREAK_IN	int
}	O
,	O
{	O
"cosmic-gnugo"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_COSMIC_GNUGO	int
}	O
,	O
{	O
"no-cosmic-gnugo"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_COSMIC_GNUGO	int
}	O
,	O
{	O
"large-scale"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_LARGE_SCALE	int
}	O
,	O
{	O
"no-large-scale"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_LARGE_SCALE	int
}	O
,	O
{	O
"options"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_OPTIONS	int
}	O
,	O
{	O
"forbid-suicide"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_FORBID_SUICIDE	int
}	O
,	O
{	O
"allow-suicide"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALLOW_SUICIDE	int
}	O
,	O
{	O
"allow-all-suicide"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALLOW_ALL_SUICIDE	int
}	O
,	O
{	O
"simple-ko"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_SIMPLE_KO	int
}	O
,	O
{	O
"no-ko"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_KO	int
}	O
,	O
{	O
"positional-superko"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_POSITIONAL_SUPERKO	int
}	O
,	O
{	O
"situational-superko"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_SITUATIONAL_SUPERKO	int
}	O
,	O
{	O
"capture-all-dead"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_CAPTURE_ALL_DEAD	int
}	O
,	O
{	O
"play-out-aftermath"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_PLAY_OUT_AFTERMATH	int
}	O
,	O
{	O
"cache-size"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"worms"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"moyo"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"benchmark"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"statistics"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"trace"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"seed"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"decide-string"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_STRING	int
}	O
,	O
{	O
"decide-connection"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_CONNECTION	int
}	O
,	O
{	O
"decide-dragon"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_OWL	int
}	O
,	O
{	O
"decide-owl"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_OWL	int
}	O
,	O
{	O
"decide-dragon-data"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_DRAGON_DATA	int
}	O
,	O
{	O
"decide-semeai"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_SEMEAI	int
}	O
,	O
{	O
"decide-tactical-semeai"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_TACTICAL_SEMEAI	int
}	O
,	O
{	O
"decide-position"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_POSITION	int
}	O
,	O
{	O
"decide-surrounded"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_SURROUNDED	int
}	O
,	O
{	O
"decide-eye"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_EYE	int
}	O
,	O
{	O
"decide-combination"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_COMBINATION	int
}	O
,	O
{	O
"decide-oracle"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_ORACLE	int
}	O
,	O
{	O
"nofusekidb"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOFUSEKIDB	int
}	O
,	O
{	O
"nofuseki"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOFUSEKI	int
}	O
,	O
{	O
"nojosekidb"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOJOSEKIDB	int
}	O
,	O
{	O
"debug-influence"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_DEBUG_INFLUENCE	int
}	O
,	O
{	O
"showtime"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWTIME	int
}	O
,	O
{	O
"showscore"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWSCORE	int
}	O
,	O
{	O
"score"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_SCORE	int
}	O
,	O
{	O
"printsgf"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_PRINTSGF	int
}	O
,	O
{	O
"profile-patterns"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_PROFILE_PATTERNS	int
}	O
,	O
{	O
"mirror"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_MIRROR	int
}	O
,	O
{	O
"mirror-limit"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MIRROR_LIMIT	int
}	O
,	O
{	O
"metamachine"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_METAMACHINE	int
}	O
,	O
{	O
"resign-allowed"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_RESIGN_ALLOWED	int
}	O
,	O
{	O
"never-resign"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_NEVER_RESIGN	int
}	O
,	O
{	O
"monte-carlo"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_MONTE_CARLO	int
}	O
,	O
{	O
"mc-games-per-level"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_GAMES_PER_LEVEL	int
}	O
,	O
{	O
"mc-patterns"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_PATTERNS	int
}	O
,	O
{	O
"mc-list-patterns"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPT_MC_LIST_PATTERNS	int
}	O
,	O
{	O
"mc-load-patterns"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_LOAD_PATTERNS	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
Gameinfo	struct(int,int,struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))),int)
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
;	O
int	O
i	int
;	O
int	O
mandated_color	int
=	O
EMPTY	int
;	O
enum	O
mode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_UNKNOWN	int
;	O
int	O
replay_color	int
=	O
EMPTY	int
;	O
char	O
*	O
infilename	*(char)
=	O
NULL	O
;	O
char	O
*	O
untilstring	*(char)
=	O
NULL	O
;	O
char	O
*	O
scoringmode	*(char)
=	O
NULL	O
;	O
char	O
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
char	O
*	O
outflags	*(char)
=	O
NULL	O
;	O
char	O
*	O
gtpfile	*(char)
=	O
NULL	O
;	O
char	O
*	O
gtp_dump_commands_file	*(char)
=	O
NULL	O
;	O
int	O
gtp_tcp_ip_mode	int
=	O
0	int
;	O
char	O
*	O
gtp_tcp_ip_address	*(char)
=	O
NULL	O
;	O
char	O
*	O
printsgffile	*(char)
=	O
NULL	O
;	O
char	O
decide_this	array(char)
[	O
8	int
]	O
;	O
char	O
*	O
decide_that	*(char)
=	O
NULL	O
;	O
char	O
debuginfluence_move	array(char)
[	O
4	int
]	O
=	O
"\0"	*(char)
;	O
int	O
benchmark	int
=	O
0	int
;	O
FILE	struct
*	O
output_check	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
orientation	int
=	O
0	int
;	O
char	O
mc_pattern_name	array(char)
[	O
40	int
]	O
=	O
""	*(char)
;	O
char	O
mc_pattern_filename	array(char)
[	O
320	int
]	O
=	O
""	*(char)
;	O
float	O
memory	float
=	O
(	O
float	O
)	O
DEFAULT_MEMORY	O
;	O
int	O
seed	int
=	O
0	int
;	O
int	O
seed_specified	int
=	O
0	int
;	O
int	O
requested_boardsize	int
=	O
-	O
1	int
;	O
sgftree_clear	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
)	O
;	O
gameinfo_clear	(*(struct(int,int,struct(*(struct`),*(struct`)),int)))->(void)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
)	O
;	O
while	O
(	O
(	O
i	int
=	O
gg_getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"-ab:B:d:D:EF:gh::K:l:L:M:m:o:O:p:r:fsStTvw"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
'T'	O
:	O
printboard	int
++	O
;	O
break	O
;	O
case	O
't'	O
:	O
++	O
verbose	int
;	O
break	O
;	O
case	O
'a'	O
:	O
allpats	int
=	O
1	int
;	O
break	O
;	O
case	O
1	int
:	O
case	O
'l'	O
:	O
infilename	*(char)
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
'b'	O
:	O
benchmark	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_SOLO	int
;	O
break	O
;	O
case	O
'r'	O
:	O
seed	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
seed_specified	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
showstatistics	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
printworms	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
printmoyo	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
gg_optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
debug	int
^=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
gg_optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
mandated_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
memory	float
=	O
atof	(*(char))->(double)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
printboard	int
=	O
2	int
;	O
break	O
;	O
case	O
'B'	O
:	O
mandated_backfill_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
mandated_fourlib_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'K'	O
:	O
mandated_ko_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
untilstring	*(char)
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>=	O
sizeof	O
(	O
outfilename	array(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Too long filename given as value to -o option.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
gg_optarg	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
outfilename	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
outflags	*(char)
=	O
gg_optarg	*(char)
;	O
output_flags	int
=	O
0	int
;	O
if	O
(	O
outflags	*(char)
)	O
while	O
(	O
*	O
outflags	*(char)
)	O
{	O
switch	O
(	O
*	O
outflags	*(char)
)	O
{	O
case	O
'd'	O
:	O
output_flags	int
|=	O
OUTPUT_MARKDRAGONS	int
;	O
break	O
;	O
case	O
'v'	O
:	O
output_flags	int
|=	O
OUTPUT_MOVEVALUES	int
;	O
break	O
;	O
}	O
outflags	*(char)
++	O
;	O
}	O
break	O
;	O
case	O
OPT_QUIET	int
:	O
quiet	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_GTP_INPUT	int
:	O
case	O
OPT_GTP_CONNECT	int
:	O
case	O
OPT_GTP_LISTEN	int
:	O
if	O
(	O
gtp_tcp_ip_mode	int
!=	O
0	int
||	O
gtpfile	*(char)
!=	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
"Options `--gtp-input', `--gtp-connect' and `--gtp-listen' "	*(char)
"are mutually-exclusive\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
i	int
==	O
OPT_GTP_INPUT	int
)	O
gtpfile	*(char)
=	O
gg_optarg	*(char)
;	O
else	O
{	O
gtp_tcp_ip_mode	int
=	O
i	int
;	O
gtp_tcp_ip_address	*(char)
=	O
gg_optarg	*(char)
;	O
}	O
break	O
;	O
case	O
OPT_GTP_DUMP_COMMANDS	int
:	O
gtp_dump_commands_file	*(char)
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
OPT_GTP_INITIAL_ORIENTATION	int
:	O
orientation	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
if	O
(	O
orientation	int
<	O
0	int
||	O
orientation	int
>	O
7	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid orientation: %d.\n"	*(char)
,	O
orientation	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_GTP_VERSION	int
:	O
gtp_version	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_OPTIONS	int
:	O
if	O
(	O
USE_BREAK_IN	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: experimental break-ins\n"	*(char)
)	O
;	O
if	O
(	O
COSMIC_GNUGO	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: cosmic GNU Go \n"	*(char)
)	O
;	O
if	O
(	O
LARGE_SCALE	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: large scale captures \n"	*(char)
)	O
;	O
if	O
(	O
EXPERIMENTAL_CONNECTIONS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: experimental connections\n"	*(char)
)	O
;	O
if	O
(	O
ALTERNATE_CONNECTIONS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: alternate connections\n"	*(char)
)	O
;	O
if	O
(	O
EXPERIMENTAL_OWL_EXT	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: experimental GAIN/LOSS codes\n"	*(char)
)	O
;	O
if	O
(	O
OWL_THREATS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: owl threats\n"	*(char)
)	O
;	O
if	O
(	O
RESIGNATION_ALLOWED	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: resignation allowed\n"	*(char)
)	O
;	O
if	O
(	O
ORACLE	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"configure option enabled: oracle\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Owl node limit: %d\n"	*(char)
,	O
OWL_NODE_LIMIT	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Semeai node limit: %d\n"	*(char)
,	O
SEMEAI_NODE_LIMIT	int
)	O
;	O
if	O
(	O
DEFAULT_MEMORY	O
==	O
-	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cache size: %d MB (special default value)\n"	*(char)
,	O
DEFAULT_MEMORY	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cache size: %d MB\n"	*(char)
,	O
DEFAULT_MEMORY	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_SHOWTIME	int
:	O
showtime	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_SHOWSCORE	int
:	O
showscore	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_HANDICAPSTONES	int
:	O
{	O
int	O
requested_handicap	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
if	O
(	O
requested_handicap	int
<	O
0	int
||	O
requested_handicap	int
>	O
MAX_HANDICAP	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unsupported handicap: %d.\n"	*(char)
,	O
requested_handicap	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
handicap	int
=	O
requested_handicap	int
;	O
}	O
break	O
;	O
case	O
OPT_BOARDSIZE	int
:	O
requested_boardsize	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_KOMI	int
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"%f"	*(char)
,	O
&	O
komi	float
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid komi selection: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_CHINESE_RULES	int
:	O
chinese_rules	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_OWL_THREATS	int
:	O
owl_threats	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OWL_THREATS	int
:	O
owl_threats	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_METAMACHINE	int
:	O
metamachine	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_JAPANESE_RULES	int
:	O
chinese_rules	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_EXPERIMENTAL_OWL_EXT	int
:	O
experimental_owl_ext	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_SEMEAI_NODE_LIMIT	int
:	O
mandated_semeai_node_limit	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_EXPERIMENTAL_CONNECTIONS	int
:	O
experimental_connections	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_STANDARD_CONNECTIONS	int
:	O
experimental_connections	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_ALTERNATE_CONNECTIONS	int
:	O
alternate_connections	int
=	O
!	O
alternate_connections	int
;	O
break	O
;	O
case	O
OPT_WITH_BREAK_IN	int
:	O
experimental_break_in	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_WITHOUT_BREAK_IN	int
:	O
experimental_break_in	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_COSMIC_GNUGO	int
:	O
cosmic_gnugo	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_COSMIC_GNUGO	int
:	O
cosmic_gnugo	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_LARGE_SCALE	int
:	O
large_scale	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_LARGE_SCALE	int
:	O
large_scale	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_FORBID_SUICIDE	int
:	O
suicide_rule	enum(int,int,int)
=	O
FORBIDDEN	int
;	O
break	O
;	O
case	O
OPT_ALLOW_SUICIDE	int
:	O
suicide_rule	enum(int,int,int)
=	O
ALLOWED	int
;	O
break	O
;	O
case	O
OPT_ALLOW_ALL_SUICIDE	int
:	O
suicide_rule	enum(int,int,int)
=	O
ALL_ALLOWED	int
;	O
break	O
;	O
case	O
OPT_SIMPLE_KO	int
:	O
ko_rule	enum(int,int,int,int)
=	O
SIMPLE	int
;	O
break	O
;	O
case	O
OPT_NO_KO	int
:	O
ko_rule	enum(int,int,int,int)
=	O
NONE	int
;	O
break	O
;	O
case	O
OPT_POSITIONAL_SUPERKO	int
:	O
ko_rule	enum(int,int,int,int)
=	O
PSK	int
;	O
break	O
;	O
case	O
OPT_SITUATIONAL_SUPERKO	int
:	O
ko_rule	enum(int,int,int,int)
=	O
SSK	int
;	O
break	O
;	O
case	O
OPT_CAPTURE_ALL_DEAD	int
:	O
capture_all_dead	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_PLAY_OUT_AFTERMATH	int
:	O
play_out_aftermath	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_RESIGN_ALLOWED	int
:	O
resign_allowed	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NEVER_RESIGN	int
:	O
resign_allowed	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_MONTE_CARLO	int
:	O
use_monte_carlo_genmove	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_MC_GAMES_PER_LEVEL	int
:	O
mc_games_per_level	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_MC_PATTERNS	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>=	O
sizeof	O
(	O
mc_pattern_name	array(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Too long name given as value to --mc-patterns option.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
mc_pattern_name	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_MC_LIST_PATTERNS	int
:	O
list_mc_patterns	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_MC_LOAD_PATTERNS	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>=	O
sizeof	O
(	O
mc_pattern_filename	array(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Too long name given as value to --mc-load-patterns option.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
mc_pattern_filename	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_MODE	int
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"ascii"	*(char)
)	O
==	O
0	int
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_ASCII	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"gtp"	*(char)
)	O
==	O
0	int
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_GTP	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"gmp"	*(char)
)	O
==	O
0	int
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_GMP	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"sgmp"	*(char)
)	O
==	O
0	int
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_SGMP	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid mode selection: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_DECIDE_STRING	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_STRING	int
;	O
break	O
;	O
case	O
OPT_DECIDE_CONNECTION	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
7	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-connection [first string]/[second string]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
strtok	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
"/"	*(char)
)	O
;	O
decide_that	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
"/"	*(char)
)	O
;	O
if	O
(	O
!	O
decide_that	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-connection [first string]/[second string]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_CONNECTION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_OWL	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_OWL	int
;	O
break	O
;	O
case	O
OPT_DECIDE_DRAGON_DATA	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_DRAGON_DATA	int
;	O
break	O
;	O
case	O
OPT_DECIDE_SEMEAI	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
7	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
strtok	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
"/"	*(char)
)	O
;	O
decide_that	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
"/"	*(char)
)	O
;	O
if	O
(	O
!	O
decide_that	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_SEMEAI	int
;	O
break	O
;	O
case	O
OPT_DECIDE_TACTICAL_SEMEAI	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
7	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
strtok	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
"/"	*(char)
)	O
;	O
decide_that	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
"/"	*(char)
)	O
;	O
if	O
(	O
!	O
decide_that	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_TACTICAL_SEMEAI	int
;	O
break	O
;	O
case	O
OPT_DECIDE_POSITION	int
:	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_POSITION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_EYE	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_EYE	int
;	O
break	O
;	O
case	O
OPT_DECIDE_COMBINATION	int
:	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_COMBINATION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_SURROUNDED	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
decide_this	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_SURROUNDED	int
;	O
break	O
;	O
case	O
OPT_DECIDE_ORACLE	int
:	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_DECIDE_ORACLE	int
;	O
break	O
;	O
case	O
OPT_BRANCH_DEPTH	int
:	O
mandated_branch_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_BACKFILL2_DEPTH	int
:	O
mandated_backfill2_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_BREAK_CHAIN_DEPTH	int
:	O
mandated_break_chain_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_SUPERSTRING_DEPTH	int
:	O
mandated_superstring_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_AA_DEPTH	int
:	O
mandated_aa_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_OWL_DISTRUST	int
:	O
mandated_owl_distrust_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_OWL_BRANCH	int
:	O
mandated_owl_branch_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_OWL_READING	int
:	O
mandated_owl_reading_depth	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_OWL_NODE_LIMIT	int
:	O
mandated_owl_node_limit	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NOFUSEKIDB	int
:	O
fusekidb	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_NOFUSEKI	int
:	O
disable_fuseki	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NOJOSEKIDB	int
:	O
josekidb	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_LEVEL	int
:	O
set_level	(int)->(void)
(	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_MIN_LEVEL	int
:	O
set_min_level	(int)->(void)
(	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_MAX_LEVEL	int
:	O
set_max_level	(int)->(void)
(	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_LIMIT_SEARCH	int
:	O
{	O
int	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
gg_optarg	*(char)
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: use --limit-search <pos>\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
set_search_diamond	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_CLOCK_TIME	int
:	O
clock_settings	(int,int,int)->(void)
(	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_CLOCK_BYO_TIME	int
:	O
clock_settings	(int,int,int)->(void)
(	O
-	O
1	int
,	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_CLOCK_BYO_PERIOD	int
:	O
clock_settings	(int,int,int)->(void)
(	O
-	O
1	int
,	O
-	O
1	int
,	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_AUTOLEVEL	int
:	O
autolevel_on	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_DEBUG_INFLUENCE	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
gg_optarg	*(char)
)	O
>	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid board coordinate: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
debuginfluence_move	array(char)
,	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_REPLAY_GAME	int
:	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_REPLAY	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"white"	*(char)
)	O
==	O
0	int
)	O
replay_color	int
=	O
WHITE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"black"	*(char)
)	O
==	O
0	int
)	O
replay_color	int
=	O
BLACK	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"both"	*(char)
)	O
==	O
0	int
)	O
replay_color	int
=	O
GRAY	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid replay color: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_SCORE	int
:	O
scoringmode	*(char)
=	O
gg_optarg	*(char)
;	O
if	O
(	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MODE_UNKNOWN	int
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_LOAD_AND_SCORE	int
;	O
break	O
;	O
case	O
OPT_PRINTSGF	int
:	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_LOAD_AND_PRINT	int
;	O
printsgffile	*(char)
=	O
gg_optarg	*(char)
;	O
break	O
;	O
case	O
OPT_PROFILE_PATTERNS	int
:	O
profile_patterns	int
=	O
1	int
;	O
prepare_pattern_profiling	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
OPT_COLOR	int
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"white"	*(char)
)	O
==	O
0	int
)	O
mandated_color	int
=	O
WHITE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
gg_optarg	*(char)
,	O
"black"	*(char)
)	O
==	O
0	int
)	O
mandated_color	int
=	O
BLACK	int
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Invalid color selection: %s\n"	*(char)
,	O
gg_optarg	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_SHOWCOPYRIGHT	int
:	O
show_copyright	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_MIRROR	int
:	O
play_mirror_go	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_MIRROR_LIMIT	int
:	O
mirror_stones_limit	int
=	O
atoi	(*(char))->(int)
(	O
gg_optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
show_version	()->(void)
(	O
)	O
;	O
show_copyright	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
'h'	O
:	O
show_version	()->(void)
(	O
)	O
;	O
if	O
(	O
gg_optarg	*(char)
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
gg_optarg	*(char)
,	O
"debug"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
show_debug_help	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
gg_optind	int
<	O
argc	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
argv	*(*(char))
[	O
gg_optind	int
]	O
,	O
"debug"	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
show_debug_help	()->(void)
(	O
)	O
;	O
}	O
else	O
show_help	()->(void)
(	O
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_DEBUG_FLAGS	int
:	O
show_debug_flags	()->(void)
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_PRINT_LEVELS	int
:	O
{	O
int	O
lev	int
;	O
for	O
(	O
lev	int
=	O
12	int
;	O
lev	int
>=	O
0	int
;	O
lev	int
--	O
)	O
set_depth_values	(int,int)->(void)
(	O
lev	int
,	O
1	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
'?'	O
:	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `gnugo --help' for more information.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
requested_boardsize	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
check_boardsize	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
requested_boardsize	int
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
gnugo_clear_board	(int)->(void)
(	O
requested_boardsize	int
)	O
;	O
}	O
if	O
(	O
!	O
seed_specified	int
)	O
seed	int
=	O
time	(*(long))->(long)
(	O
0	int
)	O
;	O
init_gnugo	(float,int)->(void)
(	O
memory	float
,	O
seed	int
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
mc_pattern_filename	array(char)
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
mc_load_patterns_from_db	(*(char),*(int))->(int)
(	O
mc_pattern_filename	array(char)
,	O
NULL	O
)	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
strlen	(*(char))->(long)
(	O
mc_pattern_name	array(char)
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
choose_mc_patterns	(*(char))->(int)
(	O
mc_pattern_name	array(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown Monte Carlo pattern database name %s.\n"	*(char)
,	O
mc_pattern_name	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Use \"--mc-list-patterns\" to list the available databases.\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
infilename	*(char)
)	O
{	O
if	O
(	O
!	O
sgftree_readfile	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(int)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
infilename	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot open or parse '%s'\n"	*(char)
,	O
infilename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
gameinfo_play_sgftree_rot	(*(struct(int,int,struct(*(struct`),*(struct`)),int)),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char),int)->(int)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
untilstring	*(char)
,	O
orientation	int
)	O
==	O
EMPTY	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot load '%s'\n"	*(char)
,	O
infilename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
sgftreeCreateHeaderNode	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,float,int)->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
board_size	int
,	O
komi	float
,	O
handicap	int
)	O
;	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
game_record	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
=	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
;	O
if	O
(	O
debuginfluence_move	array(char)
[	O
0	int
]	O
)	O
{	O
int	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
debuginfluence_move	array(char)
)	O
;	O
debug_influence_move	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
if	O
(	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MODE_UNKNOWN	int
)	O
{	O
if	O
(	O
infilename	*(char)
)	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
MODE_LOAD_AND_ANALYZE	int
;	O
else	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
(	O
isatty	(int)->(int)
(	O
0	int
)	O
)	O
?	O
MODE_ASCII	int
:	O
MODE_GMP	int
;	O
}	O
if	O
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
MODE_LOAD_AND_PRINT	int
)	O
{	O
output_check	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
output_check	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error: could not open '%s' for writing\n"	*(char)
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output_check	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
switch	O
(	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
MODE_GMP	int
:	O
case	O
MODE_SGMP	int
:	O
resign_allowed	int
=	O
0	int
;	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
computer_player	int
=	O
mandated_color	int
;	O
play_gmp	(*(struct(int,int,struct(*(struct`),*(struct`)),int)),int)->(void)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
playmode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MODE_SGMP	int
)	O
;	O
break	O
;	O
case	O
MODE_SOLO	int
:	O
play_solo	(*(struct(int,int,struct(*(struct`),*(struct`)),int)),int)->(void)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
benchmark	int
)	O
;	O
break	O
;	O
case	O
MODE_REPLAY	int
:	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"You must use -l infile with replay mode.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
play_replay	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int)->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
replay_color	int
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_ANALYZE	int
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
to_move	int
=	O
mandated_color	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"You must use -l infile with load and analyze mode.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
load_and_analyze_sgf_file	(*(struct(int,int,struct(*(struct`),*(struct`)),int)))->(void)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_SCORE	int
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
to_move	int
=	O
mandated_color	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --score must be used with -l\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
load_and_score_sgf_file	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(int,int,struct(*(struct`),*(struct`)),int)),*(char))->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
scoringmode	*(char)
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_PRINT	int
:	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --printsgf must be used with -l\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
to_move	int
=	O
mandated_color	int
;	O
sgffile_printsgf	(int,*(char))->(void)
(	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
to_move	int
,	O
printsgffile	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_STRING	int
:	O
{	O
int	O
str	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-string must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
str	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-string: strange coordinate \n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_string	(int)->(void)
(	O
str	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_CONNECTION	int
:	O
{	O
int	O
str1	int
,	O
str2	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-connection must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str1	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
str1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-connection [first string]/[second string]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str2	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_that	*(char)
)	O
;	O
if	O
(	O
str2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-connection [first string]/[second string]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_connection	(int,int)->(void)
(	O
str1	int
,	O
str2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_OWL	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-dragon must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-dragon: strange coordinate \n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_owl	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_DRAGON_DATA	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-dragon-data must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-dragon-data: strange coordinate \n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_dragon_data	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_SEMEAI	int
:	O
{	O
int	O
pos1	int
,	O
pos2	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-semeai must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos1	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos2	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_that	*(char)
)	O
;	O
if	O
(	O
pos2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_semeai	(int,int)->(void)
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_TACTICAL_SEMEAI	int
:	O
{	O
int	O
pos1	int
,	O
pos2	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-tactical-semeai must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos1	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos2	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_that	*(char)
)	O
;	O
if	O
(	O
pos2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_tactical_semeai	(int,int)->(void)
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_POSITION	int
:	O
{	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-position must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_position	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_EYE	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-eye must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-eye: strange coordinate \n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_eye	(int)->(void)
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_COMBINATION	int
:	O
{	O
int	O
color	int
;	O
if	O
(	O
!	O
infilename	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: --decide-combination must be used with -l\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
color	int
=	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
to_move	int
;	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
color	int
=	O
mandated_color	int
;	O
decide_combination	(int)->(void)
(	O
color	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_SURROUNDED	int
:	O
{	O
int	O
pos	int
=	O
string_to_location	(int,*(char))->(int)
(	O
board_size	int
,	O
decide_this	array(char)
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage: --decide-surrounded [pos]\n"	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_surrounded	(int)->(void)
(	O
pos	int
)	O
;	O
break	O
;	O
}	O
case	O
MODE_GTP	int
:	O
{	O
FILE	struct
*	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
gtpfile	*(char)
!=	O
NULL	O
)	O
{	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
gtpfile	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: Cannot open file %s\n"	*(char)
,	O
gtpfile	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
else	O
if	O
(	O
gtp_tcp_ip_mode	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
port	int
=	O
65536	int
;	O
char	O
*	O
port_string	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
gtp_tcp_ip_address	*(char)
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
host_name	*(char)
=	O
NULL	O
;	O
if	O
(	O
port_string	*(char)
)	O
{	O
host_name	*(char)
=	O
gtp_tcp_ip_address	*(char)
;	O
*	O
port_string	*(char)
++	O
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
port_string	*(char)
,	O
"%u"	*(char)
,	O
&	O
port	int
)	O
;	O
}	O
else	O
sscanf	(*(char),*(char))->(int)
(	O
gtp_tcp_ip_address	*(char)
,	O
"%u"	*(char)
,	O
&	O
port	int
)	O
;	O
if	O
(	O
port	int
>	O
65535	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"A valid TCP/IP port number expected\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_CONNECT	int
)	O
{	O
socket_connect_to	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
host_name	*(char)
,	O
port	int
,	O
&	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
socket_listen_at	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
host_name	*(char)
,	O
port	int
,	O
&	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
gtp_dump_commands_file	*(char)
!=	O
NULL	O
)	O
{	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
gtp_dump_commands_file	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: Cannot open file %s\n"	*(char)
,	O
gtp_dump_commands_file	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
play_gtp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
orientation	int
)	O
;	O
if	O
(	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
gtp_dump_commands_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_CONNECT	int
)	O
socket_close_connection	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_LISTEN	int
)	O
socket_stop_listening	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
gtp_input_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_output_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
break	O
;	O
case	O
MODE_ASCII	int
:	O
default	O
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
.	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
mandated_color	int
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
show_version	()->(void)
(	O
)	O
;	O
show_copyright	()->(void)
(	O
)	O
;	O
}	O
play_ascii	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(int,int,struct(*(struct`),*(struct`)),int)),*(char),*(char))->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
infilename	*(char)
,	O
untilstring	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
profile_patterns	int
)	O
report_pattern_profiling	()->(void)
(	O
)	O
;	O
sgfFreeNode	(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
.	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
show_version	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"GNU Go %s\n"	*(char)
,	O
VERSION	*(char)
)	O
;	O
}	O
static	O
void	O
show_help	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
USAGE	*(char)
,	O
DEFAULT_LEVEL	int
)	O
;	O
printf	(*(char))->(int)
(	O
USAGE1	*(char)
,	O
MIN_BOARD	int
,	O
MAX_BOARD	int
,	O
MAX_HANDICAP	int
)	O
;	O
printf	(*(char))->(int)
(	O
USAGE2	*(char)
,	O
DEFAULT_MEMORY	O
<=	O
0	int
?	O
reading_cache_default_size	()->(float)
(	O
)	O
:	O
(	O
float	O
)	O
DEFAULT_MEMORY	O
)	O
;	O
}	O
static	O
void	O
show_debug_help	()->(void)
(	O
void	O
)	O
{	O
set_depth_values	(int,int)->(void)
(	O
DEFAULT_LEVEL	int
,	O
0	int
)	O
;	O
printf	(*(char))->(int)
(	O
USAGE_DEBUG	*(char)
USAGE_DEBUG2	*(char)
,	O
DEFAULT_LEVEL	int
,	O
depth	int
,	O
backfill_depth	int
,	O
fourlib_depth	int
,	O
ko_depth	int
,	O
branch_depth	int
,	O
backfill2_depth	int
,	O
break_chain_depth	int
,	O
superstring_depth	int
,	O
aa_depth	int
,	O
owl_distrust_depth	int
,	O
owl_branch_depth	int
,	O
owl_reading_depth	int
,	O
owl_node_limit	int
,	O
semeai_node_limit	int
)	O
;	O
}	O
static	O
void	O
show_debug_flags	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
DEBUG_FLAGS	*(char)
)	O
;	O
}	O
static	O
void	O
show_copyright	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
COPYRIGHT	*(char)
)	O
;	O
}	O
static	O
void	O
socket_connect_to	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
const	O
char	O
*	O
host_name	*(char)
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
address	struct(short,short,struct(int),array(char))
;	O
int	O
connection_socket	int
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
char	O
*	O
*	O
address_pointer	*(*(char))
;	O
init_sockets	O
(	O
)	O
;	O
if	O
(	O
!	O
host_name	*(char)
)	O
host_name	*(char)
=	O
"127.0.0.1"	*(char)
;	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
host_name	*(char)
)	O
;	O
if	O
(	O
!	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
||	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addrtype	int
!=	O
AF_INET	O
||	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_length	int
!=	O
sizeof	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to resolve host name `%s'\n"	*(char)
,	O
host_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
connection_socket	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
connection_socket	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unexpected error: failed to create a socket\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
address	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
address	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
port	int
)	O
;	O
for	O
(	O
address_pointer	*(*(char))
=	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
;	O
*	O
address_pointer	*(*(char))
;	O
address_pointer	*(*(char))
++	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
*	O
address_pointer	*(*(char))
,	O
sizeof	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
;	O
if	O
(	O
connect	(int,*(struct(short,array(char))),int)->(int)
(	O
connection_socket	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
address	struct(short,short,struct(int),array(char))
,	O
sizeof	O
address	struct(short,short,struct(int),array(char))
)	O
!=	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
*	O
address_pointer	*(*(char))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to connect to %s:%u\n"	*(char)
,	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_name	*(char)
,	O
port	int
)	O
;	O
closesocket	O
(	O
connection_socket	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
connection_socket	int
,	O
"r"	*(char)
)	O
;	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dup	(int)->(int)
(	O
connection_socket	int
)	O
,	O
"w"	*(char)
)	O
;	O
}	O
static	O
void	O
socket_listen_at	(*(char),int,*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))->(void)
(	O
const	O
char	O
*	O
host_name	*(char)
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
address	struct(short,short,struct(int),array(char))
;	O
int	O
listening_socket	int
;	O
int	O
connection_socket	int
;	O
init_sockets	O
(	O
)	O
;	O
if	O
(	O
host_name	*(char)
)	O
{	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
host_name	*(char)
)	O
;	O
if	O
(	O
!	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
||	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addrtype	int
!=	O
AF_INET	O
||	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_length	int
!=	O
sizeof	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to resolve host name `%s'\n"	*(char)
,	O
host_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
host_name	*(char)
=	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_name	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
host_data	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
[	O
0	int
]	O
,	O
sizeof	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
;	O
}	O
else	O
address	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
htonl	(int)->(int)
(	O
INADDR_ANY	O
)	O
;	O
listening_socket	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
listening_socket	int
==	O
-	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unexpected error: failed to create a socket\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
address	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
address	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
port	int
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
host_name	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Waiting for a connection on %s:%u...\n"	*(char)
,	O
host_name	*(char)
,	O
port	int
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Waiting for a connection on port %u...\n"	*(char)
,	O
port	int
)	O
;	O
}	O
if	O
(	O
bind	(int,*(struct(short,array(char))),int)->(int)
(	O
listening_socket	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
address	struct(short,short,struct(int),array(char))
,	O
sizeof	O
address	struct(short,short,struct(int),array(char))
)	O
==	O
-	O
1	int
||	O
listen	(int,int)->(int)
(	O
listening_socket	int
,	O
0	int
)	O
==	O
-	O
1	int
||	O
(	O
connection_socket	int
=	O
accept	(int,*(struct(short,array(char))),*(int))->(int)
(	O
listening_socket	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
host_name	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to listen on %s:%u\n"	*(char)
,	O
host_name	*(char)
,	O
port	int
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Failed to listen on port %u\n"	*(char)
,	O
port	int
)	O
;	O
closesocket	O
(	O
listening_socket	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
closesocket	O
(	O
listening_socket	int
)	O
;	O
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
connection_socket	int
,	O
"r"	*(char)
)	O
;	O
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dup	(int)->(int)
(	O
connection_socket	int
)	O
,	O
"w"	*(char)
)	O
;	O
}	O
static	O
void	O
socket_close_connection	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
}	O
static	O
void	O
socket_stop_listening	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
FILE	struct
*	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
{	O
int	O
buffer	array(int)
[	O
0x1000	int
]	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Waiting for the client to disconnect...\n"	*(char)
)	O
;	O
do	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	array(int)
,	O
sizeof	O
buffer	array(int)
,	O
1	int
,	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output_file	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
}	O
