int	O
gdbm_close	(*(struct))->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
int	O
syserrno	int
;	O
gdbm_set_errno	(*(struct),int,int)->(void)
(	O
dbf	*(struct)
,	O
GDBM_NO_ERROR	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
dbf	*(struct)
->	O
desc	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
dbf	*(struct)
->	O
read_write	int
!=	O
GDBM_READER	int
)	O
gdbm_file_sync	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
dbf	*(struct)
)	O
;	O
_gdbm_mapped_unmap	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
dbf	*(struct)
->	O
file_locking	int
)	O
_gdbm_unlock_file	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
close	(int)->(int)
(	O
dbf	*(struct)
->	O
desc	int
)	O
)	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_FILE_CLOSE_ERROR	int
,	O
FALSE	int
)	O
;	O
}	O
syserrno	int
=	O
gdbm_last_syserr	(*(struct))->(int)
(	O
dbf	*(struct)
)	O
;	O
gdbm_clear_error	(*(struct))->(void)
(	O
dbf	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
dir	long
)	O
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
!=	O
NULL	O
)	O
{	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
cache_size	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
dptr	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
gdbm_errno	O
)	O
{	O
errno	O
=	O
syserrno	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
