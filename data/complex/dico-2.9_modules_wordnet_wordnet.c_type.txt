struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
{	O
char	O
*	O
dbname	*(char)
;	O
int	O
flags	int
;	O
int	O
pos	int
;	O
int	O
optc	int
;	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
*	O
optv	*(*(struct))
;	O
}	O
;	O
static	O
int	O
_dico_display_message	(*(char))->(int)
(	O
char	O
*	O
msg	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"WordNet: %s"	*(char)
,	O
msg	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
wn_free_db	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
)	O
hp	*(struct)
;	O
free	(*(void))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
dbname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
)	O
;	O
free	(*(void))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
wn_register_strategies	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
wn_free_result	(*(struct))->(void)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
;	O
static	O
int	O
wn_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
wnsearchdir	*(char)
=	O
NULL	O
;	O
char	O
*	O
wnhome	*(char)
=	O
NULL	O
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
wnsearchdir	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
wnsearchdir	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
wnhome	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
wnhome	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
display_message	O
=	O
_dico_display_message	(*(char))->(int)
;	O
if	O
(	O
wnhome	*(char)
)	O
setenv	(*(char),*(char),int)->(int)
(	O
"WNHOME"	*(char)
,	O
wnhome	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
wnsearchdir	*(char)
)	O
setenv	(*(char),*(char),int)->(int)
(	O
"WNSEARCHDIR"	*(char)
,	O
wnsearchdir	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
wninit	()->(int)
(	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open wordnet database"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
wn_register_strategies	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
pos_choice	array(*(char))
[	O
]	O
=	O
{	O
"all"	*(char)
,	O
"noun"	*(char)
,	O
"verb"	*(char)
,	O
"adj"	*(char)
,	O
"adjective"	*(char)
,	O
"adv"	*(char)
,	O
"adverb"	*(char)
,	O
"satellite"	*(char)
,	O
"adjsat"	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
pos_trans	array(int)
[	O
]	O
=	O
{	O
ALL_POS	O
,	O
NOUN	O
,	O
VERB	O
,	O
ADJ	O
,	O
ADJ	O
,	O
ADV	O
,	O
ADV	O
,	O
ADJSAT	O
,	O
ADJSAT	O
}	O
;	O
struct	O
result	*(int)
;	O
static	O
void	O
_wn_print_overview	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
)	O
;	O
static	O
void	O
_wn_print_definition	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
;	O
static	O
void	O
_wn_print_hypernym	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
)	O
;	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
{	O
char	O
*	O
option	*(char)
;	O
int	O
search	int
;	O
int	O
posmask	int
;	O
char	O
*	O
label	*(char)
;	O
void	O
(	O
*	O
tracer	*(()->(void))
)	O
(	O
SynsetPtr	int
)	O
;	O
void	O
(	O
*	O
printer	*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void))
)	O
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	*(int)
*	O
,	O
dico_stream_t	*(struct)
)	O
;	O
}	O
;	O
static	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
wn_optlist	array(struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*`,int,int,*`,*`,*`)),int,*(struct),*(struct))->(void))))
[	O
]	O
=	O
{	O
{	O
"hypernym"	*(char)
,	O
HYPERPTR	O
,	O
POS_MASK	O
(	O
NOUN	O
)	O
|	O
POS_MASK	O
(	O
VERB	O
)	O
,	O
"Synonyms/Hypernyms (Ordered by Estimated Frequency)"	*(char)
,	O
NULL	O
,	O
_wn_print_hypernym	(*(struct),int,*(struct),*(struct))->(void)
}	O
,	O
{	O
"synonym"	*(char)
,	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
find_option	(*(char))->(*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))))
(	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
wn_optlist	array(struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*`,int,int,*`,*`,*`)),int,*(struct),*(struct))->(void))))
;	O
p	*(char)
->	O
option	*(char)
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
option	*(char)
,	O
text	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(char)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
dico_handle_t	*(struct)
wn_init_db	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
dbname	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
int	O
pos	int
=	O
0	int
;	O
int	O
idx	int
,	O
i	int
,	O
j	int
;	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
*	O
optv	*(*(struct))
;	O
int	O
optc	int
;	O
int	O
flags	int
=	O
0	int
;	O
static	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
overview	array(struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*`,int,int,*`,*`,*`)),int,*(struct),*(struct))->(void))))
[	O
2	int
]	O
=	O
{	O
{	O
"overview"	*(char)
,	O
OVERVIEW	O
,	O
PM_ALL	int
,	O
"Overview"	*(char)
,	O
NULL	O
,	O
_wn_print_overview	(*(struct),int,*(struct),*(struct))->(void)
}	O
,	O
{	O
"overview"	*(char)
,	O
OVERVIEW	O
,	O
PM_ALL	int
,	O
"Overview"	*(char)
,	O
NULL	O
,	O
_wn_print_definition	(*(struct),int,*(struct),*(struct))->(void)
}	O
}	O
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
init_db_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
pos	int
)	O
,	O
dico_opt_enum	int
,	O
&	O
pos	int
,	O
{	O
.	O
enumstr	*(*(char))
=	O
pos_choice	array(*(char))
}	O
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
merge	O
-	O
defs	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
flags	int
,	O
{	O
.	O
value	*(char)
=	O
WNDB_MERGE_DEFS	int
}	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
init_db_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
DICO_PARSEOPT_PERMUTE	int
,	O
&	O
idx	int
)	O
)	O
return	O
NULL	O
;	O
argc	int
-=	O
idx	int
;	O
argv	*(*(char))
+=	O
idx	int
;	O
optc	int
=	O
argc	int
+	O
1	int
;	O
optv	*(*(struct))
=	O
calloc	(long,long)->(*(void))
(	O
optc	int
,	O
sizeof	O
(	O
optv	*(*(struct))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
optv	*(*(struct))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
optv	*(*(struct))
[	O
0	int
]	O
=	O
overview	array(struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*`,int,int,*`,*`,*`)),int,*(struct),*(struct))->(void))))
+	O
(	O
(	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
p	*(char)
;	O
if	O
(	O
(	O
p	*(char)
=	O
find_option	(*(char))->(*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"wordnet: unknown option %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
optv	*(*(struct))
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
p	*(char)
->	O
search	int
==	O
0	int
&&	O
p	*(char)
>	O
wn_optlist	array(struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*`,int,int,*`,*`,*`)),int,*(struct),*(struct))->(void))))
)	O
p	*(char)
--	O
;	O
if	O
(	O
!	O
p	*(char)
->	O
printer	*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"wordnet: option %s is not yet supported"	*(char)
)	O
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
optv	*(*(struct))
[	O
j	int
]	O
=	O
p	*(char)
;	O
}	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
)	O
;	O
if	O
(	O
!	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
optv	*(*(struct))
)	O
;	O
return	O
NULL	O
;	O
}	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
dbname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
dbname	*(char)
)	O
;	O
if	O
(	O
!	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
dbname	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
;	O
return	O
NULL	O
;	O
}	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
flags	int
=	O
flags	int
;	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
pos	int
=	O
pos_trans	array(int)
[	O
pos	int
]	O
;	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optc	int
=	O
optc	int
;	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
=	O
optv	*(*(struct))
;	O
return	O
(	O
dico_handle_t	*(struct)
)	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
}	O
static	O
char	O
*	O
wn_descr	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
return	O
strdup	(*(char))->(*(char))
(	O
"WordNet dictionary"	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
wn_info	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
return	O
strdup	(*(char))->(*(char))
(	O
license	O
)	O
;	O
}	O
static	O
int	O
wn_lang	(*(struct),array(*(struct)))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
dico_list_t	*(struct)
list	array(*(struct))
[	O
2	int
]	O
)	O
{	O
if	O
(	O
(	O
list	array(*(struct))
[	O
0	int
]	O
=	O
dico_list_create	()->(*(struct))
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
list	array(*(struct))
[	O
1	int
]	O
=	O
dico_list_create	()->(*(struct))
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	array(*(struct))
[	O
0	int
]	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
[	O
0	int
]	O
,	O
strdup	(*(char))->(*(char))
(	O
"en"	*(char)
)	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
[	O
1	int
]	O
,	O
strdup	(*(char))->(*(char))
(	O
"en"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
wordbuf	*(int)
{	O
char	O
*	O
word	*(char)
;	O
size_t	long
len	int
;	O
size_t	long
size	long
;	O
}	O
;	O
static	O
int	O
wordbuf_expand	(*(struct(*(char),long,long)),long)->(int)
(	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
,	O
size_t	long
len	int
)	O
{	O
if	O
(	O
len	int
>=	O
wb	*(struct(*(char),long,long))
->	O
size	long
)	O
{	O
size_t	long
size	long
=	O
(	O
(	O
len	int
+	O
WORDBUFINC	int
-	O
1	int
)	O
/	O
WORDBUFINC	int
)	O
*	O
WORDBUFINC	int
;	O
char	O
*	O
newword	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
!	O
newword	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
=	O
newword	*(char)
;	O
wb	*(struct(*(char),long,long))
->	O
size	long
=	O
size	long
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
wordbuf_grow	(*(struct(*(char),long,long)),int)->(int)
(	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
,	O
int	O
c	int
)	O
{	O
if	O
(	O
wordbuf_expand	(*(struct(*(char),long,long)),long)->(int)
(	O
wb	*(struct(*(char),long,long))
,	O
wb	*(struct(*(char),long,long))
->	O
len	int
+	O
1	int
)	O
)	O
return	O
1	int
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
wb	*(struct(*(char),long,long))
->	O
len	int
++	O
]	O
=	O
c	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
wordbuf_finish	(*(struct(*(char),long,long)))->(int)
(	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
)	O
{	O
if	O
(	O
wordbuf_expand	(*(struct(*(char),long,long)),long)->(int)
(	O
wb	*(struct(*(char),long,long))
,	O
wb	*(struct(*(char),long,long))
->	O
len	int
+	O
1	int
)	O
)	O
return	O
1	int
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
wb	*(struct(*(char),long,long))
->	O
len	int
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
wordbuf_reverse	(*(struct(*(char),long,long)))->(void)
(	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
wb	*(struct(*(char),long,long))
->	O
len	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
wb	*(struct(*(char),long,long))
->	O
len	int
-	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
,	O
j	int
--	O
)	O
{	O
int	O
c	int
=	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
j	int
]	O
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
j	int
]	O
=	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
=	O
c	int
;	O
}	O
}	O
enum	O
result_type	enum(int,int)
{	O
result_match	int
,	O
result_define	int
}	O
;	O
struct	O
defn	struct(int,*(int))
{	O
int	O
pos	int
;	O
SynsetPtr	int
*	O
synset	*(int)
;	O
}	O
;	O
struct	O
result	*(int)
{	O
enum	O
result_type	enum(int,int)
type	enum(int,int,int)
;	O
size_t	long
compare_count	long
;	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
char	O
*	O
searchword	*(char)
;	O
dico_list_t	*(struct)
rootlist	*(struct)
;	O
}	O
;	O
static	O
int	O
free_defn	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
defn	struct(int,*(int))
*	O
dp	*(struct(int,*(int)))
=	O
item	*(void)
;	O
free	(*(void))->(void)
(	O
dp	*(struct(int,*(int)))
->	O
synset	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
dp	*(struct(int,*(int)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_root_synset	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
free_syns	()->(int)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_string	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_words	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
return	O
utf8_strcasecmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
a	*(struct)
,	O
(	O
char	O
*	O
)	O
b	*(struct)
)	O
;	O
}	O
static	O
struct	O
result	*(int)
*	O
wn_create_match_result	(*(struct(*(char),int,int,int,*(*(struct`)))))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
;	O
res	*(struct)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
res	*(struct)
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(struct)
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
res	*(struct)
->	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
res	*(struct)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
free_string	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
compare_words	(*(void),*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
dico_list_set_flags	(*(struct),int)->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
return	O
res	*(struct)
;	O
}	O
static	O
struct	O
result	*(int)
*	O
wn_create_define_result	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
const	O
char	O
*	O
searchword	*(char)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
;	O
res	*(struct)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
res	*(struct)
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(struct)
->	O
type	enum(int,int,int)
=	O
result_define	int
;	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
res	*(struct)
->	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
res	*(struct)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
free_defn	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
res	*(struct)
->	O
searchword	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
searchword	*(char)
)	O
;	O
if	O
(	O
!	O
res	*(struct)
->	O
searchword	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
}	O
res	*(struct)
->	O
rootlist	*(struct)
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
res	*(struct)
->	O
rootlist	*(struct)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
}	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
res	*(struct)
->	O
rootlist	*(struct)
,	O
free_root_synset	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
return	O
res	*(struct)
;	O
}	O
static	O
int	O
wn_match_result_add	(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
const	O
char	O
*	O
hw	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
s	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
hw	*(char)
)	O
;	O
if	O
(	O
!	O
s	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
dico_list_insert_sorted	(*(struct),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
!=	O
EEXIST	int
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
skipeol	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
}	O
static	O
void	O
skipheader	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
' '	O
)	O
skipeol	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
int	O
getword	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
)	O
{	O
int	O
c	int
;	O
size_t	long
i	int
;	O
wordbuf_start	O
(	O
wb	*(struct(*(char),long,long))
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
' '	O
)	O
break	O
;	O
if	O
(	O
wordbuf_grow	(*(struct(*(char),long,long)),int)->(int)
(	O
wb	*(struct(*(char),long,long))
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
wb	*(struct(*(char),long,long))
->	O
len	int
==	O
0	int
&&	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
wordbuf_finish	(*(struct(*(char),long,long)))->(int)
(	O
wb	*(struct(*(char),long,long))
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
==	O
'_'	O
)	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
lineback	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
struct	O
wordbuf	*(int)
*	O
wb	*(struct(*(char),long,long))
)	O
{	O
int	O
c	int
,	O
i	int
;	O
wordbuf_start	O
(	O
wb	*(struct(*(char),long,long))
)	O
;	O
while	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
-	O
2	int
,	O
SEEK_CUR	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
wordbuf_grow	(*(struct(*(char),long,long)),int)->(int)
(	O
wb	*(struct(*(char),long,long))
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
wordbuf_finish	(*(struct(*(char),long,long)))->(int)
(	O
wb	*(struct(*(char),long,long))
)	O
)	O
return	O
-	O
1	int
;	O
wordbuf_reverse	(*(struct(*(char),long,long)))->(void)
(	O
wb	*(struct(*(char),long,long))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
==	O
' '	O
)	O
break	O
;	O
else	O
if	O
(	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
==	O
'_'	O
)	O
wb	*(struct(*(char),long,long))
->	O
word	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
wn_is_defined	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(int)
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
char	O
*	O
searchword	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
unsigned	O
int	O
search	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
search	int
=	O
is_defined	()->(int)
(	O
searchword	*(char)
,	O
i	int
)	O
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optc	int
;	O
j	int
++	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
!	O
(	O
POS_MASK	O
(	O
i	int
)	O
&	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
j	int
]	O
->	O
posmask	int
)	O
)	O
continue	O
;	O
n	long
=	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
j	int
]	O
->	O
search	int
;	O
if	O
(	O
n	long
<	O
0	int
)	O
n	long
=	O
-	O
n	long
;	O
if	O
(	O
bit	()->(int)
(	O
n	long
)	O
&	O
search	int
)	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
wn_foreach_db	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(char),*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))->(void)
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
int	O
dbn	int
,	O
char	O
*	O
searchword	*(char)
,	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
key	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct)
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
indexfps	O
[	O
dbn	int
]	O
;	O
struct	O
wordbuf	*(int)
wb	*(struct(*(char),long,long))
=	O
INIT_WORDBUF	O
;	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
char	O
*	O
word	*(char)
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
for	O
(	O
skipheader	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
getword	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
wb	*(struct(*(char),long,long))
)	O
==	O
0	int
;	O
skipeol	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
res	*(struct)
->	O
compare_count	long
++	O
;	O
if	O
(	O
dico_key_match	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
key	*(char)
,	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
)	O
{	O
if	O
(	O
wn_match_result_add	(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
res	*(struct)
,	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
)	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
;	O
itr	*((*(void),*(void))->(int))
=	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
res	*(struct)
->	O
list	array(*(struct))
)	O
;	O
for	O
(	O
word	*(char)
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
word	*(char)
;	O
word	*(char)
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
if	O
(	O
!	O
wn_is_defined	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(int)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
word	*(char)
)	O
)	O
dico_iterator_remove_current	(*(struct),*(*(void)))->(void)
(	O
itr	*((*(void),*(void))->(int))
,	O
NULL	O
)	O
;	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
static	O
struct	O
result	*(int)
*	O
wn_foreach	(*(struct(*(char),int,int,int,*(*(struct`)))),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
=	O
wn_create_match_result	(*(struct(*(char),int,int,int,*(*(struct`)))))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
)	O
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
key	*(char)
;	O
char	O
*	O
searchword	*(char)
;	O
searchword	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
word	*(char)
)	O
;	O
strtolower	()->(int)
(	O
strsubst	()->(int)
(	O
searchword	*(char)
,	O
' '	O
,	O
'_'	O
)	O
)	O
;	O
if	O
(	O
!	O
searchword	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
&	O
key	*(char)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: key initialization failed"	*(char)
)	O
,	O
__func__	O
)	O
;	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
searchword	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
pos	int
==	O
ALL_POS	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
wn_foreach_db	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(char),*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
i	int
,	O
searchword	*(char)
,	O
&	O
key	*(char)
,	O
res	*(struct)
)	O
;	O
}	O
else	O
wn_foreach_db	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(char),*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))->(void)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
pos	int
,	O
searchword	*(char)
,	O
&	O
key	*(char)
,	O
res	*(struct)
)	O
;	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
&	O
key	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
searchword	*(char)
)	O
;	O
if	O
(	O
dico_list_count	(*(struct))->(long)
(	O
res	*(struct)
->	O
list	array(*(struct))
)	O
==	O
0	int
)	O
{	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	*(struct)
;	O
}	O
static	O
off_t	long
wn_bsearch	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*((*(char),*(void))->(int)))->(long)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
void	O
*	O
key	*(char)
,	O
int	O
(	O
*	O
cmp	*((*(void),*(void),*(void))->(int))
)	O
(	O
const	O
char	O
*	O
a	*(struct)
,	O
void	O
*	O
b	*(struct)
)	O
)	O
{	O
long	O
top	long
,	O
mid	long
,	O
bot	long
,	O
diff	long
;	O
struct	O
wordbuf	*(int)
wb	*(struct(*(char),long,long))
=	O
INIT_WORDBUF	O
;	O
off_t	long
last_match	long
=	O
-	O
1	int
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
top	long
=	O
0	int
;	O
bot	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
mid	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
do	O
{	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
mid	long
-	O
1	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
mid	long
!=	O
1	int
)	O
skipeol	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
getword	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
wb	*(struct(*(char),long,long))
)	O
)	O
break	O
;	O
if	O
(	O
cmp	*((*(void),*(void),*(void))->(int))
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
,	O
key	*(char)
)	O
<	O
0	int
)	O
{	O
top	long
=	O
mid	long
;	O
diff	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
mid	long
=	O
top	long
+	O
diff	long
;	O
}	O
else	O
if	O
(	O
cmp	*((*(void),*(void),*(void))->(int))
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
,	O
key	*(char)
)	O
>	O
0	int
)	O
{	O
bot	long
=	O
mid	long
;	O
diff	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
mid	long
=	O
top	long
+	O
diff	long
;	O
}	O
else	O
{	O
do	O
last_match	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
lineback	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
wb	*(struct(*(char),long,long))
)	O
==	O
0	int
&&	O
cmp	*((*(void),*(void),*(void))->(int))
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
,	O
key	*(char)
)	O
==	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
diff	long
)	O
;	O
free	(*(void))->(void)
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
;	O
return	O
last_match	long
;	O
}	O
static	O
struct	O
result	*(int)
*	O
wn_exact_match	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
db	*(char)
,	O
const	O
char	O
*	O
hw	*(char)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
;	O
if	O
(	O
!	O
wn_is_defined	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(int)
(	O
db	*(char)
,	O
(	O
char	O
*	O
)	O
hw	*(char)
)	O
)	O
return	O
NULL	O
;	O
res	*(struct)
=	O
wn_create_match_result	(*(struct(*(char),int,int,int,*(*(struct`)))))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
db	*(char)
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
strdup	(*(char))->(*(char))
(	O
hw	*(char)
)	O
)	O
;	O
return	O
res	*(struct)
;	O
}	O
struct	O
prefix	struct(*(char),long)
{	O
const	O
char	O
*	O
str	*(struct)
;	O
size_t	long
len	int
;	O
}	O
;	O
static	O
int	O
cmp_pref	(*(char),*(void))->(int)
(	O
const	O
char	O
*	O
hw	*(char)
,	O
void	O
*	O
key	*(char)
)	O
{	O
struct	O
prefix	struct(*(char),long)
*	O
pref	*(struct(*(char),long))
=	O
key	*(char)
;	O
return	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
hw	*(char)
,	O
pref	*(struct(*(char),long))
->	O
str	*(struct)
,	O
pref	*(struct(*(char),long))
->	O
len	int
)	O
;	O
}	O
static	O
struct	O
result	*(int)
*	O
wn_prefix_match	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
db	*(char)
,	O
const	O
char	O
*	O
hw	*(char)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
;	O
int	O
i	int
;	O
struct	O
prefix	struct(*(char),long)
pfx	struct(*(char),long)
;	O
struct	O
wordbuf	*(int)
wb	*(struct(*(char),long,long))
=	O
INIT_WORDBUF	O
;	O
res	*(struct)
=	O
wn_create_match_result	(*(struct(*(char),int,int,int,*(*(struct`)))))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
db	*(char)
)	O
;	O
if	O
(	O
!	O
res	*(struct)
)	O
return	O
NULL	O
;	O
pfx	struct(*(char),long)
.	O
str	*(struct)
=	O
hw	*(char)
;	O
pfx	struct(*(char),long)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
hw	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
indexfps	O
[	O
i	int
]	O
;	O
off_t	long
off	long
;	O
off	long
=	O
wn_bsearch	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void),*((*(char),*(void))->(int)))->(long)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
pfx	struct(*(char),long)
,	O
cmp_pref	(*(char),*(void))->(int)
)	O
;	O
if	O
(	O
off	long
!=	O
-	O
1	int
)	O
{	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
off	long
,	O
SEEK_SET	int
)	O
;	O
for	O
(	O
;	O
getword	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),long,long)))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
wb	*(struct(*(char),long,long))
)	O
==	O
0	int
&&	O
cmp_pref	(*(char),*(void))->(int)
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
,	O
&	O
pfx	struct(*(char),long)
)	O
==	O
0	int
;	O
skipeol	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
wn_match_result_add	(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
res	*(struct)
,	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
)	O
break	O
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
wb	*(struct(*(char),long,long))
.	O
word	*(char)
)	O
;	O
if	O
(	O
dico_list_count	(*(struct))->(long)
(	O
res	*(struct)
->	O
list	array(*(struct))
)	O
==	O
0	int
)	O
{	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	*(struct)
;	O
}	O
typedef	O
struct	O
result	*(int)
*	O
(	O
*	O
wn_matcher_t	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
)	O
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
db	*(char)
,	O
const	O
char	O
*	O
hw	*(char)
)	O
;	O
struct	O
strategy_def	struct(struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`))))))
{	O
struct	O
dico_strategy	struct(*(char),*(char),*((int,*(struct),*(char))->(int)),*(void),int,*(struct))
strat	*(struct)
;	O
wn_matcher_t	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
matcher	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
;	O
}	O
;	O
static	O
struct	O
strategy_def	struct(struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`))))))
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	*(char)
,	O
"Match words exactly"	*(char)
}	O
,	O
wn_exact_match	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
}	O
,	O
{	O
{	O
"prefix"	*(char)
,	O
"Match word prefixes"	*(char)
}	O
,	O
wn_prefix_match	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
}	O
,	O
}	O
;	O
static	O
wn_matcher_t	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
wn_find_matcher	(*(char))->(*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`)))))
(	O
const	O
char	O
*	O
strat	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
strat	*(struct)
,	O
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
[	O
i	int
]	O
.	O
strat	*(struct)
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
[	O
i	int
]	O
.	O
matcher	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
wn_register_strategies	()->(void)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
)	O
;	O
i	int
++	O
)	O
dico_strategy_add	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
&	O
stratdef	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`))))))
[	O
i	int
]	O
.	O
strat	*(struct)
)	O
;	O
}	O
static	O
char	O
*	O
nornmalize_search_word	(*(char))->(*(char))
(	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
char	O
*	O
copy	*(char)
=	O
NULL	O
;	O
char	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
q	*(char)
;	O
copy	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
copy	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
p	*(char)
=	O
copy	*(char)
,	O
q	*(char)
=	O
word	*(char)
;	O
*	O
q	*(char)
;	O
)	O
{	O
if	O
(	O
ISSPACE	O
(	O
*	O
q	*(char)
)	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
'_'	O
;	O
do	O
q	*(char)
++	O
;	O
while	O
(	O
*	O
q	*(char)
&&	O
ISSPACE	O
(	O
*	O
q	*(char)
)	O
)	O
;	O
}	O
else	O
*	O
p	*(char)
++	O
=	O
*	O
q	*(char)
++	O
;	O
}	O
*	O
p	*(char)
=	O
0	int
;	O
strtolower	()->(int)
(	O
copy	*(char)
)	O
;	O
return	O
copy	*(char)
;	O
}	O
static	O
dico_result_t	*(struct)
wn_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
)	O
hp	*(struct)
;	O
wn_matcher_t	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
match	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
=	O
wn_find_matcher	(*(char))->(*((*(struct(*`,int,int,int,*`)),*(char))->(*(struct(enum(int,int),long,*`,*`,*`,*`,*`)))))
(	O
strat	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
match	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
)	O
return	O
(	O
dico_result_t	*(struct)
)	O
match	*((*(struct(*(char),int,int,int,*(*`))),*(char))->(*(struct(enum(int,int),long,*(struct`),*(struct`),*(struct`),*(char),*(struct`)))))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
word	*(char)
)	O
;	O
else	O
if	O
(	O
strat	*(struct)
->	O
sel	*((*(char),*(void))->(int))
)	O
return	O
(	O
dico_result_t	*(struct)
)	O
wn_foreach	(*(struct(*(char),int,int,int,*(*(struct`)))),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
strat	*(struct)
,	O
word	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
defn	struct(int,*(int))
*	O
create_defn	(*(struct(*(char),int,int,int,*(*(struct`)))),int)->(*(struct(int,*(int))))
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
int	O
pos	int
)	O
{	O
struct	O
defn	struct(int,*(int))
*	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
p	*(char)
->	O
synset	*(int)
=	O
calloc	(long,long)->(*(void))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optc	int
,	O
sizeof	O
(	O
p	*(char)
->	O
synset	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
->	O
synset	*(int)
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
p	*(char)
->	O
pos	int
=	O
pos	int
;	O
return	O
p	*(char)
;	O
}	O
static	O
int	O
search_defns	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
int	O
pos	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
const	O
char	O
*	O
searchword	*(char)
)	O
{	O
SynsetPtr	int
sp	int
;	O
int	O
i	int
;	O
struct	O
defn	struct(int,*(int))
*	O
dp	*(struct(int,*(int)))
;	O
int	O
sense	int
=	O
0	int
;	O
sp	int
=	O
findtheinfo_ds	()->(int)
(	O
(	O
char	O
*	O
)	O
searchword	*(char)
,	O
pos	int
,	O
OVERVIEW	O
,	O
ALLSENSES	O
)	O
;	O
if	O
(	O
!	O
sp	int
)	O
return	O
0	int
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
res	*(struct)
->	O
rootlist	*(struct)
,	O
sp	int
)	O
;	O
do	O
{	O
dp	*(struct(int,*(int)))
=	O
create_defn	(*(struct(*(char),int,int,int,*(*(struct`)))),int)->(*(struct(int,*(int))))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
dp	*(struct(int,*(int)))
)	O
return	O
0	int
;	O
dp	*(struct(int,*(int)))
->	O
synset	*(int)
[	O
0	int
]	O
=	O
sp	int
;	O
++	O
sense	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optc	int
;	O
i	int
++	O
)	O
{	O
SynsetPtr	int
ssp	O
;	O
if	O
(	O
!	O
(	O
POS_MASK	O
(	O
pos	int
)	O
&	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
i	int
]	O
->	O
posmask	int
)	O
)	O
continue	O
;	O
ssp	O
=	O
findtheinfo_ds	()->(int)
(	O
(	O
char	O
*	O
)	O
searchword	*(char)
,	O
pos	int
,	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
i	int
]	O
->	O
search	int
,	O
sense	int
)	O
;	O
if	O
(	O
ssp	O
)	O
dp	*(struct(int,*(int)))
->	O
synset	*(int)
[	O
i	int
]	O
=	O
ssp	O
;	O
}	O
dico_list_append	(*(struct),*(void))->(int)
(	O
res	*(struct)
->	O
list	array(*(struct))
,	O
dp	*(struct(int,*(int)))
)	O
;	O
}	O
while	O
(	O
(	O
sp	int
=	O
sp	int
->	O
nextss	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
dico_result_t	*(struct)
wn_define	(*(struct),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
(	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
)	O
hp	*(struct)
;	O
struct	O
result	*(int)
*	O
res	*(struct)
;	O
int	O
i	int
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
copy	*(char)
;	O
res	*(struct)
=	O
wn_create_define_result	(*(struct(*(char),int,int,int,*(*(struct`)))),*(char))->(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
word	*(char)
)	O
;	O
copy	*(char)
=	O
nornmalize_search_word	(*(char))->(*(char))
(	O
word	*(char)
)	O
;	O
if	O
(	O
!	O
copy	*(char)
)	O
{	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
res	*(struct)
->	O
type	enum(int,int,int)
=	O
result_define	int
;	O
if	O
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
pos	int
==	O
ALL_POS	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
found	int
+=	O
search_defns	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
i	int
,	O
res	*(struct)
,	O
copy	*(char)
)	O
;	O
}	O
else	O
found	int
=	O
search_defns	(*(struct(*(char),int,int,int,*(*(struct`)))),int,*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(char))->(int)
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
,	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
pos	int
,	O
res	*(struct)
,	O
copy	*(char)
)	O
;	O
if	O
(	O
!	O
found	int
)	O
{	O
free	(*(void))->(void)
(	O
copy	*(char)
)	O
;	O
wn_free_result	(*(struct))->(void)
(	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
free	(*(void))->(void)
(	O
copy	*(char)
)	O
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct)
;	O
}	O
static	O
void	O
format_word	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
word	*(char)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
len	int
=	O
strcspn	(*(char),*(char))->(long)
(	O
word	*(char)
,	O
"_"	*(char)
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
word	*(char)
,	O
len	int
)	O
;	O
if	O
(	O
word	*(char)
[	O
len	int
]	O
==	O
0	int
)	O
break	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
" "	*(char)
,	O
1	int
)	O
;	O
word	*(char)
+=	O
len	int
+	O
1	int
;	O
}	O
}	O
static	O
void	O
format_defn_string	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
defn	struct(int,*(int))
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
defn	struct(int,*(int))
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
defn	struct(int,*(int))
[	O
0	int
]	O
==	O
'('	O
&&	O
defn	struct(int,*(int))
[	O
len	int
-	O
1	int
]	O
==	O
')'	O
)	O
{	O
defn	struct(int,*(int))
++	O
;	O
len	int
-=	O
2	int
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
defn	struct(int,*(int))
,	O
len	int
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
}	O
static	O
void	O
_wn_print_overview	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
", "	*(char)
,	O
2	int
)	O
;	O
format_word	(*(char),*(struct))->(void)
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	*(struct)
)	O
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"; "	*(char)
,	O
2	int
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
sp	int
->	O
pos	int
,	O
strlen	(*(char))->(long)
(	O
sp	int
->	O
pos	int
)	O
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
".\n\n"	*(char)
,	O
3	int
)	O
;	O
format_defn_string	(*(char),*(struct))->(void)
(	O
sp	int
->	O
defn	struct(int,*(int))
,	O
str	*(struct)
)	O
;	O
}	O
static	O
void	O
_wn_print_definition	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
format_defn_string	(*(char),*(struct))->(void)
(	O
sp	int
->	O
defn	struct(int,*(int))
,	O
str	*(struct)
)	O
;	O
if	O
(	O
sp	int
->	O
wcount	O
>	O
1	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
static	O
char	O
const	O
*	O
sym	*(char)
=	O
"Synonyms: "	*(char)
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
sym	*(char)
,	O
strlen	(*(char))->(long)
(	O
sym	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
j	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
res	*(struct)
->	O
searchword	*(char)
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
j	int
)	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
", "	*(char)
,	O
2	int
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"{"	*(char)
,	O
1	int
)	O
;	O
format_word	(*(char),*(struct))->(void)
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	*(struct)
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"}"	*(char)
,	O
1	int
)	O
;	O
j	int
++	O
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
_wn_print_hypernym	(*(struct),int,*(struct),*(struct))->(void)
(	O
struct	O
wn_option	struct(*(char),int,int,*(char),*(()->(void)),*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void)))
*	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
,	O
SynsetPtr	int
ptr	*(void)
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
int	O
i	int
;	O
SynsetPtr	int
sp	int
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
->	O
label	*(char)
,	O
strlen	(*(char))->(long)
(	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
->	O
label	*(char)
)	O
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
":\n\n"	*(char)
,	O
3	int
)	O
;	O
for	O
(	O
sp	int
=	O
ptr	*(void)
->	O
ptrlist	O
;	O
sp	int
;	O
sp	int
=	O
sp	int
->	O
nextss	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
", "	*(char)
,	O
2	int
)	O
;	O
format_word	(*(char),*(struct))->(void)
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	*(struct)
)	O
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
format_defn	(*(struct(int,*(int))),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(struct))->(int)
(	O
struct	O
defn	struct(int,*(int))
*	O
defn	struct(int,*(int))
,	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
int	O
i	int
;	O
struct	O
wndb	struct(*(char),int,int,int,*(*(struct)))
*	O
wndb	struct(*(char),int,int,int,*(*(struct)))
=	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optc	int
;	O
i	int
++	O
)	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
i	int
]	O
->	O
printer	*((*(struct(*(char),int,int,*(char),*(()->(void)),*((*`,int,*`,*`)->(void)))),int,*(struct),*(struct))->(void))
(	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
optv	*(*(struct))
[	O
i	int
]	O
,	O
defn	struct(int,*(int))
->	O
synset	*(int)
[	O
i	int
]	O
,	O
res	*(struct)
,	O
str	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_num	(*(struct),int)->(void)
(	O
dico_stream_t	*(struct)
str	*(struct)
,	O
unsigned	O
num	int
)	O
{	O
char	O
buf	*(void)
[	O
128	int
]	O
;	O
char	O
*	O
p	*(char)
=	O
buf	*(void)
+	O
sizeof	O
(	O
buf	*(void)
)	O
;	O
*	O
--	O
p	*(char)
=	O
0	int
;	O
while	O
(	O
p	*(char)
>	O
buf	*(void)
&&	O
num	int
)	O
{	O
*	O
--	O
p	*(char)
=	O
num	int
%	O
10	int
+	O
'0'	O
;	O
num	int
/=	O
10	int
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
p	*(char)
,	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
". "	*(char)
,	O
2	int
)	O
;	O
}	O
static	O
void	O
format_all_defns	(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(struct))->(void)
(	O
struct	O
result	*(int)
*	O
res	*(struct)
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
struct	O
defn	struct(int,*(int))
*	O
defn	struct(int,*(int))
;	O
int	O
pos	int
=	O
0	int
;	O
unsigned	O
num	int
;	O
format_word	(*(char),*(struct))->(void)
(	O
res	*(struct)
->	O
searchword	*(char)
,	O
str	*(struct)
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
"\n"	*(char)
,	O
1	int
)	O
;	O
for	O
(	O
defn	struct(int,*(int))
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
)	O
;	O
defn	struct(int,*(int))
;	O
defn	struct(int,*(int))
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
if	O
(	O
defn	struct(int,*(int))
->	O
pos	int
!=	O
pos	int
)	O
{	O
pos	int
=	O
defn	struct(int,*(int))
->	O
pos	int
;	O
num	int
=	O
1	int
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
defn	struct(int,*(int))
->	O
synset	*(int)
[	O
0	int
]	O
->	O
pos	int
,	O
strlen	(*(char))->(long)
(	O
defn	struct(int,*(int))
->	O
synset	*(int)
[	O
0	int
]	O
->	O
pos	int
)	O
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
". "	*(char)
,	O
2	int
)	O
;	O
}	O
print_num	(*(struct),int)->(void)
(	O
str	*(struct)
,	O
num	int
)	O
;	O
format_defn	(*(struct(int,*(int))),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(struct))->(int)
(	O
defn	struct(int,*(int))
,	O
res	*(struct)
,	O
str	*(struct)
)	O
;	O
num	int
++	O
;	O
}	O
}	O
int	O
wn_output_result	(*(struct),long,*(struct))->(int)
(	O
dico_result_t	*(struct)
rp	*(struct)
,	O
size_t	long
n	long
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
void	O
*	O
item	*(void)
;	O
if	O
(	O
!	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
)	O
{	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
=	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
res	*(struct)
->	O
list	array(*(struct))
)	O
;	O
if	O
(	O
!	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
)	O
return	O
1	int
;	O
}	O
item	*(void)
=	O
dico_iterator_item	(*(struct),long)->(*(void))
(	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
,	O
n	long
)	O
;	O
switch	O
(	O
res	*(struct)
->	O
type	enum(int,int,int)
)	O
{	O
case	O
result_match	int
:	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
item	*(void)
,	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
item	*(void)
)	O
)	O
;	O
break	O
;	O
case	O
result_define	int
:	O
if	O
(	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
format_all_defns	(*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(struct))->(void)
(	O
res	*(struct)
,	O
str	*(struct)
)	O
;	O
else	O
format_defn	(*(struct(int,*(int))),*(struct(enum(int,int),long,*(struct(*`,int,int,int,*`)),*(struct),*(struct),*(char),*(struct))),*(struct))->(int)
(	O
item	*(void)
,	O
res	*(struct)
,	O
str	*(struct)
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
wn_result_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
if	O
(	O
res	*(struct)
->	O
type	enum(int,int,int)
==	O
result_define	int
&&	O
(	O
res	*(struct)
->	O
wndb	struct(*(char),int,int,int,*(*(struct)))
->	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
)	O
return	O
1	int
;	O
return	O
dico_list_count	(*(struct))->(long)
(	O
res	*(struct)
->	O
list	array(*(struct))
)	O
;	O
}	O
static	O
size_t	long
wn_compare_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
return	O
res	*(struct)
->	O
compare_count	long
;	O
}	O
static	O
void	O
wn_free_result	(*(struct))->(void)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct)
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct)
->	O
list	array(*(struct))
)	O
;	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct)
->	O
itr	*((*(void),*(void))->(int))
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct)
->	O
rootlist	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
res	*(struct)
->	O
searchword	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
res	*(struct)
)	O
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
wordnet	O
,	O
module	O
)	O
=	O
{	O
DICO_MODULE_VERSION	int
,	O
DICO_CAPA_NONE	int
,	O
wn_init	(int,*(*(char)))->(int)
,	O
wn_init_db	(*(char),int,*(*(char)))->(*(struct))
,	O
wn_free_db	(*(struct))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
wn_info	(*(struct))->(*(char))
,	O
wn_descr	(*(struct))->(*(char))
,	O
wn_lang	(*(struct),array(*(struct)))->(int)
,	O
wn_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
,	O
wn_define	(*(struct),*(char))->(*(struct))
,	O
wn_output_result	(*(struct),long,*(struct))->(int)
,	O
wn_result_count	(*(struct))->(long)
,	O
wn_compare_count	(*(struct))->(long)
,	O
wn_free_result	(*(struct))->(void)
}	O
;	O
