static	O
double	O
r1py_data	array(double)
[	O
]	O
=	O
{	O
1.59888328244976954803168395603	int
,	O
0.67905625353213463845115658455	int
,	O
-	O
0.068485802980122530009506482524	int
,	O
-	O
0.005788184183095866792008831182	int
,	O
0.008511258167108615980419855648	int
,	O
-	O
0.004042656134699693434334556409	int
,	O
0.001352328406159402601778462956	int
,	O
-	O
0.000311646563930660566674525382	int
,	O
0.000018507563785249135437219139	int
,	O
0.000028348705427529850296492146	int
,	O
-	O
0.000019487536014574535567541960	int
,	O
8.0709788710834469408621587335e-06	int
,	O
-	O
2.2983564321340518037060346561e-06	int
,	O
3.0506629599604749843855962658e-07	int
,	O
1.3042238632418364610774284846e-07	int
,	O
-	O
1.2308657181048950589464690208e-07	int
,	O
5.7710855710682427240667414345e-08	int
,	O
-	O
1.8275559342450963966092636354e-08	int
,	O
3.1020471300626589420759518930e-09	int
,	O
6.8989327480593812470039430640e-10	int
,	O
-	O
8.7182290258923059852334818997e-10	int
,	O
4.4069147710243611798213548777e-10	int
,	O
-	O
1.4727311099198535963467200277e-10	int
,	O
2.7589682523262644748825844248e-11	int
,	O
4.1871826756975856411554363568e-12	int
,	O
-	O
6.5673460487260087541400767340e-12	int
,	O
3.4487900886723214020103638000e-12	int
,	O
-	O
1.1807251417448690607973794078e-12	int
,	O
2.3798314343969589258709315574e-13	int
,	O
2.1663630410818831824259465821e-15	int
}	O
;	O
static	O
cheb_series	struct(*(double),int,double,double,int)
r1py_cs	struct(*(double),int,double,double,int)
=	O
{	O
r1py_data	array(double)
,	O
29	int
,	O
-	O
1	int
,	O
1	int
,	O
18	int
}	O
;	O
static	O
double	O
psics_data	array(double)
[	O
23	int
]	O
=	O
{	O
-	O
.038057080835217922	int
,	O
.491415393029387130	int
,	O
-	O
.056815747821244730	int
,	O
.008357821225914313	int
,	O
-	O
.001333232857994342	int
,	O
.000220313287069308	int
,	O
-	O
.000037040238178456	int
,	O
.000006283793654854	int
,	O
-	O
.000001071263908506	int
,	O
.000000183128394654	int
,	O
-	O
.000000031353509361	int
,	O
.000000005372808776	int
,	O
-	O
.000000000921168141	int
,	O
.000000000157981265	int
,	O
-	O
.000000000027098646	int
,	O
.000000000004648722	int
,	O
-	O
.000000000000797527	int
,	O
.000000000000136827	int
,	O
-	O
.000000000000023475	int
,	O
.000000000000004027	int
,	O
-	O
.000000000000000691	int
,	O
.000000000000000118	int
,	O
-	O
.000000000000000020	int
}	O
;	O
static	O
cheb_series	struct(*(double),int,double,double,int)
psi_cs	struct(*(double),int,double,double,int)
=	O
{	O
psics_data	array(double)
,	O
22	int
,	O
-	O
1	int
,	O
1	int
,	O
17	int
}	O
;	O
static	O
double	O
apsics_data	array(double)
[	O
16	int
]	O
=	O
{	O
-	O
.0204749044678185	int
,	O
-	O
.0101801271534859	int
,	O
.0000559718725387	int
,	O
-	O
.0000012917176570	int
,	O
.0000000572858606	int
,	O
-	O
.0000000038213539	int
,	O
.0000000003397434	int
,	O
-	O
.0000000000374838	int
,	O
.0000000000048990	int
,	O
-	O
.0000000000007344	int
,	O
.0000000000001233	int
,	O
-	O
.0000000000000228	int
,	O
.0000000000000045	int
,	O
-	O
.0000000000000009	int
,	O
.0000000000000002	int
,	O
-	O
.0000000000000000	int
}	O
;	O
static	O
cheb_series	struct(*(double),int,double,double,int)
apsi_cs	struct(*(double),int,double,double,int)
=	O
{	O
apsics_data	array(double)
,	O
15	int
,	O
-	O
1	int
,	O
1	int
,	O
9	int
}	O
;	O
static	O
double	O
psi_table	array(double)
[	O
PSI_TABLE_NMAX	int
+	O
1	int
]	O
=	O
{	O
0.0	int
,	O
-	O
M_EULER	int
,	O
0.42278433509846713939348790992	int
,	O
0.92278433509846713939348790992	int
,	O
1.25611766843180047272682124325	int
,	O
1.50611766843180047272682124325	int
,	O
1.70611766843180047272682124325	int
,	O
1.87278433509846713939348790992	int
,	O
2.01564147795560999653634505277	int
,	O
2.14064147795560999653634505277	int
,	O
2.25175258906672110764745616389	int
,	O
2.35175258906672110764745616389	int
,	O
2.44266167997581201673836525479	int
,	O
2.52599501330914535007169858813	int
,	O
2.60291809023222227314862166505	int
,	O
2.67434666166079370172005023648	int
,	O
2.74101332832746036838671690315	int
,	O
2.80351332832746036838671690315	int
,	O
2.86233685773922507426906984432	int
,	O
2.91789241329478062982462539988	int
,	O
2.97052399224214905087725697883	int
,	O
3.02052399224214905087725697883	int
,	O
3.06814303986119666992487602645	int
,	O
3.11359758531574212447033057190	int
,	O
3.15707584618530734186163491973	int
,	O
3.1987425128519740085283015864	int
,	O
3.2387425128519740085283015864	int
,	O
3.2772040513135124700667631249	int
,	O
3.3142410883505495071038001619	int
,	O
3.3499553740648352213895144476	int
,	O
3.3844381326855248765619282407	int
,	O
3.4177714660188582098952615740	int
,	O
3.4500295305349872421533260902	int
,	O
3.4812795305349872421533260902	int
,	O
3.5115825608380175451836291205	int
,	O
3.5409943255438998981248055911	int
,	O
3.5695657541153284695533770196	int
,	O
3.5973435318931062473311547974	int
,	O
3.6243705589201332743581818244	int
,	O
3.6506863483938174848844976139	int
,	O
3.6763273740348431259101386396	int
,	O
3.7013273740348431259101386396	int
,	O
3.7257176179372821503003825420	int
,	O
3.7495271417468059598241920658	int
,	O
3.7727829557002943319172153216	int
,	O
3.7955102284275670591899425943	int
,	O
3.8177324506497892814121648166	int
,	O
3.8394715810845718901078169905	int
,	O
3.8607481768292527411716467777	int
,	O
3.8815815101625860745049801110	int
,	O
3.9019896734278921969539597029	int
,	O
3.9219896734278921969539597029	int
,	O
3.9415975165651470989147440166	int
,	O
3.9608282857959163296839747858	int
,	O
3.9796962103242182164764276160	int
,	O
3.9982147288427367349949461345	int
,	O
4.0163965470245549168131279527	int
,	O
4.0342536898816977739559850956	int
,	O
4.0517975495308205809735289552	int
,	O
4.0690389288411654085597358518	int
,	O
4.0859880813835382899156680552	int
,	O
4.1026547480502049565823347218	int
,	O
4.1190481906731557762544658694	int
,	O
4.1351772229312202923834981274	int
,	O
4.1510502388042361653993711433	int
,	O
4.1666752388042361653993711433	int
,	O
4.1820598541888515500147557587	int
,	O
4.1972113693403667015299072739	int
,	O
4.2121367424746950597388624977	int
,	O
4.2268426248276362362094507330	int
,	O
4.2413353784508246420065521823	int
,	O
4.2556210927365389277208378966	int
,	O
4.2697055997787924488475984600	int
,	O
4.2835944886676813377364873489	int
,	O
4.2972931188046676391063503626	int
,	O
4.3108066323181811526198638761	int
,	O
4.3241399656515144859531972094	int
,	O
4.3372978603883565912163551041	int
,	O
4.3502848733753695782293421171	int
,	O
4.3631053861958823987421626300	int
,	O
4.3757636140439836645649474401	int
,	O
4.3882636140439836645649474401	int
,	O
4.4006092930563293435772931191	int
,	O
4.4128044150075488557724150703	int
,	O
4.4248526077786331931218126607	int
,	O
4.4367573696833950978837174226	int
,	O
4.4485220755657480390601880108	int
,	O
4.4601499825424922251066996387	int
,	O
4.4716442354160554434975042364	int
,	O
4.4830078717796918071338678728	int
,	O
4.4942438268358715824147667492	int
,	O
4.5053549379469826935258778603	int
,	O
4.5163439489359936825368668713	int
,	O
4.5272135141533849868846929582	int
,	O
4.5379662023254279976373811303	int
,	O
4.5486045001977684231692960239	int
,	O
4.5591308159872421073798223397	int
,	O
4.5695474826539087740464890064	int
,	O
4.5798567610044242379640147796	int
,	O
4.5900608426370772991885045755	int
,	O
4.6001618527380874001986055856	int
}	O
;	O
static	O
double	O
psi_1_table	array(double)
[	O
PSI_1_TABLE_NMAX	int
+	O
1	int
]	O
=	O
{	O
0.0	int
,	O
M_PI	int
*	O
M_PI	int
/	O
6.0	int
,	O
0.644934066848226436472415	int
,	O
0.394934066848226436472415	int
,	O
0.2838229557371153253613041	int
,	O
0.2213229557371153253613041	int
,	O
0.1813229557371153253613041	int
,	O
0.1535451779593375475835263	int
,	O
0.1331370146940314251345467	int
,	O
0.1175120146940314251345467	int
,	O
0.1051663356816857461222010	int
,	O
0.0951663356816857461222010	int
,	O
0.0869018728717683907503002	int
,	O
0.0799574284273239463058557	int
,	O
0.0740402686640103368384001	int
,	O
0.0689382278476838062261552	int
,	O
0.0644937834032393617817108	int
,	O
0.0605875334032393617817108	int
,	O
0.0571273257907826143768665	int
,	O
0.0540409060376961946237801	int
,	O
0.0512708229352031198315363	int
,	O
0.0487708229352031198315363	int
,	O
0.0465032492390579951149830	int
,	O
0.0444371335365786562720078	int
,	O
0.0425467743683366902984728	int
,	O
0.0408106632572255791873617	int
,	O
0.0392106632572255791873617	int
,	O
0.0377313733163971768204978	int
,	O
0.0363596312039143235969038	int
,	O
0.0350841209998326909438426	int
,	O
0.0338950603577399442137594	int
,	O
0.0327839492466288331026483	int
,	O
0.0317433665203020901265817	int
,	O
0.03076680402030209012658168	int
,	O
0.02984853037475571730748159	int
,	O
0.02898347847164153045627052	int
,	O
0.02816715194102928555831133	int
,	O
0.02739554700275768062003973	int
,	O
0.02666508681283803124093089	int
,	O
0.02597256603721476254286995	int
,	O
0.02531510384129102815759710	int
,	O
0.02469010384129102815759710	int
,	O
0.02409521984367056414807896	int
,	O
0.02352832641963428296894063	int
,	O
0.02298749353699501850166102	int
,	O
0.02247096461137518379091722	int
,	O
0.02197713745088135663042339	int
,	O
0.02150454765882086513703965	int
,	O
0.02105185413233829383780923	int
,	O
0.02061782635456051606003145	int
,	O
0.02020133322669712580597065	int
,	O
0.01980133322669712580597065	int
,	O
0.01941686571420193164987683	int
,	O
0.01904704322899483105816086	int
,	O
0.01869104465298913508094477	int
,	O
0.01834810912486842177504628	int
,	O
0.01801753061247172756017024	int
,	O
0.01769865306145131939690494	int
,	O
0.01739086605006319997554452	int
,	O
0.01709360088954001329302371	int
,	O
0.01680632711763538818529605	int
,	O
0.01652854933985761040751827	int
,	O
0.01625980437882562975715546	int
,	O
0.01599965869724394401313881	int
,	O
0.01574770606433893015574400	int
,	O
0.01550356543933893015574400	int
,	O
0.01526687904880638577704578	int
,	O
0.01503731063741979257227076	int
,	O
0.01481454387422086185273411	int
,	O
0.01459828089844231513993134	int
,	O
0.01438824099085987447620523	int
,	O
0.01418415935820681325171544	int
,	O
0.01398578601958352422176106	int
,	O
0.01379288478501562298719316	int
,	O
0.01360523231738567365335942	int
,	O
0.01342261726990576130858221	int
,	O
0.01324483949212798353080444	int
,	O
0.01307170929822216635628920	int
,	O
0.01290304679189732236910755	int
,	O
0.01273868124291638877278934	int
,	O
0.01257845051066194236996928	int
,	O
0.01242220051066194236996928	int
,	O
0.01226978472038606978956995	int
,	O
0.01212106372098095378719041	int
,	O
0.01197590477193174490346273	int
,	O
0.01183418141592267460867815	int
,	O
0.01169577311142440471248438	int
,	O
0.01156056489076458859566448	int
,	O
0.01142844704164317229232189	int
,	O
0.01129931481023821361463594	int
,	O
0.01117306812421372175754719	int
,	O
0.01104961133409026496742374	int
,	O
0.01092885297157366069257770	int
,	O
0.01081070552355853781923177	int
,	O
0.01069508522063334415522437	int
,	O
0.01058191183901270133041676	int
,	O
0.01047110851491297833872701	int
,	O
0.01036260157046853389428257	int
,	O
0.01025632035036012704977199	int
,	O
0.01015219706839427948625679	int
,	O
0.01005016666333357139524567	int
}	O
;	O
static	O
int	O
psi_x	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
y	double
=	O
fabs	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
||	O
x	double
==	O
-	O
1.0	int
||	O
x	double
==	O
-	O
2.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
y	double
>=	O
2.0	int
)	O
{	O
const	O
double	O
t	double
=	O
8.0	int
/	O
(	O
y	double
*	O
y	double
)	O
-	O
1.0	int
;	O
gsl_sf_result	struct(double,double)
result_c	struct(double,double)
;	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
apsi_cs	struct(*(double),int,double,double,int)
,	O
t	double
,	O
&	O
result_c	struct(double,double)
)	O
;	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
const	O
double	O
s	double
=	O
sin	(double)->(double)
(	O
M_PI	int
*	O
x	double
)	O
;	O
const	O
double	O
c	*(double)
=	O
cos	(double)->(double)
(	O
M_PI	int
*	O
x	double
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
s	double
)	O
<	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
log	(double)->(double)
(	O
y	double
)	O
-	O
0.5	int
/	O
x	double
+	O
result_c	struct(double,double)
.	O
val	double
-	O
M_PI	int
*	O
c	*(double)
/	O
s	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
M_PI	int
*	O
fabs	(double)->(double)
(	O
x	double
)	O
*	O
GSL_DBL_EPSILON	int
/	O
(	O
s	double
*	O
s	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
log	(double)->(double)
(	O
y	double
)	O
-	O
0.5	int
/	O
x	double
+	O
result_c	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
result_c	struct(double,double)
;	O
if	O
(	O
x	double
<	O
-	O
1.0	int
)	O
{	O
const	O
double	O
v	double
=	O
x	double
+	O
2.0	int
;	O
const	O
double	O
t1	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
t2	double
=	O
1.0	int
/	O
(	O
x	double
+	O
1.0	int
)	O
;	O
const	O
double	O
t3	double
=	O
1.0	int
/	O
v	double
;	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
psi_cs	struct(*(double),int,double,double,int)
,	O
2.0	int
*	O
v	double
-	O
1.0	int
,	O
&	O
result_c	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
(	O
t1	double
+	O
t2	double
+	O
t3	double
)	O
+	O
result_c	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
t1	double
)	O
+	O
fabs	(double)->(double)
(	O
x	double
/	O
(	O
t2	double
*	O
t2	double
)	O
)	O
+	O
fabs	(double)->(double)
(	O
x	double
/	O
(	O
t3	double
*	O
t3	double
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
const	O
double	O
v	double
=	O
x	double
+	O
1.0	int
;	O
const	O
double	O
t1	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
t2	double
=	O
1.0	int
/	O
v	double
;	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
psi_cs	struct(*(double),int,double,double,int)
,	O
2.0	int
*	O
v	double
-	O
1.0	int
,	O
&	O
result_c	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
(	O
t1	double
+	O
t2	double
)	O
+	O
result_c	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
t1	double
)	O
+	O
fabs	(double)->(double)
(	O
x	double
/	O
(	O
t2	double
*	O
t2	double
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
t1	double
=	O
1.0	int
/	O
x	double
;	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
psi_cs	struct(*(double),int,double,double,int)
,	O
2.0	int
*	O
x	double
-	O
1.0	int
,	O
&	O
result_c	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
t1	double
+	O
result_c	struct(double,double)
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
t1	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
v	double
=	O
x	double
-	O
1.0	int
;	O
return	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
psi_cs	struct(*(double),int,double,double,int)
,	O
2.0	int
*	O
v	double
-	O
1.0	int
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
}	O
static	O
gsl_complex	struct(array(double))
psi_complex_asymp	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex	struct(array(double))
z	double
)	O
{	O
static	O
const	O
double	O
c1	double
=	O
-	O
0.1	int
;	O
static	O
const	O
double	O
c2	double
=	O
1.0	int
/	O
21.0	int
;	O
static	O
const	O
double	O
c3	double
=	O
-	O
0.05	int
;	O
gsl_complex	struct(array(double))
zi	double
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
;	O
gsl_complex	struct(array(double))
w	struct(array(double))
=	O
gsl_complex_mul	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
zi	double
,	O
zi	double
)	O
;	O
gsl_complex	struct(array(double))
cs	*(struct(*(double),int,double,double,int))
;	O
gsl_complex	struct(array(double))
sum	struct(array(double))
;	O
sum	struct(array(double))
=	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
w	struct(array(double))
,	O
c3	double
/	O
c2	double
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
1.0	int
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
c2	double
/	O
c1	double
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_mul	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
w	struct(array(double))
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
1.0	int
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
c1	double
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_mul	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
w	struct(array(double))
)	O
;	O
sum	struct(array(double))
=	O
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
1.0	int
)	O
;	O
cs	*(struct(*(double),int,double,double,int))
=	O
gsl_complex_mul	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
sum	struct(array(double))
,	O
w	struct(array(double))
)	O
;	O
cs	*(struct(*(double),int,double,double,int))
=	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
cs	*(struct(*(double),int,double,double,int))
,	O
-	O
1.0	int
/	O
12.0	int
)	O
;	O
cs	*(struct(*(double),int,double,double,int))
=	O
gsl_complex_add	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
cs	*(struct(*(double),int,double,double,int))
,	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
zi	double
,	O
-	O
0.5	int
)	O
)	O
;	O
return	O
gsl_complex_add	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
gsl_complex_log	(struct(array(double)))->(struct(array(double)))
(	O
z	double
)	O
,	O
cs	*(struct(*(double),int,double,double,int))
)	O
;	O
}	O
static	O
int	O
psi_complex_rhp	(struct(array(double)),*(struct(double,double)),*(struct(double,double)))->(int)
(	O
gsl_complex	struct(array(double))
z	double
,	O
gsl_sf_result	struct(double,double)
*	O
result_re	*(struct(double,double))
,	O
gsl_sf_result	struct(double,double)
*	O
result_im	*(struct(double,double))
)	O
{	O
int	O
n_recurse	int
=	O
0	int
;	O
int	O
i	int
;	O
gsl_complex	struct(array(double))
a	double
;	O
if	O
(	O
GSL_REAL	O
(	O
z	double
)	O
==	O
0.0	int
&&	O
GSL_IMAG	O
(	O
z	double
)	O
==	O
0.0	int
)	O
{	O
result_re	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result_im	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result_re	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
result_im	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_EDOM	int
;	O
}	O
if	O
(	O
GSL_REAL	O
(	O
z	double
)	O
<	O
20.0	int
&&	O
fabs	(double)->(double)
(	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
<	O
20.0	int
)	O
{	O
const	O
double	O
sp	double
=	O
sqrt	(double)->(double)
(	O
20.0	int
+	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
const	O
double	O
sn	double
=	O
sqrt	(double)->(double)
(	O
20.0	int
-	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
const	O
double	O
rhs	double
=	O
sp	double
*	O
sn	double
-	O
GSL_REAL	O
(	O
z	double
)	O
;	O
if	O
(	O
rhs	double
>	O
0.0	int
)	O
n_recurse	int
=	O
ceil	(double)->(double)
(	O
rhs	double
)	O
;	O
}	O
a	double
=	O
psi_complex_asymp	(struct(array(double)))->(struct(array(double)))
(	O
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
n_recurse	int
)	O
)	O
;	O
result_re	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
result_im	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
n_recurse	int
;	O
i	int
>=	O
1	int
;	O
--	O
i	int
)	O
{	O
gsl_complex	struct(array(double))
zn	struct(array(double))
=	O
gsl_complex_add_real	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
i	int
-	O
1.0	int
)	O
;	O
gsl_complex	struct(array(double))
zn_inverse	struct(array(double))
=	O
gsl_complex_inverse	(struct(array(double)))->(struct(array(double)))
(	O
zn	struct(array(double))
)	O
;	O
a	double
=	O
gsl_complex_sub	(struct(array(double)),struct(array(double)))->(struct(array(double)))
(	O
a	double
,	O
zn_inverse	struct(array(double))
)	O
;	O
result_re	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
GSL_REAL	O
(	O
zn_inverse	struct(array(double))
)	O
)	O
;	O
result_im	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
GSL_IMAG	O
(	O
zn_inverse	struct(array(double))
)	O
)	O
;	O
}	O
result_re	*(struct(double,double))
->	O
val	double
=	O
GSL_REAL	O
(	O
a	double
)	O
;	O
result_im	*(struct(double,double))
->	O
val	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
result_re	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result_re	*(struct(double,double))
->	O
val	double
)	O
;	O
result_im	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result_im	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
psi_n_xg0	(int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
ln_nf	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
hzeta	struct(double,double)
;	O
int	O
stat_hz	int
=	O
gsl_sf_hzeta_e	(double,double,*(struct(double,double)))->(int)
(	O
n	int
+	O
1.0	int
,	O
x	double
,	O
&	O
hzeta	struct(double,double)
)	O
;	O
int	O
stat_nf	int
=	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
(	O
unsigned	O
int	O
)	O
n	int
,	O
&	O
ln_nf	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_nf	struct(double,double)
.	O
val	double
,	O
ln_nf	struct(double,double)
.	O
err	double
,	O
hzeta	struct(double,double)
.	O
val	double
,	O
hzeta	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
if	O
(	O
GSL_IS_EVEN	O
(	O
n	int
)	O
)	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
result	*(struct(double,double))
->	O
val	double
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_nf	int
,	O
stat_hz	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_psi_int_e	(int,*(struct(double,double)))->(int)
(	O
const	O
int	O
n	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
n	int
<=	O
PSI_TABLE_NMAX	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
psi_table	array(double)
[	O
n	int
]	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
c2	double
=	O
-	O
1.0	int
/	O
12.0	int
;	O
const	O
double	O
c3	double
=	O
1.0	int
/	O
120.0	int
;	O
const	O
double	O
c4	double
=	O
-	O
1.0	int
/	O
252.0	int
;	O
const	O
double	O
c5	double
=	O
1.0	int
/	O
240.0	int
;	O
const	O
double	O
ni2	double
=	O
(	O
1.0	int
/	O
n	int
)	O
*	O
(	O
1.0	int
/	O
n	int
)	O
;	O
const	O
double	O
ser	double
=	O
ni2	double
*	O
(	O
c2	double
+	O
ni2	double
*	O
(	O
c3	double
+	O
ni2	double
*	O
(	O
c4	double
+	O
ni2	double
*	O
c5	double
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
log	(double)->(double)
(	O
n	int
)	O
-	O
0.5	int
/	O
n	int
+	O
ser	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
log	(double)->(double)
(	O
n	int
)	O
)	O
+	O
fabs	(double)->(double)
(	O
0.5	int
/	O
n	int
)	O
+	O
fabs	(double)->(double)
(	O
ser	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
return	O
psi_x	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
int	O
gsl_sf_psi_1piy_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
y	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
ay	double
=	O
fabs	(double)->(double)
(	O
y	double
)	O
;	O
if	O
(	O
ay	double
>	O
1000.0	int
)	O
{	O
const	O
double	O
yi2	double
=	O
1.0	int
/	O
(	O
ay	double
*	O
ay	double
)	O
;	O
const	O
double	O
lny	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
sum	struct(array(double))
=	O
yi2	double
*	O
(	O
1.0	int
/	O
12.0	int
+	O
1.0	int
/	O
120.0	int
*	O
yi2	double
+	O
1.0	int
/	O
252.0	int
*	O
yi2	double
*	O
yi2	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
lny	double
+	O
sum	struct(array(double))
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lny	double
)	O
+	O
fabs	(double)->(double)
(	O
sum	struct(array(double))
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
ay	double
>	O
10.0	int
)	O
{	O
const	O
double	O
yi2	double
=	O
1.0	int
/	O
(	O
ay	double
*	O
ay	double
)	O
;	O
const	O
double	O
lny	double
=	O
log	(double)->(double)
(	O
ay	double
)	O
;	O
const	O
double	O
sum	struct(array(double))
=	O
yi2	double
*	O
(	O
1.0	int
/	O
12.0	int
+	O
yi2	double
*	O
(	O
1.0	int
/	O
120.0	int
+	O
yi2	double
*	O
(	O
1.0	int
/	O
252.0	int
+	O
yi2	double
*	O
(	O
1.0	int
/	O
240.0	int
+	O
yi2	double
*	O
(	O
1.0	int
/	O
132.0	int
+	O
691.0	int
/	O
32760.0	int
*	O
yi2	double
)	O
)	O
)	O
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
lny	double
+	O
sum	struct(array(double))
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
lny	double
)	O
+	O
fabs	(double)->(double)
(	O
sum	struct(array(double))
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
ay	double
>	O
1.0	int
)	O
{	O
const	O
double	O
y2	double
=	O
ay	double
*	O
ay	double
;	O
const	O
double	O
x	double
=	O
(	O
2.0	int
*	O
ay	double
-	O
11.0	int
)	O
/	O
9.0	int
;	O
const	O
double	O
v	double
=	O
y2	double
*	O
(	O
1.0	int
/	O
(	O
1.0	int
+	O
y2	double
)	O
+	O
0.5	int
/	O
(	O
4.0	int
+	O
y2	double
)	O
)	O
;	O
gsl_sf_result	struct(double,double)
result_c	struct(double,double)
;	O
cheb_eval_e	(*(struct(*(double),int,double,double,int)),double,*(struct(double,double)))->(int)
(	O
&	O
r1py_cs	struct(*(double),int,double,double,int)
,	O
x	double
,	O
&	O
result_c	struct(double,double)
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
result_c	struct(double,double)
.	O
val	double
-	O
M_EULER	int
+	O
v	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
result_c	struct(double,double)
.	O
err	double
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	(double)->(double)
(	O
v	double
)	O
+	O
M_EULER	int
+	O
fabs	(double)->(double)
(	O
result_c	struct(double,double)
.	O
val	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
result	*(struct(double,double))
->	O
err	double
*=	O
5.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
int	O
M	int
=	O
50	int
;	O
const	O
double	O
y2	double
=	O
y	double
*	O
y	double
;	O
const	O
double	O
c0	double
=	O
0.00019603999466879846570	int
;	O
const	O
double	O
c2	double
=	O
3.8426659205114376860e-08	int
;	O
const	O
double	O
c4	double
=	O
1.0041592839497643554e-11	int
;	O
const	O
double	O
c6	double
=	O
2.9516743763500191289e-15	int
;	O
const	O
double	O
p	double
=	O
c0	double
+	O
y2	double
*	O
(	O
-	O
c2	double
+	O
y2	double
*	O
(	O
c4	double
-	O
y2	double
*	O
c6	double
)	O
)	O
;	O
double	O
sum	struct(array(double))
=	O
0.0	int
;	O
double	O
v	double
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<=	O
M	int
;	O
n	int
++	O
)	O
{	O
sum	struct(array(double))
+=	O
1.0	int
/	O
(	O
n	int
*	O
(	O
n	int
*	O
n	int
+	O
y	double
*	O
y	double
)	O
)	O
;	O
}	O
v	double
=	O
y2	double
*	O
(	O
sum	struct(array(double))
+	O
p	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
M_EULER	int
+	O
v	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
M_EULER	int
+	O
fabs	(double)->(double)
(	O
v	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_psi_1_int_e	(int,*(struct(double,double)))->(int)
(	O
const	O
int	O
n	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
n	int
<=	O
PSI_1_TABLE_NMAX	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
psi_1_table	array(double)
[	O
n	int
]	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
result	*(struct(double,double))
->	O
val	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
c0	double
=	O
-	O
1.0	int
/	O
30.0	int
;	O
const	O
double	O
c1	double
=	O
1.0	int
/	O
42.0	int
;	O
const	O
double	O
c2	double
=	O
-	O
1.0	int
/	O
30.0	int
;	O
const	O
double	O
ni2	double
=	O
(	O
1.0	int
/	O
n	int
)	O
*	O
(	O
1.0	int
/	O
n	int
)	O
;	O
const	O
double	O
ser	double
=	O
ni2	double
*	O
ni2	double
*	O
(	O
c0	double
+	O
ni2	double
*	O
(	O
c1	double
+	O
c2	double
*	O
ni2	double
)	O
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
(	O
1.0	int
+	O
0.5	int
/	O
n	int
+	O
1.0	int
/	O
(	O
6.0	int
*	O
n	int
*	O
n	int
)	O
+	O
ser	double
)	O
/	O
n	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
result	*(struct(double,double))
->	O
val	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_psi_1_e	(double,*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
||	O
x	double
==	O
-	O
1.0	int
||	O
x	double
==	O
-	O
2.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
return	O
psi_n_xg0	(int,double,*(struct(double,double)))->(int)
(	O
1	int
,	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
-	O
5.0	int
)	O
{	O
int	O
M	int
=	O
-	O
floor	(double)->(double)
(	O
x	double
)	O
;	O
double	O
fx	double
=	O
x	double
+	O
M	int
;	O
double	O
sum	struct(array(double))
=	O
0.0	int
;	O
int	O
m	int
;	O
if	O
(	O
fx	double
==	O
0.0	int
)	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
M	int
;	O
++	O
m	int
)	O
sum	struct(array(double))
+=	O
1.0	int
/	O
(	O
(	O
x	double
+	O
m	int
)	O
*	O
(	O
x	double
+	O
m	int
)	O
)	O
;	O
{	O
int	O
stat_psi	int
=	O
psi_n_xg0	(int,double,*(struct(double,double)))->(int)
(	O
1	int
,	O
fx	double
,	O
result	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
+=	O
sum	struct(array(double))
;	O
result	*(struct(double,double))
->	O
err	double
+=	O
M	int
*	O
GSL_DBL_EPSILON	int
*	O
sum	struct(array(double))
;	O
return	O
stat_psi	int
;	O
}	O
}	O
else	O
{	O
const	O
double	O
sin_px	double
=	O
sin	(double)->(double)
(	O
M_PI	int
*	O
x	double
)	O
;	O
const	O
double	O
d	double
=	O
M_PI	int
*	O
M_PI	int
/	O
(	O
sin_px	double
*	O
sin_px	double
)	O
;	O
gsl_sf_result	struct(double,double)
r	*(struct(double,double))
;	O
int	O
stat_psi	int
=	O
psi_n_xg0	(int,double,*(struct(double,double)))->(int)
(	O
1	int
,	O
1.0	int
-	O
x	double
,	O
&	O
r	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
d	double
-	O
r	*(struct(double,double))
.	O
val	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
r	*(struct(double,double))
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
d	double
;	O
return	O
stat_psi	int
;	O
}	O
}	O
int	O
gsl_sf_psi_n_e	(int,double,*(struct(double,double)))->(int)
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
return	O
gsl_sf_psi_1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
||	O
x	double
<=	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct(double,double)
ln_nf	struct(double,double)
;	O
gsl_sf_result	struct(double,double)
hzeta	struct(double,double)
;	O
int	O
stat_hz	int
=	O
gsl_sf_hzeta_e	(double,double,*(struct(double,double)))->(int)
(	O
n	int
+	O
1.0	int
,	O
x	double
,	O
&	O
hzeta	struct(double,double)
)	O
;	O
int	O
stat_nf	int
=	O
gsl_sf_lnfact_e	(int,*(struct(double,double)))->(int)
(	O
(	O
unsigned	O
int	O
)	O
n	int
,	O
&	O
ln_nf	struct(double,double)
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	(double,double,double,double,*(struct(double,double)))->(int)
(	O
ln_nf	struct(double,double)
.	O
val	double
,	O
ln_nf	struct(double,double)
.	O
err	double
,	O
hzeta	struct(double,double)
.	O
val	double
,	O
hzeta	struct(double,double)
.	O
err	double
,	O
result	*(struct(double,double))
)	O
;	O
if	O
(	O
GSL_IS_EVEN	O
(	O
n	int
)	O
)	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
result	*(struct(double,double))
->	O
val	double
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_nf	int
,	O
stat_hz	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_complex_psi_e	(double,double,*(struct(double,double)),*(struct(double,double)))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
,	O
gsl_sf_result	struct(double,double)
*	O
result_re	*(struct(double,double))
,	O
gsl_sf_result	struct(double,double)
*	O
result_im	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
>=	O
0.0	int
)	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_rect	(double,double)->(struct(array(double)))
(	O
x	double
,	O
y	double
)	O
;	O
return	O
psi_complex_rhp	(struct(array(double)),*(struct(double,double)),*(struct(double,double)))->(int)
(	O
z	double
,	O
result_re	*(struct(double,double))
,	O
result_im	*(struct(double,double))
)	O
;	O
}	O
else	O
{	O
gsl_complex	struct(array(double))
z	double
=	O
gsl_complex_rect	(double,double)->(struct(array(double)))
(	O
x	double
,	O
y	double
)	O
;	O
gsl_complex	struct(array(double))
omz	struct(array(double))
=	O
gsl_complex_rect	(double,double)->(struct(array(double)))
(	O
1.0	int
-	O
x	double
,	O
-	O
y	double
)	O
;	O
gsl_complex	struct(array(double))
zpi	struct(array(double))
=	O
gsl_complex_mul_real	(struct(array(double)),double)->(struct(array(double)))
(	O
z	double
,	O
M_PI	int
)	O
;	O
gsl_complex	struct(array(double))
cotzpi	struct(array(double))
=	O
gsl_complex_cot	(struct(array(double)))->(struct(array(double)))
(	O
zpi	struct(array(double))
)	O
;	O
int	O
ret_val	int
=	O
psi_complex_rhp	(struct(array(double)),*(struct(double,double)),*(struct(double,double)))->(int)
(	O
omz	struct(array(double))
,	O
result_re	*(struct(double,double))
,	O
result_im	*(struct(double,double))
)	O
;	O
if	O
(	O
GSL_IS_REAL	O
(	O
GSL_REAL	O
(	O
cotzpi	struct(array(double))
)	O
)	O
&&	O
GSL_IS_REAL	O
(	O
GSL_IMAG	O
(	O
cotzpi	struct(array(double))
)	O
)	O
)	O
{	O
result_re	*(struct(double,double))
->	O
val	double
-=	O
M_PI	int
*	O
GSL_REAL	O
(	O
cotzpi	struct(array(double))
)	O
;	O
result_im	*(struct(double,double))
->	O
val	double
-=	O
M_PI	int
*	O
GSL_IMAG	O
(	O
cotzpi	struct(array(double))
)	O
;	O
return	O
ret_val	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"singularity"	*(char)
,	O
GSL_EDOM	int
)	O
;	O
}	O
}	O
}	O
double	O
gsl_sf_psi_int	(int)->(double)
(	O
const	O
int	O
n	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_int_e	(int,*(struct(double,double)))->(int)
(	O
n	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_psi	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_psi_1piy	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_1piy_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_psi_1_int	(int)->(double)
(	O
const	O
int	O
n	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_1_int_e	(int,*(struct(double,double)))->(int)
(	O
n	int
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_psi_1	(double)->(double)
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_psi_n	(int,double)->(double)
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_psi_n_e	(int,double,*(struct(double,double)))->(int)
(	O
n	int
,	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
