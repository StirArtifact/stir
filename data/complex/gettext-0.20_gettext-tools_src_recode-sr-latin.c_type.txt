static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
process	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
int	O
opt	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"hV"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%s (GNU %s) %s\n"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"2006-2019"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Written by %s and %s.\n"	*(char)
)	O
,	O
proper_name_utf8	(*(char),*(char))->(*(char))
(	O
"Danilo Segan"	*(char)
,	O
"Danilo \305\240egan"	*(char)
)	O
,	O
proper_name	(*(char))->(*(char))
(	O
"Bruno Haible"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
argc	int
-	O
optind	int
>	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
process	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Recode Serbian text from Cyrillic to Latin script.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The input text is read from standard input.  The converted text is output to\nstandard output.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Informative output:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
struct	O
linebuffer	struct(long,long,*(char))
{	O
size_t	long
size	long
;	O
size_t	long
length	long
;	O
char	O
*	O
buffer	*(char)
;	O
}	O
;	O
static	O
inline	O
void	O
init_linebuffer	(*(struct(long,long,*(char))))->(void)
(	O
struct	O
linebuffer	struct(long,long,*(char))
*	O
lb	*(struct(long,long,*(char)))
)	O
{	O
lb	*(struct(long,long,*(char)))
->	O
size	long
=	O
0	int
;	O
lb	*(struct(long,long,*(char)))
->	O
length	long
=	O
0	int
;	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
=	O
NULL	O
;	O
}	O
static	O
struct	O
linebuffer	struct(long,long,*(char))
*	O
read_linebuffer	(*(struct(long,long,*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(long,long,*(char))))
(	O
struct	O
linebuffer	struct(long,long,*(char))
*	O
lb	*(struct(long,long,*(char)))
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
NULL	O
;	O
else	O
{	O
char	O
*	O
p	*(void)
=	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
;	O
char	O
*	O
end	*(char)
=	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
+	O
lb	*(struct(long,long,*(char)))
->	O
size	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
p	*(void)
==	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
||	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
p	*(void)
==	O
end	*(char)
)	O
{	O
size_t	long
oldsize	long
=	O
lb	*(struct(long,long,*(char)))
->	O
size	long
;	O
size_t	long
newsize	long
=	O
2	int
*	O
oldsize	long
+	O
40	int
;	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
,	O
newsize	long
)	O
;	O
lb	*(struct(long,long,*(char)))
->	O
size	long
=	O
newsize	long
;	O
p	*(void)
=	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
+	O
oldsize	long
;	O
end	*(char)
=	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
+	O
newsize	long
;	O
}	O
*	O
p	*(void)
++	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
lb	*(struct(long,long,*(char)))
->	O
length	long
=	O
p	*(void)
-	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
;	O
return	O
lb	*(struct(long,long,*(char)))
;	O
}	O
}	O
static	O
inline	O
void	O
destroy_linebuffer	(*(struct(long,long,*(char))))->(void)
(	O
struct	O
linebuffer	struct(long,long,*(char))
*	O
lb	*(struct(long,long,*(char)))
)	O
{	O
if	O
(	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
lb	*(struct(long,long,*(char)))
->	O
buffer	*(char)
)	O
;	O
}	O
static	O
void	O
process	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
struct	O
linebuffer	struct(long,long,*(char))
lb	*(struct(long,long,*(char)))
;	O
const	O
char	O
*	O
locale_code	*(char)
=	O
locale_charset	()->(*(char))
(	O
)	O
;	O
bool	bool
need_code_conversion	bool
=	O
(	O
c_strcasecmp	(*(char),*(char))->(int)
(	O
locale_code	*(char)
,	O
"UTF-8"	*(char)
)	O
!=	O
0	int
)	O
;	O
iconv_t	*(void)
conv_to_utf8	*(void)
=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
;	O
iconv_t	*(void)
conv_from_utf8	*(void)
=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
;	O
char	O
*	O
last_utf8_line	*(char)
;	O
size_t	long
last_utf8_line_len	long
;	O
char	O
*	O
last_backconv_line	*(char)
;	O
size_t	long
last_backconv_line_len	long
;	O
init_linebuffer	(*(struct(long,long,*(char))))->(void)
(	O
&	O
lb	*(struct(long,long,*(char)))
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
{	O
conv_to_utf8	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
"UTF-8"	*(char)
,	O
locale_code	*(char)
)	O
;	O
conv_from_utf8	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
locale_code	*(char)
,	O
"UTF-8"	*(char)
)	O
;	O
}	O
if	O
(	O
conv_to_utf8	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot convert from \"%s\" to \"%s\". %s relies on iconv(), and iconv() does not support this conversion."	*(char)
)	O
,	O
locale_code	*(char)
,	O
"UTF-8"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
)	O
;	O
if	O
(	O
conv_from_utf8	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot convert from \"%s\" to \"%s\". %s relies on iconv(), and iconv() does not support this conversion."	*(char)
)	O
,	O
"UTF-8"	*(char)
,	O
locale_code	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
)	O
;	O
last_utf8_line	*(char)
=	O
NULL	O
;	O
last_utf8_line_len	long
=	O
0	int
;	O
last_backconv_line	*(char)
=	O
NULL	O
;	O
last_backconv_line_len	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
line	*(char)
;	O
size_t	long
line_len	long
;	O
char	O
*	O
filtered_line	*(char)
;	O
size_t	long
filtered_line_len	long
;	O
if	O
(	O
read_linebuffer	(*(struct(long,long,*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(long,long,*(char))))
(	O
&	O
lb	*(struct(long,long,*(char)))
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
break	O
;	O
line	*(char)
=	O
lb	*(struct(long,long,*(char)))
.	O
buffer	*(char)
;	O
line_len	long
=	O
lb	*(struct(long,long,*(char)))
.	O
length	long
;	O
if	O
(	O
line_len	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
char	O
*	O
utf8_line	*(char)
=	O
last_utf8_line	*(char)
;	O
size_t	long
utf8_line_len	long
=	O
last_utf8_line_len	long
;	O
if	O
(	O
xmem_cd_iconv	(*(char),long,*(void),*(*(char)),*(long))->(int)
(	O
line	*(char)
,	O
line_len	long
,	O
conv_to_utf8	*(void)
,	O
&	O
utf8_line	*(char)
,	O
&	O
utf8_line_len	long
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"input is not valid in \"%s\" encoding"	*(char)
)	O
,	O
locale_code	*(char)
)	O
;	O
if	O
(	O
utf8_line	*(char)
!=	O
last_utf8_line	*(char)
)	O
{	O
if	O
(	O
last_utf8_line	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
last_utf8_line	*(char)
)	O
;	O
last_utf8_line	*(char)
=	O
utf8_line	*(char)
;	O
last_utf8_line_len	long
=	O
utf8_line_len	long
;	O
}	O
line	*(char)
=	O
utf8_line	*(char)
;	O
line_len	long
=	O
utf8_line_len	long
;	O
}	O
serbian_to_latin	(*(char),long,*(*(char)),*(long))->(void)
(	O
line	*(char)
,	O
line_len	long
,	O
&	O
filtered_line	*(char)
,	O
&	O
filtered_line_len	long
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
char	O
*	O
backconv_line	*(char)
=	O
last_backconv_line	*(char)
;	O
size_t	long
backconv_line_len	long
=	O
last_backconv_line_len	long
;	O
if	O
(	O
xmem_cd_iconv	(*(char),long,*(void),*(*(char)),*(long))->(int)
(	O
filtered_line	*(char)
,	O
filtered_line_len	long
,	O
conv_from_utf8	*(void)
,	O
&	O
backconv_line	*(char)
,	O
&	O
backconv_line_len	long
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while converting from \"%s\" encoding to \"%s\" encoding"	*(char)
)	O
,	O
"UTF-8"	*(char)
,	O
locale_code	*(char)
)	O
;	O
if	O
(	O
backconv_line	*(char)
!=	O
last_backconv_line	*(char)
)	O
{	O
if	O
(	O
last_backconv_line	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
last_backconv_line	*(char)
)	O
;	O
last_backconv_line	*(char)
=	O
backconv_line	*(char)
;	O
last_backconv_line_len	long
=	O
backconv_line_len	long
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
backconv_line	*(char)
,	O
1	int
,	O
backconv_line_len	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
filtered_line	*(char)
,	O
1	int
,	O
filtered_line_len	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
filtered_line	*(char)
)	O
;	O
}	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
iconv_close	(*(void))->(int)
(	O
conv_from_utf8	*(void)
)	O
;	O
iconv_close	(*(void))->(int)
(	O
conv_to_utf8	*(void)
)	O
;	O
}	O
destroy_linebuffer	(*(struct(long,long,*(char))))->(void)
(	O
&	O
lb	*(struct(long,long,*(char)))
)	O
;	O
}	O
