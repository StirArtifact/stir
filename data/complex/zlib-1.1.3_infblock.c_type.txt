struct	O
inflate_codes_state	struct(int)
{	O
int	O
dummy	int
;	O
}	O
;	O
local	O
const	O
uInt	int
border	array(int)
[	O
]	O
=	O
{	O
16	int
,	O
17	int
,	O
18	int
,	O
0	int
,	O
8	int
,	O
7	int
,	O
9	int
,	O
6	int
,	O
10	int
,	O
5	int
,	O
11	int
,	O
4	int
,	O
12	int
,	O
3	int
,	O
13	int
,	O
2	int
,	O
14	int
,	O
1	int
,	O
15	int
}	O
;	O
void	O
inflate_blocks_reset	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(long))->(void)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
c	int
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
uLongf	long
*	O
c	int
;	O
{	O
if	O
(	O
c	int
!=	O
Z_NULL	int
)	O
*	O
c	int
=	O
s	*(char)
->	O
check	long
;	O
if	O
(	O
s	*(char)
->	O
mode	*(char)
==	O
BTREE	int
||	O
s	*(char)
->	O
mode	*(char)
==	O
DTREE	int
)	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
)	O
;	O
if	O
(	O
s	*(char)
->	O
mode	*(char)
==	O
CODES	int
)	O
inflate_codes_free	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(void)
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
decode	struct(*(struct))
.	O
codes	*(struct)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
TYPE	int
;	O
s	*(char)
->	O
bitk	int
=	O
0	int
;	O
s	*(char)
->	O
bitb	long
=	O
0	int
;	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
=	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
=	O
s	*(char)
->	O
window	*(char)
;	O
if	O
(	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
!=	O
Z_NULL	int
)	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
=	O
s	*(char)
->	O
check	long
=	O
(	O
*	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
)	O
(	O
0L	int
,	O
(	O
const	O
Bytef	char
*	O
)	O
Z_NULL	int
,	O
0	int
)	O
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:   blocks reset\n"	*(char)
)	O
)	O
;	O
}	O
inflate_blocks_statef	struct
*	O
inflate_blocks_new	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*((long,*(char),int)->(long)),int)->(*(struct))
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
c	int
,	O
w	int
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
check_func	*((long,*(char),int)->(long))
c	int
;	O
uInt	int
w	int
;	O
{	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
if	O
(	O
(	O
s	*(char)
=	O
(	O
inflate_blocks_statef	struct
*	O
)	O
ZALLOC	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
1	int
,	O
sizeof	O
(	O
struct	O
inflate_blocks_state	struct(enum(int,int,int,int,int,int,int,int,int,int),union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct))),int,int,long,*(struct(union(struct(char,char),int),int)),*(char),*(char),*(char),*(char),*((long,*(char),int)->(long)),long)
)	O
)	O
)	O
==	O
Z_NULL	int
)	O
return	O
s	*(char)
;	O
if	O
(	O
(	O
s	*(char)
->	O
hufts	*(struct(union(struct(char,char),int),int))
=	O
(	O
inflate_huft	struct
*	O
)	O
ZALLOC	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
sizeof	O
(	O
inflate_huft	struct
)	O
,	O
MANY	int
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
)	O
;	O
return	O
Z_NULL	int
;	O
}	O
if	O
(	O
(	O
s	*(char)
->	O
window	*(char)
=	O
(	O
Bytef	char
*	O
)	O
ZALLOC	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
1	int
,	O
w	int
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
hufts	*(struct(union(struct(char,char),int),int))
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
)	O
;	O
return	O
Z_NULL	int
;	O
}	O
s	*(char)
->	O
end	*(char)
=	O
s	*(char)
->	O
window	*(char)
+	O
w	int
;	O
s	*(char)
->	O
checkfn	*((long,*(char),int)->(long))
=	O
c	int
;	O
s	*(char)
->	O
mode	*(char)
=	O
TYPE	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:   blocks allocated\n"	*(char)
)	O
)	O
;	O
inflate_blocks_reset	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(long))->(void)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
Z_NULL	int
)	O
;	O
return	O
s	*(char)
;	O
}	O
int	O
inflate_blocks	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
r	int
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
int	O
r	int
;	O
{	O
uInt	int
t	int
;	O
uLong	long
b	long
;	O
uInt	int
k	int
;	O
Bytef	char
*	O
p	*(char)
;	O
uInt	int
n	int
;	O
Bytef	char
*	O
q	*(char)
;	O
uInt	int
m	int
;	O
LOAD	O
while	O
(	O
1	int
)	O
switch	O
(	O
s	*(char)
->	O
mode	*(char)
)	O
{	O
case	O
TYPE	int
:	O
NEEDBITS	O
(	O
3	int
)	O
t	int
=	O
(	O
uInt	int
)	O
b	long
&	O
7	int
;	O
s	*(char)
->	O
last	int
=	O
t	int
&	O
1	int
;	O
switch	O
(	O
t	int
>>	O
1	int
)	O
{	O
case	O
0	int
:	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:     stored block%s\n"	*(char)
,	O
s	*(char)
->	O
last	int
?	O
" (last)"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
DUMPBITS	O
(	O
3	int
)	O
t	int
=	O
k	int
&	O
7	int
;	O
DUMPBITS	O
(	O
t	int
)	O
s	*(char)
->	O
mode	*(char)
=	O
LENS	int
;	O
break	O
;	O
case	O
1	int
:	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:     fixed codes block%s\n"	*(char)
,	O
s	*(char)
->	O
last	int
?	O
" (last)"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
{	O
uInt	int
bl	int
,	O
bd	int
;	O
inflate_huft	struct
*	O
tl	*(struct(union(struct(char,char),int),int))
,	O
*	O
td	*(struct(union(struct(char,char),int),int))
;	O
inflate_trees_fixed	(*(int),*(int),*(*(struct(union(struct`,int),int))),*(*(struct(union(struct`,int),int))),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
bl	int
,	O
&	O
bd	int
,	O
&	O
tl	*(struct(union(struct(char,char),int),int))
,	O
&	O
td	*(struct(union(struct(char,char),int),int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
decode	struct(*(struct))
.	O
codes	*(struct)
=	O
inflate_codes_new	(int,int,*(struct(union(struct(char,char),int),int)),*(struct(union(struct(char,char),int),int)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(*(struct))
(	O
bl	int
,	O
bd	int
,	O
tl	*(struct(union(struct(char,char),int),int))
,	O
td	*(struct(union(struct(char,char),int),int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
if	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
decode	struct(*(struct))
.	O
codes	*(struct)
==	O
Z_NULL	int
)	O
{	O
r	int
=	O
Z_MEM_ERROR	O
;	O
LEAVE	O
}	O
}	O
DUMPBITS	O
(	O
3	int
)	O
s	*(char)
->	O
mode	*(char)
=	O
CODES	int
;	O
break	O
;	O
case	O
2	int
:	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:     dynamic codes block%s\n"	*(char)
,	O
s	*(char)
->	O
last	int
?	O
" (last)"	*(char)
:	O
""	*(char)
)	O
)	O
;	O
DUMPBITS	O
(	O
3	int
)	O
s	*(char)
->	O
mode	*(char)
=	O
TABLE	int
;	O
break	O
;	O
case	O
3	int
:	O
DUMPBITS	O
(	O
3	int
)	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"invalid block type"	*(char)
;	O
r	int
=	O
Z_DATA_ERROR	O
;	O
LEAVE	O
}	O
break	O
;	O
case	O
LENS	int
:	O
NEEDBITS	O
(	O
32	int
)	O
if	O
(	O
(	O
(	O
(	O
~	O
b	long
)	O
>>	O
16	int
)	O
&	O
0xffff	int
)	O
!=	O
(	O
b	long
&	O
0xffff	int
)	O
)	O
{	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"invalid stored block lengths"	*(char)
;	O
r	int
=	O
Z_DATA_ERROR	O
;	O
LEAVE	O
}	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
left	int
=	O
(	O
uInt	int
)	O
b	long
&	O
0xffff	int
;	O
b	long
=	O
k	int
=	O
0	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       stored length %u\n"	*(char)
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
left	int
)	O
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
left	int
?	O
STORED	int
:	O
(	O
s	*(char)
->	O
last	int
?	O
DRY	int
:	O
TYPE	int
)	O
;	O
break	O
;	O
case	O
STORED	int
:	O
if	O
(	O
n	int
==	O
0	int
)	O
LEAVE	O
NEEDOUT	O
t	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
left	int
;	O
if	O
(	O
t	int
>	O
n	int
)	O
t	int
=	O
n	int
;	O
if	O
(	O
t	int
>	O
m	int
)	O
t	int
=	O
m	int
;	O
zmemcpy	O
(	O
q	*(char)
,	O
p	*(char)
,	O
t	int
)	O
;	O
p	*(char)
+=	O
t	int
;	O
n	int
-=	O
t	int
;	O
q	*(char)
+=	O
t	int
;	O
m	int
-=	O
t	int
;	O
if	O
(	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
left	int
-=	O
t	int
)	O
!=	O
0	int
)	O
break	O
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       stored end, %lu total out\n"	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
+	O
(	O
q	*(char)
>=	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
?	O
q	*(char)
-	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
:	O
(	O
s	*(char)
->	O
end	*(char)
-	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
)	O
+	O
(	O
q	*(char)
-	O
s	*(char)
->	O
window	*(char)
)	O
)	O
)	O
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
s	*(char)
->	O
last	int
?	O
DRY	int
:	O
TYPE	int
;	O
break	O
;	O
case	O
TABLE	int
:	O
NEEDBITS	O
(	O
14	int
)	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
table	int
=	O
t	int
=	O
(	O
uInt	int
)	O
b	long
&	O
0x3fff	int
;	O
if	O
(	O
(	O
t	int
&	O
0x1f	int
)	O
>	O
29	int
||	O
(	O
(	O
t	int
>>	O
5	int
)	O
&	O
0x1f	int
)	O
>	O
29	int
)	O
{	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"too many length or distance symbols"	*(char)
;	O
r	int
=	O
Z_DATA_ERROR	O
;	O
LEAVE	O
}	O
t	int
=	O
258	int
+	O
(	O
t	int
&	O
0x1f	int
)	O
+	O
(	O
(	O
t	int
>>	O
5	int
)	O
&	O
0x1f	int
)	O
;	O
if	O
(	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
=	O
(	O
uIntf	int
*	O
)	O
ZALLOC	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
t	int
,	O
sizeof	O
(	O
uInt	int
)	O
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
r	int
=	O
Z_MEM_ERROR	O
;	O
LEAVE	O
}	O
DUMPBITS	O
(	O
14	int
)	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       table sizes ok\n"	*(char)
)	O
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
BTREE	int
;	O
case	O
BTREE	int
:	O
while	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
<	O
4	int
+	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
table	int
>>	O
10	int
)	O
)	O
{	O
NEEDBITS	O
(	O
3	int
)	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
[	O
border	array(int)
[	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
++	O
]	O
]	O
=	O
(	O
uInt	int
)	O
b	long
&	O
7	int
;	O
DUMPBITS	O
(	O
3	int
)	O
}	O
while	O
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
<	O
19	int
)	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
[	O
border	array(int)
[	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
++	O
]	O
]	O
=	O
0	int
;	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
bb	int
=	O
7	int
;	O
t	int
=	O
inflate_trees_bits	(*(int),*(int),*(*(struct(union(struct`,int),int))),*(struct(union(struct(char,char),int),int)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
,	O
&	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
bb	int
,	O
&	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
tb	*(struct(union(struct(char,char),int),int))
,	O
s	*(char)
->	O
hufts	*(struct(union(struct(char,char),int),int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
if	O
(	O
t	int
!=	O
Z_OK	int
)	O
{	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
)	O
;	O
r	int
=	O
t	int
;	O
if	O
(	O
r	int
==	O
Z_DATA_ERROR	O
)	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
LEAVE	O
}	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       bits tree ok\n"	*(char)
)	O
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
DTREE	int
;	O
case	O
DTREE	int
:	O
while	O
(	O
t	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
table	int
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
<	O
258	int
+	O
(	O
t	int
&	O
0x1f	int
)	O
+	O
(	O
(	O
t	int
>>	O
5	int
)	O
&	O
0x1f	int
)	O
)	O
{	O
inflate_huft	struct
*	O
h	*(struct(union(struct(char,char),int),int))
;	O
uInt	int
i	int
,	O
j	int
,	O
c	int
;	O
t	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
bb	int
;	O
NEEDBITS	O
(	O
t	int
)	O
h	*(struct(union(struct(char,char),int),int))
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
tb	*(struct(union(struct(char,char),int),int))
+	O
(	O
(	O
uInt	int
)	O
b	long
&	O
inflate_mask	array(int)
[	O
t	int
]	O
)	O
;	O
t	int
=	O
h	*(struct(union(struct(char,char),int),int))
->	O
bits	O
;	O
c	int
=	O
h	*(struct(union(struct(char,char),int),int))
->	O
base	int
;	O
if	O
(	O
c	int
<	O
16	int
)	O
{	O
DUMPBITS	O
(	O
t	int
)	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
[	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
++	O
]	O
=	O
c	int
;	O
}	O
else	O
{	O
i	int
=	O
c	int
==	O
18	int
?	O
7	int
:	O
c	int
-	O
14	int
;	O
j	int
=	O
c	int
==	O
18	int
?	O
11	int
:	O
3	int
;	O
NEEDBITS	O
(	O
t	int
+	O
i	int
)	O
DUMPBITS	O
(	O
t	int
)	O
j	int
+=	O
(	O
uInt	int
)	O
b	long
&	O
inflate_mask	array(int)
[	O
i	int
]	O
;	O
DUMPBITS	O
(	O
i	int
)	O
i	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
;	O
t	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
table	int
;	O
if	O
(	O
i	int
+	O
j	int
>	O
258	int
+	O
(	O
t	int
&	O
0x1f	int
)	O
+	O
(	O
(	O
t	int
>>	O
5	int
)	O
&	O
0x1f	int
)	O
||	O
(	O
c	int
==	O
16	int
&&	O
i	int
<	O
1	int
)	O
)	O
{	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
)	O
;	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"invalid bit length repeat"	*(char)
;	O
r	int
=	O
Z_DATA_ERROR	O
;	O
LEAVE	O
}	O
c	int
=	O
c	int
==	O
16	int
?	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
[	O
i	int
-	O
1	int
]	O
:	O
0	int
;	O
do	O
{	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
[	O
i	int
++	O
]	O
=	O
c	int
;	O
}	O
while	O
(	O
--	O
j	int
)	O
;	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
index	(*(char),int)->(*(char))
=	O
i	int
;	O
}	O
}	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
tb	*(struct(union(struct(char,char),int),int))
=	O
Z_NULL	int
;	O
{	O
uInt	int
bl	int
,	O
bd	int
;	O
inflate_huft	struct
*	O
tl	*(struct(union(struct(char,char),int),int))
,	O
*	O
td	*(struct(union(struct(char,char),int),int))
;	O
inflate_codes_statef	struct
*	O
c	int
;	O
bl	int
=	O
9	int
;	O
bd	int
=	O
6	int
;	O
t	int
=	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
table	int
;	O
t	int
=	O
inflate_trees_dynamic	(int,int,*(int),*(int),*(int),*(*(struct(union(struct`,int),int))),*(*(struct(union(struct`,int),int))),*(struct(union(struct(char,char),int),int)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
257	int
+	O
(	O
t	int
&	O
0x1f	int
)	O
,	O
1	int
+	O
(	O
(	O
t	int
>>	O
5	int
)	O
&	O
0x1f	int
)	O
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
,	O
&	O
bl	int
,	O
&	O
bd	int
,	O
&	O
tl	*(struct(union(struct(char,char),int),int))
,	O
&	O
td	*(struct(union(struct(char,char),int),int))
,	O
s	*(char)
->	O
hufts	*(struct(union(struct(char,char),int),int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
trees	struct(int,int,*(int),int,*(struct(union(struct(char,char),int),int)))
.	O
blens	*(int)
)	O
;	O
if	O
(	O
t	int
!=	O
Z_OK	int
)	O
{	O
if	O
(	O
t	int
==	O
(	O
uInt	int
)	O
Z_DATA_ERROR	O
)	O
s	*(char)
->	O
mode	*(char)
=	O
BAD	int
;	O
r	int
=	O
t	int
;	O
LEAVE	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       trees ok\n"	*(char)
)	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
inflate_codes_new	(int,int,*(struct(union(struct(char,char),int),int)),*(struct(union(struct(char,char),int),int)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(*(struct))
(	O
bl	int
,	O
bd	int
,	O
tl	*(struct(union(struct(char,char),int),int))
,	O
td	*(struct(union(struct(char,char),int),int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
r	int
=	O
Z_MEM_ERROR	O
;	O
LEAVE	O
}	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
decode	struct(*(struct))
.	O
codes	*(struct)
=	O
c	int
;	O
}	O
s	*(char)
->	O
mode	*(char)
=	O
CODES	int
;	O
case	O
CODES	int
:	O
UPDATE	O
if	O
(	O
(	O
r	int
=	O
inflate_codes	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
r	int
)	O
)	O
!=	O
Z_STREAM_END	int
)	O
return	O
inflate_flush	(*(struct(enum(int,int,int,int,int,int,int,int,int,int),union(int,struct(int,int,*`,int,*`),struct(*`)),int,int,long,*(struct(union`,int)),*(char),*(char),*(char),*(char),*((long,*`,int)->(long)),long)),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
r	int
)	O
;	O
r	int
=	O
Z_OK	int
;	O
inflate_codes_free	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(void)
(	O
s	*(char)
->	O
sub	union(int,struct(int,int,*(int),int,*(struct(union(struct`,int),int))),struct(*(struct)))
.	O
decode	struct(*(struct))
.	O
codes	*(struct)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
LOAD	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:       codes end, %lu total out\n"	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
+	O
(	O
q	*(char)
>=	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
?	O
q	*(char)
-	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
:	O
(	O
s	*(char)
->	O
end	*(char)
-	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
)	O
+	O
(	O
q	*(char)
-	O
s	*(char)
->	O
window	*(char)
)	O
)	O
)	O
)	O
;	O
if	O
(	O
!	O
s	*(char)
->	O
last	int
)	O
{	O
s	*(char)
->	O
mode	*(char)
=	O
TYPE	int
;	O
break	O
;	O
}	O
s	*(char)
->	O
mode	*(char)
=	O
DRY	int
;	O
case	O
DRY	int
:	O
FLUSH	O
if	O
(	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
!=	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
)	O
LEAVE	O
s	*(char)
->	O
mode	*(char)
=	O
DONE	int
;	O
case	O
DONE	int
:	O
r	int
=	O
Z_STREAM_END	int
;	O
LEAVE	O
case	O
BAD	int
:	O
r	int
=	O
Z_DATA_ERROR	O
;	O
LEAVE	O
default	O
:	O
r	int
=	O
Z_STREAM_ERROR	O
;	O
LEAVE	O
}	O
}	O
int	O
inflate_blocks_free	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
{	O
inflate_blocks_reset	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(long))->(void)
(	O
s	*(char)
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
Z_NULL	int
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
window	*(char)
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
->	O
hufts	*(struct(union(struct(char,char),int),int))
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
s	*(char)
)	O
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate:   blocks freed\n"	*(char)
)	O
)	O
;	O
return	O
Z_OK	int
;	O
}	O
void	O
inflate_set_dictionary	(*(struct),*(char),int)->(void)
(	O
s	*(char)
,	O
d	*(char)
,	O
n	int
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
const	O
Bytef	char
*	O
d	*(char)
;	O
uInt	int
n	int
;	O
{	O
zmemcpy	O
(	O
s	*(char)
->	O
window	*(char)
,	O
d	*(char)
,	O
n	int
)	O
;	O
s	*(char)
->	O
read	(int,*(void),long)->(long)
=	O
s	*(char)
->	O
write	(int,*(void),long)->(long)
=	O
s	*(char)
->	O
window	*(char)
+	O
n	int
;	O
}	O
int	O
inflate_blocks_sync_point	(*(struct))->(int)
(	O
s	*(char)
)	O
inflate_blocks_statef	struct
*	O
s	*(char)
;	O
{	O
return	O
s	*(char)
->	O
mode	*(char)
==	O
LENS	int
;	O
}	O
