int	O
sockfd	int
,	O
verb	int
=	O
0	int
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*(char),*(struct`),array(char))))),*((*(void),*(struct(*(char),*(struct`),array(char))))->(void)),*(void),int,int,int)
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
;	O
int	O
hide_discl	int
=	O
2	int
;	O
const	O
char	O
*	O
server	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
port	*(char)
=	O
NULL	O
;	O
int	O
nopar	int
=	O
0	int
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
ripe_argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
"search all databases"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'F'	O
,	O
NULL	O
,	O
0	int
,	O
"fast raw output (implies -r)"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'g'	O
,	O
"SOURCE:FIRST-LAST"	*(char)
,	O
0	int
,	O
"find updates from SOURCE from serial FIRST to LAST"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'i'	O
,	O
"ATTR[,ATTR]..."	*(char)
,	O
0	int
,	O
"do an inverse lookup for specified ATTRibutes"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"one level less specific lookup (RPSL only)"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'L'	O
,	O
NULL	O
,	O
0	int
,	O
"find all Less specific matches"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'M'	O
,	O
NULL	O
,	O
0	int
,	O
"find all More specific matches"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'm'	O
,	O
NULL	O
,	O
0	int
,	O
"find first level more specific matches"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
"turn off recursive lookups"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'R'	O
,	O
NULL	O
,	O
0	int
,	O
"force to show local copy of the domain object even "	*(char)
"if it contains referral"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
"tell server to leave out syntactic sugar"	*(char)
}	O
,	O
{	O
NULL	O
,	O
's'	O
,	O
"SOURCE[,SOURCE]..."	*(char)
,	O
0	int
,	O
"search the database from SOURCE"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'T'	O
,	O
"TYPE[,TYPE]..."	*(char)
,	O
0	int
,	O
"only look for objects of TYPE"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'q'	O
,	O
"version|sources"	*(char)
,	O
0	int
,	O
"query specified server info (RPSL only)"	*(char)
}	O
,	O
{	O
NULL	O
,	O
't'	O
,	O
"TYPE"	*(char)
,	O
0	int
,	O
"requests template for object of TYPE ('all' for a list)"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'x'	O
,	O
NULL	O
,	O
0	int
,	O
"exact match only (RPSL only)"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
ripe_argp_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
if	O
(	O
key	int
>	O
0	int
&&	O
(	O
unsigned	O
)	O
key	int
<	O
128	int
)	O
{	O
if	O
(	O
key	int
==	O
't'	O
||	O
key	int
==	O
'v'	O
||	O
key	int
==	O
'q'	O
)	O
nopar	int
=	O
1	int
;	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
'-'	O
)	O
;	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
key	int
)	O
;	O
if	O
(	O
arg	*(char)
)	O
{	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
' '	O
)	O
;	O
obstack_grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
arg	*(char)
,	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
ripe_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
ripe_argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
ripe_argp_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
}	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
gwhois_argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"verbose"	*(char)
,	O
'V'	O
,	O
NULL	O
,	O
0	int
,	O
"explain what is being done"	*(char)
}	O
,	O
{	O
"server"	*(char)
,	O
'h'	O
,	O
"HOST"	*(char)
,	O
0	int
,	O
"connect to server HOST"	*(char)
}	O
,	O
{	O
"port"	*(char)
,	O
'p'	O
,	O
"PORT"	*(char)
,	O
0	int
,	O
"connect to PORT"	*(char)
}	O
,	O
{	O
NULL	O
,	O
'H'	O
,	O
NULL	O
,	O
0	int
,	O
"hide legal disclaimers"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
gwhois_argp_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'h'	O
:	O
server	*(char)
=	O
q	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
+	O
1	int
)	O
;	O
for	O
(	O
p	*(char)
=	O
arg	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
&&	O
*	O
p	*(char)
!=	O
':'	O
;	O
*	O
q	*(char)
++	O
=	O
tolower	(int)->(int)
(	O
*	O
p	*(char)
++	O
)	O
)	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
':'	O
)	O
port	*(char)
=	O
p	*(char)
+	O
1	int
;	O
*	O
q	*(char)
=	O
'\0'	O
;	O
break	O
;	O
case	O
'H'	O
:	O
hide_discl	int
=	O
0	int
;	O
break	O
;	O
case	O
'p'	O
:	O
port	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'V'	O
:	O
verb	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
gwhois_argp_children	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
&	O
ripe_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
,	O
0	int
,	O
"RIPE-specific options"	*(char)
,	O
0	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
gwhois_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
gwhois_argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
gwhois_argp_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
"OBJECT..."	*(char)
,	O
"client for the whois directory service"	*(char)
,	O
gwhois_argp_children	array(struct(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
}	O
;	O
const	O
char	O
*	O
program_authors	array(*(char))
[	O
]	O
=	O
{	O
"Marco d'Itri"	*(char)
,	O
NULL	O
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
char	O
*	O
fstring	*(char)
;	O
char	O
*	O
qstring	*(char)
;	O
char	O
*	O
p	*(char)
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
obstack_init	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
iu_argp_init	O
(	O
"whois"	*(char)
,	O
program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
gwhois_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
ARGP_IN_ORDER	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
;	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
fstring	*(char)
=	O
obstack_finish	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
argc	int
-=	O
index	(*(char),int)->(*(char))
;	O
argv	*(*(char))
+=	O
index	(*(char),int)->(*(char))
;	O
if	O
(	O
argc	int
==	O
0	int
&&	O
!	O
nopar	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"not enough arguments"	*(char)
)	O
;	O
if	O
(	O
!	O
nopar	int
)	O
{	O
while	O
(	O
argc	int
--	O
)	O
{	O
const	O
char	O
*	O
arg	*(char)
=	O
*	O
argv	*(*(char))
++	O
;	O
obstack_grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
arg	*(char)
,	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
)	O
;	O
if	O
(	O
argc	int
)	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
' '	O
)	O
;	O
}	O
}	O
obstack_1grow	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
0	int
)	O
;	O
qstring	*(char)
=	O
obstack_finish	O
(	O
&	O
query_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
if	O
(	O
!	O
server	*(char)
&&	O
domfind	(*(char),array(*(char)))->(int)
(	O
qstring	*(char)
,	O
gtlds	array(*(char))
)	O
)	O
{	O
if	O
(	O
verb	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Connecting to whois.internic.net."	*(char)
)	O
)	O
;	O
sockfd	int
=	O
openconn	(*(char),*(char))->(int)
(	O
"whois.internic.net"	*(char)
,	O
NULL	O
)	O
;	O
server	*(char)
=	O
query_crsnic	(int,*(char))->(*(char))
(	O
sockfd	int
,	O
qstring	*(char)
)	O
;	O
closeconn	(int)->(void)
(	O
sockfd	int
)	O
;	O
if	O
(	O
!	O
server	*(char)
)	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nFound InterNIC referral to %s.\n\n"	*(char)
)	O
,	O
server	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
server	*(char)
)	O
{	O
server	*(char)
=	O
whichwhois	(*(char))->(*(char))
(	O
qstring	*(char)
)	O
;	O
switch	O
(	O
server	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
!	O
(	O
server	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"WHOIS_SERVER"	*(char)
)	O
)	O
)	O
server	*(char)
=	O
DEFAULTSERVER	*(char)
;	O
if	O
(	O
verb	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Using default server %s.\n"	*(char)
)	O
,	O
server	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
puts	(*(char))->(int)
(	O
_	O
(	O
"This TLD has no whois server, but you can access the "	*(char)
"whois database at"	*(char)
)	O
)	O
;	O
case	O
2	int
:	O
puts	(*(char))->(int)
(	O
server	*(char)
+	O
1	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
3	int
:	O
puts	(*(char))->(int)
(	O
_	O
(	O
"This TLD has no whois server."	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
default	O
:	O
if	O
(	O
verb	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Using server %s.\n"	*(char)
)	O
,	O
server	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"WHOIS_HIDE"	*(char)
)	O
)	O
hide_discl	int
=	O
0	int
;	O
p	*(char)
=	O
queryformat	(*(char),*(char),*(char))->(*(char))
(	O
server	*(char)
,	O
fstring	*(char)
,	O
qstring	*(char)
)	O
;	O
if	O
(	O
verb	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Query string: \"%s\"\n\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
"\r\n"	*(char)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
sighandler	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
sighandler	(int)->(void)
)	O
;	O
sockfd	int
=	O
openconn	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
port	*(char)
)	O
;	O
do_query	(int,*(char))->(void)
(	O
sockfd	int
,	O
p	*(char)
)	O
;	O
closeconn	(int)->(void)
(	O
sockfd	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
const	O
char	O
*	O
whichwhois	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
unsigned	O
long	O
ip	long
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
return	O
"whois.ripe.net"	*(char)
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
':'	O
)	O
)	O
{	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"2001:2"	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
return	O
"whois.apnic.net"	*(char)
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"2001:4"	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
return	O
"whois.arin.net"	*(char)
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"2001:6"	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
return	O
"whois.ripe.net"	*(char)
;	O
return	O
"whois.6bone.net"	*(char)
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
'@'	O
)	O
)	O
return	O
""	*(char)
;	O
if	O
(	O
!	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
".-"	*(char)
)	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"as"	*(char)
,	O
2	int
)	O
==	O
0	int
&&	O
(	O
(	O
s	*(char)
[	O
2	int
]	O
>=	O
'0'	O
&&	O
s	*(char)
[	O
2	int
]	O
<=	O
'9'	O
)	O
||	O
s	*(char)
[	O
2	int
]	O
==	O
' '	O
)	O
)	O
return	O
whereas	(int,array(struct(short,short,*(char))))->(*(char))
(	O
atoi	(*(char))->(int)
(	O
s	*(char)
+	O
2	int
)	O
,	O
as_assign	array(struct(short,short,*(char)))
)	O
;	O
else	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
p	*(char)
-	O
2	int
,	O
"jp"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
return	O
"whois.nic.ad.jp"	*(char)
;	O
if	O
(	O
*	O
p	*(char)
==	O
'!'	O
)	O
return	O
"whois.networksolutions.com"	*(char)
;	O
else	O
return	O
""	*(char)
;	O
}	O
if	O
(	O
(	O
ip	long
=	O
myinet_aton	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ip_assign	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
serv	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
(	O
ip	long
&	O
ip_assign	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
mask	long
)	O
==	O
ip_assign	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
net	long
)	O
return	O
ip_assign	array(struct(long,long,*(char)))
[	O
i	int
]	O
.	O
serv	*(char)
;	O
if	O
(	O
verb	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"I don't know where this IP has been delegated.\n"	*(char)
"I'll try ARIN and hope for the best..."	*(char)
)	O
)	O
;	O
return	O
"whois.arin.net"	*(char)
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
tld_serv	array(*(char))
[	O
i	int
]	O
;	O
i	int
+=	O
2	int
)	O
if	O
(	O
domcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
tld_serv	array(*(char))
[	O
i	int
]	O
)	O
)	O
return	O
tld_serv	array(*(char))
[	O
i	int
+	O
1	int
]	O
;	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
s	*(char)
,	O
'.'	O
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
nic_handles	array(*(char))
[	O
i	int
]	O
;	O
i	int
+=	O
2	int
)	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
nic_handles	array(*(char))
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
nic_handles	array(*(char))
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
return	O
nic_handles	array(*(char))
[	O
i	int
+	O
1	int
]	O
;	O
if	O
(	O
verb	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"I guess it's a netblock name but I don't know where to"	*(char)
" look it up."	*(char)
)	O
)	O
;	O
return	O
"whois.arin.net"	*(char)
;	O
}	O
if	O
(	O
verb	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"I guess it's a domain but I don't know where to look it"	*(char)
" up."	*(char)
)	O
)	O
;	O
return	O
""	*(char)
;	O
}	O
const	O
char	O
*	O
whereas	(int,array(struct(short,short,*(char))))->(*(char))
(	O
int	O
asn	int
,	O
struct	O
as_del	struct(short,short,*(char))
aslist	array(struct(short,short,*(char)))
[	O
]	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
asn	int
>	O
16383	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Unknown AS number. Please upgrade this program."	*(char)
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
aslist	array(struct(short,short,*(char)))
[	O
i	int
]	O
.	O
serv	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
asn	int
>=	O
aslist	array(struct(short,short,*(char)))
[	O
i	int
]	O
.	O
first	short
&&	O
asn	int
<=	O
aslist	array(struct(short,short,*(char)))
[	O
i	int
]	O
.	O
last	short
)	O
return	O
aslist	array(struct(short,short,*(char)))
[	O
i	int
]	O
.	O
serv	*(char)
;	O
return	O
"whois.arin.net"	*(char)
;	O
}	O
int	O
is_ripe_server	(*(*(char)),*(char))->(int)
(	O
const	O
char	O
*	O
const	O
*	O
srvtab	*(*(char))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
in_addr	struct(int)
addr	struct(int)
;	O
int	O
isip	int
=	O
0	int
;	O
isip	int
=	O
inet_aton	(*(char),*(struct(int)))->(int)
(	O
name	*(char)
,	O
&	O
addr	struct(int)
)	O
;	O
for	O
(	O
;	O
*	O
srvtab	*(*(char))
;	O
++	O
srvtab	*(*(char))
)	O
{	O
const	O
char	O
*	O
server	*(char)
=	O
*	O
srvtab	*(*(char))
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
isip	int
&&	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
server	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
*	O
pa	*(*(char))
;	O
for	O
(	O
pa	*(*(char))
=	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_addr_list	*(*(char))
;	O
*	O
pa	*(*(char))
;	O
pa	*(*(char))
++	O
)	O
if	O
(	O
*	O
(	O
unsigned	O
long	O
*	O
)	O
*	O
pa	*(*(char))
==	O
addr	struct(int)
.	O
s_addr	int
)	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
queryformat	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
server	*(char)
,	O
const	O
char	O
*	O
flags	int
,	O
const	O
char	O
*	O
query	*(char)
)	O
{	O
char	O
*	O
buf	*(char)
;	O
int	O
isripe	int
=	O
0	int
;	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
flags	int
)	O
+	O
strlen	(*(char))->(long)
(	O
query	*(char)
)	O
+	O
10	int
+	O
2	int
+	O
1	int
)	O
;	O
*	O
buf	*(char)
=	O
'\0'	O
;	O
isripe	int
=	O
is_ripe_server	(*(*(char)),*(char))->(int)
(	O
ripe_servers	array(*(char))
,	O
server	*(char)
)	O
||	O
is_ripe_server	(*(*(char)),*(char))->(int)
(	O
ripe_servers_old	array(*(char))
,	O
server	*(char)
)	O
;	O
if	O
(	O
isripe	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"-V"	*(char)
IDSTRING	*(char)
" "	*(char)
)	O
;	O
if	O
(	O
*	O
flags	int
!=	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
isripe	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.corenic.net"	*(char)
)	O
!=	O
0	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
"Warning: RIPE flags ignored for a traditional server."	*(char)
)	O
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
flags	int
)	O
;	O
}	O
if	O
(	O
!	O
isripe	int
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.arin.net"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.nic.mil"	*(char)
)	O
==	O
0	int
)	O
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
query	*(char)
,	O
"AS"	*(char)
,	O
2	int
)	O
==	O
0	int
&&	O
query	*(char)
[	O
2	int
]	O
>=	O
'0'	O
&&	O
query	*(char)
[	O
2	int
]	O
<=	O
'9'	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"AS %s"	*(char)
,	O
query	*(char)
+	O
2	int
)	O
;	O
else	O
if	O
(	O
!	O
isripe	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.corenic.net"	*(char)
)	O
==	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"--machine %s"	*(char)
,	O
query	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
isripe	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.ncst.ernet.in"	*(char)
)	O
==	O
0	int
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
query	*(char)
,	O
' '	O
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"domain %s"	*(char)
,	O
query	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
isripe	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
server	*(char)
,	O
"whois.nic.ad.jp"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
lang	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LANG"	*(char)
)	O
;	O
if	O
(	O
!	O
lang	*(char)
||	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
lang	*(char)
,	O
"ja"	*(char)
,	O
2	int
)	O
!=	O
0	int
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s/e"	*(char)
,	O
query	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
query	*(char)
)	O
;	O
}	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
query	*(char)
)	O
;	O
return	O
buf	*(char)
;	O
}	O
void	O
do_query	(int,*(char))->(void)
(	O
const	O
int	O
sock	int
,	O
const	O
char	O
*	O
query	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
200	int
]	O
,	O
*	O
p	*(char)
;	O
FILE	struct
*	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
i	int
=	O
0	int
,	O
hide	int
=	O
hide_discl	int
;	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
sock	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
sock	int
,	O
query	*(char)
,	O
strlen	(*(char))->(long)
(	O
query	*(char)
)	O
)	O
<	O
0	int
)	O
err_sys	(*(char))->(void)
(	O
"write"	*(char)
)	O
;	O
if	O
(	O
shutdown	(int,int)->(int)
(	O
sock	int
,	O
1	int
)	O
<	O
0	int
)	O
err_sys	(*(char))->(void)
(	O
"shutdown"	*(char)
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
200	int
,	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
hide	int
==	O
1	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
hide_strings	array(*(char))
[	O
i	int
+	O
1	int
]	O
,	O
strlen	(*(char))->(long)
(	O
hide_strings	array(*(char))
[	O
i	int
+	O
1	int
]	O
)	O
)	O
==	O
0	int
)	O
hide	int
=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
hide	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
hide_strings	array(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
+=	O
2	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
hide_strings	array(*(char))
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
hide_strings	array(*(char))
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
hide	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hide	int
==	O
1	int
)	O
continue	O
;	O
}	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
"% referto:"	*(char)
,	O
10	int
)	O
==	O
0	int
)	O
{	O
char	O
nh	array(char)
[	O
256	int
]	O
,	O
np	array(char)
[	O
16	int
]	O
,	O
nq	array(char)
[	O
1024	int
]	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
REFERTO_FORMAT	*(char)
,	O
nh	array(char)
,	O
np	array(char)
,	O
nq	array(char)
)	O
==	O
3	int
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
verb	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Detected referral to %s on %s.\n"	*(char)
)	O
,	O
nq	array(char)
,	O
nh	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
nq	array(char)
,	O
"\r\n"	*(char)
)	O
;	O
fd	int
=	O
openconn	(*(char),*(char))->(int)
(	O
nh	array(char)
,	O
np	array(char)
)	O
;	O
do_query	(int,*(char))->(void)
(	O
fd	int
,	O
nq	array(char)
)	O
;	O
closeconn	(int)->(void)
(	O
fd	int
)	O
;	O
continue	O
;	O
}	O
}	O
for	O
(	O
p	*(char)
=	O
buf	*(char)
;	O
*	O
p	*(char)
&&	O
*	O
p	*(char)
!=	O
'\r'	O
&&	O
*	O
p	*(char)
!=	O
'\n'	O
;	O
p	*(char)
++	O
)	O
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
err_sys	(*(char))->(void)
(	O
"fgets"	*(char)
)	O
;	O
if	O
(	O
hide	int
==	O
1	int
)	O
err_quit	(*(char))->(void)
(	O
_	O
(	O
"Catastrophic error: disclaimer text has been changed.\n"	*(char)
"Please upgrade this program.\n"	*(char)
)	O
)	O
;	O
}	O
const	O
char	O
*	O
query_crsnic	(int,*(char))->(*(char))
(	O
const	O
int	O
sock	int
,	O
const	O
char	O
*	O
query	*(char)
)	O
{	O
char	O
*	O
temp	union(long,*(void))
,	O
buf	*(char)
[	O
100	int
]	O
,	O
*	O
ret	*(char)
=	O
NULL	O
;	O
FILE	struct
*	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
temp	union(long,*(void))
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
query	*(char)
)	O
+	O
1	int
+	O
2	int
+	O
1	int
)	O
;	O
*	O
temp	union(long,*(void))
=	O
'='	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	union(long,*(void))
+	O
1	int
,	O
query	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	union(long,*(void))
,	O
"\r\n"	*(char)
)	O
;	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
sock	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
sock	int
,	O
temp	union(long,*(void))
,	O
strlen	(*(char))->(long)
(	O
temp	union(long,*(void))
)	O
)	O
<	O
0	int
)	O
err_sys	(*(char))->(void)
(	O
"write"	*(char)
)	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
100	int
,	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
"   Whois Server:"	*(char)
,	O
16	int
)	O
==	O
0	int
&&	O
!	O
ret	*(char)
)	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
for	O
(	O
p	*(char)
=	O
buf	*(char)
;	O
*	O
p	*(char)
!=	O
':'	O
;	O
p	*(char)
++	O
)	O
;	O
for	O
(	O
p	*(char)
++	O
;	O
*	O
p	*(char)
==	O
' '	O
;	O
p	*(char)
++	O
)	O
;	O
ret	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
+	O
1	int
)	O
;	O
for	O
(	O
q	*(char)
=	O
ret	*(char)
;	O
*	O
p	*(char)
!=	O
'\n'	O
&&	O
*	O
p	*(char)
!=	O
'\r'	O
;	O
*	O
q	*(char)
++	O
=	O
*	O
p	*(char)
++	O
)	O
;	O
*	O
q	*(char)
=	O
'\0'	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fi	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
err_sys	(*(char))->(void)
(	O
"fgets"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp	union(long,*(void))
)	O
;	O
return	O
ret	*(char)
;	O
}	O
int	O
openconn	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
server	*(char)
,	O
const	O
char	O
*	O
port	*(char)
)	O
{	O
int	O
fd	int
;	O
int	O
i	int
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
ressave	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_UNSPEC	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
if	O
(	O
(	O
i	int
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
server	*(char)
,	O
port	*(char)
?	O
port	*(char)
:	O
"whois"	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
)	O
!=	O
0	int
)	O
err_quit	(*(char))->(void)
(	O
"getaddrinfo: %s"	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
i	int
)	O
)	O
;	O
for	O
(	O
ressave	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
if	O
(	O
(	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
,	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_socktype	int
,	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_protocol	int
)	O
)	O
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
==	O
0	int
)	O
break	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
!	O
res	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
err_sys	(*(char))->(void)
(	O
"connect"	*(char)
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
ressave	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
return	O
(	O
fd	int
)	O
;	O
}	O
void	O
closeconn	(int)->(void)
(	O
const	O
int	O
fd	int
)	O
{	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
void	O
sighandler	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
closeconn	(int)->(void)
(	O
sockfd	int
)	O
;	O
err_quit	(*(char))->(void)
(	O
_	O
(	O
"Interrupted by signal %d..."	*(char)
)	O
,	O
signum	int
)	O
;	O
}	O
int	O
domcmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
dom	*(char)
,	O
const	O
char	O
*	O
tld	*(char)
)	O
{	O
const	O
char	O
*	O
p	*(char)
,	O
*	O
q	*(char)
;	O
for	O
(	O
p	*(char)
=	O
dom	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
p	*(char)
++	O
)	O
;	O
p	*(char)
--	O
;	O
for	O
(	O
q	*(char)
=	O
tld	*(char)
;	O
*	O
q	*(char)
!=	O
'\0'	O
;	O
q	*(char)
++	O
)	O
;	O
q	*(char)
--	O
;	O
while	O
(	O
p	*(char)
>=	O
dom	*(char)
&&	O
q	*(char)
>=	O
tld	*(char)
&&	O
tolower	(int)->(int)
(	O
*	O
p	*(char)
)	O
==	O
*	O
q	*(char)
)	O
{	O
if	O
(	O
q	*(char)
==	O
tld	*(char)
)	O
return	O
1	int
;	O
p	*(char)
--	O
;	O
q	*(char)
--	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
domfind	(*(char),array(*(char)))->(int)
(	O
const	O
char	O
*	O
dom	*(char)
,	O
const	O
char	O
*	O
tldlist	array(*(char))
[	O
]	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
tldlist	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
domcmp	(*(char),*(char))->(int)
(	O
dom	*(char)
,	O
tldlist	array(*(char))
[	O
i	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
unsigned	O
long	O
myinet_aton	(*(char))->(long)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
a	int
,	O
b	int
,	O
c	int
,	O
d	int
;	O
if	O
(	O
!	O
s	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d.%d.%d.%d"	*(char)
,	O
&	O
a	int
,	O
&	O
b	int
,	O
&	O
c	int
,	O
&	O
d	int
)	O
!=	O
4	int
)	O
return	O
0	int
;	O
return	O
(	O
a	int
<<	O
24	int
)	O
+	O
(	O
b	int
<<	O
16	int
)	O
+	O
(	O
c	int
<<	O
8	int
)	O
+	O
d	int
;	O
}	O
void	O
err_sys	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": %s\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
err_quit	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
