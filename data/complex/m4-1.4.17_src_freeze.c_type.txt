static	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
reverse_symbol_list	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
result	*(*(char))
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
result	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
{	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
;	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
=	O
result	*(*(char))
;	O
result	*(*(char))
=	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
next	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
}	O
return	O
result	*(*(char))
;	O
}	O
void	O
produce_frozen_state	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
FILE	struct
*	O
file	*(char)
;	O
size_t	long
h	long
;	O
symbol	struct(*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void)))))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*(char)),*((*(struct`),int,*(*`))->(void)))))
*	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
file	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
O_BINARY	int
?	O
"wb"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot open `%s'"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"# This is a frozen state file generated by %s\n"	*(char)
,	O
PACKAGE_STRING	*(char)
)	O
;	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"V1\n"	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
DEF_LQUOTE	*(char)
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
DEF_RQUOTE	*(char)
)	O
)	O
{	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"Q%d,%d\n"	*(char)
,	O
(	O
int	O
)	O
lquote	struct(*(char),long)
.	O
length	long
,	O
(	O
int	O
)	O
rquote	struct(*(char),long)
.	O
length	long
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
file	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rquote	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
file	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
DEF_BCOMM	*(char)
)	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
DEF_ECOMM	*(char)
)	O
)	O
{	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"C%d,%d\n"	*(char)
,	O
(	O
int	O
)	O
bcomm	struct(*(char),long)
.	O
length	long
,	O
(	O
int	O
)	O
ecomm	struct(*(char),long)
.	O
length	long
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
bcomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
file	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ecomm	struct(*(char),long)
.	O
string	struct(*(char),long)
,	O
file	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
file	*(char)
)	O
;	O
}	O
for	O
(	O
h	long
=	O
0	int
;	O
h	long
<	O
hash_table_size	long
;	O
h	long
++	O
)	O
{	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
=	O
reverse_symbol_list	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
)	O
;	O
for	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
;	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
=	O
SYMBOL_NEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
{	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"T%d,%d\n"	*(char)
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
SYMBOL_TEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
file	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
SYMBOL_TEXT	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
file	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
file	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
find_builtin_by_addr	(*((*(struct(long,*`,*`,*`,*`,union`,int,*`,*`,*`,int,int,int)),int,*(*(struct`)))->(void)))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
SYMBOL_FUNC	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
;	O
if	O
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: builtin not found in builtin table!"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
xfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"F%d,%d\n"	*(char)
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
)	O
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
SYMBOL_NAME	O
(	O
sym	*(struct(*(struct(*(struct`),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union`))),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct(*`),*((*`,int,*`)->(void))))))
)	O
,	O
file	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
->	O
name	*(char)
,	O
file	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
file	*(char)
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in freeze_one_symbol ()"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
=	O
reverse_symbol_list	(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))->(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
(	O
symtab	*(*(struct(*(struct(*`,bool,bool,bool,bool,bool,int,*`,struct`)),bool,bool,bool,bool,bool,int,*(char),struct(enum(int,int,int),union(struct`,*`)))))
[	O
h	long
]	O
)	O
;	O
}	O
freeze_diversions	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
file	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"# End of frozen state file\n"	*(char)
,	O
file	*(char)
)	O
;	O
if	O
(	O
close_stream	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"unable to create frozen state"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
issue_expect_message	(int)->(void)
(	O
int	O
expected	int
)	O
{	O
if	O
(	O
expected	int
==	O
'\n'	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expecting line feed in frozen file"	*(char)
)	O
)	O
;	O
else	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expecting character `%c' in frozen file"	*(char)
,	O
expected	int
)	O
)	O
;	O
}	O
void	O
reload_frozen_state	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
FILE	struct
*	O
file	*(char)
;	O
int	O
character	int
;	O
int	O
operation	int
;	O
char	O
*	O
string	struct(*(char),long)
[	O
2	int
]	O
;	O
int	O
allocated	array(int)
[	O
2	int
]	O
;	O
int	O
number	array(int)
[	O
2	int
]	O
;	O
const	O
builtin	struct(*(char),bool,bool,bool,*((*(struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),int,*(*(struct(enum(int,int,int),union`))))->(void)))
*	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
;	O
bool	bool
advance_line	bool
=	O
true	int
;	O
file	*(char)
=	O
m4_path_search	(*(char),*(*(char)))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
file	*(char)
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot open %s"	*(char)
,	O
name	*(char)
)	O
)	O
;	O
current_file	*(char)
=	O
name	*(char)
;	O
allocated	array(int)
[	O
0	int
]	O
=	O
100	int
;	O
string	struct(*(char),long)
[	O
0	int
]	O
=	O
xcharalloc	(long)->(*(char))
(	O
(	O
size_t	long
)	O
allocated	array(int)
[	O
0	int
]	O
)	O
;	O
allocated	array(int)
[	O
1	int
]	O
=	O
100	int
;	O
string	struct(*(char),long)
[	O
1	int
]	O
=	O
xcharalloc	(long)->(*(char))
(	O
(	O
size_t	long
)	O
allocated	array(int)
[	O
1	int
]	O
)	O
;	O
GET_DIRECTIVE	O
;	O
VALIDATE	O
(	O
'V'	O
)	O
;	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array(int)
[	O
0	int
]	O
,	O
false	int
)	O
;	O
if	O
(	O
number	array(int)
[	O
0	int
]	O
>	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_MISMATCH	int
,	O
0	int
,	O
"frozen file version %d greater than max supported of 1"	*(char)
,	O
number	array(int)
[	O
0	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
number	array(int)
[	O
0	int
]	O
<	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"ill-formed frozen file, version directive expected"	*(char)
)	O
)	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
GET_DIRECTIVE	O
;	O
while	O
(	O
character	int
!=	O
EOF	O
)	O
{	O
switch	O
(	O
character	int
)	O
{	O
default	O
:	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"ill-formed frozen file"	*(char)
)	O
)	O
;	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'F'	O
:	O
case	O
'T'	O
:	O
case	O
'Q'	O
:	O
operation	int
=	O
character	int
;	O
GET_CHARACTER	O
;	O
if	O
(	O
operation	int
==	O
'D'	O
&&	O
character	int
==	O
'-'	O
)	O
{	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array(int)
[	O
0	int
]	O
,	O
true	int
)	O
;	O
number	array(int)
[	O
0	int
]	O
=	O
-	O
number	array(int)
[	O
0	int
]	O
;	O
}	O
else	O
GET_NUMBER	O
(	O
number	array(int)
[	O
0	int
]	O
,	O
false	int
)	O
;	O
VALIDATE	O
(	O
','	O
)	O
;	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array(int)
[	O
1	int
]	O
,	O
false	int
)	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
if	O
(	O
operation	int
!=	O
'D'	O
)	O
GET_STRING	O
(	O
0	int
)	O
;	O
GET_STRING	O
(	O
1	int
)	O
;	O
GET_CHARACTER	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
switch	O
(	O
operation	int
)	O
{	O
case	O
'C'	O
:	O
set_comment	(*(char),*(char))->(void)
(	O
string	struct(*(char),long)
[	O
0	int
]	O
,	O
string	struct(*(char),long)
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
make_diversion	(int)->(void)
(	O
number	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number	array(int)
[	O
1	int
]	O
>	O
0	int
)	O
output_text	(*(char),int)->(void)
(	O
string	struct(*(char),long)
[	O
1	int
]	O
,	O
number	array(int)
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
=	O
find_builtin_by_name	(*(char))->(*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))))
(	O
string	struct(*(char),long)
[	O
1	int
]	O
)	O
;	O
define_builtin	(*(char),*(struct(*(char),bool,bool,bool,*((*`,int,*`)->(void)))),enum(int,int,int,int,int))->(void)
(	O
string	struct(*(char),long)
[	O
0	int
]	O
,	O
bp	*(struct(*(char),bool,bool,bool,*((*(struct`),int,*(*`))->(void))))
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
define_user_macro	(*(char),*(char),enum(int,int,int,int,int))->(void)
(	O
string	struct(*(char),long)
[	O
0	int
]	O
,	O
string	struct(*(char),long)
[	O
1	int
]	O
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
set_quotes	(*(char),*(char))->(void)
(	O
string	struct(*(char),long)
[	O
0	int
]	O
,	O
string	struct(*(char),long)
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
GET_DIRECTIVE	O
;	O
}	O
free	(*(void))->(void)
(	O
string	struct(*(char),long)
[	O
0	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
string	struct(*(char),long)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
close_stream	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
!=	O
0	int
)	O
m4_error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"unable to read frozen state"	*(char)
)	O
)	O
;	O
current_file	*(char)
=	O
NULL	O
;	O
current_line	int
=	O
0	int
;	O
}	O
