char	O
*	O
exit_commands	array(*(char))
[	O
]	O
=	O
{	O
"quit"	*(char)
,	O
"exit"	*(char)
,	O
0	int
}	O
;	O
char	O
*	O
all_commands	array(*(char))
[	O
]	O
=	O
{	O
"quit"	*(char)
,	O
"exit"	*(char)
,	O
HELPCOMMAND	*(char)
,	O
SEARCHCOMMAND	*(char)
,	O
UNITMATCH	*(char)
,	O
0	int
}	O
;	O
struct	O
{	O
char	O
*	O
word	*(char)
;	O
char	O
delimit	char
;	O
int	O
checkopen	int
;	O
}	O
fnkeywords	array(struct(*(char),char,int))
[	O
]	O
=	O
{	O
{	O
"units="	*(char)
,	O
FUNCSEPCHAR	char
,	O
0	int
}	O
,	O
{	O
"domain="	*(char)
,	O
','	O
,	O
1	int
}	O
,	O
{	O
"range="	*(char)
,	O
','	O
,	O
1	int
}	O
,	O
{	O
NOERROR_KEYWORD	*(char)
,	O
' '	O
,	O
CO_NOARG	O
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
char	O
*	O
builtins	array(*(char))
[	O
]	O
=	O
{	O
"sin"	*(char)
,	O
"cos"	*(char)
,	O
"tan"	*(char)
,	O
"ln"	*(char)
,	O
"log"	*(char)
,	O
"exp"	*(char)
,	O
"acos"	*(char)
,	O
"atan"	*(char)
,	O
"asin"	*(char)
,	O
"sqrt"	*(char)
,	O
"cuberoot"	*(char)
,	O
"per"	*(char)
,	O
"sinh"	*(char)
,	O
"cosh"	*(char)
,	O
"tanh"	*(char)
,	O
"asinh"	*(char)
,	O
"atanh"	*(char)
,	O
"acosh"	*(char)
,	O
0	int
}	O
;	O
struct	O
{	O
char	O
*	O
format	*(char)
;	O
int	O
width	int
;	O
int	O
precision	int
;	O
char	O
type	char
;	O
}	O
num_format	struct(*(char),int,int,char)
;	O
struct	O
{	O
int	O
unitlists	int
,	O
oneline	int
,	O
quiet	int
,	O
round	int
,	O
showfactor	int
,	O
strictconvert	int
,	O
unitcheck	int
,	O
verbose	int
,	O
readline	int
;	O
}	O
flags	struct(int,int,int,int,int,int,int,int,int)
;	O
struct	O
parseflag	O
parserflags	struct
;	O
char	O
*	O
homeunitsfile	*(char)
=	O
".units"	*(char)
;	O
char	O
*	O
pager	*(char)
;	O
char	O
*	O
mylocale	*(char)
;	O
int	O
utf8mode	int
;	O
char	O
*	O
powerstring	*(char)
=	O
"^"	*(char)
;	O
char	O
*	O
unitsfiles	array(*(char))
[	O
MAXFILES	int
+	O
1	int
]	O
;	O
char	O
*	O
logfilename	*(char)
=	O
0	int
;	O
FILE	O
*	O
logfile	*(int)
=	O
0	int
;	O
char	O
*	O
promptprefix	*(char)
=	O
0	int
;	O
char	O
*	O
progname	*(char)
;	O
char	O
*	O
fullprogname	*(char)
;	O
char	O
*	O
progdir	*(char)
;	O
char	O
*	O
datadir	*(char)
;	O
char	O
*	O
deftext	*(char)
=	O
"        Definition: "	*(char)
;	O
char	O
*	O
digits	*(char)
=	O
"0123456789.,"	*(char)
;	O
char	O
*	O
errormsg	array(*(char))
[	O
]	O
=	O
{	O
"Successful completion"	*(char)
,	O
"Parse error"	*(char)
,	O
"Product overflow"	*(char)
,	O
"Unit reduction error (bad unit definition)"	*(char)
,	O
"Invalid sum or difference of non-conformable units"	*(char)
,	O
"Unit not dimensionless"	*(char)
,	O
"Unit not a root"	*(char)
,	O
"Unknown unit"	*(char)
,	O
"Bad argument"	*(char)
,	O
"Weird nonlinear unit type (bug in program)"	*(char)
,	O
"Function argument has wrong dimension"	*(char)
,	O
"Argument of function outside domain"	*(char)
,	O
"Nonlinear unit definition has unit error"	*(char)
,	O
"No inverse defined"	*(char)
,	O
"Parser memory overflow (recursive function definition?)"	*(char)
,	O
"Argument wrong dimension or bad nonlinear unit definition"	*(char)
,	O
"Cannot open units file"	*(char)
,	O
"Units file contains errors"	*(char)
,	O
"Memory allocation error"	*(char)
,	O
"Malformed number"	*(char)
,	O
"Unit name ends with nonzero digit without preceding '_'"	*(char)
,	O
"No previous result; '_' not set"	*(char)
,	O
"Base unit not dimensionless; rational exponent required"	*(char)
,	O
"Base unit not a root"	*(char)
,	O
"Exponent not dimensionless"	*(char)
,	O
"Unknown function name"	*(char)
,	O
}	O
;	O
char	O
*	O
invalid_utf8	*(char)
=	O
"invalid/nonprinting UTF-8"	*(char)
;	O
char	O
*	O
irreducible	*(char)
=	O
0	int
;	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
value	*(char)
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	*(char)
;	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
}	O
*	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
HASHSIZE	int
]	O
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
{	O
int	O
len	int
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
value	*(char)
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	*(char)
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
}	O
*	O
ptab	array(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
[	O
SIMPLEHASHSIZE	int
]	O
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
definition	*(char)
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	*(char)
;	O
}	O
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
firstalias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
0	int
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
*	O
aliaslistend	*(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
=	O
&	O
firstalias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
struct	O
func	*(struct)
*	O
ftab	array(*(struct))
[	O
SIMPLEHASHSIZE	int
]	O
;	O
char	O
*	O
function_parameter	*(char)
=	O
0	int
;	O
struct	O
unittype	O
*	O
parameter_value	*(struct)
=	O
0	int
;	O
int	O
lastunitset	int
=	O
0	int
;	O
struct	O
unittype	O
lastunit	struct
;	O
char	O
*	O
NULLUNIT	*(char)
=	O
""	*(char)
;	O
void	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
char	O
*	O
*	O
buf	*(*(char))
,	O
int	O
*	O
bufsize	*(int)
)	O
{	O
int	O
usemalloc	int
;	O
usemalloc	int
=	O
!	O
*	O
buf	*(*(char))
||	O
!	O
*	O
bufsize	*(int)
;	O
*	O
bufsize	*(int)
+=	O
BUFGROW	int
;	O
if	O
(	O
usemalloc	int
)	O
*	O
buf	*(*(char))
=	O
malloc	O
(	O
*	O
bufsize	*(int)
)	O
;	O
else	O
*	O
buf	*(*(char))
=	O
realloc	O
(	O
*	O
buf	*(*(char))
,	O
*	O
bufsize	*(int)
)	O
;	O
if	O
(	O
!	O
*	O
buf	*(*(char))
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: memory allocation error (growbuffer)\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
void	O
logprintf	(*(char))->(void)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	O
args	O
;	O
va_start	O
(	O
args	O
,	O
format	*(char)
)	O
;	O
vprintf	O
(	O
format	*(char)
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
{	O
va_start	O
(	O
args	O
,	O
format	*(char)
)	O
;	O
vfprintf	()->(int)
(	O
logfile	*(int)
,	O
format	*(char)
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
}	O
}	O
void	O
logputchar	(char)->(void)
(	O
char	O
c	char
)	O
{	O
putchar	()->(int)
(	O
c	char
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
fputc	()->(int)
(	O
c	char
,	O
logfile	*(int)
)	O
;	O
}	O
void	O
logputs	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
fputs	()->(int)
(	O
s	*(char)
,	O
stdout	O
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
fputs	()->(int)
(	O
s	*(char)
,	O
logfile	*(int)
)	O
;	O
}	O
int	O
hassubscript	(*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
const	O
char	O
*	O
ptr	*(char)
=	O
&	O
lastchar	O
(	O
str	*(char)
)	O
;	O
while	O
(	O
ptr	*(char)
>	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
strchr	O
(	O
digits	*(char)
,	O
*	O
ptr	*(char)
)	O
)	O
return	O
0	int
;	O
ptr	*(char)
--	O
;	O
if	O
(	O
*	O
ptr	*(char)
==	O
'_'	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
replace_minus	(*(char))->(void)
(	O
char	O
*	O
input	*(char)
)	O
{	O
char	O
*	O
unicode_minus	array(*(char))
[	O
]	O
=	O
{	O
"\xE2\x80\x92"	*(char)
,	O
"\xE2\x80\x93"	*(char)
,	O
"\xE2\x88\x92"	*(char)
,	O
0	int
}	O
;	O
char	O
*	O
inptr	*(char)
,	O
*	O
outptr	*(char)
,	O
*	O
ptr	*(char)
,	O
*	O
*	O
minus	*(*(char))
;	O
for	O
(	O
minus	*(*(char))
=	O
unicode_minus	array(*(char))
;	O
*	O
minus	*(*(char))
;	O
minus	*(*(char))
++	O
)	O
{	O
inptr	*(char)
=	O
outptr	*(char)
=	O
input	*(char)
;	O
do	O
{	O
ptr	*(char)
=	O
strstr	O
(	O
inptr	*(char)
,	O
*	O
minus	*(*(char))
)	O
;	O
if	O
(	O
ptr	*(char)
)	O
{	O
while	O
(	O
inptr	*(char)
<	O
ptr	*(char)
)	O
*	O
outptr	*(char)
++	O
=	O
*	O
inptr	*(char)
++	O
;	O
*	O
outptr	*(char)
++	O
=	O
'-'	O
;	O
inptr	*(char)
=	O
ptr	*(char)
+	O
strlen	O
(	O
*	O
minus	*(*(char))
)	O
;	O
}	O
}	O
while	O
(	O
ptr	*(char)
)	O
;	O
if	O
(	O
inptr	*(char)
>	O
input	*(char)
)	O
{	O
while	O
(	O
*	O
inptr	*(char)
)	O
*	O
outptr	*(char)
++	O
=	O
*	O
inptr	*(char)
++	O
;	O
*	O
outptr	*(char)
=	O
'\0'	O
;	O
}	O
}	O
}	O
void	O
replacectrlchars	(*(char))->(void)
(	O
char	O
*	O
string	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
string	*(char)
;	O
string	*(char)
++	O
)	O
if	O
(	O
iscntrl	O
(	O
*	O
string	*(char)
)	O
)	O
*	O
string	*(char)
=	O
' '	O
;	O
}	O
char	O
*	O
fgetscont	(*(char),int,*(int),*(int))->(*(char))
(	O
char	O
*	O
buf	*(*(char))
,	O
int	O
size	int
,	O
FILE	O
*	O
file	*(char)
,	O
int	O
*	O
count	*(int)
)	O
{	O
if	O
(	O
!	O
fgets	()->(int)
(	O
buf	*(*(char))
,	O
size	int
,	O
file	*(char)
)	O
)	O
return	O
0	int
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
while	O
(	O
strlen	O
(	O
buf	*(*(char))
)	O
>=	O
2	int
&&	O
0	int
==	O
strcmp	O
(	O
buf	*(*(char))
+	O
strlen	O
(	O
buf	*(*(char))
)	O
-	O
2	int
,	O
"\\\n"	*(char)
)	O
)	O
{	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
buf	*(*(char))
[	O
strlen	O
(	O
buf	*(*(char))
)	O
-	O
2	int
]	O
=	O
0	int
;	O
if	O
(	O
strlen	O
(	O
buf	*(*(char))
)	O
>=	O
size	int
-	O
1	int
)	O
return	O
buf	*(*(char))
;	O
if	O
(	O
!	O
fgets	()->(int)
(	O
buf	*(*(char))
+	O
strlen	O
(	O
buf	*(*(char))
)	O
,	O
size	int
-	O
strlen	O
(	O
buf	*(*(char))
)	O
,	O
file	*(char)
)	O
)	O
return	O
buf	*(*(char))
;	O
}	O
if	O
(	O
lastchar	O
(	O
buf	*(*(char))
)	O
==	O
'\\'	O
)	O
{	O
ungetc	()->(int)
(	O
'\\'	O
,	O
file	*(char)
)	O
;	O
lastchar	O
(	O
buf	*(*(char))
)	O
=	O
0	int
;	O
}	O
return	O
buf	*(*(char))
;	O
}	O
char	O
*	O
fgetslong	(*(*(char)),*(int),*(int),*(int))->(*(char))
(	O
char	O
*	O
*	O
buf	*(*(char))
,	O
int	O
*	O
bufsize	*(int)
,	O
FILE	O
*	O
file	*(char)
,	O
int	O
*	O
count	*(int)
)	O
{	O
int	O
dummy	int
;	O
if	O
(	O
!	O
count	*(int)
)	O
count	*(int)
=	O
&	O
dummy	int
;	O
if	O
(	O
!	O
*	O
bufsize	*(int)
)	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
buf	*(*(char))
,	O
bufsize	*(int)
)	O
;	O
if	O
(	O
!	O
fgetscont	(*(char),int,*(int),*(int))->(*(char))
(	O
*	O
buf	*(*(char))
,	O
*	O
bufsize	*(int)
,	O
file	*(char)
,	O
count	*(int)
)	O
)	O
return	O
0	int
;	O
while	O
(	O
lastchar	O
(	O
*	O
buf	*(*(char))
)	O
!=	O
'\n'	O
&&	O
!	O
feof	()->(int)
(	O
file	*(char)
)	O
)	O
{	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
buf	*(*(char))
,	O
bufsize	*(int)
)	O
;	O
fgetscont	(*(char),int,*(int),*(int))->(*(char))
(	O
*	O
buf	*(*(char))
+	O
strlen	O
(	O
*	O
buf	*(*(char))
)	O
,	O
*	O
bufsize	*(int)
-	O
strlen	O
(	O
*	O
buf	*(*(char))
)	O
,	O
file	*(char)
,	O
count	*(int)
)	O
;	O
(	O
*	O
count	*(int)
)	O
--	O
;	O
}	O
replacectrlchars	(*(char))->(void)
(	O
*	O
buf	*(*(char))
)	O
;	O
return	O
*	O
buf	*(*(char))
;	O
}	O
void	O
*	O
mymalloc	(int,*(char))->(*(void))
(	O
int	O
bytes	int
,	O
const	O
char	O
*	O
mesg	*(char)
)	O
{	O
void	O
*	O
pointer	*(void)
;	O
pointer	*(void)
=	O
malloc	O
(	O
bytes	int
)	O
;	O
if	O
(	O
!	O
pointer	*(void)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: memory allocation error %s\n"	*(char)
,	O
progname	*(char)
,	O
mesg	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
return	O
pointer	*(void)
;	O
}	O
char	O
*	O
dupstr	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
ret	*(char)
;	O
ret	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
str	*(char)
)	O
+	O
1	int
,	O
"(dupstr)"	*(char)
)	O
;	O
strcpy	O
(	O
ret	*(char)
,	O
str	*(char)
)	O
;	O
return	O
ret	*(char)
;	O
}	O
char	O
*	O
dupnstr	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
string	*(char)
,	O
int	O
length	int
)	O
{	O
char	O
*	O
newstr	*(char)
;	O
newstr	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
length	int
+	O
1	int
,	O
"(dupnstr)"	*(char)
)	O
;	O
strncpy	O
(	O
newstr	*(char)
,	O
string	*(char)
,	O
length	int
)	O
;	O
newstr	*(char)
[	O
length	int
]	O
=	O
0	int
;	O
return	O
newstr	*(char)
;	O
}	O
int	O
strwidth	(*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
wchar_t	O
*	O
widestr	O
;	O
int	O
len	int
;	O
if	O
(	O
!	O
utf8mode	int
)	O
return	O
strlen	O
(	O
str	*(char)
)	O
;	O
len	int
=	O
strlen	O
(	O
str	*(char)
)	O
+	O
1	int
;	O
widestr	O
=	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
wchar_t	O
)	O
*	O
len	int
,	O
"(strwidth)"	*(char)
)	O
;	O
len	int
=	O
mbsrtowcs	()->(int)
(	O
widestr	O
,	O
&	O
str	*(char)
,	O
len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
len	int
==	O
-	O
1	int
)	O
{	O
free	()->(int)
(	O
widestr	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
wcswidth	()->(int)
(	O
widestr	O
,	O
len	int
)	O
;	O
free	()->(int)
(	O
widestr	O
)	O
;	O
return	O
len	int
;	O
}	O
unsigned	O
uhash	(*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
unsigned	O
hashval	int
;	O
for	O
(	O
hashval	int
=	O
0	int
;	O
*	O
str	*(char)
;	O
str	*(char)
++	O
)	O
hashval	int
=	O
*	O
str	*(char)
+	O
HASHNUMBER	int
*	O
hashval	int
;	O
return	O
(	O
hashval	int
%	O
HASHSIZE	int
)	O
;	O
}	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
for	O
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
uhash	(*(char))->(int)
(	O
str	*(char)
)	O
]	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
if	O
(	O
strcmp	O
(	O
str	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
return	O
NULL	O
;	O
}	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
plookup	(*(char))->(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*`,*`,int,*`,*`)))))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
bestprefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
NULL	O
;	O
int	O
bestlength	int
=	O
0	int
;	O
for	O
(	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
ptab	array(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
[	O
simplehash	O
(	O
str	*(char)
)	O
]	O
;	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
if	O
(	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
>	O
bestlength	int
&&	O
!	O
strncmp	O
(	O
str	*(char)
,	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
)	O
)	O
{	O
bestlength	int
=	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
;	O
bestprefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
}	O
}	O
return	O
bestprefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
}	O
struct	O
func	*(struct)
*	O
fnlookup	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
struct	O
func	*(struct)
*	O
funcptr	*(struct)
;	O
for	O
(	O
funcptr	*(struct)
=	O
ftab	array(*(struct))
[	O
simplehash	O
(	O
str	*(char)
)	O
]	O
;	O
funcptr	*(struct)
;	O
funcptr	*(struct)
=	O
funcptr	*(struct)
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
if	O
(	O
!	O
strcmp	O
(	O
funcptr	*(struct)
->	O
name	*(char)
,	O
str	*(char)
)	O
)	O
return	O
funcptr	*(struct)
;	O
return	O
0	int
;	O
}	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
for	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
firstalias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
if	O
(	O
!	O
strcmp	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
,	O
str	*(char)
)	O
)	O
return	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
return	O
0	int
;	O
}	O
void	O
addfunction	(*(struct))->(void)
(	O
struct	O
func	*(struct)
*	O
newfunc	*(struct)
)	O
{	O
int	O
val	int
;	O
val	int
=	O
simplehash	O
(	O
newfunc	*(struct)
->	O
name	*(char)
)	O
;	O
newfunc	*(struct)
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ftab	array(*(struct))
[	O
val	int
]	O
;	O
ftab	array(*(struct))
[	O
val	int
]	O
=	O
newfunc	*(struct)
;	O
}	O
void	O
freefunction	(*(struct))->(void)
(	O
struct	O
func	*(struct)
*	O
funcentry	*(struct)
)	O
{	O
if	O
(	O
funcentry	*(struct)
->	O
table	O
)	O
{	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
table	O
)	O
;	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
tableunit	*(char)
)	O
;	O
}	O
else	O
{	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
forward	O
.	O
param	O
)	O
;	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_min	*(double)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_min	*(double)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_max	*(double)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_max	*(double)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
forward	O
.	O
dimen	*(char)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
forward	O
.	O
dimen	*(char)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
def	*(char)
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
def	*(char)
)	O
;	O
if	O
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
param	O
)	O
free	()->(int)
(	O
funcentry	*(struct)
->	O
inverse	int
.	O
param	O
)	O
;	O
}	O
}	O
void	O
removespaces	(*(char))->(void)
(	O
char	O
*	O
in	*(char)
)	O
{	O
char	O
*	O
ptr	*(char)
;	O
if	O
(	O
*	O
in	*(char)
)	O
{	O
for	O
(	O
ptr	*(char)
=	O
&	O
lastchar	O
(	O
in	*(char)
)	O
;	O
*	O
ptr	*(char)
==	O
' '	O
;	O
ptr	*(char)
--	O
)	O
;	O
*	O
(	O
ptr	*(char)
+	O
1	int
)	O
=	O
0	int
;	O
if	O
(	O
*	O
in	*(char)
==	O
' '	O
)	O
{	O
ptr	*(char)
=	O
in	*(char)
+	O
strspn	O
(	O
in	*(char)
,	O
" "	*(char)
)	O
;	O
memmove	O
(	O
in	*(char)
,	O
ptr	*(char)
,	O
strlen	O
(	O
ptr	*(char)
)	O
+	O
1	int
)	O
;	O
}	O
}	O
}	O
struct	O
func	*(struct)
*	O
invfnlookup	(*(char))->(*(struct))
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
*	O
str	*(char)
!=	O
'~'	O
)	O
return	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
str	*(char)
+	O
1	int
)	O
;	O
return	O
fnlookup	(*(char))->(*(struct))
(	O
str	*(char)
+	O
1	int
)	O
;	O
}	O
char	O
*	O
strip_comment	(*(char))->(*(char))
(	O
char	O
*	O
line	*(char)
)	O
{	O
char	O
*	O
comment	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
line	*(char)
=	O
strchr	O
(	O
line	*(char)
,	O
COMMENTCHAR	char
)	O
)	O
)	O
{	O
comment	*(char)
=	O
line	*(char)
+	O
1	int
;	O
*	O
line	*(char)
=	O
0	int
;	O
}	O
return	O
comment	*(char)
;	O
}	O
void	O
tightprint	(*(int),*(char))->(void)
(	O
FILE	O
*	O
outfile	*(int)
,	O
char	O
*	O
string	*(char)
)	O
{	O
while	O
(	O
*	O
string	*(char)
)	O
{	O
fputc	()->(int)
(	O
*	O
string	*(char)
,	O
outfile	*(int)
)	O
;	O
if	O
(	O
*	O
string	*(char)
!=	O
' '	O
)	O
string	*(char)
++	O
;	O
else	O
while	O
(	O
*	O
string	*(char)
==	O
' '	O
)	O
string	*(char)
++	O
;	O
}	O
}	O
void	O
splitline	(*(char),*(*(char)),*(*(char)))->(void)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
*	O
first	*(*(char))
,	O
char	O
*	O
*	O
second	*(*(char))
)	O
{	O
*	O
second	*(*(char))
=	O
0	int
;	O
*	O
first	*(*(char))
=	O
strtok	O
(	O
line	*(char)
,	O
" "	*(char)
)	O
;	O
if	O
(	O
*	O
first	*(*(char))
)	O
{	O
*	O
second	*(*(char))
=	O
strtok	O
(	O
0	int
,	O
"\n"	*(char)
)	O
;	O
if	O
(	O
*	O
second	*(*(char))
)	O
{	O
removespaces	(*(char))->(void)
(	O
*	O
second	*(*(char))
)	O
;	O
if	O
(	O
emptystr	O
(	O
*	O
second	*(*(char))
)	O
)	O
*	O
second	*(*(char))
=	O
0	int
;	O
}	O
}	O
}	O
int	O
isdecimal	(char)->(int)
(	O
char	O
c	char
)	O
{	O
return	O
strchr	O
(	O
digits	*(char)
,	O
c	char
)	O
!=	O
NULL	O
;	O
}	O
int	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
char	O
*	O
name	*(char)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
)	O
{	O
char	O
nonunitchars	array(char)
[	O
]	O
=	O
"~;+-*/|^)"	*(char)
;	O
char	O
*	O
*	O
ptr	*(char)
;	O
char	O
*	O
cptr	*(char)
;	O
if	O
(	O
(	O
cptr	*(char)
=	O
strpbrk	O
(	O
name	*(char)
,	O
nonunitchars	array(char)
)	O
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' in units file '%s' on line %d ignored.  It contains invalid character '%c'\n"	*(char)
,	O
progname	*(char)
,	O
name	*(char)
,	O
file	*(char)
,	O
linenum	int
,	O
*	O
cptr	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strchr	O
(	O
digits	*(char)
,	O
name	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' in units file '%s' on line %d ignored.  It starts with a digit\n"	*(char)
,	O
progname	*(char)
,	O
name	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
ptr	*(char)
=	O
builtins	array(*(char))
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
*	O
ptr	*(char)
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: redefinition of built-in function '%s' in file '%s' on line %d ignored.\n"	*(char)
,	O
progname	*(char)
,	O
name	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
ptr	*(char)
=	O
all_commands	array(*(char))
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
*	O
ptr	*(char)
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit name '%s' in file '%s' on line %d may be hidden by command with the same name.\n"	*(char)
,	O
progname	*(char)
,	O
name	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
unitdef	*(char)
,	O
int	O
*	O
count	*(int)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
,	O
int	O
redefine	int
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
unsigned	O
hashval	int
;	O
if	O
(	O
unitname	*(char)
[	O
0	int
]	O
==	O
'_'	O
||	O
lastchar	O
(	O
unitname	*(char)
)	O
==	O
'_'	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' on line %d of '%s' ignored.  It starts or ends with '_'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
strchr	O
(	O
".,23456789"	*(char)
,	O
lastchar	O
(	O
unitname	*(char)
)	O
)	O
&&	O
!	O
hassubscript	(*(char))->(int)
(	O
unitname	*(char)
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' on line %d of '%s' ignored.  %s\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errormsg	array(*(char))
[	O
E_UNITEND	O
]	O
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
unitname	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
&&	O
!	O
redefine	int
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
linenumber	int
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
free	()->(int)
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
}	O
else	O
{	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
(	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
,	O
"(newunit)"	*(char)
)	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
hashval	int
=	O
uhash	(*(char))->(int)
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
hashval	int
]	O
;	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
hashval	int
]	O
=	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
}	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitdef	*(char)
)	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
linenumber	int
=	O
linenum	int
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
file	*(char)
=	O
file	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
newprefix	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
unitdef	*(char)
,	O
int	O
*	O
count	*(int)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
,	O
int	O
redefine	int
)	O
{	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
unsigned	O
pval	int
;	O
lastchar	O
(	O
unitname	*(char)
)	O
=	O
0	int
;	O
if	O
(	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
(	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
plookup	(*(char))->(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*`,*`,int,*`,*`)))))
(	O
unitname	*(char)
)	O
)	O
&&	O
!	O
strcmp	O
(	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
unitname	*(char)
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
&&	O
!	O
redefine	int
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: prefix '%s-' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
linenumber	int
,	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
free	()->(int)
(	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
}	O
else	O
{	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
(	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
*	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
)	O
,	O
"(newprefix)"	*(char)
)	O
;	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
=	O
strlen	O
(	O
unitname	*(char)
)	O
;	O
pval	int
=	O
simplehash	O
(	O
unitname	*(char)
)	O
;	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ptab	array(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
[	O
pval	int
]	O
;	O
ptab	array(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
[	O
pval	int
]	O
=	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
}	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitdef	*(char)
)	O
;	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
linenumber	int
=	O
linenum	int
;	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
file	*(char)
=	O
file	*(char)
;	O
return	O
0	int
;	O
}	O
char	O
*	O
parsepair	(*(char),*(*(char)),*(*(char)),*(int),*(int),char,int,*(char),int,*(char),*(int))->(*(char))
(	O
char	O
*	O
input	*(char)
,	O
char	O
*	O
*	O
first	*(*(char))
,	O
char	O
*	O
*	O
second	*(*(char))
,	O
int	O
*	O
firstopen	*(int)
,	O
int	O
*	O
secondopen	*(int)
,	O
char	O
delimiter	char
,	O
int	O
checkopen	int
,	O
char	O
*	O
unitname	*(char)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
)	O
{	O
char	O
*	O
start	*(char)
,	O
*	O
end	*(char)
,	O
*	O
middle	*(char)
;	O
start	*(char)
=	O
strpbrk	O
(	O
input	*(char)
,	O
checkopen	int
?	O
"[("	*(char)
:	O
"["	*(char)
)	O
;	O
if	O
(	O
!	O
start	*(char)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: expecting '[' %s in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
checkopen	int
?	O
"or '('"	*(char)
:	O
""	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
start	*(char)
==	O
'('	O
)	O
*	O
firstopen	*(int)
=	O
1	int
;	O
else	O
*	O
firstopen	*(int)
=	O
0	int
;	O
*	O
start	*(char)
++	O
=	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
input	*(char)
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
input	*(char)
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unexpected characters before '%c' in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
*	O
firstopen	*(int)
?	O
'('	O
:	O
'['	O
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
end	*(char)
=	O
strpbrk	O
(	O
start	*(char)
,	O
checkopen	int
?	O
"])"	*(char)
:	O
"]"	*(char)
)	O
;	O
if	O
(	O
!	O
end	*(char)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: expecting ']' %s in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
checkopen	int
?	O
"or ')'"	*(char)
:	O
""	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
end	*(char)
==	O
')'	O
)	O
*	O
secondopen	*(int)
=	O
1	int
;	O
else	O
*	O
secondopen	*(int)
=	O
0	int
;	O
*	O
end	*(char)
++	O
=	O
0	int
;	O
middle	*(char)
=	O
strchr	O
(	O
start	*(char)
,	O
delimiter	char
)	O
;	O
if	O
(	O
middle	*(char)
)	O
{	O
*	O
middle	*(char)
++	O
=	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
middle	*(char)
)	O
;	O
*	O
second	*(*(char))
=	O
middle	*(char)
;	O
}	O
else	O
*	O
second	*(*(char))
=	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
start	*(char)
)	O
;	O
*	O
first	*(*(char))
=	O
start	*(char)
;	O
return	O
end	*(char)
;	O
}	O
int	O
extract_interval	(*(char),*(char),*(*(double)),*(*(double)))->(int)
(	O
char	O
*	O
first	*(*(char))
,	O
char	O
*	O
second	*(*(char))
,	O
double	O
*	O
*	O
firstout	*(*(double))
,	O
double	O
*	O
*	O
secondout	*(*(double))
)	O
{	O
double	O
val	int
;	O
char	O
*	O
end	*(char)
;	O
if	O
(	O
!	O
emptystr	O
(	O
first	*(*(char))
)	O
)	O
{	O
val	int
=	O
strtod	O
(	O
first	*(*(char))
,	O
&	O
end	*(char)
)	O
;	O
if	O
(	O
*	O
end	*(char)
)	O
return	O
EI_ERR_MALF	int
;	O
else	O
{	O
*	O
firstout	*(*(double))
=	O
(	O
double	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(extract_interval)"	*(char)
)	O
;	O
*	O
*	O
firstout	*(*(double))
=	O
val	int
;	O
}	O
}	O
if	O
(	O
second	*(*(char))
&&	O
!	O
emptystr	O
(	O
second	*(*(char))
)	O
)	O
{	O
val	int
=	O
strtod	O
(	O
second	*(*(char))
,	O
&	O
end	*(char)
)	O
;	O
if	O
(	O
*	O
end	*(char)
)	O
return	O
EI_ERR_MALF	int
;	O
else	O
if	O
(	O
*	O
firstout	*(*(double))
&&	O
*	O
*	O
firstout	*(*(double))
>=	O
val	int
)	O
return	O
EI_ERR_DEC	int
;	O
else	O
{	O
*	O
secondout	*(*(double))
=	O
(	O
double	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(extract_interval)"	*(char)
)	O
;	O
*	O
*	O
secondout	*(*(double))
=	O
val	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
copyfunctype	(*(struct),*(struct))->(void)
(	O
struct	O
functype	O
*	O
dest	*(struct)
,	O
struct	O
functype	O
*	O
src	*(struct)
)	O
{	O
dest	*(struct)
->	O
domain_min_open	int
=	O
src	*(struct)
->	O
domain_min_open	int
;	O
dest	*(struct)
->	O
domain_max_open	int
=	O
src	*(struct)
->	O
domain_max_open	int
;	O
dest	*(struct)
->	O
param	O
=	O
dest	*(struct)
->	O
def	*(char)
=	O
dest	*(struct)
->	O
dimen	*(char)
=	O
NULL	O
;	O
dest	*(struct)
->	O
domain_min	*(double)
=	O
dest	*(struct)
->	O
domain_max	*(double)
=	O
NULL	O
;	O
if	O
(	O
src	*(struct)
->	O
param	O
)	O
dest	*(struct)
->	O
param	O
=	O
dupstr	(*(char))->(*(char))
(	O
src	*(struct)
->	O
param	O
)	O
;	O
if	O
(	O
src	*(struct)
->	O
def	*(char)
)	O
dest	*(struct)
->	O
def	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
src	*(struct)
->	O
def	*(char)
)	O
;	O
if	O
(	O
src	*(struct)
->	O
dimen	*(char)
)	O
dest	*(struct)
->	O
dimen	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
src	*(struct)
->	O
dimen	*(char)
)	O
;	O
if	O
(	O
src	*(struct)
->	O
domain_min	*(double)
)	O
{	O
dest	*(struct)
->	O
domain_min	*(double)
=	O
(	O
double	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(copyfunctype)"	*(char)
)	O
;	O
*	O
dest	*(struct)
->	O
domain_min	*(double)
=	O
*	O
src	*(struct)
->	O
domain_min	*(double)
;	O
}	O
if	O
(	O
src	*(struct)
->	O
domain_max	*(double)
)	O
{	O
dest	*(struct)
->	O
domain_max	*(double)
=	O
(	O
double	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(copyfunctype)"	*(char)
)	O
;	O
*	O
dest	*(struct)
->	O
domain_max	*(double)
=	O
*	O
src	*(struct)
->	O
domain_max	*(double)
;	O
}	O
}	O
int	O
copyfunction	(*(char),*(char),*(int),int,*(char),*(int))->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
funcname	*(char)
,	O
int	O
*	O
count	*(int)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
)	O
{	O
struct	O
func	*(struct)
*	O
source	*(struct)
,	O
*	O
funcentry	*(struct)
;	O
int	O
i	int
;	O
if	O
(	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
)	O
return	O
E_BADFILE	O
;	O
removespaces	(*(char))->(void)
(	O
funcname	*(char)
)	O
;	O
i	int
=	O
strlen	O
(	O
funcname	*(char)
)	O
-	O
2	int
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
!	O
strcmp	O
(	O
funcname	*(char)
+	O
i	int
,	O
"()"	*(char)
)	O
)	O
funcname	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
source	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
funcname	*(char)
)	O
;	O
if	O
(	O
!	O
source	*(struct)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
{	O
if	O
(	O
!	O
strpbrk	O
(	O
funcname	*(char)
,	O
" ;][()+*/-^"	*(char)
)	O
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: bad definition for '%s' in '%s' line %d, function '%s' not defined\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
,	O
funcname	*(char)
)	O
;	O
else	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: bad function definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
}	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
funcentry	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
unitname	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
funcentry	*(struct)
->	O
linenumber	int
,	O
funcentry	*(struct)
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
freefunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
}	O
else	O
{	O
funcentry	*(struct)
=	O
(	O
struct	O
func	*(struct)
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
func	*(struct)
)	O
,	O
"(newfunction)"	*(char)
)	O
;	O
funcentry	*(struct)
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
addfunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
}	O
funcentry	*(struct)
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	*(struct)
->	O
file	*(char)
=	O
file	*(char)
;	O
funcentry	*(struct)
->	O
skip_error_check	O
=	O
source	*(struct)
->	O
skip_error_check	O
;	O
if	O
(	O
source	*(struct)
->	O
table	O
)	O
{	O
funcentry	*(struct)
->	O
tablelen	O
=	O
source	*(struct)
->	O
tablelen	O
;	O
funcentry	*(struct)
->	O
tableunit	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
source	*(struct)
->	O
tableunit	*(char)
)	O
;	O
funcentry	*(struct)
->	O
table	O
=	O
(	O
struct	O
pair	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
funcentry	*(struct)
->	O
tablelen	O
,	O
"(copyfunction)"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
funcentry	*(struct)
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
funcentry	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
location	O
=	O
source	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
location	O
;	O
funcentry	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
value	*(char)
=	O
source	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
value	*(char)
;	O
}	O
}	O
else	O
{	O
funcentry	*(struct)
->	O
table	O
=	O
0	int
;	O
copyfunctype	(*(struct),*(struct))->(void)
(	O
&	O
funcentry	*(struct)
->	O
forward	O
,	O
&	O
source	*(struct)
->	O
forward	O
)	O
;	O
copyfunctype	(*(struct),*(struct))->(void)
(	O
&	O
funcentry	*(struct)
->	O
inverse	int
,	O
&	O
source	*(struct)
->	O
inverse	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
newfunction	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
unitdef	*(char)
,	O
int	O
*	O
count	*(int)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
,	O
int	O
redefine	int
)	O
{	O
char	O
*	O
start	*(char)
,	O
*	O
end	*(char)
,	O
*	O
inv	*(char)
,	O
*	O
forward_dim	*(char)
,	O
*	O
inverse_dim	*(char)
,	O
*	O
first	*(*(char))
,	O
*	O
second	*(*(char))
;	O
double	O
*	O
domain_min	*(double)
,	O
*	O
domain_max	*(double)
,	O
*	O
range_min	*(double)
,	O
*	O
range_max	*(double)
;	O
struct	O
func	*(struct)
*	O
funcentry	*(struct)
;	O
int	O
looking_for_keywords	int
,	O
i	int
,	O
firstopen	*(int)
,	O
secondopen	*(int)
;	O
int	O
domain_min_open	int
,	O
domain_max_open	int
,	O
range_min_open	int
,	O
range_max_open	int
;	O
int	O
noerror	int
=	O
0	int
;	O
if	O
(	O
*	O
unitname	*(char)
==	O
'('	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' on line %d of '%s' ignored.  It starts with a '('\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
start	*(char)
=	O
strchr	O
(	O
unitname	*(char)
,	O
'('	O
)	O
;	O
end	*(char)
=	O
strchr	O
(	O
unitname	*(char)
,	O
')'	O
)	O
;	O
*	O
start	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
start	*(char)
==	O
end	*(char)
)	O
return	O
copyfunction	(*(char),*(char),*(int),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
count	*(int)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
;	O
if	O
(	O
!	O
end	*(char)
||	O
strlen	O
(	O
end	*(char)
)	O
>	O
1	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: bad function definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
*	O
end	*(char)
=	O
0	int
;	O
forward_dim	*(char)
=	O
NULL	O
;	O
inverse_dim	*(char)
=	O
NULL	O
;	O
domain_min	*(double)
=	O
NULL	O
;	O
domain_max	*(double)
=	O
NULL	O
;	O
range_min	*(double)
=	O
NULL	O
;	O
range_max	*(double)
=	O
NULL	O
;	O
domain_min_open	int
=	O
0	int
;	O
domain_max_open	int
=	O
0	int
;	O
range_min_open	int
=	O
0	int
;	O
range_max_open	int
=	O
0	int
;	O
looking_for_keywords	int
=	O
1	int
;	O
while	O
(	O
looking_for_keywords	int
)	O
{	O
looking_for_keywords	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
word	*(char)
;	O
i	int
++	O
)	O
{	O
if	O
(	O
startswith	O
(	O
unitdef	*(char)
,	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
word	*(char)
)	O
)	O
{	O
looking_for_keywords	int
=	O
1	int
;	O
unitdef	*(char)
+=	O
strlen	O
(	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
word	*(char)
)	O
;	O
if	O
(	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
checkopen	int
!=	O
CO_NOARG	O
)	O
{	O
unitdef	*(char)
=	O
parsepair	(*(char),*(*(char)),*(*(char)),*(int),*(int),char,int,*(char),int,*(char),*(int))->(*(char))
(	O
unitdef	*(char)
,	O
&	O
first	*(*(char))
,	O
&	O
second	*(*(char))
,	O
&	O
firstopen	*(int)
,	O
&	O
secondopen	*(int)
,	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
delimit	char
,	O
fnkeywords	array(struct(*(char),char,int))
[	O
i	int
]	O
.	O
checkopen	int
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
;	O
if	O
(	O
!	O
unitdef	*(char)
)	O
{	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
removespaces	(*(char))->(void)
(	O
unitdef	*(char)
)	O
;	O
}	O
if	O
(	O
i	int
==	O
FN_NOERROR	int
)	O
noerror	int
=	O
1	int
;	O
if	O
(	O
i	int
==	O
FN_UNITS	int
)	O
{	O
if	O
(	O
forward_dim	*(char)
||	O
inverse_dim	*(char)
)	O
{	O
REPEAT_ERR	O
;	O
return	O
E_BADFILE	O
;	O
}	O
forward_dim	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
first	*(*(char))
)	O
;	O
if	O
(	O
second	*(*(char))
)	O
inverse_dim	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
second	*(*(char))
)	O
;	O
}	O
if	O
(	O
i	int
==	O
FN_DOMAIN	int
)	O
{	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
domain_min	*(double)
||	O
domain_max	*(double)
)	O
{	O
REPEAT_ERR	O
;	O
return	O
E_BADFILE	O
;	O
}	O
err	int
=	O
extract_interval	(*(char),*(char),*(*(double)),*(*(double)))->(int)
(	O
first	*(*(char))
,	O
second	*(*(char))
,	O
&	O
domain_min	*(double)
,	O
&	O
domain_max	*(double)
)	O
;	O
domain_min_open	int
=	O
firstopen	*(int)
;	O
domain_max_open	int
=	O
secondopen	*(int)
;	O
if	O
(	O
err	int
)	O
FREE_STUFF	O
;	O
if	O
(	O
err	int
==	O
EI_ERR_DEC	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: second endpoint for domain must be greater than the first\n       in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
err	int
==	O
EI_ERR_MALF	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: malformed domain in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
FN_RANGE	int
)	O
{	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
range_min	*(double)
||	O
range_max	*(double)
)	O
{	O
REPEAT_ERR	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
err	int
=	O
extract_interval	(*(char),*(char),*(*(double)),*(*(double)))->(int)
(	O
first	*(*(char))
,	O
second	*(*(char))
,	O
&	O
range_min	*(double)
,	O
&	O
range_max	*(double)
)	O
;	O
range_min_open	int
=	O
firstopen	*(int)
;	O
range_max_open	int
=	O
secondopen	*(int)
;	O
if	O
(	O
err	int
)	O
FREE_STUFF	O
;	O
if	O
(	O
err	int
==	O
EI_ERR_DEC	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: second endpoint for range must be greater than the first\n       in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
err	int
==	O
EI_ERR_MALF	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: malformed range in definition of '%s' in '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
emptystr	O
(	O
unitdef	*(char)
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' lacks a definition at line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
*	O
unitdef	*(char)
==	O
'['	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' missing keyword before '[' on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
!	O
forward_dim	*(char)
&&	O
(	O
(	O
domain_min	*(double)
&&	O
*	O
domain_min	*(double)
)	O
||	O
(	O
domain_max	*(double)
&&	O
*	O
domain_max	*(double)
)	O
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' defined on line %d of '%s' has domain with no units.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
!	O
inverse_dim	*(char)
&&	O
(	O
(	O
range_min	*(double)
&&	O
*	O
range_min	*(double)
)	O
||	O
(	O
range_max	*(double)
&&	O
*	O
range_max	*(double)
)	O
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' defined on line %d of '%s' has range with no units.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
funcentry	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
unitname	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
&&	O
!	O
redefine	int
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
funcentry	*(struct)
->	O
linenumber	int
,	O
funcentry	*(struct)
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
freefunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
}	O
else	O
{	O
funcentry	*(struct)
=	O
(	O
struct	O
func	*(struct)
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
func	*(struct)
)	O
,	O
"(newfunction)"	*(char)
)	O
;	O
funcentry	*(struct)
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
addfunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
}	O
funcentry	*(struct)
->	O
table	O
=	O
0	int
;	O
funcentry	*(struct)
->	O
skip_error_check	O
=	O
noerror	int
;	O
funcentry	*(struct)
->	O
forward	O
.	O
dimen	*(char)
=	O
forward_dim	*(char)
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
=	O
inverse_dim	*(char)
;	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
=	O
domain_min	*(double)
;	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
=	O
domain_max	*(double)
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_min	*(double)
=	O
range_min	*(double)
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_max	*(double)
=	O
range_max	*(double)
;	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_min_open	int
=	O
domain_min_open	int
;	O
funcentry	*(struct)
->	O
forward	O
.	O
domain_max_open	int
=	O
domain_max_open	int
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_min_open	int
=	O
range_min_open	int
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
domain_max_open	int
=	O
range_max_open	int
;	O
inv	*(char)
=	O
strchr	O
(	O
unitdef	*(char)
,	O
FUNCSEPCHAR	char
)	O
;	O
if	O
(	O
inv	*(char)
)	O
*	O
inv	*(char)
++	O
=	O
0	int
;	O
funcentry	*(struct)
->	O
forward	O
.	O
param	O
=	O
dupstr	(*(char))->(*(char))
(	O
start	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
unitdef	*(char)
)	O
;	O
funcentry	*(struct)
->	O
forward	O
.	O
def	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitdef	*(char)
)	O
;	O
if	O
(	O
inv	*(char)
)	O
{	O
removespaces	(*(char))->(void)
(	O
inv	*(char)
)	O
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
def	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
inv	*(char)
)	O
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
param	O
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
}	O
else	O
{	O
funcentry	*(struct)
->	O
inverse	int
.	O
def	*(char)
=	O
0	int
;	O
funcentry	*(struct)
->	O
inverse	int
.	O
param	O
=	O
0	int
;	O
}	O
funcentry	*(struct)
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	*(struct)
->	O
file	*(char)
=	O
file	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
newtable	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
unitdef	*(char)
,	O
int	O
*	O
count	*(int)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
,	O
int	O
redefine	int
)	O
{	O
char	O
*	O
start	*(char)
,	O
*	O
end	*(char)
;	O
char	O
*	O
tableunit	*(char)
;	O
int	O
tablealloc	int
,	O
tabpt	int
;	O
struct	O
pair	O
*	O
tab	*(struct)
;	O
struct	O
func	*(struct)
*	O
funcentry	*(struct)
;	O
int	O
noerror	int
=	O
0	int
;	O
tableunit	*(char)
=	O
strchr	O
(	O
unitname	*(char)
,	O
'['	O
)	O
;	O
end	*(char)
=	O
strchr	O
(	O
unitname	*(char)
,	O
']'	O
)	O
;	O
*	O
tableunit	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
checkunitname	(*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
,	O
errfile	*(int)
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
!	O
end	*(char)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: missing ']' in units file '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
strlen	O
(	O
end	*(char)
)	O
>	O
1	int
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unexpected characters after ']' in units file '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
*	O
end	*(char)
=	O
0	int
;	O
tab	*(struct)
=	O
(	O
struct	O
pair	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
20	int
,	O
"(newtable)"	*(char)
)	O
;	O
tablealloc	int
=	O
20	int
;	O
tabpt	int
=	O
0	int
;	O
start	*(char)
=	O
unitdef	*(char)
;	O
if	O
(	O
startswith	O
(	O
start	*(char)
,	O
NOERROR_KEYWORD	*(char)
)	O
)	O
{	O
noerror	int
=	O
1	int
;	O
start	*(char)
+=	O
strlen	O
(	O
NOERROR_KEYWORD	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
start	*(char)
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
tabpt	int
>=	O
tablealloc	int
)	O
{	O
tablealloc	int
+=	O
20	int
;	O
tab	*(struct)
=	O
(	O
struct	O
pair	O
*	O
)	O
realloc	O
(	O
tab	*(struct)
,	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
tablealloc	int
)	O
;	O
if	O
(	O
!	O
tab	*(struct)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: memory allocation error (newtable)\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
E_MEMORY	O
;	O
}	O
}	O
tab	*(struct)
[	O
tabpt	int
]	O
.	O
location	O
=	O
strtod	O
(	O
start	*(char)
,	O
&	O
end	*(char)
)	O
;	O
if	O
(	O
start	*(char)
==	O
end	*(char)
||	O
(	O
!	O
emptystr	O
(	O
end	*(char)
)	O
&&	O
*	O
end	*(char)
!=	O
' '	O
)	O
)	O
{	O
if	O
(	O
!	O
emptystr	O
(	O
start	*(char)
)	O
)	O
{	O
if	O
(	O
strlen	O
(	O
start	*(char)
)	O
>	O
15	int
)	O
start	*(char)
[	O
15	int
]	O
=	O
0	int
;	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: cannot parse table definition %s at '%s' on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
start	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
free	()->(int)
(	O
tab	*(struct)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
tabpt	int
>	O
0	int
&&	O
tab	*(struct)
[	O
tabpt	int
]	O
.	O
location	O
<=	O
tab	*(struct)
[	O
tabpt	int
-	O
1	int
]	O
.	O
location	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: points don't increase (%.8g to %.8g) in units file '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
tab	*(struct)
[	O
tabpt	int
-	O
1	int
]	O
.	O
location	O
,	O
tab	*(struct)
[	O
tabpt	int
]	O
.	O
location	O
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
free	()->(int)
(	O
tab	*(struct)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
start	*(char)
=	O
end	*(char)
+	O
strspn	O
(	O
end	*(char)
,	O
" "	*(char)
)	O
;	O
tab	*(struct)
[	O
tabpt	int
]	O
.	O
value	*(char)
=	O
strtod	O
(	O
start	*(char)
,	O
&	O
end	*(char)
)	O
;	O
if	O
(	O
start	*(char)
==	O
end	*(char)
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: missing value after %.8g in units file '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
tab	*(struct)
[	O
tabpt	int
]	O
.	O
location	O
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
free	()->(int)
(	O
tab	*(struct)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
tabpt	int
++	O
;	O
start	*(char)
=	O
end	*(char)
+	O
strspn	O
(	O
end	*(char)
,	O
" ,"	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
funcentry	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
unitname	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
&&	O
!	O
redefine	int
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
funcentry	*(struct)
->	O
linenumber	int
,	O
funcentry	*(struct)
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
freefunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
}	O
else	O
{	O
funcentry	*(struct)
=	O
(	O
struct	O
func	*(struct)
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
func	*(struct)
)	O
,	O
"(newtable)"	*(char)
)	O
;	O
funcentry	*(struct)
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
addfunction	(*(struct))->(void)
(	O
funcentry	*(struct)
)	O
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
}	O
funcentry	*(struct)
->	O
tableunit	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
tableunit	*(char)
)	O
;	O
funcentry	*(struct)
->	O
tablelen	O
=	O
tabpt	int
;	O
funcentry	*(struct)
->	O
table	O
=	O
tab	*(struct)
;	O
funcentry	*(struct)
->	O
skip_error_check	O
=	O
noerror	int
;	O
funcentry	*(struct)
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	*(struct)
->	O
file	*(char)
=	O
file	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
newalias	(*(char),*(char),int,*(char),*(int))->(int)
(	O
char	O
*	O
unitname	*(char)
,	O
char	O
*	O
unitdef	*(char)
,	O
int	O
linenum	int
,	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
)	O
{	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
if	O
(	O
!	O
strchr	O
(	O
unitdef	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
if	O
(	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit list missing '%c' on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
UNITSEPCHAR	char
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
unitname	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
&&	O
errfile	*(int)
)	O
fprintf	()->(int)
(	O
errfile	*(int)
,	O
"%s: unit list '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
linenumber	int
,	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
file	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
free	()->(int)
(	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
}	O
else	O
{	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
(	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
sizeof	O
(	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
)	O
,	O
"(newalias)"	*(char)
)	O
;	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
0	int
;	O
*	O
aliaslistend	*(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
=	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliaslistend	*(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
=	O
&	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
}	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitdef	*(char)
)	O
;	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
linenumber	int
=	O
linenum	int
;	O
aliasentry	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
file	*(char)
=	O
file	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
checkvar	(*(char),*(char))->(int)
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
list	*(char)
)	O
{	O
char	O
*	O
listitem	*(char)
;	O
name	*(char)
=	O
getenv	()->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
2	int
;	O
listitem	*(char)
=	O
strtok	O
(	O
list	*(char)
,	O
" "	*(char)
)	O
;	O
while	O
(	O
listitem	*(char)
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
listitem	*(char)
)	O
)	O
return	O
1	int
;	O
listitem	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
pathend	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
pointer	*(void)
;	O
for	O
(	O
pointer	*(void)
=	O
filename	*(char)
+	O
strlen	O
(	O
filename	*(char)
)	O
;	O
pointer	*(void)
>	O
filename	*(char)
;	O
pointer	*(void)
--	O
)	O
{	O
if	O
(	O
isdirsep	O
(	O
*	O
pointer	*(void)
)	O
)	O
{	O
pointer	*(void)
++	O
;	O
break	O
;	O
}	O
}	O
return	O
pointer	*(void)
;	O
}	O
int	O
isfullpath	(*(char))->(int)
(	O
char	O
*	O
path	*(char)
)	O
{	O
return	O
isdirsep	O
(	O
*	O
path	*(char)
)	O
;	O
}	O
int	O
readunits	(*(char),*(int),*(int),*(int),*(int),int)->(int)
(	O
char	O
*	O
file	*(char)
,	O
FILE	O
*	O
errfile	*(int)
,	O
int	O
*	O
unitcount	*(int)
,	O
int	O
*	O
prefixcount	*(int)
,	O
int	O
*	O
funccount	*(int)
,	O
int	O
depth	int
)	O
{	O
FILE	O
*	O
unitfile	O
;	O
char	O
*	O
line	*(char)
=	O
0	int
,	O
*	O
lineptr	*(char)
,	O
*	O
unitdef	*(char)
,	O
*	O
unitname	*(char)
,	O
*	O
permfile	*(char)
;	O
int	O
linenum	int
,	O
linebufsize	int
,	O
goterr	int
,	O
retcode	int
;	O
int	O
locunitcount	int
,	O
locprefixcount	int
,	O
locfunccount	int
,	O
redefinition	int
;	O
int	O
wronglocale	int
=	O
0	int
;	O
int	O
inlocale	int
=	O
0	int
;	O
int	O
in_utf8	int
=	O
0	int
;	O
int	O
invar	int
=	O
0	int
;	O
int	O
wrongvar	int
=	O
0	int
;	O
locunitcount	int
=	O
0	int
;	O
locprefixcount	int
=	O
0	int
;	O
locfunccount	int
=	O
0	int
;	O
linenum	int
=	O
0	int
;	O
linebufsize	int
=	O
0	int
;	O
goterr	int
=	O
0	int
;	O
unitfile	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
unitfile	O
)	O
return	O
E_FILE	O
;	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
&	O
line	*(char)
,	O
&	O
linebufsize	int
)	O
;	O
permfile	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
file	*(char)
)	O
;	O
while	O
(	O
!	O
feof	()->(int)
(	O
unitfile	O
)	O
)	O
{	O
if	O
(	O
!	O
fgetslong	(*(*(char)),*(int),*(int),*(int))->(*(char))
(	O
&	O
line	*(char)
,	O
&	O
linebufsize	int
,	O
unitfile	O
,	O
&	O
linenum	int
)	O
)	O
break	O
;	O
if	O
(	O
linenum	int
==	O
1	int
&&	O
startswith	O
(	O
line	*(char)
,	O
UTF8MARKER	*(char)
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
lineptr	*(char)
=	O
line	*(char)
,	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	O
(	O
UTF8MARKER	*(char)
)	O
;	O
i	int
++	O
,	O
lineptr	*(char)
++	O
)	O
*	O
lineptr	*(char)
=	O
' '	O
;	O
}	O
strip_comment	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
if	O
(	O
-	O
1	int
==	O
strwidth	(*(char))->(int)
(	O
line	*(char)
)	O
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: %s on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
invalid_utf8	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
continue	O
;	O
}	O
replace_minus	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
*	O
line	*(char)
==	O
COMMANDCHAR	char
)	O
{	O
unitname	*(char)
=	O
strtok	O
(	O
line	*(char)
+	O
1	int
,	O
" "	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
VAGUE_ERR	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"var"	*(char)
)	O
||	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"varnot"	*(char)
)	O
)	O
{	O
int	O
not	int
=	O
0	int
;	O
if	O
(	O
unitname	*(char)
[	O
3	int
]	O
==	O
'n'	O
)	O
not	int
=	O
1	int
;	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
unitdef	*(char)
=	O
strtok	O
(	O
0	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: no variable name specified on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
unitdef	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: no value specified on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
if	O
(	O
invar	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: nested var statements not allowed, line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
{	O
int	O
check	int
;	O
invar	int
=	O
1	int
;	O
check	int
=	O
checkvar	(*(char),*(char))->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
)	O
;	O
if	O
(	O
check	int
==	O
2	int
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: environment variable %s not set at line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
wrongvar	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
not	int
^	O
check	int
)	O
)	O
wrongvar	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"endvar"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
invar	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: unmatched !endvar on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
wrongvar	int
=	O
0	int
;	O
invar	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"locale"	*(char)
)	O
)	O
{	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: no locale specified on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
if	O
(	O
inlocale	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: nested locales not allowed, line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
{	O
inlocale	int
=	O
1	int
;	O
if	O
(	O
strcmp	O
(	O
unitname	*(char)
,	O
mylocale	*(char)
)	O
)	O
wronglocale	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"endlocale"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
inlocale	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: unmatched !endlocale on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
wronglocale	int
=	O
0	int
;	O
inlocale	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"utf8"	*(char)
)	O
)	O
{	O
if	O
(	O
in_utf8	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: nested utf8 not allowed, line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
in_utf8	int
=	O
1	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"endutf8"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
in_utf8	int
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: unmatched !endutf8 on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
in_utf8	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
in_utf8	int
&&	O
!	O
utf8mode	int
)	O
continue	O
;	O
if	O
(	O
wronglocale	int
||	O
wrongvar	int
)	O
continue	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"prompt"	*(char)
)	O
)	O
{	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
promptprefix	*(char)
)	O
free	()->(int)
(	O
promptprefix	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
promptprefix	*(char)
=	O
0	int
;	O
else	O
promptprefix	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unitname	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"message"	*(char)
)	O
)	O
{	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
)	O
{	O
if	O
(	O
unitname	*(char)
)	O
logputs	(*(char))->(void)
(	O
unitname	*(char)
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"set"	*(char)
)	O
)	O
{	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
unitdef	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: no variable name specified on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
unitdef	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: no value specified on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
else	O
setenv	()->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"unitlist"	*(char)
)	O
)	O
{	O
splitline	(*(char),*(*(char)),*(*(char)))->(void)
(	O
0	int
,	O
&	O
unitname	*(char)
,	O
&	O
unitdef	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
||	O
!	O
unitdef	*(char)
)	O
readerror	O
(	O
errfile	*(int)
,	O
VAGUE_ERR	O
)	O
;	O
else	O
{	O
if	O
(	O
newalias	(*(char),*(char),int,*(char),*(int))->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
linenum	int
,	O
permfile	*(char)
,	O
errfile	*(int)
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	*(char)
,	O
"include"	*(char)
)	O
)	O
{	O
if	O
(	O
depth	int
>	O
MAXINCLUDE	int
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: max include depth of %d exceeded in file '%s' line %d\n"	*(char)
,	O
progname	*(char)
,	O
MAXINCLUDE	int
,	O
file	*(char)
,	O
linenum	int
)	O
;	O
}	O
else	O
{	O
int	O
readerr	int
;	O
char	O
*	O
includefile	*(char)
;	O
unitname	*(char)
=	O
strtok	O
(	O
0	int
,	O
" "	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: missing include filename on line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
continue	O
;	O
}	O
includefile	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
file	*(char)
)	O
+	O
strlen	O
(	O
unitname	*(char)
)	O
+	O
1	int
,	O
"(readunits)"	*(char)
)	O
;	O
if	O
(	O
isfullpath	(*(char))->(int)
(	O
unitname	*(char)
)	O
)	O
strcpy	O
(	O
includefile	*(char)
,	O
unitname	*(char)
)	O
;	O
else	O
{	O
strcpy	O
(	O
includefile	*(char)
,	O
file	*(char)
)	O
;	O
strcpy	O
(	O
pathend	(*(char))->(*(char))
(	O
includefile	*(char)
)	O
,	O
unitname	*(char)
)	O
;	O
}	O
readerr	int
=	O
readunits	(*(char),*(int),*(int),*(int),*(int),int)->(int)
(	O
includefile	*(char)
,	O
errfile	*(int)
,	O
unitcount	*(int)
,	O
prefixcount	*(int)
,	O
funccount	*(int)
,	O
depth	int
+	O
1	int
)	O
;	O
if	O
(	O
readerr	int
==	O
E_MEMORY	O
)	O
{	O
fclose	()->(int)
(	O
unitfile	O
)	O
;	O
free	()->(int)
(	O
line	*(char)
)	O
;	O
free	()->(int)
(	O
includefile	*(char)
)	O
;	O
return	O
readerr	int
;	O
}	O
if	O
(	O
readerr	int
==	O
E_FILE	O
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: cannot open included file '%s' at line %d of file '%s\n"	*(char)
,	O
progname	*(char)
,	O
includefile	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
readerr	int
)	O
goterr	int
=	O
1	int
;	O
free	()->(int)
(	O
includefile	*(char)
)	O
;	O
}	O
}	O
else	O
readerror	O
(	O
errfile	*(int)
,	O
VAGUE_ERR	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
in_utf8	int
&&	O
!	O
utf8mode	int
)	O
continue	O
;	O
if	O
(	O
wronglocale	int
||	O
wrongvar	int
)	O
continue	O
;	O
splitline	(*(char),*(*(char)),*(*(char)))->(void)
(	O
line	*(char)
,	O
&	O
unitname	*(char)
,	O
&	O
unitdef	*(char)
)	O
;	O
if	O
(	O
!	O
unitname	*(char)
)	O
continue	O
;	O
if	O
(	O
!	O
unitdef	*(char)
)	O
{	O
readerror	O
(	O
errfile	*(int)
,	O
"%s: unit '%s' lacks a definition at line %d of '%s'\n"	*(char)
,	O
progname	*(char)
,	O
unitname	*(char)
,	O
linenum	int
,	O
file	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
unitname	*(char)
==	O
REDEFCHAR	char
)	O
{	O
unitname	*(char)
++	O
;	O
redefinition	int
=	O
1	int
;	O
}	O
else	O
redefinition	int
=	O
0	int
;	O
if	O
(	O
lastchar	O
(	O
unitname	*(char)
)	O
==	O
'-'	O
)	O
{	O
if	O
(	O
newprefix	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
&	O
locprefixcount	int
,	O
linenum	int
,	O
permfile	*(char)
,	O
errfile	*(int)
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strchr	O
(	O
unitname	*(char)
,	O
'['	O
)	O
)	O
{	O
retcode	int
=	O
newtable	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
&	O
locfunccount	int
,	O
linenum	int
,	O
permfile	*(char)
,	O
errfile	*(int)
,	O
redefinition	int
)	O
;	O
if	O
(	O
retcode	int
)	O
{	O
if	O
(	O
retcode	int
!=	O
E_BADFILE	O
)	O
{	O
fclose	()->(int)
(	O
unitfile	O
)	O
;	O
free	()->(int)
(	O
line	*(char)
)	O
;	O
return	O
retcode	int
;	O
}	O
goterr	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strchr	O
(	O
unitname	*(char)
,	O
'('	O
)	O
)	O
{	O
if	O
(	O
newfunction	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
&	O
locfunccount	int
,	O
linenum	int
,	O
permfile	*(char)
,	O
errfile	*(int)
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
(	O
unitname	*(char)
,	O
unitdef	*(char)
,	O
&	O
locunitcount	int
,	O
linenum	int
,	O
permfile	*(char)
,	O
errfile	*(int)
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
}	O
fclose	()->(int)
(	O
unitfile	O
)	O
;	O
free	()->(int)
(	O
line	*(char)
)	O
;	O
if	O
(	O
unitcount	*(int)
)	O
*	O
unitcount	*(int)
+=	O
locunitcount	int
;	O
if	O
(	O
prefixcount	*(int)
)	O
*	O
prefixcount	*(int)
+=	O
locprefixcount	int
;	O
if	O
(	O
funccount	*(int)
)	O
*	O
funccount	*(int)
+=	O
locfunccount	int
;	O
if	O
(	O
goterr	int
)	O
return	O
E_BADFILE	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
initializeunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
theunit	*(struct)
->	O
factor	double
=	O
1.0	int
;	O
theunit	*(struct)
->	O
numerator	O
[	O
0	int
]	O
=	O
theunit	*(struct)
->	O
denominator	O
[	O
0	int
]	O
=	O
NULL	O
;	O
}	O
void	O
freeunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
char	O
*	O
*	O
ptr	*(char)
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
numerator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
if	O
(	O
*	O
ptr	*(char)
!=	O
NULLUNIT	*(char)
)	O
free	()->(int)
(	O
*	O
ptr	*(char)
)	O
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
denominator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
if	O
(	O
*	O
ptr	*(char)
!=	O
NULLUNIT	*(char)
)	O
free	()->(int)
(	O
*	O
ptr	*(char)
)	O
;	O
theunit	*(struct)
->	O
numerator	O
[	O
0	int
]	O
=	O
0	int
;	O
theunit	*(struct)
->	O
denominator	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
void	O
showunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
char	O
*	O
*	O
ptr	*(char)
;	O
int	O
printedslash	int
;	O
int	O
counter	int
=	O
1	int
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
theunit	*(struct)
->	O
factor	double
)	O
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
numerator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
{	O
if	O
(	O
ptr	*(char)
>	O
theunit	*(struct)
->	O
numerator	O
&&	O
*	O
*	O
ptr	*(char)
&&	O
!	O
strcmp	O
(	O
*	O
ptr	*(char)
,	O
*	O
(	O
ptr	*(char)
-	O
1	int
)	O
)	O
)	O
counter	int
++	O
;	O
else	O
{	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	(*(char))->(void)
(	O
"%s%d"	*(char)
,	O
powerstring	*(char)
,	O
counter	int
)	O
;	O
if	O
(	O
*	O
*	O
ptr	*(char)
)	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
*	O
ptr	*(char)
)	O
;	O
counter	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	(*(char))->(void)
(	O
"%s%d"	*(char)
,	O
powerstring	*(char)
,	O
counter	int
)	O
;	O
counter	int
=	O
1	int
;	O
printedslash	int
=	O
0	int
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
denominator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
)	O
{	O
if	O
(	O
ptr	*(char)
>	O
theunit	*(struct)
->	O
denominator	O
&&	O
*	O
*	O
ptr	*(char)
&&	O
!	O
strcmp	O
(	O
*	O
ptr	*(char)
,	O
*	O
(	O
ptr	*(char)
-	O
1	int
)	O
)	O
)	O
counter	int
++	O
;	O
else	O
{	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	(*(char))->(void)
(	O
"%s%d"	*(char)
,	O
powerstring	*(char)
,	O
counter	int
)	O
;	O
if	O
(	O
*	O
*	O
ptr	*(char)
)	O
{	O
if	O
(	O
!	O
printedslash	int
)	O
logprintf	(*(char))->(void)
(	O
" /"	*(char)
)	O
;	O
printedslash	int
=	O
1	int
;	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
*	O
ptr	*(char)
)	O
;	O
}	O
counter	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	(*(char))->(void)
(	O
"%s%d"	*(char)
,	O
powerstring	*(char)
,	O
counter	int
)	O
;	O
}	O
int	O
compare	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item1	*(void)
,	O
const	O
void	O
*	O
item2	*(void)
)	O
{	O
return	O
strcmp	O
(	O
*	O
(	O
char	O
*	O
*	O
)	O
item1	*(void)
,	O
*	O
(	O
char	O
*	O
*	O
)	O
item2	*(void)
)	O
;	O
}	O
void	O
sortunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
char	O
*	O
*	O
ptr	*(char)
;	O
int	O
count	*(int)
;	O
for	O
(	O
count	*(int)
=	O
0	int
,	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
numerator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
,	O
count	*(int)
++	O
)	O
;	O
qsort	()->(int)
(	O
theunit	*(struct)
->	O
numerator	O
,	O
count	*(int)
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
compare	(*(void),*(void))->(int)
)	O
;	O
for	O
(	O
count	*(int)
=	O
0	int
,	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
denominator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
,	O
count	*(int)
++	O
)	O
;	O
qsort	()->(int)
(	O
theunit	*(struct)
->	O
denominator	O
,	O
count	*(int)
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
compare	(*(void),*(void))->(int)
)	O
;	O
}	O
void	O
cancelunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
char	O
*	O
*	O
den	*(*(char))
,	O
*	O
*	O
num	*(*(char))
;	O
int	O
comp	int
;	O
den	*(*(char))
=	O
theunit	*(struct)
->	O
denominator	O
;	O
num	*(*(char))
=	O
theunit	*(struct)
->	O
numerator	O
;	O
while	O
(	O
*	O
num	*(*(char))
&&	O
*	O
den	*(*(char))
)	O
{	O
comp	int
=	O
strcmp	O
(	O
*	O
den	*(*(char))
,	O
*	O
num	*(*(char))
)	O
;	O
if	O
(	O
!	O
comp	int
)	O
{	O
if	O
(	O
*	O
den	*(*(char))
!=	O
NULLUNIT	*(char)
)	O
free	()->(int)
(	O
*	O
den	*(*(char))
)	O
;	O
if	O
(	O
*	O
num	*(*(char))
!=	O
NULLUNIT	*(char)
)	O
free	()->(int)
(	O
*	O
num	*(*(char))
)	O
;	O
*	O
den	*(*(char))
++	O
=	O
NULLUNIT	*(char)
;	O
*	O
num	*(*(char))
++	O
=	O
NULLUNIT	*(char)
;	O
}	O
else	O
if	O
(	O
comp	int
<	O
0	int
)	O
den	*(*(char))
++	O
;	O
else	O
num	*(*(char))
++	O
;	O
}	O
}	O
static	O
int	O
bufsize	*(int)
=	O
0	int
;	O
static	O
char	O
*	O
buffer	*(char)
;	O
char	O
*	O
lookupunit	(*(char),int)->(*(char))
(	O
char	O
*	O
unit	*(char)
,	O
int	O
prefixok	int
)	O
{	O
char	O
*	O
copy	*(char)
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
if	O
(	O
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
unit	*(char)
)	O
)	O
)	O
return	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
;	O
if	O
(	O
strwidth	(*(char))->(int)
(	O
unit	*(char)
)	O
>	O
2	int
&&	O
lastchar	O
(	O
unit	*(char)
)	O
==	O
's'	O
)	O
{	O
copy	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
unit	*(char)
)	O
;	O
lastchar	O
(	O
copy	*(char)
)	O
=	O
0	int
;	O
if	O
(	O
lookupunit	(*(char),int)->(*(char))
(	O
copy	*(char)
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	*(char)
)	O
+	O
1	int
>	O
bufsize	*(int)
)	O
{	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
&	O
buffer	*(char)
,	O
&	O
bufsize	*(int)
)	O
;	O
}	O
strcpy	O
(	O
buffer	*(char)
,	O
copy	*(char)
)	O
;	O
free	()->(int)
(	O
copy	*(char)
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
if	O
(	O
strlen	O
(	O
copy	*(char)
)	O
>	O
2	int
&&	O
lastchar	O
(	O
copy	*(char)
)	O
==	O
'e'	O
)	O
{	O
lastchar	O
(	O
copy	*(char)
)	O
=	O
0	int
;	O
if	O
(	O
lookupunit	(*(char),int)->(*(char))
(	O
copy	*(char)
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	*(char)
)	O
+	O
1	int
>	O
bufsize	*(int)
)	O
{	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
&	O
buffer	*(char)
,	O
&	O
bufsize	*(int)
)	O
;	O
}	O
strcpy	O
(	O
buffer	*(char)
,	O
copy	*(char)
)	O
;	O
free	()->(int)
(	O
copy	*(char)
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
}	O
if	O
(	O
strlen	O
(	O
copy	*(char)
)	O
>	O
2	int
&&	O
lastchar	O
(	O
copy	*(char)
)	O
==	O
'i'	O
)	O
{	O
lastchar	O
(	O
copy	*(char)
)	O
=	O
'y'	O
;	O
if	O
(	O
lookupunit	(*(char),int)->(*(char))
(	O
copy	*(char)
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	*(char)
)	O
+	O
1	int
>	O
bufsize	*(int)
)	O
{	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
&	O
buffer	*(char)
,	O
&	O
bufsize	*(int)
)	O
;	O
}	O
strcpy	O
(	O
buffer	*(char)
,	O
copy	*(char)
)	O
;	O
free	()->(int)
(	O
copy	*(char)
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
}	O
free	()->(int)
(	O
copy	*(char)
)	O
;	O
}	O
if	O
(	O
prefixok	int
&&	O
(	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
plookup	(*(char))->(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*`,*`,int,*`,*`)))))
(	O
unit	*(char)
)	O
)	O
)	O
{	O
copy	*(char)
=	O
unit	*(char)
+	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
;	O
if	O
(	O
emptystr	O
(	O
copy	*(char)
)	O
||	O
lookupunit	(*(char),int)->(*(char))
(	O
copy	*(char)
,	O
0	int
)	O
)	O
{	O
char	O
*	O
tempbuf	*(char)
;	O
while	O
(	O
strlen	O
(	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
+	O
strlen	O
(	O
copy	*(char)
)	O
+	O
2	int
>	O
bufsize	*(int)
)	O
{	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
&	O
buffer	*(char)
,	O
&	O
bufsize	*(int)
)	O
;	O
}	O
tempbuf	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
copy	*(char)
)	O
;	O
strcpy	O
(	O
buffer	*(char)
,	O
pfxptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
strcat	O
(	O
buffer	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	O
(	O
buffer	*(char)
,	O
tempbuf	*(char)
)	O
;	O
free	()->(int)
(	O
tempbuf	*(char)
)	O
;	O
return	O
buffer	*(char)
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
moveproduct	(array(*(char)),array(*(char)))->(int)
(	O
char	O
*	O
product	array(*(char))
[	O
]	O
,	O
char	O
*	O
tomove	array(*(char))
[	O
]	O
)	O
{	O
char	O
*	O
*	O
dest	*(struct)
,	O
*	O
*	O
src	*(struct)
;	O
dest	*(struct)
=	O
product	array(*(char))
;	O
for	O
(	O
src	*(struct)
=	O
tomove	array(*(char))
;	O
*	O
src	*(struct)
;	O
src	*(struct)
++	O
)	O
{	O
if	O
(	O
*	O
src	*(struct)
==	O
NULLUNIT	*(char)
)	O
continue	O
;	O
for	O
(	O
;	O
*	O
dest	*(struct)
&&	O
*	O
dest	*(struct)
!=	O
NULLUNIT	*(char)
;	O
dest	*(struct)
++	O
)	O
;	O
if	O
(	O
dest	*(struct)
-	O
product	array(*(char))
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
if	O
(	O
!	O
*	O
dest	*(struct)
)	O
*	O
(	O
dest	*(struct)
+	O
1	int
)	O
=	O
0	int
;	O
*	O
dest	*(struct)
=	O
*	O
src	*(struct)
;	O
*	O
src	*(struct)
=	O
NULLUNIT	*(char)
;	O
}	O
return	O
0	int
;	O
}	O
void	O
copyproduct	(*(*(char)),*(*(char)))->(void)
(	O
char	O
*	O
*	O
dest	*(struct)
,	O
char	O
*	O
*	O
source	*(struct)
)	O
{	O
for	O
(	O
;	O
*	O
source	*(struct)
;	O
source	*(struct)
++	O
,	O
dest	*(struct)
++	O
)	O
{	O
if	O
(	O
*	O
source	*(struct)
==	O
NULLUNIT	*(char)
)	O
*	O
dest	*(struct)
=	O
NULLUNIT	*(char)
;	O
else	O
*	O
dest	*(struct)
=	O
dupstr	(*(char))->(*(char))
(	O
*	O
source	*(struct)
)	O
;	O
}	O
*	O
dest	*(struct)
=	O
0	int
;	O
}	O
void	O
unitcopy	(*(struct),*(struct))->(void)
(	O
struct	O
unittype	O
*	O
dest	*(struct)
,	O
struct	O
unittype	O
*	O
source	*(struct)
)	O
{	O
dest	*(struct)
->	O
factor	double
=	O
source	*(struct)
->	O
factor	double
;	O
copyproduct	(*(*(char)),*(*(char)))->(void)
(	O
dest	*(struct)
->	O
numerator	O
,	O
source	*(struct)
->	O
numerator	O
)	O
;	O
copyproduct	(*(*(char)),*(*(char)))->(void)
(	O
dest	*(struct)
->	O
denominator	O
,	O
source	*(struct)
->	O
denominator	O
)	O
;	O
}	O
int	O
multunit	(*(struct),*(struct))->(int)
(	O
struct	O
unittype	O
*	O
left	*(struct)
,	O
struct	O
unittype	O
*	O
right	*(struct)
)	O
{	O
int	O
myerr	int
;	O
left	*(struct)
->	O
factor	double
*=	O
right	*(struct)
->	O
factor	double
;	O
myerr	int
=	O
moveproduct	(array(*(char)),array(*(char)))->(int)
(	O
left	*(struct)
->	O
numerator	O
,	O
right	*(struct)
->	O
numerator	O
)	O
;	O
if	O
(	O
!	O
myerr	int
)	O
myerr	int
=	O
moveproduct	(array(*(char)),array(*(char)))->(int)
(	O
left	*(struct)
->	O
denominator	O
,	O
right	*(struct)
->	O
denominator	O
)	O
;	O
return	O
myerr	int
;	O
}	O
int	O
divunit	(*(struct),*(struct))->(int)
(	O
struct	O
unittype	O
*	O
left	*(struct)
,	O
struct	O
unittype	O
*	O
right	*(struct)
)	O
{	O
int	O
myerr	int
;	O
left	*(struct)
->	O
factor	double
/=	O
right	*(struct)
->	O
factor	double
;	O
myerr	int
=	O
moveproduct	(array(*(char)),array(*(char)))->(int)
(	O
left	*(struct)
->	O
numerator	O
,	O
right	*(struct)
->	O
denominator	O
)	O
;	O
if	O
(	O
!	O
myerr	int
)	O
myerr	int
=	O
moveproduct	(array(*(char)),array(*(char)))->(int)
(	O
left	*(struct)
->	O
denominator	O
,	O
right	*(struct)
->	O
numerator	O
)	O
;	O
return	O
myerr	int
;	O
}	O
int	O
reduceproduct	(*(struct),int)->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
,	O
int	O
flip	int
)	O
{	O
char	O
*	O
toadd	*(char)
;	O
char	O
*	O
*	O
product	array(*(char))
;	O
int	O
didsomething	int
=	O
NOREDUCTION	O
;	O
struct	O
unittype	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
;	O
int	O
ret	*(char)
;	O
if	O
(	O
flip	int
)	O
product	array(*(char))
=	O
theunit	*(struct)
->	O
denominator	O
;	O
else	O
product	array(*(char))
=	O
theunit	*(struct)
->	O
numerator	O
;	O
for	O
(	O
;	O
*	O
product	array(*(char))
;	O
product	array(*(char))
++	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
strlen	O
(	O
*	O
product	array(*(char))
)	O
)	O
break	O
;	O
toadd	*(char)
=	O
lookupunit	(*(char),int)->(*(char))
(	O
*	O
product	array(*(char))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
toadd	*(char)
)	O
{	O
if	O
(	O
!	O
irreducible	*(char)
)	O
irreducible	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
*	O
product	array(*(char))
)	O
;	O
return	O
REDUCTIONERROR	O
;	O
}	O
if	O
(	O
strchr	O
(	O
toadd	*(char)
,	O
PRIMITIVECHAR	char
)	O
)	O
break	O
;	O
didsomething	int
=	O
DIDREDUCTION	O
;	O
if	O
(	O
*	O
product	array(*(char))
!=	O
NULLUNIT	*(char)
)	O
{	O
free	()->(int)
(	O
*	O
product	array(*(char))
)	O
;	O
*	O
product	array(*(char))
=	O
NULLUNIT	*(char)
;	O
}	O
if	O
(	O
parseunit	()->(int)
(	O
&	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
,	O
toadd	*(char)
,	O
0	int
,	O
0	int
)	O
)	O
return	O
REDUCTIONERROR	O
;	O
if	O
(	O
flip	int
)	O
ret	*(char)
=	O
divunit	(*(struct),*(struct))->(int)
(	O
theunit	*(struct)
,	O
&	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
)	O
;	O
else	O
ret	*(char)
=	O
multunit	(*(struct),*(struct))->(int)
(	O
theunit	*(struct)
,	O
&	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
newunit	(*(char),*(char),*(int),int,*(char),*(int),int)->(int)
)	O
;	O
if	O
(	O
ret	*(char)
)	O
return	O
REDUCTIONERROR	O
;	O
}	O
}	O
return	O
didsomething	int
;	O
}	O
int	O
reduceunit	(*(struct))->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
int	O
ret	*(char)
;	O
if	O
(	O
irreducible	*(char)
)	O
free	()->(int)
(	O
irreducible	*(char)
)	O
;	O
irreducible	*(char)
=	O
0	int
;	O
ret	*(char)
=	O
DIDREDUCTION	O
;	O
while	O
(	O
ret	*(char)
&	O
DIDREDUCTION	O
)	O
{	O
ret	*(char)
=	O
reduceproduct	(*(struct),int)->(int)
(	O
theunit	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
ret	*(char)
&	O
REDUCTIONERROR	O
)	O
)	O
ret	*(char)
|=	O
reduceproduct	(*(struct),int)->(int)
(	O
theunit	*(struct)
,	O
1	int
)	O
;	O
if	O
(	O
ret	*(char)
&	O
REDUCTIONERROR	O
)	O
{	O
if	O
(	O
irreducible	*(char)
)	O
return	O
E_UNKNOWNUNIT	O
;	O
else	O
return	O
E_REDUCE	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
ignore_dimless	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
0	int
;	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
&&	O
!	O
strcmp	O
(	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
,	O
NODIM	*(char)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
ignore_nothing	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
0	int
;	O
}	O
int	O
ignore_primitive	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
0	int
;	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
&&	O
strchr	O
(	O
ul	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
,	O
PRIMITIVECHAR	char
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
compareproducts	(*(*(char)),*(*(char)),*((*(char))->(int)))->(int)
(	O
char	O
*	O
*	O
one	*(*(char))
,	O
char	O
*	O
*	O
two	*(*(char))
,	O
int	O
(	O
*	O
isdimless	*((*(char))->(int))
)	O
(	O
char	O
*	O
name	*(char)
)	O
)	O
{	O
int	O
oneblank	int
,	O
twoblank	int
;	O
while	O
(	O
*	O
one	*(*(char))
||	O
*	O
two	*(*(char))
)	O
{	O
oneblank	int
=	O
(	O
*	O
one	*(*(char))
==	O
NULLUNIT	*(char)
)	O
||	O
isdimless	*((*(char))->(int))
(	O
*	O
one	*(*(char))
)	O
;	O
twoblank	int
=	O
(	O
*	O
two	*(*(char))
==	O
NULLUNIT	*(char)
)	O
||	O
isdimless	*((*(char))->(int))
(	O
*	O
two	*(*(char))
)	O
;	O
if	O
(	O
!	O
*	O
one	*(*(char))
&&	O
!	O
twoblank	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
two	*(*(char))
&&	O
!	O
oneblank	int
)	O
return	O
1	int
;	O
if	O
(	O
oneblank	int
)	O
one	*(*(char))
++	O
;	O
else	O
if	O
(	O
twoblank	int
)	O
two	*(*(char))
++	O
;	O
else	O
if	O
(	O
strcmp	O
(	O
*	O
one	*(*(char))
,	O
*	O
two	*(*(char))
)	O
)	O
return	O
1	int
;	O
else	O
one	*(*(char))
++	O
,	O
two	*(*(char))
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
struct	O
unittype	O
*	O
first	*(*(char))
,	O
struct	O
unittype	O
*	O
second	*(*(char))
,	O
int	O
(	O
*	O
isdimless	*((*(char))->(int))
)	O
(	O
char	O
*	O
name	*(char)
)	O
)	O
{	O
return	O
compareproducts	(*(*(char)),*(*(char)),*((*(char))->(int)))->(int)
(	O
first	*(*(char))
->	O
numerator	O
,	O
second	*(*(char))
->	O
numerator	O
,	O
isdimless	*((*(char))->(int))
)	O
||	O
compareproducts	(*(*(char)),*(*(char)),*((*(char))->(int)))->(int)
(	O
first	*(*(char))
->	O
denominator	O
,	O
second	*(*(char))
->	O
denominator	O
,	O
isdimless	*((*(char))->(int))
)	O
;	O
}	O
int	O
completereduce	(*(struct))->(int)
(	O
struct	O
unittype	O
*	O
unit	*(char)
)	O
{	O
int	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
reduceunit	(*(struct))->(int)
(	O
unit	*(char)
)	O
)	O
)	O
return	O
err	int
;	O
sortunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
cancelunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
expunit	(*(struct),int)->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
,	O
int	O
power	int
)	O
{	O
char	O
*	O
*	O
numptr	*(*(char))
,	O
*	O
*	O
denptr	*(*(char))
;	O
double	O
thefactor	double
;	O
int	O
i	int
,	O
uind	int
,	O
denlen	int
,	O
numlen	int
;	O
if	O
(	O
power	int
==	O
0	int
)	O
{	O
freeunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
numlen	int
=	O
0	int
;	O
for	O
(	O
numptr	*(*(char))
=	O
theunit	*(struct)
->	O
numerator	O
;	O
*	O
numptr	*(*(char))
;	O
numptr	*(*(char))
++	O
)	O
numlen	int
++	O
;	O
denlen	int
=	O
0	int
;	O
for	O
(	O
denptr	*(*(char))
=	O
theunit	*(struct)
->	O
denominator	O
;	O
*	O
denptr	*(*(char))
;	O
denptr	*(*(char))
++	O
)	O
denlen	int
++	O
;	O
thefactor	double
=	O
theunit	*(struct)
->	O
factor	double
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
power	int
;	O
i	int
++	O
)	O
{	O
theunit	*(struct)
->	O
factor	double
*=	O
thefactor	double
;	O
for	O
(	O
uind	int
=	O
0	int
;	O
uind	int
<	O
numlen	int
;	O
uind	int
++	O
)	O
{	O
if	O
(	O
theunit	*(struct)
->	O
numerator	O
[	O
uind	int
]	O
!=	O
NULLUNIT	*(char)
)	O
{	O
if	O
(	O
numptr	*(*(char))
-	O
theunit	*(struct)
->	O
numerator	O
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
*	O
numptr	*(*(char))
=	O
*	O
denptr	*(*(char))
=	O
0	int
;	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
*	O
numptr	*(*(char))
++	O
=	O
dupstr	(*(char))->(*(char))
(	O
theunit	*(struct)
->	O
numerator	O
[	O
uind	int
]	O
)	O
;	O
}	O
}	O
for	O
(	O
uind	int
=	O
0	int
;	O
uind	int
<	O
denlen	int
;	O
uind	int
++	O
)	O
{	O
if	O
(	O
theunit	*(struct)
->	O
denominator	O
[	O
uind	int
]	O
!=	O
NULLUNIT	*(char)
)	O
{	O
*	O
denptr	*(*(char))
++	O
=	O
dupstr	(*(char))->(*(char))
(	O
theunit	*(struct)
->	O
denominator	O
[	O
uind	int
]	O
)	O
;	O
if	O
(	O
denptr	*(*(char))
-	O
theunit	*(struct)
->	O
denominator	O
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
*	O
numptr	*(*(char))
=	O
*	O
denptr	*(*(char))
=	O
0	int
;	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
}	O
}	O
}	O
*	O
numptr	*(*(char))
=	O
0	int
;	O
*	O
denptr	*(*(char))
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
unit2num	(*(struct))->(int)
(	O
struct	O
unittype	O
*	O
input	*(char)
)	O
{	O
struct	O
unittype	O
one	*(*(char))
;	O
int	O
err	int
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
one	*(*(char))
)	O
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
input	*(char)
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
input	*(char)
,	O
&	O
one	*(*(char))
,	O
ignore_nothing	(*(char))->(int)
)	O
)	O
return	O
E_NOTANUMBER	O
;	O
freeunit	(*(struct))->(void)
(	O
input	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
unitdimless	(*(struct))->(int)
(	O
struct	O
unittype	O
*	O
input	*(char)
)	O
{	O
struct	O
unittype	O
one	*(*(char))
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
one	*(*(char))
)	O
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
input	*(char)
,	O
&	O
one	*(*(char))
,	O
ignore_dimless	(*(char))->(int)
)	O
)	O
return	O
0	int
;	O
freeunit	(*(struct))->(void)
(	O
input	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
subunitroot	(int,array(*(char)),array(*(char)))->(int)
(	O
int	O
n	int
,	O
char	O
*	O
current	array(*(char))
[	O
]	O
,	O
char	O
*	O
out	array(*(char))
[	O
]	O
)	O
{	O
char	O
*	O
*	O
ptr	*(char)
;	O
int	O
count	*(int)
=	O
0	int
;	O
while	O
(	O
*	O
current	array(*(char))
==	O
NULLUNIT	*(char)
)	O
current	array(*(char))
++	O
;	O
ptr	*(char)
=	O
current	array(*(char))
;	O
while	O
(	O
*	O
ptr	*(char)
)	O
{	O
while	O
(	O
*	O
ptr	*(char)
)	O
{	O
if	O
(	O
*	O
ptr	*(char)
!=	O
NULLUNIT	*(char)
)	O
{	O
if	O
(	O
strcmp	O
(	O
*	O
current	array(*(char))
,	O
*	O
ptr	*(char)
)	O
)	O
break	O
;	O
count	*(int)
++	O
;	O
}	O
ptr	*(char)
++	O
;	O
}	O
if	O
(	O
count	*(int)
%	O
n	int
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
ignore_dimless	(*(char))->(int)
(	O
*	O
current	array(*(char))
)	O
)	O
return	O
E_NOTROOT	O
;	O
}	O
else	O
{	O
for	O
(	O
count	*(int)
/=	O
n	int
;	O
count	*(int)
>	O
0	int
;	O
count	*(int)
--	O
)	O
*	O
(	O
out	array(*(char))
++	O
)	O
=	O
dupstr	(*(char))->(*(char))
(	O
*	O
current	array(*(char))
)	O
;	O
}	O
current	array(*(char))
=	O
ptr	*(char)
;	O
}	O
*	O
out	array(*(char))
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rootunit	(*(struct),int)->(int)
(	O
struct	O
unittype	O
*	O
inunit	*(struct)
,	O
int	O
n	int
)	O
{	O
struct	O
unittype	O
outunit	struct
;	O
int	O
err	int
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
outunit	struct
)	O
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
inunit	*(struct)
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
inunit	*(struct)
->	O
factor	double
<	O
0	int
)	O
return	O
E_NOTROOT	O
;	O
outunit	struct
.	O
factor	double
=	O
pow	O
(	O
inunit	*(struct)
->	O
factor	double
,	O
1.0	int
/	O
(	O
double	O
)	O
n	int
)	O
;	O
if	O
(	O
(	O
err	int
=	O
subunitroot	(int,array(*(char)),array(*(char)))->(int)
(	O
n	int
,	O
inunit	*(struct)
->	O
numerator	O
,	O
outunit	struct
.	O
numerator	O
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
subunitroot	(int,array(*(char)),array(*(char)))->(int)
(	O
n	int
,	O
inunit	*(struct)
->	O
denominator	O
,	O
outunit	struct
.	O
denominator	O
)	O
)	O
)	O
return	O
err	int
;	O
freeunit	(*(struct))->(void)
(	O
inunit	*(struct)
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
inunit	*(struct)
)	O
;	O
return	O
multunit	(*(struct),*(struct))->(int)
(	O
inunit	*(struct)
,	O
&	O
outunit	struct
)	O
;	O
}	O
void	O
invertunit	(*(struct))->(void)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
char	O
*	O
*	O
ptr	*(char)
,	O
*	O
swap	*(char)
;	O
int	O
numlen	int
,	O
length	int
,	O
ind	int
;	O
theunit	*(struct)
->	O
factor	double
=	O
1.0	int
/	O
theunit	*(struct)
->	O
factor	double
;	O
length	int
=	O
numlen	int
=	O
0	int
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
denominator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
,	O
length	int
++	O
)	O
;	O
for	O
(	O
ptr	*(char)
=	O
theunit	*(struct)
->	O
numerator	O
;	O
*	O
ptr	*(char)
;	O
ptr	*(char)
++	O
,	O
numlen	int
++	O
)	O
;	O
if	O
(	O
numlen	int
>	O
length	int
)	O
length	int
=	O
numlen	int
;	O
for	O
(	O
ind	int
=	O
0	int
;	O
ind	int
<=	O
length	int
;	O
ind	int
++	O
)	O
{	O
swap	*(char)
=	O
theunit	*(struct)
->	O
numerator	O
[	O
ind	int
]	O
;	O
theunit	*(struct)
->	O
numerator	O
[	O
ind	int
]	O
=	O
theunit	*(struct)
->	O
denominator	O
[	O
ind	int
]	O
;	O
theunit	*(struct)
->	O
denominator	O
[	O
ind	int
]	O
=	O
swap	*(char)
;	O
}	O
}	O
int	O
float2rat	(double,*(int),*(int))->(int)
(	O
double	O
y	double
,	O
int	O
*	O
p	int
,	O
int	O
*	O
q	*(int)
)	O
{	O
int	O
coef	array(int)
[	O
20	int
]	O
;	O
int	O
i	int
,	O
termcount	int
,	O
saveq	int
;	O
double	O
fracpart	double
,	O
x	double
;	O
x	double
=	O
y	double
;	O
termcount	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
coef	array(int)
[	O
termcount	int
]	O
=	O
(	O
int	O
)	O
floor	O
(	O
x	double
)	O
;	O
fracpart	double
=	O
x	double
-	O
coef	array(int)
[	O
termcount	int
]	O
;	O
if	O
(	O
fracpart	double
<	O
.001	int
||	O
termcount	int
==	O
19	int
)	O
break	O
;	O
x	double
=	O
1	int
/	O
fracpart	double
;	O
termcount	int
++	O
;	O
}	O
*	O
p	int
=	O
0	int
;	O
*	O
q	*(int)
=	O
1	int
;	O
for	O
(	O
i	int
=	O
termcount	int
;	O
i	int
>=	O
1	int
;	O
i	int
--	O
)	O
{	O
saveq	int
=	O
*	O
q	*(int)
;	O
*	O
q	*(int)
=	O
coef	array(int)
[	O
i	int
]	O
*	O
*	O
q	*(int)
+	O
*	O
p	int
;	O
*	O
p	int
=	O
saveq	int
;	O
}	O
*	O
p	int
+=	O
*	O
q	*(int)
*	O
coef	array(int)
[	O
0	int
]	O
;	O
return	O
*	O
q	*(int)
<	O
MAXSUBUNITS	O
&&	O
fabs	O
(	O
(	O
double	O
)	O
*	O
p	int
/	O
(	O
double	O
)	O
*	O
q	*(int)
-	O
y	double
)	O
<	O
DBL_EPSILON	O
;	O
}	O
int	O
unitpower	(*(struct),*(struct))->(int)
(	O
struct	O
unittype	O
*	O
base	*(struct)
,	O
struct	O
unittype	O
*	O
exponent	*(struct)
)	O
{	O
int	O
errcode	int
,	O
p	int
,	O
q	*(int)
;	O
errcode	int
=	O
unit2num	(*(struct))->(int)
(	O
exponent	*(struct)
)	O
;	O
if	O
(	O
errcode	int
==	O
E_NOTANUMBER	O
)	O
return	O
E_DIMEXPONENT	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
errcode	int
=	O
unit2num	(*(struct))->(int)
(	O
base	*(struct)
)	O
;	O
if	O
(	O
!	O
errcode	int
)	O
{	O
base	*(struct)
->	O
factor	double
=	O
pow	O
(	O
base	*(struct)
->	O
factor	double
,	O
exponent	*(struct)
->	O
factor	double
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
}	O
else	O
if	O
(	O
errcode	int
==	O
E_NOTANUMBER	O
)	O
{	O
if	O
(	O
!	O
float2rat	(double,*(int),*(int))->(int)
(	O
exponent	*(struct)
->	O
factor	double
,	O
&	O
p	int
,	O
&	O
q	*(int)
)	O
)	O
{	O
if	O
(	O
unitdimless	(*(struct))->(int)
(	O
base	*(struct)
)	O
)	O
{	O
base	*(struct)
->	O
factor	double
=	O
pow	O
(	O
base	*(struct)
->	O
factor	double
,	O
exponent	*(struct)
->	O
factor	double
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
}	O
else	O
return	O
E_IRRATIONAL_EXPONENT	O
;	O
}	O
else	O
{	O
if	O
(	O
q	*(int)
!=	O
1	int
)	O
{	O
errcode	int
=	O
rootunit	(*(struct),int)->(int)
(	O
base	*(struct)
,	O
q	*(int)
)	O
;	O
if	O
(	O
errcode	int
==	O
E_NOTROOT	O
)	O
return	O
E_BASE_NOTROOT	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
}	O
errcode	int
=	O
expunit	(*(struct),int)->(int)
(	O
base	*(struct)
,	O
abs	O
(	O
p	int
)	O
)	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
if	O
(	O
p	int
<	O
0	int
)	O
invertunit	(*(struct))->(void)
(	O
base	*(struct)
)	O
;	O
}	O
}	O
else	O
return	O
errcode	int
;	O
return	O
0	int
;	O
}	O
int	O
addunit	(*(struct),*(struct))->(int)
(	O
struct	O
unittype	O
*	O
unita	*(struct)
,	O
struct	O
unittype	O
*	O
unitb	*(struct)
)	O
{	O
int	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
unita	*(struct)
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
unitb	*(struct)
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
unita	*(struct)
,	O
unitb	*(struct)
,	O
ignore_nothing	(*(char))->(int)
)	O
)	O
return	O
E_BADSUM	O
;	O
unita	*(struct)
->	O
factor	double
+=	O
unitb	*(struct)
->	O
factor	double
;	O
freeunit	(*(struct))->(void)
(	O
unitb	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
double	O
linearinterp	(double,double,double,double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
aval	double
,	O
double	O
bval	double
,	O
double	O
c	char
)	O
{	O
double	O
lambda	double
;	O
lambda	double
=	O
(	O
b	double
-	O
c	char
)	O
/	O
(	O
b	double
-	O
a	double
)	O
;	O
return	O
lambda	double
*	O
aval	double
+	O
(	O
1	int
-	O
lambda	double
)	O
*	O
bval	double
;	O
}	O
int	O
evalfunc	(*(struct),*(struct),int,int)->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
,	O
struct	O
func	*(struct)
*	O
infunc	*(struct)
,	O
int	O
inverse	int
,	O
int	O
allerrors	int
)	O
{	O
struct	O
unittype	O
result	struct
;	O
struct	O
functype	O
*	O
thefunc	*(struct)
;	O
int	O
err	int
;	O
double	O
value	*(char)
;	O
int	O
foundit	int
,	O
count	*(int)
;	O
struct	O
unittype	O
*	O
save_value	*(struct)
;	O
char	O
*	O
save_function	*(char)
;	O
if	O
(	O
infunc	*(struct)
->	O
table	O
)	O
{	O
err	int
=	O
parseunit	()->(int)
(	O
&	O
result	struct
,	O
infunc	*(struct)
->	O
tableunit	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
if	O
(	O
inverse	int
)	O
{	O
err	int
=	O
divunit	(*(struct),*(struct))->(int)
(	O
theunit	*(struct)
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
unit2num	(*(struct))->(int)
(	O
theunit	*(struct)
)	O
;	O
if	O
(	O
err	int
==	O
E_NOTANUMBER	O
)	O
return	O
E_BADFUNCARG	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
value	*(char)
=	O
theunit	*(struct)
->	O
factor	double
;	O
foundit	int
=	O
0	int
;	O
for	O
(	O
count	*(int)
=	O
0	int
;	O
count	*(int)
<	O
infunc	*(struct)
->	O
tablelen	O
-	O
1	int
;	O
count	*(int)
++	O
)	O
if	O
(	O
(	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
value	*(char)
<=	O
value	*(char)
&&	O
value	*(char)
<=	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
value	*(char)
)	O
||	O
(	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
value	*(char)
<=	O
value	*(char)
&&	O
value	*(char)
<=	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
value	*(char)
)	O
)	O
{	O
foundit	int
=	O
1	int
;	O
value	*(char)
=	O
linearinterp	(double,double,double,double,double)->(double)
(	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
value	*(char)
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
value	*(char)
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
location	O
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
location	O
,	O
value	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
foundit	int
)	O
return	O
E_NOTINDOMAIN	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
result	struct
)	O
;	O
freeunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
theunit	*(struct)
->	O
factor	double
=	O
value	*(char)
;	O
return	O
0	int
;	O
}	O
else	O
{	O
err	int
=	O
unit2num	(*(struct))->(int)
(	O
theunit	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
value	*(char)
=	O
theunit	*(struct)
->	O
factor	double
;	O
foundit	int
=	O
0	int
;	O
for	O
(	O
count	*(int)
=	O
0	int
;	O
count	*(int)
<	O
infunc	*(struct)
->	O
tablelen	O
-	O
1	int
;	O
count	*(int)
++	O
)	O
if	O
(	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
location	O
<=	O
value	*(char)
&&	O
value	*(char)
<=	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
location	O
)	O
{	O
foundit	int
=	O
1	int
;	O
value	*(char)
=	O
linearinterp	(double,double,double,double,double)->(double)
(	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
location	O
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
location	O
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
]	O
.	O
value	*(char)
,	O
infunc	*(struct)
->	O
table	O
[	O
count	*(int)
+	O
1	int
]	O
.	O
value	*(char)
,	O
value	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
foundit	int
)	O
return	O
E_NOTINDOMAIN	O
;	O
result	struct
.	O
factor	double
*=	O
value	*(char)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
inverse	int
)	O
{	O
thefunc	*(struct)
=	O
&	O
(	O
infunc	*(struct)
->	O
inverse	int
)	O
;	O
if	O
(	O
!	O
thefunc	*(struct)
->	O
def	*(char)
)	O
return	O
E_NOINVERSE	O
;	O
}	O
else	O
thefunc	*(struct)
=	O
&	O
(	O
infunc	*(struct)
->	O
forward	O
)	O
;	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
theunit	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
thefunc	*(struct)
->	O
dimen	*(char)
)	O
{	O
err	int
=	O
parseunit	()->(int)
(	O
&	O
result	struct
,	O
thefunc	*(struct)
->	O
dimen	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
&	O
result	struct
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
&	O
result	struct
,	O
theunit	*(struct)
,	O
ignore_nothing	(*(char))->(int)
)	O
)	O
return	O
E_BADFUNCARG	O
;	O
value	*(char)
=	O
theunit	*(struct)
->	O
factor	double
/	O
result	struct
.	O
factor	double
;	O
}	O
else	O
value	*(char)
=	O
theunit	*(struct)
->	O
factor	double
;	O
if	O
(	O
thefunc	*(struct)
->	O
domain_max	*(double)
&&	O
(	O
value	*(char)
>	O
*	O
thefunc	*(struct)
->	O
domain_max	*(double)
||	O
(	O
thefunc	*(struct)
->	O
domain_max_open	int
&&	O
value	*(char)
==	O
*	O
thefunc	*(struct)
->	O
domain_max	*(double)
)	O
)	O
)	O
return	O
E_NOTINDOMAIN	O
;	O
if	O
(	O
thefunc	*(struct)
->	O
domain_min	*(double)
&&	O
(	O
value	*(char)
<	O
*	O
thefunc	*(struct)
->	O
domain_min	*(double)
||	O
(	O
thefunc	*(struct)
->	O
domain_min_open	int
&&	O
value	*(char)
==	O
*	O
thefunc	*(struct)
->	O
domain_min	*(double)
)	O
)	O
)	O
return	O
E_NOTINDOMAIN	O
;	O
save_value	*(struct)
=	O
parameter_value	*(struct)
;	O
save_function	*(char)
=	O
function_parameter	*(char)
;	O
parameter_value	*(struct)
=	O
theunit	*(struct)
;	O
function_parameter	*(char)
=	O
thefunc	*(struct)
->	O
param	O
;	O
err	int
=	O
parseunit	()->(int)
(	O
&	O
result	struct
,	O
thefunc	*(struct)
->	O
def	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
function_parameter	*(char)
=	O
save_function	*(char)
;	O
parameter_value	*(struct)
=	O
save_value	*(struct)
;	O
if	O
(	O
err	int
&&	O
(	O
allerrors	int
==	O
ALLERR	int
||	O
err	int
==	O
E_PARSEMEM	O
||	O
err	int
==	O
E_PRODOVERFLOW	O
||	O
err	int
==	O
E_NOTROOT	O
||	O
err	int
==	O
E_BADFUNCTYPE	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
err	int
)	O
return	O
E_FUNARGDEF	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
multunit	(*(struct),*(struct))->(int)
(	O
theunit	*(struct)
,	O
&	O
result	struct
)	O
;	O
return	O
0	int
;	O
}	O
void	O
showdefinition	(*(char),*(struct))->(void)
(	O
char	O
*	O
unitstr	*(char)
,	O
struct	O
unittype	O
*	O
theunit	*(struct)
)	O
{	O
logputs	(*(char))->(void)
(	O
deftext	*(char)
)	O
;	O
while	O
(	O
(	O
unitstr	*(char)
=	O
lookupunit	(*(char),int)->(*(char))
(	O
unitstr	*(char)
,	O
1	int
)	O
)	O
&&	O
strspn	O
(	O
unitstr	*(char)
,	O
digits	*(char)
)	O
!=	O
strlen	O
(	O
unitstr	*(char)
)	O
&&	O
!	O
strchr	O
(	O
unitstr	*(char)
,	O
PRIMITIVECHAR	char
)	O
)	O
{	O
tightprint	(*(int),*(char))->(void)
(	O
stdout	O
,	O
unitstr	*(char)
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
tightprint	(*(int),*(char))->(void)
(	O
logfile	*(int)
,	O
unitstr	*(char)
)	O
;	O
logputs	(*(char))->(void)
(	O
" = "	*(char)
)	O
;	O
}	O
showunit	(*(struct))->(void)
(	O
theunit	*(struct)
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
void	O
showfunction	(*(struct))->(void)
(	O
struct	O
functype	O
*	O
func	*(struct)
)	O
{	O
struct	O
unittype	O
unit	*(char)
;	O
int	O
not_dimensionless	int
,	O
i	int
;	O
if	O
(	O
!	O
func	*(struct)
->	O
def	*(char)
)	O
{	O
logputs	(*(char))->(void)
(	O
" is undefined"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
func	*(struct)
->	O
dimen	*(char)
)	O
{	O
parseunit	()->(int)
(	O
&	O
unit	*(char)
,	O
func	*(struct)
->	O
dimen	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
not_dimensionless	int
=	O
unit2num	(*(struct))->(int)
(	O
&	O
unit	*(char)
)	O
;	O
}	O
logprintf	(*(char))->(void)
(	O
"(%s) = %s"	*(char)
,	O
func	*(struct)
->	O
param	O
,	O
func	*(struct)
->	O
def	*(char)
)	O
;	O
if	O
(	O
func	*(struct)
->	O
domain_min	*(double)
||	O
func	*(struct)
->	O
domain_max	*(double)
)	O
{	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
for	O
(	O
i	int
=	O
strwidth	(*(char))->(int)
(	O
deftext	*(char)
)	O
;	O
i	int
;	O
i	int
--	O
)	O
logputchar	(char)->(void)
(	O
' '	O
)	O
;	O
logputs	(*(char))->(void)
(	O
"defined for "	*(char)
)	O
;	O
if	O
(	O
func	*(struct)
->	O
domain_min	*(double)
&&	O
func	*(struct)
->	O
domain_max	*(double)
)	O
{	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
*	O
func	*(struct)
->	O
domain_min	*(double)
)	O
;	O
if	O
(	O
func	*(struct)
->	O
dimen	*(char)
&&	O
(	O
not_dimensionless	int
||	O
unit	*(char)
.	O
factor	double
!=	O
1	int
)	O
)	O
{	O
if	O
(	O
isdecimal	(char)->(int)
(	O
*	O
func	*(struct)
->	O
dimen	*(char)
)	O
)	O
logputs	(*(char))->(void)
(	O
" *"	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
func	*(struct)
->	O
dimen	*(char)
)	O
;	O
}	O
logputs	(*(char))->(void)
(	O
func	*(struct)
->	O
domain_min_open	int
?	O
" < "	*(char)
:	O
" <= "	*(char)
)	O
;	O
}	O
logputs	(*(char))->(void)
(	O
func	*(struct)
->	O
param	O
)	O
;	O
if	O
(	O
func	*(struct)
->	O
domain_max	*(double)
)	O
{	O
logputs	(*(char))->(void)
(	O
func	*(struct)
->	O
domain_max_open	int
?	O
" < "	*(char)
:	O
" <= "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
*	O
func	*(struct)
->	O
domain_max	*(double)
)	O
;	O
}	O
else	O
{	O
logputs	(*(char))->(void)
(	O
func	*(struct)
->	O
domain_min_open	int
?	O
" > "	*(char)
:	O
" >= "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
*	O
func	*(struct)
->	O
domain_min	*(double)
)	O
;	O
}	O
if	O
(	O
func	*(struct)
->	O
dimen	*(char)
&&	O
(	O
not_dimensionless	int
||	O
unit	*(char)
.	O
factor	double
!=	O
1	int
)	O
)	O
{	O
if	O
(	O
isdecimal	(char)->(int)
(	O
*	O
func	*(struct)
->	O
dimen	*(char)
)	O
)	O
logputs	(*(char))->(void)
(	O
" *"	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
func	*(struct)
->	O
dimen	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
func	*(struct)
->	O
dimen	*(char)
)	O
logputs	(*(char))->(void)
(	O
" (any units)"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
func	*(struct)
->	O
dimen	*(char)
)	O
{	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
for	O
(	O
i	int
=	O
strwidth	(*(char))->(int)
(	O
deftext	*(char)
)	O
;	O
i	int
;	O
i	int
--	O
)	O
logputchar	(char)->(void)
(	O
' '	O
)	O
;	O
if	O
(	O
not_dimensionless	int
)	O
logprintf	(*(char))->(void)
(	O
"%s has units %s"	*(char)
,	O
func	*(struct)
->	O
param	O
,	O
func	*(struct)
->	O
dimen	*(char)
)	O
;	O
else	O
logprintf	(*(char))->(void)
(	O
"%s is dimensionless"	*(char)
,	O
func	*(struct)
->	O
param	O
)	O
;	O
}	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
void	O
showtable	(*(struct),int)->(void)
(	O
struct	O
func	*(struct)
*	O
fun	*(struct)
,	O
int	O
inverse	int
)	O
{	O
int	O
i	int
;	O
logprintf	(*(char))->(void)
(	O
"%sinterpolated table with points\n"	*(char)
,	O
deftext	*(char)
)	O
;	O
if	O
(	O
inverse	int
)	O
{	O
int	O
reverse	int
,	O
j	int
;	O
reverse	int
=	O
(	O
fun	*(struct)
->	O
table	O
[	O
0	int
]	O
.	O
value	*(char)
>	O
fun	*(struct)
->	O
table	O
[	O
fun	*(struct)
->	O
tablelen	O
-	O
1	int
]	O
.	O
value	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fun	*(struct)
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
reverse	int
)	O
j	int
=	O
fun	*(struct)
->	O
tablelen	O
-	O
i	int
-	O
1	int
;	O
else	O
j	int
=	O
i	int
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
>	O
0	int
)	O
logputs	(*(char))->(void)
(	O
"\t\t    "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
"~%s("	*(char)
,	O
fun	*(struct)
->	O
name	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
fun	*(struct)
->	O
table	O
[	O
j	int
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
isdecimal	(char)->(int)
(	O
fun	*(struct)
->	O
tableunit	*(char)
[	O
0	int
]	O
)	O
)	O
logputs	(*(char))->(void)
(	O
" *"	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
fun	*(struct)
->	O
tableunit	*(char)
)	O
;	O
logputs	(*(char))->(void)
(	O
") = "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
fun	*(struct)
->	O
table	O
[	O
j	int
]	O
.	O
location	O
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fun	*(struct)
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
>	O
0	int
)	O
logputs	(*(char))->(void)
(	O
"\t\t    "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
"%s("	*(char)
,	O
fun	*(struct)
->	O
name	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
fun	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
location	O
)	O
;	O
logputs	(*(char))->(void)
(	O
") = "	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
fun	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
isdecimal	(char)->(int)
(	O
fun	*(struct)
->	O
tableunit	*(char)
[	O
0	int
]	O
)	O
)	O
logputs	(*(char))->(void)
(	O
" *"	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
" %s\n"	*(char)
,	O
fun	*(struct)
->	O
tableunit	*(char)
)	O
;	O
}	O
}	O
}	O
void	O
showfuncdefinition	(*(struct),int)->(void)
(	O
struct	O
func	*(struct)
*	O
fun	*(struct)
,	O
int	O
inverse	int
)	O
{	O
if	O
(	O
fun	*(struct)
->	O
table	O
)	O
showtable	(*(struct),int)->(void)
(	O
fun	*(struct)
,	O
inverse	int
)	O
;	O
else	O
{	O
logprintf	(*(char))->(void)
(	O
"%s%s%s"	*(char)
,	O
deftext	*(char)
,	O
inverse	int
?	O
"~"	*(char)
:	O
""	*(char)
,	O
fun	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
inverse	int
)	O
showfunction	(*(struct))->(void)
(	O
&	O
fun	*(struct)
->	O
inverse	int
)	O
;	O
else	O
showfunction	(*(struct))->(void)
(	O
&	O
fun	*(struct)
->	O
forward	O
)	O
;	O
}	O
}	O
void	O
showunitlistdef	(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))->(void)
(	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
)	O
{	O
logprintf	(*(char))->(void)
(	O
"%sunit list, "	*(char)
,	O
deftext	*(char)
)	O
;	O
tightprint	(*(int),*(char))->(void)
(	O
stdout	O
,	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
tightprint	(*(int),*(char))->(void)
(	O
logfile	*(int)
,	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
int	O
showfunc	(*(char),*(struct),*(struct))->(int)
(	O
char	O
*	O
havestr	*(char)
,	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
struct	O
func	*(struct)
*	O
fun	*(struct)
)	O
{	O
int	O
err	int
;	O
char	O
*	O
dimen	*(char)
;	O
err	int
=	O
evalfunc	(*(struct),*(struct),int,int)->(int)
(	O
have	*(struct)
,	O
fun	*(struct)
,	O
INVERSE	int
,	O
NORMALERR	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
have	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
{	O
if	O
(	O
err	int
==	O
E_BADFUNCARG	O
)	O
{	O
logputs	(*(char))->(void)
(	O
"conformability error"	*(char)
)	O
;	O
if	O
(	O
fun	*(struct)
->	O
table	O
)	O
dimen	*(char)
=	O
fun	*(struct)
->	O
tableunit	*(char)
;	O
else	O
if	O
(	O
fun	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
)	O
dimen	*(char)
=	O
fun	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
;	O
else	O
dimen	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
dimen	*(char)
)	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
else	O
{	O
struct	O
unittype	O
want	struct
;	O
if	O
(	O
emptystr	O
(	O
dimen	*(char)
)	O
)	O
dimen	*(char)
=	O
"1"	*(char)
;	O
logprintf	(*(char))->(void)
(	O
": conversion requires dimensions of '%s'\n"	*(char)
,	O
dimen	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\t%s = "	*(char)
,	O
havestr	*(char)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputchar	(char)->(void)
(	O
'\t'	O
)	O
;	O
showunit	(*(struct))->(void)
(	O
have	*(struct)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\n\t%s = "	*(char)
,	O
dimen	*(char)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logprintf	(*(char))->(void)
(	O
"\n\t"	*(char)
)	O
;	O
else	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
parseunit	()->(int)
(	O
&	O
want	struct
,	O
dimen	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
completereduce	(*(struct))->(int)
(	O
&	O
want	struct
)	O
;	O
showunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
err	int
==	O
E_NOTINDOMAIN	O
)	O
logprintf	(*(char))->(void)
(	O
"Value '%s' is not in the function's range\n"	*(char)
,	O
havestr	*(char)
)	O
;	O
else	O
logputs	(*(char))->(void)
(	O
"Function evaluation error (bad function definition)\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\t%s = %s("	*(char)
,	O
havestr	*(char)
,	O
fun	*(struct)
->	O
inverse	int
.	O
param	O
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputchar	(char)->(void)
(	O
'\t'	O
)	O
;	O
showunit	(*(struct))->(void)
(	O
have	*(struct)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logputchar	(char)->(void)
(	O
')'	O
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
showconformabilityerr	(*(char),*(struct),*(char),*(struct))->(void)
(	O
char	O
*	O
havestr	*(char)
,	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
char	O
*	O
wantstr	*(char)
,	O
struct	O
unittype	O
*	O
want	struct
)	O
{	O
logputs	(*(char))->(void)
(	O
"conformability error\n"	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\t%s = "	*(char)
,	O
havestr	*(char)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputchar	(char)->(void)
(	O
'\t'	O
)	O
;	O
showunit	(*(struct))->(void)
(	O
have	*(struct)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\n\t%s = "	*(char)
,	O
wantstr	*(char)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputs	(*(char))->(void)
(	O
"\n\t"	*(char)
)	O
;	O
else	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
showunit	(*(struct))->(void)
(	O
want	struct
)	O
;	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
}	O
int	O
isfract	(*(char))->(int)
(	O
const	O
char	O
*	O
unitstr	*(char)
)	O
{	O
char	O
*	O
enddouble	*(char)
=	O
0	int
,	O
*	O
endlong	*(char)
=	O
0	int
;	O
while	O
(	O
isdigit	O
(	O
*	O
unitstr	*(char)
)	O
)	O
unitstr	*(char)
++	O
;	O
if	O
(	O
*	O
unitstr	*(char)
++	O
==	O
'|'	O
)	O
{	O
(	O
void	O
)	O
strtod	O
(	O
unitstr	*(char)
,	O
&	O
enddouble	*(char)
)	O
;	O
(	O
void	O
)	O
strtol	O
(	O
unitstr	*(char)
,	O
&	O
endlong	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
enddouble	*(char)
==	O
endlong	*(char)
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
checksigdigits	(*(char))->(int)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
errors	int
,	O
ival	int
;	O
char	O
*	O
nonum	*(char)
;	O
errors	int
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	O
(	O
arg	*(char)
,	O
"max"	*(char)
)	O
)	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
MAXPRECISION	O
;	O
else	O
{	O
ival	int
=	O
(	O
int	O
)	O
strtol	O
(	O
arg	*(char)
,	O
&	O
nonum	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
nonum	*(char)
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid significant digits (%s)--integer value or 'max' required\n"	*(char)
,	O
progname	*(char)
,	O
arg	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
ival	int
<=	O
0	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: number of significant digits must be positive\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
ival	int
>	O
MAXPRECISION	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: too many significant digits (%d)--using maximum value (%d)\n"	*(char)
,	O
progname	*(char)
,	O
ival	int
,	O
MAXPRECISION	O
)	O
;	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
MAXPRECISION	O
;	O
}	O
else	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
ival	int
;	O
}	O
if	O
(	O
errors	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
setnumformat	()->(int)
(	O
)	O
{	O
size_t	O
len	int
;	O
if	O
(	O
strchr	O
(	O
"Ee"	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
type	char
)	O
)	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
--	O
;	O
len	int
=	O
4	int
;	O
if	O
(	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
>	O
0	int
)	O
len	int
+=	O
(	O
size_t	O
)	O
floor	O
(	O
log10	O
(	O
(	O
double	O
)	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
)	O
)	O
+	O
1	int
;	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
len	int
,	O
"(setnumformat)"	*(char)
)	O
;	O
sprintf	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
"%%.%d%c"	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
,	O
num_format	struct(*(char),int,int,char)
.	O
type	char
)	O
;	O
return	O
0	int
;	O
}	O
int	O
parsenumformat	()->(int)
(	O
)	O
{	O
static	O
char	O
*	O
format_types	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
format_flags	*(char)
=	O
"+-# 0'"	*(char)
;	O
static	O
char	O
badflag	char
;	O
char	O
*	O
two	*(*(char))
=	O
"0x1p+1"	*(char)
;	O
char	O
*	O
valid	*(char)
=	O
"ABCDEFGHIJKLMNOPQRSTUVWXYXabcdefghijklmnopqrstuvwxyx.01234567890"	*(char)
;	O
char	O
*	O
dotptr	*(char)
,	O
*	O
lptr	*(char)
,	O
*	O
nonum	*(char)
,	O
*	O
p	int
;	O
char	O
testbuf	array(char)
[	O
80	int
]	O
;	O
int	O
errors	int
,	O
ndx	int
;	O
if	O
(	O
format_types	*(char)
==	O
NULL	O
)	O
{	O
format_types	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
BASE_FORMATS	*(char)
)	O
+	O
4	int
,	O
"(parsenumformat)"	*(char)
)	O
;	O
strcpy	O
(	O
format_types	*(char)
,	O
BASE_FORMATS	*(char)
)	O
;	O
sprintf	O
(	O
testbuf	array(char)
,	O
"%.1F"	*(char)
,	O
1.2	int
)	O
;	O
if	O
(	O
strlen	O
(	O
testbuf	array(char)
)	O
==	O
3	int
&&	O
testbuf	array(char)
[	O
0	int
]	O
==	O
'1'	O
&&	O
testbuf	array(char)
[	O
2	int
]	O
==	O
'2'	O
)	O
strcat	O
(	O
format_types	*(char)
,	O
"F"	*(char)
)	O
;	O
sprintf	O
(	O
testbuf	array(char)
,	O
"%.0a"	*(char)
,	O
2.0	int
)	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
testbuf	array(char)
,	O
two	*(*(char))
)	O
)	O
strcat	O
(	O
format_types	*(char)
,	O
"aA"	*(char)
)	O
;	O
sprintf	O
(	O
testbuf	array(char)
,	O
"%'.0f"	*(char)
,	O
1234.0	int
)	O
;	O
if	O
(	O
strlen	O
(	O
testbuf	array(char)
)	O
>	O
2	int
&&	O
testbuf	array(char)
[	O
0	int
]	O
==	O
'1'	O
&&	O
testbuf	array(char)
[	O
2	int
]	O
==	O
'2'	O
)	O
badflag	char
=	O
'\0'	O
;	O
else	O
badflag	char
=	O
'\''	O
;	O
}	O
errors	int
=	O
0	int
;	O
p	int
=	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
;	O
if	O
(	O
*	O
p	int
!=	O
'%'	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: number format specification must start with '%%'\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
strrchr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
'%'	O
)	O
!=	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: only one '%%' allowed in number format specification\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
p	int
++	O
;	O
}	O
else	O
p	int
++	O
;	O
dotptr	*(char)
=	O
strchr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
dotptr	*(char)
&&	O
strrchr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
'.'	O
)	O
!=	O
dotptr	*(char)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: only one '.' allowed in number format specification\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
while	O
(	O
*	O
p	int
&&	O
strchr	O
(	O
format_flags	*(char)
,	O
*	O
p	int
)	O
)	O
{	O
if	O
(	O
*	O
p	int
==	O
badflag	char
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: digit-grouping flag (') not supported\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
p	int
++	O
;	O
}	O
if	O
(	O
(	O
lptr	*(char)
=	O
strstr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
"hh"	*(char)
)	O
)	O
||	O
(	O
lptr	*(char)
=	O
strstr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
"ll"	*(char)
)	O
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: type length modifier (%.2s) not supported\n"	*(char)
,	O
progname	*(char)
,	O
lptr	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
(	O
lptr	*(char)
=	O
strpbrk	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
"hjLltz"	*(char)
)	O
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: type length modifier (%c) not supported\n"	*(char)
,	O
progname	*(char)
,	O
lptr	*(char)
[	O
0	int
]	O
)	O
;	O
errors	int
++	O
;	O
}	O
ndx	int
=	O
strspn	O
(	O
p	int
,	O
valid	*(char)
)	O
;	O
if	O
(	O
ndx	int
<	O
strlen	O
(	O
p	int
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid character (%c) in width, precision, or type\n"	*(char)
,	O
progname	*(char)
,	O
p	int
[	O
ndx	int
]	O
)	O
;	O
errors	int
++	O
;	O
}	O
if	O
(	O
errors	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid number format specification (%s)\n"	*(char)
,	O
progname	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
)	O
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: valid specification is %%[flags][width][.precision]type\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
num_format	struct(*(char),int,int,char)
.	O
width	int
=	O
(	O
int	O
)	O
strtol	O
(	O
p	int
,	O
&	O
nonum	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
nonum	*(char)
==	O
'.'	O
)	O
{	O
if	O
(	O
isdigit	O
(	O
nonum	*(char)
[	O
1	int
]	O
)	O
)	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
(	O
int	O
)	O
strtol	O
(	O
nonum	*(char)
+	O
1	int
,	O
&	O
nonum	*(char)
,	O
10	int
)	O
;	O
else	O
{	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
0	int
;	O
nonum	*(char)
++	O
;	O
}	O
}	O
else	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
6	int
;	O
if	O
(	O
emptystr	O
(	O
nonum	*(char)
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: missing format type\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
strchr	O
(	O
format_types	*(char)
,	O
*	O
nonum	*(char)
)	O
)	O
{	O
if	O
(	O
nonum	*(char)
[	O
1	int
]	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid character(s) (%s) after format type\n"	*(char)
,	O
progname	*(char)
,	O
nonum	*(char)
+	O
1	int
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
num_format	struct(*(char),int,int,char)
.	O
type	char
=	O
*	O
nonum	*(char)
;	O
}	O
else	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid format type (%c)--valid types are [%s]\n"	*(char)
,	O
progname	*(char)
,	O
*	O
nonum	*(char)
,	O
format_types	*(char)
)	O
;	O
errors	int
++	O
;	O
}	O
}	O
if	O
(	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
==	O
0	int
&&	O
(	O
num_format	struct(*(char),int,int,char)
.	O
type	char
==	O
'G'	O
||	O
num_format	struct(*(char),int,int,char)
.	O
type	char
==	O
'g'	O
)	O
)	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
1	int
;	O
if	O
(	O
errors	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: invalid number format specification (%s)\n"	*(char)
,	O
progname	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
)	O
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: valid specification is %%[flags][width][.precision]type\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
double	O
round_to_displayed	(double,*(int))->(double)
(	O
double	O
value	*(char)
,	O
int	O
*	O
hasnondigits	*(int)
)	O
{	O
int	O
buflen	int
;	O
char	O
*	O
buf	*(*(char))
;	O
double	O
rounded	double
;	O
if	O
(	O
!	O
isfinite	()->(int)
(	O
value	*(char)
)	O
)	O
{	O
if	O
(	O
hasnondigits	*(int)
)	O
*	O
hasnondigits	*(int)
=	O
1	int
;	O
return	O
value	*(char)
;	O
}	O
buflen	int
=	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
+	O
9	int
;	O
if	O
(	O
num_format	struct(*(char),int,int,char)
.	O
width	int
>	O
buflen	int
)	O
buflen	int
=	O
num_format	struct(*(char),int,int,char)
.	O
width	int
;	O
if	O
(	O
strchr	O
(	O
"Ff"	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
type	char
)	O
)	O
{	O
int	O
len	int
=	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
+	O
2	int
;	O
if	O
(	O
fabs	O
(	O
value	*(char)
)	O
>	O
1.0	int
)	O
len	int
+=	O
(	O
int	O
)	O
floor	O
(	O
log10	O
(	O
fabs	O
(	O
value	*(char)
)	O
)	O
)	O
+	O
1	int
;	O
if	O
(	O
len	int
>	O
buflen	int
)	O
buflen	int
=	O
len	int
;	O
}	O
if	O
(	O
strchr	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
'\''	O
)	O
&&	O
strchr	O
(	O
"FfGg"	*(char)
,	O
num_format	struct(*(char),int,int,char)
.	O
type	char
)	O
)	O
buflen	int
=	O
buflen	int
*	O
3	int
/	O
2	int
;	O
buf	*(*(char))
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
buflen	int
,	O
"(round_to_displayed)"	*(char)
)	O
;	O
sprintf	O
(	O
buf	*(*(char))
,	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
value	*(char)
)	O
;	O
if	O
(	O
hasnondigits	*(int)
)	O
{	O
if	O
(	O
strspn	O
(	O
buf	*(*(char))
,	O
"1234567890"	*(char)
)	O
!=	O
strlen	O
(	O
buf	*(*(char))
)	O
)	O
*	O
hasnondigits	*(int)
=	O
1	int
;	O
else	O
*	O
hasnondigits	*(int)
=	O
0	int
;	O
}	O
rounded	double
=	O
strtod	O
(	O
buf	*(*(char))
,	O
NULL	O
)	O
;	O
free	()->(int)
(	O
buf	*(*(char))
)	O
;	O
return	O
rounded	double
;	O
}	O
void	O
showunitname	(double,*(char),int)->(void)
(	O
double	O
value	*(char)
,	O
char	O
*	O
unitstr	*(char)
,	O
int	O
printnum	int
)	O
{	O
int	O
hasnondigits	*(int)
;	O
double	O
rnd_value	double
;	O
rnd_value	double
=	O
round_to_displayed	(double,*(int))->(double)
(	O
value	*(char)
,	O
&	O
hasnondigits	*(int)
)	O
;	O
if	O
(	O
printnum	int
&&	O
!	O
(	O
rnd_value	double
==	O
1	int
&&	O
isdecimal	(char)->(int)
(	O
*	O
unitstr	*(char)
)	O
)	O
)	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
value	*(char)
)	O
;	O
if	O
(	O
strpbrk	O
(	O
unitstr	*(char)
,	O
"+-"	*(char)
)	O
)	O
logprintf	(*(char))->(void)
(	O
" (%s)"	*(char)
,	O
unitstr	*(char)
)	O
;	O
else	O
if	O
(	O
printnum	int
&&	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
showfactor	int
&&	O
startswith	O
(	O
unitstr	*(char)
,	O
"1|"	*(char)
)	O
&&	O
isfract	(*(char))->(int)
(	O
unitstr	*(char)
)	O
&&	O
rnd_value	double
!=	O
1	int
&&	O
!	O
hasnondigits	*(int)
)	O
logputs	(*(char))->(void)
(	O
unitstr	*(char)
+	O
1	int
)	O
;	O
else	O
if	O
(	O
rnd_value	double
==	O
1	int
&&	O
isdecimal	(char)->(int)
(	O
*	O
unitstr	*(char)
)	O
)	O
logputs	(*(char))->(void)
(	O
unitstr	*(char)
)	O
;	O
else	O
if	O
(	O
isdecimal	(char)->(int)
(	O
unitstr	*(char)
[	O
0	int
]	O
)	O
)	O
logprintf	(*(char))->(void)
(	O
" * %s"	*(char)
,	O
unitstr	*(char)
)	O
;	O
else	O
logprintf	(*(char))->(void)
(	O
" %s"	*(char)
,	O
unitstr	*(char)
)	O
;	O
}	O
int	O
showanswer	(*(char),*(struct),*(char),*(struct))->(int)
(	O
char	O
*	O
havestr	*(char)
,	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
char	O
*	O
wantstr	*(char)
,	O
struct	O
unittype	O
*	O
want	struct
)	O
{	O
struct	O
unittype	O
invhave	struct
;	O
int	O
doingrec	int
;	O
char	O
*	O
right	*(struct)
=	O
NULL	O
,	O
*	O
left	*(struct)
=	O
NULL	O
;	O
doingrec	int
=	O
0	int
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
have	*(struct)
,	O
want	struct
,	O
ignore_dimless	(*(char))->(int)
)	O
)	O
{	O
char	O
*	O
*	O
src	*(struct)
,	O
*	O
*	O
dest	*(struct)
;	O
invhave	struct
.	O
factor	double
=	O
1	int
/	O
have	*(struct)
->	O
factor	double
;	O
for	O
(	O
src	*(struct)
=	O
have	*(struct)
->	O
numerator	O
,	O
dest	*(struct)
=	O
invhave	struct
.	O
denominator	O
;	O
*	O
src	*(struct)
;	O
src	*(struct)
++	O
,	O
dest	*(struct)
++	O
)	O
*	O
dest	*(struct)
=	O
*	O
src	*(struct)
;	O
*	O
dest	*(struct)
=	O
0	int
;	O
for	O
(	O
src	*(struct)
=	O
have	*(struct)
->	O
denominator	O
,	O
dest	*(struct)
=	O
invhave	struct
.	O
numerator	O
;	O
*	O
src	*(struct)
;	O
src	*(struct)
++	O
,	O
dest	*(struct)
++	O
)	O
*	O
dest	*(struct)
=	O
*	O
src	*(struct)
;	O
*	O
dest	*(struct)
=	O
0	int
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
strictconvert	int
||	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
&	O
invhave	struct
,	O
want	struct
,	O
ignore_dimless	(*(char))->(int)
)	O
)	O
{	O
showconformabilityerr	(*(char),*(struct),*(char),*(struct))->(void)
(	O
havestr	*(char)
,	O
have	*(struct)
,	O
wantstr	*(char)
,	O
want	struct
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
>	O
0	int
)	O
logputchar	(char)->(void)
(	O
'\t'	O
)	O
;	O
logputs	(*(char))->(void)
(	O
"reciprocal conversion\n"	*(char)
)	O
;	O
have	*(struct)
=	O
&	O
invhave	struct
;	O
doingrec	int
=	O
1	int
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
doingrec	int
)	O
left	*(struct)
=	O
right	*(struct)
=	O
""	*(char)
;	O
else	O
if	O
(	O
strchr	O
(	O
havestr	*(char)
,	O
'/'	O
)	O
)	O
{	O
left	*(struct)
=	O
"1 / ("	*(char)
;	O
right	*(struct)
=	O
")"	*(char)
;	O
}	O
else	O
{	O
left	*(struct)
=	O
"1 / "	*(char)
;	O
right	*(struct)
=	O
""	*(char)
;	O
}	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\t%s%s%s = "	*(char)
,	O
left	*(struct)
,	O
havestr	*(char)
,	O
right	*(struct)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputs	(*(char))->(void)
(	O
"\t* "	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
showunitname	(double,*(char),int)->(void)
(	O
have	*(struct)
->	O
factor	double
/	O
want	struct
->	O
factor	double
,	O
wantstr	*(char)
,	O
PRINTNUM	int
)	O
;	O
else	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
have	*(struct)
->	O
factor	double
/	O
want	struct
->	O
factor	double
)	O
;	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
oneline	int
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
logprintf	(*(char))->(void)
(	O
"\n\t%s%s%s = (1 / "	*(char)
,	O
left	*(struct)
,	O
havestr	*(char)
,	O
right	*(struct)
)	O
;	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputs	(*(char))->(void)
(	O
"\n\t/ "	*(char)
)	O
;	O
else	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
want	struct
->	O
factor	double
/	O
have	*(struct)
->	O
factor	double
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
logputchar	(char)->(void)
(	O
')'	O
)	O
;	O
showunitname	(double,*(char),int)->(void)
(	O
0	int
,	O
wantstr	*(char)
,	O
NOPRINTNUM	int
)	O
;	O
}	O
}	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
checkfunc	(*(struct),int)->(void)
(	O
struct	O
func	*(struct)
*	O
infunc	*(struct)
,	O
int	O
verbose	int
)	O
{	O
struct	O
unittype	O
theunit	*(struct)
,	O
saveunit	struct
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
int	O
err	int
,	O
i	int
;	O
double	O
direction	double
;	O
if	O
(	O
infunc	*(struct)
->	O
skip_error_check	O
)	O
{	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"skipped function '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"doing function '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
plookup	(*(char))->(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*`,*`,int,*`,*`)))))
(	O
infunc	*(struct)
->	O
name	*(char)
)	O
)	O
&&	O
strlen	O
(	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
==	O
strlen	O
(	O
infunc	*(struct)
->	O
name	*(char)
)	O
)	O
printf	O
(	O
"Warning: '%s' defined as prefix and function\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
infunc	*(struct)
->	O
table	O
)	O
{	O
if	O
(	O
parseunit	()->(int)
(	O
&	O
theunit	*(struct)
,	O
infunc	*(struct)
->	O
tableunit	*(char)
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	(*(struct))->(int)
(	O
&	O
theunit	*(struct)
)	O
)	O
printf	O
(	O
"Table '%s' has invalid units '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
tableunit	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
if	O
(	O
infunc	*(struct)
->	O
tablelen	O
<=	O
1	int
)	O
{	O
printf	O
(	O
"Table '%s' has only one data point\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
direction	double
=	O
SIGN	O
(	O
infunc	*(struct)
->	O
table	O
[	O
1	int
]	O
.	O
value	*(char)
-	O
infunc	*(struct)
->	O
table	O
[	O
0	int
]	O
.	O
value	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
infunc	*(struct)
->	O
tablelen	O
;	O
i	int
++	O
)	O
if	O
(	O
SIGN	O
(	O
infunc	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
value	*(char)
-	O
infunc	*(struct)
->	O
table	O
[	O
i	int
-	O
1	int
]	O
.	O
value	*(char)
)	O
!=	O
direction	double
)	O
{	O
printf	O
(	O
"Table '%s' lacks unique inverse around entry %.8g\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
table	O
[	O
i	int
]	O
.	O
location	O
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
infunc	*(struct)
->	O
forward	O
.	O
dimen	*(char)
)	O
{	O
if	O
(	O
parseunit	()->(int)
(	O
&	O
theunit	*(struct)
,	O
infunc	*(struct)
->	O
forward	O
.	O
dimen	*(char)
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	(*(struct))->(int)
(	O
&	O
theunit	*(struct)
)	O
)	O
{	O
printf	O
(	O
"Function '%s' has invalid units '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
dimen	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
return	O
;	O
}	O
}	O
else	O
initializeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
if	O
(	O
infunc	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
&&	O
infunc	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
)	O
theunit	*(struct)
.	O
factor	double
*=	O
(	O
*	O
infunc	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
+	O
*	O
infunc	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
)	O
/	O
2	int
;	O
else	O
if	O
(	O
infunc	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
)	O
theunit	*(struct)
.	O
factor	double
=	O
theunit	*(struct)
.	O
factor	double
*	O
*	O
infunc	*(struct)
->	O
forward	O
.	O
domain_max	*(double)
-	O
1	int
;	O
else	O
if	O
(	O
infunc	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
)	O
theunit	*(struct)
.	O
factor	double
=	O
theunit	*(struct)
.	O
factor	double
*	O
*	O
infunc	*(struct)
->	O
forward	O
.	O
domain_min	*(double)
+	O
1	int
;	O
else	O
theunit	*(struct)
.	O
factor	double
*=	O
7	int
;	O
if	O
(	O
infunc	*(struct)
->	O
forward	O
.	O
dimen	*(char)
)	O
{	O
unitcopy	(*(struct),*(struct))->(void)
(	O
&	O
saveunit	struct
,	O
&	O
theunit	*(struct)
)	O
;	O
err	int
=	O
evalfunc	(*(struct),*(struct),int,int)->(int)
(	O
&	O
theunit	*(struct)
,	O
infunc	*(struct)
,	O
FUNCTION	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
printf	O
(	O
"Error in definition %s(%s) as '%s':\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
param	O
,	O
infunc	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
printf	O
(	O
"      %s\n"	*(char)
,	O
errormsg	array(*(char))
[	O
err	int
]	O
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
struct	O
unittype	O
resultunit	struct
,	O
arbunit	struct
;	O
char	O
unittext	array(char)
[	O
9	int
]	O
;	O
double	O
factor	double
;	O
int	O
errors	int
[	O
MAXPOWERTOCHECK	int
]	O
,	O
errcount	int
=	O
0	int
;	O
char	O
*	O
indent	*(char)
;	O
strcpy	O
(	O
unittext	array(char)
,	O
"(kg K)^ "	*(char)
)	O
;	O
factor	double
=	O
theunit	*(struct)
.	O
factor	double
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
resultunit	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXPOWERTOCHECK	int
;	O
i	int
++	O
)	O
{	O
lastchar	O
(	O
unittext	array(char)
)	O
=	O
'0'	O
+	O
i	int
;	O
err	int
=	O
parseunit	()->(int)
(	O
&	O
arbunit	struct
,	O
unittext	array(char)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
initializeunit	(*(struct))->(void)
(	O
&	O
arbunit	struct
)	O
;	O
arbunit	struct
.	O
factor	double
=	O
factor	double
;	O
unitcopy	(*(struct),*(struct))->(void)
(	O
&	O
resultunit	struct
,	O
&	O
arbunit	struct
)	O
;	O
errors	int
[	O
i	int
]	O
=	O
evalfunc	(*(struct),*(struct),int,int)->(int)
(	O
&	O
resultunit	struct
,	O
infunc	*(struct)
,	O
FUNCTION	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
errors	int
[	O
i	int
]	O
)	O
errcount	int
++	O
;	O
else	O
{	O
freeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
unitcopy	(*(struct),*(struct))->(void)
(	O
&	O
saveunit	struct
,	O
&	O
arbunit	struct
)	O
;	O
unitcopy	(*(struct),*(struct))->(void)
(	O
&	O
theunit	*(struct)
,	O
&	O
resultunit	struct
)	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
&	O
resultunit	struct
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
arbunit	struct
)	O
;	O
}	O
if	O
(	O
!	O
errors	int
[	O
0	int
]	O
&&	O
errcount	int
==	O
3	int
)	O
{	O
printf	O
(	O
"Warning: function '%s(%s)' defined as '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
param	O
,	O
infunc	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
printf	O
(	O
"         appears to require a dimensionless argument, 'units' keyword not given\n"	*(char)
)	O
;	O
indent	*(char)
=	O
"         "	*(char)
;	O
}	O
else	O
if	O
(	O
errcount	int
==	O
MAXPOWERTOCHECK	int
)	O
{	O
printf	O
(	O
"Error or missing 'units' keyword in definion %s(%s) as '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
param	O
,	O
infunc	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
indent	*(char)
=	O
"      "	*(char)
;	O
}	O
else	O
if	O
(	O
errcount	int
)	O
{	O
printf	O
(	O
"Warning: function '%s(%s)' defined as '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
param	O
,	O
infunc	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
printf	O
(	O
"         failed for some test inputs:\n"	*(char)
)	O
;	O
indent	*(char)
=	O
"         "	*(char)
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXPOWERTOCHECK	int
;	O
i	int
++	O
)	O
if	O
(	O
errors	int
[	O
i	int
]	O
)	O
{	O
lastchar	O
(	O
unittext	array(char)
)	O
=	O
'0'	O
+	O
i	int
;	O
printf	O
(	O
"%s%s("	*(char)
,	O
indent	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
printf	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
factor	double
)	O
;	O
printf	O
(	O
"%s): %s\n"	*(char)
,	O
unittext	array(char)
,	O
errormsg	array(*(char))
[	O
errors	int
[	O
i	int
]	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
completereduce	(*(struct))->(int)
(	O
&	O
theunit	*(struct)
)	O
)	O
{	O
printf	O
(	O
"Definition %s(%s) as '%s' is irreducible\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
forward	O
.	O
param	O
,	O
infunc	*(struct)
->	O
forward	O
.	O
def	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
infunc	*(struct)
->	O
inverse	int
.	O
def	*(char)
)	O
)	O
{	O
printf	O
(	O
"Warning: no inverse for function '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
err	int
=	O
evalfunc	(*(struct),*(struct),int,int)->(int)
(	O
&	O
theunit	*(struct)
,	O
infunc	*(struct)
,	O
INVERSE	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
printf	O
(	O
"Error in inverse ~%s(%s) as '%s':\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
,	O
infunc	*(struct)
->	O
inverse	int
.	O
param	O
,	O
infunc	*(struct)
->	O
inverse	int
.	O
def	*(char)
)	O
;	O
printf	O
(	O
"      %s\n"	*(char)
,	O
errormsg	array(*(char))
[	O
err	int
]	O
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
divunit	(*(struct),*(struct))->(int)
(	O
&	O
theunit	*(struct)
,	O
&	O
saveunit	struct
)	O
;	O
if	O
(	O
unit2num	(*(struct))->(int)
(	O
&	O
theunit	*(struct)
)	O
||	O
fabs	O
(	O
theunit	*(struct)
.	O
factor	double
-	O
1	int
)	O
>	O
1e-12	int
)	O
printf	O
(	O
"Inverse is not the inverse for function '%s'\n"	*(char)
,	O
infunc	*(struct)
->	O
name	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
theunit	*(struct)
)	O
;	O
}	O
struct	O
namedef	struct(*(char),*(char))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
def	*(char)
;	O
}	O
;	O
void	O
addtolist	(*(struct),*(char),*(char),*(char),*(char),*(*(struct(*(char),*(char)))),*(int),*(int),*(int),int)->(void)
(	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
char	O
*	O
searchstring	*(char)
,	O
char	O
*	O
rname	*(char)
,	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
def	*(char)
,	O
struct	O
namedef	struct(*(char),*(char))
*	O
*	O
list	*(char)
,	O
int	O
*	O
listsize	*(int)
,	O
int	O
*	O
maxnamelen	*(int)
,	O
int	O
*	O
count	*(int)
,	O
int	O
searchtype	int
)	O
{	O
struct	O
unittype	O
want	struct
;	O
int	O
len	int
=	O
0	int
;	O
int	O
keepit	int
=	O
0	int
;	O
if	O
(	O
!	O
name	*(char)
)	O
return	O
;	O
if	O
(	O
searchtype	int
==	O
CONFORMABLE	int
)	O
{	O
initializeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
if	O
(	O
!	O
parseunit	()->(int)
(	O
&	O
want	struct
,	O
name	*(char)
,	O
0	int
,	O
0	int
)	O
&&	O
!	O
completereduce	(*(struct))->(int)
(	O
&	O
want	struct
)	O
)	O
keepit	int
=	O
!	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
have	*(struct)
,	O
&	O
want	struct
,	O
ignore_dimless	(*(char))->(int)
)	O
;	O
}	O
else	O
if	O
(	O
searchtype	int
==	O
TEXTMATCH	int
)	O
{	O
keepit	int
=	O
(	O
strstr	O
(	O
rname	*(char)
,	O
searchstring	*(char)
)	O
!=	O
NULL	O
)	O
;	O
}	O
if	O
(	O
keepit	int
)	O
{	O
if	O
(	O
*	O
count	*(int)
==	O
*	O
listsize	*(int)
)	O
{	O
*	O
listsize	*(int)
+=	O
100	int
;	O
*	O
list	*(char)
=	O
(	O
struct	O
namedef	struct(*(char),*(char))
*	O
)	O
realloc	O
(	O
*	O
list	*(char)
,	O
*	O
listsize	*(int)
*	O
sizeof	O
(	O
struct	O
namedef	struct(*(char),*(char))
)	O
)	O
;	O
if	O
(	O
!	O
*	O
list	*(char)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: memory allocation error (addtolist)\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
(	O
*	O
list	*(char)
)	O
[	O
*	O
count	*(int)
]	O
.	O
name	*(char)
=	O
rname	*(char)
;	O
if	O
(	O
strchr	O
(	O
def	*(char)
,	O
PRIMITIVECHAR	char
)	O
)	O
(	O
*	O
list	*(char)
)	O
[	O
*	O
count	*(int)
]	O
.	O
def	*(char)
=	O
"<primitive unit>"	*(char)
;	O
else	O
(	O
*	O
list	*(char)
)	O
[	O
*	O
count	*(int)
]	O
.	O
def	*(char)
=	O
def	*(char)
;	O
(	O
*	O
count	*(int)
)	O
++	O
;	O
len	int
=	O
strwidth	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
*	O
maxnamelen	*(int)
)	O
*	O
maxnamelen	*(int)
=	O
len	int
;	O
}	O
if	O
(	O
searchtype	int
==	O
CONFORMABLE	int
)	O
freeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
}	O
int	O
compnd	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	double
,	O
const	O
void	O
*	O
b	double
)	O
{	O
return	O
strcmp	O
(	O
(	O
(	O
struct	O
namedef	struct(*(char),*(char))
*	O
)	O
a	double
)	O
->	O
name	*(char)
,	O
(	O
(	O
struct	O
namedef	struct(*(char),*(char))
*	O
)	O
b	double
)	O
->	O
name	*(char)
)	O
;	O
}	O
int	O
screensize	()->(int)
(	O
)	O
{	O
return	O
20	int
;	O
}	O
void	O
tryallunits	(*(struct),*(char))->(void)
(	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
char	O
*	O
searchstring	*(char)
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
struct	O
namedef	struct(*(char),*(char))
*	O
list	*(char)
;	O
int	O
listsize	*(int)
,	O
maxnamelen	*(int)
,	O
count	*(int)
;	O
struct	O
func	*(struct)
*	O
funcptr	*(struct)
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
int	O
i	int
,	O
j	int
,	O
searchtype	int
;	O
FILE	O
*	O
outfile	*(int)
;	O
char	O
*	O
seploc	*(char)
,	O
*	O
firstunit	*(char)
;	O
list	*(char)
=	O
(	O
struct	O
namedef	struct(*(char),*(char))
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
100	int
*	O
sizeof	O
(	O
struct	O
namedef	struct(*(char),*(char))
)	O
,	O
"(tryallunits)"	*(char)
)	O
;	O
listsize	*(int)
=	O
100	int
;	O
maxnamelen	*(int)
=	O
0	int
;	O
count	*(int)
=	O
0	int
;	O
if	O
(	O
have	*(struct)
)	O
searchtype	int
=	O
CONFORMABLE	int
;	O
else	O
{	O
if	O
(	O
!	O
searchstring	*(char)
)	O
searchstring	*(char)
=	O
""	*(char)
;	O
searchtype	int
=	O
TEXTMATCH	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
i	int
]	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
addtolist	(*(struct),*(char),*(char),*(char),*(char),*(*(struct(*(char),*(char)))),*(int),*(int),*(int),int)->(void)
(	O
have	*(struct)
,	O
searchstring	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
,	O
&	O
list	*(char)
,	O
&	O
listsize	*(int)
,	O
&	O
maxnamelen	*(int)
,	O
&	O
count	*(int)
,	O
searchtype	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
funcptr	*(struct)
=	O
ftab	array(*(struct))
[	O
i	int
]	O
;	O
funcptr	*(struct)
;	O
funcptr	*(struct)
=	O
funcptr	*(struct)
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
if	O
(	O
funcptr	*(struct)
->	O
table	O
)	O
addtolist	(*(struct),*(char),*(char),*(char),*(char),*(*(struct(*(char),*(char)))),*(int),*(int),*(int),int)->(void)
(	O
have	*(struct)
,	O
searchstring	*(char)
,	O
funcptr	*(struct)
->	O
name	*(char)
,	O
funcptr	*(struct)
->	O
tableunit	*(char)
,	O
"<piecewise linear>"	*(char)
,	O
&	O
list	*(char)
,	O
&	O
listsize	*(int)
,	O
&	O
maxnamelen	*(int)
,	O
&	O
count	*(int)
,	O
searchtype	int
)	O
;	O
else	O
addtolist	(*(struct),*(char),*(char),*(char),*(char),*(*(struct(*(char),*(char)))),*(int),*(int),*(int),int)->(void)
(	O
have	*(struct)
,	O
searchstring	*(char)
,	O
funcptr	*(struct)
->	O
name	*(char)
,	O
funcptr	*(struct)
->	O
inverse	int
.	O
dimen	*(char)
,	O
"<nonlinear>"	*(char)
,	O
&	O
list	*(char)
,	O
&	O
listsize	*(int)
,	O
&	O
maxnamelen	*(int)
,	O
&	O
count	*(int)
,	O
searchtype	int
)	O
;	O
}	O
for	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
firstalias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
firstunit	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
seploc	*(char)
=	O
strchr	O
(	O
firstunit	*(char)
,	O
UNITSEPCHAR	char
)	O
;	O
*	O
seploc	*(char)
=	O
0	int
;	O
addtolist	(*(struct),*(char),*(char),*(char),*(char),*(*(struct(*(char),*(char)))),*(int),*(int),*(int),int)->(void)
(	O
have	*(struct)
,	O
searchstring	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
,	O
firstunit	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
,	O
&	O
list	*(char)
,	O
&	O
listsize	*(int)
,	O
&	O
maxnamelen	*(int)
,	O
&	O
count	*(int)
,	O
searchtype	int
)	O
;	O
free	()->(int)
(	O
firstunit	*(char)
)	O
;	O
}	O
qsort	()->(int)
(	O
list	*(char)
,	O
count	*(int)
,	O
sizeof	O
(	O
struct	O
namedef	struct(*(char),*(char))
)	O
,	O
compnd	(*(void),*(void))->(int)
)	O
;	O
outfile	*(int)
=	O
0	int
;	O
if	O
(	O
count	*(int)
==	O
0	int
)	O
puts	()->(int)
(	O
"No matching units found."	*(char)
)	O
;	O
signal	()->(int)
(	O
SIGPIPE	O
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
count	*(int)
>	O
screensize	()->(int)
(	O
)	O
)	O
{	O
outfile	*(int)
=	O
popen	()->(int)
(	O
pager	*(char)
,	O
"w"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
outfile	*(int)
)	O
outfile	*(int)
=	O
stdout	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	*(int)
;	O
i	int
++	O
)	O
{	O
fputs	()->(int)
(	O
list	*(char)
[	O
i	int
]	O
.	O
name	*(char)
,	O
outfile	*(int)
)	O
;	O
for	O
(	O
j	int
=	O
strwidth	(*(char))->(int)
(	O
list	*(char)
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
j	int
<=	O
maxnamelen	*(int)
;	O
j	int
++	O
)	O
putc	()->(int)
(	O
' '	O
,	O
outfile	*(int)
)	O
;	O
tightprint	(*(int),*(char))->(void)
(	O
outfile	*(int)
,	O
list	*(char)
[	O
i	int
]	O
.	O
def	*(char)
)	O
;	O
fputc	()->(int)
(	O
'\n'	O
,	O
outfile	*(int)
)	O
;	O
}	O
if	O
(	O
outfile	*(int)
!=	O
stdout	O
)	O
pclose	()->(int)
(	O
outfile	*(int)
)	O
;	O
signal	()->(int)
(	O
SIGPIPE	O
,	O
SIG_DFL	O
)	O
;	O
}	O
void	O
getuser_noreadline	(*(*(char)),*(int),*(char))->(void)
(	O
char	O
*	O
*	O
buffer	*(char)
,	O
int	O
*	O
bufsize	*(int)
,	O
const	O
char	O
*	O
query	*(char)
)	O
{	O
int	O
valid	*(char)
=	O
0	int
;	O
while	O
(	O
!	O
valid	*(char)
)	O
{	O
fputs	()->(int)
(	O
query	*(char)
,	O
stdout	O
)	O
;	O
if	O
(	O
!	O
fgetslong	(*(*(char)),*(int),*(int),*(int))->(*(char))
(	O
buffer	*(char)
,	O
bufsize	*(int)
,	O
stdin	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
)	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
replacectrlchars	(*(char))->(void)
(	O
*	O
buffer	*(char)
)	O
;	O
valid	*(char)
=	O
strwidth	(*(char))->(int)
(	O
*	O
buffer	*(char)
)	O
>=	O
0	int
;	O
if	O
(	O
!	O
valid	*(char)
)	O
printf	O
(	O
"Error: %s\n"	*(char)
,	O
invalid_utf8	*(char)
)	O
;	O
}	O
}	O
int	O
checkcwd	(*(char))->(int)
(	O
char	O
*	O
file	*(char)
)	O
{	O
FILE	O
*	O
fp	O
;	O
char	O
*	O
p	int
;	O
fp	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	O
)	O
{	O
fclose	()->(int)
(	O
fp	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
getprogramname	(*(char))->(*(char))
(	O
char	O
*	O
path	*(char)
)	O
{	O
size_t	O
proglen	O
;	O
char	O
*	O
p	int
;	O
path	*(char)
=	O
pathend	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
proglen	O
=	O
strlen	O
(	O
path	*(char)
)	O
;	O
if	O
(	O
(	O
p	int
=	O
strrchr	O
(	O
path	*(char)
,	O
'.'	O
)	O
)	O
&&	O
isexe	O
(	O
p	int
)	O
)	O
proglen	O
-=	O
4	int
;	O
return	O
dupnstr	(*(char),int)->(*(char))
(	O
path	*(char)
,	O
proglen	O
)	O
;	O
}	O
char	O
*	O
getprogdir	(*(char),*(*(char)))->(*(char))
(	O
char	O
*	O
progname	*(char)
,	O
char	O
*	O
*	O
fullprogname	*(char)
)	O
{	O
char	O
*	O
progdir	*(char)
=	O
NULL	O
;	O
char	O
*	O
p	int
;	O
if	O
(	O
!	O
progdir	*(char)
&&	O
(	O
isfullpath	(*(char))->(int)
(	O
progname	*(char)
)	O
||	O
hasdirsep	O
(	O
progname	*(char)
)	O
)	O
)	O
progdir	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
progname	*(char)
)	O
;	O
if	O
(	O
!	O
progdir	*(char)
)	O
{	O
char	O
*	O
env	*(char)
;	O
env	*(char)
=	O
getenv	()->(int)
(	O
"PATH"	*(char)
)	O
;	O
if	O
(	O
env	*(char)
)	O
{	O
char	O
*	O
direc	*(char)
,	O
*	O
direc_end	*(char)
,	O
*	O
pathname	*(char)
;	O
int	O
len	int
;	O
FILE	O
*	O
fp	O
;	O
pathname	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
env	*(char)
)	O
+	O
strlen	O
(	O
progname	*(char)
)	O
+	O
strlen	O
(	O
EXE_EXT	*(char)
)	O
+	O
2	int
,	O
"(getprogdir)"	*(char)
)	O
;	O
direc	*(char)
=	O
env	*(char)
;	O
while	O
(	O
direc	*(char)
)	O
{	O
direc_end	*(char)
=	O
strchr	O
(	O
direc	*(char)
,	O
PATHSEP	char
)	O
;	O
if	O
(	O
!	O
direc_end	*(char)
)	O
len	int
=	O
strlen	O
(	O
direc	*(char)
)	O
;	O
else	O
len	int
=	O
direc_end	*(char)
-	O
direc	*(char)
;	O
strncpy	O
(	O
pathname	*(char)
,	O
direc	*(char)
,	O
len	int
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
pathname	*(char)
[	O
len	int
++	O
]	O
=	O
'/'	O
;	O
strcpy	O
(	O
pathname	*(char)
+	O
len	int
,	O
progname	*(char)
)	O
;	O
fp	O
=	O
fopen	()->(int)
(	O
pathname	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	O
)	O
{	O
progdir	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
pathname	*(char)
)	O
;	O
break	O
;	O
}	O
direc	*(char)
=	O
direc_end	*(char)
;	O
if	O
(	O
direc	*(char)
)	O
direc	*(char)
++	O
;	O
}	O
free	()->(int)
(	O
pathname	*(char)
)	O
;	O
if	O
(	O
fp	O
)	O
fclose	()->(int)
(	O
fp	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
progdir	*(char)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot find program directory\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
*	O
fullprogname	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
progdir	*(char)
)	O
;	O
p	int
=	O
pathend	(*(char))->(*(char))
(	O
progdir	*(char)
)	O
;	O
*	O
p	int
=	O
'\0'	O
;	O
return	O
progdir	*(char)
;	O
}	O
char	O
*	O
getdatadir	()->(*(char))
(	O
)	O
{	O
int	O
progdirlen	int
;	O
char	O
*	O
p	int
;	O
progdirlen	int
=	O
strlen	O
(	O
progdir	*(char)
)	O
;	O
datadir	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
progdirlen	int
+	O
strlen	O
(	O
DATADIR	*(char)
)	O
+	O
2	int
,	O
"(getdatadir)"	*(char)
)	O
;	O
strcpy	O
(	O
datadir	*(char)
,	O
progdir	*(char)
)	O
;	O
if	O
(	O
isdirsep	O
(	O
progdir	*(char)
[	O
progdirlen	int
-	O
1	int
]	O
)	O
)	O
datadir	*(char)
[	O
progdirlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
p	int
=	O
pathend	(*(char))->(*(char))
(	O
datadir	*(char)
)	O
;	O
if	O
(	O
(	O
strlen	O
(	O
p	int
)	O
==	O
3	int
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
0	int
]	O
)	O
==	O
'b'	O
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
1	int
]	O
)	O
==	O
'i'	O
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
2	int
]	O
)	O
==	O
'n'	O
)	O
)	O
{	O
p	int
=	O
DATADIR	*(char)
;	O
while	O
(	O
*	O
p	int
==	O
'.'	O
)	O
p	int
++	O
;	O
if	O
(	O
isdirsep	O
(	O
*	O
p	int
)	O
)	O
p	int
++	O
;	O
strcpy	O
(	O
pathend	(*(char))->(*(char))
(	O
datadir	*(char)
)	O
,	O
p	int
)	O
;	O
return	O
datadir	*(char)
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
char	O
*	O
findlocalemap	(int)->(*(char))
(	O
int	O
checkonly	int
)	O
{	O
FILE	O
*	O
map	O
=	O
NULL	O
;	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
char	O
*	O
file	*(char)
;	O
file	*(char)
=	O
getenv	()->(int)
(	O
"UNITSLOCALEMAP"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
&&	O
*	O
file	*(char)
)	O
{	O
map	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
map	O
)	O
{	O
if	O
(	O
!	O
checkonly	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open locale map '%s'\n  specified in UNITSLOCALEMAP environment variable. "	*(char)
,	O
progname	*(char)
,	O
file	*(char)
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
else	O
filename	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
file	*(char)
=	O
LOCALEMAP	O
;	O
map	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
map	O
)	O
filename	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
map	O
&&	O
!	O
progdir	*(char)
)	O
{	O
if	O
(	O
!	O
checkonly	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot find locale map--program directory not set\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
progdir	*(char)
)	O
+	O
strlen	O
(	O
file	*(char)
)	O
+	O
2	int
,	O
"(findlocalemap)"	*(char)
)	O
;	O
strcpy	O
(	O
filename	*(char)
,	O
progdir	*(char)
)	O
;	O
strcat	O
(	O
filename	*(char)
,	O
file	*(char)
)	O
;	O
map	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
map	O
&&	O
!	O
emptystr	O
(	O
DATADIR	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
datadir	*(char)
)	O
datadir	*(char)
=	O
getdatadir	()->(*(char))
(	O
)	O
;	O
if	O
(	O
datadir	*(char)
)	O
{	O
if	O
(	O
filename	*(char)
)	O
free	()->(int)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
datadir	*(char)
)	O
+	O
strlen	O
(	O
DATADIR	*(char)
)	O
+	O
strlen	O
(	O
file	*(char)
)	O
+	O
2	int
,	O
"(findlocalemap)"	*(char)
)	O
;	O
strcpy	O
(	O
filename	*(char)
,	O
datadir	*(char)
)	O
;	O
strcat	O
(	O
filename	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	O
(	O
filename	*(char)
,	O
file	*(char)
)	O
;	O
map	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
if	O
(	O
filename	*(char)
)	O
free	()->(int)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
unitsfiles	array(*(char))
[	O
0	int
]	O
)	O
+	O
strlen	O
(	O
file	*(char)
)	O
+	O
2	int
,	O
"(findlocalemap)"	*(char)
)	O
;	O
strcpy	O
(	O
filename	*(char)
,	O
unitsfiles	array(*(char))
[	O
0	int
]	O
)	O
;	O
strcpy	O
(	O
pathend	(*(char))->(*(char))
(	O
filename	*(char)
)	O
,	O
file	*(char)
)	O
;	O
map	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
}	O
if	O
(	O
map	O
)	O
{	O
fclose	()->(int)
(	O
map	O
)	O
;	O
return	O
filename	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
filename	*(char)
)	O
free	()->(int)
(	O
filename	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
char	O
*	O
findunitsfile	(int)->(*(char))
(	O
int	O
noerrmsg	int
)	O
{	O
FILE	O
*	O
testfile	O
=	O
0	int
;	O
char	O
*	O
file	*(char)
;	O
file	*(char)
=	O
getenv	()->(int)
(	O
"UNITSFILE"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
&&	O
*	O
file	*(char)
)	O
{	O
testfile	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open units file '%s' in environment variable UNITSFILE.  "	*(char)
,	O
progname	*(char)
,	O
file	*(char)
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
isfullpath	(*(char))->(int)
(	O
UNITSFILE	O
)	O
)	O
{	O
file	*(char)
=	O
UNITSFILE	O
;	O
testfile	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open units data file '%s'.  "	*(char)
,	O
progname	*(char)
,	O
UNITSFILE	O
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
!	O
progdir	*(char)
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open units file '%s' and cannot find program directory.\n"	*(char)
,	O
progname	*(char)
,	O
UNITSFILE	O
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
testfile	O
)	O
{	O
file	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
progdir	*(char)
)	O
+	O
strlen	O
(	O
UNITSFILE	O
)	O
+	O
1	int
,	O
"(findunitsfile)"	*(char)
)	O
;	O
strcpy	O
(	O
file	*(char)
,	O
progdir	*(char)
)	O
;	O
strcat	O
(	O
file	*(char)
,	O
UNITSFILE	O
)	O
;	O
testfile	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
free	()->(int)
(	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
!	O
emptystr	O
(	O
DATADIR	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
datadir	*(char)
)	O
datadir	*(char)
=	O
getdatadir	()->(*(char))
(	O
)	O
;	O
if	O
(	O
datadir	*(char)
)	O
{	O
file	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
datadir	*(char)
)	O
+	O
strlen	O
(	O
UNITSFILE	O
)	O
+	O
2	int
,	O
"(findunitsfile)"	*(char)
)	O
;	O
strcpy	O
(	O
file	*(char)
,	O
datadir	*(char)
)	O
;	O
strcat	O
(	O
file	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	O
(	O
file	*(char)
,	O
UNITSFILE	O
)	O
;	O
testfile	O
=	O
fopen	()->(int)
(	O
file	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
free	()->(int)
(	O
file	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot find units file '%s'\n"	*(char)
,	O
progname	*(char)
,	O
UNITSFILE	O
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
fclose	()->(int)
(	O
testfile	O
)	O
;	O
return	O
file	*(char)
;	O
}	O
}	O
char	O
*	O
personalfile	(*(char),*(char),int,*(int))->(*(char))
(	O
const	O
char	O
*	O
envname	*(char)
,	O
const	O
char	O
*	O
basename	*(char)
,	O
int	O
checkonly	int
,	O
int	O
*	O
exists	*(int)
)	O
{	O
FILE	O
*	O
testfile	O
=	O
0	int
;	O
char	O
*	O
homedir	*(char)
,	O
*	O
filename	*(char)
=	O
0	int
;	O
*	O
exists	*(int)
=	O
0	int
;	O
if	O
(	O
envname	*(char)
)	O
filename	*(char)
=	O
getenv	()->(int)
(	O
envname	*(char)
)	O
;	O
if	O
(	O
filename	*(char)
&&	O
*	O
filename	*(char)
)	O
{	O
testfile	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
testfile	O
)	O
{	O
fclose	()->(int)
(	O
testfile	O
)	O
;	O
*	O
exists	*(int)
=	O
1	int
;	O
return	O
filename	*(char)
;	O
}	O
if	O
(	O
checkonly	int
)	O
return	O
filename	*(char)
;	O
else	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open file '%s' specified in %s environment variable. "	*(char)
,	O
progname	*(char)
,	O
filename	*(char)
,	O
envname	*(char)
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
homedir	*(char)
=	O
getenv	()->(int)
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
homedir	*(char)
)	O
{	O
filename	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
homedir	*(char)
)	O
+	O
strlen	O
(	O
basename	*(char)
)	O
+	O
2	int
,	O
"(personalfile)"	*(char)
)	O
;	O
strcpy	O
(	O
filename	*(char)
,	O
homedir	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
strcat	O
(	O
filename	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	O
(	O
filename	*(char)
,	O
basename	*(char)
)	O
;	O
testfile	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
testfile	O
)	O
{	O
fclose	()->(int)
(	O
testfile	O
)	O
;	O
*	O
exists	*(int)
=	O
1	int
;	O
return	O
filename	*(char)
;	O
}	O
if	O
(	O
checkonly	int
)	O
return	O
filename	*(char)
;	O
else	O
{	O
if	O
(	O
errno	O
==	O
EACCES	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot read file '%s'.  "	*(char)
,	O
progname	*(char)
,	O
filename	*(char)
)	O
;	O
perror	()->(int)
(	O
0	int
)	O
;	O
}	O
free	()->(int)
(	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
void	O
usage	()->(void)
(	O
)	O
{	O
char	O
*	O
unitsfile	*(char)
;	O
unitsfile	*(char)
=	O
findunitsfile	(int)->(*(char))
(	O
1	int
)	O
;	O
printf	O
(	O
"\nUsage: %s [options] ['from-unit' 'to-unit']\n"	*(char)
,	O
progname	*(char)
)	O
;	O
printf	O
(	O
"\nOptions:\n    -h, --help           show this help and exit\n    -c, --check          check that all units reduce to primitive units\n        --check-verbose  like --check, but lists units as they are checked\n        --verbose-check    so you can find units that cause endless loops\n    -d, --digits         show output to specified number of digits (default: %d)\n    -e, --exponential    exponential format output\n    -f, --file           specify a units data file (-f '' loads default file)\n"	*(char)
,	O
DEFAULTPRECISION	int
)	O
;	O
printf	O
(	O
"    -L, --log            specify a file to log conversions\n    -l, --locale         specify a desired locale\n    -m, --minus          make - into a subtraction operator (default)\n        --oldstar        use old '*' precedence, higher than '/'\n        --newstar        use new '*' precedence, equal to '/'\n    -n, --nolists        disable conversion to unit lists\n    -S, --show-factor    show non-unity factor before 1|x in multi-unit output\n    -o, --output-format  specify printf numeric output format (default: %%.%d%c)\n    -p, --product        make '-' into a product operator\n    -q, --quiet          suppress prompting\n        --silent         same as --quiet\n    -s, --strict         suppress reciprocal unit conversion (e.g. Hz<->s)\n    -v, --verbose        show slightly more verbose output\n        --compact        suppress printing of tab, '*', and '/' character\n    -1, --one-line       suppress the second line of output\n    -t, --terse          terse output (--strict --compact --quiet --one-line)\n    -r, --round          round last element of unit list output to an integer\n    -U, --unitsfile      show units data filename and exit\n    -u, --units          specify a CGS unit system (gauss[ian]|esu|emu)\n    -V, --version        show version, data filenames (with -t: version only)\n    -I, --info           show version, files, and program properties\n"	*(char)
,	O
DEFAULTTYPE	char
,	O
DEFAULTPRECISION	int
)	O
;	O
if	O
(	O
!	O
unitsfile	*(char)
)	O
printf	O
(	O
"Units data file '%s' not found.\n\n"	*(char)
,	O
UNITSFILE	O
)	O
;	O
else	O
printf	O
(	O
"To learn about the available units look in '%s'\n\n"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
puts	()->(int)
(	O
"Report bugs to adrianm@gnu.org.\n\n"	*(char)
)	O
;	O
}	O
void	O
helpmsg	()->(void)
(	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"\nTry '%s --help' for more information.\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
void	O
printversion	()->(void)
(	O
)	O
{	O
int	O
exists	*(int)
;	O
char	O
*	O
unitsfile	*(char)
,	O
*	O
localemap	*(char)
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
0	int
)	O
{	O
printf	O
(	O
"GNU Units version %s\n"	*(char)
,	O
VERSION	*(char)
)	O
;	O
return	O
;	O
}	O
printf	O
(	O
"GNU Units version %s\n%s, %s, locale %s\n"	*(char)
,	O
VERSION	*(char)
,	O
RVERSTR	*(char)
,	O
UTF8VERSTR	*(char)
,	O
mylocale	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
fullprogname	*(char)
)	O
getprogdir	(*(char),*(*(char)))->(*(char))
(	O
progname	*(char)
,	O
&	O
fullprogname	*(char)
)	O
;	O
if	O
(	O
fullprogname	*(char)
)	O
printf	O
(	O
"\n%s program is %s\n"	*(char)
,	O
progname	*(char)
,	O
fullprogname	*(char)
)	O
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
unitsfile	*(char)
=	O
getenv	()->(int)
(	O
"UNITSFILE"	*(char)
)	O
;	O
if	O
(	O
unitsfile	*(char)
)	O
printf	O
(	O
"Environment variable UNITSFILE set to '%s'\n"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
else	O
puts	()->(int)
(	O
"Environment variable UNITSFILE not set"	*(char)
)	O
;	O
if	O
(	O
isfullpath	(*(char))->(int)
(	O
UNITSFILE	O
)	O
)	O
printf	O
(	O
"Default units data file is '%s'\n"	*(char)
,	O
UNITSFILE	O
)	O
;	O
else	O
printf	O
(	O
"Default units data file is '%s';\n  %s will search for this file\n"	*(char)
,	O
UNITSFILE	O
,	O
progname	*(char)
)	O
;	O
}	O
unitsfile	*(char)
=	O
findunitsfile	(int)->(*(char))
(	O
1	int
)	O
;	O
if	O
(	O
unitsfile	*(char)
&&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
&&	O
!	O
isfullpath	(*(char))->(int)
(	O
UNITSFILE	O
)	O
)	O
printf	O
(	O
"Found data file '%s'\n"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
else	O
if	O
(	O
unitsfile	*(char)
)	O
printf	O
(	O
"Units data file is '%s'\n"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
else	O
puts	()->(int)
(	O
"*** Units data file not found ***"	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
unitsfile	*(char)
=	O
getenv	()->(int)
(	O
HOME_UNITS_ENV	*(char)
)	O
;	O
if	O
(	O
unitsfile	*(char)
)	O
printf	O
(	O
"Environment variable %s set to '%s'\n"	*(char)
,	O
HOME_UNITS_ENV	*(char)
,	O
unitsfile	*(char)
)	O
;	O
else	O
printf	O
(	O
"Environment variable %s not set\n"	*(char)
,	O
HOME_UNITS_ENV	*(char)
)	O
;	O
}	O
unitsfile	*(char)
=	O
personalfile	(*(char),*(char),int,*(int))->(*(char))
(	O
HOME_UNITS_ENV	*(char)
,	O
homeunitsfile	*(char)
,	O
1	int
,	O
&	O
exists	*(int)
)	O
;	O
if	O
(	O
unitsfile	*(char)
)	O
{	O
printf	O
(	O
"Personal units data file is '%s'"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
if	O
(	O
!	O
exists	*(int)
)	O
puts	()->(int)
(	O
"\n  (file does not exist)"	*(char)
)	O
;	O
else	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
}	O
else	O
puts	()->(int)
(	O
"Personal units data file not found: no home directory"	*(char)
)	O
;	O
printf	O
(	O
"\n\n%s\n\n"	*(char)
,	O
LICENSE	*(char)
)	O
;	O
}	O
void	O
showunitsfile	()->(void)
(	O
)	O
{	O
char	O
*	O
unitsfile	*(char)
;	O
unitsfile	*(char)
=	O
findunitsfile	(int)->(*(char))
(	O
1	int
)	O
;	O
if	O
(	O
unitsfile	*(char)
)	O
printf	O
(	O
"%s\n"	*(char)
,	O
unitsfile	*(char)
)	O
;	O
else	O
puts	()->(int)
(	O
"Units data file not found"	*(char)
)	O
;	O
}	O
char	O
*	O
shortoptions	*(char)
=	O
"VIUu:vqechSstf:o:d:mnpr1l:L:"	*(char)
;	O
struct	O
option	O
longoptions	int
[	O
]	O
=	O
{	O
{	O
"check"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
,	O
1	int
}	O
,	O
{	O
"check-verbose"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
,	O
2	int
}	O
,	O
{	O
"compact"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
,	O
0	int
}	O
,	O
{	O
"digits"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"exponential"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"file"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"info"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"locale"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"log"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"minus"	*(char)
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
minusminus	O
,	O
1	int
}	O
,	O
{	O
"newstar"	*(char)
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
oldstar	O
,	O
0	int
}	O
,	O
{	O
"nolists"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"oldstar"	*(char)
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
oldstar	O
,	O
1	int
}	O
,	O
{	O
"one-line"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
oneline	int
,	O
1	int
}	O
,	O
{	O
"output-format"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"product"	*(char)
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
minusminus	O
,	O
0	int
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
,	O
1	int
}	O
,	O
{	O
"round"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"show-factor"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
,	O
1	int
}	O
,	O
{	O
"strict"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
strictconvert	int
,	O
1	int
}	O
,	O
{	O
"terse"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"unitsfile"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"units"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
,	O
2	int
}	O
,	O
{	O
"verbose-check"	*(char)
,	O
no_argument	O
,	O
&	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
,	O
2	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
processargs	(int,*(*(char)),*(*(char)),*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
*	O
from	*(*(char))
,	O
char	O
*	O
*	O
to	*(*(char))
)	O
{	O
extern	O
char	O
*	O
optarg	*(char)
;	O
extern	O
int	O
optind	int
;	O
int	O
optchar	int
,	O
optindex	int
;	O
int	O
ind	int
;	O
int	O
doprintversion	int
=	O
0	int
;	O
char	O
*	O
unitsys	*(char)
=	O
0	int
;	O
while	O
(	O
-	O
1	int
!=	O
(	O
optchar	int
=	O
getopt_long	()->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
shortoptions	*(char)
,	O
longoptions	int
,	O
&	O
optindex	int
)	O
)	O
)	O
{	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'm'	O
:	O
parserflags	struct
.	O
minusminus	O
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
parserflags	struct
.	O
minusminus	O
=	O
0	int
;	O
break	O
;	O
case	O
't'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
oneline	int
=	O
1	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
=	O
1	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
strictconvert	int
=	O
1	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
checksigdigits	(*(char))->(int)
(	O
optarg	*(char)
)	O
<	O
0	int
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
'e'	O
:	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
=	O
NULL	O
;	O
num_format	struct(*(char),int,int,char)
.	O
type	char
=	O
'e'	O
;	O
break	O
;	O
case	O
'o'	O
:	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'c'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
for	O
(	O
ind	int
=	O
0	int
;	O
unitsfiles	array(*(char))
[	O
ind	int
]	O
;	O
ind	int
++	O
)	O
;	O
if	O
(	O
ind	int
==	O
MAXFILES	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"At most %d -f specifications are allowed\n"	*(char)
,	O
MAXFILES	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
if	O
(	O
optarg	*(char)
&&	O
*	O
optarg	*(char)
)	O
unitsfiles	array(*(char))
[	O
ind	int
]	O
=	O
optarg	*(char)
;	O
else	O
{	O
unitsfiles	array(*(char))
[	O
ind	int
]	O
=	O
findunitsfile	(int)->(*(char))
(	O
0	int
)	O
;	O
if	O
(	O
!	O
unitsfiles	array(*(char))
[	O
ind	int
]	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
unitsfiles	array(*(char))
[	O
ind	int
+	O
1	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
logfilename	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'l'	O
:	O
mylocale	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'n'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitlists	int
=	O
0	int
;	O
break	O
;	O
case	O
'q'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
round	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
showfactor	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
strictconvert	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
2	int
;	O
break	O
;	O
case	O
'1'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
oneline	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
2	int
;	O
case	O
'V'	O
:	O
doprintversion	int
=	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
showunitsfile	()->(void)
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
unitsys	*(char)
=	O
optarg	*(char)
;	O
for	O
(	O
ind	int
=	O
0	int
;	O
unitsys	*(char)
[	O
ind	int
]	O
;	O
ind	int
++	O
)	O
unitsys	*(char)
[	O
ind	int
]	O
=	O
tolower	O
(	O
unitsys	*(char)
[	O
ind	int
]	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	()->(void)
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
case	O
0	int
:	O
break	O
;	O
case	O
'?'	O
:	O
default	O
:	O
helpmsg	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
doprintversion	int
)	O
{	O
printversion	()->(void)
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
unitsys	*(char)
)	O
setenv	()->(int)
(	O
"UNITS_SYSTEM"	*(char)
,	O
unitsys	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
)	O
{	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Too many arguments (arguments are not allowed with -c).\n"	*(char)
)	O
;	O
helpmsg	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
optind	int
==	O
argc	int
-	O
2	int
)	O
{	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
=	O
1	int
;	O
*	O
from	*(*(char))
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
*	O
to	*(*(char))
=	O
dupstr	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
optind	int
+	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
-	O
1	int
)	O
{	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
=	O
1	int
;	O
*	O
from	*(*(char))
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
*	O
to	*(*(char))
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
-	O
2	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Too many arguments (maybe you need quotes).\n"	*(char)
)	O
;	O
helpmsg	()->(void)
(	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
showpointer	(int)->(void)
(	O
int	O
position	int
)	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
while	O
(	O
position	int
--	O
)	O
putchar	()->(int)
(	O
' '	O
)	O
;	O
puts	()->(int)
(	O
"^"	*(char)
)	O
;	O
}	O
}	O
int	O
processunit	(*(struct),*(char),int)->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
,	O
char	O
*	O
unitstr	*(char)
,	O
int	O
promptlen	int
)	O
{	O
char	O
*	O
errmsg	*(char)
;	O
int	O
errloc	int
,	O
err	int
;	O
char	O
savechar	char
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitlists	int
&&	O
strchr	O
(	O
unitstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
puts	()->(int)
(	O
"Unit list not allowed"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
err	int
=	O
parseunit	()->(int)
(	O
theunit	*(struct)
,	O
unitstr	*(char)
,	O
&	O
errmsg	*(char)
,	O
&	O
errloc	int
)	O
)	O
)	O
{	O
if	O
(	O
promptlen	int
>=	O
0	int
)	O
{	O
if	O
(	O
err	int
!=	O
E_UNKNOWNUNIT	O
||	O
!	O
irreducible	*(char)
)	O
{	O
if	O
(	O
errloc	int
>	O
0	int
)	O
{	O
savechar	char
=	O
unitstr	*(char)
[	O
errloc	int
]	O
;	O
unitstr	*(char)
[	O
errloc	int
]	O
=	O
0	int
;	O
showpointer	(int)->(void)
(	O
promptlen	int
+	O
strwidth	(*(char))->(int)
(	O
unitstr	*(char)
)	O
-	O
1	int
)	O
;	O
unitstr	*(char)
[	O
errloc	int
]	O
=	O
savechar	char
;	O
}	O
else	O
showpointer	(int)->(void)
(	O
promptlen	int
)	O
;	O
}	O
}	O
else	O
printf	O
(	O
"Error in '%s': "	*(char)
,	O
unitstr	*(char)
)	O
;	O
fputs	()->(int)
(	O
errmsg	*(char)
,	O
stdout	O
)	O
;	O
if	O
(	O
err	int
==	O
E_UNKNOWNUNIT	O
&&	O
irreducible	*(char)
)	O
printf	O
(	O
" '%s'"	*(char)
,	O
irreducible	*(char)
)	O
;	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
err	int
=	O
completereduce	(*(struct))->(int)
(	O
theunit	*(struct)
)	O
)	O
)	O
{	O
fputs	()->(int)
(	O
errormsg	array(*(char))
[	O
err	int
]	O
,	O
stdout	O
)	O
;	O
if	O
(	O
err	int
==	O
E_UNKNOWNUNIT	O
)	O
printf	O
(	O
" '%s'"	*(char)
,	O
irreducible	*(char)
)	O
;	O
putchar	()->(int)
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
checkunitlist	(*(char),int)->(int)
(	O
char	O
*	O
unitstr	*(char)
,	O
int	O
promptlen	int
)	O
{	O
struct	O
unittype	O
unit	*(char)
[	O
2	int
]	O
,	O
one	*(*(char))
;	O
char	O
*	O
firstunitstr	*(char)
,	O
*	O
nextunitstr	*(char)
;	O
int	O
unitidx	int
=	O
0	int
;	O
int	O
printerror	int
=	O
promptlen	int
!=	O
NOERRMSG	O
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
one	*(*(char))
)	O
;	O
firstunitstr	*(char)
=	O
unitstr	*(char)
;	O
initializeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
unit	*(char)
+	O
1	int
)	O
;	O
while	O
(	O
unitstr	*(char)
)	O
{	O
if	O
(	O
(	O
nextunitstr	*(char)
=	O
strchr	O
(	O
unitstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
!=	O
0	int
)	O
*	O
nextunitstr	*(char)
=	O
'\0'	O
;	O
if	O
(	O
!	O
unitstr	*(char)
[	O
strspn	O
(	O
unitstr	*(char)
,	O
" "	*(char)
)	O
]	O
)	O
{	O
if	O
(	O
!	O
nextunitstr	*(char)
)	O
{	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
printerror	int
)	O
{	O
showpointer	(int)->(void)
(	O
promptlen	int
)	O
;	O
puts	()->(int)
(	O
"Error: blank unit not allowed"	*(char)
)	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
printerror	int
&&	O
processunit	(*(struct),*(char),int)->(int)
(	O
unit	*(char)
+	O
unitidx	int
,	O
unitstr	*(char)
,	O
promptlen	int
)	O
)	O
||	O
(	O
!	O
printerror	int
&&	O
(	O
parseunit	()->(int)
(	O
unit	*(char)
+	O
unitidx	int
,	O
unitstr	*(char)
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	(*(struct))->(int)
(	O
unit	*(char)
+	O
unitidx	int
)	O
||	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
unit	*(char)
+	O
unitidx	int
,	O
&	O
one	*(*(char))
,	O
ignore_primitive	(*(char))->(int)
)	O
)	O
)	O
)	O
{	O
if	O
(	O
printerror	int
)	O
printf	O
(	O
"Error in unit list entry: %s\n"	*(char)
,	O
unitstr	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
+	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
unitidx	int
==	O
0	int
)	O
unitidx	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
unit	*(char)
,	O
unit	*(char)
+	O
1	int
,	O
ignore_dimless	(*(char))->(int)
)	O
)	O
{	O
if	O
(	O
printerror	int
)	O
{	O
int	O
wasverbose	int
=	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
;	O
FILE	O
*	O
savelog	O
=	O
logfile	*(int)
;	O
logfile	*(int)
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
2	int
;	O
*	O
(	O
strchr	O
(	O
firstunitstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
=	O
'\0'	O
;	O
removespaces	(*(char))->(void)
(	O
firstunitstr	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
unitstr	*(char)
)	O
;	O
showpointer	(int)->(void)
(	O
promptlen	int
)	O
;	O
showconformabilityerr	(*(char),*(struct),*(char),*(struct))->(void)
(	O
firstunitstr	*(char)
,	O
unit	*(char)
,	O
unitstr	*(char)
,	O
unit	*(char)
+	O
1	int
)	O
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
wasverbose	int
;	O
logfile	*(int)
=	O
savelog	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
+	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
+	O
1	int
)	O
;	O
}	O
if	O
(	O
nextunitstr	*(char)
)	O
{	O
if	O
(	O
promptlen	int
>=	O
0	int
)	O
promptlen	int
+=	O
strwidth	(*(char))->(int)
(	O
unitstr	*(char)
)	O
+	O
1	int
;	O
*	O
(	O
nextunitstr	*(char)
++	O
)	O
=	O
UNITSEPCHAR	char
;	O
}	O
unitstr	*(char)
=	O
nextunitstr	*(char)
;	O
}	O
freeunit	(*(struct))->(void)
(	O
unit	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
processwant	(*(struct),*(char),int)->(int)
(	O
struct	O
unittype	O
*	O
theunit	*(struct)
,	O
char	O
*	O
unitstr	*(char)
,	O
int	O
promptlen	int
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitlists	int
&&	O
strchr	O
(	O
unitstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
return	O
checkunitlist	(*(char),int)->(int)
(	O
unitstr	*(char)
,	O
promptlen	int
)	O
;	O
else	O
return	O
processunit	(*(struct),*(char),int)->(int)
(	O
theunit	*(struct)
,	O
unitstr	*(char)
,	O
promptlen	int
)	O
;	O
}	O
void	O
checkallaliases	(int)->(void)
(	O
int	O
verbose	int
)	O
{	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
for	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
firstalias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"doing unit list '%s'\n"	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
checkunitlist	(*(char),int)->(int)
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
,	O
NOERRMSG	O
)	O
)	O
printf	O
(	O
"Unit list '%s' contains errors\n"	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
)	O
printf	O
(	O
"Unit list '%s' hides a unit definition.\n"	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
fnlookup	(*(char))->(*(struct))
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
)	O
printf	O
(	O
"Unit list '%s' hides a function definition.\n"	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
;	O
}	O
}	O
void	O
checkunits	(int)->(void)
(	O
int	O
verbosecheck	int
)	O
{	O
struct	O
unittype	O
have	*(struct)
,	O
second	*(*(char))
,	O
one	*(*(char))
;	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
struct	O
func	*(struct)
*	O
funcptr	*(struct)
;	O
char	O
*	O
prefixbuf	*(char)
,	O
*	O
testunit	*(char)
;	O
int	O
i	int
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
one	*(*(char))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
funcptr	*(struct)
=	O
ftab	array(*(struct))
[	O
i	int
]	O
;	O
funcptr	*(struct)
;	O
funcptr	*(struct)
=	O
funcptr	*(struct)
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
checkfunc	(*(struct),int)->(void)
(	O
funcptr	*(struct)
,	O
verbosecheck	int
)	O
;	O
checkallaliases	(int)->(void)
(	O
verbosecheck	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
utab	array(*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
[	O
i	int
]	O
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
;	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
=	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
if	O
(	O
verbosecheck	int
)	O
printf	O
(	O
"doing '%s'\n"	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
parseunit	()->(int)
(	O
&	O
have	*(struct)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	(*(struct))->(int)
(	O
&	O
have	*(struct)
)	O
||	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
&	O
have	*(struct)
,	O
&	O
one	*(*(char))
,	O
ignore_primitive	(*(char))->(int)
)	O
)	O
{	O
if	O
(	O
fnlookup	(*(char))->(*(struct))
(	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
)	O
printf	O
(	O
"Unit '%s' hidden by function '%s'\n"	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
else	O
printf	O
(	O
"'%s' defined as '%s' irreducible\n"	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
}	O
else	O
{	O
parserflags	struct
.	O
minusminus	O
=	O
!	O
parserflags	struct
.	O
minusminus	O
;	O
parseunit	()->(int)
(	O
&	O
second	*(*(char))
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
completereduce	(*(struct))->(int)
(	O
&	O
second	*(*(char))
)	O
;	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
&	O
have	*(struct)
,	O
&	O
second	*(*(char))
,	O
ignore_nothing	(*(char))->(int)
)	O
)	O
{	O
printf	O
(	O
"'%s': replace '-' with '+-' for subtraction or '*' to multiply\n"	*(char)
,	O
uptr	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
&	O
second	*(*(char))
)	O
;	O
parserflags	struct
.	O
minusminus	O
=	O
!	O
parserflags	struct
.	O
minusminus	O
;	O
}	O
freeunit	(*(struct))->(void)
(	O
&	O
have	*(struct)
)	O
;	O
}	O
testunit	*(char)
=	O
"meter"	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
ptab	array(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
[	O
i	int
]	O
;	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`)))))
)	O
{	O
if	O
(	O
verbosecheck	int
)	O
printf	O
(	O
"doing '%s-'\n"	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
prefixbuf	*(char)
=	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
+	O
strlen	O
(	O
testunit	*(char)
)	O
+	O
1	int
,	O
"(checkunits)"	*(char)
)	O
;	O
strcpy	O
(	O
prefixbuf	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
strcat	O
(	O
prefixbuf	*(char)
,	O
testunit	*(char)
)	O
;	O
if	O
(	O
parseunit	()->(int)
(	O
&	O
have	*(struct)
,	O
prefixbuf	*(char)
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	(*(struct))->(int)
(	O
&	O
have	*(struct)
)	O
||	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
&	O
have	*(struct)
,	O
&	O
one	*(*(char))
,	O
ignore_primitive	(*(char))->(int)
)	O
)	O
printf	O
(	O
"'%s-' defined as '%s' irreducible\n"	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
else	O
{	O
int	O
plevel	int
;	O
char	O
*	O
ch	*(char)
;	O
plevel	int
=	O
0	int
;	O
for	O
(	O
ch	*(char)
=	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
;	O
*	O
ch	*(char)
;	O
ch	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
ch	*(char)
==	O
')'	O
)	O
plevel	int
--	O
;	O
else	O
if	O
(	O
*	O
ch	*(char)
==	O
'('	O
)	O
plevel	int
++	O
;	O
else	O
if	O
(	O
plevel	int
==	O
0	int
&&	O
*	O
ch	*(char)
==	O
'/'	O
)	O
{	O
printf	O
(	O
"'%s-' defined as '%s' contains a bad '/'. (Add parentheses.)\n"	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
name	*(char)
,	O
pptr	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
freeunit	(*(struct))->(void)
(	O
&	O
have	*(struct)
)	O
;	O
free	()->(int)
(	O
prefixbuf	*(char)
)	O
;	O
}	O
}	O
int	O
showunitlist	(*(char),*(struct),*(char))->(int)
(	O
char	O
*	O
havestr	*(char)
,	O
struct	O
unittype	O
*	O
have	*(struct)
,	O
char	O
*	O
wantstr	*(char)
)	O
{	O
struct	O
unittype	O
want	struct
,	O
lastwant	struct
;	O
char	O
*	O
lastunitstr	*(char)
,	O
*	O
nextunitstr	*(char)
,	O
*	O
lastwantstr	*(char)
=	O
0	int
;	O
double	O
remainder	double
;	O
double	O
round_dir	double
;	O
double	O
value	*(char)
;	O
int	O
firstunit	*(char)
=	O
1	int
;	O
int	O
value_shown	int
=	O
0	int
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
remainder	double
=	O
have	*(struct)
->	O
factor	double
;	O
lastunitstr	*(char)
=	O
0	int
;	O
nextunitstr	*(char)
=	O
0	int
;	O
round_dir	double
=	O
0	int
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
round	int
)	O
{	O
if	O
(	O
lastchar	O
(	O
wantstr	*(char)
)	O
==	O
UNITSEPCHAR	char
)	O
lastchar	O
(	O
wantstr	*(char)
)	O
=	O
0	int
;	O
if	O
(	O
(	O
lastwantstr	*(char)
=	O
strrchr	O
(	O
wantstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
)	O
lastwantstr	*(char)
++	O
;	O
}	O
while	O
(	O
wantstr	*(char)
)	O
{	O
if	O
(	O
(	O
nextunitstr	*(char)
=	O
strchr	O
(	O
wantstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
)	O
*	O
(	O
nextunitstr	*(char)
++	O
)	O
=	O
'\0'	O
;	O
removespaces	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
if	O
(	O
emptystr	O
(	O
wantstr	*(char)
)	O
)	O
wantstr	*(char)
=	O
lastunitstr	*(char)
;	O
if	O
(	O
processunit	(*(struct),*(char),int)->(int)
(	O
&	O
want	struct
,	O
wantstr	*(char)
,	O
NOPOINT	O
)	O
)	O
{	O
freeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
firstunit	*(char)
)	O
{	O
if	O
(	O
compareunits	(*(struct),*(struct),*((*(char))->(int)))->(int)
(	O
have	*(struct)
,	O
&	O
want	struct
,	O
ignore_dimless	(*(char))->(int)
)	O
)	O
{	O
showconformabilityerr	(*(char),*(struct),*(char),*(struct))->(void)
(	O
havestr	*(char)
,	O
have	*(struct)
,	O
wantstr	*(char)
,	O
&	O
want	struct
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
round	int
)	O
{	O
value	*(char)
=	O
remainder	double
;	O
if	O
(	O
lastwantstr	*(char)
&&	O
*	O
lastwantstr	*(char)
)	O
{	O
removespaces	(*(char))->(void)
(	O
lastwantstr	*(char)
)	O
;	O
initializeunit	(*(struct))->(void)
(	O
&	O
lastwant	struct
)	O
;	O
if	O
(	O
processunit	(*(struct),*(char),int)->(int)
(	O
&	O
lastwant	struct
,	O
lastwantstr	*(char)
,	O
NOPOINT	O
)	O
)	O
{	O
freeunit	(*(struct))->(void)
(	O
&	O
lastwant	struct
)	O
;	O
return	O
1	int
;	O
}	O
remainder	double
=	O
floor	O
(	O
remainder	double
/	O
lastwant	struct
.	O
factor	double
+	O
0.5	int
)	O
*	O
lastwant	struct
.	O
factor	double
;	O
}	O
else	O
remainder	double
=	O
floor	O
(	O
remainder	double
/	O
want	struct
.	O
factor	double
+	O
0.5	int
)	O
*	O
want	struct
.	O
factor	double
;	O
round_dir	double
=	O
remainder	double
-	O
value	*(char)
;	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
{	O
removespaces	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
logprintf	(*(char))->(void)
(	O
"\t%s = "	*(char)
,	O
havestr	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
1	int
)	O
logputchar	(char)->(void)
(	O
'\t'	O
)	O
;	O
}	O
if	O
(	O
nextunitstr	*(char)
)	O
{	O
remainder	double
=	O
want	struct
.	O
factor	double
*	O
modf	O
(	O
remainder	double
/	O
want	struct
.	O
factor	double
,	O
&	O
value	*(char)
)	O
;	O
if	O
(	O
round_to_displayed	(double,*(int))->(double)
(	O
remainder	double
/	O
want	struct
.	O
factor	double
,	O
NULL	O
)	O
==	O
1	int
)	O
{	O
value	*(char)
++	O
;	O
remainder	double
=	O
0	int
;	O
}	O
else	O
if	O
(	O
fabs	O
(	O
remainder	double
/	O
have	*(struct)
->	O
factor	double
)	O
<	O
DBL_EPSILON	O
)	O
remainder	double
=	O
0	int
;	O
}	O
else	O
{	O
value	*(char)
=	O
remainder	double
/	O
want	struct
.	O
factor	double
;	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
round	int
)	O
{	O
value	*(char)
=	O
round_to_displayed	(double,*(int))->(double)
(	O
value	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
)	O
{	O
if	O
(	O
!	O
firstunit	*(char)
)	O
logputchar	(char)->(void)
(	O
UNITSEPCHAR	char
)	O
;	O
logprintf	(*(char))->(void)
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
,	O
value	*(char)
)	O
;	O
value_shown	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
value	*(char)
!=	O
0	int
)	O
{	O
if	O
(	O
value_shown	int
)	O
logputs	(*(char))->(void)
(	O
" + "	*(char)
)	O
;	O
showunitname	(double,*(char),int)->(void)
(	O
value	*(char)
,	O
wantstr	*(char)
,	O
PRINTNUM	int
)	O
;	O
value_shown	int
=	O
1	int
;	O
}	O
}	O
freeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
lastunitstr	*(char)
=	O
wantstr	*(char)
;	O
wantstr	*(char)
=	O
nextunitstr	*(char)
;	O
firstunit	*(char)
=	O
0	int
;	O
}	O
if	O
(	O
!	O
value_shown	int
)	O
{	O
logputs	(*(char))->(void)
(	O
"0 "	*(char)
)	O
;	O
if	O
(	O
isdecimal	(char)->(int)
(	O
*	O
lastunitstr	*(char)
)	O
)	O
logputs	(*(char))->(void)
(	O
"* "	*(char)
)	O
;	O
logputs	(*(char))->(void)
(	O
lastunitstr	*(char)
)	O
;	O
}	O
if	O
(	O
round_dir	double
!=	O
0	int
)	O
{	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
)	O
{	O
if	O
(	O
round_dir	double
>	O
0	int
)	O
logprintf	(*(char))->(void)
(	O
" (rounded up to nearest %s) "	*(char)
,	O
lastunitstr	*(char)
)	O
;	O
else	O
logprintf	(*(char))->(void)
(	O
" (rounded down to nearest %s) "	*(char)
,	O
lastunitstr	*(char)
)	O
;	O
}	O
else	O
logprintf	(*(char))->(void)
(	O
"%c%c"	*(char)
,	O
UNITSEPCHAR	char
,	O
round_dir	double
>	O
0	int
?	O
'-'	O
:	O
'+'	O
)	O
;	O
}	O
logputchar	(char)->(void)
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
ishelpquery	(*(char),*(struct))->(int)
(	O
char	O
*	O
str	*(char)
,	O
struct	O
unittype	O
*	O
have	*(struct)
)	O
{	O
struct	O
unitlist	struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct(*(char),*(char),int,*(char),*(struct`))))))
*	O
unit	*(char)
;	O
struct	O
func	*(struct)
*	O
function	*(struct)
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
struct	O
prefixlist	struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`))))))
*	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
;	O
char	O
commandbuf	array(char)
[	O
1000	int
]	O
;	O
int	O
unitline	int
;	O
char	O
*	O
file	*(char)
;	O
char	O
*	O
*	O
exitptr	*(*(char))
;	O
if	O
(	O
have	*(struct)
&&	O
!	O
strcmp	O
(	O
str	*(char)
,	O
UNITMATCH	*(char)
)	O
)	O
{	O
tryallunits	(*(struct),*(char))->(void)
(	O
have	*(struct)
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
exitptr	*(*(char))
=	O
exit_commands	array(*(char))
;	O
*	O
exitptr	*(*(char))
;	O
exitptr	*(*(char))
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
str	*(char)
,	O
*	O
exitptr	*(*(char))
)	O
)	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
if	O
(	O
startswith	O
(	O
str	*(char)
,	O
SEARCHCOMMAND	*(char)
)	O
)	O
{	O
str	*(char)
+=	O
strlen	O
(	O
SEARCHCOMMAND	*(char)
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
str	*(char)
)	O
&&	O
*	O
str	*(char)
!=	O
' '	O
)	O
return	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
str	*(char)
)	O
;	O
if	O
(	O
emptystr	O
(	O
str	*(char)
)	O
)	O
{	O
printf	O
(	O
"\nType 'search text' to see a list of all unit names \ncontaining 'text' as a substring\n\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
tryallunits	(*(struct),*(char))->(void)
(	O
0	int
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
startswith	O
(	O
str	*(char)
,	O
HELPCOMMAND	*(char)
)	O
)	O
{	O
str	*(char)
+=	O
strlen	O
(	O
HELPCOMMAND	*(char)
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
str	*(char)
)	O
&&	O
*	O
str	*(char)
!=	O
' '	O
)	O
return	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
str	*(char)
)	O
;	O
if	O
(	O
emptystr	O
(	O
str	*(char)
)	O
)	O
{	O
printf	O
(	O
"\nUnits converts between different measuring systems and    %s6 inches\nacts as a units-aware calculator.  At the '%s'    %scm\nprompt, type in the units you want to convert from or             * 15.24\nan expression to evaluate.  At the '%s' prompt,           / 0.065\nenter the units to convert to or press return to see\nthe reduced form or definition.                           %stempF(75)\n                                                          %stempC\nThe first example shows that 6 inches is about 15 cm              23.889\nor (1/0.065) cm.  The second example shows how to\nconvert 75 degrees Fahrenheit to Celsius.  The third      %sbu^(1/3)\nexample converts the cube root of a bushel to a list      %sft;in\nof semicolon-separated units.                                     1 ft + 0.9 in\n\nTo quit from units type 'quit' or 'exit'.       %s2 btu + 450 ft lbf\n                                                %s(kg^2/s)/(day lb/m^2)\nAt the '%s' prompt type '%s' to get a            * 1.0660684e+08\nlist of conformable units.  At either prompt you        / 9.3802611e-09\ntype 'help myunit' to browse the units database\nand read the comments relating to myunit or see         %s6 tbsp sugar\nother units related to myunit.  Typing 'search          %sg\ntext' will show units whose names contain 'text'.               * 75\n                                                                / 0.013333333\n"	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYWANT	*(char)
,	O
QUERYWANT	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYWANT	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYWANT	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYWANT	*(char)
,	O
QUERYWANT	*(char)
,	O
UNITMATCH	*(char)
,	O
QUERYHAVE	*(char)
,	O
QUERYWANT	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
function	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
str	*(char)
)	O
)	O
)	O
{	O
file	*(char)
=	O
function	*(struct)
->	O
file	*(char)
;	O
unitline	int
=	O
function	*(struct)
->	O
linenumber	int
;	O
}	O
else	O
if	O
(	O
(	O
unit	*(char)
=	O
ulookup	(*(char))->(*(struct(*(char),*(char),int,*(char),*(struct(*`,*`,int,*`,*`)))))
(	O
str	*(char)
)	O
)	O
)	O
{	O
unitline	int
=	O
unit	*(char)
->	O
linenumber	int
;	O
file	*(char)
=	O
unit	*(char)
->	O
file	*(char)
;	O
}	O
else	O
if	O
(	O
(	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
=	O
plookup	(*(char))->(*(struct(int,*(char),*(char),int,*(char),*(struct(int,*`,*`,int,*`,*`)))))
(	O
str	*(char)
)	O
)	O
&&	O
strlen	O
(	O
str	*(char)
)	O
==	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
len	int
)	O
{	O
unitline	int
=	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
linenumber	int
;	O
file	*(char)
=	O
prefix	*(struct(int,*(char),*(char),int,*(char),*(struct(int,*(char),*(char),int,*(char),*(struct`)))))
->	O
file	*(char)
;	O
}	O
else	O
if	O
(	O
(	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
str	*(char)
)	O
)	O
)	O
{	O
unitline	int
=	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
linenumber	int
;	O
file	*(char)
=	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
file	*(char)
;	O
}	O
else	O
{	O
printf	O
(	O
"Unknown unit '%s'\n"	*(char)
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	O
(	O
commandbuf	array(char)
,	O
"%s +%d %s"	*(char)
,	O
pager	*(char)
,	O
unitline	int
,	O
file	*(char)
)	O
;	O
if	O
(	O
system	()->(int)
(	O
commandbuf	array(char)
)	O
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot invoke pager '%s' to display help\n"	*(char)
,	O
progname	*(char)
,	O
pager	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
checklocale	()->(void)
(	O
)	O
{	O
char	O
*	O
temp	*(char)
;	O
temp	*(char)
=	O
setlocale	()->(int)
(	O
LC_CTYPE	O
,	O
""	*(char)
)	O
;	O
utf8mode	int
=	O
(	O
strcmp	O
(	O
nl_langinfo	()->(int)
(	O
CODESET	O
)	O
,	O
"UTF-8"	*(char)
)	O
==	O
0	int
)	O
;	O
if	O
(	O
temp	*(char)
)	O
{	O
mylocale	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
temp	*(char)
)	O
;	O
temp	*(char)
=	O
strchr	O
(	O
mylocale	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
temp	*(char)
)	O
*	O
temp	*(char)
=	O
0	int
;	O
}	O
else	O
mylocale	*(char)
=	O
DEFAULTLOCALE	*(char)
;	O
}	O
int	O
replacealias	(*(*(char)),*(int))->(int)
(	O
char	O
*	O
*	O
string	*(char)
,	O
int	O
*	O
buflen	int
)	O
{	O
int	O
usefree	int
=	O
1	int
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
char	O
*	O
input	*(char)
;	O
if	O
(	O
!	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
readline	int
&&	O
buflen	int
)	O
usefree	int
=	O
0	int
;	O
if	O
(	O
*	O
string	*(char)
&&	O
*	O
*	O
string	*(char)
)	O
{	O
input	*(char)
=	O
*	O
string	*(char)
;	O
removespaces	(*(char))->(void)
(	O
input	*(char)
)	O
;	O
if	O
(	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
input	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
checkunitlist	(*(char),int)->(int)
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
,	O
NOERRMSG	O
)	O
)	O
{	O
puts	()->(int)
(	O
"Unit list definition contains errors."	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
usefree	int
)	O
{	O
free	()->(int)
(	O
*	O
string	*(char)
)	O
;	O
*	O
string	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
}	O
else	O
{	O
while	O
(	O
strlen	O
(	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
>	O
*	O
buflen	int
)	O
growbuffer	(*(*(char)),*(int))->(void)
(	O
string	*(char)
,	O
buflen	int
)	O
;	O
strcpy	O
(	O
*	O
string	*(char)
,	O
aliasptr	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
->	O
definition	*(char)
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
remaplocale	(*(char))->(void)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE	O
*	O
map	O
;	O
char	O
*	O
value	*(char)
;	O
char	O
name	*(char)
[	O
80	int
]	O
;	O
map	O
=	O
fopen	()->(int)
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
;	O
if	O
(	O
!	O
map	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open locale map '%s'. "	*(char)
,	O
progname	*(char)
,	O
filename	*(char)
)	O
;	O
perror	()->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
!	O
feof	()->(int)
(	O
map	O
)	O
)	O
{	O
if	O
(	O
!	O
fgets	()->(int)
(	O
name	*(char)
,	O
80	int
,	O
map	O
)	O
)	O
break	O
;	O
lastchar	O
(	O
name	*(char)
)	O
=	O
0	int
;	O
value	*(char)
=	O
strchr	O
(	O
name	*(char)
,	O
'#'	O
)	O
;	O
if	O
(	O
value	*(char)
)	O
*	O
value	*(char)
=	O
0	int
;	O
value	*(char)
=	O
strchr	O
(	O
name	*(char)
,	O
'\t'	O
)	O
;	O
if	O
(	O
!	O
value	*(char)
)	O
continue	O
;	O
*	O
value	*(char)
++	O
=	O
0	int
;	O
removespaces	(*(char))->(void)
(	O
value	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
mylocale	*(char)
)	O
)	O
mylocale	*(char)
=	O
dupstr	(*(char))->(*(char))
(	O
value	*(char)
)	O
;	O
}	O
fclose	()->(int)
(	O
map	O
)	O
;	O
}	O
}	O
void	O
close_logfile	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
logfile	*(int)
)	O
{	O
fputc	()->(int)
(	O
'\n'	O
,	O
logfile	*(int)
)	O
;	O
fclose	()->(int)
(	O
logfile	*(int)
)	O
;	O
}	O
}	O
void	O
open_logfile	()->(void)
(	O
void	O
)	O
{	O
time_t	O
logtime	O
;	O
char	O
*	O
timestr	*(char)
;	O
logfile	*(int)
=	O
fopen	()->(int)
(	O
logfilename	*(char)
,	O
"at"	*(char)
)	O
;	O
if	O
(	O
!	O
logfile	*(int)
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot write to log file '%s'.  "	*(char)
,	O
progname	*(char)
,	O
logfilename	*(char)
)	O
;	O
perror	()->(int)
(	O
0	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
time	()->(int)
(	O
&	O
logtime	O
)	O
;	O
timestr	*(char)
=	O
ctime	()->(int)
(	O
&	O
logtime	O
)	O
;	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"### Log started %s \n"	*(char)
,	O
timestr	*(char)
)	O
;	O
atexit	()->(int)
(	O
close_logfile	()->(void)
)	O
;	O
}	O
void	O
write_files_sig	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
close_logfile	()->(void)
(	O
)	O
;	O
signal	()->(int)
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
raise	()->(int)
(	O
sig	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
static	O
struct	O
unittype	O
have	*(struct)
,	O
want	struct
;	O
char	O
*	O
havestr	*(char)
=	O
0	int
,	O
*	O
wantstr	*(char)
=	O
0	int
;	O
struct	O
func	*(struct)
*	O
funcval	*(struct)
;	O
struct	O
wantalias	struct(*(char),*(char),*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
;	O
int	O
havestrsize	int
=	O
0	int
;	O
int	O
wantstrsize	int
=	O
0	int
;	O
int	O
interactive	int
;	O
int	O
readerr	int
;	O
char	O
*	O
*	O
unitfileptr	*(*(char))
;	O
int	O
unitcount	*(int)
=	O
0	int
,	O
prefixcount	*(int)
=	O
0	int
,	O
funccount	*(int)
=	O
0	int
;	O
char	O
*	O
queryhave	*(char)
,	O
*	O
querywant	*(char)
,	O
*	O
comment	*(char)
;	O
int	O
queryhavewidth	int
,	O
querywantwidth	int
;	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
=	O
NULL	O
;	O
num_format	struct(*(char),int,int,char)
.	O
precision	int
=	O
DEFAULTPRECISION	int
;	O
num_format	struct(*(char),int,int,char)
.	O
type	char
=	O
DEFAULTTYPE	char
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
=	O
1	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
round	int
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
strictconvert	int
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitlists	int
=	O
1	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
oneline	int
=	O
0	int
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
showfactor	int
=	O
0	int
;	O
parserflags	struct
.	O
minusminus	O
=	O
1	int
;	O
parserflags	struct
.	O
oldstar	O
=	O
0	int
;	O
progname	*(char)
=	O
getprogramname	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
(	O
isfullpath	(*(char))->(int)
(	O
UNITSFILE	O
)	O
&&	O
isfullpath	(*(char))->(int)
(	O
LOCALEMAP	O
)	O
)	O
)	O
progdir	*(char)
=	O
getprogdir	(*(char),*(*(char)))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
&	O
fullprogname	*(char)
)	O
;	O
else	O
{	O
progdir	*(char)
=	O
NULL	O
;	O
fullprogname	*(char)
=	O
NULL	O
;	O
}	O
datadir	*(char)
=	O
NULL	O
;	O
checklocale	()->(void)
(	O
)	O
;	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
readline	int
=	O
0	int
;	O
unitsfiles	array(*(char))
[	O
0	int
]	O
=	O
0	int
;	O
interactive	int
=	O
processargs	(int,*(*(char)),*(*(char)),*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
havestr	*(char)
,	O
&	O
wantstr	*(char)
)	O
;	O
signal	()->(int)
(	O
SIGINT	O
,	O
write_files_sig	(int)->(void)
)	O
;	O
signal	()->(int)
(	O
SIGTERM	O
,	O
write_files_sig	(int)->(void)
)	O
;	O
if	O
(	O
logfilename	*(char)
)	O
{	O
if	O
(	O
!	O
interactive	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Log file '%s' ignored in non-interactive mode.\n"	*(char)
,	O
logfilename	*(char)
)	O
;	O
else	O
open_logfile	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
num_format	struct(*(char),int,int,char)
.	O
format	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
parsenumformat	()->(int)
(	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
else	O
setnumformat	()->(int)
(	O
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
0	int
)	O
deftext	*(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
unitsfiles	array(*(char))
[	O
0	int
]	O
)	O
{	O
char	O
*	O
unitsfile	*(char)
;	O
unitsfile	*(char)
=	O
findunitsfile	(int)->(*(char))
(	O
0	int
)	O
;	O
if	O
(	O
!	O
unitsfile	*(char)
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
{	O
int	O
file_exists	int
;	O
unitsfiles	array(*(char))
[	O
0	int
]	O
=	O
unitsfile	*(char)
;	O
unitsfiles	array(*(char))
[	O
1	int
]	O
=	O
personalfile	(*(char),*(char),int,*(int))->(*(char))
(	O
HOME_UNITS_ENV	*(char)
,	O
homeunitsfile	*(char)
,	O
0	int
,	O
&	O
file_exists	int
)	O
;	O
unitsfiles	array(*(char))
[	O
2	int
]	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
unitfileptr	*(*(char))
=	O
unitsfiles	array(*(char))
;	O
*	O
unitfileptr	*(*(char))
;	O
unitfileptr	*(*(char))
++	O
)	O
{	O
readerr	int
=	O
readunits	(*(char),*(int),*(int),*(int),*(int),int)->(int)
(	O
*	O
unitfileptr	*(*(char))
,	O
stderr	O
,	O
&	O
unitcount	*(int)
,	O
&	O
prefixcount	*(int)
,	O
&	O
funccount	*(int)
,	O
0	int
)	O
;	O
if	O
(	O
readerr	int
==	O
E_MEMORY	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
readerr	int
==	O
E_FILE	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: cannot open units file '%s'.  "	*(char)
,	O
progname	*(char)
,	O
*	O
unitfileptr	*(*(char))
)	O
;	O
perror	()->(int)
(	O
0	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
quiet	int
)	O
queryhave	*(char)
=	O
querywant	*(char)
=	O
""	*(char)
;	O
else	O
{	O
if	O
(	O
!	O
promptprefix	*(char)
)	O
{	O
queryhave	*(char)
=	O
QUERYHAVE	*(char)
;	O
querywant	*(char)
=	O
QUERYWANT	*(char)
;	O
}	O
else	O
{	O
queryhave	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
promptprefix	*(char)
)	O
+	O
strlen	O
(	O
QUERYHAVE	*(char)
)	O
+	O
1	int
,	O
"(main)"	*(char)
)	O
;	O
querywant	*(char)
=	O
(	O
char	O
*	O
)	O
mymalloc	(int,*(char))->(*(void))
(	O
strlen	O
(	O
promptprefix	*(char)
)	O
+	O
strlen	O
(	O
QUERYWANT	*(char)
)	O
+	O
1	int
,	O
"(main)"	*(char)
)	O
;	O
strcpy	O
(	O
queryhave	*(char)
,	O
promptprefix	*(char)
)	O
;	O
strcat	O
(	O
queryhave	*(char)
,	O
QUERYHAVE	*(char)
)	O
;	O
memset	O
(	O
querywant	*(char)
,	O
' '	O
,	O
strlen	O
(	O
promptprefix	*(char)
)	O
)	O
;	O
strcpy	O
(	O
querywant	*(char)
+	O
strlen	O
(	O
promptprefix	*(char)
)	O
,	O
QUERYWANT	*(char)
)	O
;	O
}	O
printf	O
(	O
"%d units, %d prefixes, %d nonlinear units\n\n"	*(char)
,	O
unitcount	*(int)
,	O
prefixcount	*(int)
,	O
funccount	*(int)
)	O
;	O
}	O
queryhavewidth	int
=	O
strwidth	(*(char))->(int)
(	O
queryhave	*(char)
)	O
;	O
querywantwidth	int
=	O
strwidth	(*(char))->(int)
(	O
querywant	*(char)
)	O
;	O
if	O
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
)	O
{	O
checkunits	(int)->(void)
(	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
unitcheck	int
==	O
2	int
||	O
flags	struct(int,int,int,int,int,int,int,int,int)
.	O
verbose	int
==	O
2	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
!	O
interactive	int
)	O
{	O
replacectrlchars	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
if	O
(	O
wantstr	*(char)
)	O
replacectrlchars	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
if	O
(	O
strwidth	(*(char))->(int)
(	O
havestr	*(char)
)	O
<	O
0	int
)	O
{	O
printf	O
(	O
"Error: %s on input\n"	*(char)
,	O
invalid_utf8	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
if	O
(	O
wantstr	*(char)
&&	O
strwidth	(*(char))->(int)
(	O
wantstr	*(char)
)	O
<	O
0	int
)	O
{	O
printf	O
(	O
"Error: %s on input\n"	*(char)
,	O
invalid_utf8	*(char)
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
replace_minus	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
if	O
(	O
wantstr	*(char)
)	O
{	O
replace_minus	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
funcval	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showfuncdefinition	(*(struct),int)->(void)
(	O
funcval	*(struct)
,	O
FUNCTION	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
(	O
funcval	*(struct)
=	O
invfnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showfuncdefinition	(*(struct),int)->(void)
(	O
funcval	*(struct)
,	O
INVERSE	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
(	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showunitlistdef	(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))->(void)
(	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
processunit	(*(struct),*(char),int)->(int)
(	O
&	O
have	*(struct)
,	O
havestr	*(char)
,	O
NOPOINT	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
!	O
wantstr	*(char)
)	O
{	O
showdefinition	(*(char),*(struct))->(void)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
replacealias	(*(*(char)),*(int))->(int)
(	O
&	O
wantstr	*(char)
,	O
0	int
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
(	O
funcval	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
wantstr	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
showfunc	(*(char),*(struct),*(struct))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
funcval	*(struct)
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
processwant	(*(struct),*(char),int)->(int)
(	O
&	O
want	struct
,	O
wantstr	*(char)
,	O
NOPOINT	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
strchr	O
(	O
wantstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
if	O
(	O
showunitlist	(*(char),*(struct),*(char))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
wantstr	*(char)
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
showanswer	(*(char),*(struct),*(char),*(struct))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
wantstr	*(char)
,	O
&	O
want	struct
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
else	O
{	O
pager	*(char)
=	O
getenv	()->(int)
(	O
"PAGER"	*(char)
)	O
;	O
if	O
(	O
!	O
pager	*(char)
)	O
pager	*(char)
=	O
DEFAULTPAGER	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
getuser	O
(	O
&	O
havestr	*(char)
,	O
&	O
havestrsize	int
,	O
queryhave	*(char)
)	O
;	O
replace_minus	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
comment	*(char)
=	O
strip_comment	(*(char))->(*(char))
(	O
havestr	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
havestr	*(char)
)	O
;	O
if	O
(	O
logfile	*(int)
&&	O
comment	*(char)
&&	O
emptystr	O
(	O
havestr	*(char)
)	O
)	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"#%s\n"	*(char)
,	O
comment	*(char)
)	O
;	O
}	O
while	O
(	O
emptystr	O
(	O
havestr	*(char)
)	O
||	O
ishelpquery	(*(char),*(struct))->(int)
(	O
havestr	*(char)
,	O
0	int
)	O
||	O
(	O
!	O
fnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
&&	O
!	O
invfnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
&&	O
!	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
havestr	*(char)
)	O
&&	O
processunit	(*(struct),*(char),int)->(int)
(	O
&	O
have	*(struct)
,	O
havestr	*(char)
,	O
queryhavewidth	int
)	O
)	O
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
{	O
if	O
(	O
comment	*(char)
)	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"%s%s\t#%s\n"	*(char)
,	O
LOGFROM	*(char)
,	O
havestr	*(char)
,	O
comment	*(char)
)	O
;	O
else	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"%s%s\n"	*(char)
,	O
LOGFROM	*(char)
,	O
havestr	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
=	O
aliaslookup	(*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showunitlistdef	(*(struct(*(char),*(char),*(struct(*`,*`,*`,int,*`)),int,*(char))))->(void)
(	O
alias	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`),int,*(char))),int,*(char)))
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
funcval	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showfuncdefinition	(*(struct),int)->(void)
(	O
funcval	*(struct)
,	O
FUNCTION	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
funcval	*(struct)
=	O
invfnlookup	(*(char))->(*(struct))
(	O
havestr	*(char)
)	O
)	O
)	O
{	O
showfuncdefinition	(*(struct),int)->(void)
(	O
funcval	*(struct)
,	O
INVERSE	int
)	O
;	O
continue	O
;	O
}	O
do	O
{	O
int	O
repeat	int
;	O
do	O
{	O
repeat	int
=	O
0	int
;	O
fflush	()->(int)
(	O
stdout	O
)	O
;	O
getuser	O
(	O
&	O
wantstr	*(char)
,	O
&	O
wantstrsize	int
,	O
querywant	*(char)
)	O
;	O
replace_minus	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
comment	*(char)
=	O
strip_comment	(*(char))->(*(char))
(	O
wantstr	*(char)
)	O
;	O
removespaces	(*(char))->(void)
(	O
wantstr	*(char)
)	O
;	O
if	O
(	O
logfile	*(int)
&&	O
comment	*(char)
&&	O
emptystr	O
(	O
wantstr	*(char)
)	O
)	O
{	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"#%s\n"	*(char)
,	O
comment	*(char)
)	O
;	O
repeat	int
=	O
1	int
;	O
}	O
if	O
(	O
ishelpquery	(*(char),*(struct))->(int)
(	O
wantstr	*(char)
,	O
&	O
have	*(struct)
)	O
)	O
{	O
repeat	int
=	O
1	int
;	O
printf	O
(	O
"%s%s\n"	*(char)
,	O
queryhave	*(char)
,	O
havestr	*(char)
)	O
;	O
}	O
}	O
while	O
(	O
repeat	int
)	O
;	O
}	O
while	O
(	O
replacealias	(*(*(char)),*(int))->(int)
(	O
&	O
wantstr	*(char)
,	O
&	O
wantstrsize	int
)	O
||	O
(	O
!	O
fnlookup	(*(char))->(*(struct))
(	O
wantstr	*(char)
)	O
&&	O
processwant	(*(struct),*(char),int)->(int)
(	O
&	O
want	struct
,	O
wantstr	*(char)
,	O
querywantwidth	int
)	O
)	O
)	O
;	O
if	O
(	O
logfile	*(int)
)	O
{	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"%s"	*(char)
,	O
LOGTO	*(char)
)	O
;	O
tightprint	(*(int),*(char))->(void)
(	O
logfile	*(int)
,	O
wantstr	*(char)
)	O
;	O
if	O
(	O
comment	*(char)
)	O
fprintf	()->(int)
(	O
logfile	*(int)
,	O
"\t#%s"	*(char)
,	O
comment	*(char)
)	O
;	O
putc	()->(int)
(	O
'\n'	O
,	O
logfile	*(int)
)	O
;	O
}	O
if	O
(	O
emptystr	O
(	O
wantstr	*(char)
)	O
)	O
showdefinition	(*(char),*(struct))->(void)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
)	O
;	O
else	O
if	O
(	O
strchr	O
(	O
wantstr	*(char)
,	O
UNITSEPCHAR	char
)	O
)	O
showunitlist	(*(char),*(struct),*(char))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
wantstr	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
funcval	*(struct)
=	O
fnlookup	(*(char))->(*(struct))
(	O
wantstr	*(char)
)	O
)	O
)	O
showfunc	(*(char),*(struct),*(struct))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
funcval	*(struct)
)	O
;	O
else	O
{	O
showanswer	(*(char),*(struct),*(char),*(struct))->(int)
(	O
havestr	*(char)
,	O
&	O
have	*(struct)
,	O
wantstr	*(char)
,	O
&	O
want	struct
)	O
;	O
freeunit	(*(struct))->(void)
(	O
&	O
want	struct
)	O
;	O
}	O
unitcopy	(*(struct),*(struct))->(void)
(	O
&	O
lastunit	struct
,	O
&	O
have	*(struct)
)	O
;	O
lastunitset	int
=	O
1	int
;	O
freeunit	(*(struct))->(void)
(	O
&	O
have	*(struct)
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
