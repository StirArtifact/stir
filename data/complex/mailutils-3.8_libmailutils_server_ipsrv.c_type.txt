struct	O
_mu_ip_server	struct(*(char),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),int,int,*(struct),*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(void),union(struct(int),struct(*(char),long,long)))
{	O
char	O
*	O
ident	*(char)
;	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
addr	int
;	O
int	O
fd	int
;	O
int	O
type	int
;	O
mu_acl_t	*(struct)
acl	*(*(struct))
;	O
mu_ip_server_conn_fp	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
f_conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int))
;	O
mu_ip_server_intr_fp	*((*(void),*(void))->(int))
f_intr	*((*(void),*(void))->(int))
;	O
mu_ip_server_free_fp	*((*(void))->(void))
f_free	*((*(void))->(void))
;	O
void	O
*	O
data	*(void)
;	O
union	O
{	O
struct	O
{	O
int	O
backlog	int
;	O
}	O
tcp_data	struct(int)
;	O
struct	O
{	O
char	O
*	O
buf	*(void)
;	O
size_t	long
bufsize	long
;	O
ssize_t	long
rdsize	long
;	O
}	O
udp_data	struct(*(char),long,long)
;	O
}	O
v	union(struct(int),struct(*(char),long,long))
;	O
}	O
;	O
int	O
mu_ip_server_create	(*(*(struct)),*(struct),int)->(int)
(	O
mu_ip_server_t	*(struct)
*	O
psrv	*(*(struct))
,	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
addr	int
,	O
int	O
type	int
)	O
{	O
struct	O
_mu_ip_server	struct(*(char),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),int,int,*(struct),*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int)),*((*(void),*(void))->(int)),*((*(void))->(void)),*(void),union(struct(int),struct(*(char),long,long)))
*	O
srv	*(struct)
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
MU_IP_UDP	int
:	O
case	O
MU_IP_TCP	int
:	O
break	O
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
srv	*(struct)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
srv	*(struct)
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
ENOMEM	int
;	O
srv	*(struct)
->	O
addr	int
=	O
addr	int
;	O
srv	*(struct)
->	O
type	int
=	O
type	int
;	O
srv	*(struct)
->	O
fd	int
=	O
-	O
1	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
MU_IP_UDP	int
:	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
bufsize	long
=	O
4096	int
;	O
break	O
;	O
case	O
MU_IP_TCP	int
:	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
tcp_data	struct(int)
.	O
backlog	int
=	O
4	int
;	O
}	O
*	O
psrv	*(*(struct))
=	O
srv	*(struct)
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_destroy	(*(*(struct)))->(int)
(	O
mu_ip_server_t	*(struct)
*	O
psrv	*(*(struct))
)	O
{	O
mu_ip_server_t	*(struct)
srv	*(struct)
;	O
if	O
(	O
!	O
psrv	*(*(struct))
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
=	O
*	O
psrv	*(*(struct))
;	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
0	int
;	O
if	O
(	O
srv	*(struct)
->	O
f_free	*((*(void))->(void))
)	O
srv	*(struct)
->	O
f_free	*((*(void))->(void))
(	O
srv	*(struct)
->	O
data	*(void)
)	O
;	O
close	(int)->(int)
(	O
srv	*(struct)
->	O
fd	int
)	O
;	O
mu_sockaddr_free	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(void)
(	O
srv	*(struct)
->	O
addr	int
)	O
;	O
free	(*(void))->(void)
(	O
srv	*(struct)
->	O
ident	*(char)
)	O
;	O
if	O
(	O
srv	*(struct)
->	O
type	int
==	O
MU_IP_UDP	int
&&	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
)	O
free	(*(void))->(void)
(	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
srv	*(struct)
)	O
;	O
*	O
psrv	*(*(struct))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_get_type	(*(struct),*(int))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
int	O
*	O
ptype	*(int)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
*	O
ptype	*(int)
=	O
srv	*(struct)
->	O
type	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_tcp_server_set_backlog	(*(struct),int)->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
int	O
backlog	int
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
type	int
!=	O
MU_IP_TCP	int
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
tcp_data	struct(int)
.	O
backlog	int
=	O
backlog	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_udp_server_get_bufsize	(*(struct),*(long))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
size_t	long
*	O
psize	*(long)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
type	int
!=	O
MU_IP_UDP	int
)	O
return	O
EINVAL	int
;	O
*	O
psize	*(long)
=	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
bufsize	long
;	O
return	O
0	int
;	O
}	O
int	O
mu_udp_server_set_bufsize	(*(struct),long)->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
type	int
!=	O
MU_IP_UDP	int
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
bufsize	long
=	O
size	long
;	O
if	O
(	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
)	O
{	O
char	O
*	O
p	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
,	O
size	long
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
return	O
ENOMEM	int
;	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
=	O
p	*(char)
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_set_ident	(*(struct),*(char))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
const	O
char	O
*	O
ident	*(char)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
if	O
(	O
srv	*(struct)
->	O
ident	*(char)
)	O
free	(*(void))->(void)
(	O
srv	*(struct)
->	O
ident	*(char)
)	O
;	O
srv	*(struct)
->	O
ident	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
ident	*(char)
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
->	O
ident	*(char)
)	O
return	O
ENOMEM	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_set_acl	(*(struct),*(struct))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
mu_acl_t	*(struct)
acl	*(*(struct))
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
acl	*(*(struct))
=	O
acl	*(*(struct))
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_set_conn	(*(struct),*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int)))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
mu_ip_server_conn_fp	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
f_conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int))
=	O
conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct))->(int))
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_set_intr	(*(struct),*((*(void),*(void))->(int)))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
mu_ip_server_intr_fp	*((*(void),*(void))->(int))
intr	*((*(void),*(void))->(int))
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
f_intr	*((*(void),*(void))->(int))
=	O
intr	*((*(void),*(void))->(int))
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_set_data	(*(struct),*(void),*((*(void))->(void)))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
void	O
*	O
data	*(void)
,	O
mu_ip_server_free_fp	*((*(void))->(void))
free	(*(void))->(void)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
)	O
return	O
EINVAL	int
;	O
srv	*(struct)
->	O
data	*(void)
=	O
data	*(void)
;	O
srv	*(struct)
->	O
f_free	*((*(void))->(void))
=	O
free	(*(void))->(void)
;	O
return	O
0	int
;	O
}	O
void	O
*	O
mu_ip_server_get_data	(*(struct))->(*(void))
(	O
mu_ip_server_t	*(struct)
tcpsrv	*(struct)
)	O
{	O
return	O
tcpsrv	*(struct)
->	O
data	*(void)
;	O
}	O
int	O
mu_address_family_to_domain	(int)->(int)
(	O
int	O
family	int
)	O
{	O
switch	O
(	O
family	int
)	O
{	O
case	O
AF_UNIX	O
:	O
return	O
PF_UNIX	O
;	O
case	O
AF_INET	O
:	O
return	O
PF_INET	int
;	O
case	O
AF_INET6	O
:	O
return	O
PF_INET6	int
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
int	O
mu_ip_server_open	(*(struct))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
fd	int
!=	O
-	O
1	int
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_TRACE0	int
,	O
(	O
"opening server \"%s\" %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_sockaddr_str	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(*(char))
(	O
srv	*(struct)
->	O
addr	int
)	O
)	O
)	O
;	O
fd	int
=	O
socket	(int,int,int)->(int)
(	O
mu_address_family_to_domain	(int)->(int)
(	O
srv	*(struct)
->	O
addr	int
->	O
addr	int
->	O
sa_family	short
)	O
,	O
(	O
(	O
srv	*(struct)
->	O
type	int
==	O
MU_IP_UDP	int
)	O
?	O
SOCK_DGRAM	int
:	O
SOCK_STREAM	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: socket: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
switch	O
(	O
srv	*(struct)
->	O
addr	int
->	O
addr	int
->	O
sa_family	short
)	O
{	O
case	O
AF_UNIX	O
:	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
s_un	*(struct(short,array(char)))
=	O
(	O
struct	O
sockaddr_un	struct(short,array(char))
*	O
)	O
srv	*(struct)
->	O
addr	int
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: file %s exists but cannot be stat'd: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
EAGAIN	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
S_ISSOCK	O
(	O
st	*(struct(long,long,long))
.	O
st_mode	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: file %s is not a socket"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
)	O
)	O
;	O
return	O
EAGAIN	int
;	O
}	O
else	O
if	O
(	O
unlink	(*(char))->(int)
(	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: cannot unlink file %s: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
s_un	*(struct(short,array(char)))
->	O
sun_path	array(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
EAGAIN	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
{	O
int	O
t	long
;	O
t	long
=	O
1	int
;	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
&	O
t	long
,	O
sizeof	O
(	O
t	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
fd	int
,	O
srv	*(struct)
->	O
addr	int
->	O
addr	int
,	O
srv	*(struct)
->	O
addr	int
->	O
addrlen	int
)	O
==	O
-	O
1	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: bind: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
srv	*(struct)
->	O
type	int
==	O
MU_IP_TCP	int
)	O
{	O
if	O
(	O
listen	(int,int)->(int)
(	O
fd	int
,	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
tcp_data	struct(int)
.	O
backlog	int
)	O
==	O
-	O
1	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: listen: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
return	O
errno	O
;	O
}	O
}	O
srv	*(struct)
->	O
fd	int
=	O
fd	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_shutdown	(*(struct))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
fd	int
!=	O
-	O
1	int
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_TRACE0	int
,	O
(	O
"closing server \"%s\" %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_sockaddr_str	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(*(char))
(	O
srv	*(struct)
->	O
addr	int
)	O
)	O
)	O
;	O
close	(int)->(int)
(	O
srv	*(struct)
->	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_tcp_accept	(*(struct(*(char),*(struct(*`,*`,*`,int,*`)),int,int,*(struct),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct(int),struct(*`,long,long)))),*(void))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
void	O
*	O
call_data	*(void)
)	O
{	O
int	O
rc	int
;	O
int	O
connfd	int
;	O
union	O
{	O
struct	O
sockaddr	struct(short,array(char))
sa	*(struct(short,array(char)))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
s_in	struct(short,short,struct(int),array(char))
;	O
struct	O
sockaddr_un	struct(short,array(char))
s_un	*(struct(short,array(char)))
;	O
struct	O
sockaddr_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
s_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
;	O
}	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
;	O
socklen_t	int
size	long
=	O
sizeof	O
(	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
fd	int
==	O
-	O
1	int
||	O
srv	*(struct)
->	O
type	int
==	O
MU_IP_UDP	int
)	O
return	O
EINVAL	int
;	O
connfd	int
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
srv	*(struct)
->	O
fd	int
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
&	O
size	long
)	O
;	O
if	O
(	O
connfd	int
==	O
-	O
1	int
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
switch	O
(	O
ec	int
)	O
{	O
case	O
EINTR	int
:	O
if	O
(	O
srv	*(struct)
->	O
f_intr	*((*(void),*(void))->(int))
&&	O
srv	*(struct)
->	O
f_intr	*((*(void),*(void))->(int))
(	O
srv	*(struct)
->	O
data	*(void)
,	O
call_data	*(void)
)	O
)	O
break	O
;	O
case	O
EAGAIN	int
:	O
case	O
ECONNABORTED	int
:	O
ec	int
=	O
0	int
;	O
}	O
return	O
ec	int
;	O
}	O
if	O
(	O
srv	*(struct)
->	O
acl	*(*(struct))
)	O
{	O
mu_acl_result_t	enum(int,int,int)
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
srv	*(struct)
->	O
acl	*(*(struct))
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
size	long
,	O
&	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: mu_acl_check_sockaddr: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
if	O
(	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
==	O
mu_acl_result_deny	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
size	long
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
"Denying connection from %s"	*(char)
,	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
close	(int)->(int)
(	O
connfd	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
rc	int
=	O
srv	*(struct)
->	O
f_conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int))
(	O
connfd	int
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
size	long
,	O
srv	*(struct)
->	O
data	*(void)
,	O
call_data	*(void)
,	O
srv	*(struct)
)	O
;	O
close	(int)->(int)
(	O
connfd	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_ip_udp_accept	(*(struct(*(char),*(struct(*`,*`,*`,int,*`)),int,int,*(struct),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct(int),struct(*`,long,long)))),*(void))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
void	O
*	O
call_data	*(void)
)	O
{	O
int	O
rc	int
;	O
union	O
{	O
struct	O
sockaddr	struct(short,array(char))
sa	*(struct(short,array(char)))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
s_in	struct(short,short,struct(int),array(char))
;	O
struct	O
sockaddr_un	struct(short,array(char))
s_un	*(struct(short,array(char)))
;	O
struct	O
sockaddr_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
s_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
;	O
}	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
;	O
fd_set	struct(array(long))
rdset	struct(array(long))
;	O
socklen_t	int
salen	int
=	O
sizeof	O
(	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
)	O
;	O
ssize_t	long
size	long
;	O
if	O
(	O
!	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
)	O
{	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
)	O
return	O
ENOMEM	int
;	O
}	O
FD_ZERO	O
(	O
&	O
rdset	struct(array(long))
)	O
;	O
FD_SET	O
(	O
srv	*(struct)
->	O
fd	int
,	O
&	O
rdset	struct(array(long))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
rc	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
srv	*(struct)
->	O
fd	int
+	O
1	int
,	O
&	O
rdset	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
if	O
(	O
srv	*(struct)
->	O
f_intr	*((*(void),*(void))->(int))
&&	O
srv	*(struct)
->	O
f_intr	*((*(void),*(void))->(int))
(	O
srv	*(struct)
->	O
data	*(void)
,	O
call_data	*(void)
)	O
)	O
break	O
;	O
else	O
continue	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
return	O
errno	O
;	O
size	long
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
srv	*(struct)
->	O
fd	int
,	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
,	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
bufsize	long
,	O
0	int
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
&	O
salen	int
)	O
;	O
if	O
(	O
size	long
<	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: recvfrom: %s"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
rdsize	long
=	O
size	long
;	O
if	O
(	O
srv	*(struct)
->	O
acl	*(*(struct))
)	O
{	O
mu_acl_result_t	enum(int,int,int)
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_acl_check_sockaddr	(*(struct),*(struct(short,array(char))),int,*(enum(int,int,int)))->(int)
(	O
srv	*(struct)
->	O
acl	*(*(struct))
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
size	long
,	O
&	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_debug	O
(	O
MU_DEBCAT_SERVER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: mu_acl_check_sockaddr: %s\n"	*(char)
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
if	O
(	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
==	O
mu_acl_result_deny	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
mu_sys_sockaddr_to_astr	(*(struct(short,array(char))),int)->(*(char))
(	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
salen	int
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
"Denying connection from %s"	*(char)
,	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
rc	int
=	O
srv	*(struct)
->	O
f_conn	*((int,*(struct(short,array(char))),int,*(void),*(void),*(struct(*(char),*(struct`),int,int,*(struct`),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct`,struct`))))->(int))
(	O
-	O
1	int
,	O
&	O
client	union(struct(short,array(char)),struct(short,short,struct(int),array(char)),struct(short,array(char)),struct(short,short,int,struct(union(array(char),array(short),array(int))),int))
.	O
sa	*(struct(short,array(char)))
,	O
size	long
,	O
srv	*(struct)
->	O
data	*(void)
,	O
call_data	*(void)
,	O
srv	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
set_strerr_flt	()->(int)
(	O
void	O
)	O
{	O
mu_stream_t	*(struct)
flt	*(struct)
,	O
trans	array(*(struct))
[	O
2	int
]	O
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
mu_log_session_id	int
)	O
return	O
ENOSYS	int
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_TOPSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array(*(struct))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
char	O
*	O
sid	*(char)
;	O
char	O
*	O
argv	*(*(char))
[	O
]	O
=	O
{	O
"inline-comment"	*(char)
,	O
NULL	O
,	O
"-S"	*(char)
,	O
NULL	O
}	O
;	O
rc	int
=	O
mu_sid	(*(*(char)))->(int)
(	O
&	O
sid	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERR	O
,	O
"mu_sid"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
argv	*(*(char))
[	O
1	int
]	O
=	O
sid	*(char)
;	O
rc	int
=	O
mu_filter_create_args	(*(*(struct)),*(struct),*(char),int,*(*(char)),int,int)->(int)
(	O
&	O
flt	*(struct)
,	O
trans	array(*(struct))
[	O
0	int
]	O
,	O
"inline-comment"	*(char)
,	O
3	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
free	(*(void))->(void)
(	O
sid	*(char)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
trans	array(*(struct))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_set_buffer	(*(struct),enum(int,int,int),long)->(int)
(	O
flt	*(struct)
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
trans	array(*(struct))
[	O
0	int
]	O
=	O
flt	*(struct)
;	O
trans	array(*(struct))
[	O
1	int
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_TOPSTREAM	int
,	O
MU_IOCTL_OP_SET	int
,	O
trans	array(*(struct))
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
trans	array(*(struct))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s failed: %s"	*(char)
)	O
,	O
"MU_IOCTL_SET_STREAM"	*(char)
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
mu_strerr	*(struct)
,	O
rc	int
)	O
)	O
;	O
}	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create log filter stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s failed: %s"	*(char)
)	O
,	O
"MU_IOCTL_GET_STREAM"	*(char)
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
mu_strerr	*(struct)
,	O
rc	int
)	O
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
clr_strerr_flt	()->(void)
(	O
void	O
)	O
{	O
mu_stream_t	*(struct)
flt	*(struct)
,	O
trans	array(*(struct))
[	O
2	int
]	O
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_TOPSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array(*(struct))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
flt	*(struct)
=	O
trans	array(*(struct))
[	O
0	int
]	O
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
flt	*(struct)
,	O
MU_IOCTL_TOPSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array(*(struct))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
trans	array(*(struct))
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
mu_strerr	*(struct)
,	O
MU_IOCTL_TOPSTREAM	int
,	O
MU_IOCTL_OP_SET	int
,	O
trans	array(*(struct))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
mu_stream_unref	(*(struct))->(void)
(	O
flt	*(struct)
)	O
;	O
}	O
}	O
}	O
int	O
mu_ip_server_accept	(*(struct),*(void))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
void	O
*	O
call_data	*(void)
)	O
{	O
int	O
rc	int
;	O
int	O
flt	*(struct)
;	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
fd	int
==	O
-	O
1	int
)	O
return	O
EINVAL	int
;	O
flt	*(struct)
=	O
set_strerr_flt	()->(int)
(	O
)	O
;	O
switch	O
(	O
srv	*(struct)
->	O
type	int
)	O
{	O
case	O
MU_IP_UDP	int
:	O
rc	int
=	O
mu_ip_udp_accept	(*(struct(*(char),*(struct(*`,*`,*`,int,*`)),int,int,*(struct),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct(int),struct(*`,long,long)))),*(void))->(int)
(	O
srv	*(struct)
,	O
call_data	*(void)
)	O
;	O
break	O
;	O
case	O
MU_IP_TCP	int
:	O
rc	int
=	O
mu_ip_tcp_accept	(*(struct(*(char),*(struct(*`,*`,*`,int,*`)),int,int,*(struct),*((int,*`,int,*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(void)),*(void),union(struct(int),struct(*`,long,long)))),*(void))->(int)
(	O
srv	*(struct)
,	O
call_data	*(void)
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"socket error on \"%s\": %s"	*(char)
)	O
,	O
IDENTSTR	O
(	O
srv	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_ip_server_shutdown	(*(struct))->(int)
(	O
srv	*(struct)
)	O
;	O
}	O
if	O
(	O
flt	*(struct)
==	O
0	int
)	O
clr_strerr_flt	()->(void)
(	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_ip_server_get_fd	(*(struct))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
srv	*(struct)
->	O
fd	int
;	O
}	O
int	O
mu_udp_server_get_rdata	(*(struct),*(*(char)),*(long))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
pbufsize	*(long)
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
srv	*(struct)
->	O
type	int
!=	O
MU_IP_UDP	int
)	O
return	O
EINVAL	int
;	O
*	O
pbuf	*(*(char))
=	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
buf	*(void)
;	O
*	O
pbufsize	*(long)
=	O
srv	*(struct)
->	O
v	union(struct(int),struct(*(char),long,long))
.	O
udp_data	struct(*(char),long,long)
.	O
rdsize	long
;	O
return	O
0	int
;	O
}	O
int	O
mu_ip_server_get_sockaddr	(*(struct),*(*(struct)))->(int)
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
,	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
*	O
psa	*(*(struct))
)	O
{	O
if	O
(	O
!	O
srv	*(struct)
||	O
!	O
psa	*(*(struct))
)	O
return	O
EINVAL	int
;	O
return	O
mu_sockaddr_copy	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(int)
(	O
psa	*(*(struct))
,	O
srv	*(struct)
->	O
addr	int
)	O
;	O
}	O
const	O
char	O
*	O
mu_ip_server_addrstr	(*(struct))->(*(char))
(	O
mu_ip_server_t	*(struct)
srv	*(struct)
)	O
{	O
return	O
mu_sockaddr_str	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(*(char))
(	O
srv	*(struct)
->	O
addr	int
)	O
;	O
}	O
