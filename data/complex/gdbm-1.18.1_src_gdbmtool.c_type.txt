char	O
*	O
file_name	*(char)
=	O
NULL	O
;	O
GDBM_FILE	*(struct)
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
=	O
NULL	O
;	O
datum	struct(*(char),int)
key_data	struct(*(char),int)
;	O
datum	struct(*(char),int)
return_data	struct(*(char),int)
;	O
int	O
open_mode	int
;	O
unsigned	O
input_line	int
;	O
static	O
void	O
closedb	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
{	O
gdbm_close	(*(struct))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
file_name	*(char)
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
opendb	(*(char))->(int)
(	O
char	O
*	O
dbname	*(char)
)	O
{	O
int	O
cache_size	long
=	O
0	int
;	O
int	O
block_size	int
=	O
0	int
;	O
int	O
flags	int
=	O
0	int
;	O
int	O
filemode	int
;	O
GDBM_FILE	*(struct)
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
;	O
switch	O
(	O
variable_get	(*(char),int,*(*(void)))->(int)
(	O
"cachesize"	*(char)
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cache_size	long
)	O
)	O
{	O
case	O
VAR_OK	int
:	O
case	O
VAR_ERR_NOTSET	int
:	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
switch	O
(	O
variable_get	(*(char),int,*(*(void)))->(int)
(	O
"blocksize"	*(char)
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
block_size	int
)	O
)	O
{	O
case	O
VAR_OK	int
:	O
case	O
VAR_ERR_NOTSET	int
:	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
variable_is_true	(*(char))->(int)
(	O
"lock"	*(char)
)	O
)	O
flags	int
|=	O
GDBM_NOLOCK	int
;	O
if	O
(	O
!	O
variable_is_true	(*(char))->(int)
(	O
"mmap"	*(char)
)	O
)	O
flags	int
|=	O
GDBM_NOMMAP	int
;	O
if	O
(	O
variable_is_true	(*(char))->(int)
(	O
"sync"	*(char)
)	O
)	O
flags	int
|=	O
GDBM_SYNC	int
;	O
if	O
(	O
open_mode	int
==	O
GDBM_NEWDB	int
)	O
{	O
if	O
(	O
interactive	()->(int)
(	O
)	O
&&	O
variable_is_true	(*(char))->(int)
(	O
"confirm"	*(char)
)	O
&&	O
access	(*(char),int)->(int)
(	O
dbname	*(char)
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
getyn	(*(char))->(int)
(	O
_	O
(	O
"database %s already exists; overwrite"	*(char)
)	O
,	O
dbname	*(char)
)	O
)	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
variable_get	(*(char),int,*(*(void)))->(int)
(	O
"filemode"	*(char)
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
filemode	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
=	O
gdbm_open	(*(char),int,int,int,*((*(char))->(void)))->(*(struct))
(	O
dbname	*(char)
,	O
block_size	int
,	O
open_mode	int
|	O
flags	int
,	O
filemode	int
,	O
NULL	O
)	O
;	O
if	O
(	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
==	O
NULL	O
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"cannot open database %s: %s"	*(char)
)	O
,	O
dbname	*(char)
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
cache_size	long
&&	O
gdbm_setopt	(*(struct),int,*(void),int)->(int)
(	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
GDBM_CACHESIZE	O
,	O
&	O
cache_size	long
,	O
sizeof	O
(	O
int	O
)	O
)	O
==	O
-	O
1	int
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"gdbm_setopt failed: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
if	O
(	O
variable_is_true	(*(char))->(int)
(	O
"coalesce"	*(char)
)	O
)	O
{	O
int	O
t	int
=	O
1	int
;	O
if	O
(	O
gdbm_setopt	(*(struct),int,*(void),int)->(int)
(	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
GDBM_SETCOALESCEBLKS	int
,	O
&	O
t	int
,	O
sizeof	O
(	O
t	int
)	O
)	O
==	O
-	O
1	int
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"gdbm_setopt failed: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
if	O
(	O
variable_is_true	(*(char))->(int)
(	O
"centfree"	*(char)
)	O
)	O
{	O
int	O
t	int
=	O
1	int
;	O
if	O
(	O
gdbm_setopt	(*(struct),int,*(void),int)->(int)
(	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
GDBM_SETCENTFREE	int
,	O
&	O
t	int
,	O
sizeof	O
(	O
t	int
)	O
)	O
==	O
-	O
1	int
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"gdbm_setopt failed: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
if	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
gdbm_close	(*(struct))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
=	O
db	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
checkdb	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
{	O
if	O
(	O
!	O
file_name	*(char)
)	O
{	O
file_name	*(char)
=	O
estrdup	(*(char))->(*(char))
(	O
GDBMTOOL_DEFFILE	*(char)
)	O
;	O
terror	(*(char))->(void)
(	O
_	O
(	O
"warning: using default database file %s"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
}	O
return	O
opendb	(*(char))->(int)
(	O
file_name	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
GDBM_ARG_UNUSED	O
)	O
{	O
return	O
checkdb	()->(int)
(	O
)	O
;	O
}	O
size_t	long
bucket_print_lines	(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))))->(long)
(	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
{	O
return	O
6	int
+	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
+	O
3	int
+	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
;	O
}	O
static	O
void	O
format_key_start	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,array(char),long,int,int)))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
bucket_element	struct(int,array(char),long,int,int)
*	O
elt	*(struct(int,array(char),long,int,int))
)	O
{	O
int	O
size	int
=	O
SMALL	int
<	O
elt	*(struct(int,array(char),long,int,int))
->	O
key_size	int
?	O
SMALL	int
:	O
elt	*(struct(int,array(char),long,int,int))
->	O
key_size	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
elt	*(struct(int,array(char),long,int,int))
->	O
key_start	array(char)
[	O
i	int
]	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"   %c"	*(char)
,	O
elt	*(struct(int,array(char),long,int,int))
->	O
key_start	array(char)
[	O
i	int
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %03o"	*(char)
,	O
elt	*(struct(int,array(char),long,int,int))
->	O
key_start	array(char)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
void	O
print_bucket	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),*(char))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
hash_bucket	struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))
*	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
const	O
char	O
*	O
mesg	*(char)
,	O
...	O
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"******* "	*(char)
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
mesg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
mesg	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" **********\n\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"bits = %d\ncount= %d\nHash Table:\n"	*(char)
)	O
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_bits	int
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"    #    hash value     key size    data size     data adr home  key start\n"	*(char)
)	O
)	O
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %4d  %12x  %11d  %11d  %11lu %4d"	*(char)
,	O
index	(*(char),int)->(*(char))
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
hash_value	int
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
key_size	int
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
data_size	int
,	O
(	O
unsigned	O
long	O
)	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
data_pointer	long
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
hash_value	int
%	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
)	O
;	O
if	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
key_size	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" "	*(char)
)	O
;	O
format_key_start	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,array(char),long,int,int)))->(void)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
index	(*(char),int)->(*(char))
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\nAvail count = %1d\n"	*(char)
)	O
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Address           size\n"	*(char)
)	O
)	O
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
av_count	int
;	O
index	(*(char),int)->(*(char))
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%11lu%9d\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_avail	array(struct(int,long))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
av_adr	long
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
bucket_avail	array(struct(int,long))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
av_size	int
)	O
;	O
}	O
size_t	long
_gdbm_avail_list_size	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long)->(long)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
size_t	long
min_size	long
)	O
{	O
int	O
temp	int
;	O
int	O
size	int
;	O
avail_block	struct(int,int,long,array(struct(int,long)))
*	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
;	O
size_t	long
lines	long
;	O
lines	long
=	O
4	int
+	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
count	int
;	O
if	O
(	O
lines	long
>	O
min_size	long
)	O
return	O
lines	long
;	O
temp	int
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
next_block	long
;	O
size	int
=	O
(	O
(	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct(int,long)
)	O
)	O
>>	O
1	int
)	O
+	O
sizeof	O
(	O
avail_block	struct(int,int,long,array(struct(int,long)))
)	O
)	O
;	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
=	O
emalloc	(long)->(*(void))
(	O
size	int
)	O
;	O
while	O
(	O
temp	int
)	O
{	O
if	O
(	O
gdbm_file_seek	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(long)
(	O
dbf	*(struct)
,	O
temp	int
,	O
SEEK_SET	int
)	O
!=	O
temp	int
)	O
{	O
terror	(*(char))->(void)
(	O
"lseek: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
_gdbm_full_read	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(void),long)->(int)
(	O
dbf	*(struct)
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
,	O
size	int
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
"read: %s"	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
gdbm_avail_block_valid_p	(*(struct(int,int,long,array(struct(int,long)))))->(int)
(	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
)	O
)	O
{	O
lines	long
+=	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
count	int
;	O
if	O
(	O
lines	long
>	O
min_size	long
)	O
break	O
;	O
}	O
temp	int
=	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
next_block	long
;	O
}	O
free	(*(void))->(void)
(	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
)	O
;	O
return	O
lines	long
;	O
}	O
static	O
void	O
av_table_display	(*(struct(int,long)),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
avail_elem	struct(int,long)
*	O
av_table	array(struct(int,long))
,	O
int	O
count	int
,	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %15d   %10lu \n"	*(char)
,	O
av_table	array(struct(int,long))
[	O
i	int
]	O
.	O
av_size	int
,	O
(	O
unsigned	O
long	O
)	O
av_table	array(struct(int,long))
[	O
i	int
]	O
.	O
av_adr	long
)	O
;	O
}	O
}	O
void	O
_gdbm_print_avail_list	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
GDBM_FILE	*(struct)
dbf	*(struct)
)	O
{	O
int	O
temp	int
;	O
int	O
size	int
;	O
avail_block	struct(int,int,long,array(struct(int,long)))
*	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\nheader block\nsize  = %d\ncount = %d\n"	*(char)
)	O
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
size	int
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
count	int
)	O
;	O
av_table_display	(*(struct(int,long)),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
av_table	array(struct(int,long))
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
count	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
temp	int
=	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
next_block	long
;	O
size	int
=	O
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct(int,long)
)	O
)	O
+	O
sizeof	O
(	O
avail_block	struct(int,int,long,array(struct(int,long)))
)	O
;	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
=	O
emalloc	(long)->(*(void))
(	O
size	int
)	O
;	O
while	O
(	O
temp	int
)	O
{	O
if	O
(	O
gdbm_file_seek	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long,int)->(long)
(	O
dbf	*(struct)
,	O
temp	int
,	O
SEEK_SET	int
)	O
!=	O
temp	int
)	O
{	O
terror	(*(char))->(void)
(	O
"lseek: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
_gdbm_full_read	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(void),long)->(int)
(	O
dbf	*(struct)
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
,	O
size	int
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
"read: %s"	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\nblock = %d\nsize  = %d\ncount = %d\n"	*(char)
)	O
,	O
temp	int
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
size	int
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
count	int
)	O
;	O
if	O
(	O
gdbm_avail_block_validate	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(int,int,long,array(struct(int,long)))))->(int)
(	O
dbf	*(struct)
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
)	O
==	O
0	int
)	O
av_table_display	(*(struct(int,long)),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
av_table	array(struct(int,long))
,	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
count	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"invalid avail_block"	*(char)
)	O
)	O
;	O
temp	int
=	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
->	O
next_block	long
;	O
}	O
free	(*(void))->(void)
(	O
av_stk	*(struct(int,int,long,array(struct(int,long))))
)	O
;	O
}	O
void	O
_gdbm_print_bucket_cache	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
GDBM_FILE	*(struct)
dbf	*(struct)
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
char	O
changed	char
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
!=	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Bucket Cache (size %zu):\n  Index:         Address  Changed  Data_Hash \n"	*(char)
)	O
,	O
dbf	*(struct)
->	O
cache_size	long
)	O
;	O
for	O
(	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
index	(*(char),int)->(*(char))
<	O
dbf	*(struct)
->	O
cache_size	long
;	O
index	(*(char),int)->(*(char))
++	O
)	O
{	O
changed	char
=	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_changed	char
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %5d:  %15lu %7s  %x\n"	*(char)
,	O
index	(*(char),int)->(*(char))
,	O
(	O
unsigned	O
long	O
)	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_adr	long
,	O
(	O
changed	char
?	O
_	O
(	O
"True"	*(char)
)	O
:	O
_	O
(	O
"False"	*(char)
)	O
)	O
,	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
index	(*(char),int)->(*(char))
]	O
.	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
hash_val	int
)	O
;	O
}	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Bucket cache has not been initialized.\n"	*(char)
)	O
)	O
;	O
}	O
int	O
trimnl	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
if	O
(	O
str	*(char)
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
str	*(char)
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
get_screen_lines	()->(int)
(	O
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
1	int
)	O
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
ws	struct(short,short,short,short)
;	O
ws	struct(short,short,short,short)
.	O
ws_col	short
=	O
ws	struct(short,short,short,short)
.	O
ws_row	short
=	O
0	int
;	O
if	O
(	O
(	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	struct(short,short,short,short)
)	O
<	O
0	int
)	O
||	O
ws	struct(short,short,short,short)
.	O
ws_row	short
==	O
0	int
)	O
{	O
const	O
char	O
*	O
lines	long
=	O
getenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
;	O
if	O
(	O
lines	long
)	O
ws	struct(short,short,short,short)
.	O
ws_row	short
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
lines	long
,	O
NULL	O
,	O
10	int
)	O
;	O
}	O
return	O
ws	struct(short,short,short,short)
.	O
ws_row	short
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
open_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
char	O
*	O
name	*(char)
=	O
tildexpand	(*(char))->(*(char))
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
;	O
closedb	()->(void)
(	O
)	O
;	O
if	O
(	O
opendb	(*(char))->(int)
(	O
name	*(char)
)	O
==	O
0	int
)	O
file_name	*(char)
=	O
name	*(char)
;	O
else	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
void	O
close_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
!	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"nothing to close"	*(char)
)	O
)	O
;	O
else	O
closedb	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
*	O
count_to_str	(long long,*(char),long)->(*(char))
(	O
gdbm_count_t	long long
count	int
,	O
char	O
*	O
buf	*(void)
,	O
size_t	long
bufsize	long
)	O
{	O
char	O
*	O
p	*(char)
=	O
buf	*(void)
+	O
bufsize	long
;	O
*	O
--	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
count	int
==	O
0	int
)	O
*	O
--	O
p	*(char)
=	O
'0'	O
;	O
else	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
p	*(char)
==	O
buf	*(void)
)	O
return	O
NULL	O
;	O
*	O
--	O
p	*(char)
=	O
'0'	O
+	O
count	int
%	O
10	int
;	O
count	int
/=	O
10	int
;	O
}	O
return	O
p	*(char)
;	O
}	O
void	O
count_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
gdbm_count_t	long long
count	int
;	O
if	O
(	O
gdbm_count	(*(struct),*(long long))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
&	O
count	int
)	O
)	O
terror	(*(char))->(void)
(	O
"gdbm_count: %s"	*(char)
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
else	O
{	O
char	O
buf	*(void)
[	O
128	int
]	O
;	O
char	O
*	O
p	*(char)
=	O
count_to_str	(long long,*(char),long)->(*(char))
(	O
count	int
,	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"count buffer overflow"	*(char)
)	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"There is %s item in the database.\n"	*(char)
,	O
"There are %s items in the database.\n"	*(char)
,	O
count	int
)	O
,	O
p	*(char)
)	O
;	O
}	O
}	O
void	O
delete_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
gdbm_delete	(*(struct),struct(*(char),int))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Item not found"	*(char)
)	O
)	O
;	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Can't delete: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
}	O
void	O
fetch_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
return_data	struct(*(char),int)
=	O
gdbm_fetch	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
;	O
if	O
(	O
return_data	struct(*(char),int)
.	O
dptr	*(char)
!=	O
NULL	O
)	O
{	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
return_data	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
return_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
terror	(*(char))->(void)
(	O
"%s"	*(char)
,	O
_	O
(	O
"No such item found."	*(char)
)	O
)	O
;	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Can't fetch data: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
store_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
gdbm_store	(*(struct),struct(*(char),int),struct(*(char),int),int)->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
1	int
)	O
,	O
GDBM_REPLACE	int
)	O
!=	O
0	int
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Item not inserted: %s."	*(char)
)	O
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
;	O
}	O
void	O
firstkey_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
key_data	struct(*(char),int)
=	O
gdbm_firstkey	(*(struct))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
if	O
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
!=	O
NULL	O
)	O
{	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
key_data	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return_data	struct(*(char),int)
=	O
gdbm_fetch	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key_data	struct(*(char),int)
)	O
;	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
return_data	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
return_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"No such item found.\n"	*(char)
)	O
)	O
;	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Can't find key: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
nextkey_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
param	*(struct)
->	O
argc	int
==	O
1	int
)	O
{	O
if	O
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
=	O
emalloc	(long)->(*(void))
(	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
.	O
dsize	int
)	O
;	O
key_data	struct(*(char),int)
.	O
dsize	int
=	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
.	O
dsize	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
.	O
dptr	*(char)
,	O
key_data	struct(*(char),int)
.	O
dsize	int
)	O
;	O
}	O
return_data	struct(*(char),int)
=	O
gdbm_nextkey	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key_data	struct(*(char),int)
)	O
;	O
if	O
(	O
return_data	struct(*(char),int)
.	O
dptr	*(char)
!=	O
NULL	O
)	O
{	O
key_data	struct(*(char),int)
=	O
return_data	struct(*(char),int)
;	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
key_data	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return_data	struct(*(char),int)
=	O
gdbm_fetch	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key_data	struct(*(char),int)
)	O
;	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
return_data	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
return_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
{	O
terror	(*(char))->(void)
(	O
"%s"	*(char)
,	O
_	O
(	O
"No such item found."	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
key_data	struct(*(char),int)
.	O
dptr	*(char)
=	O
NULL	O
;	O
}	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Can't find key: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
reorganize_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
)	O
{	O
if	O
(	O
gdbm_reorganize	(*(struct))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
terror	(*(char))->(void)
(	O
"%s"	*(char)
,	O
_	O
(	O
"Reorganization failed."	*(char)
)	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"Reorganization succeeded."	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
err_printer	(*(void),*(char))->(void)
(	O
void	O
*	O
data	*(void)
GDBM_ARG_UNUSED	O
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
void	O
recover_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
gdbm_recovery	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
;	O
int	O
flags	int
=	O
0	int
;	O
int	O
rc	int
;	O
int	O
i	int
;	O
char	O
*	O
p	*(char)
;	O
int	O
summary	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
param	*(struct)
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
arg	*(char)
=	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"verbose"	*(char)
)	O
==	O
0	int
)	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
errfun	*((*(void),*(char))->(void))
=	O
err_printer	(*(void),*(char))->(void)
;	O
flags	int
|=	O
GDBM_RCVR_ERRFUN	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"force"	*(char)
)	O
==	O
0	int
)	O
{	O
flags	int
|=	O
GDBM_RCVR_FORCE	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"summary"	*(char)
)	O
==	O
0	int
)	O
{	O
summary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"backup"	*(char)
)	O
==	O
0	int
)	O
{	O
flags	int
|=	O
GDBM_RCVR_BACKUP	int
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	*(char)
,	O
"max-failures="	*(char)
,	O
13	int
)	O
==	O
0	int
)	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
max_failures	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
+	O
13	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not a number (stopped near %s)\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILURES	int
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	*(char)
,	O
"max-failed-keys="	*(char)
,	O
16	int
)	O
==	O
0	int
)	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
max_failed_keys	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
+	O
16	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not a number (stopped near %s)\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILED_KEYS	int
;	O
}	O
else	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	*(char)
,	O
"max-failed-buckets="	*(char)
,	O
19	int
)	O
==	O
0	int
)	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
max_failures	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
+	O
19	int
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not a number (stopped near %s)\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILED_BUCKETS	int
;	O
}	O
else	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"unrecognized argument: %s"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
rc	int
=	O
gdbm_recover	(*(struct),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
&	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Recovery succeeded.\n"	*(char)
)	O
)	O
;	O
if	O
(	O
summary	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Keys recovered: %lu, failed: %lu, duplicate: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
recovered_keys	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
failed_keys	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
duplicate_keys	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Buckets recovered: %lu, failed: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
recovered_buckets	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
failed_buckets	long
)	O
;	O
}	O
if	O
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
backup_name	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Original database preserved in file %s"	*(char)
)	O
,	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
backup_name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
.	O
backup_name	*(char)
)	O
;	O
}	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Recovery failed: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
if	O
(	O
gdbm_syserr	array(int)
[	O
gdbm_errno	O
]	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
int	O
avail_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
_gdbm_avail_list_size	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),long)->(long)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
SIZE_T_MAX	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
avail_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
_gdbm_print_avail_list	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
}	O
int	O
print_current_bucket_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
return	O
0	int
;	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
?	O
bucket_print_lines	(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))))->(long)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
+	O
3	int
:	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
print_current_bucket_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
!	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"no current bucket\n"	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
param	*(struct)
->	O
argc	int
)	O
print_bucket	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),*(char))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
_	O
(	O
"Bucket #%s"	*(char)
)	O
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
;	O
else	O
print_bucket	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),*(char))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
"%s"	*(char)
,	O
_	O
(	O
"Current bucket"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\n current directory entry = %d.\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket_dir	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
" current bucket address  = %lu.\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
->	O
ca_adr	long
)	O
;	O
}	O
}	O
int	O
getnum	(*(int),*(char),*(*(char)))->(int)
(	O
int	O
*	O
pnum	*(int)
,	O
char	O
*	O
arg	*(char)
,	O
char	O
*	O
*	O
endp	*(*(char))
)	O
{	O
char	O
*	O
p	*(char)
;	O
unsigned	O
long	O
x	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
p	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
p	*(char)
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not a number (stopped near %s)\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
*	O
p	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
p	*(char)
)	O
)	O
p	*(char)
++	O
;	O
if	O
(	O
endp	*(*(char))
)	O
*	O
endp	*(*(char))
=	O
p	*(char)
;	O
else	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not a number (stopped near %s)\n"	*(char)
)	O
,	O
p	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pnum	*(int)
=	O
x	long
;	O
return	O
0	int
;	O
}	O
int	O
print_bucket_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
int	O
temp	int
;	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getnum	(*(int),*(char),*(*(char)))->(int)
(	O
&	O
temp	int
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
temp	int
>=	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"Not a bucket."	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
_gdbm_get_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
temp	int
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
"%s"	*(char)
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
bucket_print_lines	(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))))->(long)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
+	O
3	int
;	O
return	O
0	int
;	O
}	O
int	O
print_dir_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
+	O
3	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
bucket_count	()->(long)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
off_t	long
last	long
=	O
0	int
;	O
size_t	long
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
dir	long
[	O
i	int
]	O
!=	O
last	long
)	O
{	O
++	O
count	int
;	O
last	long
=	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
dir	long
[	O
i	int
]	O
;	O
}	O
}	O
return	O
count	int
;	O
}	O
void	O
print_dir_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
int	O
i	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Hash table directory.\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  Size =  %d.  Bits = %d,  Buckets = %zu.\n\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
,	O
bucket_count	()->(long)
(	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
i	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  %10d:  %12lu\n"	*(char)
,	O
i	int
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
dir	long
[	O
i	int
]	O
)	O
;	O
}	O
int	O
print_header_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
14	int
;	O
return	O
0	int
;	O
}	O
void	O
print_header_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"\nFile Header: \n\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  table        = %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  table size   = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_size	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  table bits   = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  block size   = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
block_size	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  bucket elems = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  bucket size  = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_size	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  header magic = %x\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
header_magic	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  next block   = %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
next_block	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  avail size   = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
size	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  avail count  = %d\n"	*(char)
)	O
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
count	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"  avail nx blk = %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
avail	struct(int,int,long,array(struct(int,long)))
.	O
next_block	long
)	O
;	O
}	O
void	O
hash_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
{	O
int	O
hashval	int
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
off	long
;	O
_gdbm_hash_key	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),struct(*(char),int),*(int),*(int),*(int))->(void)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
&	O
hashval	int
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
&	O
off	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"hash value = %x, bucket #%u, slot %u"	*(char)
)	O
,	O
hashval	int
,	O
hashval	int
>>	O
(	O
GDBM_HASH_BITS	int
-	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
dir_bits	int
)	O
,	O
hashval	int
%	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"hash value = %x"	*(char)
)	O
,	O
_gdbm_hash	(struct(*(char),int))->(int)
(	O
PARAM_DATUM	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
".\n"	*(char)
)	O
;	O
}	O
int	O
print_cache_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
?	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
cache_size	long
+	O
1	int
:	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
print_cache_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
_gdbm_print_bucket_cache	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
}	O
void	O
print_version_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
gdbm_version	*(char)
)	O
;	O
}	O
int	O
list_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
checkdb	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	*(long)
)	O
{	O
gdbm_count_t	long long
count	int
;	O
if	O
(	O
gdbm_count	(*(struct),*(long long))->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
&	O
count	int
)	O
)	O
*	O
exp_count	*(long)
=	O
0	int
;	O
else	O
if	O
(	O
count	int
>	O
SIZE_T_MAX	O
)	O
*	O
exp_count	*(long)
=	O
SIZE_T_MAX	O
;	O
else	O
*	O
exp_count	*(long)
=	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
list_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
datum	struct(*(char),int)
key	struct(*(char),int)
;	O
datum	struct(*(char),int)
data	*(void)
;	O
key	struct(*(char),int)
=	O
gdbm_firstkey	(*(struct))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
while	O
(	O
key	struct(*(char),int)
.	O
dptr	*(char)
)	O
{	O
datum	struct(*(char),int)
nextkey	struct(*(char),int)
=	O
gdbm_nextkey	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key	struct(*(char),int)
)	O
;	O
data	*(void)
=	O
gdbm_fetch	(*(struct),struct(*(char),int))->(struct(*(char),int))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key	struct(*(char),int)
)	O
;	O
if	O
(	O
!	O
data	*(void)
.	O
dptr	*(char)
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"%s; the key was:"	*(char)
)	O
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
;	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
key	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
)	O
;	O
}	O
else	O
{	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
key	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
datum_format	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
data	*(void)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
.	O
dptr	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
key	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
key	struct(*(char),int)
=	O
nextkey	struct(*(char),int)
;	O
}	O
}	O
void	O
quit_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
)	O
{	O
closedb	()->(void)
(	O
)	O
;	O
input_done	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_OK	int
)	O
;	O
}	O
void	O
export_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
int	O
format	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),int)->(int))
=	O
GDBM_DUMP_FMT_ASCII	int
;	O
int	O
flags	int
=	O
GDBM_WRCREAT	int
;	O
int	O
i	int
;	O
int	O
filemode	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
param	*(struct)
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
,	O
"truncate"	*(char)
)	O
==	O
0	int
)	O
flags	int
=	O
GDBM_NEWDB	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
,	O
"binary"	*(char)
)	O
==	O
0	int
)	O
format	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),int)->(int))
=	O
GDBM_DUMP_FMT_BINARY	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
,	O
"ascii"	*(char)
)	O
==	O
0	int
)	O
format	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),int)->(int))
=	O
GDBM_DUMP_FMT_ASCII	int
;	O
else	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"unrecognized argument: %s"	*(char)
)	O
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
variable_get	(*(char),int,*(*(void)))->(int)
(	O
"filemode"	*(char)
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
filemode	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
gdbm_dump	(*(struct),*(char),int,int,int)->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
format	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),int)->(int))
,	O
flags	int
,	O
filemode	int
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"error dumping database: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
}	O
void	O
import_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
int	O
flag	int
=	O
GDBM_INSERT	int
;	O
unsigned	O
long	O
err_line	long
;	O
int	O
meta_mask	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
rc	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
param	*(struct)
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
,	O
"replace"	*(char)
)	O
==	O
0	int
)	O
flag	int
=	O
GDBM_REPLACE	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
,	O
"nometa"	*(char)
)	O
==	O
0	int
)	O
meta_mask	int
=	O
GDBM_META_MASK_MODE	int
|	O
GDBM_META_MASK_OWNER	int
;	O
else	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"unrecognized argument: %s"	*(char)
)	O
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
i	int
)	O
)	O
;	O
return	O
;	O
}	O
}	O
rc	int
=	O
gdbm_load	(*(*(struct)),*(char),int,int,*(long))->(int)
(	O
&	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
flag	int
,	O
meta_mask	int
,	O
&	O
err_line	long
)	O
;	O
if	O
(	O
rc	int
&&	O
gdbm_errno	O
==	O
GDBM_NO_DBNAME	int
)	O
{	O
int	O
t	int
=	O
open_mode	int
;	O
open_mode	int
=	O
GDBM_NEWDB	int
;	O
rc	int
=	O
checkdb	()->(int)
(	O
)	O
;	O
open_mode	int
=	O
t	int
;	O
if	O
(	O
rc	int
)	O
return	O
;	O
rc	int
=	O
gdbm_load	(*(*(struct)),*(char),int,int,*(long))->(int)
(	O
&	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
flag	int
,	O
meta_mask	int
,	O
&	O
err_line	long
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
switch	O
(	O
gdbm_errno	O
)	O
{	O
case	O
GDBM_ERR_FILE_OWNER	int
:	O
case	O
GDBM_ERR_FILE_MODE	int
:	O
terror	(*(char))->(void)
(	O
_	O
(	O
"error restoring metadata: %s (%s)"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
err_line	long
)	O
terror	(*(char))->(void)
(	O
"%s:%lu: %s"	*(char)
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
err_line	long
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
else	O
terror	(*(char))->(void)
(	O
_	O
(	O
"cannot load from %s: %s"	*(char)
)	O
,	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
return	O
;	O
}	O
free	(*(void))->(void)
(	O
file_name	*(char)
)	O
;	O
if	O
(	O
gdbm_setopt	(*(struct),int,*(void),int)->(int)
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
GDBM_GETDBNAME	int
,	O
&	O
file_name	*(char)
,	O
sizeof	O
(	O
file_name	*(char)
)	O
)	O
)	O
terror	(*(char))->(void)
(	O
_	O
(	O
"gdbm_setopt failed: %s"	*(char)
)	O
,	O
gdbm_strerror	(int)->(*(char))
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
status_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
if	O
(	O
file_name	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Database file: %s\n"	*(char)
)	O
,	O
file_name	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"No database name"	*(char)
)	O
)	O
;	O
if	O
(	O
gdbm_file	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"Database is open"	*(char)
)	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"Database is not open"	*(char)
)	O
)	O
;	O
dsprint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
DS_KEY	int
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
)	O
;	O
dsprint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))->(void)
(	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
DS_CONTENT	int
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
)	O
;	O
}	O
void	O
debug_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
terror	(*(char))->(void)
(	O
"%s"	*(char)
,	O
_	O
(	O
"compiled without debug support"	*(char)
)	O
)	O
;	O
}	O
void	O
source_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
char	O
*	O
fname	*(char)
=	O
tildexpand	(*(char))->(*(char))
(	O
PARAM_STRING	O
(	O
param	*(struct)
,	O
0	int
)	O
)	O
;	O
instream_t	*(struct)
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
=	O
instream_file_create	(*(char))->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
fname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
fname	*(char)
)	O
;	O
if	O
(	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
&&	O
input_context_push	(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))->(int)
(	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
)	O
==	O
0	int
)	O
yyparse	()->(int)
(	O
)	O
;	O
}	O
void	O
help_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
;	O
int	O
help_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
,	O
size_t	long
*	O
exp_count	*(long)
)	O
;	O
struct	O
argdef	struct(*(char),int,int)
{	O
char	O
*	O
name	*(char)
;	O
int	O
type	int
;	O
int	O
ds	*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char)))))
;	O
}	O
;	O
enum	O
command_repeat_type	enum(int,int,int)
{	O
REPEAT_NEVER	int
,	O
REPEAT_ALWAYS	int
,	O
REPEAT_NOARG	int
}	O
;	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
{	O
char	O
*	O
name	*(char)
;	O
size_t	long
len	int
;	O
int	O
tok	int
;	O
int	O
(	O
*	O
begin	*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int))
)	O
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
,	O
size_t	long
*	O
)	O
;	O
void	O
(	O
*	O
handler	*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void))
)	O
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
;	O
void	O
(	O
*	O
end	struct(*(char),int,int)
)	O
(	O
void	O
*	O
data	*(void)
)	O
;	O
struct	O
argdef	struct(*(char),int,int)
args	array(struct(*(char),int,int))
[	O
NARGS	int
]	O
;	O
int	O
variadic	int
;	O
enum	O
command_repeat_type	enum(int,int,int)
repeat	enum(int,int,int)
;	O
char	O
*	O
doc	*(char)
;	O
}	O
;	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
[	O
]	O
=	O
{	O
{	O
S	O
(	O
count	int
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
count_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"count (number of entries)"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
delete	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
delete_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"delete a record"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
export	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
export_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[truncate]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[binary|ascii]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"export"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
fetch	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
fetch_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"fetch record"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
import	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
import_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[replace]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[nometa]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
FALSE	int
,	O
N_	O
(	O
"import"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
list	O
)	O
,	O
T_CMD	int
,	O
list_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
list_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"list"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
nextkey_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"[KEY]"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NOARG	int
,	O
N_	O
(	O
"nextkey"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
store	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
store_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
N_	O
(	O
"DATA"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_CONTENT	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"store"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
first	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
firstkey_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"firstkey"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
reorganize	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
reorganize_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"reorganize"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
recover	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
recover_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
"[verbose]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[summary]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[backup]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[force]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failed-keys=N]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failed-buckets=N]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failures=N]"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"recover the database"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
avail	struct(int,int,long,array(struct(int,long)))
)	O
,	O
T_CMD	int
,	O
avail_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
avail_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print avail list"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
,	O
T_CMD	int
,	O
print_bucket_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
print_current_bucket_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print a bucket"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
current	O
)	O
,	O
T_CMD	int
,	O
print_current_bucket_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
print_current_bucket_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print current bucket"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
dir	long
)	O
,	O
T_CMD	int
,	O
print_dir_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
print_dir_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print hash directory"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
)	O
,	O
T_CMD	int
,	O
print_header_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
print_header_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print database file header"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
hash	*(int)
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
hash_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	*(char)
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"hash value of key"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
cache	O
)	O
,	O
T_CMD	int
,	O
print_cache_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
print_cache_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print the bucket cache"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
status	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
status_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print current program status"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
version	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
print_version_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print version of gdbm"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
help	O
)	O
,	O
T_CMD	int
,	O
help_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
,	O
help_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print this help list"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
quit	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
quit_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"quit the program"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
set	O
)	O
,	O
T_SET	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"[VAR=VALUE...]"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"set or list variables"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
unset	O
)	O
,	O
T_UNSET	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"VAR..."	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"unset variables"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
define	O
)	O
,	O
T_DEF	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"key|content"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"{ FIELD-LIST }"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"define datum structure"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
source	*(char)
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
source_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
"FILE"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"source command script"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
close	(int)->(int)
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
close_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"close the database"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
open	(*(char),int)->(int)
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
open_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
"FILE"	*(char)
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"open new database"	*(char)
)	O
}	O
,	O
{	O
S	O
(	O
debug	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
debug_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
TRUE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"query/set debug level"	*(char)
)	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
cmdcmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	array(int)
,	O
const	O
void	O
*	O
b	array(int)
)	O
{	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
const	O
*	O
ac	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
a	array(int)
;	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
const	O
*	O
bc	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
b	array(int)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
ac	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
->	O
name	*(char)
,	O
bc	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
->	O
name	*(char)
)	O
;	O
}	O
void	O
sort_commands	()->(void)
(	O
)	O
{	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
,	O
sizeof	O
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
)	O
/	O
sizeof	O
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
[	O
0	int
]	O
)	O
-	O
1	int
,	O
sizeof	O
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
[	O
0	int
]	O
)	O
,	O
cmdcmp	(*(void),*(void))->(int)
)	O
;	O
}	O
char	O
*	O
command_generator	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
static	O
int	O
len	int
;	O
static	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
cmd	*(struct)
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
cmd	*(struct)
=	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
cmd	*(struct)
||	O
!	O
cmd	*(struct)
->	O
name	*(char)
)	O
return	O
NULL	O
;	O
while	O
(	O
(	O
name	*(char)
=	O
cmd	*(struct)
->	O
name	*(char)
)	O
)	O
{	O
cmd	*(struct)
++	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
text	*(char)
,	O
len	int
)	O
==	O
0	int
)	O
return	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
int	O
help_begin	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(long))->(int)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	*(long)
)	O
{	O
if	O
(	O
exp_count	*(long)
)	O
*	O
exp_count	*(long)
=	O
sizeof	O
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
)	O
/	O
sizeof	O
(	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
[	O
0	int
]	O
)	O
+	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
help_handler	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
)	O
{	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
cmd	*(struct)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
param	*(struct)
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
for	O
(	O
cmd	*(struct)
=	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
;	O
cmd	*(struct)
->	O
name	*(char)
;	O
cmd	*(struct)
++	O
)	O
{	O
int	O
i	int
;	O
int	O
n	int
;	O
n	int
=	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
cmd	*(struct)
->	O
name	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NARGS	int
&&	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
n	int
+=	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
n	int
<	O
CMDCOLS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%*.s"	*(char)
,	O
CMDCOLS	int
-	O
n	int
,	O
""	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
cmd	*(struct)
->	O
doc	*(char)
)	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
int	O
command_lookup	(*(char),*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
*	O
pcmd	*(*(struct))
)	O
{	O
enum	O
{	O
fcom_init	int
,	O
fcom_found	int
,	O
fcom_ambig	int
,	O
fcom_abort	int
}	O
state	*(int)
=	O
fcom_init	int
;	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
cmd	*(struct)
,	O
*	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
for	O
(	O
cmd	*(struct)
=	O
command_tab	array(struct(*(char),long,int,*((*(struct(int,*`,*`,*`,*`)),*(long))->(int)),*((*(struct(int,*`,*`,*`,*`)))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
;	O
state	*(int)
!=	O
fcom_abort	int
&&	O
cmd	*(struct)
->	O
name	*(char)
;	O
cmd	*(struct)
++	O
)	O
{	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
cmd	*(struct)
->	O
name	*(char)
,	O
str	*(char)
,	O
len	int
<	O
cmd	*(struct)
->	O
len	int
?	O
len	int
:	O
cmd	*(struct)
->	O
len	int
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
fcom_init	int
:	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
cmd	*(struct)
;	O
state	*(int)
=	O
fcom_found	int
;	O
break	O
;	O
case	O
fcom_found	int
:	O
if	O
(	O
!	O
interactive	()->(int)
(	O
)	O
)	O
{	O
state	*(int)
=	O
fcom_abort	int
;	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
continue	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"ambiguous command: %s\n"	*(char)
,	O
str	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"    %s\n"	*(char)
,	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
->	O
name	*(char)
)	O
;	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
NULL	O
;	O
state	*(int)
=	O
fcom_ambig	int
;	O
case	O
fcom_ambig	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"    %s\n"	*(char)
,	O
cmd	*(struct)
->	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
fcom_abort	int
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
state	*(int)
==	O
fcom_init	int
)	O
lerror	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
interactive	()->(int)
(	O
)	O
?	O
_	O
(	O
"Invalid command. Try ? for help."	*(char)
)	O
:	O
_	O
(	O
"Unknown command"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
)	O
return	O
T_BOGUS	int
;	O
*	O
pcmd	*(*(struct))
=	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
;	O
return	O
found	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
->	O
tok	int
;	O
}	O
char	O
*	O
parseopt_program_doc	*(char)
=	O
N_	O
(	O
"examine and/or modify a GDBM database"	*(char)
)	O
;	O
char	O
*	O
parseopt_program_args	*(char)
=	O
N_	O
(	O
"DBFILE [COMMAND [ARG ...]]"	*(char)
)	O
;	O
enum	O
{	O
OPT_LEX_TRACE	int
=	O
256	int
,	O
OPT_GRAM_TRACE	int
}	O
;	O
struct	O
gdbm_option	struct(int,*(char),*(char),*(char),int)
optab	array(struct(int,*(char),*(char),*(char),int))
[	O
]	O
=	O
{	O
{	O
'b'	O
,	O
"block-size"	*(char)
,	O
N_	O
(	O
"SIZE"	*(char)
)	O
,	O
N_	O
(	O
"set block size"	*(char)
)	O
}	O
,	O
{	O
'c'	O
,	O
"cache-size"	*(char)
,	O
N_	O
(	O
"SIZE"	*(char)
)	O
,	O
N_	O
(	O
"set cache size"	*(char)
)	O
}	O
,	O
{	O
'f'	O
,	O
"file"	*(char)
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"read commands from FILE"	*(char)
)	O
}	O
,	O
{	O
'g'	O
,	O
NULL	O
,	O
"FILE"	*(char)
,	O
NULL	O
,	O
PARSEOPT_HIDDEN	int
}	O
,	O
{	O
'l'	O
,	O
"no-lock"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"disable file locking"	*(char)
)	O
}	O
,	O
{	O
'm'	O
,	O
"no-mmap"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"do not use mmap"	*(char)
)	O
}	O
,	O
{	O
'n'	O
,	O
"newdb"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"create database"	*(char)
)	O
}	O
,	O
{	O
'N'	O
,	O
"norc"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"do not read .gdbmtoolrc file"	*(char)
)	O
}	O
,	O
{	O
'r'	O
,	O
"read-only"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"open database in read-only mode"	*(char)
)	O
}	O
,	O
{	O
's'	O
,	O
"synchronize"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"synchronize to disk after each write"	*(char)
)	O
}	O
,	O
{	O
'q'	O
,	O
"quiet"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"don't print initial banner"	*(char)
)	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
gdbmarg_string	(*(char),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
char	O
*	O
string	*(char)
,	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	*(char)
)	O
)	O
;	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
arg	*(char)
->	O
type	int
=	O
GDBM_ARG_STRING	int
;	O
arg	*(char)
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
string	*(char)
=	O
string	*(char)
;	O
return	O
arg	*(char)
;	O
}	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
gdbmarg_datum	(*(struct(*(char),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
datum	struct(*(char),int)
*	O
dat	struct(*(char),int)
,	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	*(char)
)	O
)	O
;	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
arg	*(char)
->	O
type	int
=	O
GDBM_ARG_DATUM	int
;	O
arg	*(char)
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
dat	struct(*(char),int)
=	O
*	O
dat	struct(*(char),int)
;	O
return	O
arg	*(char)
;	O
}	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
gdbmarg_kvpair	(*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
,	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
{	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	*(char)
)	O
)	O
;	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
arg	*(char)
->	O
type	int
=	O
GDBM_ARG_KVPAIR	int
;	O
arg	*(char)
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
=	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
;	O
return	O
arg	*(char)
;	O
}	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
slist_new_s	(*(char))->(*(struct(*(struct(*`,*`)),*(char))))
(	O
char	O
*	O
s	*(char)
)	O
{	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
)	O
;	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
str	*(char)
=	O
s	*(char)
;	O
return	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
slist_new	(*(char))->(*(struct(*(struct(*`,*`)),*(char))))
(	O
char	O
const	O
*	O
s	*(char)
)	O
{	O
return	O
slist_new_s	(*(char))->(*(struct(*(struct(*`,*`)),*(char))))
(	O
estrdup	(*(char))->(*(char))
(	O
s	*(char)
)	O
)	O
;	O
}	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
slist_new_l	(*(char),long)->(*(struct(*(struct(*`,*`)),*(char))))
(	O
char	O
const	O
*	O
s	*(char)
,	O
size_t	long
l	long
)	O
{	O
char	O
*	O
copy	*(char)
=	O
emalloc	(long)->(*(void))
(	O
l	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
copy	*(char)
,	O
s	*(char)
,	O
l	long
)	O
;	O
copy	*(char)
[	O
l	long
]	O
=	O
0	int
;	O
return	O
slist_new_s	(*(char))->(*(struct(*(struct(*`,*`)),*(char))))
(	O
copy	*(char)
)	O
;	O
}	O
void	O
slist_free	(*(struct(*(struct(*`,*`)),*(char))))->(void)
(	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
{	O
while	O
(	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
{	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
str	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
;	O
lp	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
}	O
void	O
slist_insert	(*(*(struct(*(struct`),*(char)))),*(struct(*(struct(*`,*`)),*(char))))->(void)
(	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
*	O
where	*(*(struct(*(struct(*`,*`)),*(char))))
,	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
{	O
if	O
(	O
*	O
where	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
{	O
while	O
(	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
(	O
*	O
where	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
(	O
*	O
where	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
else	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
*	O
where	*(*(struct(*(struct(*`,*`)),*(char))))
=	O
what	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
kvpair_string	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
(	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
char	O
*	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
)	O
{	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
p	*(char)
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
p	*(char)
->	O
type	int
=	O
KV_STRING	int
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
p	*(char)
->	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
.	O
s	*(char)
=	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
;	O
return	O
p	*(char)
;	O
}	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
kvpair_list	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(struct(*(struct(*`,*`)),*(char))))->(*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
(	O
struct	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
struct	O
slist	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
*	O
s	*(char)
)	O
{	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
p	*(char)
=	O
ecalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
p	*(char)
->	O
type	int
=	O
KV_LIST	int
;	O
if	O
(	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
p	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
=	O
*	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
;	O
p	*(char)
->	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
.	O
l	long
=	O
s	*(char)
;	O
return	O
p	*(char)
;	O
}	O
static	O
void	O
kvlist_free	(*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))->(void)
(	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
)	O
{	O
while	O
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
)	O
{	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
*	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
free	(*(void))->(void)
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
->	O
key	struct(*(char),int)
)	O
;	O
switch	O
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
->	O
type	int
)	O
{	O
case	O
KV_STRING	int
:	O
free	(*(void))->(void)
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
->	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
.	O
s	*(char)
)	O
;	O
break	O
;	O
case	O
KV_LIST	int
:	O
slist_free	(*(struct(*(struct(*`,*`)),*(char))))->(void)
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
->	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
.	O
l	long
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
)	O
;	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
=	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
}	O
int	O
gdbmarg_free	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(int)
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
&&	O
--	O
arg	*(char)
->	O
ref	int
==	O
0	int
)	O
{	O
switch	O
(	O
arg	*(char)
->	O
type	int
)	O
{	O
case	O
GDBM_ARG_STRING	int
:	O
free	(*(void))->(void)
(	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
GDBM_ARG_KVPAIR	int
:	O
kvlist_free	(*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))->(void)
(	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
)	O
;	O
break	O
;	O
case	O
GDBM_ARG_DATUM	int
:	O
free	(*(void))->(void)
(	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
dat	struct(*(char),int)
.	O
dptr	*(char)
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
arg	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
gdbmarg_destroy	(*(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))->(void)
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
*	O
parg	*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
)	O
{	O
if	O
(	O
parg	*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
&&	O
gdbmarg_free	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(int)
(	O
*	O
parg	*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
)	O
)	O
*	O
parg	*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
=	O
NULL	O
;	O
}	O
void	O
gdbmarglist_init	(*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(void)
(	O
struct	O
gdbmarglist	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))))
*	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
,	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
)	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
tail	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
arg	*(char)
;	O
}	O
void	O
gdbmarglist_add	(*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(void)
(	O
struct	O
gdbmarglist	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))))
*	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
,	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
)	O
{	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
if	O
(	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
tail	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
)	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
tail	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
arg	*(char)
;	O
else	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
arg	*(char)
;	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
tail	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
arg	*(char)
;	O
}	O
void	O
gdbmarglist_free	(*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))))->(void)
(	O
struct	O
gdbmarglist	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))))
*	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
)	O
{	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
;	O
for	O
(	O
arg	*(char)
=	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
;	O
arg	*(char)
;	O
)	O
{	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
=	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
gdbmarg_free	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(int)
(	O
arg	*(char)
)	O
;	O
arg	*(char)
=	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
;	O
}	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
lst	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
tail	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
NULL	O
;	O
}	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
param	*(struct)
;	O
size_t	long
argmax	long
;	O
void	O
param_free_argv	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int)->(void)
(	O
struct	O
handler_param	struct(int,*(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
param	*(struct)
,	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
gdbmarg_destroy	(*(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))->(void)
(	O
&	O
param	*(struct)
->	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
param	*(struct)
->	O
argc	int
=	O
0	int
;	O
}	O
typedef	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
(	O
*	O
coerce_type_t	*((*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(char),int,int)))->(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
)	O
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
,	O
struct	O
argdef	struct(*(char),int,int)
*	O
def	*(struct(*(char),int,int))
)	O
;	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
coerce_ref	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
,	O
struct	O
argdef	struct(*(char),int,int)
*	O
def	*(struct(*(char),int,int))
)	O
{	O
++	O
arg	*(char)
->	O
ref	int
;	O
return	O
arg	*(char)
;	O
}	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
coerce_k2d	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
,	O
struct	O
argdef	struct(*(char),int,int)
*	O
def	*(struct(*(char),int,int))
)	O
{	O
datum	struct(*(char),int)
d	struct(*(char),int)
;	O
if	O
(	O
datum_scan	(*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))->(int)
(	O
&	O
d	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
def	*(struct(*(char),int,int))
->	O
ds	*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char)))))
]	O
,	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
)	O
)	O
return	O
NULL	O
;	O
return	O
gdbmarg_datum	(*(struct(*(char),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
&	O
d	struct(*(char),int)
,	O
&	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
coerce_s2d	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
,	O
struct	O
argdef	struct(*(char),int,int)
*	O
def	*(struct(*(char),int,int))
)	O
{	O
datum	struct(*(char),int)
d	struct(*(char),int)
;	O
struct	O
kvpair	struct(*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`))))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*(struct(*`,*`)),*(char)))))
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
)	O
)	O
;	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
.	O
type	int
=	O
KV_STRING	int
;	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
.	O
val	union(*(char),*(struct(*(struct(*`,*`)),*(char))))
.	O
s	*(char)
=	O
arg	*(char)
->	O
v	union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))
.	O
string	*(char)
;	O
if	O
(	O
datum_scan	(*(struct(*(char),int)),*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`)))))->(int)
(	O
&	O
d	struct(*(char),int)
,	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
def	*(struct(*(char),int,int))
->	O
ds	*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char)))))
]	O
,	O
&	O
kvp	*(struct(*(struct(*(struct`),int,struct(struct`,struct`),*(char),union(*`,*`))),int,struct(struct(*(char),int,int),struct(*(char),int,int)),*(char),union(*(char),*(struct(*`,*`)))))
)	O
)	O
return	O
NULL	O
;	O
return	O
gdbmarg_datum	(*(struct(*(char),int)),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
&	O
d	struct(*(char),int)
,	O
&	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
)	O
;	O
}	O
coerce_type_t	*((*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(char),int,int)))->(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
coerce_tab	array(array(*((*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(char),int,int)))->(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))))
[	O
GDBM_ARG_MAX	int
]	O
[	O
GDBM_ARG_MAX	int
]	O
=	O
{	O
{	O
coerce_ref	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
,	O
coerce_fail	O
,	O
coerce_fail	O
}	O
,	O
{	O
coerce_s2d	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
,	O
coerce_ref	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
,	O
coerce_k2d	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
}	O
,	O
{	O
coerce_fail	O
,	O
coerce_fail	O
,	O
coerce_ref	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
}	O
}	O
;	O
char	O
*	O
argtypestr	array(*(char))
[	O
]	O
=	O
{	O
"string"	*(char)
,	O
"datum"	*(char)
,	O
"k/v pair"	*(char)
}	O
;	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
coerce	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
,	O
struct	O
argdef	struct(*(char),int,int)
*	O
def	*(struct(*(char),int,int))
)	O
{	O
if	O
(	O
!	O
coerce_tab	array(array(*((*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(char),int,int)))->(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))))
[	O
def	*(struct(*(char),int,int))
->	O
type	int
]	O
[	O
arg	*(char)
->	O
type	int
]	O
)	O
{	O
lerror	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),*(char))->(void)
(	O
&	O
arg	*(char)
->	O
loc	*(struct(struct(*(char),int,int),struct(*(char),int,int)))
,	O
_	O
(	O
"cannot coerce %s to %s"	*(char)
)	O
,	O
argtypestr	array(*(char))
[	O
arg	*(char)
->	O
type	int
]	O
,	O
argtypestr	array(*(char))
[	O
def	*(struct(*(char),int,int))
->	O
type	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
coerce_tab	array(array(*((*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(char),int,int)))->(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))))
[	O
def	*(struct(*(char),int,int))
->	O
type	int
]	O
[	O
arg	*(char)
->	O
type	int
]	O
(	O
arg	*(char)
,	O
def	*(struct(*(char),int,int))
)	O
;	O
}	O
static	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
last_cmd	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
;	O
static	O
struct	O
gdbmarglist	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))))
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
;	O
void	O
run_last_command	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
interactive	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
last_cmd	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
)	O
{	O
switch	O
(	O
last_cmd	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
->	O
repeat	enum(int,int,int)
)	O
{	O
case	O
REPEAT_NEVER	int
:	O
break	O
;	O
case	O
REPEAT_NOARG	int
:	O
gdbmarglist_free	(*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))))->(void)
(	O
&	O
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
)	O
;	O
case	O
REPEAT_ALWAYS	int
:	O
if	O
(	O
run_command	(*(struct),*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))))->(int)
(	O
last_cmd	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
,	O
&	O
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
)	O
)	O
exit	(int)->(void)
(	O
EXIT_USAGE	int
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
int	O
run_command	(*(struct),*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))))->(int)
(	O
struct	O
command	struct(*(char),long,int,*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int)),*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char))
*	O
cmd	*(struct)
,	O
struct	O
gdbmarglist	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))))
*	O
arglist	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
)	O
{	O
int	O
i	int
;	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
arg	*(char)
;	O
char	O
*	O
pager	*(char)
=	O
NULL	O
;	O
char	O
argbuf	array(char)
[	O
128	int
]	O
;	O
size_t	long
expected_lines	long
,	O
*	O
expected_lines_ptr	*(long)
;	O
FILE	struct
*	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
variable_get	(*(char),int,*(*(void)))->(int)
(	O
"pager"	*(char)
,	O
VART_STRING	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
pager	*(char)
)	O
;	O
arg	*(char)
=	O
arglist	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
?	O
arglist	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
:	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
.	O
name	*(char)
&&	O
arg	*(char)
;	O
i	int
++	O
,	O
arg	*(char)
=	O
arg	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char))),*(char)))
)	O
{	O
if	O
(	O
i	int
>=	O
argmax	long
)	O
{	O
argmax	long
+=	O
ARGINC	int
;	O
param	*(struct)
.	O
argv	*(*(char))
=	O
erealloc	(*(void),long)->(*(void))
(	O
param	*(struct)
.	O
argv	*(*(char))
,	O
sizeof	O
(	O
param	*(struct)
.	O
argv	*(*(char))
[	O
0	int
]	O
)	O
*	O
argmax	long
)	O
;	O
}	O
if	O
(	O
(	O
param	*(struct)
.	O
argv	*(*(char))
[	O
i	int
]	O
=	O
coerce	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
arg	*(char)
,	O
&	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
param_free_argv	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int)->(void)
(	O
&	O
param	*(struct)
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
for	O
(	O
;	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
{	O
char	O
*	O
argname	*(char)
=	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
struct	O
gdbmarg	struct(*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`))))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*(struct(*`,int,struct`,*`,union`)),int,struct(struct(*`,int,int),struct(*`,int,int)),*(char),union(*(char),*(struct`))))))
*	O
t	int
;	O
if	O
(	O
*	O
argname	*(char)
==	O
'['	O
)	O
break	O
;	O
if	O
(	O
!	O
interactive	()->(int)
(	O
)	O
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"%s: not enough arguments"	*(char)
)	O
,	O
cmd	*(struct)
->	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
"%s? "	*(char)
,	O
argname	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
argbuf	array(char)
,	O
sizeof	O
argbuf	array(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"unexpected eof"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_USAGE	int
)	O
;	O
}	O
trimnl	(*(char))->(int)
(	O
argbuf	array(char)
)	O
;	O
if	O
(	O
i	int
>=	O
argmax	long
)	O
{	O
argmax	long
+=	O
ARGINC	int
;	O
param	*(struct)
.	O
argv	*(*(char))
=	O
erealloc	(*(void),long)->(*(void))
(	O
param	*(struct)
.	O
argv	*(*(char))
,	O
sizeof	O
(	O
param	*(struct)
.	O
argv	*(*(char))
[	O
0	int
]	O
)	O
*	O
argmax	long
)	O
;	O
}	O
t	int
=	O
gdbmarg_string	(*(char),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
estrdup	(*(char))->(*(char))
(	O
argbuf	array(char)
)	O
,	O
&	O
yylloc	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
if	O
(	O
(	O
param	*(struct)
.	O
argv	*(*(char))
[	O
i	int
]	O
=	O
coerce	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(char),int,int)))->(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
(	O
t	int
,	O
&	O
cmd	*(struct)
->	O
args	array(struct(*(char),int,int))
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
gdbmarg_free	(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))->(int)
(	O
t	int
)	O
;	O
param_free_argv	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int)->(void)
(	O
&	O
param	*(struct)
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
arg	*(char)
&&	O
!	O
cmd	*(struct)
->	O
variadic	int
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"%s: too many arguments"	*(char)
)	O
,	O
cmd	*(struct)
->	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
param	*(struct)
.	O
argc	int
=	O
i	int
;	O
if	O
(	O
!	O
param	*(struct)
.	O
argv	*(*(char))
)	O
{	O
argmax	long
=	O
ARGINC	int
;	O
param	*(struct)
.	O
argv	*(*(char))
=	O
ecalloc	(long,long)->(*(void))
(	O
argmax	long
,	O
sizeof	O
(	O
param	*(struct)
.	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
}	O
param	*(struct)
.	O
argv	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
param	*(struct)
.	O
vararg	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
=	O
arg	*(char)
;	O
param	*(struct)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
param	*(struct)
.	O
data	*(void)
=	O
NULL	O
;	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
expected_lines	long
=	O
0	int
;	O
expected_lines_ptr	*(long)
=	O
(	O
interactive	()->(int)
(	O
)	O
&&	O
pager	*(char)
)	O
?	O
&	O
expected_lines	long
:	O
NULL	O
;	O
if	O
(	O
!	O
(	O
cmd	*(struct)
->	O
begin	*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int))
&&	O
cmd	*(struct)
->	O
begin	*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))),*(long))->(int))
(	O
&	O
param	*(struct)
,	O
expected_lines_ptr	*(long)
)	O
)	O
)	O
{	O
if	O
(	O
pager	*(char)
&&	O
expected_lines	long
>	O
get_screen_lines	()->(int)
(	O
)	O
)	O
{	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pager	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
param	*(struct)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"cannot run pager `%s': %s"	*(char)
)	O
,	O
pager	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
pager	*(char)
=	O
NULL	O
;	O
param	*(struct)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
}	O
else	O
param	*(struct)
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
cmd	*(struct)
->	O
handler	*((*(struct(int,*(*`),*(struct`),*(struct`),*(void))))->(void))
(	O
&	O
param	*(struct)
)	O
;	O
if	O
(	O
cmd	*(struct)
->	O
end	struct(*(char),int,int)
)	O
cmd	*(struct)
->	O
end	struct(*(char),int,int)
(	O
param	*(struct)
.	O
data	*(void)
)	O
;	O
else	O
if	O
(	O
param	*(struct)
.	O
data	*(void)
)	O
free	(*(void))->(void)
(	O
param	*(struct)
.	O
data	*(void)
)	O
;	O
if	O
(	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pagfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
param_free_argv	(*(struct(int,*(*(struct`)),*(struct(*`,int,int,struct`,union`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int)->(void)
(	O
&	O
param	*(struct)
,	O
param	*(struct)
.	O
argc	int
)	O
;	O
last_cmd	*(struct(*(char),long,int,*((*(struct`),*(long))->(int)),*((*(struct`))->(void)),*((*(void))->(void)),array(struct(*(char),int,int)),int,enum(int,int,int),*(char)))
=	O
cmd	*(struct)
;	O
if	O
(	O
arglist	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
->	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
!=	O
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
.	O
head	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),int,int,struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(char),struct(*(char),int),*(struct(*`,int,struct`,*`,union`)))))
)	O
{	O
gdbmarglist_free	(*(struct(*(struct(*`,int,int,struct`,union`)),*(struct(*`,int,int,struct`,union`)))))->(void)
(	O
&	O
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
)	O
;	O
last_args	struct(*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))),*(struct(*(struct(*`,int,int,struct`,union`)),int,int,struct(struct(*`,int,int),struct(*`,int,int)),union(*(char),struct(*`,int),*(struct`)))))
=	O
*	O
arglist	*(struct(*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`))),*(struct(*(struct`),int,int,struct(struct`,struct`),union(*`,struct`,*`)))))
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
source_rcfile	()->(void)
(	O
void	O
)	O
{	O
instream_t	*(struct)
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
=	O
NULL	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
GDBMTOOLRC	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
=	O
instream_file_create	(*(char))->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
GDBMTOOLRC	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
fname	*(char)
;	O
char	O
*	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
!	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"cannot find home directory"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
p	*(char)
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
;	O
}	O
fname	*(char)
=	O
mkfilename	(*(char),*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
GDBMTOOLRC	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
fname	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
=	O
instream_file_create	(*(char))->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
GDBMTOOLRC	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
fname	*(char)
)	O
;	O
}	O
if	O
(	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
)	O
{	O
if	O
(	O
input_context_push	(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))->(int)
(	O
istr	*(struct(*(char),int,*((*(struct`),*(char),long)->(long)),*((*(struct`))->(void)),*((*(struct`),*(struct`))->(int))))
)	O
)	O
exit	(int)->(void)
(	O
EXIT_FATAL	int
)	O
;	O
yyparse	()->(int)
(	O
)	O
;	O
}	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
opt	int
;	O
int	O
bv	int
;	O
int	O
norc	int
=	O
0	int
;	O
int	O
res	int
;	O
char	O
*	O
source	*(char)
=	O
NULL	O
;	O
instream_t	*(struct)
input	*(char)
=	O
NULL	O
;	O
set_progname	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
sort_commands	()->(void)
(	O
)	O
;	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_KEY	int
]	O
=	O
dsegm_new_field	(*(struct(*(char),int,*((*`,*`,int)->(int)),*((*`,*`)->(int)))),*(char),int)->(*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))
(	O
datadef_lookup	(*(char))->(*(struct(*(char),int,*((*`,*`,int)->(int)),*((*`,*`)->(int)))))
(	O
"string"	*(char)
)	O
,	O
NULL	O
,	O
1	int
)	O
;	O
dsdef	array(*(struct(*(struct(*(struct`),int,union(int,struct`))),int,union(int,struct(*(struct`),int,*(char))))))
[	O
DS_CONTENT	int
]	O
=	O
dsegm_new_field	(*(struct(*(char),int,*((*`,*`,int)->(int)),*((*`,*`)->(int)))),*(char),int)->(*(struct(*(struct(*`,int,union`)),int,union(int,struct(*`,int,*`)))))
(	O
datadef_lookup	(*(char))->(*(struct(*(char),int,*((*`,*`,int)->(int)),*((*`,*`)->(int)))))
(	O
"string"	*(char)
)	O
,	O
NULL	O
,	O
1	int
)	O
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"open"	*(char)
,	O
VART_STRING	int
,	O
"wrcreat"	*(char)
)	O
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"pager"	*(char)
,	O
VART_STRING	int
,	O
getenv	(*(char))->(*(char))
(	O
"PAGER"	*(char)
)	O
)	O
;	O
input_init	()->(void)
(	O
)	O
;	O
lex_trace	(int)->(void)
(	O
0	int
)	O
;	O
for	O
(	O
opt	int
=	O
parseopt_first	(int,*(*(char)),*(struct(int,*(char),*(char),*(char),int)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
optab	array(struct(int,*(char),*(char),*(char),int))
)	O
;	O
opt	int
!=	O
EOF	O
;	O
opt	int
=	O
parseopt_next	()->(int)
(	O
)	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'f'	O
:	O
source	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'l'	O
:	O
bv	int
=	O
0	int
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"lock"	*(char)
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
bv	int
=	O
0	int
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"mmap"	*(char)
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
bv	int
=	O
1	int
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"sync"	*(char)
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
variable_set	(*(char),int,*(void))->(int)
(	O
"open"	*(char)
,	O
VART_STRING	int
,	O
"readonly"	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
variable_set	(*(char),int,*(void))->(int)
(	O
"open"	*(char)
,	O
VART_STRING	int
,	O
"newdb"	*(char)
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
norc	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
variable_set	(*(char),int,*(void))->(int)
(	O
"cachesize"	*(char)
,	O
VART_STRING	int
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
variable_set	(*(char),int,*(void))->(int)
(	O
"blocksize"	*(char)
,	O
VART_STRING	int
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
file_name	*(char)
=	O
estrdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
bv	int
=	O
1	int
;	O
variable_set	(*(char),int,*(void))->(int)
(	O
"quiet"	*(char)
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
OPT_LEX_TRACE	int
:	O
lex_trace	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_GRAM_TRACE	int
:	O
gram_trace	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
terror	(*(char))->(void)
(	O
_	O
(	O
"unknown option; try `%s -h' for more info"	*(char)
)	O
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_USAGE	int
)	O
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	*(*(char))
+=	O
optind	int
;	O
if	O
(	O
source	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
source	*(char)
,	O
"-"	*(char)
)	O
)	O
{	O
input	*(char)
=	O
instream_file_create	(*(char))->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
source	*(char)
)	O
;	O
if	O
(	O
!	O
input	*(char)
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
>=	O
1	int
)	O
{	O
file_name	*(char)
=	O
estrdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
if	O
(	O
argc	int
)	O
{	O
if	O
(	O
input	*(char)
)	O
{	O
terror	(*(char))->(void)
(	O
_	O
(	O
"--file and command cannot be used together"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_USAGE	int
)	O
;	O
}	O
input	*(char)
=	O
instream_argv_create	(int,*(*(char)))->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
if	O
(	O
!	O
input	*(char)
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
param	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
param	*(struct)
)	O
)	O
;	O
argmax	long
=	O
0	int
;	O
if	O
(	O
!	O
norc	int
)	O
source_rcfile	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
input	*(char)
)	O
input	*(char)
=	O
instream_stdin_create	()->(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))
(	O
)	O
;	O
if	O
(	O
instream_interactive	(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))->(int)
(	O
input	*(char)
)	O
&&	O
!	O
variable_is_true	(*(char))->(int)
(	O
"quiet"	*(char)
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nWelcome to the gdbm tool.  Type ? for help.\n\n"	*(char)
)	O
)	O
;	O
if	O
(	O
input_context_push	(*(struct(*(char),int,*((*`,*`,long)->(long)),*((*`)->(void)),*((*`,*`)->(int)))))->(int)
(	O
input	*(char)
)	O
)	O
exit	(int)->(void)
(	O
EXIT_FATAL	int
)	O
;	O
res	int
=	O
yyparse	()->(int)
(	O
)	O
;	O
closedb	()->(void)
(	O
)	O
;	O
input_done	()->(void)
(	O
)	O
;	O
return	O
res	int
;	O
}	O
