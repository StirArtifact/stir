__BEGIN_DECLARATIONS	O
static	O
void	O
var_warning	(int,int,*(char),*(char),long)->(void)
__P_	O
(	O
(	O
const	O
int	O
exit_status	int
,	O
const	O
int	O
var_name	*(char)
,	O
const	O
char	O
*	O
line_buffer	*(char)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
long	O
line_number	long
)	O
)	O
;	O
__END_DECLARATIONS	O
Bool	int
rc_valid_day	(*(char),int,int,int)->(int)
(	O
date_text	*(char)
,	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
char	O
*	O
date_text	*(char)
;	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
wd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
auto	O
const	O
char	O
*	O
ptr_date_text	*(char)
=	O
date_text	*(char)
;	O
auto	O
Bool	int
hd_found	int
;	O
static	O
Bool	int
inclusive_weekday_map	array(int)
[	O
DAY_MAX	int
+	O
1	int
]	O
;	O
static	O
Bool	int
exclusive_weekday_map	array(int)
[	O
DAY_MAX	int
+	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
DAY_MAX	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
!	O
(	O
exclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
TRUE	O
)	O
;	O
*	O
inclusive_weekday_map	array(int)
=	O
*	O
exclusive_weekday_map	array(int)
=	O
FALSE	O
;	O
while	O
(	O
*	O
ptr_date_text	*(char)
)	O
{	O
hd_found	int
=	O
FALSE	O
;	O
switch	O
(	O
*	O
ptr_date_text	*(char)
)	O
{	O
case	O
RC_EX_LHDY_CHAR	char
:	O
case	O
RC_EX_AHDY_CHAR	char
:	O
if	O
(	O
hd_ldays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
hd_found	int
=	O
TRUE	O
;	O
if	O
(	O
hd_found	int
||	O
*	O
ptr_date_text	*(char)
==	O
RC_EX_LHDY_CHAR	char
)	O
{	O
if	O
(	O
hd_found	int
)	O
{	O
exclusive_weekday_map	array(int)
[	O
wd	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
hd_mdays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
exclusive_weekday_map	array(int)
[	O
wd	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
RC_EX_NLHDY_CHAR	char
:	O
case	O
RC_EX_NAHDY_CHAR	char
:	O
if	O
(	O
hd_ldays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
hd_found	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_found	int
||	O
*	O
ptr_date_text	*(char)
==	O
RC_EX_NLHDY_CHAR	char
)	O
{	O
if	O
(	O
hd_found	int
)	O
inclusive_weekday_map	array(int)
[	O
wd	int
]	O
=	O
TRUE	O
;	O
*	O
inclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_mdays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
hd_found	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_found	int
)	O
inclusive_weekday_map	array(int)
[	O
wd	int
]	O
=	O
TRUE	O
;	O
*	O
inclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
DAY_MIN	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
DAY_MIN	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_TUE_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
2	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NTUE_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
2	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_WED_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
3	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NWED_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
3	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_THU_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
4	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NTHU_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
4	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_FRI_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
5	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NFRI_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
5	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_SAT_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
6	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NSAT_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
6	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_SUN_CHAR	char
:	O
exclusive_weekday_map	array(int)
[	O
DAY_MAX	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NSUN_CHAR	char
:	O
*	O
inclusive_weekday_map	array(int)
=	O
inclusive_weekday_map	array(int)
[	O
DAY_MAX	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_2_THU_CHAR	char
:	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
exclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_2_THU_CHAR	char
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_2_FRI_CHAR	char
:	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
5	int
;	O
i	int
++	O
)	O
exclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array(int)
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_2_FRI_CHAR	char
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
5	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array(int)
[	O
i	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
ptr_date_text	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
inclusive_weekday_map	array(int)
||	O
*	O
exclusive_weekday_map	array(int)
)	O
{	O
if	O
(	O
*	O
inclusive_weekday_map	array(int)
&&	O
*	O
exclusive_weekday_map	array(int)
)	O
{	O
if	O
(	O
!	O
inclusive_weekday_map	array(int)
[	O
wd	int
]	O
||	O
!	O
exclusive_weekday_map	array(int)
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
inclusive_weekday_map	array(int)
)	O
{	O
if	O
(	O
!	O
inclusive_weekday_map	array(int)
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
exclusive_weekday_map	array(int)
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
rc_valid_period	(*(char),int,int,int,int,int)->(int)
(	O
date_text	*(char)
,	O
d	int
,	O
m	int
,	O
y	int
,	O
incr_year	int
,	O
decr_year	int
)	O
char	O
*	O
date_text	*(char)
;	O
const	O
int	O
d	int
;	O
const	O
int	O
m	int
;	O
const	O
int	O
y	int
;	O
const	O
int	O
incr_year	int
;	O
const	O
int	O
decr_year	int
;	O
{	O
auto	O
Slint	long
num	long
;	O
register	O
int	O
i	int
;	O
static	O
Bool	int
inclusive_date_map	array(int)
[	O
DAY_LAST	int
+	O
2	int
]	O
;	O
static	O
Bool	int
exclusive_date_map	array(int)
[	O
DAY_LAST	int
+	O
2	int
]	O
;	O
auto	O
int	O
len	int
;	O
auto	O
int	O
rlen	int
;	O
auto	O
int	O
dd	int
;	O
auto	O
int	O
rdd	int
;	O
auto	O
int	O
mm	int
;	O
auto	O
int	O
rmm	int
;	O
auto	O
int	O
yy	int
;	O
auto	O
int	O
ryy	int
;	O
auto	O
int	O
nn	int
;	O
auto	O
int	O
rnn	int
;	O
auto	O
int	O
hhn	int
;	O
auto	O
int	O
rhn	int
;	O
auto	O
int	O
hhwd	int
;	O
auto	O
int	O
rhwd	int
;	O
auto	O
char	O
*	O
ptr_date_text	*(char)
=	O
date_text	*(char)
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
char	O
special_text_char	char
;	O
auto	O
char	O
ch	char
;	O
auto	O
char	O
hhc	char
;	O
auto	O
char	O
rhc	char
;	O
auto	O
Bool	int
is_weekday_mode	*(int)
;	O
auto	O
Bool	int
ris_weekday_mode	int
;	O
auto	O
Bool	int
is_range	int
;	O
auto	O
Bool	int
dflt_yy_set	int
;	O
auto	O
Bool	int
dflt_ryy_set	int
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<	O
DAY_LAST	int
+	O
2	int
;	O
i	int
++	O
)	O
inclusive_date_map	array(int)
[	O
i	int
]	O
=	O
!	O
(	O
exclusive_date_map	array(int)
[	O
i	int
]	O
=	O
TRUE	O
)	O
;	O
*	O
inclusive_date_map	array(int)
=	O
*	O
exclusive_date_map	array(int)
=	O
FALSE	O
;	O
while	O
(	O
*	O
ptr_date_text	*(char)
)	O
{	O
rhc	char
=	O
'\0'	O
;	O
rlen	int
=	O
rdd	int
=	O
rmm	int
=	O
ryy	int
=	O
rnn	int
=	O
0	int
;	O
is_range	int
=	O
dflt_yy_set	int
=	O
dflt_ryy_set	int
=	O
FALSE	O
;	O
special_text_char	char
=	O
*	O
ptr_date_text	*(char)
++	O
;	O
ptr_char	*(char)
=	O
ptr_date_text	*(char)
;	O
while	O
(	O
*	O
ptr_date_text	*(char)
&&	O
(	O
*	O
ptr_date_text	*(char)
!=	O
*	O
SPLIT_SEP	*(char)
)	O
&&	O
(	O
*	O
ptr_date_text	*(char)
!=	O
RC_DRANGE_CHAR	char
)	O
)	O
ptr_date_text	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_date_text	*(char)
==	O
RC_DRANGE_CHAR	char
)	O
is_range	int
=	O
TRUE	O
;	O
ch	char
=	O
*	O
ptr_date_text	*(char)
;	O
*	O
ptr_date_text	*(char)
=	O
'\0'	O
;	O
(	O
void	O
)	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
ptr_char	*(char)
,	O
lptrs3	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
FALSE	O
,	O
&	O
is_weekday_mode	*(int)
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
&	O
nn	int
,	O
&	O
len	int
,	O
&	O
hhc	char
,	O
&	O
hhn	int
,	O
&	O
hhwd	int
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
-	O
1L	int
,	O
date_text	*(char)
,	O
FALSE	O
)	O
;	O
if	O
(	O
yy	int
==	O
SPECIAL_VALUE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: invalid date given -- %s\n%s\n%s\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
date_text	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
my_exit	(int)->(void)
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
*	O
ptr_date_text	*(char)
=	O
ch	char
;	O
if	O
(	O
is_range	int
)	O
{	O
ptr_char	*(char)
=	O
++	O
ptr_date_text	*(char)
;	O
while	O
(	O
*	O
ptr_date_text	*(char)
&&	O
(	O
*	O
ptr_date_text	*(char)
!=	O
*	O
SPLIT_SEP	*(char)
)	O
)	O
ptr_date_text	*(char)
++	O
;	O
ch	char
=	O
*	O
ptr_date_text	*(char)
;	O
*	O
ptr_date_text	*(char)
=	O
'\0'	O
;	O
(	O
void	O
)	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
ptr_char	*(char)
,	O
lptrs3	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
FALSE	O
,	O
&	O
ris_weekday_mode	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
&	O
rnn	int
,	O
&	O
rlen	int
,	O
&	O
rhc	char
,	O
&	O
rhn	int
,	O
&	O
rhwd	int
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
-	O
1L	int
,	O
date_text	*(char)
,	O
FALSE	O
)	O
;	O
if	O
(	O
ryy	int
==	O
SPECIAL_VALUE	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: invalid date given -- %s\n%s\n%s\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
date_text	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
my_exit	(int)->(void)
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
*	O
ptr_date_text	*(char)
=	O
ch	char
;	O
}	O
if	O
(	O
ch	char
)	O
ptr_date_text	*(char)
++	O
;	O
if	O
(	O
!	O
len	int
)	O
dflt_yy_set	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
rlen	int
)	O
dflt_ryy_set	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
yy	int
)	O
{	O
if	O
(	O
dflt_yy_set	int
)	O
yy	int
=	O
YEAR_MIN	int
;	O
else	O
{	O
yy	int
=	O
year	int
;	O
if	O
(	O
y	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
yy	int
=	O
y	int
;	O
}	O
}	O
if	O
(	O
!	O
ryy	int
)	O
{	O
if	O
(	O
dflt_ryy_set	int
)	O
ryy	int
=	O
YEAR_MAX	int
;	O
else	O
{	O
ryy	int
=	O
year	int
;	O
if	O
(	O
y	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
ryy	int
=	O
y	int
;	O
}	O
}	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
yy	int
-=	O
incr_year	int
;	O
yy	int
+=	O
decr_year	int
;	O
}	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
ryy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
ryy	int
-=	O
incr_year	int
;	O
ryy	int
+=	O
decr_year	int
;	O
}	O
switch	O
(	O
hhc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
+	O
incr_year	int
,	O
(	O
hhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
,	O
(	O
hhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
auto	O
int	O
fiscal_year	int
=	O
yy	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
hhn	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
fiscal_year	int
,	O
(	O
hhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
yy	int
=	O
fiscal_year	int
;	O
}	O
else	O
(	O
void	O
)	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
hhn	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
(	O
hhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
islower	(int)->(int)
(	O
hhc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
)	O
{	O
mm	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
dd	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
;	O
}	O
else	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
)	O
{	O
mm	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
;	O
dd	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
+	O
incr_year	int
,	O
DVar	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
,	O
DVar	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
switch	O
(	O
rhc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
+	O
incr_year	int
,	O
(	O
rhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
,	O
(	O
rhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
auto	O
int	O
fiscal_year	int
=	O
ryy	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rhn	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
fiscal_year	int
,	O
(	O
rhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
ryy	int
=	O
fiscal_year	int
;	O
}	O
else	O
(	O
void	O
)	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rhn	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
(	O
rhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
islower	(int)->(int)
(	O
rhc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
)	O
{	O
rmm	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
rdd	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
;	O
}	O
else	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
)	O
{	O
rmm	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
;	O
rdd	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
+	O
incr_year	int
,	O
DVar	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
,	O
DVar	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
len	int
>	O
len_year_max	int
)	O
len	int
-=	O
len_year_max	int
;	O
else	O
len	int
=	O
0	int
;	O
if	O
(	O
rlen	int
>	O
len_year_max	int
)	O
rlen	int
-=	O
len_year_max	int
;	O
else	O
rlen	int
=	O
0	int
;	O
if	O
(	O
!	O
mm	int
)	O
{	O
if	O
(	O
len	int
>=	O
1	int
)	O
{	O
mm	int
=	O
m	int
;	O
if	O
(	O
len	int
==	O
2	int
)	O
len	int
=	O
0	int
;	O
else	O
len	int
--	O
;	O
}	O
else	O
mm	int
=	O
MONTH_MIN	int
;	O
}	O
else	O
{	O
if	O
(	O
len	int
==	O
2	int
)	O
len	int
=	O
0	int
;	O
else	O
len	int
--	O
;	O
}	O
if	O
(	O
!	O
dd	int
)	O
{	O
if	O
(	O
len	int
>=	O
1	int
)	O
dd	int
=	O
d	int
;	O
else	O
dd	int
=	O
DAY_MIN	int
;	O
}	O
if	O
(	O
!	O
rmm	int
)	O
{	O
if	O
(	O
rlen	int
>=	O
1	int
)	O
{	O
rmm	int
=	O
m	int
;	O
if	O
(	O
rlen	int
==	O
2	int
)	O
rlen	int
=	O
0	int
;	O
else	O
rlen	int
--	O
;	O
}	O
else	O
rmm	int
=	O
MONTH_MAX	int
;	O
}	O
else	O
{	O
if	O
(	O
rlen	int
==	O
2	int
)	O
rlen	int
=	O
0	int
;	O
else	O
rlen	int
--	O
;	O
}	O
if	O
(	O
!	O
rdd	int
)	O
{	O
if	O
(	O
rlen	int
>=	O
1	int
)	O
rdd	int
=	O
d	int
;	O
else	O
{	O
if	O
(	O
rmm	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
rdd	int
=	O
days_of_february	(int)->(int)
(	O
ryy	int
+	O
incr_year	int
)	O
;	O
else	O
rdd	int
=	O
days_of_february	(int)->(int)
(	O
ryy	int
)	O
;	O
}	O
else	O
rdd	int
=	O
dvec	array(int)
[	O
rmm	int
-	O
1	int
]	O
;	O
}	O
}	O
if	O
(	O
dd	int
==	O
99	int
)	O
{	O
if	O
(	O
mm	int
==	O
2	int
)	O
dd	int
=	O
days_of_february	(int)->(int)
(	O
yy	int
)	O
;	O
else	O
dd	int
=	O
dvec	array(int)
[	O
mm	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
rdd	int
==	O
99	int
)	O
{	O
if	O
(	O
rmm	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
rdd	int
=	O
days_of_february	(int)->(int)
(	O
ryy	int
+	O
incr_year	int
)	O
;	O
else	O
rdd	int
=	O
days_of_february	(int)->(int)
(	O
ryy	int
)	O
;	O
}	O
else	O
rdd	int
=	O
dvec	array(int)
[	O
rmm	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
nn	int
)	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
&	O
nn	int
,	O
&	O
is_weekday_mode	*(int)
)	O
;	O
if	O
(	O
rnn	int
)	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
&	O
rnn	int
,	O
&	O
ris_weekday_mode	int
)	O
;	O
if	O
(	O
(	O
!	O
is_range	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
ryy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
)	O
{	O
register	O
int	O
true_year	int
=	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
nn	int
&&	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
||	O
(	O
incr_year	int
&&	O
(	O
rc_tomorrow_flag	int
||	O
rc_week_flag	int
)	O
)	O
)	O
)	O
yy	int
+=	O
incr_year	int
;	O
if	O
(	O
!	O
rnn	int
&&	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
||	O
(	O
incr_year	int
&&	O
(	O
rc_tomorrow_flag	int
||	O
rc_week_flag	int
)	O
)	O
)	O
)	O
ryy	int
+=	O
incr_year	int
;	O
num	long
=	O
d_between	(int,int,int,int,int,int)->(long)
(	O
dd	int
,	O
mm	int
,	O
yy	int
,	O
rdd	int
,	O
rmm	int
,	O
ryy	int
)	O
;	O
if	O
(	O
num	long
>=	O
0L	int
)	O
{	O
register	O
int	O
s_doy	int
=	O
DAY_MIN	int
;	O
register	O
int	O
e_doy	int
=	O
DAY_LAST	int
+	O
1	int
;	O
if	O
(	O
special_text_char	char
==	O
RC_IDATE_CHAR	char
)	O
*	O
inclusive_date_map	array(int)
=	O
TRUE	O
;	O
else	O
*	O
exclusive_date_map	array(int)
=	O
TRUE	O
;	O
if	O
(	O
yy	int
==	O
true_year	int
)	O
s_doy	int
=	O
day_of_year	(int,int,int)->(int)
(	O
dd	int
,	O
mm	int
,	O
yy	int
)	O
;	O
else	O
if	O
(	O
yy	int
>	O
true_year	int
)	O
s_doy	int
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
ryy	int
==	O
true_year	int
)	O
e_doy	int
=	O
day_of_year	(int,int,int)->(int)
(	O
rdd	int
,	O
rmm	int
,	O
ryy	int
)	O
;	O
else	O
if	O
(	O
ryy	int
<	O
true_year	int
)	O
e_doy	int
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
(	O
s_doy	int
!=	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
e_doy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
if	O
(	O
special_text_char	char
==	O
RC_IDATE_CHAR	char
)	O
for	O
(	O
i	int
=	O
s_doy	int
;	O
i	int
<=	O
e_doy	int
;	O
i	int
++	O
)	O
inclusive_date_map	array(int)
[	O
i	int
]	O
=	O
TRUE	O
;	O
else	O
for	O
(	O
i	int
=	O
s_doy	int
;	O
i	int
<=	O
e_doy	int
;	O
i	int
++	O
)	O
exclusive_date_map	array(int)
[	O
i	int
]	O
=	O
FALSE	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
*	O
inclusive_date_map	array(int)
||	O
*	O
exclusive_date_map	array(int)
)	O
{	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
year	int
+	O
incr_year	int
-	O
decr_year	int
)	O
;	O
if	O
(	O
*	O
inclusive_date_map	array(int)
&&	O
*	O
exclusive_date_map	array(int)
)	O
{	O
if	O
(	O
!	O
inclusive_date_map	array(int)
[	O
i	int
]	O
||	O
!	O
exclusive_date_map	array(int)
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
inclusive_date_map	array(int)
)	O
{	O
if	O
(	O
!	O
inclusive_date_map	array(int)
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
exclusive_date_map	array(int)
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
void	O
rc_clean_flags	()->(void)
(	O
)	O
{	O
rc_tomorrow_flag	int
=	O
rc_week_flag	int
=	O
rc_month_flag	int
=	O
rc_year_flag	int
=	O
rc_week_year_flag	int
=	O
rc_forwards_flag	int
=	O
rc_backwards_flag	int
=	O
rc_period_flag	int
=	O
FALSE	O
;	O
}	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
*	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
the_line	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
is_rc_file	int
,	O
is_weekday_mode	*(int)
,	O
d	int
,	O
m	int
,	O
y	int
,	O
n	long
,	O
len	int
,	O
hc	char
,	O
hn	int
,	O
hwd	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
on_error_exit	int
)	O
char	O
*	O
the_line	*(char)
;	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
*	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
;	O
const	O
Bool	int
is_rc_file	int
;	O
Bool	int
*	O
is_weekday_mode	*(int)
;	O
int	O
*	O
d	int
;	O
int	O
*	O
m	int
;	O
int	O
*	O
y	int
;	O
int	O
*	O
n	long
;	O
int	O
*	O
len	int
;	O
char	O
*	O
hc	char
;	O
int	O
*	O
hn	int
;	O
int	O
*	O
hwd	int
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
const	O
char	O
*	O
line_buffer	*(char)
;	O
const	O
Bool	int
on_error_exit	int
;	O
{	O
register	O
int	O
num_of_range_chars	int
=	O
0	int
;	O
register	O
int	O
num_of_repeat_chars	int
=	O
0	int
;	O
register	O
int	O
num_of_appears_chars	int
=	O
0	int
;	O
register	O
int	O
i	int
;	O
static	O
char	O
str7	array(char)
[	O
8	int
]	O
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
Bool	int
is_hdy_mode	int
=	O
FALSE	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
=	O
FALSE	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
(	O
*	O
len	int
)	O
=	O
(	O
*	O
hn	int
)	O
=	O
(	O
*	O
hwd	int
)	O
=	O
(	O
*	O
n	long
)	O
=	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
isdigit	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
i	int
<	O
len_year_max	int
)	O
)	O
str7	array(char)
[	O
i	int
++	O
]	O
=	O
*	O
the_line	*(char)
++	O
;	O
str7	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
y	int
=	O
my_atoi	(*(char))->(int)
(	O
str7	array(char)
)	O
;	O
*	O
len	int
=	O
i	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
i	int
<	O
2	int
)	O
)	O
str7	array(char)
[	O
i	int
++	O
]	O
=	O
*	O
the_line	*(char)
++	O
;	O
if	O
(	O
i	int
)	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
isupper	(int)->(int)
(	O
str7	array(char)
[	O
i	int
-	O
1	int
]	O
)	O
||	O
str7	array(char)
[	O
i	int
-	O
1	int
]	O
==	O
'"'	O
||	O
islower	(int)->(int)
(	O
str7	array(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
)	O
str7	array(char)
[	O
i	int
++	O
]	O
=	O
*	O
the_line	*(char)
++	O
;	O
str7	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
m	int
=	O
my_atoi	(*(char))->(int)
(	O
str7	array(char)
)	O
;	O
if	O
(	O
!	O
*	O
m	int
)	O
*	O
m	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
str7	array(char)
,	O
MOnth	int
)	O
;	O
else	O
if	O
(	O
i	int
==	O
3	int
||	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
!	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_MONTH_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
m	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
i	int
)	O
{	O
*	O
len	int
+=	O
i	int
;	O
if	O
(	O
*	O
str7	array(char)
==	O
RC_HDY_CHAR	char
)	O
{	O
is_hdy_mode	int
=	O
TRUE	O
;	O
if	O
(	O
i	int
==	O
2	int
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
str7	array(char)
==	O
RC_NWD_CHAR	char
)	O
{	O
is_hdy_mode	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
toupper	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
==	O
'D'	O
||	O
toupper	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
==	O
'W'	O
)	O
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
;	O
else	O
{	O
if	O
(	O
i	int
==	O
2	int
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
;	O
else	O
*	O
hc	char
=	O
*	O
str7	array(char)
;	O
}	O
}	O
}	O
if	O
(	O
*	O
m	int
==	O
99	int
)	O
*	O
m	int
=	O
MONTH_MAX	int
;	O
if	O
(	O
!	O
is_hdy_mode	int
&&	O
(	O
*	O
m	int
>	O
MONTH_MAX	int
||	O
(	O
!	O
*	O
m	int
&&	O
(	O
(	O
(	O
i	int
==	O
1	int
)	O
&&	O
!	O
isdigit	(int)->(int)
(	O
*	O
str7	array(char)
)	O
)	O
||	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
str7	array(char)
)	O
||	O
!	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
i	int
==	O
3	int
)	O
&&	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
str7	array(char)
)	O
||	O
!	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
||	O
!	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
2	int
]	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_MONTH_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
m	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
the_line	*(char)
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
i	int
<	O
(	O
(	O
is_hdy_mode	int
)	O
?	O
7	int
:	O
3	int
)	O
)	O
)	O
str7	array(char)
[	O
i	int
++	O
]	O
=	O
*	O
the_line	*(char)
++	O
;	O
str7	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
d	int
=	O
atoi	(*(char))->(int)
(	O
str7	array(char)
)	O
;	O
*	O
len	int
+=	O
i	int
;	O
*	O
is_weekday_mode	*(int)
=	O
FALSE	O
;	O
the_line	*(char)
--	O
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
||	O
(	O
(	O
i	int
<	O
3	int
)	O
&&	O
!	O
is_hdy_mode	int
)	O
)	O
the_line	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_DLIST_CHAR	char
)	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_DRANGE_CHAR	char
)	O
{	O
num_of_range_chars	int
++	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_REPEAT_CHAR	char
)	O
{	O
num_of_repeat_chars	int
++	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
=	O
ptr_char	*(char)
;	O
}	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_APPEARS_CHAR	char
)	O
{	O
num_of_appears_chars	int
++	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
=	O
ptr_char	*(char)
;	O
}	O
ptr_char	*(char)
++	O
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
||	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
)	O
{	O
if	O
(	O
is_rc_file	int
)	O
{	O
if	O
(	O
(	O
num_of_range_chars	int
>	O
1	int
||	O
*	O
ptr_char	*(char)
==	O
RC_DLIST_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_DRANGE_CHAR	char
||	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
&&	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
)	O
||	O
(	O
!	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
&&	O
!	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
&&	O
(	O
num_of_repeat_chars	int
>	O
1	int
||	O
num_of_appears_chars	int
>	O
1	int
)	O
)	O
)	O
&&	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
islower	(int)->(int)
(	O
*	O
hc	char
)	O
&&	O
(	O
*	O
hc	char
!=	O
RC_EASTER_CHAR	char
)	O
&&	O
(	O
*	O
hc	char
!=	O
RC_TODAY_CHAR	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
||	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
)	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
;	O
}	O
else	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
on_error_exit	int
)	O
var_warning	(int,int,*(char),*(char),long)->(void)
(	O
ERR_INVALID_VAR_REFERENCE	int
,	O
(	O
int	O
)	O
*	O
hc	char
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
str7	array(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
(	O
*	O
len	int
)	O
--	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
{	O
the_line	*(char)
++	O
;	O
i	int
++	O
;	O
}	O
*	O
len	int
+=	O
i	int
;	O
}	O
else	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
is_rc_file	int
&&	O
(	O
num_of_repeat_chars	int
||	O
num_of_appears_chars	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
num_of_repeat_chars	int
>	O
1	int
||	O
num_of_appears_chars	int
>	O
1	int
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
is_hdy_mode	int
)	O
{	O
if	O
(	O
!	O
*	O
d	int
)	O
{	O
if	O
(	O
*	O
str7	array(char)
)	O
*	O
d	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
str7	array(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
*	O
d	int
)	O
{	O
*	O
is_weekday_mode	*(int)
=	O
TRUE	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
(	O
*	O
len	int
)	O
--	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
i	int
]	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
str7	array(char)
[	O
i	int
]	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
i	int
>	O
1	int
)	O
&&	O
!	O
isdigit	(int)->(int)
(	O
str7	array(char)
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
{	O
*	O
n	long
=	O
CHR2DIG	O
(	O
*	O
the_line	*(char)
)	O
;	O
if	O
(	O
*	O
n	long
)	O
{	O
if	O
(	O
(	O
*	O
n	long
>	O
5	int
)	O
&&	O
(	O
*	O
n	long
<	O
9	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_NWD_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
n	long
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
the_line	*(char)
)	O
the_line	*(char)
++	O
;	O
if	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
n	long
&&	O
(	O
*	O
d	int
<	O
DAY_MIN	int
||	O
*	O
d	int
>	O
DAY_MAX	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
(	O
*	O
len	int
)	O
++	O
;	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
{	O
the_line	*(char)
++	O
;	O
(	O
*	O
len	int
)	O
++	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
the_line	*(char)
++	O
;	O
if	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
&&	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
i	int
=	O
atoi	(*(char))->(int)
(	O
str7	array(char)
)	O
;	O
ptr_char	*(char)
=	O
str7	array(char)
;	O
if	O
(	O
islower	(int)->(int)
(	O
*	O
hc	char
)	O
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
DES_LIT	*(char)
||	O
isalpha	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
RC_REPEAT_CHAR	char
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
{	O
*	O
hwd	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
ptr_char	*(char)
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
*	O
hwd	int
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
*	O
y	int
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
hc	char
==	O
RC_EASTER_CHAR	char
||	O
*	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
{	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
i	int
,	O
*	O
hwd	int
,	O
d	int
,	O
m	int
,	O
*	O
y	int
,	O
(	O
*	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
y	int
)	O
{	O
*	O
hn	int
=	O
i	int
;	O
*	O
d	int
=	O
(	O
*	O
m	int
)	O
=	O
0	int
;	O
}	O
else	O
{	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
*	O
hc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
||	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
)	O
{	O
if	O
(	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
)	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
;	O
}	O
else	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
i	int
,	O
*	O
hwd	int
,	O
d	int
,	O
m	int
,	O
*	O
y	int
,	O
DVar	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
y	int
)	O
*	O
hn	int
=	O
i	int
;	O
else	O
{	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
on_error_exit	int
)	O
var_warning	(int,int,*(char),*(char),long)->(void)
(	O
ERR_INVALID_VAR_REFERENCE	int
,	O
(	O
int	O
)	O
*	O
hc	char
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
hc	char
==	O
'D'	O
||	O
*	O
hc	char
==	O
'W'	O
)	O
{	O
if	O
(	O
*	O
y	int
==	O
0	int
)	O
{	O
*	O
hn	int
=	O
i	int
;	O
*	O
d	int
=	O
0	int
;	O
*	O
m	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
i	int
,	O
*	O
hwd	int
,	O
hn	int
,	O
d	int
,	O
m	int
,	O
y	int
,	O
(	O
*	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
on_error_exit	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
while	O
(	O
*	O
the_line	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
the_line	*(char)
)	O
)	O
{	O
the_line	*(char)
++	O
;	O
(	O
*	O
len	int
)	O
++	O
;	O
}	O
if	O
(	O
*	O
the_line	*(char)
)	O
the_line	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
is_rc_file	int
)	O
{	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	*(char)
++	O
;	O
}	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->day_part"	*(char)
,	O
0	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
,	O
ptr_char	*(char)
,	O
i	int
)	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_part	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	*(char)
++	O
;	O
}	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->repeat_part"	*(char)
,	O
0	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
,	O
ptr_char	*(char)
,	O
i	int
)	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	*(char)
++	O
;	O
}	O
ptr_char	*(char)
=	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->appears_part"	*(char)
,	O
0	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
,	O
ptr_char	*(char)
,	O
i	int
)	O
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
repeat_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
appears_part	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
!	O
is_hdy_mode	int
&&	O
!	O
*	O
is_weekday_mode	*(int)
&&	O
!	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_list	int
&&	O
!	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
day_range	int
)	O
(	O
*	O
len	int
)	O
--	O
;	O
}	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
->	O
text_part	*(char)
=	O
the_line	*(char)
;	O
return	O
(	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
)	O
;	O
}	O
Bool	int
precomp_nth_wd	(int,int,*(int),*(int),*(int),*(int),enum(int,int,int,int,int,int,int))->(int)
(	O
diff	int
,	O
wd	int
,	O
n	long
,	O
day	int
,	O
month	int
,	O
year	int
,	O
mode	enum(int,int,int,int,int,int,int)
)	O
int	O
diff	int
;	O
const	O
int	O
wd	int
;	O
int	O
*	O
n	long
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
const	O
Cmode_enum	enum(int,int,int,int,int,int,int)
mode	enum(int,int,int,int,int,int,int)
;	O
{	O
register	O
int	O
the_diff	int
=	O
diff	int
;	O
register	O
int	O
j	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
*	O
year	int
)	O
==	O
29	int
)	O
;	O
auto	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
year	int
)	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
{	O
*	O
day	int
=	O
DAY_MIN	int
;	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
wd	int
)	O
{	O
if	O
(	O
the_diff	int
==	O
WEEK_MAX	int
+	O
1	int
||	O
the_diff	int
==	O
99	int
)	O
{	O
i	int
=	O
the_diff	int
;	O
diff	int
=	O
WEEK_MAX	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
the_diff	int
==	O
999	int
)	O
diff	int
=	O
j	int
;	O
i	int
=	O
diff	int
--	O
;	O
}	O
}	O
else	O
{	O
register	O
int	O
k	int
=	O
(	O
iso_week_number	int
)	O
?	O
DAY_MIN	int
:	O
start_day	int
;	O
diff	int
=	O
i	int
=	O
weekno2doy	(int,int,int,int)->(int)
(	O
the_diff	int
,	O
*	O
year	int
,	O
iso_week_number	int
,	O
k	int
)	O
;	O
if	O
(	O
diff	int
>	O
DAY_MIN	int
)	O
{	O
diff	int
--	O
;	O
k	int
=	O
j	int
-	O
diff	int
;	O
if	O
(	O
iso_week_number	int
)	O
j	int
=	O
wd	int
;	O
else	O
j	int
=	O
SYEAR	O
(	O
wd	int
,	O
start_day	int
)	O
;	O
if	O
(	O
(	O
the_diff	int
==	O
99	int
)	O
&&	O
(	O
*	O
year	int
!=	O
YEAR_MAX	int
)	O
&&	O
(	O
j	int
>	O
k	int
)	O
)	O
diff	int
-=	O
DAY_MAX	int
;	O
}	O
else	O
diff	int
=	O
1	int
;	O
if	O
(	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
diff	int
,	O
(	O
days_of_february	(int)->(int)
(	O
*	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
)	O
diff	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
diff	int
,	O
wd	int
,	O
day	int
,	O
month	int
,	O
*	O
year	int
,	O
DVar	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
year	int
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
n	long
=	O
diff	int
;	O
}	O
else	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
wd	int
&&	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
DAy	int
)	O
)	O
{	O
register	O
int	O
year_old	int
=	O
(	O
*	O
year	int
)	O
;	O
if	O
(	O
i	int
)	O
for	O
(	O
diff	int
=	O
DAY_MIN	int
;	O
diff	int
<=	O
DAY_MAX	int
;	O
diff	int
++	O
)	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
(	O
(	O
*	O
day	int
<=	O
DAY_MAX	int
)	O
&&	O
(	O
*	O
year	int
!=	O
year_old	int
)	O
)	O
||	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
)	O
==	O
wd	int
)	O
for	O
(	O
diff	int
=	O
DAY_MIN	int
;	O
diff	int
<=	O
DAY_MAX	int
;	O
diff	int
++	O
)	O
(	O
void	O
)	O
prev_date	(*(int),*(int),*(int))->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
i	int
==	O
WEEK_MAX	int
+	O
1	int
)	O
{	O
i	int
=	O
DAY_MIN	int
;	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
(	O
void	O
)	O
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
WEEK_MAX	int
,	O
wd	int
,	O
&	O
i	int
,	O
month	int
,	O
*	O
year	int
,	O
DVar	int
)	O
;	O
if	O
(	O
(	O
*	O
day	int
==	O
i	int
)	O
&&	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
)	O
!=	O
wd	int
)	O
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
wd	int
||	O
i	int
<	O
DAY_MIN	int
||	O
(	O
(	O
the_diff	int
<=	O
1	int
)	O
&&	O
(	O
*	O
day	int
==	O
DAY_MAX	int
+	O
1	int
)	O
&&	O
(	O
wd	int
==	O
DAY_MIN	int
)	O
)	O
)	O
{	O
if	O
(	O
*	O
day	int
>=	O
DAY_MAX	int
+	O
i	int
)	O
*	O
day	int
-=	O
DAY_MAX	int
;	O
else	O
if	O
(	O
!	O
wd	int
&&	O
(	O
i	int
<	O
DAY_MIN	int
||	O
(	O
(	O
*	O
day	int
==	O
DAY_MIN	int
+	O
1	int
)	O
&&	O
(	O
i	int
==	O
DAY_MIN	int
)	O
)	O
)	O
)	O
(	O
*	O
day	int
)	O
--	O
;	O
if	O
(	O
*	O
day	int
<	O
DAY_MIN	int
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
precomp_date	(int,int,*(int),*(int),int,enum(int,int,int,int,int,int,int))->(int)
(	O
diff	int
,	O
wd	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
mode	enum(int,int,int,int,int,int,int)
)	O
int	O
diff	int
;	O
const	O
int	O
wd	int
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Cmode_enum	enum(int,int,int,int,int,int,int)
mode	enum(int,int,int,int,int,int,int)
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
EAster	int
)	O
&&	O
(	O
year	int
>=	O
EASTER_MIN	int
)	O
&&	O
(	O
year	int
<=	O
EASTER_MAX	O
)	O
)	O
||	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
TOday	int
||	O
mode	enum(int,int,int,int,int,int,int)
==	O
DVar	int
)	O
&&	O
(	O
year	int
>=	O
YEAR_MIN	int
)	O
&&	O
(	O
year	int
<=	O
YEAR_MAX	int
)	O
)	O
)	O
{	O
switch	O
(	O
mode	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
EAster	int
:	O
i	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
)	O
;	O
break	O
;	O
case	O
TOday	int
:	O
*	O
day	int
=	O
act_day	int
;	O
*	O
month	int
=	O
act_month	int
;	O
default	O
:	O
if	O
(	O
!	O
valid_date	(int,int,int)->(int)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
year	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
*	O
day	int
,	O
*	O
month	int
,	O
year	int
)	O
;	O
}	O
if	O
(	O
wd	int
)	O
{	O
if	O
(	O
wd	int
<	O
DAY_MIN	int
||	O
wd	int
>	O
DAY_MAX	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
!	O
diff	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
diff	int
==	O
-	O
99	int
)	O
{	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
*	O
day	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
*	O
month	int
,	O
year	int
,	O
wd	int
,	O
TRUE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
else	O
if	O
(	O
diff	int
==	O
99	int
)	O
{	O
*	O
month	int
=	O
MONTH_MAX	int
;	O
*	O
day	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
*	O
month	int
,	O
year	int
,	O
wd	int
,	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
else	O
{	O
register	O
int	O
act_wd	int
;	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	int
=	O
year	int
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
,	O
(	O
days_of_february	(int)->(int)
(	O
y	int
)	O
==	O
29	int
)	O
,	O
&	O
d	int
,	O
&	O
m	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
if	O
(	O
diff	int
<	O
0	int
)	O
{	O
while	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
(	O
void	O
)	O
prev_date	(*(int),*(int),*(int))->(int)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
i	int
--	O
;	O
}	O
diff	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
(	O
void	O
)	O
next_date	(*(int),*(int),*(int))->(int)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
i	int
++	O
;	O
}	O
diff	int
--	O
;	O
}	O
}	O
if	O
(	O
y	int
!=	O
year	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
+=	O
diff	int
*	O
DAY_MAX	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
diff	int
==	O
-	O
999	int
)	O
i	int
=	O
1	int
;	O
else	O
if	O
(	O
diff	int
==	O
999	int
)	O
i	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
;	O
else	O
i	int
+=	O
diff	int
;	O
}	O
if	O
(	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
,	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
void	O
set_dvar	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),*(char),long,enum(int,int))->(void)
(	O
line_buffer	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
filename	*(char)
,	O
line_number	long
,	O
mode	enum(int,int,int,int,int,int,int)
)	O
const	O
char	O
*	O
line_buffer	*(char)
;	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
*	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
const	O
Var_enum	enum(int,int)
mode	enum(int,int,int,int,int,int,int)
;	O
{	O
register	O
int	O
error	int
=	O
0	int
;	O
auto	O
char	O
dvar	char
=	O
'\0'	O
;	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
line_buffer	*(char)
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
line_buffer	*(char)
)	O
!=	O
RC_EASTER_CHAR	char
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
line_buffer	*(char)
)	O
!=	O
RC_TODAY_CHAR	char
)	O
)	O
{	O
auto	O
int	O
i	int
;	O
auto	O
int	O
len	int
;	O
auto	O
int	O
d	int
=	O
0	int
;	O
auto	O
int	O
m	int
=	O
0	int
;	O
auto	O
int	O
y	int
=	O
year	int
;	O
auto	O
int	O
n	long
;	O
auto	O
const	O
char	O
*	O
ptr_char	*(char)
=	O
line_buffer	*(char)
;	O
auto	O
char	O
op	char
;	O
auto	O
char	O
op2	char
;	O
static	O
char	O
str20	array(char)
[	O
21	int
]	O
;	O
auto	O
Bool	int
is_weekday_mode	*(int)
;	O
auto	O
Bool	int
dvar_with_displacement	int
=	O
FALSE	O
;	O
auto	O
Bool	int
dvar_add_sub	int
=	O
FALSE	O
;	O
auto	O
Bool	int
dvar_inc_dec	int
=	O
FALSE	O
;	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_ASSIGN	*(char)
)	O
{	O
if	O
(	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_ADD	*(char)
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_SUB	*(char)
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
op	char
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
op2	char
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
op2	char
==	O
op	char
||	O
op2	char
==	O
*	O
RC_VAR_ASSIGN	*(char)
)	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
line_buffer	*(char)
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
if	O
(	O
m	int
)	O
{	O
if	O
(	O
op	char
==	O
op2	char
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
dvar_inc_dec	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
dvar_add_sub	int
=	O
TRUE	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_ADD	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_SUB	*(char)
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_SUB	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_ADD	*(char)
)	O
op	char
=	O
*	O
RC_VAR_SUB	*(char)
;	O
else	O
op	char
=	O
*	O
RC_VAR_ADD	*(char)
;	O
}	O
else	O
op	char
=	O
*	O
ptr_char	*(char)
;	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
!	O
error	int
)	O
goto	O
LABEL_compute_dvar	O
;	O
}	O
else	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
else	O
{	O
if	O
(	O
isalpha	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
&&	O
!	O
isalpha	(int)->(int)
(	O
*	O
(	O
ptr_char	*(char)
+	O
1	int
)	O
)	O
)	O
{	O
dvar	char
=	O
op	char
=	O
*	O
ptr_char	*(char)
;	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
if	O
(	O
tolower	(int)->(int)
(	O
dvar	char
)	O
==	O
RC_EASTER_CHAR	char
||	O
tolower	(int)->(int)
(	O
dvar	char
)	O
==	O
RC_TODAY_CHAR	char
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
else	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
{	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
;	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
;	O
}	O
else	O
{	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
;	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
m	int
)	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
DES_LIT	*(char)
||	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
ptr_char	*(char)
--	O
;	O
dvar_with_displacement	int
=	O
TRUE	O
;	O
goto	O
LABEL_compute_dvar	O
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
}	O
else	O
{	O
LABEL_compute_dvar	O
:	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
str20	array(char)
,	O
ptr_char	*(char)
,	O
20	int
)	O
;	O
str20	array(char)
[	O
20	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
dvar_with_displacement	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"%0*d%c%s"	*(char)
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
str20	array(char)
)	O
;	O
else	O
if	O
(	O
dvar_add_sub	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"%0*d%c%c%c%s"	*(char)
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
*	O
line_buffer	*(char)
,	O
op	char
,	O
str20	array(char)
)	O
;	O
else	O
if	O
(	O
dvar_inc_dec	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"%0*d%c%c%c1"	*(char)
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
*	O
line_buffer	*(char)
,	O
op	char
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"%0*d%s"	*(char)
,	O
len_year_max	int
,	O
y	int
,	O
str20	array(char)
)	O
;	O
(	O
void	O
)	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
s5	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
FALSE	O
,	O
&	O
is_weekday_mode	*(int)
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
len	int
,	O
&	O
op	char
,	O
&	O
i	int
,	O
&	O
i	int
,	O
filename	*(char)
,	O
line_number	long
,	O
line_buffer	*(char)
,	O
TRUE	O
)	O
;	O
if	O
(	O
y	int
!=	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
&&	O
(	O
op	char
||	O
is_weekday_mode	*(int)
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
{	O
if	O
(	O
m	int
<	O
MONTH_MIN	int
||	O
m	int
>	O
MONTH_MAX	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
i	int
=	O
dvec	array(int)
[	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
m	int
==	O
2	int
)	O
i	int
+=	O
is_leap_year	int
;	O
if	O
(	O
is_weekday_mode	*(int)
)	O
{	O
if	O
(	O
n	long
==	O
9	int
)	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
i	int
,	O
m	int
,	O
year	int
,	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
m	int
,	O
year	int
,	O
d	int
,	O
TRUE	O
)	O
;	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
d	int
>	O
i	int
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
d	int
==	O
99	int
)	O
d	int
=	O
i	int
;	O
if	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
+	O
1	int
)	O
&&	O
(	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
==	O
28	int
)	O
&&	O
!	O
rc_feb_29_to_feb_28	int
&&	O
!	O
rc_feb_29_to_mar_01	int
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
else	O
{	O
if	O
(	O
d	int
>	O
i	int
)	O
{	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
i	int
=	O
d	int
;	O
}	O
if	O
(	O
d	int
<	O
DAY_MIN	int
||	O
d	int
>	O
i	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
}	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
error	int
)	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
{	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
line_buffer	*(char)
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_month	char
=	O
(	O
char	O
)	O
m	int
;	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
line_buffer	*(char)
)	O
]	O
.	O
dvar_global	struct(char,char)
.	O
dvar_day	char
=	O
(	O
char	O
)	O
d	int
;	O
}	O
else	O
{	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
line_buffer	*(char)
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_month	char
=	O
(	O
char	O
)	O
m	int
;	O
rc_dvar	array(struct(struct(char,char),struct(char,char)))
[	O
IDX	O
(	O
*	O
line_buffer	*(char)
)	O
]	O
.	O
dvar_local	struct(char,char)
.	O
dvar_day	char
=	O
(	O
char	O
)	O
d	int
;	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
if	O
(	O
error	int
)	O
{	O
if	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
&&	O
(	O
error	int
==	O
ERR_ILLEGAL_VAR_DEFINITION	int
||	O
error	int
==	O
ERR_ILLEGAL_VAR_OPERATION	int
)	O
)	O
warning_level	int
=	O
WARN_LVL_MAX	int
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
dvar	char
)	O
dvar	char
=	O
*	O
line_buffer	*(char)
;	O
var_warning	(int,int,*(char),*(char),long)->(void)
(	O
error	int
,	O
(	O
int	O
)	O
dvar	char
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
}	O
}	O
}	O
void	O
set_tvar	(*(char),*(char),long,enum(int,int))->(void)
(	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
,	O
mode	enum(int,int,int,int,int,int,int)
)	O
const	O
char	O
*	O
line_buffer	*(char)
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
const	O
Var_enum	enum(int,int)
mode	enum(int,int,int,int,int,int,int)
;	O
{	O
register	O
int	O
error	int
=	O
0	int
;	O
auto	O
char	O
tvar	char
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_buffer	*(char)
!=	O
RC_TVAR_CHAR	char
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
auto	O
char	O
*	O
ptr_char	*(char)
=	O
(	O
char	O
*	O
)	O
line_buffer	*(char)
;	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
tvar	char
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_ASSIGN	*(char)
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_TVAR_UCMD_ASSIGN	*(char)
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_ADD	*(char)
)	O
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
RC_VAR_SUB	*(char)
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
len	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_tvar	*(char)
;	O
auto	O
char	O
op	char
;	O
auto	O
char	O
op2	char
=	O
'\0'	O
;	O
auto	O
char	O
op3	char
=	O
op2	char
;	O
auto	O
Bool	int
is_quoted	int
=	O
FALSE	O
;	O
auto	O
Bool	int
restore_tvar	int
=	O
FALSE	O
;	O
op	char
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
op	char
)	O
{	O
op2	char
=	O
*	O
ptr_char	*(char)
;	O
if	O
(	O
op2	char
)	O
op3	char
=	O
*	O
(	O
ptr_char	*(char)
+	O
1	int
)	O
;	O
}	O
ptr_tvar	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr_char	*(char)
,	O
RC_TVAR_CHAR	char
)	O
;	O
if	O
(	O
ptr_tvar	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
auto	O
Bool	int
global_tvar_defined	int
;	O
auto	O
Bool	int
local_tvar_set	int
;	O
do	O
{	O
len	int
=	O
(	O
int	O
)	O
(	O
ptr_tvar	*(char)
-	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
len	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
len	int
+	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
s5	*(char)
+	O
i	int
,	O
ptr_char	*(char)
,	O
len	int
)	O
;	O
i	int
+=	O
len	int
;	O
}	O
s5	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	int
)	O
if	O
(	O
s5	*(char)
[	O
i	int
-	O
1	int
]	O
==	O
QUOTE_CHAR	char
)	O
is_quoted	int
=	O
TRUE	O
;	O
ptr_tvar	*(char)
++	O
;	O
if	O
(	O
!	O
is_quoted	int
&&	O
isalpha	(int)->(int)
(	O
*	O
ptr_tvar	*(char)
)	O
)	O
{	O
global_tvar_defined	int
=	O
local_tvar_set	int
=	O
FALSE	O
;	O
if	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
global_tvar_defined	int
=	O
TRUE	O
;	O
if	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
local_tvar_set	int
=	O
TRUE	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
global_tvar_defined	int
&&	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
||	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
&&	O
!	O
local_tvar_set	int
)	O
)	O
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
i	int
+	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
&&	O
local_tvar_set	int
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
while	O
(	O
(	O
Uint	int
)	O
i	int
+	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
*	O
ptr_tvar	*(char)
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
&&	O
global_tvar_defined	int
)	O
||	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
&&	O
(	O
global_tvar_defined	int
||	O
local_tvar_set	int
)	O
)	O
||	O
(	O
(	O
tvar	char
==	O
*	O
ptr_tvar	*(char)
)	O
&&	O
(	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
&&	O
!	O
global_tvar_defined	int
)	O
||	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
&&	O
!	O
global_tvar_defined	int
&&	O
!	O
local_tvar_set	int
)	O
)	O
)	O
)	O
{	O
len	int
+=	O
2	int
;	O
if	O
(	O
j	int
)	O
i	int
+=	O
j	int
;	O
else	O
if	O
(	O
i	int
)	O
if	O
(	O
isspace	(int)->(int)
(	O
s5	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
&&	O
isspace	(int)->(int)
(	O
*	O
(	O
ptr_tvar	*(char)
+	O
1	int
)	O
)	O
)	O
s5	*(char)
[	O
--	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
restore_tvar	int
=	O
TRUE	O
;	O
}	O
else	O
restore_tvar	int
=	O
TRUE	O
;	O
if	O
(	O
restore_tvar	int
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
+	O
1	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s5	*(char)
[	O
i	int
++	O
]	O
=	O
RC_TVAR_CHAR	char
;	O
len	int
++	O
;	O
if	O
(	O
*	O
ptr_tvar	*(char)
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
+	O
1	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s5	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_tvar	*(char)
;	O
len	int
++	O
;	O
}	O
s5	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
ptr_char	*(char)
+=	O
len	int
;	O
ptr_tvar	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ptr_char	*(char)
,	O
RC_TVAR_CHAR	char
)	O
;	O
restore_tvar	int
=	O
is_quoted	int
=	O
FALSE	O
;	O
}	O
while	O
(	O
ptr_tvar	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
i	int
+=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
while	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
ptr_char	*(char)
)	O
;	O
}	O
i	int
++	O
;	O
ptr_char	*(char)
=	O
s5	*(char)
;	O
}	O
else	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ASSIGN	*(char)
||	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
||	O
op	char
==	O
*	O
RC_TVAR_UCMD_ASSIGN	*(char)
)	O
{	O
if	O
(	O
rc_execute_command	int
&&	O
(	O
i	int
>	O
1	int
)	O
&&	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
||	O
op	char
==	O
*	O
RC_TVAR_UCMD_ASSIGN	*(char)
)	O
)	O
{	O
static	O
char	O
*	O
txt2gcal_prgr	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
ptr_tfn	*(char)
;	O
auto	O
char	O
*	O
the_command	*(char)
;	O
ptr_tfn	*(char)
=	O
TMPFILENAME	O
;	O
if	O
(	O
ptr_tfn	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"tmpnam()="	*(char)
,	O
0	int
)	O
;	O
rc_tvar_tfn	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
ptr_tfn	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar_tfn"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_tvar_tfn	*(char)
,	O
ptr_tfn	*(char)
)	O
;	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
rc_tvar_tfn	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_tvar_tfn	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
)	O
i	int
+=	O
(	O
strlen	(*(char))->(long)
(	O
REDIRECT_OUT	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
rc_tvar_tfn	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
txt2gcal_prgr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
txt2gcal_prgr	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_TXT2GCALPROG	*(char)
)	O
;	O
if	O
(	O
txt2gcal_prgr	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
*	O
txt2gcal_prgr	*(char)
)	O
txt2gcal_prgr	*(char)
=	O
TXT2GCAL_PRGR	*(char)
;	O
}	O
else	O
txt2gcal_prgr	*(char)
=	O
TXT2GCAL_PRGR	*(char)
;	O
}	O
i	int
+=	O
(	O
strlen	(*(char))->(long)
(	O
PIPELINE	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
txt2gcal_prgr	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
REDIRECT_OUT	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
rc_tvar_tfn	*(char)
)	O
)	O
;	O
}	O
j	int
=	O
i	int
;	O
the_command	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar_tfn"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
the_command	*(char)
,	O
"%s%s%s"	*(char)
,	O
ptr_char	*(char)
,	O
REDIRECT_OUT	*(char)
,	O
rc_tvar_tfn	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
the_command	*(char)
,	O
"%s%s%s%s%s"	*(char)
,	O
ptr_char	*(char)
,	O
PIPELINE	*(char)
,	O
txt2gcal_prgr	*(char)
,	O
REDIRECT_OUT	*(char)
,	O
rc_tvar_tfn	*(char)
)	O
;	O
i	int
=	O
my_system	(*(char))->(int)
(	O
the_command	*(char)
)	O
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
j	int
+	O
LEN_SINGLE_LINE	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Cannot execute command in file `%s'\nLine: %ld %s"	*(char)
)	O
,	O
filename	*(char)
,	O
line_number	long
,	O
the_command	*(char)
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
the_command	*(char)
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
-	O
9	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
j	int
+	O
9	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"system(%s)="	*(char)
,	O
the_command	*(char)
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
22L	int
,	O
s5	*(char)
,	O
i	int
)	O
;	O
}	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Command executed (exit code=%d) in file `%s'\nLine %ld: %s"	*(char)
)	O
,	O
i	int
,	O
filename	*(char)
,	O
line_number	long
,	O
the_command	*(char)
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
if	O
(	O
i	int
&&	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
)	O
my_exit	(int)->(void)
(	O
ERR_EXTERNAL_CMD_FAILURE	int
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
the_command	*(char)
)	O
;	O
if	O
(	O
!	O
error	int
)	O
{	O
auto	O
long	O
lnumber	long
=	O
0L	int
;	O
auto	O
int	O
llength	int
;	O
auto	O
int	O
in_pool	int
=	O
0	int
;	O
static	O
char	O
rc_nl	array(char)
[	O
2	int
]	O
=	O
{	O
RC_NL_CHAR	char
,	O
'\0'	O
}	O
;	O
auto	O
char	O
*	O
pool	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
ptr_pool	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
b_dummy	int
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
rc_tvar_tfn	*(char)
,	O
0	int
)	O
;	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
rc_tvar_tfn	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_READ_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_tvar_tfn	*(char)
,	O
0	int
)	O
;	O
pool	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
BUF_LEN	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"pool"	*(char)
,	O
0	int
)	O
;	O
j	int
=	O
0	int
;	O
*	O
s5	*(char)
=	O
'\0'	O
;	O
while	O
(	O
(	O
ptr_pool	*(char)
=	O
file_read_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),*(int),*(char),*(char),*(char),*(long),*(int),enum(int,int,int,int,int,int,int),*(int),*(int),*(int))->(*(char))
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
s7	*(char)
,	O
&	O
in_pool	int
,	O
pool	*(char)
,	O
ptr_pool	*(char)
,	O
rc_tvar_tfn	*(char)
,	O
&	O
lnumber	long
,	O
&	O
llength	int
,	O
COmmon	int
,	O
&	O
b_dummy	int
,	O
&	O
b_dummy	int
,	O
&	O
b_dummy	int
)	O
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
j	int
+	O
llength	int
+	O
2	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
*	O
s7	*(char)
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
s7	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
rc_nl	array(char)
)	O
;	O
j	int
+=	O
(	O
llength	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
ptr_char	*(char)
=	O
s7	*(char)
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
i	int
++	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
i	int
=	O
llength	int
-	O
i	int
;	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
pool	*(char)
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	*(char)
)	O
{	O
i	int
=	O
j	int
;	O
s5	*(char)
[	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
s5	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
do	O
{	O
*	O
ptr_char	*(char)
=	O
RC_NL_CHAR	char
;	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
s5	*(char)
,	O
'\n'	O
)	O
;	O
}	O
while	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
ptr_char	*(char)
=	O
s5	*(char)
;	O
}	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rc_tvar_tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
rc_tvar_tfn	*(char)
,	O
0	int
)	O
;	O
j	int
=	O
unlink	(*(char))->(int)
(	O
rc_tvar_tfn	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"unlink(rc_tvar_tfn)="	*(char)
,	O
j	int
)	O
;	O
free	(*(void))->(void)
(	O
rc_tvar_tfn	*(char)
)	O
;	O
rc_tvar_tfn	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
{	O
if	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"rc_tvar[IDX(tvar)].tvar_global.tvar_text"	*(char)
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
else	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
)	O
,	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_global.tvar_text"	*(char)
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct(*(char))
.	O
tvar_text	*(char)
,	O
ptr_char	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	*(char)
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
else	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
,	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	*(char)
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
,	O
ptr_char	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
auto	O
Bool	int
tvar_inc_dec	int
=	O
FALSE	O
;	O
if	O
(	O
op2	char
==	O
op	char
||	O
op2	char
==	O
*	O
RC_VAR_ASSIGN	*(char)
)	O
{	O
if	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
LOcal	int
)	O
{	O
if	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
*	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
{	O
if	O
(	O
op	char
==	O
op2	char
)	O
{	O
if	O
(	O
op3	char
&&	O
!	O
isspace	(int)->(int)
(	O
op3	char
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
{	O
ptr_char	*(char)
=	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_ADD	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_SUB	*(char)
)	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
tvar_inc_dec	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_ADD	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_SUB	*(char)
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_SUB	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
RC_VAR_ADD	*(char)
)	O
op	char
=	O
*	O
RC_VAR_SUB	*(char)
;	O
else	O
op	char
=	O
*	O
RC_VAR_ADD	*(char)
;	O
}	O
else	O
op	char
=	O
*	O
ptr_char	*(char)
;	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
if	O
(	O
!	O
error	int
)	O
{	O
static	O
Slint	long
num	long
;	O
if	O
(	O
tvar_inc_dec	int
)	O
{	O
len	int
=	O
strlen	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
num	long
=	O
atol	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ADD	*(char)
)	O
num	long
++	O
;	O
else	O
num	long
--	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
s5	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
i	int
&&	O
!	O
*	O
ptr_char	*(char)
)	O
{	O
s5	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
num	long
=	O
atol	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ADD	*(char)
)	O
num	long
+=	O
atol	(*(char))->(long)
(	O
s5	*(char)
)	O
;	O
else	O
num	long
-=	O
atol	(*(char))->(long)
(	O
s5	*(char)
)	O
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
if	O
(	O
!	O
error	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
"%0*ld"	*(char)
,	O
len	int
,	O
num	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s5	*(char)
)	O
;	O
if	O
(	O
len	int
!=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
)	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
)	O
,	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	*(char)
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_tvar	array(struct(struct(*(char)),struct(*(char))))
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct(*(char))
.	O
tvar_text	*(char)
,	O
s5	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
error	int
)	O
{	O
if	O
(	O
(	O
mode	enum(int,int,int,int,int,int,int)
==	O
GLobal	int
)	O
&&	O
(	O
error	int
==	O
ERR_ILLEGAL_VAR_DEFINITION	int
||	O
error	int
==	O
ERR_ILLEGAL_VAR_OPERATION	int
)	O
)	O
warning_level	int
=	O
WARN_LVL_MAX	int
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
line_buffer	*(char)
==	O
RC_TVAR_CHAR	char
)	O
tvar	char
=	O
*	O
(	O
line_buffer	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
!	O
tvar	char
)	O
tvar	char
=	O
*	O
line_buffer	*(char)
;	O
var_warning	(int,int,*(char),*(char),long)->(void)
(	O
error	int
,	O
(	O
int	O
)	O
tvar	char
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
;	O
}	O
}	O
}	O
void	O
nth_weekday_of_month	(*(int),*(int),*(int),*(int),*(int))->(void)
(	O
d	int
,	O
m	int
,	O
y	int
,	O
n	long
,	O
is_weekday_mode	*(int)
)	O
int	O
*	O
d	int
;	O
int	O
*	O
m	int
;	O
int	O
*	O
y	int
;	O
const	O
int	O
*	O
n	long
;	O
Bool	int
*	O
is_weekday_mode	*(int)
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
auto	O
int	O
dd	int
=	O
0	int
;	O
auto	O
int	O
mm	int
=	O
0	int
;	O
auto	O
Bool	int
year_set	int
=	O
FALSE	O
;	O
auto	O
Bool	int
year_modified	int
=	O
FALSE	O
;	O
if	O
(	O
*	O
n	long
&&	O
(	O
!	O
rc_year_flag	int
||	O
(	O
*	O
m	int
&&	O
rc_year_flag	int
)	O
)	O
&&	O
(	O
!	O
rc_period_list	int
||	O
(	O
*	O
m	int
&&	O
rc_period_list	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
*	O
m	int
&&	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
||	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
;	O
else	O
{	O
*	O
is_weekday_mode	*(int)
=	O
FALSE	O
;	O
if	O
(	O
!	O
*	O
y	int
)	O
{	O
year_set	int
=	O
TRUE	O
;	O
*	O
y	int
=	O
year	int
;	O
}	O
if	O
(	O
!	O
*	O
m	int
)	O
{	O
*	O
m	int
=	O
month	int
;	O
if	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
{	O
if	O
(	O
(	O
*	O
n	long
>	O
3	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
)	O
)	O
{	O
i	int
=	O
(	O
days_of_february	(int)->(int)
(	O
year	int
-	O
1	int
)	O
==	O
29	int
)	O
;	O
j	int
=	O
day	int
+	O
DAY_LAST	int
+	O
i	int
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
j	int
,	O
i	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
n	long
==	O
1	int
)	O
{	O
if	O
(	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
>	O
0	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
<	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
,	O
is_leap_year	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
else	O
{	O
i	int
=	O
(	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
==	O
29	int
)	O
;	O
j	int
=	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
)	O
-	O
(	O
DAY_LAST	int
+	O
is_leap_year	int
)	O
;	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
j	int
,	O
i	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
}	O
}	O
dd	int
=	O
*	O
d	int
;	O
}	O
}	O
else	O
if	O
(	O
year_set	int
&&	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
)	O
{	O
if	O
(	O
(	O
*	O
n	long
==	O
9	int
)	O
&&	O
(	O
*	O
m	int
==	O
MONTH_MAX	int
)	O
&&	O
(	O
*	O
y	int
>	O
YEAR_MIN	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
)	O
)	O
{	O
year_modified	int
=	O
TRUE	O
;	O
(	O
*	O
y	int
)	O
--	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
n	long
==	O
1	int
)	O
&&	O
(	O
*	O
m	int
==	O
MONTH_MIN	int
)	O
&&	O
(	O
*	O
y	int
<	O
YEAR_MAX	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
>=	O
DAY_LAST	int
+	O
is_leap_year	int
)	O
)	O
{	O
year_modified	int
=	O
TRUE	O
;	O
(	O
*	O
y	int
)	O
++	O
;	O
}	O
}	O
if	O
(	O
year_set	int
&&	O
(	O
*	O
y	int
<	O
YEAR_MAX	int
)	O
&&	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
&&	O
(	O
*	O
m	int
<	O
fiscal_month	int
)	O
)	O
)	O
if	O
(	O
!	O
year_modified	int
)	O
(	O
*	O
y	int
)	O
++	O
;	O
if	O
(	O
*	O
m	int
==	O
2	int
)	O
i	int
=	O
days_of_february	(int)->(int)
(	O
*	O
y	int
)	O
;	O
else	O
i	int
=	O
dvec	array(int)
[	O
*	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
*	O
n	long
==	O
9	int
)	O
*	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
i	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
*	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
*	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
*	O
d	int
,	O
TRUE	O
)	O
;	O
*	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
*	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
*	O
d	int
>	O
i	int
)	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
mm	int
&&	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
)	O
{	O
if	O
(	O
(	O
*	O
n	long
==	O
1	int
)	O
&&	O
(	O
mm	int
!=	O
*	O
m	int
)	O
)	O
{	O
*	O
m	int
=	O
mm	int
;	O
if	O
(	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
>	O
0	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
<	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
;	O
else	O
if	O
(	O
year_set	int
&&	O
(	O
year	int
<	O
YEAR_MAX	int
)	O
)	O
*	O
y	int
=	O
year	int
+	O
1	int
;	O
*	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
TRUE	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
n	long
>	O
3	int
)	O
&&	O
(	O
(	O
adate_set	int
&&	O
(	O
mm	int
==	O
*	O
m	int
)	O
)	O
||	O
(	O
!	O
adate_set	int
&&	O
(	O
mm	int
!=	O
*	O
m	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
adate_set	int
)	O
*	O
m	int
=	O
mm	int
;	O
if	O
(	O
year_set	int
&&	O
(	O
year	int
>	O
YEAR_MIN	int
)	O
)	O
*	O
y	int
=	O
year	int
-	O
1	int
;	O
if	O
(	O
*	O
n	long
==	O
9	int
)	O
*	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
*	O
d	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
TRUE	O
)	O
;	O
*	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
*	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
*	O
d	int
>	O
dvec	array(int)
[	O
MONTH_MAX	int
-	O
1	int
]	O
)	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
Slint	long
d_between	(int,int,int,int,int,int)->(long)
(	O
d1	int
,	O
m1	int
,	O
y1	(double)->(double)
,	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
d1	int
;	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	(double)->(double)
;	O
const	O
int	O
d2	int
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
return	O
(	O
date2num	(int,int,int)->(long)
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
-	O
date2num	(int,int,int)->(long)
(	O
d1	int
,	O
m1	int
,	O
y1	(double)->(double)
)	O
)	O
;	O
}	O
Slint	long
w_between	(int,int,int,int,int,int)->(long)
(	O
d1	int
,	O
m1	int
,	O
y1	(double)->(double)
,	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
d1	int
;	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	(double)->(double)
;	O
const	O
int	O
d2	int
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
auto	O
Ulint	long
date1	long
=	O
date2num	(int,int,int)->(long)
(	O
d1	int
,	O
m1	int
,	O
y1	(double)->(double)
)	O
;	O
auto	O
Ulint	long
date2	long
=	O
date2num	(int,int,int)->(long)
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
;	O
auto	O
Slint	long
diff	int
;	O
auto	O
Slint	long
result	long
;	O
diff	int
=	O
(	O
Slint	long
)	O
date2	long
-	O
(	O
date1	long
-	O
(	O
SYEAR	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
d1	int
,	O
m1	int
,	O
y1	(double)->(double)
)	O
,	O
start_day	int
)	O
)	O
+	O
1	int
)	O
;	O
result	long
=	O
diff	int
/	O
DAY_MAX	int
;	O
if	O
(	O
(	O
diff	int
%	O
DAY_MAX	int
)	O
&&	O
(	O
diff	int
<	O
0L	int
)	O
)	O
result	long
--	O
;	O
return	O
(	O
result	long
)	O
;	O
}	O
Slint	long
m_between	(int,int,int,int)->(long)
(	O
m1	int
,	O
y1	(double)->(double)
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	(double)->(double)
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
return	O
(	O
(	O
(	O
y2	int
-	O
y1	(double)->(double)
)	O
*	O
MONTH_MAX	int
)	O
+	O
(	O
m2	int
-	O
m1	int
)	O
)	O
;	O
}	O
void	O
manage_leap_day	(*(int),*(int),int,*(char),*(char),long)->(void)
(	O
day	int
,	O
month	int
,	O
year	int
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
year	int
;	O
const	O
char	O
*	O
line_buffer	*(char)
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
{	O
register	O
int	O
action	int
=	O
0	int
;	O
if	O
(	O
(	O
*	O
month	int
==	O
2	int
)	O
&&	O
(	O
*	O
day	int
==	O
29	int
)	O
&&	O
(	O
rc_feb_29_to_feb_28	int
||	O
rc_feb_29_to_mar_01	int
)	O
)	O
{	O
if	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
+	O
1	int
)	O
&&	O
(	O
year	int
<	O
YEAR_MAX	int
)	O
)	O
{	O
if	O
(	O
days_of_february	(int)->(int)
(	O
year	int
+	O
1	int
)	O
==	O
28	int
)	O
{	O
if	O
(	O
rc_feb_29_to_feb_28	int
)	O
*	O
day	int
=	O
action	int
=	O
28	int
;	O
else	O
{	O
*	O
day	int
=	O
action	int
=	O
DAY_MIN	int
;	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
28	int
)	O
{	O
if	O
(	O
rc_feb_29_to_feb_28	int
)	O
*	O
day	int
=	O
action	int
=	O
28	int
;	O
else	O
{	O
*	O
day	int
=	O
action	int
=	O
DAY_MIN	int
;	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
action	int
)	O
{	O
*	O
s5	*(char)
=	O
'\0'	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
action	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
action	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
action	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Leap-day set to `%02d-%s' in file `%s'."	*(char)
)	O
,	O
*	O
day	int
,	O
month_name	(int)->(*(char))
(	O
*	O
month	int
)	O
,	O
filename	*(char)
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Line %ld: %s"	*(char)
)	O
,	O
line_number	long
,	O
line_buffer	*(char)
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
}	O
}	O
}	O
char	O
*	O
biorhythm	(int,int,*(char),int,int,int,int,int,int,*(char),*(int),*(int),*(char),*(int),*(int),*(char),*(int),*(int),*(int),*(int),*(int))->(*(char))
(	O
create_bar	int
,	O
axis_len	int
,	O
string	*(char)
,	O
day	int
,	O
month	int
,	O
year	int
,	O
birth_day	int
,	O
birth_month	int
,	O
birth_year	int
,	O
emo_text	*(char)
,	O
emo_phase	*(int)
,	O
emo_waxes	*(int)
,	O
int_text	*(char)
,	O
int_phase	*(int)
,	O
int_waxes	*(int)
,	O
phy_text	*(char)
,	O
phy_phase	*(int)
,	O
phy_waxes	*(int)
,	O
critical_day	*(int)
,	O
positive_day	*(int)
,	O
negative_day	*(int)
)	O
const	O
Bool	int
create_bar	int
;	O
int	O
axis_len	int
;	O
char	O
*	O
string	*(char)
;	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
int	O
birth_day	int
;	O
const	O
int	O
birth_month	int
;	O
const	O
int	O
birth_year	int
;	O
const	O
char	O
*	O
emo_text	*(char)
;	O
int	O
*	O
emo_phase	*(int)
;	O
int	O
*	O
emo_waxes	*(int)
;	O
const	O
char	O
*	O
int_text	*(char)
;	O
int	O
*	O
int_phase	*(int)
;	O
int	O
*	O
int_waxes	*(int)
;	O
const	O
char	O
*	O
phy_text	*(char)
;	O
int	O
*	O
phy_phase	*(int)
;	O
int	O
*	O
phy_waxes	*(int)
;	O
int	O
*	O
critical_day	*(int)
;	O
int	O
*	O
positive_day	*(int)
;	O
int	O
*	O
negative_day	*(int)
;	O
{	O
auto	O
double	O
x	double
;	O
auto	O
Slint	long
diff	int
=	O
d_between	(int,int,int,int,int,int)->(long)
(	O
birth_day	int
,	O
birth_month	int
,	O
birth_year	int
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
register	O
int	O
yes_phase	int
;	O
register	O
int	O
yes_waxes	int
;	O
register	O
int	O
i	int
;	O
(	O
*	O
critical_day	*(int)
)	O
=	O
(	O
*	O
positive_day	*(int)
)	O
=	O
(	O
*	O
negative_day	*(int)
)	O
=	O
(	O
*	O
emo_waxes	*(int)
)	O
=	O
(	O
*	O
int_waxes	*(int)
)	O
=	O
(	O
*	O
phy_waxes	*(int)
)	O
=	O
0	int
;	O
if	O
(	O
create_bar	int
)	O
{	O
auto	O
char	O
*	O
ptr_string	*(char)
;	O
for	O
(	O
i	int
=	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
,	O
ptr_string	*(char)
=	O
string	*(char)
;	O
--	O
i	int
;	O
)	O
*	O
ptr_string	*(char)
++	O
=	O
' '	O
;	O
string	*(char)
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
string	*(char)
[	O
BIO_AXIS_EXTRA	int
-	O
1	int
]	O
=	O
*	O
BIO_WANES	O
;	O
string	*(char)
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
BIO_AXIS_EXTRA	int
-	O
1	int
]	O
=	O
*	O
BIO_WAXES	O
;	O
}	O
if	O
(	O
diff	int
<	O
1L	int
)	O
diff	int
=	O
21252L	int
-	O
(	O
-	O
diff	int
%	O
21252L	int
)	O
;	O
else	O
diff	int
%=	O
21252L	int
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
28.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
28.0	int
;	O
*	O
emo_phase	*(int)
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
*	O
emo_waxes	*(int)
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
emo_phase	*(int)
==	O
100	int
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
emo_waxes	*(int)
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
if	O
(	O
*	O
emo_phase	*(int)
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
emo_waxes	*(int)
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
*	O
emo_waxes	*(int)
=	O
(	O
*	O
emo_waxes	*(int)
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
emo_phase	*(int)
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
emo_phase	*(int)
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	*(int)
)	O
++	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
33.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
33.0	int
;	O
*	O
int_phase	*(int)
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
*	O
int_waxes	*(int)
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
int_phase	*(int)
==	O
100	int
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
int_waxes	*(int)
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
if	O
(	O
*	O
int_phase	*(int)
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
int_waxes	*(int)
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
*	O
int_waxes	*(int)
=	O
(	O
*	O
int_waxes	*(int)
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
int_phase	*(int)
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
int_phase	*(int)
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	*(int)
)	O
++	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
23.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
23.0	int
;	O
*	O
phy_phase	*(int)
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	(double)->(double)
(	O
x	double
)	O
)	O
;	O
*	O
phy_waxes	*(int)
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	(double)->(double)
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
phy_phase	*(int)
==	O
100	int
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
phy_waxes	*(int)
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	*(int)
)	O
++	O
;	O
if	O
(	O
*	O
phy_phase	*(int)
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
phy_waxes	*(int)
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	*(int)
)	O
++	O
;	O
*	O
phy_waxes	*(int)
=	O
(	O
*	O
phy_waxes	*(int)
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
phy_phase	*(int)
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
phy_phase	*(int)
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	*(int)
)	O
++	O
;	O
if	O
(	O
create_bar	int
)	O
{	O
i	int
=	O
*	O
emo_phase	*(int)
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
emo_phase	*(int)
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
' '	O
)	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
emo_text	*(char)
;	O
else	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
i	int
=	O
*	O
int_phase	*(int)
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
int_phase	*(int)
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
' '	O
)	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
int_text	*(char)
;	O
else	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
i	int
=	O
*	O
phy_phase	*(int)
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
phy_phase	*(int)
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
' '	O
)	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
phy_text	*(char)
;	O
else	O
string	*(char)
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
*	O
string	*(char)
=	O
DIG2CHR	O
(	O
*	O
negative_day	*(int)
)	O
;	O
string	*(char)
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
BIO_AXIS_EXTRA	int
]	O
=	O
DIG2CHR	O
(	O
*	O
positive_day	*(int)
)	O
;	O
string	*(char)
[	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
]	O
=	O
DIG2CHR	O
(	O
*	O
critical_day	*(int)
)	O
;	O
}	O
return	O
(	O
string	*(char)
)	O
;	O
}	O
double	O
compute_distance	(*(struct(int,int,int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int)))->(double)
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
,	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
)	O
const	O
Coor_struct	struct(int,int,int,int,int,int,int,int,int)
*	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
;	O
const	O
Coor_struct	struct(int,int,int,int,int,int,int,int,int)
*	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
;	O
{	O
auto	O
double	O
lon_c1	double
=	O
TORAD	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_sec	int
)	O
)	O
;	O
auto	O
double	O
lat_c1	double
=	O
TORAD	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_sec	int
)	O
)	O
;	O
auto	O
double	O
lon_c2	double
=	O
TORAD	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lon_sec	int
)	O
)	O
;	O
auto	O
double	O
lat_c2	double
=	O
TORAD	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
lat_sec	int
)	O
)	O
;	O
auto	O
double	O
delta_lambda	double
;	O
auto	O
double	O
x1	double
;	O
auto	O
double	O
x2	double
;	O
switch	O
(	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
the_mode	int
)	O
{	O
case	O
0	int
:	O
x1	double
=	O
gd_latitude2gc_latitude	(double,int,*(double))->(double)
(	O
lat_c1	double
,	O
coor1	*(struct(int,int,int,int,int,int,int,int,int))
->	O
meters_above_sea_level	int
,	O
&	O
lat_c1	double
)	O
;	O
x2	double
=	O
gd_latitude2gc_latitude	(double,int,*(double))->(double)
(	O
lat_c2	double
,	O
coor2	*(struct(int,int,int,int,int,int,int,int,int))
->	O
meters_above_sea_level	int
,	O
&	O
lat_c2	double
)	O
;	O
if	O
(	O
SGN	O
(	O
lat_c1	double
)	O
==	O
0	int
||	O
SGN	O
(	O
lat_c2	double
)	O
==	O
0	int
||	O
SGN	O
(	O
lat_c1	double
)	O
==	O
SGN	O
(	O
lat_c2	double
)	O
)	O
{	O
delta_lambda	double
=	O
(	O
x1	double
+	O
x2	double
)	O
*	O
0.5	int
;	O
x1	double
=	O
2.0	int
*	O
MAX	O
(	O
x1	double
,	O
delta_lambda	double
)	O
+	O
MIN	O
(	O
x1	double
,	O
delta_lambda	double
)	O
+	O
2.0	int
*	O
MAX	O
(	O
x2	double
,	O
delta_lambda	double
)	O
+	O
MIN	O
(	O
x2	double
,	O
delta_lambda	double
)	O
;	O
}	O
else	O
x1	double
=	O
4.0	int
*	O
EQUATOR_EARTH_RADIUS	int
+	O
x1	double
+	O
x2	double
;	O
delta_lambda	double
=	O
lon_c1	double
-	O
lon_c2	double
;	O
return	O
(	O
DEG2DAY	O
(	O
TODEG	O
(	O
acos	(double)->(double)
(	O
sin	(double)->(double)
(	O
lat_c1	double
)	O
*	O
sin	(double)->(double)
(	O
lat_c2	double
)	O
+	O
cos	(double)->(double)
(	O
lat_c1	double
)	O
*	O
cos	(double)->(double)
(	O
lat_c2	double
)	O
*	O
cos	(double)->(double)
(	O
delta_lambda	double
)	O
)	O
)	O
)	O
*	O
(	O
x1	double
/	O
6000.0	int
)	O
*	O
MY_TWO_PI	int
)	O
;	O
case	O
1	int
:	O
delta_lambda	double
=	O
lon_c1	double
-	O
lon_c2	double
;	O
x1	double
=	O
cos	(double)->(double)
(	O
lat_c1	double
)	O
*	O
tan	(double)->(double)
(	O
lat_c2	double
)	O
-	O
sin	(double)->(double)
(	O
lat_c1	double
)	O
*	O
cos	(double)->(double)
(	O
delta_lambda	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
delta_lambda	double
=	O
lon_c2	double
-	O
lon_c1	double
;	O
x1	double
=	O
cos	(double)->(double)
(	O
lat_c2	double
)	O
*	O
tan	(double)->(double)
(	O
lat_c1	double
)	O
-	O
sin	(double)->(double)
(	O
lat_c2	double
)	O
*	O
cos	(double)->(double)
(	O
delta_lambda	double
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
x2	double
=	O
sin	(double)->(double)
(	O
delta_lambda	double
)	O
;	O
if	O
(	O
x1	double
>	O
0.0	int
)	O
delta_lambda	double
=	O
atan	(double)->(double)
(	O
x2	double
/	O
x1	double
)	O
;	O
else	O
if	O
(	O
x1	double
<	O
0.0	int
)	O
delta_lambda	double
=	O
atan	(double)->(double)
(	O
x2	double
/	O
x1	double
)	O
+	O
MY_PI	int
;	O
else	O
if	O
(	O
x2	double
>	O
0.0	int
)	O
delta_lambda	double
=	O
MY_HALF_PI	int
;	O
else	O
if	O
(	O
x2	double
<	O
0.0	int
)	O
delta_lambda	double
=	O
-	O
MY_HALF_PI	int
;	O
else	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
if	O
(	O
SGN	O
(	O
delta_lambda	double
)	O
>	O
0	int
)	O
delta_lambda	double
=	O
MY_TWO_PI	int
-	O
delta_lambda	double
;	O
else	O
if	O
(	O
SGN	O
(	O
delta_lambda	double
)	O
<	O
0	int
)	O
delta_lambda	double
=	O
-	O
delta_lambda	double
;	O
return	O
(	O
TODEG	O
(	O
delta_lambda	double
)	O
)	O
;	O
}	O
static	O
void	O
var_warning	(int,int,*(char),*(char),long)->(void)
(	O
exit_status	int
,	O
var_name	*(char)
,	O
line_buffer	*(char)
,	O
filename	*(char)
,	O
line_number	long
)	O
const	O
int	O
exit_status	int
;	O
const	O
int	O
var_name	*(char)
;	O
const	O
char	O
*	O
line_buffer	*(char)
;	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
long	O
line_number	long
;	O
{	O
register	O
int	O
i	int
;	O
auto	O
Bool	int
with_usage	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
line_number	long
)	O
S_NEWLINE	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
*	O
s5	*(char)
=	O
'\0'	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
}	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: abort, "	*(char)
)	O
,	O
prgr_name	*(char)
)	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
switch	O
(	O
exit_status	int
)	O
{	O
case	O
ERR_ILLEGAL_VAR_DEFINITION	int
:	O
if	O
(	O
line_number	long
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"illegal variable definition in file `%s'"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"illegal definition of variable `%c'"	*(char)
)	O
,	O
(	O
char	O
)	O
var_name	*(char)
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
with_usage	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
ERR_ILLEGAL_VAR_OPERATION	int
:	O
if	O
(	O
line_number	long
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"illegal variable operation in file `%s'"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"illegal operation on variable `%c'"	*(char)
)	O
,	O
(	O
char	O
)	O
var_name	*(char)
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
with_usage	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
ERR_INVALID_VAR_REFERENCE	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"variable `%c' undefined in file `%s'"	*(char)
)	O
,	O
(	O
char	O
)	O
var_name	*(char)
,	O
filename	*(char)
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_VAR_ASSIGNMENT	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"invalid value assigned to variable `%c' in file `%s'"	*(char)
)	O
,	O
(	O
char	O
)	O
var_name	*(char)
,	O
filename	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
warning_level	int
<	O
WARN_LVL_MAX	int
)	O
{	O
*	O
s5	*(char)
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
s5	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s5	*(char)
,	O
"."	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
s5	*(char)
)	O
;	O
else	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
{	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Invalid argument in command line given -- %s"	*(char)
)	O
,	O
line_buffer	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Line %ld: %s"	*(char)
)	O
,	O
line_number	long
,	O
line_buffer	*(char)
)	O
;	O
S_NEWLINE	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
line_buffer	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Argument `%s' of command line ignored."	*(char)
)	O
,	O
line_buffer	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s5	*(char)
,	O
_	O
(	O
"Line %ld ignored: %s"	*(char)
)	O
,	O
line_number	long
,	O
line_buffer	*(char)
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
s5	*(char)
)	O
;	O
else	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s5	*(char)
)	O
;	O
}	O
if	O
(	O
with_usage	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n%s\n"	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
my_exit	(int)->(void)
(	O
exit_status	int
)	O
;	O
}	O
