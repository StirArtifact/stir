static	O
char	O
lex	O
[	O
256	int
]	O
;	O
static	O
const	O
char	O
symbol_chars	O
[	O
]	O
=	O
"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"	*(char)
;	O
static	O
int	O
process_escape	O
(	O
int	O
)	O
;	O
void	O
do_scrub_begin	O
(	O
int	O
m68k_mri	O
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
int	O
c	O
;	O
lex	O
[	O
' '	O
]	O
=	O
LEX_IS_WHITESPACE	O
;	O
lex	O
[	O
'\t'	O
]	O
=	O
LEX_IS_WHITESPACE	O
;	O
lex	O
[	O
'\r'	O
]	O
=	O
LEX_IS_WHITESPACE	O
;	O
lex	O
[	O
'\n'	O
]	O
=	O
LEX_IS_NEWLINE	O
;	O
lex	O
[	O
':'	O
]	O
=	O
LEX_IS_COLON	O
;	O
{	O
lex	O
[	O
'"'	O
]	O
=	O
LEX_IS_STRINGQUOTE	O
;	O
lex	O
[	O
'\''	O
]	O
=	O
LEX_IS_ONECHAR_QUOTE	O
;	O
}	O
for	O
(	O
p	*(void)
=	O
symbol_chars	O
;	O
*	O
p	*(void)
;	O
++	O
p	*(void)
)	O
lex	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	O
;	O
for	O
(	O
c	O
=	O
128	int
;	O
c	O
<	O
256	int
;	O
++	O
c	O
)	O
lex	O
[	O
c	O
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	O
;	O
for	O
(	O
p	*(void)
=	O
tc_symbol_chars	O
;	O
*	O
p	*(void)
;	O
++	O
p	*(void)
)	O
lex	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	O
;	O
for	O
(	O
p	*(void)
=	O
tc_comment_chars	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
lex	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
LEX_IS_COMMENT_START	O
;	O
for	O
(	O
p	*(void)
=	O
line_comment_chars	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
lex	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
LEX_IS_LINE_COMMENT_START	O
;	O
for	O
(	O
p	*(void)
=	O
tc_line_separator_chars	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
lex	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
LEX_IS_LINE_SEPARATOR	O
;	O
if	O
(	O
lex	O
[	O
'/'	O
]	O
==	O
0	int
)	O
lex	O
[	O
'/'	O
]	O
=	O
LEX_IS_TWOCHAR_COMMENT_1ST	O
;	O
}	O
static	O
int	O
state	*(int)
;	O
static	O
int	O
old_state	O
;	O
static	O
const	O
char	O
*	O
out_string	O
;	O
static	O
char	O
out_buf	O
[	O
20	int
]	O
;	O
static	O
int	O
add_newlines	O
;	O
static	O
char	O
*	O
saved_input	O
;	O
static	O
size_t	long
saved_input_len	O
;	O
static	O
char	O
input_buffer	O
[	O
32	int
*	O
1024	int
]	O
;	O
static	O
const	O
char	O
*	O
mri_state	O
;	O
static	O
char	O
mri_last_ch	O
;	O
struct	O
app_save	O
{	O
int	O
state	*(int)
;	O
int	O
old_state	O
;	O
const	O
char	O
*	O
out_string	O
;	O
char	O
out_buf	O
[	O
sizeof	O
(	O
out_buf	O
)	O
]	O
;	O
int	O
add_newlines	O
;	O
char	O
*	O
saved_input	O
;	O
size_t	long
saved_input_len	O
;	O
const	O
char	O
*	O
mri_state	O
;	O
char	O
mri_last_ch	O
;	O
}	O
;	O
char	O
*	O
app_push	O
(	O
void	O
)	O
{	O
struct	O
app_save	O
*	O
saved	O
;	O
saved	O
=	O
XNEW	O
(	O
struct	O
app_save	O
)	O
;	O
saved	O
->	O
state	*(int)
=	O
state	*(int)
;	O
saved	O
->	O
old_state	O
=	O
old_state	O
;	O
saved	O
->	O
out_string	O
=	O
out_string	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved	O
->	O
out_buf	O
,	O
out_buf	O
,	O
sizeof	O
(	O
out_buf	O
)	O
)	O
;	O
saved	O
->	O
add_newlines	O
=	O
add_newlines	O
;	O
if	O
(	O
saved_input	O
==	O
NULL	O
)	O
saved	O
->	O
saved_input	O
=	O
NULL	O
;	O
else	O
{	O
saved	O
->	O
saved_input	O
=	O
XNEWVEC	O
(	O
char	O
,	O
saved_input_len	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved	O
->	O
saved_input	O
,	O
saved_input	O
,	O
saved_input_len	O
)	O
;	O
saved	O
->	O
saved_input_len	O
=	O
saved_input_len	O
;	O
}	O
saved	O
->	O
mri_state	O
=	O
mri_state	O
;	O
saved	O
->	O
mri_last_ch	O
=	O
mri_last_ch	O
;	O
state	*(int)
=	O
0	int
;	O
saved_input	O
=	O
NULL	O
;	O
add_newlines	O
=	O
0	int
;	O
return	O
(	O
char	O
*	O
)	O
saved	O
;	O
}	O
void	O
app_pop	O
(	O
char	O
*	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
struct	O
app_save	O
*	O
saved	O
=	O
(	O
struct	O
app_save	O
*	O
)	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
state	*(int)
=	O
saved	O
->	O
state	*(int)
;	O
old_state	O
=	O
saved	O
->	O
old_state	O
;	O
out_string	O
=	O
saved	O
->	O
out_string	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
out_buf	O
,	O
saved	O
->	O
out_buf	O
,	O
sizeof	O
(	O
out_buf	O
)	O
)	O
;	O
add_newlines	O
=	O
saved	O
->	O
add_newlines	O
;	O
if	O
(	O
saved	O
->	O
saved_input	O
==	O
NULL	O
)	O
saved_input	O
=	O
NULL	O
;	O
else	O
{	O
gas_assert	O
(	O
saved	O
->	O
saved_input_len	O
<=	O
sizeof	O
(	O
input_buffer	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
input_buffer	O
,	O
saved	O
->	O
saved_input	O
,	O
saved	O
->	O
saved_input_len	O
)	O
;	O
saved_input	O
=	O
input_buffer	O
;	O
saved_input_len	O
=	O
saved	O
->	O
saved_input_len	O
;	O
free	(*(void))->(void)
(	O
saved	O
->	O
saved_input	O
)	O
;	O
}	O
mri_state	O
=	O
saved	O
->	O
mri_state	O
;	O
mri_last_ch	O
=	O
saved	O
->	O
mri_last_ch	O
;	O
free	(*(void))->(void)
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
;	O
}	O
static	O
int	O
process_escape	O
(	O
int	O
ch	O
)	O
{	O
switch	O
(	O
ch	O
)	O
{	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'\''	O
:	O
return	O
'\''	O
;	O
case	O
'"'	O
:	O
return	O
'\"'	O
;	O
default	O
:	O
return	O
ch	O
;	O
}	O
}	O
size_t	long
do_scrub_chars	O
(	O
size_t	long
(	O
*	O
get	O
)	O
(	O
char	O
*	O
,	O
size_t	long
)	O
,	O
char	O
*	O
tostart	O
,	O
size_t	long
tolen	O
)	O
{	O
char	O
*	O
to	O
=	O
tostart	O
;	O
char	O
*	O
toend	O
=	O
tostart	O
+	O
tolen	O
;	O
char	O
*	O
from	O
;	O
char	O
*	O
fromend	O
;	O
size_t	long
fromlen	O
;	O
int	O
ch	O
,	O
ch2	O
=	O
0	int
;	O
static	O
char	O
quotechar	O
;	O
if	O
(	O
saved_input	O
!=	O
NULL	O
)	O
{	O
from	O
=	O
saved_input	O
;	O
fromend	O
=	O
from	O
+	O
saved_input_len	O
;	O
}	O
else	O
{	O
fromlen	O
=	O
(	O
*	O
get	O
)	O
(	O
input_buffer	O
,	O
sizeof	O
input_buffer	O
)	O
;	O
if	O
(	O
fromlen	O
==	O
0	int
)	O
return	O
0	int
;	O
from	O
=	O
input_buffer	O
;	O
fromend	O
=	O
from	O
+	O
fromlen	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
-	O
1	int
:	O
ch	O
=	O
*	O
out_string	O
++	O
;	O
if	O
(	O
*	O
out_string	O
==	O
'\0'	O
)	O
{	O
state	*(int)
=	O
old_state	O
;	O
old_state	O
=	O
3	int
;	O
}	O
PUT	O
(	O
ch	O
)	O
;	O
continue	O
;	O
case	O
-	O
2	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file in comment"	*(char)
)	O
)	O
;	O
goto	O
fromeof	O
;	O
}	O
if	O
(	O
ch	O
==	O
'\n'	O
)	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
while	O
(	O
ch	O
!=	O
'*'	O
)	O
;	O
while	O
(	O
(	O
ch	O
=	O
GET	O
(	O
)	O
)	O
==	O
'*'	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file in comment"	*(char)
)	O
)	O
;	O
goto	O
fromeof	O
;	O
}	O
if	O
(	O
ch	O
==	O
'/'	O
)	O
break	O
;	O
UNGET	O
(	O
ch	O
)	O
;	O
}	O
state	*(int)
=	O
old_state	O
;	O
UNGET	O
(	O
' '	O
)	O
;	O
continue	O
;	O
case	O
4	int
:	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
goto	O
fromeof	O
;	O
else	O
if	O
(	O
ch	O
>=	O
'0'	O
&&	O
ch	O
<=	O
'9'	O
)	O
PUT	O
(	O
ch	O
)	O
;	O
else	O
{	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	O
)	O
)	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
'"'	O
)	O
{	O
quotechar	O
=	O
ch	O
;	O
state	*(int)
=	O
5	int
;	O
old_state	O
=	O
3	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
ch	O
!=	O
'\n'	O
)	O
ch	O
=	O
GET	O
(	O
)	O
;	O
state	*(int)
=	O
0	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
}	O
continue	O
;	O
case	O
5	int
:	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
ptrdiff_t	O
len	long
;	O
for	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
from	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
<	O
fromend	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
)	O
{	O
ch	O
=	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
ch	O
==	O
'\\'	O
||	O
ch	O
==	O
quotechar	O
||	O
ch	O
==	O
'\n'	O
)	O
break	O
;	O
}	O
len	long
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
from	O
;	O
if	O
(	O
len	long
>	O
toend	O
-	O
to	O
)	O
len	long
=	O
toend	O
-	O
to	O
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
to	O
,	O
from	O
,	O
len	long
)	O
;	O
to	O
+=	O
len	long
;	O
from	O
+=	O
len	long
;	O
if	O
(	O
to	O
>=	O
toend	O
)	O
goto	O
tofull	O
;	O
}	O
}	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
static	O
char	O
one_char_buf	O
[	O
1	int
]	O
;	O
as_warn	O
(	O
_	O
(	O
"end of file in string; '%c' inserted"	*(char)
)	O
,	O
quotechar	O
)	O
;	O
state	*(int)
=	O
old_state	O
;	O
from	O
=	O
fromend	O
=	O
one_char_buf	O
+	O
1	int
;	O
fromlen	O
=	O
1	int
;	O
UNGET	O
(	O
'\n'	O
)	O
;	O
PUT	O
(	O
quotechar	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	O
==	O
quotechar	O
)	O
{	O
state	*(int)
=	O
old_state	O
;	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
else	O
if	O
(	O
TC_STRING_ESCAPES	O
&&	O
ch	O
==	O
'\\'	O
)	O
{	O
state	*(int)
=	O
6	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
else	O
if	O
(	O
scrub_m68k_mri	O
&&	O
ch	O
==	O
'\n'	O
)	O
{	O
state	*(int)
=	O
old_state	O
;	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
'\''	O
)	O
;	O
}	O
else	O
{	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
continue	O
;	O
case	O
6	int
:	O
state	*(int)
=	O
5	int
;	O
ch	O
=	O
GET	O
(	O
)	O
;	O
switch	O
(	O
ch	O
)	O
{	O
case	O
'\n'	O
:	O
UNGET	O
(	O
'n'	O
)	O
;	O
add_newlines	O
++	O
;	O
PUT	O
(	O
'\\'	O
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
as_warn	O
(	O
_	O
(	O
"end of file in string; '%c' inserted"	*(char)
)	O
,	O
quotechar	O
)	O
;	O
PUT	O
(	O
quotechar	O
)	O
;	O
continue	O
;	O
case	O
'"'	O
:	O
case	O
'\\'	O
:	O
case	O
'b'	O
:	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
'r'	O
:	O
case	O
't'	O
:	O
case	O
'v'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
PUT	O
(	O
ch	O
)	O
;	O
continue	O
;	O
}	O
ch	O
=	O
GET	O
(	O
)	O
;	O
recycle	O
:	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
if	O
(	O
state	*(int)
!=	O
0	int
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file not at end of a line; newline inserted"	*(char)
)	O
)	O
;	O
state	*(int)
=	O
0	int
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
goto	O
fromeof	O
;	O
}	O
switch	O
(	O
lex	O
[	O
ch	O
]	O
)	O
{	O
case	O
LEX_IS_WHITESPACE	O
:	O
do	O
{	O
ch	O
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	O
)	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
goto	O
fromeof	O
;	O
if	O
(	O
state	*(int)
==	O
0	int
)	O
{	O
state	*(int)
=	O
1	int
;	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
IS_COMMENT	O
(	O
ch	O
)	O
||	O
ch	O
==	O
'/'	O
||	O
IS_LINE_SEPARATOR	O
(	O
ch	O
)	O
||	O
IS_PARALLEL_SEPARATOR	O
(	O
ch	O
)	O
)	O
{	O
if	O
(	O
scrub_m68k_mri	O
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
goto	O
recycle	O
;	O
}	O
if	O
(	O
(	O
state	*(int)
==	O
2	int
||	O
state	*(int)
==	O
11	int
)	O
&&	O
lex	O
[	O
ch	O
]	O
==	O
LEX_IS_COLON	O
&&	O
!	O
scrub_m68k_mri	O
)	O
{	O
state	*(int)
=	O
1	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
1	int
:	O
goto	O
recycle	O
;	O
case	O
2	int
:	O
state	*(int)
=	O
3	int
;	O
if	O
(	O
to	O
+	O
1	int
<	O
toend	O
)	O
{	O
PUT	O
(	O
' '	O
)	O
;	O
goto	O
recycle	O
;	O
}	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
scrub_m68k_mri	O
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
goto	O
recycle	O
;	O
case	O
9	int
:	O
case	O
10	int
:	O
if	O
(	O
scrub_m68k_mri	O
)	O
{	O
state	*(int)
=	O
3	int
;	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
state	*(int)
=	O
10	int
;	O
goto	O
recycle	O
;	O
case	O
11	int
:	O
if	O
(	O
LABELS_WITHOUT_COLONS	O
||	O
flag_m68k_mri	O
)	O
state	*(int)
=	O
1	int
;	O
else	O
{	O
state	*(int)
=	O
3	int
;	O
}	O
UNGET	O
(	O
ch	O
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
default	O
:	O
BAD_CASE	O
(	O
state	*(int)
)	O
;	O
}	O
break	O
;	O
case	O
LEX_IS_TWOCHAR_COMMENT_1ST	O
:	O
ch2	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	O
==	O
'*'	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
ch2	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	O
!=	O
EOF	O
&&	O
IS_NEWLINE	O
(	O
ch2	O
)	O
)	O
add_newlines	O
++	O
;	O
}	O
while	O
(	O
ch2	O
!=	O
EOF	O
&&	O
ch2	O
!=	O
'*'	O
)	O
;	O
while	O
(	O
ch2	O
==	O
'*'	O
)	O
ch2	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	O
==	O
EOF	O
||	O
ch2	O
==	O
'/'	O
)	O
break	O
;	O
UNGET	O
(	O
ch2	O
)	O
;	O
}	O
if	O
(	O
ch2	O
==	O
EOF	O
)	O
as_warn	O
(	O
_	O
(	O
"end of file in multiline comment"	*(char)
)	O
)	O
;	O
ch	O
=	O
' '	O
;	O
goto	O
recycle	O
;	O
}	O
else	O
{	O
if	O
(	O
ch2	O
!=	O
EOF	O
)	O
UNGET	O
(	O
ch2	O
)	O
;	O
if	O
(	O
state	*(int)
==	O
9	int
||	O
state	*(int)
==	O
10	int
)	O
state	*(int)
=	O
3	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
}	O
break	O
;	O
case	O
LEX_IS_STRINGQUOTE	O
:	O
quotechar	O
=	O
ch	O
;	O
if	O
(	O
state	*(int)
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
state	*(int)
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
ch	O
=	O
GET	O
(	O
)	O
;	O
old_state	O
=	O
3	int
;	O
}	O
else	O
if	O
(	O
state	*(int)
==	O
9	int
)	O
old_state	O
=	O
3	int
;	O
else	O
old_state	O
=	O
state	*(int)
;	O
state	*(int)
=	O
5	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_ONECHAR_QUOTE	O
:	O
if	O
(	O
state	*(int)
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
state	*(int)
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file after a one-character quote; \\0 inserted"	*(char)
)	O
)	O
;	O
ch	O
=	O
0	int
;	O
}	O
if	O
(	O
ch	O
==	O
'\\'	O
)	O
{	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file in escape character"	*(char)
)	O
)	O
;	O
ch	O
=	O
'\\'	O
;	O
}	O
else	O
ch	O
=	O
process_escape	O
(	O
ch	O
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
out_buf	O
,	O
"%d"	*(char)
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	O
)	O
;	O
if	O
(	O
(	O
ch	O
=	O
GET	O
(	O
)	O
)	O
!=	O
'\''	O
)	O
{	O
if	O
(	O
ch	O
!=	O
EOF	O
)	O
UNGET	O
(	O
ch	O
)	O
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
out_buf	O
)	O
==	O
1	int
)	O
{	O
PUT	O
(	O
out_buf	O
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
state	*(int)
==	O
9	int
)	O
old_state	O
=	O
3	int
;	O
else	O
old_state	O
=	O
state	*(int)
;	O
state	*(int)
=	O
-	O
1	int
;	O
out_string	O
=	O
out_buf	O
;	O
PUT	O
(	O
*	O
out_string	O
++	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_COLON	O
:	O
if	O
(	O
state	*(int)
==	O
9	int
||	O
state	*(int)
==	O
10	int
)	O
state	*(int)
=	O
3	int
;	O
else	O
if	O
(	O
state	*(int)
!=	O
3	int
)	O
state	*(int)
=	O
1	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_NEWLINE	O
:	O
if	O
(	O
add_newlines	O
)	O
{	O
--	O
add_newlines	O
;	O
UNGET	O
(	O
ch	O
)	O
;	O
}	O
case	O
LEX_IS_LINE_SEPARATOR	O
:	O
state	*(int)
=	O
0	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_PARALLEL_SEPARATOR	O
:	O
state	*(int)
=	O
1	int
;	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_LINE_COMMENT_START	O
:	O
if	O
(	O
ch	O
==	O
'/'	O
)	O
{	O
ch2	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	O
==	O
'*'	O
)	O
{	O
old_state	O
=	O
3	int
;	O
state	*(int)
=	O
-	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ch2	O
!=	O
EOF	O
)	O
{	O
UNGET	O
(	O
ch2	O
)	O
;	O
}	O
}	O
if	O
(	O
state	*(int)
==	O
0	int
||	O
state	*(int)
==	O
1	int
)	O
{	O
int	O
startch	O
;	O
startch	O
=	O
ch	O
;	O
do	O
{	O
ch	O
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	O
)	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file in comment; newline inserted"	*(char)
)	O
)	O
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ch	O
<	O
'0'	O
||	O
ch	O
>	O
'9'	O
||	O
state	*(int)
!=	O
0	int
||	O
startch	O
!=	O
'#'	O
)	O
{	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
!	O
IS_NEWLINE	O
(	O
ch	O
)	O
)	O
ch	O
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"end of file in comment; newline inserted"	*(char)
)	O
)	O
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
}	O
state	*(int)
=	O
0	int
;	O
break	O
;	O
}	O
UNGET	O
(	O
ch	O
)	O
;	O
old_state	O
=	O
4	int
;	O
state	*(int)
=	O
-	O
1	int
;	O
if	O
(	O
scrub_m68k_mri	O
)	O
out_string	O
=	O
"\tlinefile "	*(char)
;	O
else	O
out_string	O
=	O
"\t.linefile "	*(char)
;	O
PUT	O
(	O
*	O
out_string	O
++	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
tc_comment_chars	O
,	O
ch	O
)	O
==	O
NULL	O
&&	O
(	O
!	O
scrub_m68k_mri	O
||	O
(	O
ch	O
!=	O
'!'	O
&&	O
ch	O
!=	O
'*'	O
)	O
)	O
)	O
goto	O
de_fault	O
;	O
if	O
(	O
scrub_m68k_mri	O
&&	O
(	O
ch	O
==	O
'!'	O
||	O
ch	O
==	O
'*'	O
||	O
ch	O
==	O
'#'	O
)	O
&&	O
state	*(int)
!=	O
1	int
&&	O
state	*(int)
!=	O
10	int
)	O
goto	O
de_fault	O
;	O
case	O
LEX_IS_COMMENT_START	O
:	O
do	O
{	O
ch	O
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	O
!=	O
EOF	O
&&	O
!	O
IS_NEWLINE	O
(	O
ch	O
)	O
)	O
;	O
if	O
(	O
ch	O
==	O
EOF	O
)	O
as_warn	O
(	O
_	O
(	O
"end of file in comment; newline inserted"	*(char)
)	O
)	O
;	O
state	*(int)
=	O
0	int
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_SYMBOL_COMPONENT	O
:	O
if	O
(	O
state	*(int)
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
state	*(int)
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
state	*(int)
==	O
3	int
)	O
state	*(int)
=	O
9	int
;	O
if	O
(	O
to	O
+	O
1	int
<	O
toend	O
&&	O
mri_state	O
==	O
NULL	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
ptrdiff_t	O
len	long
;	O
for	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
from	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
<	O
fromend	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
)	O
{	O
int	O
type	char
;	O
ch2	O
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
type	char
=	O
lex	O
[	O
ch2	O
]	O
;	O
if	O
(	O
type	char
!=	O
0	int
&&	O
type	char
!=	O
LEX_IS_SYMBOL_COMPONENT	O
)	O
break	O
;	O
}	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
>	O
from	O
)	O
--	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
len	long
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
from	O
;	O
if	O
(	O
len	long
>	O
(	O
toend	O
-	O
to	O
)	O
-	O
1	int
)	O
len	long
=	O
(	O
toend	O
-	O
to	O
)	O
-	O
1	int
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
PUT	O
(	O
ch	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
to	O
,	O
from	O
,	O
len	long
)	O
;	O
to	O
+=	O
len	long
;	O
from	O
+=	O
len	long
;	O
if	O
(	O
to	O
>=	O
toend	O
)	O
goto	O
tofull	O
;	O
ch	O
=	O
GET	O
(	O
)	O
;	O
}	O
}	O
default	O
:	O
de_fault	O
:	O
if	O
(	O
state	*(int)
==	O
0	int
)	O
{	O
state	*(int)
=	O
11	int
;	O
}	O
else	O
if	O
(	O
state	*(int)
==	O
1	int
)	O
{	O
state	*(int)
=	O
2	int
;	O
}	O
else	O
if	O
(	O
state	*(int)
==	O
9	int
)	O
{	O
if	O
(	O
!	O
IS_SYMBOL_COMPONENT	O
(	O
ch	O
)	O
)	O
state	*(int)
=	O
3	int
;	O
}	O
else	O
if	O
(	O
state	*(int)
==	O
10	int
)	O
{	O
if	O
(	O
ch	O
==	O
'\\'	O
)	O
{	O
if	O
(	O
to	O
+	O
1	int
>=	O
toend	O
)	O
{	O
UNGET	O
(	O
ch	O
)	O
;	O
goto	O
tofull	O
;	O
}	O
*	O
to	O
++	O
=	O
' '	O
;	O
}	O
state	*(int)
=	O
3	int
;	O
}	O
PUT	O
(	O
ch	O
)	O
;	O
break	O
;	O
}	O
}	O
fromeof	O
:	O
return	O
to	O
-	O
tostart	O
;	O
tofull	O
:	O
if	O
(	O
fromend	O
>	O
from	O
)	O
{	O
saved_input	O
=	O
from	O
;	O
saved_input_len	O
=	O
fromend	O
-	O
from	O
;	O
}	O
else	O
saved_input	O
=	O
NULL	O
;	O
return	O
to	O
-	O
tostart	O
;	O
}	O
