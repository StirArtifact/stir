static	O
void	O
set_default_dirlist	O
(	O
char	O
*	O
)	O
;	O
static	O
void	O
set_section_start	O
(	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
void	O
set_segment_start	O
(	O
const	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
void	O
help	O
(	O
void	O
)	O
;	O
enum	O
control_enum	O
{	O
ONE_DASH	O
=	O
1	int
,	O
TWO_DASHES	O
=	O
2	int
,	O
EXACTLY_TWO_DASHES	O
,	O
NO_HELP	O
}	O
;	O
struct	O
ld_option	O
{	O
struct	O
option	O
opt	O
;	O
char	O
shortopt	O
;	O
const	O
char	O
*	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
const	O
char	O
*	O
doc	O
;	O
enum	O
control_enum	O
control	O
;	O
}	O
;	O
static	O
const	O
struct	O
ld_option	O
ld_options	O
[	O
]	O
=	O
{	O
{	O
{	O
NULL	O
,	O
required_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'a'	O
,	O
N_	O
(	O
"KEYWORD"	*(char)
)	O
,	O
N_	O
(	O
"Shared library control for HP/UX compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"architecture"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'A'	O
}	O
,	O
'A'	O
,	O
N_	O
(	O
"ARCH"	*(char)
)	O
,	O
N_	O
(	O
"Set architecture"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"format"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'b'	O
}	O
,	O
'b'	O
,	O
N_	O
(	O
"TARGET"	*(char)
)	O
,	O
N_	O
(	O
"Specify target for following input files"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"mri-script"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'c'	O
}	O
,	O
'c'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Read MRI format linker script"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dc"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'd'	O
}	O
,	O
'd'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force common symbols to be defined"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"dp"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'd'	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"force-group-allocation"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_FORCE_GROUP_ALLOCATION	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force group members out of groups"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"entry"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'e'	O
}	O
,	O
'e'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set start address"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"export-dynamic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_EXPORT_DYNAMIC	O
}	O
,	O
'E'	O
,	O
NULL	O
,	O
N_	O
(	O
"Export all dynamic symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-export-dynamic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_EXPORT_DYNAMIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Undo the effect of --export-dynamic"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"EB"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_EB	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link big-endian objects"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"EL"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_EL	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link little-endian objects"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"auxiliary"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'f'	O
}	O
,	O
'f'	O
,	O
N_	O
(	O
"SHLIB"	*(char)
)	O
,	O
N_	O
(	O
"Auxiliary filter for shared object symbol table"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"filter"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'F'	O
}	O
,	O
'F'	O
,	O
N_	O
(	O
"SHLIB"	*(char)
)	O
,	O
N_	O
(	O
"Filter for shared object symbol table"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'g'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"gpsize"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'G'	O
}	O
,	O
'G'	O
,	O
N_	O
(	O
"SIZE"	*(char)
)	O
,	O
N_	O
(	O
"Small data size (if no size, same as --shared)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"soname"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_SONAME	O
}	O
,	O
'h'	O
,	O
N_	O
(	O
"FILENAME"	*(char)
)	O
,	O
N_	O
(	O
"Set internal name of shared library"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"dynamic-linker"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_DYNAMIC_LINKER	O
}	O
,	O
'I'	O
,	O
N_	O
(	O
"PROGRAM"	*(char)
)	O
,	O
N_	O
(	O
"Set PROGRAM as the dynamic linker to use"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-dynamic-linker"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_DYNAMIC_LINKER	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Produce an executable with no program interpreter header"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"library"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'l'	O
}	O
,	O
'l'	O
,	O
N_	O
(	O
"LIBNAME"	*(char)
)	O
,	O
N_	O
(	O
"Search for library LIBNAME"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"library-path"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'L'	O
}	O
,	O
'L'	O
,	O
N_	O
(	O
"DIRECTORY"	*(char)
)	O
,	O
N_	O
(	O
"Add DIRECTORY to library search path"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"sysroot=<DIRECTORY>"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_SYSROOT	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Override the default sysroot location"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'm'	O
,	O
N_	O
(	O
"EMULATION"	*(char)
)	O
,	O
N_	O
(	O
"Set emulation"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"print-map"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'M'	O
}	O
,	O
'M'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print map file on standard output"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"nmagic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'n'	O
}	O
,	O
'n'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not page align data"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"omagic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'N'	O
}	O
,	O
'N'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not page align data, do not make text readonly"	*(char)
)	O
,	O
EXACTLY_TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-omagic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_OMAGIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Page align data, make text readonly"	*(char)
)	O
,	O
EXACTLY_TWO_DASHES	O
}	O
,	O
{	O
{	O
"output"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'o'	O
}	O
,	O
'o'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Set output file name"	*(char)
)	O
,	O
EXACTLY_TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'O'	O
,	O
NULL	O
,	O
N_	O
(	O
"Optimize output file"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"out-implib"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_OUT_IMPLIB	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Generate import library"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"plugin"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_PLUGIN	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PLUGIN"	*(char)
)	O
,	O
N_	O
(	O
"Load named plugin"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"plugin-opt"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_PLUGIN_OPT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ARG"	*(char)
)	O
,	O
N_	O
(	O
"Send arg to last-loaded plugin"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"flto"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC LTO option compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"flto-partition="	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC LTO option compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"fuse-ld="	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC linker option compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"map-whole-files"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for gold option compatibility"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-map-whole-files"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for gold option compatibility"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"Qy"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for SVR4 compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"emit-relocs"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'q'	O
}	O
,	O
'q'	O
,	O
NULL	O
,	O
"Generate relocations in final output"	*(char)
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"relocatable"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'r'	O
}	O
,	O
'r'	O
,	O
NULL	O
,	O
N_	O
(	O
"Generate relocatable output"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'i'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"just-symbols"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'R'	O
}	O
,	O
'R'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Just link symbols (if directory, same as --rpath)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"strip-all"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
's'	O
}	O
,	O
's'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip all symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"strip-debug"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'S'	O
}	O
,	O
'S'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip debugging symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"strip-discarded"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_STRIP_DISCARDED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip symbols in discarded sections"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-strip-discarded"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_STRIP_DISCARDED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not strip symbols in discarded sections"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"trace"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
't'	O
}	O
,	O
't'	O
,	O
NULL	O
,	O
N_	O
(	O
"Trace file opens"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"script"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'T'	O
}	O
,	O
'T'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Read linker script"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"default-script"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_DEFAULT_SCRIPT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Read default linker script"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dT"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_DEFAULT_SCRIPT	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"undefined"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'u'	O
}	O
,	O
'u'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Start with undefined reference to SYMBOL"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"require-defined"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_REQUIRE_DEFINED_SYMBOL	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Require SYMBOL be defined in the final output"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"unique"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_UNIQUE	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=SECTION]"	*(char)
)	O
,	O
N_	O
(	O
"Don't merge input [SECTION | orphan] sections"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"Ur"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_UR	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Build global constructor/destructor tables"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_VERSION	O
}	O
,	O
'v'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print version information"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'V'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print version and emulation information"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"discard-all"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'x'	O
}	O
,	O
'x'	O
,	O
NULL	O
,	O
N_	O
(	O
"Discard all local symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"discard-locals"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'X'	O
}	O
,	O
'X'	O
,	O
NULL	O
,	O
N_	O
(	O
"Discard temporary local symbols (default)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"discard-none"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DISCARD_NONE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't discard any local symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"trace-symbol"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'y'	O
}	O
,	O
'y'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Trace mentions of SYMBOL"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	O
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'Y'	O
,	O
N_	O
(	O
"PATH"	*(char)
)	O
,	O
N_	O
(	O
"Default search path for Solaris compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"start-group"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'('	O
}	O
,	O
'('	O
,	O
NULL	O
,	O
N_	O
(	O
"Start a group"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"end-group"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
')'	O
}	O
,	O
')'	O
,	O
NULL	O
,	O
N_	O
(	O
"End a group"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"accept-unknown-input-arch"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ACCEPT_UNKNOWN_INPUT_ARCH	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Accept input files whose architecture cannot be determined"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-accept-unknown-input-arch"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reject input files whose architecture is unknown"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"add-needed"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	O
}	O
,	O
{	O
{	O
"no-add-needed"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	O
}	O
,	O
{	O
{	O
"as-needed"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_REGULAR	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Only set DT_NEEDED for following dynamic libs if used"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-as-needed"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Always set DT_NEEDED for dynamic libraries mentioned on\n"	*(char)
"                                the command line"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"assert"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_ASSERT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"KEYWORD"	*(char)
)	O
,	O
N_	O
(	O
"Ignored for SunOS compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Bdynamic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_CALL_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link against shared libraries"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"dy"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_CALL_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"call_shared"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_CALL_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Bstatic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NON_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not link against shared libraries"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"dn"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NON_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"non_shared"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NON_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"static"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NON_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Bsymbolic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_SYMBOLIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Bind global references locally"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Bsymbolic-functions"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_SYMBOLIC_FUNCTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Bind global function references locally"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"check-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_CHECK_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Check section addresses for overlaps (default)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-check-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_CHECK_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not check section addresses for overlaps"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"copy-dt-needed-entries"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Copy DT_NEEDED links mentioned inside DSOs that follow"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-copy-dt-needed-entries"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not copy DT_NEEDED links mentioned inside DSOs that follow"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"cref"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_CREF	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Output cross reference table"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"defsym"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_DEFSYM	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL=EXPRESSION"	*(char)
)	O
,	O
N_	O
(	O
"Define a symbol"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"demangle"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_DEMANGLE	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=STYLE]"	*(char)
)	O
,	O
N_	O
(	O
"Demangle symbol names [using STYLE]"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"disable-multiple-abs-defs"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DISABLE_MULTIPLE_DEFS_ABS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow multiple definitions with symbols included\n"	*(char)
"           in filename invoked by -R or --just-symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"embedded-relocs"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_EMBEDDED_RELOCS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Generate embedded relocs"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"fatal-warnings"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_FATAL	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Treat warnings as errors"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-fatal-warnings"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_WARN_FATAL	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not treat warnings as errors (default)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"fini"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_FINI	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Call SYMBOL at unload-time"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"force-exe-suffix"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_FORCE_EXE_SUFFIX	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force generation of file with .exe suffix"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"gc-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_GC_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Remove unused sections (on some targets)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-gc-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_GC_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't remove unused sections (default)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"print-gc-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PRINT_GC_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"List removed unused sections on stderr"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-print-gc-sections"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_PRINT_GC_SECTIONS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not list removed unused sections"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"gc-keep-exported"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_GC_KEEP_EXPORTED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Keep exported symbols when removing unused sections"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"hash-size=<NUMBER>"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_HASH_SIZE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Set default hash table size close to <NUMBER>"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_HELP	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print option help"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"init"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_INIT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Call SYMBOL at load-time"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Map"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_MAP	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Write a map file"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"no-define-common"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_DEFINE_COMMON	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not define Common storage"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-demangle"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_DEMANGLE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not demangle symbol names"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-keep-memory"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_KEEP_MEMORY	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use less memory and more disk I/O"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-undefined"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_UNDEFINED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow unresolved references in object files"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"allow-shlib-undefined"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ALLOW_SHLIB_UNDEFINED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Allow unresolved references in shared libraries"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-allow-shlib-undefined"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_ALLOW_SHLIB_UNDEFINED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow unresolved references in shared libs"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"allow-multiple-definition"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ALLOW_MULTIPLE_DEFINITION	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Allow multiple definitions"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-undefined-version"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_UNDEFINED_VERSION	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Disallow undefined version"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"default-symver"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DEFAULT_SYMVER	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create default symbol version"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"default-imported-symver"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DEFAULT_IMPORTED_SYMVER	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create default symbol version for imported symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-warn-mismatch"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_WARN_MISMATCH	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't warn about mismatched input files"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-warn-search-mismatch"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_WARN_SEARCH_MISMATCH	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't warn on finding an incompatible library"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-whole-archive"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_WHOLE_ARCHIVE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Turn off --whole-archive"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"noinhibit-exec"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NOINHIBIT_EXEC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create an output file even if errors occur"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"noinhibit_exec"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NOINHIBIT_EXEC	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	O
}	O
,	O
{	O
{	O
"nostdlib"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NOSTDLIB	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Only use library directories specified on\n"	*(char)
"                                the command line"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"oformat"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_OFORMAT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"TARGET"	*(char)
)	O
,	O
N_	O
(	O
"Specify target of output file"	*(char)
)	O
,	O
EXACTLY_TWO_DASHES	O
}	O
,	O
{	O
{	O
"print-output-format"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PRINT_OUTPUT_FORMAT	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print default output format"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"print-sysroot"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PRINT_SYSROOT	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print current sysroot"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"qmagic"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for Linux compatibility"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"reduce-memory-overheads"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_REDUCE_MEMORY_OVERHEADS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reduce memory overheads, possibly taking much longer"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"relax"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_RELAX	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reduce code size by using target specific optimizations"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-relax"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_RELAX	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not use relaxation techniques to reduce code size"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"retain-symbols-file"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_RETAIN_SYMBOLS_FILE	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Keep only symbols listed in FILE"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"rpath"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_RPATH	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PATH"	*(char)
)	O
,	O
N_	O
(	O
"Set runtime shared library search path"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"rpath-link"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_RPATH_LINK	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PATH"	*(char)
)	O
,	O
N_	O
(	O
"Set link time shared library search path"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"shared"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create a shared library"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Bshareable"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_SHARED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"pie"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PIE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create a position independent executable"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"pic-executable"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PIE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"sort-common"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_SORT_COMMON	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=ascending|descending]"	*(char)
)	O
,	O
N_	O
(	O
"Sort common symbols by alignment [in specified order]"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"sort_common"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_SORT_COMMON	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	O
}	O
,	O
{	O
{	O
"sort-section"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_SORT_SECTION	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"name|alignment"	*(char)
)	O
,	O
N_	O
(	O
"Sort sections by name or maximum alignment"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"spare-dynamic-tags"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_SPARE_DYNAMIC_TAGS	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"COUNT"	*(char)
)	O
,	O
N_	O
(	O
"How many tags to reserve in .dynamic section"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"split-by-file"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_SPLIT_BY_FILE	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=SIZE]"	*(char)
)	O
,	O
N_	O
(	O
"Split output sections every SIZE octets"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"split-by-reloc"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_SPLIT_BY_RELOC	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=COUNT]"	*(char)
)	O
,	O
N_	O
(	O
"Split output sections every COUNT relocs"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"stats"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_STATS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print memory usage statistics"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"target-help"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_TARGET_HELP	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Display target specific options"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"task-link"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TASK_LINK	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Do task level linking"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"traditional-format"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_TRADITIONAL_FORMAT	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use same format as native linker"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"section-start"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_SECTION_START	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SECTION=ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of named section"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"Tbss"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TBSS	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of .bss section"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Tdata"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TDATA	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of .data section"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Ttext"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TTEXT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of .text section"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Ttext-segment"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TTEXT_SEGMENT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of text segment"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Trodata-segment"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TRODATA_SEGMENT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of rodata segment"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"Tldata-segment"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_TLDATA_SEGMENT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
N_	O
(	O
"Set address of ldata segment"	*(char)
)	O
,	O
ONE_DASH	O
}	O
,	O
{	O
{	O
"unresolved-symbols=<method>"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_UNRESOLVED_SYMBOLS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"How to handle unresolved symbols.  <method> is:\n"	*(char)
"                                ignore-all, report-all, ignore-in-object-files,\n"	*(char)
"                                ignore-in-shared-libs"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"verbose"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
OPTION_VERBOSE	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=NUMBER]"	*(char)
)	O
,	O
N_	O
(	O
"Output lots of information during link"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dll-verbose"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_VERBOSE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	O
}	O
,	O
{	O
{	O
"version-script"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_VERSION_SCRIPT	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Read version information script"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"version-exports-section"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_VERSION_EXPORTS_SECTION	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Take export symbols list from .exports, using\n"	*(char)
"                                SYMBOL as the version."	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dynamic-list-data"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_DATA	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Add data symbols to dynamic list"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dynamic-list-cpp-new"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_CPP_NEW	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use C++ operator new/delete dynamic list"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dynamic-list-cpp-typeinfo"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_CPP_TYPEINFO	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use C++ typeinfo dynamic list"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"dynamic-list"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
N_	O
(	O
"Read dynamic list"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-common"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_COMMON	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn about duplicate common symbols"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-constructors"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_CONSTRUCTORS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if global constructors/destructors are seen"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-multiple-gp"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_MULTIPLE_GP	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if the multiple GP values are used"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-once"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_ONCE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn only once per undefined symbol"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-section-align"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_SECTION_ALIGN	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if start of section changes due to alignment"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-shared-textrel"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_SHARED_TEXTREL	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if shared object has DT_TEXTREL"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-alternate-em"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_ALTERNATE_EM	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if an object has alternate ELF machine code"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"warn-unresolved-symbols"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WARN_UNRESOLVED_SYMBOLS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report unresolved symbols as warnings"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"error-unresolved-symbols"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_ERROR_UNRESOLVED_SYMBOLS	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report unresolved symbols as errors"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"whole-archive"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_WHOLE_ARCHIVE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Include all objects from following archives"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"wrap"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_WRAP	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Use wrapper functions for SYMBOL"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"ignore-unresolved-symbol"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_IGNORE_UNRESOLVED_SYMBOL	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	*(char)
)	O
,	O
N_	O
(	O
"Unresolved SYMBOL will not cause an error or warning"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"push-state"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PUSH_STATE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Push state of flags governing input file handling"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"pop-state"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_POP_STATE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Pop state of flags governing input file handling"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"print-memory-usage"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PRINT_MEMORY_USAGE	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report target memory usage"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"orphan-handling"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
OPTION_ORPHAN_HANDLING	O
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"=MODE"	*(char)
)	O
,	O
N_	O
(	O
"Control how orphan sections are handled."	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"print-map-discarded"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_PRINT_MAP_DISCARDED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Show discarded sections in map file output (default)"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
{	O
{	O
"no-print-map-discarded"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
OPTION_NO_PRINT_MAP_DISCARDED	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not show discarded sections in map file output"	*(char)
)	O
,	O
TWO_DASHES	O
}	O
,	O
}	O
;	O
void	O
parse_args	O
(	O
unsigned	O
argc	O
,	O
char	O
*	O
*	O
argv	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
int	O
is	O
,	O
il	O
,	O
irl	O
;	O
int	O
ingroup	O
=	O
0	int
;	O
char	O
*	O
default_dirlist	O
=	O
NULL	O
;	O
char	O
*	O
shortopts	O
;	O
struct	O
option	O
*	O
longopts	O
;	O
struct	O
option	O
*	O
really_longopts	O
;	O
int	O
last_optind	O
;	O
enum	O
report_method	O
how_to_report_unresolved_symbols	O
=	O
RM_GENERATE_ERROR	O
;	O
enum	O
symbolic_enum	O
{	O
symbolic_unset	O
=	O
0	int
,	O
symbolic	O
,	O
symbolic_functions	O
,	O
}	O
opt_symbolic	O
=	O
symbolic_unset	O
;	O
enum	O
dynamic_list_enum	O
{	O
dynamic_list_unset	O
=	O
0	int
,	O
dynamic_list_data	O
,	O
dynamic_list	O
}	O
opt_dynamic_list	O
=	O
dynamic_list_unset	O
;	O
shortopts	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
OPTION_COUNT	O
*	O
3	int
+	O
2	int
)	O
;	O
longopts	O
=	O
(	O
struct	O
option	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
*	O
longopts	O
)	O
*	O
(	O
OPTION_COUNT	O
+	O
1	int
)	O
)	O
;	O
really_longopts	O
=	O
(	O
struct	O
option	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
really_longopts	O
)	O
*	O
(	O
OPTION_COUNT	O
+	O
1	int
)	O
)	O
;	O
shortopts	O
[	O
0	int
]	O
=	O
'-'	O
;	O
is	O
=	O
1	int
;	O
il	O
=	O
0	int
;	O
irl	O
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
OPTION_COUNT	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
shortopt	O
!=	O
'\0'	O
)	O
{	O
shortopts	O
[	O
is	O
]	O
=	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
shortopt	O
;	O
++	O
is	O
;	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
.	O
has_arg	O
==	O
required_argument	O
||	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
.	O
has_arg	O
==	O
optional_argument	O
)	O
{	O
shortopts	O
[	O
is	O
]	O
=	O
':'	O
;	O
++	O
is	O
;	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
.	O
has_arg	O
==	O
optional_argument	O
)	O
{	O
shortopts	O
[	O
is	O
]	O
=	O
':'	O
;	O
++	O
is	O
;	O
}	O
}	O
}	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
.	O
name	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
control	O
==	O
EXACTLY_TWO_DASHES	O
)	O
{	O
really_longopts	O
[	O
irl	O
]	O
=	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
;	O
++	O
irl	O
;	O
}	O
else	O
{	O
longopts	O
[	O
il	O
]	O
=	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
opt	O
;	O
++	O
il	O
;	O
}	O
}	O
}	O
shortopts	O
[	O
is	O
]	O
=	O
'\0'	O
;	O
longopts	O
[	O
il	O
]	O
.	O
name	*(char)
=	O
NULL	O
;	O
really_longopts	O
[	O
irl	O
]	O
.	O
name	*(char)
=	O
NULL	O
;	O
ldemul_add_options	O
(	O
is	O
,	O
&	O
shortopts	O
,	O
il	O
,	O
&	O
longopts	O
,	O
irl	O
,	O
&	O
really_longopts	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
1	int
;	O
i	*(struct)
<	O
argc	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
i	*(struct)
]	O
,	O
"-G"	*(char)
)	O
==	O
0	int
&&	O
(	O
i	*(struct)
+	O
1	int
>=	O
argc	O
||	O
!	O
ISDIGIT	O
(	O
argv	O
[	O
i	*(struct)
+	O
1	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
argv	O
[	O
i	*(struct)
]	O
=	O
(	O
char	O
*	O
)	O
"--shared"	*(char)
;	O
for	O
(	O
i	*(struct)
=	O
1	int
;	O
i	*(struct)
<	O
argc	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
argv	O
[	O
i	*(struct)
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
argv	O
[	O
i	*(struct)
]	O
[	O
1	int
]	O
==	O
'l'	O
&&	O
argv	O
[	O
i	*(struct)
]	O
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
n	O
;	O
n	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
strlen	(*(char))->(long)
(	O
argv	O
[	O
i	*(struct)
]	O
)	O
+	O
20	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
n	O
,	O
"--library=%s"	*(char)
,	O
argv	O
[	O
i	*(struct)
]	O
+	O
2	int
)	O
;	O
argv	O
[	O
i	*(struct)
]	O
=	O
n	O
;	O
}	O
}	O
last_optind	O
=	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
longind	O
;	O
int	O
optc	O
;	O
static	O
unsigned	O
int	O
defsym_count	O
;	O
if	O
(	O
optind	int
!=	O
last_optind	O
)	O
if	O
(	O
ldemul_parse_args	O
(	O
argc	O
,	O
argv	O
)	O
)	O
continue	O
;	O
opterr	int
=	O
0	int
;	O
last_optind	O
=	O
optind	int
;	O
optc	O
=	O
getopt_long_only	O
(	O
argc	O
,	O
argv	O
,	O
shortopts	O
,	O
longopts	O
,	O
&	O
longind	O
)	O
;	O
if	O
(	O
optc	O
==	O
'?'	O
)	O
{	O
optind	int
=	O
last_optind	O
;	O
optc	O
=	O
getopt_long	O
(	O
argc	O
,	O
argv	O
,	O
"-"	*(char)
,	O
really_longopts	O
,	O
&	O
longind	O
)	O
;	O
}	O
if	O
(	O
ldemul_handle_option	O
(	O
optc	O
)	O
)	O
continue	O
;	O
if	O
(	O
optc	O
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
optc	O
)	O
{	O
case	O
'?'	O
:	O
{	O
int	O
opt	O
;	O
for	O
(	O
opt	O
=	O
ARRAY_SIZE	O
(	O
ld_options	O
)	O
;	O
opt	O
--	O
;	O
)	O
if	O
(	O
ld_options	O
[	O
opt	O
]	O
.	O
opt	O
.	O
has_arg	O
==	O
required_argument	O
&&	O
ld_options	O
[	O
opt	O
]	O
.	O
opt	O
.	O
name	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
argv	O
[	O
last_optind	O
]	O
+	O
ld_options	O
[	O
opt	O
]	O
.	O
control	O
,	O
ld_options	O
[	O
opt	O
]	O
.	O
opt	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
einfo	O
(	O
_	O
(	O
"%P: %s: missing argument\n"	*(char)
)	O
,	O
argv	O
[	O
last_optind	O
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
opt	O
==	O
-	O
1	int
)	O
einfo	O
(	O
_	O
(	O
"%P: unrecognized option '%s'\n"	*(char)
)	O
,	O
argv	O
[	O
last_optind	O
]	O
)	O
;	O
}	O
default	O
:	O
einfo	O
(	O
_	O
(	O
"%F%P: use the --help option for usage information\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
lang_add_input_file	O
(	O
optarg	*(char)
,	O
lang_input_file_is_file_enum	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
OPTION_IGNORE	O
:	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"archive"	*(char)
)	O
==	O
0	int
)	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"shared"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"default"	*(char)
)	O
==	O
0	int
)	O
input_flags	O
.	O
dynamic	O
=	O
TRUE	int
;	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: unrecognized -a option `%s'\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_ASSERT	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"definitions"	*(char)
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"nodefinitions"	*(char)
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"nosymbolic"	*(char)
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"pure-text"	*(char)
)	O
==	O
0	int
)	O
;	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: unrecognized -assert option `%s'\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
ldfile_add_arch	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
lang_add_target	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
ldfile_open_command_file	O
(	O
optarg	*(char)
)	O
;	O
parser_input	O
=	O
input_mri_script	O
;	O
yyparse	O
(	O
)	O
;	O
break	O
;	O
case	O
OPTION_CALL_SHARED	O
:	O
input_flags	O
.	O
dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NON_SHARED	O
:	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_CREF	O
:	O
command_line	O
.	O
cref	O
=	O
TRUE	int
;	O
link_info	O
.	O
notice_all	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'd'	O
:	O
command_line	O
.	O
force_common_definition	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_FORCE_GROUP_ALLOCATION	O
:	O
command_line	O
.	O
force_group_allocation	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_DEFSYM	O
:	O
lex_string	O
=	O
optarg	*(char)
;	O
lex_redirect	O
(	O
optarg	*(char)
,	O
"--defsym"	*(char)
,	O
++	O
defsym_count	O
)	O
;	O
parser_input	O
=	O
input_defsym	O
;	O
yyparse	O
(	O
)	O
;	O
lex_string	O
=	O
NULL	O
;	O
break	O
;	O
case	O
OPTION_DEMANGLE	O
:	O
demangling	O
=	O
TRUE	int
;	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
{	O
enum	O
demangling_styles	O
style	O
;	O
style	O
=	O
cplus_demangle_name_to_style	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
style	O
==	O
unknown_demangling	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: unknown demangling style `%s'\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
cplus_demangle_set_style	O
(	O
style	O
)	O
;	O
}	O
break	O
;	O
case	O
'I'	O
:	O
case	O
OPTION_DYNAMIC_LINKER	O
:	O
command_line	O
.	O
interpreter	O
=	O
optarg	*(char)
;	O
link_info	O
.	O
nointerp	O
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_NO_DYNAMIC_LINKER	O
:	O
link_info	O
.	O
nointerp	O
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_SYSROOT	O
:	O
break	O
;	O
case	O
OPTION_EB	O
:	O
command_line	O
.	O
endian	O
=	O
ENDIAN_BIG	O
;	O
break	O
;	O
case	O
OPTION_EL	O
:	O
command_line	O
.	O
endian	O
=	O
ENDIAN_LITTLE	O
;	O
break	O
;	O
case	O
OPTION_EMBEDDED_RELOCS	O
:	O
command_line	O
.	O
embedded_relocs	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_EXPORT_DYNAMIC	O
:	O
case	O
'E'	O
:	O
link_info	O
.	O
export_dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_EXPORT_DYNAMIC	O
:	O
link_info	O
.	O
export_dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'e'	O
:	O
lang_add_entry	O
(	O
optarg	*(char)
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
command_line	O
.	O
auxiliary_filters	O
==	O
NULL	O
)	O
{	O
command_line	O
.	O
auxiliary_filters	O
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	O
(	O
2	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
command_line	O
.	O
auxiliary_filters	O
[	O
0	int
]	O
=	O
optarg	*(char)
;	O
command_line	O
.	O
auxiliary_filters	O
[	O
1	int
]	O
=	O
NULL	O
;	O
}	O
else	O
{	O
int	O
c	O
;	O
char	O
*	O
*	O
p	*(void)
;	O
c	O
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
command_line	O
.	O
auxiliary_filters	O
;	O
*	O
p	*(void)
!=	O
NULL	O
;	O
p	*(void)
++	O
)	O
++	O
c	O
;	O
command_line	O
.	O
auxiliary_filters	O
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	O
(	O
command_line	O
.	O
auxiliary_filters	O
,	O
(	O
c	O
+	O
2	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
command_line	O
.	O
auxiliary_filters	O
[	O
c	O
]	O
=	O
optarg	*(char)
;	O
command_line	O
.	O
auxiliary_filters	O
[	O
c	O
+	O
1	int
]	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
command_line	O
.	O
filter_shlib	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_FORCE_EXE_SUFFIX	O
:	O
command_line	O
.	O
force_exe_suffix	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'G'	O
:	O
{	O
char	O
*	O
end	*(*(char))
;	O
g_switch_value	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
end	*(*(char))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	*(*(char))
)	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid number `%s'\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'g'	O
:	O
break	O
;	O
case	O
OPTION_GC_SECTIONS	O
:	O
link_info	O
.	O
gc_sections	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_PRINT_GC_SECTIONS	O
:	O
link_info	O
.	O
print_gc_sections	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_GC_KEEP_EXPORTED	O
:	O
link_info	O
.	O
gc_keep_exported	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_HELP	O
:	O
help	O
(	O
)	O
;	O
xexit	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
ldfile_add_library_path	O
(	O
optarg	*(char)
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
lang_add_input_file	O
(	O
optarg	*(char)
,	O
lang_input_file_is_l_enum	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
config	O
.	O
map_filename	O
=	O
"-"	*(char)
;	O
break	O
;	O
case	O
'm'	O
:	O
break	O
;	O
case	O
OPTION_MAP	O
:	O
config	O
.	O
map_filename	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'N'	O
:	O
config	O
.	O
text_read_only	O
=	O
FALSE	O
;	O
config	O
.	O
magic_demand_paged	O
=	O
FALSE	O
;	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_OMAGIC	O
:	O
config	O
.	O
text_read_only	O
=	O
TRUE	int
;	O
config	O
.	O
magic_demand_paged	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
config	O
.	O
magic_demand_paged	O
=	O
FALSE	O
;	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_DEFINE_COMMON	O
:	O
link_info	O
.	O
inhibit_common_definition	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_DEMANGLE	O
:	O
demangling	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_GC_SECTIONS	O
:	O
link_info	O
.	O
gc_sections	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_PRINT_GC_SECTIONS	O
:	O
link_info	O
.	O
print_gc_sections	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_KEEP_MEMORY	O
:	O
link_info	O
.	O
keep_memory	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_UNDEFINED	O
:	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
how_to_report_unresolved_symbols	O
;	O
break	O
;	O
case	O
OPTION_ALLOW_SHLIB_UNDEFINED	O
:	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_IGNORE	O
;	O
break	O
;	O
case	O
OPTION_NO_ALLOW_SHLIB_UNDEFINED	O
:	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
how_to_report_unresolved_symbols	O
;	O
break	O
;	O
case	O
OPTION_UNRESOLVED_SYMBOLS	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"ignore-all"	*(char)
)	O
==	O
0	int
)	O
{	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
RM_IGNORE	O
;	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_IGNORE	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"report-all"	*(char)
)	O
==	O
0	int
)	O
{	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
how_to_report_unresolved_symbols	O
;	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
how_to_report_unresolved_symbols	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"ignore-in-object-files"	*(char)
)	O
==	O
0	int
)	O
{	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
RM_IGNORE	O
;	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
how_to_report_unresolved_symbols	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"ignore-in-shared-libs"	*(char)
)	O
==	O
0	int
)	O
{	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
how_to_report_unresolved_symbols	O
;	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_IGNORE	O
;	O
}	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: bad --unresolved-symbols option: %s\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_WARN_UNRESOLVED_SYMBOLS	O
:	O
how_to_report_unresolved_symbols	O
=	O
RM_GENERATE_WARNING	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_objects	O
==	O
RM_GENERATE_ERROR	O
)	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
RM_GENERATE_WARNING	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
==	O
RM_GENERATE_ERROR	O
)	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_GENERATE_WARNING	O
;	O
break	O
;	O
case	O
OPTION_ERROR_UNRESOLVED_SYMBOLS	O
:	O
how_to_report_unresolved_symbols	O
=	O
RM_GENERATE_ERROR	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_objects	O
==	O
RM_GENERATE_WARNING	O
)	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
RM_GENERATE_ERROR	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
==	O
RM_GENERATE_WARNING	O
)	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_GENERATE_ERROR	O
;	O
break	O
;	O
case	O
OPTION_ALLOW_MULTIPLE_DEFINITION	O
:	O
link_info	O
.	O
allow_multiple_definition	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_UNDEFINED_VERSION	O
:	O
link_info	O
.	O
allow_undefined_version	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_DEFAULT_SYMVER	O
:	O
link_info	O
.	O
create_default_symver	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_DEFAULT_IMPORTED_SYMVER	O
:	O
link_info	O
.	O
default_imported_symver	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WARN_MISMATCH	O
:	O
command_line	O
.	O
warn_mismatch	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NO_WARN_SEARCH_MISMATCH	O
:	O
command_line	O
.	O
warn_search_mismatch	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_NOINHIBIT_EXEC	O
:	O
force_make_executable	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NOSTDLIB	O
:	O
config	O
.	O
only_cmd_line_lib_dirs	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WHOLE_ARCHIVE	O
:	O
input_flags	O
.	O
whole_archive	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'O'	O
:	O
link_info	O
.	O
optimize	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
?	O
TRUE	int
:	O
FALSE	O
;	O
break	O
;	O
case	O
'o'	O
:	O
lang_add_output	O
(	O
optarg	*(char)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_OFORMAT	O
:	O
lang_add_output_format	O
(	O
optarg	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_OUT_IMPLIB	O
:	O
command_line	O
.	O
out_implib_filename	O
=	O
xstrdup	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_PRINT_SYSROOT	O
:	O
if	O
(	O
*	O
ld_sysroot	O
)	O
puts	(*(char))->(int)
(	O
ld_sysroot	O
)	O
;	O
xexit	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_PRINT_OUTPUT_FORMAT	O
:	O
command_line	O
.	O
print_output_format	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_PLUGIN	O
:	O
plugin_opt_plugin	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_PLUGIN_OPT	O
:	O
if	O
(	O
plugin_opt_plugin_arg	O
(	O
optarg	*(char)
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: bad -plugin-opt option\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
link_info	O
.	O
emitrelocations	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'r'	O
:	O
if	O
(	O
optind	int
==	O
last_optind	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: unrecognised option: %s\n"	*(char)
)	O
,	O
argv	O
[	O
optind	int
]	O
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
&	O
link_info	O
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	*(char)
)	O
,	O
bfd_link_dll	O
(	O
&	O
link_info	O
)	O
?	O
"-shared"	*(char)
:	O
"-pie"	*(char)
)	O
;	O
link_info	O
.	O
type	enum(int,int,int,int)
=	O
type_relocatable	O
;	O
config	O
.	O
build_constructors	O
=	O
FALSE	O
;	O
config	O
.	O
magic_demand_paged	O
=	O
FALSE	O
;	O
config	O
.	O
text_read_only	O
=	O
FALSE	O
;	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'R'	O
:	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
optarg	*(char)
,	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
>=	O
0	int
&&	O
!	O
S_ISDIR	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
.	O
st_mode	int
)	O
)	O
{	O
lang_add_input_file	O
(	O
optarg	*(char)
,	O
lang_input_file_is_symbols_only_enum	O
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
}	O
case	O
OPTION_RPATH	O
:	O
if	O
(	O
command_line	O
.	O
rpath	O
==	O
NULL	O
)	O
command_line	O
.	O
rpath	O
=	O
xstrdup	O
(	O
optarg	*(char)
)	O
;	O
else	O
{	O
size_t	long
rpath_len	O
=	O
strlen	(*(char))->(long)
(	O
command_line	O
.	O
rpath	O
)	O
;	O
size_t	long
optarg_len	O
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
;	O
char	O
*	O
buf	*(void)
;	O
char	O
*	O
cp	O
=	O
command_line	O
.	O
rpath	O
;	O
do	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
optarg	*(char)
,	O
cp	O
,	O
optarg_len	O
)	O
==	O
0	int
&&	O
(	O
cp	O
[	O
optarg_len	O
]	O
==	O
0	int
||	O
cp	O
[	O
optarg_len	O
]	O
==	O
config	O
.	O
rpath_separator	O
)	O
)	O
break	O
;	O
cp	O
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	O
,	O
config	O
.	O
rpath_separator	O
)	O
;	O
if	O
(	O
cp	O
!=	O
NULL	O
)	O
++	O
cp	O
;	O
}	O
while	O
(	O
cp	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
cp	O
==	O
NULL	O
)	O
{	O
buf	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
rpath_len	O
+	O
optarg_len	O
+	O
2	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%s%c%s"	*(char)
,	O
command_line	O
.	O
rpath	O
,	O
config	O
.	O
rpath_separator	O
,	O
optarg	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
command_line	O
.	O
rpath	O
)	O
;	O
command_line	O
.	O
rpath	O
=	O
buf	*(void)
;	O
}	O
}	O
break	O
;	O
case	O
OPTION_RPATH_LINK	O
:	O
if	O
(	O
command_line	O
.	O
rpath_link	O
==	O
NULL	O
)	O
command_line	O
.	O
rpath_link	O
=	O
xstrdup	O
(	O
optarg	*(char)
)	O
;	O
else	O
{	O
char	O
*	O
buf	*(void)
;	O
buf	*(void)
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
strlen	(*(char))->(long)
(	O
command_line	O
.	O
rpath_link	O
)	O
+	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
2	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%s%c%s"	*(char)
,	O
command_line	O
.	O
rpath_link	O
,	O
config	O
.	O
rpath_separator	O
,	O
optarg	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
command_line	O
.	O
rpath_link	O
)	O
;	O
command_line	O
.	O
rpath_link	O
=	O
buf	*(void)
;	O
}	O
break	O
;	O
case	O
OPTION_NO_RELAX	O
:	O
DISABLE_RELAXATION	O
;	O
break	O
;	O
case	O
OPTION_RELAX	O
:	O
ENABLE_RELAXATION	O
;	O
break	O
;	O
case	O
OPTION_RETAIN_SYMBOLS_FILE	O
:	O
add_keepsyms_file	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
link_info	O
.	O
strip	O
=	O
strip_debugger	O
;	O
break	O
;	O
case	O
's'	O
:	O
link_info	O
.	O
strip	O
=	O
strip_all	O
;	O
break	O
;	O
case	O
OPTION_STRIP_DISCARDED	O
:	O
link_info	O
.	O
strip_discarded	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_STRIP_DISCARDED	O
:	O
link_info	O
.	O
strip_discarded	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_DISABLE_MULTIPLE_DEFS_ABS	O
:	O
link_info	O
.	O
prohibit_multiple_definition_absolute	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_SHARED	O
:	O
if	O
(	O
config	O
.	O
has_shared	O
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	O
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	*(char)
)	O
,	O
"-shared"	*(char)
)	O
;	O
link_info	O
.	O
type	enum(int,int,int,int)
=	O
type_dll	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_objects	O
==	O
RM_NOT_YET_SET	O
)	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
RM_IGNORE	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
==	O
RM_NOT_YET_SET	O
)	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
RM_IGNORE	O
;	O
}	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: -shared not supported\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_PIE	O
:	O
if	O
(	O
config	O
.	O
has_shared	O
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	O
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	*(char)
)	O
,	O
"-pie"	*(char)
)	O
;	O
link_info	O
.	O
type	enum(int,int,int,int)
=	O
type_pie	O
;	O
}	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: -pie not supported\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
OPTION_SONAME	O
:	O
if	O
(	O
optarg	*(char)
[	O
0	int
]	O
==	O
'\0'	O
&&	O
command_line	O
.	O
soname	O
&&	O
command_line	O
.	O
soname	O
[	O
0	int
]	O
)	O
einfo	O
(	O
_	O
(	O
"%P: SONAME must not be empty string; keeping previous one\n"	*(char)
)	O
)	O
;	O
else	O
command_line	O
.	O
soname	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_SORT_COMMON	O
:	O
if	O
(	O
optarg	*(char)
==	O
NULL	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
N_	O
(	O
"descending"	*(char)
)	O
)	O
==	O
0	int
)	O
config	O
.	O
sort_common	O
=	O
sort_descending	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
N_	O
(	O
"ascending"	*(char)
)	O
)	O
==	O
0	int
)	O
config	O
.	O
sort_common	O
=	O
sort_ascending	O
;	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid common section sorting option: %s\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_SORT_SECTION	O
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
N_	O
(	O
"name"	*(char)
)	O
)	O
==	O
0	int
)	O
sort_section	O
=	O
by_name	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
N_	O
(	O
"alignment"	*(char)
)	O
)	O
==	O
0	int
)	O
sort_section	O
=	O
by_alignment	O
;	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid section sorting option: %s\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_STATS	O
:	O
config	O
.	O
stats	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_SYMBOLIC	O
:	O
opt_symbolic	O
=	O
symbolic	O
;	O
break	O
;	O
case	O
OPTION_SYMBOLIC_FUNCTIONS	O
:	O
opt_symbolic	O
=	O
symbolic_functions	O
;	O
break	O
;	O
case	O
't'	O
:	O
++	O
trace_files	O
;	O
break	O
;	O
case	O
'T'	O
:	O
previous_script_handle	O
=	O
saved_script_handle	O
;	O
ldfile_open_script_file	O
(	O
optarg	*(char)
)	O
;	O
parser_input	O
=	O
input_script	O
;	O
yyparse	O
(	O
)	O
;	O
previous_script_handle	O
=	O
NULL	O
;	O
break	O
;	O
case	O
OPTION_DEFAULT_SCRIPT	O
:	O
command_line	O
.	O
default_script	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_SECTION_START	O
:	O
{	O
char	O
*	O
optarg2	O
;	O
char	O
*	O
sec_name	O
;	O
int	O
len	long
;	O
optarg2	O
=	O
strchr	(*(char),int)->(*(char))
(	O
optarg	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
optarg2	O
==	O
NULL	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid argument to option"	*(char)
" \"--section-start\"\n"	*(char)
)	O
)	O
;	O
optarg2	O
++	O
;	O
if	O
(	O
(	O
*	O
optarg	*(char)
==	O
'\0'	O
)	O
||	O
(	O
*	O
optarg2	O
==	O
'\0'	O
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: missing argument(s) to option"	*(char)
" \"--section-start\"\n"	*(char)
)	O
)	O
;	O
len	long
=	O
optarg2	O
-	O
optarg	*(char)
;	O
sec_name	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
sec_name	O
,	O
optarg	*(char)
,	O
len	long
-	O
1	int
)	O
;	O
sec_name	O
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
set_section_start	O
(	O
sec_name	O
,	O
optarg2	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_TARGET_HELP	O
:	O
ldemul_list_emulation_options	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
OPTION_TBSS	O
:	O
set_segment_start	O
(	O
".bss"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TDATA	O
:	O
set_segment_start	O
(	O
".data"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TTEXT	O
:	O
set_segment_start	O
(	O
".text"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TTEXT_SEGMENT	O
:	O
set_segment_start	O
(	O
".text-segment"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TRODATA_SEGMENT	O
:	O
set_segment_start	O
(	O
".rodata-segment"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TLDATA_SEGMENT	O
:	O
set_segment_start	O
(	O
".ldata-segment"	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_TRADITIONAL_FORMAT	O
:	O
link_info	O
.	O
traditional_format	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_TASK_LINK	O
:	O
link_info	O
.	O
task_link	O
=	O
TRUE	int
;	O
case	O
OPTION_UR	O
:	O
if	O
(	O
bfd_link_pic	O
(	O
&	O
link_info	O
)	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	*(char)
)	O
,	O
bfd_link_dll	O
(	O
&	O
link_info	O
)	O
?	O
"-shared"	*(char)
:	O
"-pie"	*(char)
)	O
;	O
link_info	O
.	O
type	enum(int,int,int,int)
=	O
type_relocatable	O
;	O
config	O
.	O
build_constructors	O
=	O
TRUE	int
;	O
config	O
.	O
magic_demand_paged	O
=	O
FALSE	O
;	O
config	O
.	O
text_read_only	O
=	O
FALSE	O
;	O
input_flags	O
.	O
dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'u'	O
:	O
ldlang_add_undef	O
(	O
optarg	*(char)
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
OPTION_REQUIRE_DEFINED_SYMBOL	O
:	O
ldlang_add_require_defined	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_UNIQUE	O
:	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
lang_add_unique	O
(	O
optarg	*(char)
)	O
;	O
else	O
config	O
.	O
unique_orphan_sections	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_VERBOSE	O
:	O
ldversion	O
(	O
1	int
)	O
;	O
version_printed	O
=	O
TRUE	int
;	O
verbose	O
=	O
TRUE	int
;	O
overflow_cutoff_limit	O
=	O
-	O
2	int
;	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
{	O
char	O
*	O
end	*(*(char))
;	O
int	O
level	O
ATTRIBUTE_UNUSED	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
end	*(*(char))
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	*(*(char))
)	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid number `%s'\n"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
report_plugin_symbols	O
=	O
level	O
>	O
1	int
;	O
}	O
break	O
;	O
case	O
'v'	O
:	O
ldversion	O
(	O
0	int
)	O
;	O
version_printed	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'V'	O
:	O
ldversion	O
(	O
1	int
)	O
;	O
version_printed	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_VERSION	O
:	O
ldversion	O
(	O
2	int
)	O
;	O
xexit	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_VERSION_SCRIPT	O
:	O
{	O
FILE	struct
*	O
hold_script_handle	O
;	O
hold_script_handle	O
=	O
saved_script_handle	O
;	O
ldfile_open_command_file	O
(	O
optarg	*(char)
)	O
;	O
saved_script_handle	O
=	O
hold_script_handle	O
;	O
parser_input	O
=	O
input_version_script	O
;	O
yyparse	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_VERSION_EXPORTS_SECTION	O
:	O
command_line	O
.	O
version_exports_section	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_DATA	O
:	O
opt_dynamic_list	O
=	O
dynamic_list_data	O
;	O
if	O
(	O
opt_symbolic	O
==	O
symbolic	O
)	O
opt_symbolic	O
=	O
symbolic_unset	O
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_CPP_TYPEINFO	O
:	O
lang_append_dynamic_list_cpp_typeinfo	O
(	O
)	O
;	O
if	O
(	O
opt_dynamic_list	O
!=	O
dynamic_list_data	O
)	O
opt_dynamic_list	O
=	O
dynamic_list	O
;	O
if	O
(	O
opt_symbolic	O
==	O
symbolic	O
)	O
opt_symbolic	O
=	O
symbolic_unset	O
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_CPP_NEW	O
:	O
lang_append_dynamic_list_cpp_new	O
(	O
)	O
;	O
if	O
(	O
opt_dynamic_list	O
!=	O
dynamic_list_data	O
)	O
opt_dynamic_list	O
=	O
dynamic_list	O
;	O
if	O
(	O
opt_symbolic	O
==	O
symbolic	O
)	O
opt_symbolic	O
=	O
symbolic_unset	O
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST	O
:	O
{	O
FILE	struct
*	O
hold_script_handle	O
;	O
hold_script_handle	O
=	O
saved_script_handle	O
;	O
ldfile_open_command_file	O
(	O
optarg	*(char)
)	O
;	O
saved_script_handle	O
=	O
hold_script_handle	O
;	O
parser_input	O
=	O
input_dynamic_list	O
;	O
yyparse	O
(	O
)	O
;	O
}	O
if	O
(	O
opt_dynamic_list	O
!=	O
dynamic_list_data	O
)	O
opt_dynamic_list	O
=	O
dynamic_list	O
;	O
if	O
(	O
opt_symbolic	O
==	O
symbolic	O
)	O
opt_symbolic	O
=	O
symbolic_unset	O
;	O
break	O
;	O
case	O
OPTION_WARN_COMMON	O
:	O
config	O
.	O
warn_common	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_CONSTRUCTORS	O
:	O
config	O
.	O
warn_constructors	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_FATAL	O
:	O
config	O
.	O
fatal_warnings	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WARN_FATAL	O
:	O
config	O
.	O
fatal_warnings	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_WARN_MULTIPLE_GP	O
:	O
config	O
.	O
warn_multiple_gp	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_ONCE	O
:	O
config	O
.	O
warn_once	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_SECTION_ALIGN	O
:	O
config	O
.	O
warn_section_align	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_SHARED_TEXTREL	O
:	O
link_info	O
.	O
warn_shared_textrel	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_ALTERNATE_EM	O
:	O
link_info	O
.	O
warn_alternate_em	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WHOLE_ARCHIVE	O
:	O
input_flags	O
.	O
whole_archive	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	O
:	O
input_flags	O
.	O
add_DT_NEEDED_for_dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	O
:	O
input_flags	O
.	O
add_DT_NEEDED_for_dynamic	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_ADD_DT_NEEDED_FOR_REGULAR	O
:	O
input_flags	O
.	O
add_DT_NEEDED_for_regular	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR	O
:	O
input_flags	O
.	O
add_DT_NEEDED_for_regular	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_WRAP	O
:	O
add_wrap	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_IGNORE_UNRESOLVED_SYMBOL	O
:	O
add_ignoresym	O
(	O
&	O
link_info	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_DISCARD_NONE	O
:	O
link_info	O
.	O
discard	O
=	O
discard_none	O
;	O
break	O
;	O
case	O
'X'	O
:	O
link_info	O
.	O
discard	O
=	O
discard_l	O
;	O
break	O
;	O
case	O
'x'	O
:	O
link_info	O
.	O
discard	O
=	O
discard_all	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
CONST_STRNEQ	O
(	O
optarg	*(char)
,	O
"P,"	*(char)
)	O
)	O
optarg	*(char)
+=	O
2	int
;	O
if	O
(	O
default_dirlist	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
default_dirlist	O
)	O
;	O
default_dirlist	O
=	O
xstrdup	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
add_ysym	O
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_SPARE_DYNAMIC_TAGS	O
:	O
link_info	O
.	O
spare_dynamic_tags	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_SPLIT_BY_RELOC	O
:	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
config	O
.	O
split_by_reloc	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
config	O
.	O
split_by_reloc	O
=	O
32768	int
;	O
break	O
;	O
case	O
OPTION_SPLIT_BY_FILE	O
:	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
config	O
.	O
split_by_file	O
=	O
bfd_scan_vma	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
config	O
.	O
split_by_file	O
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_CHECK_SECTIONS	O
:	O
command_line	O
.	O
check_section_addresses	O
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_NO_CHECK_SECTIONS	O
:	O
command_line	O
.	O
check_section_addresses	O
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_ACCEPT_UNKNOWN_INPUT_ARCH	O
:	O
command_line	O
.	O
accept_unknown_input_arch	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH	O
:	O
command_line	O
.	O
accept_unknown_input_arch	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
'('	O
:	O
lang_enter_group	O
(	O
)	O
;	O
ingroup	O
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
!	O
ingroup	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: group ended before it began (--help for usage)\n"	*(char)
)	O
)	O
;	O
lang_leave_group	O
(	O
)	O
;	O
ingroup	O
--	O
;	O
break	O
;	O
case	O
OPTION_INIT	O
:	O
link_info	O
.	O
init_function	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_FINI	O
:	O
link_info	O
.	O
fini_function	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
OPTION_REDUCE_MEMORY_OVERHEADS	O
:	O
link_info	O
.	O
reduce_memory_overheads	O
=	O
TRUE	int
;	O
if	O
(	O
config	O
.	O
hash_table_size	O
==	O
0	int
)	O
config	O
.	O
hash_table_size	O
=	O
1021	int
;	O
break	O
;	O
case	O
OPTION_HASH_SIZE	O
:	O
{	O
bfd_size_type	long
new_size	O
;	O
new_size	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
new_size	O
)	O
config	O
.	O
hash_table_size	O
=	O
new_size	O
;	O
else	O
einfo	O
(	O
_	O
(	O
"%X%P: --hash-size needs a numeric argument\n"	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_PUSH_STATE	O
:	O
input_flags	O
.	O
pushed	O
=	O
xmemdup	O
(	O
&	O
input_flags	O
,	O
sizeof	O
(	O
input_flags	O
)	O
,	O
sizeof	O
(	O
input_flags	O
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_POP_STATE	O
:	O
if	O
(	O
input_flags	O
.	O
pushed	O
==	O
NULL	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: no state pushed before popping\n"	*(char)
)	O
)	O
;	O
else	O
{	O
struct	O
lang_input_statement_flags	O
*	O
oldp	O
=	O
input_flags	O
.	O
pushed	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
input_flags	O
,	O
oldp	O
,	O
sizeof	O
(	O
input_flags	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
oldp	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_PRINT_MEMORY_USAGE	O
:	O
command_line	O
.	O
print_memory_usage	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ORPHAN_HANDLING	O
:	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"place"	*(char)
)	O
==	O
0	int
)	O
config	O
.	O
orphan_handling	O
=	O
orphan_handling_place	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"warn"	*(char)
)	O
==	O
0	int
)	O
config	O
.	O
orphan_handling	O
=	O
orphan_handling_warn	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"error"	*(char)
)	O
==	O
0	int
)	O
config	O
.	O
orphan_handling	O
=	O
orphan_handling_error	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"discard"	*(char)
)	O
==	O
0	int
)	O
config	O
.	O
orphan_handling	O
=	O
orphan_handling_discard	O
;	O
else	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid argument to option"	*(char)
" \"--orphan-handling\"\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_NO_PRINT_MAP_DISCARDED	O
:	O
config	O
.	O
print_map_discarded	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
OPTION_PRINT_MAP_DISCARDED	O
:	O
config	O
.	O
print_map_discarded	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
command_line	O
.	O
soname	O
&&	O
command_line	O
.	O
soname	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
einfo	O
(	O
_	O
(	O
"%P: SONAME must not be empty string; ignored\n"	*(char)
)	O
)	O
;	O
command_line	O
.	O
soname	O
=	O
NULL	O
;	O
}	O
while	O
(	O
ingroup	O
)	O
{	O
einfo	O
(	O
_	O
(	O
"%P: missing --end-group; added as last command line option\n"	*(char)
)	O
)	O
;	O
lang_leave_group	O
(	O
)	O
;	O
ingroup	O
--	O
;	O
}	O
if	O
(	O
default_dirlist	O
!=	O
NULL	O
)	O
{	O
set_default_dirlist	O
(	O
default_dirlist	O
)	O
;	O
free	(*(void))->(void)
(	O
default_dirlist	O
)	O
;	O
}	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_objects	O
==	O
RM_NOT_YET_SET	O
)	O
link_info	O
.	O
unresolved_syms_in_objects	O
=	O
how_to_report_unresolved_symbols	O
;	O
if	O
(	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
==	O
RM_NOT_YET_SET	O
)	O
link_info	O
.	O
unresolved_syms_in_shared_libs	O
=	O
how_to_report_unresolved_symbols	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	O
)	O
&&	O
command_line	O
.	O
check_section_addresses	O
<	O
0	int
)	O
command_line	O
.	O
check_section_addresses	O
=	O
0	int
;	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	O
)	O
)	O
switch	O
(	O
opt_symbolic	O
)	O
{	O
case	O
symbolic_unset	O
:	O
break	O
;	O
case	O
symbolic	O
:	O
link_info	O
.	O
symbolic	O
=	O
TRUE	int
;	O
if	O
(	O
link_info	O
.	O
dynamic_list	O
)	O
{	O
struct	O
bfd_elf_version_expr	O
*	O
ent	O
,	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
for	O
(	O
ent	O
=	O
link_info	O
.	O
dynamic_list	O
->	O
head	O
.	O
list	O
;	O
ent	O
;	O
ent	O
=	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
ent	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
free	(*(void))->(void)
(	O
ent	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
link_info	O
.	O
dynamic_list	O
)	O
;	O
link_info	O
.	O
dynamic_list	O
=	O
NULL	O
;	O
}	O
opt_dynamic_list	O
=	O
dynamic_list_unset	O
;	O
break	O
;	O
case	O
symbolic_functions	O
:	O
opt_dynamic_list	O
=	O
dynamic_list_data	O
;	O
break	O
;	O
}	O
switch	O
(	O
opt_dynamic_list	O
)	O
{	O
case	O
dynamic_list_unset	O
:	O
break	O
;	O
case	O
dynamic_list_data	O
:	O
link_info	O
.	O
dynamic_data	O
=	O
TRUE	int
;	O
case	O
dynamic_list	O
:	O
link_info	O
.	O
dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
bfd_link_dll	O
(	O
&	O
link_info	O
)	O
)	O
{	O
if	O
(	O
command_line	O
.	O
filter_shlib	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -F may not be used without -shared\n"	*(char)
)	O
)	O
;	O
if	O
(	O
command_line	O
.	O
auxiliary_filters	O
)	O
einfo	O
(	O
_	O
(	O
"%F%P: -f may not be used without -shared\n"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	O
)	O
&&	O
link_info	O
.	O
strip	O
==	O
strip_all	O
)	O
{	O
link_info	O
.	O
strip	O
=	O
strip_debugger	O
;	O
if	O
(	O
link_info	O
.	O
discard	O
==	O
discard_sec_merge	O
)	O
link_info	O
.	O
discard	O
=	O
discard_all	O
;	O
}	O
}	O
static	O
void	O
set_default_dirlist	O
(	O
char	O
*	O
dirlist_ptr	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
while	O
(	O
1	int
)	O
{	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
dirlist_ptr	O
,	O
PATH_SEPARATOR	O
)	O
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
)	O
*	O
p	*(void)
=	O
'\0'	O
;	O
if	O
(	O
*	O
dirlist_ptr	O
!=	O
'\0'	O
)	O
ldfile_add_library_path	O
(	O
dirlist_ptr	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
break	O
;	O
dirlist_ptr	O
=	O
p	*(void)
+	O
1	int
;	O
}	O
}	O
static	O
void	O
set_section_start	O
(	O
char	O
*	O
sect	*(struct)
,	O
char	O
*	O
valstr	O
)	O
{	O
const	O
char	O
*	O
end	*(*(char))
;	O
bfd_vma	long
val	array(int)
=	O
bfd_scan_vma	(*(char),*(*(char)),int)->(long)
(	O
valstr	O
,	O
&	O
end	*(*(char))
,	O
16	int
)	O
;	O
if	O
(	O
*	O
end	*(*(char))
)	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid hex number `%s'\n"	*(char)
)	O
,	O
valstr	O
)	O
;	O
lang_section_start	O
(	O
sect	*(struct)
,	O
exp_intop	O
(	O
val	array(int)
)	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
set_segment_start	O
(	O
const	O
char	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
char	O
*	O
valstr	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
end	*(*(char))
;	O
segment_type	O
*	O
seg	O
;	O
bfd_vma	long
val	array(int)
=	O
bfd_scan_vma	(*(char),*(*(char)),int)->(long)
(	O
valstr	O
,	O
&	O
end	*(*(char))
,	O
16	int
)	O
;	O
if	O
(	O
*	O
end	*(*(char))
)	O
einfo	O
(	O
_	O
(	O
"%F%P: invalid hex number `%s'\n"	*(char)
)	O
,	O
valstr	O
)	O
;	O
name	*(char)
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
+	O
1	int
;	O
for	O
(	O
seg	O
=	O
segments	O
;	O
seg	O
;	O
seg	O
=	O
seg	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
seg	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
seg	O
->	O
value	long
=	O
val	array(int)
;	O
lang_section_start	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
exp_intop	O
(	O
val	array(int)
)	O
,	O
seg	O
)	O
;	O
return	O
;	O
}	O
seg	O
=	O
stat_alloc	O
(	O
sizeof	O
(	O
*	O
seg	O
)	O
)	O
;	O
seg	O
->	O
name	*(char)
=	O
name	*(char)
;	O
seg	O
->	O
value	long
=	O
val	array(int)
;	O
seg	O
->	O
used	O
=	O
FALSE	O
;	O
seg	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
segments	O
;	O
segments	O
=	O
seg	O
;	O
lang_section_start	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
exp_intop	O
(	O
val	array(int)
)	O
,	O
seg	O
)	O
;	O
}	O
static	O
void	O
elf_shlib_list_options	O
(	O
FILE	struct
*	O
file	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --audit=AUDITLIB            Specify a library to use for auditing\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -Bgroup                     Selects group name lookup rules for DSO\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --disable-new-dtags         Disable new dynamic tags\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --enable-new-dtags          Enable new dynamic tags\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --eh-frame-hdr              Create .eh_frame_hdr section\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --no-eh-frame-hdr           Do not create .eh_frame_hdr section\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --exclude-libs=LIBS         Make all symbols in LIBS hidden\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --hash-style=STYLE          Set hash style to sysv, gnu or both\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -P AUDITLIB, --depaudit=AUDITLIB\n"	*(char)
"                              Specify a library to use for auditing dependencies\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z combreloc                Merge dynamic relocs into one section and sort\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nocombreloc              Don't merge dynamic relocs into one section\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z global                   Make symbols in DSO available for subsequently\n                               loaded objects\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z initfirst                Mark DSO to be initialized first at runtime\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z interpose                Mark object to interpose all DSOs but executable\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z lazy                     Mark object lazy runtime binding (default)\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z loadfltr                 Mark object requiring immediate process\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nocopyreloc              Don't create copy relocs\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nodefaultlib             Mark object not to use default search paths\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nodelete                 Mark DSO non-deletable at runtime\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nodlopen                 Mark DSO not available to dlopen\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nodump                   Mark DSO not available to dldump\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z now                      Mark object non-lazy runtime binding\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z origin                   Mark object requiring immediate $ORIGIN\n                                processing at runtime\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z relro                    Create RELRO program header (default)\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z norelro                  Don't create RELRO program header\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z separate-code            Create separate code program header (default)\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z noseparate-code          Don't create separate code program header\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z common                   Generate common symbols with STT_COMMON type\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z nocommon                 Generate common symbols with STT_OBJECT type\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z stack-size=SIZE          Set size of stack segment\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z text                     Treat DT_TEXTREL in shared object as error\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z notext                   Don't treat DT_TEXTREL in shared object as error\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z textoff                  Don't treat DT_TEXTREL in shared object as error\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
elf_static_list_options	O
(	O
FILE	struct
*	O
file	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --build-id[=STYLE]          Generate build ID note\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --compress-debug-sections=[none|zlib|zlib-gnu|zlib-gabi]\n                              Compress DWARF debug sections using zlib\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"                               Default: none\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z common-page-size=SIZE    Set common page size to SIZE\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z max-page-size=SIZE       Set maximum page size to SIZE\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z defs                     Report unresolved symbols in object files\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z muldefs                  Allow multiple definitions\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z execstack                Mark executable as requiring executable stack\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z noexecstack              Mark executable as not requiring executable stack\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  -z globalaudit              Mark executable requiring global auditing\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
elf_plt_unwind_list_options	O
(	O
FILE	struct
*	O
file	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --ld-generated-unwind-info  Generate exception handling info for PLT\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(void)
,	O
_	O
(	O
"  --no-ld-generated-unwind-info\n                              Don't generate exception handling info for PLT\n"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
ld_list_options	O
(	O
FILE	struct
*	O
file	*(void)
,	O
bfd_boolean	int
elf	O
,	O
bfd_boolean	int
shlib	O
,	O
bfd_boolean	int
plt_unwind	O
)	O
{	O
if	O
(	O
!	O
elf	O
)	O
return	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"ELF emulations:\n"	*(char)
)	O
)	O
;	O
if	O
(	O
plt_unwind	O
)	O
elf_plt_unwind_list_options	O
(	O
file	*(void)
)	O
;	O
elf_static_list_options	O
(	O
file	*(void)
)	O
;	O
if	O
(	O
shlib	O
)	O
elf_shlib_list_options	O
(	O
file	*(void)
)	O
;	O
}	O
static	O
void	O
help	O
(	O
void	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
const	O
char	O
*	O
*	O
targets	O
,	O
*	O
*	O
pp	O
;	O
int	O
len	long
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [options] file...\n"	*(char)
)	O
,	O
program_name	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Options:\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
OPTION_COUNT	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
doc	O
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
comma	O
;	O
unsigned	O
j	O
;	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
comma	O
=	O
FALSE	O
;	O
len	long
=	O
2	int
;	O
j	O
=	O
i	*(struct)
;	O
do	O
{	O
if	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
shortopt	O
!=	O
'\0'	O
&&	O
ld_options	O
[	O
j	O
]	O
.	O
control	O
!=	O
NO_HELP	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s-%c"	*(char)
,	O
comma	O
?	O
", "	*(char)
:	O
""	*(char)
,	O
ld_options	O
[	O
j	O
]	O
.	O
shortopt	O
)	O
;	O
len	long
+=	O
(	O
comma	O
?	O
2	int
:	O
0	int
)	O
+	O
2	int
;	O
if	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
!=	O
NULL	O
)	O
{	O
if	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
opt	O
.	O
has_arg	O
!=	O
optional_argument	O
)	O
{	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
++	O
len	long
;	O
}	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
_	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
)	O
;	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
_	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
)	O
;	O
}	O
comma	O
=	O
TRUE	int
;	O
}	O
++	O
j	O
;	O
}	O
while	O
(	O
j	O
<	O
OPTION_COUNT	O
&&	O
ld_options	O
[	O
j	O
]	O
.	O
doc	O
==	O
NULL	O
)	O
;	O
j	O
=	O
i	*(struct)
;	O
do	O
{	O
if	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
opt	O
.	O
name	*(char)
!=	O
NULL	O
&&	O
ld_options	O
[	O
j	O
]	O
.	O
control	O
!=	O
NO_HELP	O
)	O
{	O
int	O
two_dashes	O
=	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
control	O
==	O
TWO_DASHES	O
||	O
ld_options	O
[	O
j	O
]	O
.	O
control	O
==	O
EXACTLY_TWO_DASHES	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s-%s%s"	*(char)
,	O
comma	O
?	O
", "	*(char)
:	O
""	*(char)
,	O
two_dashes	O
?	O
"-"	*(char)
:	O
""	*(char)
,	O
ld_options	O
[	O
j	O
]	O
.	O
opt	O
.	O
name	*(char)
)	O
;	O
len	long
+=	O
(	O
(	O
comma	O
?	O
2	int
:	O
0	int
)	O
+	O
1	int
+	O
(	O
two_dashes	O
?	O
1	int
:	O
0	int
)	O
+	O
strlen	(*(char))->(long)
(	O
ld_options	O
[	O
j	O
]	O
.	O
opt	O
.	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
!=	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
" %s"	*(char)
,	O
_	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
)	O
;	O
len	long
+=	O
1	int
+	O
strlen	(*(char))->(long)
(	O
_	O
(	O
ld_options	O
[	O
j	O
]	O
.	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
)	O
;	O
}	O
comma	O
=	O
TRUE	int
;	O
}	O
++	O
j	O
;	O
}	O
while	O
(	O
j	O
<	O
OPTION_COUNT	O
&&	O
ld_options	O
[	O
j	O
]	O
.	O
doc	O
==	O
NULL	O
)	O
;	O
if	O
(	O
len	long
>=	O
30	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
len	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
len	long
<	O
30	int
;	O
len	long
++	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
_	O
(	O
ld_options	O
[	O
i	*(struct)
]	O
.	O
doc	O
)	O
)	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  @FILE"	*(char)
)	O
)	O
;	O
for	O
(	O
len	long
=	O
strlen	(*(char))->(long)
(	O
"  @FILE"	*(char)
)	O
;	O
len	long
<	O
30	int
;	O
len	long
++	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Read options from FILE\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%s: supported targets:"	*(char)
)	O
,	O
program_name	O
)	O
;	O
targets	O
=	O
bfd_target_list	O
(	O
)	O
;	O
for	O
(	O
pp	O
=	O
targets	O
;	O
*	O
pp	O
!=	O
NULL	O
;	O
pp	O
++	O
)	O
printf	(*(char))->(int)
(	O
" %s"	*(char)
,	O
*	O
pp	O
)	O
;	O
free	(*(void))->(void)
(	O
targets	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%s: supported emulations: "	*(char)
)	O
,	O
program_name	O
)	O
;	O
ldemul_list_emulations	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%s: emulation specific options:\n"	*(char)
)	O
,	O
program_name	O
)	O
;	O
ld_list_options	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ELF_LIST_OPTIONS	O
,	O
ELF_SHLIB_LIST_OPTIONS	O
,	O
ELF_PLT_UNWIND_LIST_OPTIONS	O
)	O
;	O
ldemul_list_emulation_options	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	O
[	O
0	int
]	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Report bugs to %s\n"	*(char)
)	O
,	O
REPORT_BUGS_TO	O
)	O
;	O
}	O
