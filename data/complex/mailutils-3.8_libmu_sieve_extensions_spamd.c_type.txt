static	O
int	O
spamd_connect_tcp	(*(struct),*(*(struct)),*(char),int)->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_stream_t	*(struct)
*	O
stream	*(struct)
,	O
char	O
*	O
host	*(*(char))
,	O
int	O
port	int
)	O
{	O
int	O
rc	int
=	O
mu_tcp_stream_create	(*(*(struct)),*(char),int,int)->(int)
(	O
stream	*(struct)
,	O
host	*(*(char))
,	O
port	int
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"mu_tcp_stream_create: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
spamd_connect_socket	(*(struct),*(*(struct)),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_stream_t	*(struct)
*	O
stream	*(struct)
,	O
char	O
*	O
path	*(char)
)	O
{	O
int	O
rc	int
=	O
mu_socket_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
stream	*(struct)
,	O
path	*(char)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"mu_socket_stream_create: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
spamd_destroy	(*(*(struct)))->(void)
(	O
mu_stream_t	*(struct)
*	O
stream	*(struct)
)	O
{	O
mu_stream_close	(*(struct))->(int)
(	O
*	O
stream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
stream	*(struct)
)	O
;	O
}	O
static	O
void	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
size_t	long
n	*(long)
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
n	*(long)
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
mu_stream_writeline	(*(struct),*(char),long)->(int)
(	O
stream	*(struct)
,	O
buf	*(char)
,	O
n	*(long)
)	O
;	O
}	O
static	O
int	O
spamd_send_message	(*(struct),*(struct),int)->(int)
(	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
int	O
dbg	int
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
mstr	*(struct)
,	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
;	O
struct	O
mu_buffer_query	struct(int,enum(int,int,int),long)
newbuf	struct(int,enum(int,int,int),long)
,	O
oldbuf	struct(int,enum(int,int,int),long)
;	O
int	O
bufchg	int
=	O
0	int
;	O
mu_debug_handle_t	int
dlev	int
;	O
int	O
xlev	int
;	O
int	O
xlevchg	int
=	O
0	int
;	O
rc	int
=	O
mu_message_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
mstr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_filter_create	(*(*(struct)),*(struct),*(char),int,int)->(int)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
mstr	*(struct)
,	O
"CRLF"	*(char)
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
|	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
mstr	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_TRANSPORT_BUFFER	int
,	O
MU_IOCTL_OP_GET	int
,	O
&	O
oldbuf	struct(int,enum(int,int,int),long)
)	O
==	O
0	int
)	O
{	O
newbuf	struct(int,enum(int,int,int),long)
.	O
type	int
=	O
MU_TRANSPORT_OUTPUT	int
;	O
newbuf	struct(int,enum(int,int,int),long)
.	O
buftype	enum(int,int,int)
=	O
mu_buffer_full	int
;	O
newbuf	struct(int,enum(int,int,int),long)
.	O
bufsize	long
=	O
64	int
*	O
1024	int
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_TRANSPORT_BUFFER	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
newbuf	struct(int,enum(int,int,int),long)
)	O
;	O
bufchg	int
=	O
1	int
;	O
}	O
if	O
(	O
dbg	int
&&	O
mu_debug_category_level	(*(char),long,*(int))->(int)
(	O
"sieve"	*(char)
,	O
5	int
,	O
&	O
dlev	int
)	O
==	O
0	int
&&	O
!	O
(	O
dlev	int
&	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE9	int
)	O
)	O
)	O
{	O
xlev	int
=	O
MU_XSCRIPT_PAYLOAD	int
;	O
if	O
(	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_XSCRIPTSTREAM	int
,	O
MU_IOCTL_XSCRIPTSTREAM_LEVEL	int
,	O
&	O
xlev	int
)	O
==	O
0	int
)	O
xlevchg	int
=	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
stream	*(struct)
,	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
bufchg	int
)	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_TRANSPORT_BUFFER	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
oldbuf	struct(int,enum(int,int,int),long)
)	O
;	O
if	O
(	O
xlevchg	int
)	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_XSCRIPTSTREAM	int
,	O
MU_IOCTL_XSCRIPTSTREAM_LEVEL	int
,	O
&	O
xlev	int
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
mstr	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
long	O
*	O
vn	*(long)
,	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
digits	*(int)
,	O
char	O
*	O
*	O
endp	*(*(char))
)	O
{	O
long	O
v	array(*(char))
;	O
size_t	long
frac	long
=	O
0	int
;	O
size_t	long
base	long
=	O
1	int
;	O
int	O
i	long
;	O
int	O
negative	int
=	O
0	int
;	O
char	O
*	O
end	struct(*(char),int,int)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
digits	*(int)
;	O
i	long
++	O
)	O
base	long
*=	O
10	int
;	O
v	array(*(char))
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
end	struct(*(char),int,int)
,	O
10	int
)	O
;	O
str	*(char)
=	O
end	struct(*(char),int,int)
;	O
if	O
(	O
v	array(*(char))
<	O
0	int
)	O
{	O
negative	int
=	O
1	int
;	O
v	array(*(char))
=	O
-	O
v	array(*(char))
;	O
}	O
v	array(*(char))
*=	O
base	long
;	O
if	O
(	O
*	O
str	*(char)
==	O
'.'	O
)	O
{	O
for	O
(	O
str	*(char)
++	O
,	O
i	long
=	O
0	int
;	O
*	O
str	*(char)
&&	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
&&	O
i	long
<	O
digits	*(int)
;	O
i	long
++	O
,	O
str	*(char)
++	O
)	O
frac	long
=	O
frac	long
*	O
10	int
+	O
char_to_num	O
(	O
*	O
str	*(char)
)	O
;	O
if	O
(	O
*	O
str	*(char)
&&	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
)	O
{	O
if	O
(	O
char_to_num	O
(	O
*	O
str	*(char)
)	O
>=	O
5	int
)	O
frac	long
++	O
;	O
if	O
(	O
endp	*(*(char))
)	O
while	O
(	O
*	O
str	*(char)
&&	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
}	O
else	O
for	O
(	O
;	O
i	long
<	O
digits	*(int)
;	O
i	long
++	O
)	O
frac	long
*=	O
10	int
;	O
}	O
*	O
vn	*(long)
=	O
v	array(*(char))
+	O
frac	long
;	O
if	O
(	O
negative	int
)	O
*	O
vn	*(long)
=	O
-	O
*	O
vn	*(long)
;	O
if	O
(	O
endp	*(*(char))
)	O
*	O
endp	*(*(char))
=	O
(	O
char	O
*	O
)	O
str	*(char)
;	O
}	O
static	O
int	O
decode_boolean	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"true"	*(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"false"	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
0	int
;	O
}	O
typedef	O
RETSIGTYPE	void
(	O
*	O
signal_handler	*((int)->(void))
)	O
(	O
int	O
)	O
;	O
static	O
signal_handler	*((int)->(void))
set_signal_handler	(int,*((int)->(void)))->(*((int)->(void)))
(	O
int	O
sig	int
,	O
signal_handler	*((int)->(void))
h	*((int)->(void))
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	enum(int,int,int,int,int)
,	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
act	enum(int,int,int,int,int)
.	O
sa_handler	*((int)->(void))
=	O
h	*((int)->(void))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
act	enum(int,int,int,int,int)
.	O
sa_mask	struct(array(long))
)	O
;	O
act	enum(int,int,int,int,int)
.	O
sa_flags	int
=	O
0	int
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
act	enum(int,int,int,int,int)
,	O
&	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
;	O
return	O
oldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
;	O
}	O
void	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_stream_t	*(struct)
*	O
stream	*(struct)
,	O
signal_handler	*((int)->(void))
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
{	O
spamd_destroy	(*(*(struct)))->(void)
(	O
stream	*(struct)
)	O
;	O
set_signal_handler	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
static	O
int	O
got_sigpipe	int
;	O
static	O
signal_handler	*((int)->(void))
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
;	O
static	O
RETSIGTYPE	void
sigpipe_handler	(int)->(void)
(	O
int	O
sig	int
MU_ARG_UNUSED	O
)	O
{	O
got_sigpipe	int
=	O
1	int
;	O
}	O
static	O
void	O
spamd_read_line	(*(struct),*(struct),*(*(char)),*(long))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_stream_t	*(struct)
stream	*(struct)
,	O
char	O
*	O
*	O
pbuffer	*(*(char))
,	O
size_t	long
*	O
psize	*(long)
)	O
{	O
size_t	long
n	*(long)
;	O
int	O
rc	int
=	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
stream	*(struct)
,	O
pbuffer	*(*(char))
,	O
psize	*(long)
,	O
&	O
n	*(long)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
mu_rtrim_class	(*(char),int)->(long)
(	O
*	O
pbuffer	*(*(char))
,	O
MU_CTYPE_ENDLN	int
)	O
;	O
else	O
{	O
free	(*(void))->(void)
(	O
pbuffer	*(*(char))
)	O
;	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"read error: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
}	O
}	O
static	O
int	O
parse_response_line	(*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
const	O
char	O
*	O
buffer	*(struct)
)	O
{	O
const	O
char	O
*	O
str	*(char)
;	O
char	O
*	O
end	struct(*(char),int,int)
;	O
long	O
version	long
;	O
unsigned	O
long	O
resp	long
;	O
str	*(char)
=	O
buffer	*(struct)
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
str	*(char)
,	O
"SPAMD/"	*(char)
,	O
6	int
)	O
)	O
return	O
MU_ERR_BADREPLY	O
;	O
str	*(char)
+=	O
6	int
;	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
&	O
version	long
,	O
str	*(char)
,	O
1	int
,	O
&	O
end	struct(*(char),int,int)
)	O
;	O
if	O
(	O
version	long
<	O
10	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"unsupported SPAMD version: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
MU_ERR_BADREPLY	O
;	O
}	O
str	*(char)
=	O
mu_str_skip_class	(*(char),int)->(*(char))
(	O
end	struct(*(char),int,int)
,	O
MU_CTYPE_SPACE	int
)	O
;	O
if	O
(	O
!	O
*	O
str	*(char)
||	O
!	O
mu_isdigit	O
(	O
*	O
str	*(char)
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"malformed spamd response: %s"	*(char)
)	O
,	O
buffer	*(struct)
)	O
;	O
return	O
MU_ERR_BADREPLY	O
;	O
}	O
resp	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
end	struct(*(char),int,int)
,	O
10	int
)	O
;	O
if	O
(	O
resp	long
!=	O
0	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"spamd failure: %lu %s"	*(char)
)	O
,	O
resp	long
,	O
end	struct(*(char),int,int)
)	O
;	O
return	O
MU_ERR_REPLY	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
get_real_message_size	(*(struct),*(long))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
size_t	long
*	O
psize	*(long)
)	O
{	O
mu_stream_t	*(struct)
null	*(struct)
;	O
mu_stream_stat_buffer	array(long)
stat	*(int)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_nullstream_create	(*(*(struct)),int)->(int)
(	O
&	O
null	*(struct)
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_stream_set_stat	(*(struct),int,array(long))->(int)
(	O
null	*(struct)
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	*(int)
)	O
;	O
rc	int
=	O
spamd_send_message	(*(struct),*(struct),int)->(int)
(	O
null	*(struct)
,	O
msg	*(struct)
,	O
0	int
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
null	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
psize	*(long)
=	O
stat	*(int)
[	O
MU_STREAM_STAT_OUT	int
]	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
spamd_test	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
char	O
*	O
buffer	*(struct)
=	O
NULL	O
;	O
size_t	long
size	long
;	O
char	O
spam_str	array(char)
[	O
6	int
]	O
,	O
score_str	array(char)
[	O
21	int
]	O
,	O
threshold_str	array(char)
[	O
21	int
]	O
;	O
int	O
rc	int
;	O
int	O
result	*(struct)
;	O
long	O
score	long
,	O
threshold	long
,	O
limit	long
;	O
mu_stream_t	*(struct)
stream	*(struct)
=	O
NULL	O
,	O
null	*(struct)
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
char	O
*	O
host	*(*(char))
;	O
size_t	long
num	long
;	O
char	O
*	O
str	*(char)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_debug_handle_t	int
lev	int
=	O
0	int
;	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
return	O
0	int
;	O
msg	*(struct)
=	O
mu_sieve_get_message	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
rc	int
=	O
get_real_message_size	(*(struct),*(long))->(int)
(	O
msg	*(struct)
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get real message size: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
if	O
(	O
!	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"host"	*(char)
,	O
SVT_STRING	int
,	O
&	O
host	*(*(char))
)	O
)	O
host	*(*(char))
=	O
"127.0.0.1"	*(char)
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"port"	*(char)
,	O
SVT_NUMBER	int
,	O
&	O
num	long
)	O
)	O
result	*(struct)
=	O
spamd_connect_tcp	(*(struct),*(*(struct)),*(char),int)->(int)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
host	*(*(char))
,	O
num	long
)	O
;	O
else	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"socket"	*(char)
,	O
SVT_STRING	int
,	O
&	O
str	*(char)
)	O
)	O
result	*(struct)
=	O
spamd_connect_socket	(*(struct),*(*(struct)),*(char))->(int)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
str	*(char)
)	O
;	O
else	O
result	*(struct)
=	O
spamd_connect_tcp	(*(struct),*(*(struct)),*(char),int)->(int)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
host	*(*(char))
,	O
DEFAULT_SPAMD_PORT	int
)	O
;	O
if	O
(	O
result	*(struct)
)	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
mu_stream_set_buffer	(*(struct),enum(int,int,int),long)->(int)
(	O
stream	*(struct)
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
if	O
(	O
mu_debug_category_level	(*(char),long,*(int))->(int)
(	O
"sieve"	*(char)
,	O
5	int
,	O
&	O
lev	int
)	O
==	O
0	int
&&	O
(	O
lev	int
&	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_PROT	int
)	O
)	O
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
dstr	*(struct)
,	O
xstr	*(struct)
;	O
rc	int
=	O
mu_dbgstream_create	(*(*(struct)),int)->(int)
(	O
&	O
dstr	*(struct)
,	O
MU_DIAG_DEBUG	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create debug stream; transcript disabled: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
rc	int
=	O
mu_xscript_stream_create	(*(*(struct)),*(struct),*(struct),array(*(char)))->(int)
(	O
&	O
xstr	*(struct)
,	O
stream	*(struct)
,	O
dstr	*(struct)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create transcript stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
)	O
;	O
stream	*(struct)
=	O
xstr	*(struct)
;	O
}	O
}	O
}	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
stream	*(struct)
,	O
"SYMBOLS SPAMC/1.2"	*(char)
)	O
;	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
stream	*(struct)
,	O
"Content-length: %lu"	*(char)
,	O
(	O
u_long	long
)	O
size	long
)	O
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"user"	*(char)
,	O
SVT_STRING	int
,	O
&	O
str	*(char)
)	O
)	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
stream	*(struct)
,	O
"User: %s"	*(char)
,	O
str	*(char)
)	O
;	O
else	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
mu_get_auth_by_uid	(int)->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
geteuid	()->(int)
(	O
)	O
)	O
;	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
stream	*(struct)
,	O
"User: %s"	*(char)
,	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
?	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
name	*(char)
:	O
"root"	*(char)
)	O
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
}	O
got_sigpipe	int
=	O
0	int
;	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
=	O
set_signal_handler	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
sigpipe_handler	(int)->(void)
)	O
;	O
spamd_send_command	(*(struct),*(char))->(void)
(	O
stream	*(struct)
,	O
""	*(char)
)	O
;	O
spamd_send_message	(*(struct),*(struct),int)->(int)
(	O
stream	*(struct)
,	O
msg	*(struct)
,	O
1	int
)	O
;	O
mu_stream_shutdown	(*(struct),int)->(int)
(	O
stream	*(struct)
,	O
MU_STREAM_WRITE	int
)	O
;	O
spamd_read_line	(*(struct),*(struct),*(*(char)),*(long))->(void)
(	O
mach	*(struct)
,	O
stream	*(struct)
,	O
&	O
buffer	*(struct)
,	O
&	O
size	long
)	O
;	O
if	O
(	O
got_sigpipe	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"remote side has closed connection"	*(char)
)	O
)	O
;	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
}	O
if	O
(	O
parse_response_line	(*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
buffer	*(struct)
)	O
)	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
spamd_read_line	(*(struct),*(struct),*(*(char)),*(long))->(void)
(	O
mach	*(struct)
,	O
stream	*(struct)
,	O
&	O
buffer	*(struct)
,	O
&	O
size	long
)	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
buffer	*(struct)
,	O
"Spam: %5s ; %20s / %20s"	*(char)
,	O
spam_str	array(char)
,	O
score_str	array(char)
,	O
threshold_str	array(char)
)	O
!=	O
3	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"spamd responded with bad Spam header '%s'"	*(char)
)	O
,	O
buffer	*(struct)
)	O
;	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
}	O
result	*(struct)
=	O
decode_boolean	(*(char))->(int)
(	O
spam_str	array(char)
)	O
;	O
score	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
score_str	array(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
&	O
score	long
,	O
score_str	array(char)
,	O
3	int
,	O
NULL	O
)	O
;	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
&	O
threshold	long
,	O
threshold_str	array(char)
,	O
3	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
result	*(struct)
)	O
{	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"over"	*(char)
,	O
SVT_STRING	int
,	O
&	O
str	*(char)
)	O
)	O
{	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
&	O
limit	long
,	O
str	*(char)
,	O
3	int
,	O
NULL	O
)	O
;	O
result	*(struct)
=	O
score	long
>=	O
limit	long
;	O
}	O
else	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"under"	*(char)
,	O
SVT_STRING	int
,	O
&	O
str	*(char)
)	O
)	O
{	O
decode_float	(*(long),*(char),int,*(*(char)))->(void)
(	O
&	O
limit	long
,	O
str	*(char)
,	O
3	int
,	O
NULL	O
)	O
;	O
result	*(struct)
=	O
score	long
<=	O
limit	long
;	O
}	O
}	O
spamd_read_line	(*(struct),*(struct),*(*(char)),*(long))->(void)
(	O
mach	*(struct)
,	O
stream	*(struct)
,	O
&	O
buffer	*(struct)
,	O
&	O
size	long
)	O
;	O
spamd_read_line	(*(struct),*(struct),*(*(char)),*(long))->(void)
(	O
mach	*(struct)
,	O
stream	*(struct)
,	O
&	O
buffer	*(struct)
,	O
&	O
size	long
)	O
;	O
rc	int
=	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get message header: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
spamd_abort	(*(struct),*(*(struct)),*((int)->(void)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
}	O
mu_header_append	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
"X-Spamd-Status"	*(char)
,	O
spam_str	array(char)
)	O
;	O
mu_header_append	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
"X-Spamd-Score"	*(char)
,	O
score_str	array(char)
)	O
;	O
mu_header_append	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
"X-Spamd-Threshold"	*(char)
,	O
threshold_str	array(char)
)	O
;	O
mu_header_append	(*(struct),*(char),*(char))->(int)
(	O
hdr	*(struct)
,	O
"X-Spamd-Keywords"	*(char)
,	O
buffer	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
buffer	*(struct)
)	O
;	O
mu_nullstream_create	(*(*(struct)),int)->(int)
(	O
&	O
null	*(struct)
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
!	O
(	O
lev	int
&	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE9	int
)	O
)	O
)	O
{	O
int	O
xlev	int
=	O
MU_XSCRIPT_PAYLOAD	int
;	O
mu_stream_ioctl	(*(struct),int,int,*(void))->(int)
(	O
stream	*(struct)
,	O
MU_IOCTL_XSCRIPTSTREAM	int
,	O
MU_IOCTL_XSCRIPTSTREAM_LEVEL	int
,	O
&	O
xlev	int
)	O
;	O
}	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
null	*(struct)
,	O
stream	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
null	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
set_signal_handler	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
handler	array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int)))
)	O
;	O
return	O
result	*(struct)
;	O
}	O
static	O
mu_sieve_data_type	enum(int,int,int,int,int)
spamd_req_args	array(enum(int,int,int,int,int))
[	O
]	O
=	O
{	O
SVT_VOID	int
}	O
;	O
static	O
mu_sieve_tag_def_t	struct(*(char),enum(int,int,int,int,int))
spamd_tags	array(struct(*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"host"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"port"	*(char)
,	O
SVT_NUMBER	int
}	O
,	O
{	O
"socket"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"user"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"over"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"under"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_tag_group_t	struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int)))
spamd_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
[	O
]	O
=	O
{	O
{	O
spamd_tags	array(struct(*(char),enum(int,int,int,int,int)))
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
SIEVE_EXPORT	O
(	O
spamd	O
,	O
init	O
)	O
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_register_test	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"spamd"	*(char)
,	O
spamd_test	(*(struct))->(int)
,	O
spamd_req_args	array(enum(int,int,int,int,int))
,	O
spamd_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
