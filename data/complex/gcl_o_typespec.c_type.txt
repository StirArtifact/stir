object	O
sLkeyword	int
;	O
enum	O
type	O
t_vtype	enum
;	O
int	O
vtypep_fn	(int)->(int)
(	O
object	O
x	int
)	O
{	O
return	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_vtype	enum
;	O
}	O
LFD	(int)->(int)
(	O
Ltype_of	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLfixnum	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLbignum	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLratio	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLshort_float	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLlong_float	O
;	O
break	O
;	O
case	O
t_complex	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLcomplex	O
;	O
break	O
;	O
case	O
t_character	O
:	O
if	O
(	O
char_font	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
0	int
||	O
char_bits	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
0	int
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLcharacter	O
;	O
else	O
{	O
i	int
=	O
char_code	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
(	O
' '	O
<=	O
i	int
&&	O
i	int
<	O
'\177'	O
)	O
||	O
i	int
==	O
'\n'	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLstandard_char	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLstring_char	O
;	O
}	O
break	O
;	O
case	O
t_symbol	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_hpack	O
==	O
keyword_package	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLkeyword	int
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLsymbol	O
;	O
break	O
;	O
case	O
t_package	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLpackage	O
;	O
break	O
;	O
case	O
t_cons	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLcons	O
;	O
break	O
;	O
case	O
t_hashtable	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLhash_table	O
;	O
break	O
;	O
case	O
t_array	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
a	O
.	O
a_adjustable	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
a	O
.	O
a_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLarray	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLsimple_array	O
;	O
break	O
;	O
case	O
t_vector	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
v	O
.	O
v_adjustable	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
v	O
.	O
v_hasfillp	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
v	O
.	O
v_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
||	O
(	O
enum	O
aelttype	O
)	O
vs_base	O
[	O
0	int
]	O
->	O
v	O
.	O
v_elttype	O
!=	O
aet_object	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLvector	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLsimple_vector	O
;	O
break	O
;	O
case	O
t_string	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_adjustable	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_hasfillp	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLstring	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLsimple_string	O
;	O
break	O
;	O
case	O
t_bitvector	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
bv	O
.	O
bv_adjustable	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
bv	O
.	O
bv_hasfillp	O
||	O
vs_base	O
[	O
0	int
]	O
->	O
bv	O
.	O
bv_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
sLbit_vector	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLsimple_bit_vector	O
;	O
break	O
;	O
case	O
t_structure	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
S_DATA	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
->	O
str	O
.	O
str_def	O
)	O
->	O
name	O
;	O
break	O
;	O
case	O
t_stream	O
:	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
sm	O
.	O
sm_mode	O
==	O
(	O
int	O
)	O
smm_user_defined	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
sm	O
.	O
sm_object1	O
->	O
str	O
.	O
str_self	O
[	O
8	int
]	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
sLstream	O
;	O
break	O
;	O
case	O
t_readtable	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLreadtable	O
;	O
break	O
;	O
case	O
t_pathname	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLpathname	O
;	O
break	O
;	O
case	O
t_random	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLrandom_state	O
;	O
break	O
;	O
case	O
t_sfun	O
:	O
case	O
t_gfun	O
:	O
case	O
t_cfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_afun	O
:	O
case	O
t_cclosure	O
:	O
case	O
t_closure	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
sLcompiled_function	O
;	O
break	O
;	O
default	O
:	O
error	()->(int)
(	O
"not a lisp data object"	*(char)
)	O
;	O
}	O
}	O
DEF_ORDINARY	()->(int)
(	O
"PROCLAIMED-ARG-TYPES"	*(char)
,	O
sSproclaimed_arg_types	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PROCLAIMED-RETURN-TYPE"	*(char)
,	O
sSproclaimed_return_type	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PROCLAIMED-FUNCTION"	*(char)
,	O
sSproclaimed_function	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"COMMON"	*(char)
,	O
sLcommon	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"NULL"	*(char)
,	O
sLnull	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CONS"	*(char)
,	O
sLcons	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LIST"	*(char)
,	O
sLlist	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SYMBOL"	*(char)
,	O
sLsymbol	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"ARRAY"	*(char)
,	O
sLarray	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VECTOR"	*(char)
,	O
sLvector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BIT-VECTOR"	*(char)
,	O
sLbit_vector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRING"	*(char)
,	O
sLstring	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SEQUENCE"	*(char)
,	O
sLsequence	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-ARRAY"	*(char)
,	O
sLsimple_array	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-VECTOR"	*(char)
,	O
sLsimple_vector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-BIT-VECTOR"	*(char)
,	O
sLsimple_bit_vector	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-STRING"	*(char)
,	O
sLsimple_string	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FUNCTION"	*(char)
,	O
sLfunction	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"COMPILED-FUNCTION"	*(char)
,	O
sLcompiled_function	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PATHNAME"	*(char)
,	O
sLpathname	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CHARACTER"	*(char)
,	O
sLcharacter	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"NUMBER"	*(char)
,	O
sLnumber	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"RATIONAL"	*(char)
,	O
sLrational	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FLOAT"	*(char)
,	O
sLfloat	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRING-CHAR"	*(char)
,	O
sLstring_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"REAL"	*(char)
,	O
sLreal	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"INTEGER"	*(char)
,	O
sLinteger	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"RATIO"	*(char)
,	O
sLratio	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SHORT-FLOAT"	*(char)
,	O
sLshort_float	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STANDARD-CHAR"	*(char)
,	O
sLstandard_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BOOLEAN"	*(char)
,	O
sLboolean	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FIXNUM"	*(char)
,	O
sLfixnum	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"POSITIVE-FIXNUM"	*(char)
,	O
sLpositive_fixnum	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"COMPLEX"	*(char)
,	O
sLcomplex	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SINGLE-FLOAT"	*(char)
,	O
sLsingle_float	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PACKAGE"	*(char)
,	O
sLpackage	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BIGNUM"	*(char)
,	O
sLbignum	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"RANDOM-STATE"	*(char)
,	O
sLrandom_state	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DOUBLE-FLOAT"	*(char)
,	O
sLdouble_float	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STREAM"	*(char)
,	O
sLstream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BIT"	*(char)
,	O
sLbit	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"READTABLE"	*(char)
,	O
sLreadtable	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LONG-FLOAT"	*(char)
,	O
sLlong_float	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"HASH-TABLE"	*(char)
,	O
sLhash_table	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"KEYWORD"	*(char)
,	O
sLkeyword	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRUCTURE"	*(char)
,	O
sLstructure	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SATISFIES"	*(char)
,	O
sLsatisfies	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"MEMBER"	*(char)
,	O
sLmember	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"NOT"	*(char)
,	O
sLnot	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"OR"	*(char)
,	O
sLor	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"AND"	*(char)
,	O
sLand	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VALUES"	*(char)
,	O
sLvalues	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"MOD"	*(char)
,	O
sLmod	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIGNED-BYTE"	*(char)
,	O
sLsigned_byte	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNSIGNED-BYTE"	*(char)
,	O
sLunsigned_byte	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIGNED-CHAR"	*(char)
,	O
sLsigned_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNSIGNED-CHAR"	*(char)
,	O
sLunsigned_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIGNED-SHORT"	*(char)
,	O
sLsigned_short	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNSIGNED-SHORT"	*(char)
,	O
sLunsigned_short	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"*"	*(char)
,	O
sLA	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PLUSP"	*(char)
,	O
sLplusp	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DIVISION-BY-ZERO"	*(char)
,	O
sLdivision_by_zero	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FLOATING-POINT-INEXACT"	*(char)
,	O
sLfloating_point_inexact	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FLOATING-POINT-INVALID-OPERATION"	*(char)
,	O
sLfloating_point_invalid_operation	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FLOATING-POINT-OVERFLOW"	*(char)
,	O
sLfloating_point_overflow	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FLOATING-POINT-UNDERFLOW"	*(char)
,	O
sLfloating_point_underflow	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PROGRAM-ERROR"	*(char)
,	O
sLprogram_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNDEFINED-FUNCTION"	*(char)
,	O
sLundefined_function	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNBOUND-VARIABLE"	*(char)
,	O
sLunbound_variable	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PACKAGE-ERROR"	*(char)
,	O
sLpackage_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"METHOD-COMBINATION"	*(char)
,	O
sLmethod_combination	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"ARITHMETIC-ERROR"	*(char)
,	O
sLarithmetic_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BASE-CHAR"	*(char)
,	O
sLbase_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BASE-STRING"	*(char)
,	O
sLbase_string	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BROADCAST-STREAM"	*(char)
,	O
sLbroadcast_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"BUILT-IN-CLASS"	*(char)
,	O
sLbuilt_in_class	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CELL-ERROR"	*(char)
,	O
sLcell_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CLASS"	*(char)
,	O
sLclass	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CONCATENATED-STREAM"	*(char)
,	O
sLconcatenated_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CONDITION"	*(char)
,	O
sLcondition	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"CONTROL-ERROR"	*(char)
,	O
sLcontrol_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"ECHO-STREAM"	*(char)
,	O
sLecho_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"END-OF-FILE"	*(char)
,	O
sLend_of_file	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"ERROR"	*(char)
,	O
sLerror	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"EXTENDED-CHAR"	*(char)
,	O
sLextended_char	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FILE-ERROR"	*(char)
,	O
sLfile_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FILE-STREAM"	*(char)
,	O
sLfile_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"GENERIC-FUNCTION"	*(char)
,	O
sLgeneric_function	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LOGICAL-PATHNAME"	*(char)
,	O
sLlogical_pathname	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"METHOD"	*(char)
,	O
sLmethod	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PARSE-ERROR"	*(char)
,	O
sLparse_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PRINT-NOT-READABLE"	*(char)
,	O
sLprint_not_readable	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"READER-ERROR"	*(char)
,	O
sLreader_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SERIOUS-CONDITION"	*(char)
,	O
sLserious_condition	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-BASE-STRING"	*(char)
,	O
sLsimple_base_string	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-CONDITION"	*(char)
,	O
sLsimple_condition	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-TYPE-ERROR"	*(char)
,	O
sLsimple_type_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SIMPLE-WARNING"	*(char)
,	O
sLsimple_warning	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STANDARD-CLASS"	*(char)
,	O
sLstandard_class	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STANDARD-GENERIC-FUNCTION"	*(char)
,	O
sLstandard_generic_function	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STANDARD-METHOD"	*(char)
,	O
sLstandard_method	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STANDARD-OBJECT"	*(char)
,	O
sLstandard_object	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STORAGE-CONDITION"	*(char)
,	O
sLstorage_condition	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STREAM-ERROR"	*(char)
,	O
sLstream_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRING-STREAM"	*(char)
,	O
sLstring_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRUCTURE-CLASS"	*(char)
,	O
sLstructure_class	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STRUCTURE-OBJECT"	*(char)
,	O
sLstructure_object	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"STYLE-WARNING"	*(char)
,	O
sLstyle_warning	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"SYNONYM-STREAM"	*(char)
,	O
sLsynonym_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TWO-WAY-STREAM"	*(char)
,	O
sLtwo_way_stream	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TYPE-ERROR"	*(char)
,	O
sLtype_error	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"UNBOUND-SLOT"	*(char)
,	O
sLunbound_slot	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"WARNING"	*(char)
,	O
sLwarning	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEFCONST	()->(int)
(	O
"CHAR-SIZE"	*(char)
,	O
sSchar_size	O
,	O
SI	O
,	O
small_fixnum	O
(	O
CHAR_SIZE	O
)	O
,	O
"Size in bits of a character"	*(char)
)	O
;	O
DEFCONST	()->(int)
(	O
"SHORT-SIZE"	*(char)
,	O
sSshort_size	O
,	O
SI	O
,	O
small_fixnum	O
(	O
CHAR_SIZE	O
*	O
sizeof	O
(	O
short	O
)	O
)	O
,	O
"Size in bits of a short integer"	*(char)
)	O
;	O
void	O
gcl_init_typespec	()->(void)
(	O
void	O
)	O
{	O
}	O
void	O
gcl_init_typespec_function	()->(void)
(	O
void	O
)	O
{	O
TSor_symbol_string	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLsymbol	O
,	O
make_cons	()->(int)
(	O
sLstring	O
,	O
Cnil	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_symbol_string	O
)	O
;	O
TSor_string_symbol	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLstring	O
,	O
make_cons	()->(int)
(	O
sLsymbol	O
,	O
Cnil	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_string_symbol	O
)	O
;	O
TSor_symbol_string_package	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLsymbol	O
,	O
make_cons	()->(int)
(	O
sLstring	O
,	O
make_cons	()->(int)
(	O
sLpackage	O
,	O
Cnil	O
)	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_symbol_string_package	O
)	O
;	O
TSnon_negative_integer	O
=	O
make_cons	()->(int)
(	O
sLinteger	O
,	O
make_cons	()->(int)
(	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_cons	()->(int)
(	O
sLA	O
,	O
Cnil	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSnon_negative_integer	O
)	O
;	O
TSpositive_number	O
=	O
make_cons	()->(int)
(	O
sLsatisfies	O
,	O
make_cons	()->(int)
(	O
sLplusp	O
,	O
Cnil	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSpositive_number	O
)	O
;	O
TSor_integer_float	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLinteger	O
,	O
make_cons	()->(int)
(	O
sLfloat	O
,	O
Cnil	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_integer_float	O
)	O
;	O
TSor_rational_float	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLrational	O
,	O
make_cons	()->(int)
(	O
sLfloat	O
,	O
Cnil	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_rational_float	O
)	O
;	O
TSor_pathname_string_symbol_stream	O
=	O
make_cons	()->(int)
(	O
sLor	O
,	O
make_cons	()->(int)
(	O
sLpathname	O
,	O
make_cons	()->(int)
(	O
sLstring	O
,	O
make_cons	()->(int)
(	O
sLsymbol	O
,	O
make_cons	()->(int)
(	O
sLstream	O
,	O
Cnil	O
)	O
)	O
)	O
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
TSor_pathname_string_symbol_stream	O
)	O
;	O
make_function	()->(int)
(	O
"TYPE-OF"	*(char)
,	O
Ltype_of	int
)	O
;	O
}	O
