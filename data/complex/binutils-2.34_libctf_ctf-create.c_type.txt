static	O
int	O
ctf_grow_ptrtab	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
size_t	long
new_ptrtab_len	O
=	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_ptrtab	O
==	O
NULL	O
)	O
new_ptrtab_len	O
=	O
1024	int
;	O
else	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_typemax	O
+	O
2	int
)	O
>	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
)	O
new_ptrtab_len	O
=	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
*	O
1.25	int
;	O
if	O
(	O
new_ptrtab_len	O
!=	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
)	O
{	O
uint32_t	int
*	O
new_ptrtab	O
;	O
if	O
(	O
(	O
new_ptrtab	O
=	O
realloc	(*(void),long)->(*(void))
(	O
fp	*(struct)
->	O
ctf_ptrtab	O
,	O
new_ptrtab_len	O
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_ptrtab	O
=	O
new_ptrtab	O
;	O
memset	O
(	O
fp	*(struct)
->	O
ctf_ptrtab	O
+	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
,	O
0	int
,	O
(	O
new_ptrtab_len	O
-	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
)	O
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
=	O
new_ptrtab_len	O
;	O
}	O
return	O
0	int
;	O
}	O
ctf_file_t	struct
*	O
ctf_create	(*(int))->(*(struct))
(	O
int	O
*	O
errp	*(int)
)	O
{	O
static	O
const	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
hdr	O
=	O
{	O
.	O
cth_preamble	struct(short,char,char)
=	O
{	O
CTF_MAGIC	O
,	O
CTF_VERSION	O
,	O
0	int
}	O
}	O
;	O
ctf_dynhash_t	O
*	O
dthash	O
;	O
ctf_dynhash_t	O
*	O
dvhash	O
;	O
ctf_dynhash_t	O
*	O
structs	O
=	O
NULL	O
,	O
*	O
unions	O
=	O
NULL	O
,	O
*	O
enums	O
=	O
NULL	O
,	O
*	O
names	O
=	O
NULL	O
;	O
ctf_sect_t	struct(*(char),*(void),long,long)
cts	O
;	O
ctf_file_t	struct
*	O
fp	*(struct)
;	O
libctf_init_debug	O
(	O
)	O
;	O
dthash	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_integer	O
,	O
ctf_hash_eq_integer	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dthash	O
==	O
NULL	O
)	O
{	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
EAGAIN	O
)	O
;	O
goto	O
err	long
;	O
}	O
dvhash	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dvhash	O
==	O
NULL	O
)	O
{	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
EAGAIN	O
)	O
;	O
goto	O
err_dt	O
;	O
}	O
structs	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
unions	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
enums	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
names	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
structs	O
||	O
!	O
unions	O
||	O
!	O
enums	O
||	O
!	O
names	O
)	O
{	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
EAGAIN	O
)	O
;	O
goto	O
err_dv	O
;	O
}	O
cts	O
.	O
cts_name	*(char)
=	O
_CTF_SECTION	O
;	O
cts	O
.	O
cts_data	*(void)
=	O
&	O
hdr	O
;	O
cts	O
.	O
cts_size	long
=	O
sizeof	O
(	O
hdr	O
)	O
;	O
cts	O
.	O
cts_entsize	long
=	O
1	int
;	O
if	O
(	O
(	O
fp	*(struct)
=	O
ctf_bufopen_internal	O
(	O
&	O
cts	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
1	int
,	O
errp	*(int)
)	O
)	O
==	O
NULL	O
)	O
goto	O
err_dv	O
;	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_writable	O
=	O
structs	O
;	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_writable	O
=	O
unions	O
;	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_writable	O
=	O
enums	O
;	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_writable	O
=	O
names	O
;	O
fp	*(struct)
->	O
ctf_dthash	O
=	O
dthash	O
;	O
fp	*(struct)
->	O
ctf_dvhash	O
=	O
dvhash	O
;	O
fp	*(struct)
->	O
ctf_dtoldid	O
=	O
0	int
;	O
fp	*(struct)
->	O
ctf_snapshots	O
=	O
1	int
;	O
fp	*(struct)
->	O
ctf_snapshot_lu	O
=	O
0	int
;	O
ctf_set_ctl_hashes	O
(	O
fp	*(struct)
)	O
;	O
ctf_setmodel	(*(struct),int)->(int)
(	O
fp	*(struct)
,	O
CTF_MODEL_NATIVE	O
)	O
;	O
if	O
(	O
ctf_grow_ptrtab	O
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
{	O
ctf_set_open_errno	O
(	O
errp	*(int)
,	O
ctf_errno	(*(struct))->(int)
(	O
fp	*(struct)
)	O
)	O
;	O
ctf_file_close	(*(struct))->(void)
(	O
fp	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
fp	*(struct)
;	O
err_dv	O
:	O
ctf_dynhash_destroy	O
(	O
structs	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
unions	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
enums	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
names	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
dvhash	O
)	O
;	O
err_dt	O
:	O
ctf_dynhash_destroy	O
(	O
dthash	O
)	O
;	O
err	long
:	O
return	O
NULL	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_smembers	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
unsigned	O
char	O
*	O
t	O
)	O
{	O
ctf_dmdef_t	O
*	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
ctf_member_t	struct(int,int,int)
ctm	O
;	O
for	O
(	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
ctf_member_t	struct(int,int,int)
*	O
copied	O
;	O
ctm	O
.	O
ctm_name	int
=	O
0	int
;	O
ctm	O
.	O
ctm_type	short
=	O
(	O
uint32_t	int
)	O
dmd	O
->	O
dmd_type	O
;	O
ctm	O
.	O
ctm_offset	short
=	O
(	O
uint32_t	int
)	O
dmd	O
->	O
dmd_offset	O
;	O
memcpy	O
(	O
t	O
,	O
&	O
ctm	O
,	O
sizeof	O
(	O
ctm	O
)	O
)	O
;	O
copied	O
=	O
(	O
ctf_member_t	struct(int,int,int)
*	O
)	O
t	O
;	O
if	O
(	O
dmd	O
->	O
dmd_name	O
)	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
dmd	O
->	O
dmd_name	O
,	O
&	O
copied	O
->	O
ctm_name	int
)	O
;	O
t	O
+=	O
sizeof	O
(	O
ctm	O
)	O
;	O
}	O
return	O
t	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_lmembers	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
unsigned	O
char	O
*	O
t	O
)	O
{	O
ctf_dmdef_t	O
*	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
ctf_lmember_t	struct(int,int,int,int)
ctlm	O
;	O
for	O
(	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
ctf_lmember_t	struct(int,int,int,int)
*	O
copied	O
;	O
ctlm	O
.	O
ctlm_name	int
=	O
0	int
;	O
ctlm	O
.	O
ctlm_type	short
=	O
(	O
uint32_t	int
)	O
dmd	O
->	O
dmd_type	O
;	O
ctlm	O
.	O
ctlm_offsethi	int
=	O
CTF_OFFSET_TO_LMEMHI	O
(	O
dmd	O
->	O
dmd_offset	O
)	O
;	O
ctlm	O
.	O
ctlm_offsetlo	int
=	O
CTF_OFFSET_TO_LMEMLO	O
(	O
dmd	O
->	O
dmd_offset	O
)	O
;	O
memcpy	O
(	O
t	O
,	O
&	O
ctlm	O
,	O
sizeof	O
(	O
ctlm	O
)	O
)	O
;	O
copied	O
=	O
(	O
ctf_lmember_t	struct(int,int,int,int)
*	O
)	O
t	O
;	O
if	O
(	O
dmd	O
->	O
dmd_name	O
)	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
dmd	O
->	O
dmd_name	O
,	O
&	O
copied	O
->	O
ctlm_name	int
)	O
;	O
t	O
+=	O
sizeof	O
(	O
ctlm	O
)	O
;	O
}	O
return	O
t	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_emembers	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
unsigned	O
char	O
*	O
t	O
)	O
{	O
ctf_dmdef_t	O
*	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
ctf_enum_t	struct(int,int)
cte	O
;	O
for	O
(	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
ctf_enum_t	struct(int,int)
*	O
copied	O
;	O
cte	O
.	O
cte_value	int
=	O
dmd	O
->	O
dmd_value	O
;	O
memcpy	O
(	O
t	O
,	O
&	O
cte	O
,	O
sizeof	O
(	O
cte	O
)	O
)	O
;	O
copied	O
=	O
(	O
ctf_enum_t	struct(int,int)
*	O
)	O
t	O
;	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
dmd	O
->	O
dmd_name	O
,	O
&	O
copied	O
->	O
cte_name	int
)	O
;	O
t	O
+=	O
sizeof	O
(	O
cte	O
)	O
;	O
}	O
return	O
t	O
;	O
}	O
typedef	O
struct	O
ctf_sort_var_arg_cb	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
;	O
ctf_strs_t	O
*	O
strtab	O
;	O
}	O
ctf_sort_var_arg_cb_t	O
;	O
static	O
int	O
ctf_sort_var	O
(	O
const	O
void	O
*	O
one_	O
,	O
const	O
void	O
*	O
two_	O
,	O
void	O
*	O
arg_	O
)	O
{	O
const	O
ctf_varent_t	struct(int,int)
*	O
one	O
=	O
one_	O
;	O
const	O
ctf_varent_t	struct(int,int)
*	O
two	O
=	O
two_	O
;	O
ctf_sort_var_arg_cb_t	O
*	O
arg	*(void)
=	O
arg_	O
;	O
return	O
(	O
strcmp	O
(	O
ctf_strraw_explicit	O
(	O
arg	*(void)
->	O
fp	*(struct)
,	O
one	O
->	O
ctv_name	int
,	O
arg	*(void)
->	O
strtab	O
)	O
,	O
ctf_strraw_explicit	O
(	O
arg	*(void)
->	O
fp	*(struct)
,	O
two	O
->	O
ctv_name	int
,	O
arg	*(void)
->	O
strtab	O
)	O
)	O
)	O
;	O
}	O
int	O
ctf_update	(*(struct))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_dtoldid	O
=	O
fp	*(struct)
->	O
ctf_typemax	O
;	O
return	O
0	int
;	O
}	O
int	O
ctf_serialize	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_file_t	struct
ofp	O
,	O
*	O
nfp	O
;	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
hdr	O
,	O
*	O
hdrp	O
;	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_dvdef_t	O
*	O
dvd	O
;	O
ctf_varent_t	struct(int,int)
*	O
dvarents	O
;	O
ctf_strs_writable_t	O
strtab	O
;	O
unsigned	O
char	O
*	O
t	O
;	O
unsigned	O
long	O
i	*(struct)
;	O
size_t	long
buf_size	O
,	O
type_size	O
,	O
nvars	O
;	O
unsigned	O
char	O
*	O
buf	*(void)
,	O
*	O
newbuf	O
;	O
int	O
err	long
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_DIRTY	O
)	O
)	O
return	O
0	int
;	O
memset	O
(	O
&	O
hdr	O
,	O
0	int
,	O
sizeof	O
(	O
hdr	O
)	O
)	O
;	O
hdr	O
.	O
cth_magic	O
=	O
CTF_MAGIC	O
;	O
hdr	O
.	O
cth_version	O
=	O
CTF_VERSION	O
;	O
for	O
(	O
type_size	O
=	O
0	int
,	O
dtd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
)	O
;	O
dtd	O
!=	O
NULL	O
;	O
dtd	O
=	O
ctf_list_next	O
(	O
dtd	O
)	O
)	O
{	O
uint32_t	int
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
uint32_t	int
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
!=	O
CTF_LSIZE_SENT	O
)	O
type_size	O
+=	O
sizeof	O
(	O
ctf_stype_t	O
)	O
;	O
else	O
type_size	O
+=	O
sizeof	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
type_size	O
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	O
:	O
type_size	O
+=	O
sizeof	O
(	O
ctf_array_t	struct(int,int,int)
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	O
:	O
type_size	O
+=	O
sizeof	O
(	O
ctf_slice_t	struct(int,short,short)
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
type_size	O
+=	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	O
+	O
(	O
vlen	O
&	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
<	O
CTF_LSTRUCT_THRESH	O
)	O
type_size	O
+=	O
sizeof	O
(	O
ctf_member_t	struct(int,int,int)
)	O
*	O
vlen	O
;	O
else	O
type_size	O
+=	O
sizeof	O
(	O
ctf_lmember_t	struct(int,int,int,int)
)	O
*	O
vlen	O
;	O
break	O
;	O
case	O
CTF_K_ENUM	O
:	O
type_size	O
+=	O
sizeof	O
(	O
ctf_enum_t	struct(int,int)
)	O
*	O
vlen	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
nvars	O
=	O
0	int
,	O
dvd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
)	O
;	O
dvd	O
!=	O
NULL	O
;	O
dvd	O
=	O
ctf_list_next	O
(	O
dvd	O
)	O
,	O
nvars	O
++	O
)	O
;	O
hdr	O
.	O
cth_typeoff	int
=	O
hdr	O
.	O
cth_varoff	int
+	O
(	O
nvars	O
*	O
sizeof	O
(	O
ctf_varent_t	struct(int,int)
)	O
)	O
;	O
hdr	O
.	O
cth_stroff	int
=	O
hdr	O
.	O
cth_typeoff	int
+	O
type_size	O
;	O
hdr	O
.	O
cth_strlen	int
=	O
0	int
;	O
buf_size	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
+	O
hdr	O
.	O
cth_stroff	int
+	O
hdr	O
.	O
cth_strlen	int
;	O
if	O
(	O
(	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
buf_size	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
memcpy	O
(	O
buf	*(void)
,	O
&	O
hdr	O
,	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
t	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(void)
+	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
+	O
hdr	O
.	O
cth_varoff	int
;	O
hdrp	O
=	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
)	O
buf	*(void)
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_CHILD	O
)	O
&&	O
(	O
fp	*(struct)
->	O
ctf_parname	O
!=	O
NULL	O
)	O
)	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
fp	*(struct)
->	O
ctf_parname	O
,	O
&	O
hdrp	O
->	O
cth_parname	int
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
!=	O
NULL	O
)	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
fp	*(struct)
->	O
ctf_cuname	(*(struct))->(*(char))
,	O
&	O
hdrp	O
->	O
cth_cuname	int
)	O
;	O
dvarents	O
=	O
(	O
ctf_varent_t	struct(int,int)
*	O
)	O
t	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
dvd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
)	O
;	O
dvd	O
!=	O
NULL	O
;	O
dvd	O
=	O
ctf_list_next	O
(	O
dvd	O
)	O
,	O
i	*(struct)
++	O
)	O
{	O
ctf_varent_t	struct(int,int)
*	O
var	O
=	O
&	O
dvarents	O
[	O
i	*(struct)
]	O
;	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
dvd	O
->	O
dvd_name	O
,	O
&	O
var	O
->	O
ctv_name	int
)	O
;	O
var	O
->	O
ctv_type	int
=	O
dvd	O
->	O
dvd_type	O
;	O
}	O
assert	O
(	O
i	*(struct)
==	O
nvars	O
)	O
;	O
t	O
+=	O
sizeof	O
(	O
ctf_varent_t	struct(int,int)
)	O
*	O
nvars	O
;	O
assert	O
(	O
t	O
==	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(void)
+	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
+	O
hdr	O
.	O
cth_typeoff	int
)	O
;	O
for	O
(	O
dtd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
)	O
;	O
dtd	O
!=	O
NULL	O
;	O
dtd	O
=	O
ctf_list_next	O
(	O
dtd	O
)	O
)	O
{	O
uint32_t	int
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
uint32_t	int
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
ctf_array_t	struct(int,int,int)
cta	O
;	O
uint32_t	int
encoding	O
;	O
size_t	long
len	int
;	O
ctf_stype_t	O
*	O
copied	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
!=	O
CTF_LSIZE_SENT	O
)	O
len	int
=	O
sizeof	O
(	O
ctf_stype_t	O
)	O
;	O
else	O
len	int
=	O
sizeof	O
(	O
ctf_type_t	struct(int,int,union(int,int),int,int)
)	O
;	O
memcpy	O
(	O
t	O
,	O
&	O
dtd	O
->	O
dtd_data	O
,	O
len	int
)	O
;	O
copied	O
=	O
(	O
ctf_stype_t	O
*	O
)	O
t	O
;	O
if	O
(	O
copied	O
->	O
ctt_name	int
&&	O
(	O
name	*(char)
=	O
ctf_strraw	O
(	O
fp	*(struct)
,	O
copied	O
->	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
&	O
copied	O
->	O
ctt_name	int
)	O
;	O
t	O
+=	O
len	int
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_INTEGER	O
:	O
case	O
CTF_K_FLOAT	O
:	O
if	O
(	O
kind	O
==	O
CTF_K_INTEGER	O
)	O
{	O
encoding	O
=	O
CTF_INT_DATA	O
(	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_format	int
,	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_offset	int
,	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_bits	int
)	O
;	O
}	O
else	O
{	O
encoding	O
=	O
CTF_FP_DATA	O
(	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_format	int
,	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_offset	int
,	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
.	O
cte_bits	int
)	O
;	O
}	O
memcpy	O
(	O
t	O
,	O
&	O
encoding	O
,	O
sizeof	O
(	O
encoding	O
)	O
)	O
;	O
t	O
+=	O
sizeof	O
(	O
encoding	O
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	O
:	O
memcpy	O
(	O
t	O
,	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_slice	O
,	O
sizeof	O
(	O
struct	O
ctf_slice	struct(int,short,short)
)	O
)	O
;	O
t	O
+=	O
sizeof	O
(	O
struct	O
ctf_slice	struct(int,short,short)
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	O
:	O
cta	O
.	O
cta_contents	short
=	O
(	O
uint32_t	int
)	O
dtd	O
->	O
dtd_u	O
.	O
dtu_arr	O
.	O
ctr_contents	long
;	O
cta	O
.	O
cta_index	short
=	O
(	O
uint32_t	int
)	O
dtd	O
->	O
dtd_u	O
.	O
dtu_arr	O
.	O
ctr_index	long
;	O
cta	O
.	O
cta_nelems	int
=	O
dtd	O
->	O
dtd_u	O
.	O
dtu_arr	O
.	O
ctr_nelems	int
;	O
memcpy	O
(	O
t	O
,	O
&	O
cta	O
,	O
sizeof	O
(	O
cta	O
)	O
)	O
;	O
t	O
+=	O
sizeof	O
(	O
cta	O
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
{	O
uint32_t	int
*	O
argv	*(*(char))
=	O
(	O
uint32_t	int
*	O
)	O
(	O
uintptr_t	long
)	O
t	O
;	O
uint32_t	int
argc	O
;	O
for	O
(	O
argc	O
=	O
0	int
;	O
argc	O
<	O
vlen	O
;	O
argc	O
++	O
)	O
*	O
argv	*(*(char))
++	O
=	O
(	O
uint32_t	int
)	O
dtd	O
->	O
dtd_u	O
.	O
dtu_argv	O
[	O
argc	O
]	O
;	O
if	O
(	O
vlen	O
&	O
1	int
)	O
*	O
argv	*(*(char))
++	O
=	O
0	int
;	O
t	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
argv	*(*(char))
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
<	O
CTF_LSTRUCT_THRESH	O
)	O
t	O
=	O
ctf_copy_smembers	O
(	O
fp	*(struct)
,	O
dtd	O
,	O
t	O
)	O
;	O
else	O
t	O
=	O
ctf_copy_lmembers	O
(	O
fp	*(struct)
,	O
dtd	O
,	O
t	O
)	O
;	O
break	O
;	O
case	O
CTF_K_ENUM	O
:	O
t	O
=	O
ctf_copy_emembers	O
(	O
fp	*(struct)
,	O
dtd	O
,	O
t	O
)	O
;	O
break	O
;	O
}	O
}	O
assert	O
(	O
t	O
==	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(void)
+	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
+	O
hdr	O
.	O
cth_stroff	int
)	O
;	O
strtab	O
=	O
ctf_str_write_strtab	O
(	O
fp	*(struct)
)	O
;	O
ctf_str_purge_refs	O
(	O
fp	*(struct)
)	O
;	O
if	O
(	O
strtab	O
.	O
cts_strs	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
ctf_sort_var_arg_cb_t	O
sort_var_arg	O
=	O
{	O
fp	*(struct)
,	O
(	O
ctf_strs_t	O
*	O
)	O
&	O
strtab	O
}	O
;	O
ctf_qsort_r	(*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(void)
(	O
dvarents	O
,	O
nvars	O
,	O
sizeof	O
(	O
ctf_varent_t	struct(int,int)
)	O
,	O
ctf_sort_var	O
,	O
&	O
sort_var_arg	O
)	O
;	O
if	O
(	O
(	O
newbuf	O
=	O
ctf_realloc	O
(	O
fp	*(struct)
,	O
buf	*(void)
,	O
buf_size	O
+	O
strtab	O
.	O
cts_len	O
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
strtab	O
.	O
cts_strs	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
buf	*(void)
=	O
newbuf	O
;	O
memcpy	O
(	O
buf	*(void)
+	O
buf_size	O
,	O
strtab	O
.	O
cts_strs	O
,	O
strtab	O
.	O
cts_len	O
)	O
;	O
hdrp	O
=	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
)	O
buf	*(void)
;	O
hdrp	O
->	O
cth_strlen	int
=	O
strtab	O
.	O
cts_len	O
;	O
buf_size	O
+=	O
hdrp	O
->	O
cth_strlen	int
;	O
free	(*(void))->(void)
(	O
strtab	O
.	O
cts_strs	O
)	O
;	O
if	O
(	O
(	O
nfp	O
=	O
ctf_simple_open_internal	O
(	O
(	O
char	O
*	O
)	O
buf	*(void)
,	O
buf_size	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
,	O
1	int
,	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
err	long
)	O
)	O
;	O
}	O
(	O
void	O
)	O
ctf_setmodel	(*(struct),int)->(int)
(	O
nfp	O
,	O
ctf_getmodel	(*(struct))->(int)
(	O
fp	*(struct)
)	O
)	O
;	O
(	O
void	O
)	O
ctf_import	(*(struct),*(struct))->(int)
(	O
nfp	O
,	O
fp	*(struct)
->	O
ctf_parent	O
)	O
;	O
nfp	O
->	O
ctf_refcnt	O
=	O
fp	*(struct)
->	O
ctf_refcnt	O
;	O
nfp	O
->	O
ctf_flags	O
|=	O
fp	*(struct)
->	O
ctf_flags	O
&	O
~	O
LCTF_DIRTY	O
;	O
if	O
(	O
nfp	O
->	O
ctf_dynbase	O
==	O
NULL	O
)	O
nfp	O
->	O
ctf_dynbase	O
=	O
buf	*(void)
;	O
nfp	O
->	O
ctf_dthash	O
=	O
fp	*(struct)
->	O
ctf_dthash	O
;	O
nfp	O
->	O
ctf_dtdefs	O
=	O
fp	*(struct)
->	O
ctf_dtdefs	O
;	O
nfp	O
->	O
ctf_dvhash	O
=	O
fp	*(struct)
->	O
ctf_dvhash	O
;	O
nfp	O
->	O
ctf_dvdefs	O
=	O
fp	*(struct)
->	O
ctf_dvdefs	O
;	O
nfp	O
->	O
ctf_dtoldid	O
=	O
fp	*(struct)
->	O
ctf_dtoldid	O
;	O
nfp	O
->	O
ctf_add_processing	O
=	O
fp	*(struct)
->	O
ctf_add_processing	O
;	O
nfp	O
->	O
ctf_snapshots	O
=	O
fp	*(struct)
->	O
ctf_snapshots	O
+	O
1	int
;	O
nfp	O
->	O
ctf_specific	O
=	O
fp	*(struct)
->	O
ctf_specific	O
;	O
nfp	O
->	O
ctf_ptrtab	O
=	O
fp	*(struct)
->	O
ctf_ptrtab	O
;	O
nfp	O
->	O
ctf_ptrtab_len	O
=	O
fp	*(struct)
->	O
ctf_ptrtab_len	O
;	O
nfp	O
->	O
ctf_link_inputs	O
=	O
fp	*(struct)
->	O
ctf_link_inputs	O
;	O
nfp	O
->	O
ctf_link_outputs	O
=	O
fp	*(struct)
->	O
ctf_link_outputs	O
;	O
nfp	O
->	O
ctf_str_prov_offset	O
=	O
fp	*(struct)
->	O
ctf_str_prov_offset	O
;	O
nfp	O
->	O
ctf_syn_ext_strtab	O
=	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
;	O
nfp	O
->	O
ctf_link_cu_mapping	O
=	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
;	O
nfp	O
->	O
ctf_link_type_mapping	O
=	O
fp	*(struct)
->	O
ctf_link_type_mapping	O
;	O
nfp	O
->	O
ctf_link_memb_name_changer	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer	O
;	O
nfp	O
->	O
ctf_link_memb_name_changer_arg	O
=	O
fp	*(struct)
->	O
ctf_link_memb_name_changer_arg	O
;	O
nfp	O
->	O
ctf_snapshot_lu	O
=	O
fp	*(struct)
->	O
ctf_snapshots	O
;	O
memcpy	O
(	O
&	O
nfp	O
->	O
ctf_lookups	O
,	O
fp	*(struct)
->	O
ctf_lookups	O
,	O
sizeof	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
)	O
)	O
;	O
nfp	O
->	O
ctf_structs	O
=	O
fp	*(struct)
->	O
ctf_structs	O
;	O
nfp	O
->	O
ctf_unions	O
=	O
fp	*(struct)
->	O
ctf_unions	O
;	O
nfp	O
->	O
ctf_enums	O
=	O
fp	*(struct)
->	O
ctf_enums	O
;	O
nfp	O
->	O
ctf_names	O
=	O
fp	*(struct)
->	O
ctf_names	O
;	O
fp	*(struct)
->	O
ctf_dthash	O
=	O
NULL	O
;	O
ctf_str_free_atoms	O
(	O
nfp	O
)	O
;	O
nfp	O
->	O
ctf_str_atoms	O
=	O
fp	*(struct)
->	O
ctf_str_atoms	O
;	O
nfp	O
->	O
ctf_prov_strtab	O
=	O
fp	*(struct)
->	O
ctf_prov_strtab	O
;	O
fp	*(struct)
->	O
ctf_str_atoms	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_prov_strtab	O
=	O
NULL	O
;	O
memset	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
,	O
0	int
,	O
sizeof	O
(	O
ctf_list_t	O
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_add_processing	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_ptrtab	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_link_inputs	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_link_outputs	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_link_cu_mapping	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_link_type_mapping	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_dvhash	O
=	O
NULL	O
;	O
memset	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
,	O
0	int
,	O
sizeof	O
(	O
ctf_list_t	O
)	O
)	O
;	O
memset	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
,	O
0	int
,	O
sizeof	O
(	O
fp	*(struct)
->	O
ctf_lookups	O
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_structs	O
.	O
ctn_writable	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_unions	O
.	O
ctn_writable	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_enums	O
.	O
ctn_writable	O
=	O
NULL	O
;	O
fp	*(struct)
->	O
ctf_names	O
.	O
ctn_writable	O
=	O
NULL	O
;	O
memcpy	O
(	O
&	O
ofp	O
,	O
fp	*(struct)
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
memcpy	O
(	O
fp	*(struct)
,	O
nfp	O
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
memcpy	O
(	O
nfp	O
,	O
&	O
ofp	O
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
nfp	O
->	O
ctf_refcnt	O
=	O
1	int
;	O
ctf_file_close	(*(struct))->(void)
(	O
nfp	O
)	O
;	O
return	O
0	int
;	O
}	O
ctf_names_t	O
*	O
ctf_name_table	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
kind	O
)	O
{	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_STRUCT	O
:	O
return	O
&	O
fp	*(struct)
->	O
ctf_structs	O
;	O
case	O
CTF_K_UNION	O
:	O
return	O
&	O
fp	*(struct)
->	O
ctf_unions	O
;	O
case	O
CTF_K_ENUM	O
:	O
return	O
&	O
fp	*(struct)
->	O
ctf_enums	O
;	O
default	O
:	O
return	O
&	O
fp	*(struct)
->	O
ctf_names	O
;	O
}	O
}	O
int	O
ctf_dtd_insert	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
int	O
kind	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
,	O
(	O
void	O
*	O
)	O
dtd	O
->	O
dtd_type	O
,	O
dtd	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
&&	O
(	O
name	*(char)
=	O
ctf_strraw	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
ctf_dynhash_insert	O
(	O
ctf_name_table	O
(	O
fp	*(struct)
,	O
kind	O
)	O
->	O
ctn_writable	O
,	O
(	O
char	O
*	O
)	O
name	*(char)
,	O
(	O
void	O
*	O
)	O
dtd	O
->	O
dtd_type	O
)	O
<	O
0	int
)	O
{	O
ctf_dynhash_remove	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
,	O
(	O
void	O
*	O
)	O
dtd	O
->	O
dtd_type	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
ctf_list_append	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
,	O
dtd	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ctf_dtd_delete	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dtdef_t	O
*	O
dtd	O
)	O
{	O
ctf_dmdef_t	O
*	O
dmd	O
,	O
*	O
nmd	O
;	O
int	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
ctf_dynhash_remove	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
,	O
(	O
void	O
*	O
)	O
dtd	O
->	O
dtd_type	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
case	O
CTF_K_ENUM	O
:	O
for	O
(	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
nmd	O
)	O
{	O
if	O
(	O
dmd	O
->	O
dmd_name	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
dmd	O
->	O
dmd_name	O
)	O
;	O
nmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
;	O
free	(*(void))->(void)
(	O
dmd	O
)	O
;	O
}	O
break	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
free	(*(void))->(void)
(	O
dtd	O
->	O
dtd_u	O
.	O
dtu_argv	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
&&	O
(	O
name	*(char)
=	O
ctf_strraw	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_dynhash_remove	O
(	O
ctf_name_table	O
(	O
fp	*(struct)
,	O
kind	O
)	O
->	O
ctn_writable	O
,	O
name	*(char)
)	O
;	O
ctf_str_remove_ref	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
&	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
;	O
}	O
ctf_list_delete	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
,	O
dtd	O
)	O
;	O
free	(*(void))->(void)
(	O
dtd	O
)	O
;	O
}	O
ctf_dtdef_t	O
*	O
ctf_dtd_lookup	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
type	long
)	O
{	O
return	O
(	O
ctf_dtdef_t	O
*	O
)	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
,	O
(	O
void	O
*	O
)	O
type	long
)	O
;	O
}	O
ctf_dtdef_t	O
*	O
ctf_dynamic_type	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
id	int
)	O
{	O
ctf_id_t	long
idx	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_CHILD	O
)	O
&&	O
LCTF_TYPE_ISPARENT	O
(	O
fp	*(struct)
,	O
id	int
)	O
)	O
fp	*(struct)
=	O
fp	*(struct)
->	O
ctf_parent	O
;	O
idx	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
id	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
idx	O
<=	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
return	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
id	int
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
ctf_dvd_insert	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dvdef_t	O
*	O
dvd	O
)	O
{	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_dvhash	O
,	O
dvd	O
->	O
dvd_name	O
,	O
dvd	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
ctf_list_append	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
,	O
dvd	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ctf_dvd_delete	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_dvdef_t	O
*	O
dvd	O
)	O
{	O
ctf_dynhash_remove	O
(	O
fp	*(struct)
->	O
ctf_dvhash	O
,	O
dvd	O
->	O
dvd_name	O
)	O
;	O
free	(*(void))->(void)
(	O
dvd	O
->	O
dvd_name	O
)	O
;	O
ctf_list_delete	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
,	O
dvd	O
)	O
;	O
free	(*(void))->(void)
(	O
dvd	O
)	O
;	O
}	O
ctf_dvdef_t	O
*	O
ctf_dvd_lookup	O
(	O
const	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
ctf_dvdef_t	O
*	O
)	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_dvhash	O
,	O
name	*(char)
)	O
;	O
}	O
int	O
ctf_discard	(*(struct))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_snapshot_id_t	struct(long,long)
last_update	O
=	O
{	O
fp	*(struct)
->	O
ctf_dtoldid	O
,	O
fp	*(struct)
->	O
ctf_snapshot_lu	O
+	O
1	int
}	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_DIRTY	O
)	O
)	O
return	O
0	int
;	O
return	O
(	O
ctf_rollback	(*(struct),struct(long,long))->(int)
(	O
fp	*(struct)
,	O
last_update	O
)	O
)	O
;	O
}	O
ctf_snapshot_id_t	struct(long,long)
ctf_snapshot	(*(struct))->(struct(long,long))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_snapshot_id_t	struct(long,long)
snapid	O
;	O
snapid	O
.	O
dtd_id	long
=	O
fp	*(struct)
->	O
ctf_typemax	O
;	O
snapid	O
.	O
snapshot_id	long
=	O
fp	*(struct)
->	O
ctf_snapshots	O
++	O
;	O
return	O
snapid	O
;	O
}	O
int	O
ctf_rollback	(*(struct),struct(long,long))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_snapshot_id_t	struct(long,long)
id	int
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
,	O
*	O
ntd	O
;	O
ctf_dvdef_t	O
*	O
dvd	O
,	O
*	O
nvd	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_snapshot_lu	O
>=	O
id	int
.	O
snapshot_id	long
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_OVERROLLBACK	int
)	O
)	O
;	O
for	O
(	O
dtd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dtdefs	O
)	O
;	O
dtd	O
!=	O
NULL	O
;	O
dtd	O
=	O
ntd	O
)	O
{	O
int	O
kind	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
ntd	O
=	O
ctf_list_next	O
(	O
dtd	O
)	O
;	O
if	O
(	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_type	O
)	O
<=	O
id	int
.	O
dtd_id	long
)	O
continue	O
;	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
&&	O
(	O
name	*(char)
=	O
ctf_strraw	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_dynhash_remove	O
(	O
ctf_name_table	O
(	O
fp	*(struct)
,	O
kind	O
)	O
->	O
ctn_writable	O
,	O
name	*(char)
)	O
;	O
ctf_str_remove_ref	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
&	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
;	O
}	O
ctf_dynhash_remove	O
(	O
fp	*(struct)
->	O
ctf_dthash	O
,	O
(	O
void	O
*	O
)	O
dtd	O
->	O
dtd_type	O
)	O
;	O
ctf_dtd_delete	O
(	O
fp	*(struct)
,	O
dtd	O
)	O
;	O
}	O
for	O
(	O
dvd	O
=	O
ctf_list_next	O
(	O
&	O
fp	*(struct)
->	O
ctf_dvdefs	O
)	O
;	O
dvd	O
!=	O
NULL	O
;	O
dvd	O
=	O
nvd	O
)	O
{	O
nvd	O
=	O
ctf_list_next	O
(	O
dvd	O
)	O
;	O
if	O
(	O
dvd	O
->	O
dvd_snapshots	O
<=	O
id	int
.	O
snapshot_id	long
)	O
continue	O
;	O
ctf_dvd_delete	O
(	O
fp	*(struct)
,	O
dvd	O
)	O
;	O
}	O
fp	*(struct)
->	O
ctf_typemax	O
=	O
id	int
.	O
dtd_id	long
;	O
fp	*(struct)
->	O
ctf_snapshots	O
=	O
id	int
.	O
snapshot_id	long
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_snapshots	O
==	O
fp	*(struct)
->	O
ctf_snapshot_lu	O
)	O
fp	*(struct)
->	O
ctf_flags	O
&=	O
~	O
LCTF_DIRTY	O
;	O
return	O
0	int
;	O
}	O
static	O
ctf_id_t	long
ctf_add_generic	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
kind	O
,	O
ctf_dtdef_t	O
*	O
*	O
rp	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
if	O
(	O
flag	int
!=	O
CTF_ADD_NONROOT	O
&&	O
flag	int
!=	O
CTF_ADD_ROOT	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
fp	*(struct)
->	O
ctf_typemax	O
,	O
1	int
)	O
>=	O
CTF_MAX_TYPE	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_FULL	int
)	O
)	O
;	O
if	O
(	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
fp	*(struct)
->	O
ctf_typemax	O
,	O
1	int
)	O
==	O
(	O
CTF_MAX_PTYPE	O
-	O
1	int
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_FULL	int
)	O
)	O
;	O
if	O
(	O
ctf_grow_ptrtab	O
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
dtd	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_dtdef_t	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
type	long
=	O
++	O
fp	*(struct)
->	O
ctf_typemax	O
;	O
type	long
=	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	*(struct)
,	O
type	long
,	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_CHILD	O
)	O
)	O
;	O
memset	O
(	O
dtd	O
,	O
0	int
,	O
sizeof	O
(	O
ctf_dtdef_t	O
)	O
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
=	O
ctf_str_add_ref	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
&	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
;	O
dtd	O
->	O
dtd_type	O
=	O
type	long
;	O
if	O
(	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
==	O
0	int
&&	O
name	*(char)
!=	O
NULL	O
&&	O
name	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
free	(*(void))->(void)
(	O
dtd	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
if	O
(	O
ctf_dtd_insert	O
(	O
fp	*(struct)
,	O
dtd	O
,	O
kind	O
)	O
<	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
dtd	O
)	O
;	O
return	O
CTF_ERR	O
;	O
}	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
*	O
rp	O
=	O
dtd	O
;	O
return	O
type	long
;	O
}	O
static	O
size_t	long
clp2	O
(	O
size_t	long
x	O
)	O
{	O
x	O
--	O
;	O
x	O
|=	O
(	O
x	O
>>	O
1	int
)	O
;	O
x	O
|=	O
(	O
x	O
>>	O
2	int
)	O
;	O
x	O
|=	O
(	O
x	O
>>	O
4	int
)	O
;	O
x	O
|=	O
(	O
x	O
>>	O
8	int
)	O
;	O
x	O
|=	O
(	O
x	O
>>	O
16	int
)	O
;	O
return	O
(	O
x	O
+	O
1	int
)	O
;	O
}	O
static	O
ctf_id_t	long
ctf_add_encoded	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
ctf_encoding_t	struct(int,int,int)
*	O
ep	O
,	O
uint32_t	int
kind	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
if	O
(	O
ep	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
kind	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
clp2	O
(	O
P2ROUNDUP	O
(	O
ep	O
->	O
cte_bits	int
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
)	O
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_enc	O
=	O
*	O
ep	O
;	O
return	O
type	long
;	O
}	O
static	O
ctf_id_t	long
ctf_add_reftype	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
,	O
uint32_t	int
kind	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
int	O
child	O
=	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_CHILD	O
;	O
if	O
(	O
ref	O
==	O
CTF_ERR	O
||	O
ref	O
>	O
CTF_MAX_TYPE	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
ref	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
NULL	O
,	O
kind	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ref	O
;	O
if	O
(	O
kind	O
!=	O
CTF_K_POINTER	O
)	O
return	O
type	long
;	O
uint32_t	int
type_idx	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
uint32_t	int
ref_idx	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
ref	O
)	O
;	O
if	O
(	O
LCTF_TYPE_ISCHILD	O
(	O
fp	*(struct)
,	O
ref	O
)	O
==	O
child	O
&&	O
ref_idx	O
<	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
{	O
fp	*(struct)
->	O
ctf_ptrtab	O
[	O
ref_idx	O
]	O
=	O
type_idx	O
;	O
ctf_id_t	long
refref_idx	O
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_type	short
)	O
;	O
if	O
(	O
tmp	O
==	O
fp	*(struct)
&&	O
(	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
==	O
CTF_K_TYPEDEF	O
)	O
&&	O
strcmp	O
(	O
ctf_strptr	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_name	int
)	O
,	O
""	*(char)
)	O
==	O
0	int
&&	O
refref_idx	O
<	O
fp	*(struct)
->	O
ctf_typemax	O
)	O
fp	*(struct)
->	O
ctf_ptrtab	O
[	O
refref_idx	O
]	O
=	O
type_idx	O
;	O
}	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_slice	(*(struct),int,long,*(struct(int,int,int)))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
,	O
const	O
ctf_encoding_t	struct(int,int,int)
*	O
ep	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
int	O
kind	O
;	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
tp	O
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
ep	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
(	O
ep	O
->	O
cte_bits	int
>	O
255	int
)	O
||	O
(	O
ep	O
->	O
cte_offset	int
>	O
255	int
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_SLICEOVERFLOW	int
)	O
)	O
;	O
if	O
(	O
ref	O
==	O
CTF_ERR	O
||	O
ref	O
>	O
CTF_MAX_TYPE	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
(	O
tp	O
=	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
ref	O
)	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
kind	O
=	O
ctf_type_kind_unsliced	O
(	O
tmp	O
,	O
ref	O
)	O
;	O
if	O
(	O
(	O
kind	O
!=	O
CTF_K_INTEGER	O
)	O
&&	O
(	O
kind	O
!=	O
CTF_K_FLOAT	O
)	O
&&	O
(	O
kind	O
!=	O
CTF_K_ENUM	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_SLICE	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_SLICE	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
clp2	O
(	O
P2ROUNDUP	O
(	O
ep	O
->	O
cte_bits	int
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
)	O
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_slice	O
.	O
cts_type	int
=	O
ref	O
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_slice	O
.	O
cts_bits	short
=	O
ep	O
->	O
cte_bits	int
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_slice	O
.	O
cts_offset	short
=	O
ep	O
->	O
cte_offset	int
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_integer	(*(struct),int,*(char),*(struct(int,int,int)))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
ctf_encoding_t	struct(int,int,int)
*	O
ep	O
)	O
{	O
return	O
(	O
ctf_add_encoded	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
ep	O
,	O
CTF_K_INTEGER	O
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_float	(*(struct),int,*(char),*(struct(int,int,int)))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
ctf_encoding_t	struct(int,int,int)
*	O
ep	O
)	O
{	O
return	O
(	O
ctf_add_encoded	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
ep	O
,	O
CTF_K_FLOAT	O
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_pointer	(*(struct),int,long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
)	O
{	O
return	O
(	O
ctf_add_reftype	O
(	O
fp	*(struct)
,	O
flag	int
,	O
ref	O
,	O
CTF_K_POINTER	O
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_array	(*(struct),int,*(struct(long,long,int)))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
ctf_arinfo_t	struct(long,long,int)
*	O
arp	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
arp	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
arp	O
->	O
ctr_contents	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
arp	O
->	O
ctr_index	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_ARRAY	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_ARRAY	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
0	int
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_arr	O
=	O
*	O
arp	O
;	O
return	O
type	long
;	O
}	O
int	O
ctf_set_array	(*(struct),long,*(struct(long,long,int)))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
type	long
,	O
const	O
ctf_arinfo_t	struct(long,long,int)
*	O
arp	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	O
==	O
NULL	O
||	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
!=	O
CTF_K_ARRAY	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_BADID	int
)	O
)	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_arr	O
=	O
*	O
arp	O
;	O
return	O
0	int
;	O
}	O
ctf_id_t	long
ctf_add_function	(*(struct),int,*(struct(long,int,int)),*(long))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
ctf_funcinfo_t	struct(long,int,int)
*	O
ctc	O
,	O
const	O
ctf_id_t	long
*	O
argv	*(*(char))
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
uint32_t	int
vlen	O
;	O
ctf_id_t	long
*	O
vdat	O
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
size_t	long
i	*(struct)
;	O
if	O
(	O
ctc	O
==	O
NULL	O
||	O
(	O
ctc	O
->	O
ctc_flags	int
&	O
~	O
CTF_FUNC_VARARG	O
)	O
!=	O
0	int
||	O
(	O
ctc	O
->	O
ctc_argc	int
!=	O
0	int
&&	O
argv	*(*(char))
==	O
NULL	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
vlen	O
=	O
ctc	O
->	O
ctc_argc	int
;	O
if	O
(	O
ctc	O
->	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	O
)	O
vlen	O
++	O
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
ctc	O
->	O
ctc_return	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ctc	O
->	O
ctc_argc	int
;	O
i	*(struct)
++	O
)	O
{	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
argv	*(*(char))
[	O
i	*(struct)
]	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
}	O
if	O
(	O
vlen	O
>	O
CTF_MAX_VLEN	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EOVERFLOW	O
)	O
)	O
;	O
if	O
(	O
vlen	O
!=	O
0	int
&&	O
(	O
vdat	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_id_t	long
)	O
*	O
vlen	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_FUNCTION	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
{	O
free	(*(void))->(void)
(	O
vdat	O
)	O
;	O
return	O
CTF_ERR	O
;	O
}	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_FUNCTION	O
,	O
flag	int
,	O
vlen	O
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ctc	O
->	O
ctc_return	long
;	O
memcpy	O
(	O
vdat	O
,	O
argv	*(*(char))
,	O
sizeof	O
(	O
ctf_id_t	long
)	O
*	O
ctc	O
->	O
ctc_argc	int
)	O
;	O
if	O
(	O
ctc	O
->	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	O
)	O
vdat	O
[	O
vlen	O
-	O
1	int
]	O
=	O
0	int
;	O
dtd	O
->	O
dtd_u	O
.	O
dtu_argv	O
=	O
vdat	O
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_struct_sized	(*(struct),int,*(char),long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
size	long
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	O
(	O
fp	*(struct)
,	O
CTF_K_STRUCT	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	(*(struct),long)->(int)
(	O
fp	*(struct)
,	O
type	long
)	O
==	O
CTF_K_FORWARD	O
)	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
CTF_K_STRUCT	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_STRUCT	O
,	O
flag	int
,	O
0	int
)	O
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	O
)	O
{	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_struct	(*(struct),int,*(char))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
ctf_add_struct_sized	(*(struct),int,*(char),long)->(long)
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
0	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_union_sized	(*(struct),int,*(char),long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
size	long
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	O
(	O
fp	*(struct)
,	O
CTF_K_UNION	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	(*(struct),long)->(int)
(	O
fp	*(struct)
,	O
type	long
)	O
==	O
CTF_K_FORWARD	O
)	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
CTF_K_UNION	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_UNION	O
,	O
flag	int
,	O
0	int
)	O
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	O
)	O
{	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_union	(*(struct),int,*(char))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
(	O
ctf_add_union_sized	(*(struct),int,*(char),long)->(long)
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
0	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_enum	(*(struct),int,*(char))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	O
(	O
fp	*(struct)
,	O
CTF_K_ENUM	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	(*(struct),long)->(int)
(	O
fp	*(struct)
,	O
type	long
)	O
==	O
CTF_K_FORWARD	O
)	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
CTF_K_ENUM	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_ENUM	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
fp	*(struct)
->	O
ctf_dmodel	O
->	O
ctd_int	O
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_enum_encoded	(*(struct),int,*(char),*(struct(int,int,int)))->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
ctf_encoding_t	struct(int,int,int)
*	O
ep	O
)	O
{	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	O
(	O
fp	*(struct)
,	O
CTF_K_ENUM	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ctf_type_kind	(*(struct),long)->(int)
(	O
fp	*(struct)
,	O
type	long
)	O
!=	O
CTF_K_FORWARD	O
)	O
&&	O
(	O
ctf_type_kind_unsliced	O
(	O
fp	*(struct)
,	O
type	long
)	O
!=	O
CTF_K_ENUM	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_enum	(*(struct),int,*(char))->(long)
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
return	O
ctf_add_slice	(*(struct),int,long,*(struct(int,int,int)))->(long)
(	O
fp	*(struct)
,	O
flag	int
,	O
type	long
,	O
ep	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_forward	(*(struct),int,*(char),int)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
uint32_t	int
kind	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
kind	O
!=	O
CTF_K_STRUCT	O
&&	O
kind	O
!=	O
CTF_K_UNION	O
&&	O
kind	O
!=	O
CTF_K_ENUM	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTSUE	int
)	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	O
(	O
fp	*(struct)
,	O
kind	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
CTF_K_FORWARD	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_FORWARD	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_type	short
=	O
kind	O
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_typedef	(*(struct),int,*(char),long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
ref	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
ref	O
==	O
CTF_ERR	O
||	O
ref	O
>	O
CTF_MAX_TYPE	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
ref	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	O
(	O
fp	*(struct)
,	O
flag	int
,	O
name	*(char)
,	O
CTF_K_TYPEDEF	O
,	O
&	O
dtd	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_TYPEDEF	O
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ref	O
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_volatile	(*(struct),int,long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
)	O
{	O
return	O
(	O
ctf_add_reftype	O
(	O
fp	*(struct)
,	O
flag	int
,	O
ref	O
,	O
CTF_K_VOLATILE	O
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_const	(*(struct),int,long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
)	O
{	O
return	O
(	O
ctf_add_reftype	O
(	O
fp	*(struct)
,	O
flag	int
,	O
ref	O
,	O
CTF_K_CONST	O
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_restrict	(*(struct),int,long)->(long)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	O
)	O
{	O
return	O
(	O
ctf_add_reftype	O
(	O
fp	*(struct)
,	O
flag	int
,	O
ref	O
,	O
CTF_K_RESTRICT	O
)	O
)	O
;	O
}	O
int	O
ctf_add_enumerator	(*(struct),long,*(char),int)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
enid	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
value	int
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
enid	O
)	O
;	O
ctf_dmdef_t	O
*	O
dmd	O
;	O
uint32_t	int
kind	O
,	O
vlen	O
,	O
root	O
;	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EINVAL	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_BADID	int
)	O
)	O
;	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
root	O
=	O
LCTF_INFO_ISROOT	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
if	O
(	O
kind	O
!=	O
CTF_K_ENUM	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTENUM	int
)	O
)	O
;	O
if	O
(	O
vlen	O
==	O
CTF_MAX_VLEN	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DTFULL	int
)	O
)	O
;	O
for	O
(	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
if	O
(	O
strcmp	O
(	O
dmd	O
->	O
dmd_name	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
dmd	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_dmdef_t	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
if	O
(	O
(	O
s	*(char)
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
dmd	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
dmd	O
->	O
dmd_name	O
=	O
s	*(char)
;	O
dmd	O
->	O
dmd_type	O
=	O
CTF_ERR	O
;	O
dmd	O
->	O
dmd_offset	O
=	O
0	int
;	O
dmd	O
->	O
dmd_value	O
=	O
value	int
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
root	O
,	O
vlen	O
+	O
1	int
)	O
;	O
ctf_list_append	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
,	O
dmd	O
)	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
return	O
0	int
;	O
}	O
int	O
ctf_add_member_offset	(*(struct),long,*(char),long,long)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
souid	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
bit_offset	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
souid	O
)	O
;	O
ctf_dmdef_t	O
*	O
dmd	O
;	O
ssize_t	long
msize	O
,	O
malign	O
,	O
ssize	O
;	O
uint32_t	int
kind	O
,	O
vlen	O
,	O
root	O
;	O
char	O
*	O
s	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_BADID	int
)	O
)	O
;	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
root	O
=	O
LCTF_INFO_ISROOT	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
if	O
(	O
kind	O
!=	O
CTF_K_STRUCT	O
&&	O
kind	O
!=	O
CTF_K_UNION	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTSOU	int
)	O
)	O
;	O
if	O
(	O
vlen	O
==	O
CTF_MAX_VLEN	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DTFULL	int
)	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
{	O
for	O
(	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
if	O
(	O
dmd	O
->	O
dmd_name	O
!=	O
NULL	O
&&	O
strcmp	O
(	O
dmd	O
->	O
dmd_name	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
msize	O
=	O
ctf_type_size	(*(struct),long)->(long)
(	O
fp	*(struct)
,	O
type	long
)	O
)	O
<	O
0	int
||	O
(	O
malign	O
=	O
ctf_type_align	(*(struct),long)->(long)
(	O
fp	*(struct)
,	O
type	long
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
dmd	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_dmdef_t	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
(	O
s	*(char)
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
dmd	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
dmd	O
->	O
dmd_name	O
=	O
s	*(char)
;	O
dmd	O
->	O
dmd_type	O
=	O
type	long
;	O
dmd	O
->	O
dmd_value	O
=	O
-	O
1	int
;	O
if	O
(	O
kind	O
==	O
CTF_K_STRUCT	O
&&	O
vlen	O
!=	O
0	int
)	O
{	O
if	O
(	O
bit_offset	O
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
{	O
ctf_dmdef_t	O
*	O
lmd	O
=	O
ctf_list_prev	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
ctf_id_t	long
ltype	O
=	O
ctf_type_resolve	(*(struct),long)->(long)
(	O
fp	*(struct)
,	O
lmd	O
->	O
dmd_type	O
)	O
;	O
size_t	long
off	O
=	O
lmd	O
->	O
dmd_offset	O
;	O
ctf_encoding_t	struct(int,int,int)
linfo	O
;	O
ssize_t	long
lsize	O
;	O
if	O
(	O
ctf_type_encoding	(*(struct),long,*(struct(int,int,int)))->(int)
(	O
fp	*(struct)
,	O
ltype	O
,	O
&	O
linfo	O
)	O
==	O
0	int
)	O
off	O
+=	O
linfo	O
.	O
cte_bits	int
;	O
else	O
if	O
(	O
(	O
lsize	O
=	O
ctf_type_size	(*(struct),long)->(long)
(	O
fp	*(struct)
,	O
ltype	O
)	O
)	O
>	O
0	int
)	O
off	O
+=	O
lsize	O
*	O
CHAR_BIT	O
;	O
off	O
=	O
roundup	O
(	O
off	O
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
;	O
off	O
=	O
roundup	O
(	O
off	O
,	O
MAX	O
(	O
malign	O
,	O
1	int
)	O
)	O
;	O
dmd	O
->	O
dmd_offset	O
=	O
off	O
*	O
CHAR_BIT	O
;	O
ssize	O
=	O
off	O
+	O
msize	O
;	O
}	O
else	O
{	O
dmd	O
->	O
dmd_offset	O
=	O
bit_offset	O
;	O
ssize	O
=	O
ctf_get_ctt_size	O
(	O
fp	*(struct)
,	O
&	O
dtd	O
->	O
dtd_data	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
ssize	O
=	O
MAX	O
(	O
ssize	O
,	O
(	O
(	O
signed	O
)	O
bit_offset	O
/	O
CHAR_BIT	O
)	O
+	O
msize	O
)	O
;	O
}	O
}	O
else	O
{	O
dmd	O
->	O
dmd_offset	O
=	O
0	int
;	O
ssize	O
=	O
ctf_get_ctt_size	O
(	O
fp	*(struct)
,	O
&	O
dtd	O
->	O
dtd_data	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
ssize	O
=	O
MAX	O
(	O
ssize	O
,	O
msize	O
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
ssize	O
>	O
CTF_MAX_SIZE	O
)	O
{	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
ssize	O
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
ssize	O
)	O
;	O
}	O
else	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
ssize	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
root	O
,	O
vlen	O
+	O
1	int
)	O
;	O
ctf_list_append	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
,	O
dmd	O
)	O
;	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
return	O
0	int
;	O
}	O
int	O
ctf_add_member_encoded	(*(struct),long,*(char),long,long,struct(int,int,int))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
souid	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
bit_offset	O
,	O
const	O
ctf_encoding_t	struct(int,int,int)
encoding	O
)	O
{	O
ctf_dtdef_t	O
*	O
dtd	O
=	O
ctf_dtd_lookup	O
(	O
fp	*(struct)
,	O
type	long
)	O
;	O
int	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
fp	*(struct)
,	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
)	O
;	O
int	O
otype	O
=	O
type	long
;	O
if	O
(	O
(	O
kind	O
!=	O
CTF_K_INTEGER	O
)	O
&&	O
(	O
kind	O
!=	O
CTF_K_FLOAT	O
)	O
&&	O
(	O
kind	O
!=	O
CTF_K_ENUM	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_slice	(*(struct),int,long,*(struct(int,int,int)))->(long)
(	O
fp	*(struct)
,	O
CTF_ADD_NONROOT	O
,	O
otype	O
,	O
&	O
encoding	O
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
-	O
1	int
;	O
return	O
ctf_add_member_offset	(*(struct),long,*(char),long,long)->(int)
(	O
fp	*(struct)
,	O
souid	O
,	O
name	*(char)
,	O
type	long
,	O
bit_offset	O
)	O
;	O
}	O
int	O
ctf_add_member	(*(struct),long,*(char),long)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_id_t	long
souid	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
)	O
{	O
return	O
ctf_add_member_offset	(*(struct),long,*(char),long,long)->(int)
(	O
fp	*(struct)
,	O
souid	O
,	O
name	*(char)
,	O
type	long
,	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
;	O
}	O
int	O
ctf_add_variable	(*(struct),*(char),long)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
ref	O
)	O
{	O
ctf_dvdef_t	O
*	O
dvd	O
;	O
ctf_file_t	struct
*	O
tmp	O
=	O
fp	*(struct)
;	O
if	O
(	O
!	O
(	O
fp	*(struct)
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
ctf_dvd_lookup	O
(	O
fp	*(struct)
,	O
name	*(char)
)	O
!=	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	O
(	O
&	O
tmp	O
,	O
ref	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
ctf_type_resolve	(*(struct),long)->(long)
(	O
fp	*(struct)
,	O
ref	O
)	O
==	O
CTF_ERR	O
)	O
&&	O
(	O
ctf_errno	(*(struct))->(int)
(	O
fp	*(struct)
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
dvd	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_dvdef_t	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
(	O
dvd	O
->	O
dvd_name	O
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
dvd	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
dvd	O
->	O
dvd_type	O
=	O
ref	O
;	O
dvd	O
->	O
dvd_snapshots	O
=	O
fp	*(struct)
->	O
ctf_snapshots	O
;	O
if	O
(	O
ctf_dvd_insert	O
(	O
fp	*(struct)
,	O
dvd	O
)	O
<	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
dvd	O
->	O
dvd_name	O
)	O
;	O
free	(*(void))->(void)
(	O
dvd	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fp	*(struct)
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
enumcmp	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_bundle_t	O
*	O
ctb	O
=	O
arg	*(void)
;	O
int	O
bvalue	O
;	O
if	O
(	O
ctf_enum_value	(*(struct),long,*(char),*(int))->(int)
(	O
ctb	O
->	O
ctb_file	O
,	O
ctb	O
->	O
ctb_type	long
,	O
name	*(char)
,	O
&	O
bvalue	O
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	O
(	O
"Conflict due to member %s iteration error: %s.\n"	*(char)
,	O
name	*(char)
,	O
ctf_errmsg	(int)->(*(char))
(	O
ctf_errno	(*(struct))->(int)
(	O
ctb	O
->	O
ctb_file	O
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
value	int
!=	O
bvalue	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict due to value change: %i versus %i\n"	*(char)
,	O
value	int
,	O
bvalue	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
enumadd	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_bundle_t	O
*	O
ctb	O
=	O
arg	*(void)
;	O
return	O
(	O
ctf_add_enumerator	(*(struct),long,*(char),int)->(int)
(	O
ctb	O
->	O
ctb_file	O
,	O
ctb	O
->	O
ctb_type	long
,	O
name	*(char)
,	O
value	int
)	O
<	O
0	int
)	O
;	O
}	O
static	O
int	O
membcmp	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
_libctf_unused_	O
,	O
unsigned	O
long	O
offset	long
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_bundle_t	O
*	O
ctb	O
=	O
arg	*(void)
;	O
ctf_membinfo_t	struct(long,long)
ctm	O
;	O
if	O
(	O
ctf_member_info	(*(struct),long,*(char),*(struct(long,long)))->(int)
(	O
ctb	O
->	O
ctb_file	O
,	O
ctb	O
->	O
ctb_type	long
,	O
name	*(char)
,	O
&	O
ctm	O
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	O
(	O
"Conflict due to member %s iteration error: %s.\n"	*(char)
,	O
name	*(char)
,	O
ctf_errmsg	(int)->(*(char))
(	O
ctf_errno	(*(struct))->(int)
(	O
ctb	O
->	O
ctb_file	O
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ctm	O
.	O
ctm_offset	short
!=	O
offset	long
)	O
{	O
ctf_dprintf	O
(	O
"Conflict due to member %s offset change: "	*(char)
"%lx versus %lx\n"	*(char)
,	O
name	*(char)
,	O
ctm	O
.	O
ctm_offset	short
,	O
offset	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
membadd	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
offset	long
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_bundle_t	O
*	O
ctb	O
=	O
arg	*(void)
;	O
ctf_dmdef_t	O
*	O
dmd	O
;	O
char	O
*	O
s	*(char)
=	O
NULL	O
;	O
if	O
(	O
(	O
dmd	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ctf_dmdef_t	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
ctb	O
->	O
ctb_file	O
,	O
EAGAIN	O
)	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
(	O
s	*(char)
=	O
strdup	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
dmd	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
ctb	O
->	O
ctb_file	O
,	O
EAGAIN	O
)	O
)	O
;	O
}	O
dmd	O
->	O
dmd_name	O
=	O
s	*(char)
;	O
dmd	O
->	O
dmd_type	O
=	O
type	long
;	O
dmd	O
->	O
dmd_offset	O
=	O
offset	long
;	O
dmd	O
->	O
dmd_value	O
=	O
-	O
1	int
;	O
ctf_list_append	O
(	O
&	O
ctb	O
->	O
ctb_dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
,	O
dmd	O
)	O
;	O
ctb	O
->	O
ctb_file	O
->	O
ctf_flags	O
|=	O
LCTF_DIRTY	O
;	O
return	O
0	int
;	O
}	O
static	O
ctf_id_t	long
ctf_add_type_internal	O
(	O
ctf_file_t	struct
*	O
dst_fp	O
,	O
ctf_file_t	struct
*	O
src_fp	O
,	O
ctf_id_t	long
src_type	O
,	O
ctf_file_t	struct
*	O
proc_tracking_fp	O
)	O
{	O
ctf_id_t	long
dst_type	O
=	O
CTF_ERR	O
;	O
uint32_t	int
dst_kind	O
=	O
CTF_K_UNKNOWN	O
;	O
ctf_file_t	struct
*	O
tmp_fp	O
=	O
dst_fp	O
;	O
ctf_id_t	long
tmp	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
uint32_t	int
kind	O
,	O
forward_kind	O
,	O
flag	int
,	O
vlen	O
;	O
const	O
ctf_type_t	struct(int,int,union(int,int),int,int)
*	O
src_tp	O
,	O
*	O
dst_tp	O
;	O
ctf_bundle_t	O
src	O
,	O
dst	O
;	O
ctf_encoding_t	struct(int,int,int)
src_en	O
,	O
dst_en	O
;	O
ctf_arinfo_t	struct(long,long,int)
src_ar	O
,	O
dst_ar	O
;	O
ctf_funcinfo_t	struct(long,int,int)
ctc	O
;	O
ctf_id_t	long
orig_src_type	O
=	O
src_type	O
;	O
if	O
(	O
!	O
(	O
dst_fp	O
->	O
ctf_flags	O
&	O
LCTF_RDWR	O
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
(	O
src_tp	O
=	O
ctf_lookup_by_id	O
(	O
&	O
src_fp	O
,	O
src_type	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ctf_errno	(*(struct))->(int)
(	O
src_fp	O
)	O
)	O
)	O
;	O
if	O
(	O
(	O
ctf_type_resolve	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
==	O
CTF_ERR	O
)	O
&&	O
(	O
ctf_errno	(*(struct))->(int)
(	O
src_fp	O
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
;	O
name	*(char)
=	O
ctf_strptr	O
(	O
src_fp	O
,	O
src_tp	O
->	O
ctt_name	int
)	O
;	O
kind	O
=	O
LCTF_INFO_KIND	O
(	O
src_fp	O
,	O
src_tp	O
->	O
ctt_info	short
)	O
;	O
flag	int
=	O
LCTF_INFO_ISROOT	O
(	O
src_fp	O
,	O
src_tp	O
->	O
ctt_info	short
)	O
;	O
vlen	O
=	O
LCTF_INFO_VLEN	O
(	O
src_fp	O
,	O
src_tp	O
->	O
ctt_info	short
)	O
;	O
tmp	O
=	O
ctf_type_mapping	O
(	O
src_fp	O
,	O
src_type	O
,	O
&	O
tmp_fp	O
)	O
;	O
if	O
(	O
tmp	O
!=	O
0	int
)	O
{	O
if	O
(	O
ctf_dynhash_lookup	O
(	O
proc_tracking_fp	O
->	O
ctf_add_processing	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
src_type	O
)	O
)	O
return	O
tmp	O
;	O
if	O
(	O
(	O
ctf_type_kind_unsliced	O
(	O
tmp_fp	O
,	O
tmp	O
)	O
==	O
(	O
int	O
)	O
kind	O
)	O
&&	O
(	O
kind	O
==	O
CTF_K_STRUCT	O
||	O
kind	O
==	O
CTF_K_UNION	O
||	O
kind	O
==	O
CTF_K_ENUM	O
)	O
)	O
{	O
if	O
(	O
(	O
dst_tp	O
=	O
ctf_lookup_by_id	O
(	O
&	O
tmp_fp	O
,	O
dst_type	O
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
vlen	O
==	O
LCTF_INFO_VLEN	O
(	O
tmp_fp	O
,	O
dst_tp	O
->	O
ctt_info	short
)	O
)	O
return	O
tmp	O
;	O
}	O
}	O
forward_kind	O
=	O
kind	O
;	O
if	O
(	O
kind	O
==	O
CTF_K_FORWARD	O
)	O
forward_kind	O
=	O
src_tp	O
->	O
ctt_type	short
;	O
if	O
(	O
(	O
flag	int
&	O
CTF_ADD_ROOT	O
)	O
&&	O
name	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
(	O
tmp	O
=	O
ctf_lookup_by_rawname	O
(	O
dst_fp	O
,	O
forward_kind	O
,	O
name	*(char)
)	O
)	O
!=	O
0	int
)	O
{	O
dst_type	O
=	O
tmp	O
;	O
dst_kind	O
=	O
ctf_type_kind_unsliced	O
(	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
}	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
&&	O
dst_kind	O
!=	O
kind	O
)	O
{	O
if	O
(	O
kind	O
==	O
CTF_K_FORWARD	O
&&	O
(	O
dst_kind	O
==	O
CTF_K_ENUM	O
||	O
dst_kind	O
==	O
CTF_K_STRUCT	O
||	O
dst_kind	O
==	O
CTF_K_UNION	O
)	O
)	O
{	O
ctf_add_type_mapping	O
(	O
src_fp	O
,	O
src_type	O
,	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
return	O
dst_type	O
;	O
}	O
if	O
(	O
dst_kind	O
!=	O
CTF_K_FORWARD	O
||	O
(	O
kind	O
!=	O
CTF_K_ENUM	O
&&	O
kind	O
!=	O
CTF_K_STRUCT	O
&&	O
kind	O
!=	O
CTF_K_UNION	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict for type %s: kinds differ, new: %i; "	*(char)
"old (ID %lx): %i\n"	*(char)
,	O
name	*(char)
,	O
kind	O
,	O
dst_type	O
,	O
dst_kind	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
kind	O
==	O
CTF_K_INTEGER	O
||	O
kind	O
==	O
CTF_K_FLOAT	O
||	O
kind	O
==	O
CTF_K_SLICE	O
)	O
{	O
if	O
(	O
ctf_type_encoding	(*(struct),long,*(struct(int,int,int)))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
&	O
src_en	O
)	O
!=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ctf_errno	(*(struct))->(int)
(	O
src_fp	O
)	O
)	O
)	O
;	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
)	O
{	O
ctf_file_t	struct
*	O
fp	*(struct)
=	O
dst_fp	O
;	O
if	O
(	O
(	O
dst_tp	O
=	O
ctf_lookup_by_id	O
(	O
&	O
fp	*(struct)
,	O
dst_type	O
)	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
ctf_type_encoding	(*(struct),long,*(struct(int,int,int)))->(int)
(	O
dst_fp	O
,	O
dst_type	O
,	O
&	O
dst_en	O
)	O
!=	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
LCTF_INFO_ISROOT	O
(	O
fp	*(struct)
,	O
dst_tp	O
->	O
ctt_info	short
)	O
&	O
CTF_ADD_ROOT	O
)	O
{	O
if	O
(	O
memcmp	O
(	O
&	O
src_en	O
,	O
&	O
dst_en	O
,	O
sizeof	O
(	O
ctf_encoding_t	struct(int,int,int)
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
kind	O
!=	O
CTF_K_SLICE	O
)	O
{	O
ctf_add_type_mapping	O
(	O
src_fp	O
,	O
src_type	O
,	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
return	O
dst_type	O
;	O
}	O
}	O
else	O
{	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
memcmp	O
(	O
&	O
src_en	O
,	O
&	O
dst_en	O
,	O
sizeof	O
(	O
ctf_encoding_t	struct(int,int,int)
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
kind	O
!=	O
CTF_K_SLICE	O
)	O
{	O
ctf_add_type_mapping	O
(	O
src_fp	O
,	O
src_type	O
,	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
return	O
dst_type	O
;	O
}	O
}	O
}	O
}	O
}	O
src	O
.	O
ctb_file	O
=	O
src_fp	O
;	O
src	O
.	O
ctb_type	long
=	O
src_type	O
;	O
src	O
.	O
ctb_dtd	O
=	O
NULL	O
;	O
dst	O
.	O
ctb_file	O
=	O
dst_fp	O
;	O
dst	O
.	O
ctb_type	long
=	O
dst_type	O
;	O
dst	O
.	O
ctb_dtd	O
=	O
NULL	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
proc_tracking_fp	O
->	O
ctf_add_processing	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
src_type	O
,	O
(	O
void	O
*	O
)	O
1	int
)	O
<	O
0	int
)	O
return	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ENOMEM	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
CTF_K_INTEGER	O
:	O
dst_type	O
=	O
ctf_add_integer	(*(struct),int,*(char),*(struct(int,int,int)))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
,	O
&	O
src_en	O
)	O
;	O
break	O
;	O
case	O
CTF_K_FLOAT	O
:	O
dst_type	O
=	O
ctf_add_float	(*(struct),int,*(char),*(struct(int,int,int)))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
,	O
&	O
src_en	O
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	O
:	O
src_type	O
=	O
ctf_type_reference	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
;	O
src_type	O
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_type	O
,	O
proc_tracking_fp	O
)	O
;	O
if	O
(	O
src_type	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	O
=	O
ctf_add_slice	(*(struct),int,long,*(struct(int,int,int)))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
src_type	O
,	O
&	O
src_en	O
)	O
;	O
break	O
;	O
case	O
CTF_K_POINTER	O
:	O
case	O
CTF_K_VOLATILE	O
:	O
case	O
CTF_K_CONST	O
:	O
case	O
CTF_K_RESTRICT	O
:	O
src_type	O
=	O
ctf_type_reference	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
;	O
src_type	O
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_type	O
,	O
proc_tracking_fp	O
)	O
;	O
if	O
(	O
src_type	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	O
=	O
ctf_add_reftype	O
(	O
dst_fp	O
,	O
flag	int
,	O
src_type	O
,	O
kind	O
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	O
:	O
if	O
(	O
ctf_array_info	(*(struct),long,*(struct(long,long,int)))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
&	O
src_ar	O
)	O
!=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ctf_errno	(*(struct))->(int)
(	O
src_fp	O
)	O
)	O
)	O
;	O
src_ar	O
.	O
ctr_contents	long
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_ar	O
.	O
ctr_contents	long
,	O
proc_tracking_fp	O
)	O
;	O
src_ar	O
.	O
ctr_index	long
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_ar	O
.	O
ctr_index	long
,	O
proc_tracking_fp	O
)	O
;	O
src_ar	O
.	O
ctr_nelems	int
=	O
src_ar	O
.	O
ctr_nelems	int
;	O
if	O
(	O
src_ar	O
.	O
ctr_contents	long
==	O
CTF_ERR	O
||	O
src_ar	O
.	O
ctr_index	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
)	O
{	O
if	O
(	O
ctf_array_info	(*(struct),long,*(struct(long,long,int)))->(int)
(	O
dst_fp	O
,	O
dst_type	O
,	O
&	O
dst_ar	O
)	O
!=	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
memcmp	O
(	O
&	O
src_ar	O
,	O
&	O
dst_ar	O
,	O
sizeof	O
(	O
ctf_arinfo_t	struct(long,long,int)
)	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict for type %s against ID %lx: "	*(char)
"array info differs, old %lx/%lx/%x; "	*(char)
"new: %lx/%lx/%x\n"	*(char)
,	O
name	*(char)
,	O
dst_type	O
,	O
src_ar	O
.	O
ctr_contents	long
,	O
src_ar	O
.	O
ctr_index	long
,	O
src_ar	O
.	O
ctr_nelems	int
,	O
dst_ar	O
.	O
ctr_contents	long
,	O
dst_ar	O
.	O
ctr_index	long
,	O
dst_ar	O
.	O
ctr_nelems	int
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
dst_type	O
=	O
ctf_add_array	(*(struct),int,*(struct(long,long,int)))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
&	O
src_ar	O
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	O
:	O
ctc	O
.	O
ctc_return	long
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_tp	O
->	O
ctt_type	short
,	O
proc_tracking_fp	O
)	O
;	O
ctc	O
.	O
ctc_argc	int
=	O
0	int
;	O
ctc	O
.	O
ctc_flags	int
=	O
0	int
;	O
if	O
(	O
ctc	O
.	O
ctc_return	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	O
=	O
ctf_add_function	(*(struct),int,*(struct(long,int,int)),*(long))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
&	O
ctc	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
CTF_K_STRUCT	O
:	O
case	O
CTF_K_UNION	O
:	O
{	O
ctf_dmdef_t	O
*	O
dmd	O
;	O
int	O
errs	O
=	O
0	int
;	O
size_t	long
size	long
;	O
ssize_t	long
ssize	O
;	O
ctf_dtdef_t	O
*	O
dtd	O
;	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
&&	O
kind	O
!=	O
CTF_K_FORWARD	O
&&	O
dst_kind	O
!=	O
CTF_K_FORWARD	O
)	O
{	O
if	O
(	O
ctf_type_size	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
!=	O
ctf_type_size	(*(struct),long)->(long)
(	O
dst_fp	O
,	O
dst_type	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict for type %s against ID %lx: "	*(char)
"union size differs, old %li, new %li\n"	*(char)
,	O
name	*(char)
,	O
dst_type	O
,	O
(	O
long	O
)	O
ctf_type_size	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
,	O
(	O
long	O
)	O
ctf_type_size	(*(struct),long)->(long)
(	O
dst_fp	O
,	O
dst_type	O
)	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
if	O
(	O
ctf_member_iter	(*(struct),long,*((*(char),long,long,*(void))->(int)),*(void))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
membcmp	O
,	O
&	O
dst	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict for type %s against ID %lx: "	*(char)
"members differ, see above\n"	*(char)
,	O
name	*(char)
,	O
dst_type	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
break	O
;	O
}	O
dst_type	O
=	O
ctf_add_generic	O
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
,	O
kind	O
,	O
&	O
dtd	O
)	O
;	O
if	O
(	O
dst_type	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst	O
.	O
ctb_type	long
=	O
dst_type	O
;	O
dst	O
.	O
ctb_dtd	O
=	O
dtd	O
;	O
ctf_add_type_mapping	O
(	O
src_fp	O
,	O
src_type	O
,	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
if	O
(	O
ctf_member_iter	(*(struct),long,*((*(char),long,long,*(void))->(int)),*(void))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
membadd	O
,	O
&	O
dst	O
)	O
!=	O
0	int
)	O
errs	O
++	O
;	O
if	O
(	O
(	O
ssize	O
=	O
ctf_type_size	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
)	O
<	O
0	int
)	O
return	O
CTF_ERR	O
;	O
size	long
=	O
(	O
size_t	long
)	O
ssize	O
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	O
)	O
{	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	O
->	O
dtd_data	O
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
dtd	O
->	O
dtd_data	O
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	O
,	O
flag	int
,	O
vlen	O
)	O
;	O
for	O
(	O
dmd	O
=	O
ctf_list_next	O
(	O
&	O
dtd	O
->	O
dtd_u	O
.	O
dtu_members	O
)	O
;	O
dmd	O
!=	O
NULL	O
;	O
dmd	O
=	O
ctf_list_next	O
(	O
dmd	O
)	O
)	O
{	O
ctf_file_t	struct
*	O
dst	O
=	O
dst_fp	O
;	O
ctf_id_t	long
memb_type	O
;	O
memb_type	O
=	O
ctf_type_mapping	O
(	O
src_fp	O
,	O
dmd	O
->	O
dmd_type	O
,	O
&	O
dst	O
)	O
;	O
if	O
(	O
memb_type	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
dmd	O
->	O
dmd_type	O
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
dmd	O
->	O
dmd_type	O
,	O
proc_tracking_fp	O
)	O
)	O
==	O
CTF_ERR	O
)	O
{	O
if	O
(	O
ctf_errno	(*(struct))->(int)
(	O
dst_fp	O
)	O
!=	O
ECTF_NONREPRESENTABLE	int
)	O
errs	O
++	O
;	O
}	O
}	O
else	O
dmd	O
->	O
dmd_type	O
=	O
memb_type	O
;	O
}	O
if	O
(	O
errs	O
)	O
return	O
CTF_ERR	O
;	O
break	O
;	O
}	O
case	O
CTF_K_ENUM	O
:	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
&&	O
kind	O
!=	O
CTF_K_FORWARD	O
&&	O
dst_kind	O
!=	O
CTF_K_FORWARD	O
)	O
{	O
if	O
(	O
ctf_enum_iter	(*(struct),long,*((*(char),int,*(void))->(int)),*(void))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
enumcmp	O
,	O
&	O
dst	O
)	O
||	O
ctf_enum_iter	(*(struct),long,*((*(char),int,*(void))->(int)),*(void))->(int)
(	O
dst_fp	O
,	O
dst_type	O
,	O
enumcmp	O
,	O
&	O
src	O
)	O
)	O
{	O
ctf_dprintf	O
(	O
"Conflict for enum %s against ID %lx: "	*(char)
"members differ, see above\n"	*(char)
,	O
name	*(char)
,	O
dst_type	O
)	O
;	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
{	O
dst_type	O
=	O
ctf_add_enum	(*(struct),int,*(char))->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
dst	O
.	O
ctb_type	long
=	O
dst_type	O
)	O
==	O
CTF_ERR	O
||	O
ctf_enum_iter	(*(struct),long,*((*(char),int,*(void))->(int)),*(void))->(int)
(	O
src_fp	O
,	O
src_type	O
,	O
enumadd	O
,	O
&	O
dst	O
)	O
)	O
return	O
CTF_ERR	O
;	O
}	O
break	O
;	O
case	O
CTF_K_FORWARD	O
:	O
if	O
(	O
dst_type	O
==	O
CTF_ERR	O
)	O
dst_type	O
=	O
ctf_add_forward	(*(struct),int,*(char),int)->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
,	O
forward_kind	O
)	O
;	O
break	O
;	O
case	O
CTF_K_TYPEDEF	O
:	O
src_type	O
=	O
ctf_type_reference	(*(struct),long)->(long)
(	O
src_fp	O
,	O
src_type	O
)	O
;	O
src_type	O
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_type	O
,	O
proc_tracking_fp	O
)	O
;	O
if	O
(	O
src_type	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
dst_type	O
==	O
CTF_ERR	O
)	O
dst_type	O
=	O
ctf_add_typedef	(*(struct),int,*(char),long)->(long)
(	O
dst_fp	O
,	O
flag	int
,	O
name	*(char)
,	O
src_type	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
}	O
if	O
(	O
dst_type	O
!=	O
CTF_ERR	O
)	O
ctf_add_type_mapping	O
(	O
src_fp	O
,	O
orig_src_type	O
,	O
dst_fp	O
,	O
dst_type	O
)	O
;	O
return	O
dst_type	O
;	O
}	O
ctf_id_t	long
ctf_add_type	(*(struct),*(struct),long)->(long)
(	O
ctf_file_t	struct
*	O
dst_fp	O
,	O
ctf_file_t	struct
*	O
src_fp	O
,	O
ctf_id_t	long
src_type	O
)	O
{	O
ctf_id_t	long
id	int
;	O
if	O
(	O
!	O
src_fp	O
->	O
ctf_add_processing	O
)	O
src_fp	O
->	O
ctf_add_processing	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_integer	O
,	O
ctf_hash_eq_integer	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
src_fp	O
->	O
ctf_add_processing	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
dst_fp	O
,	O
ENOMEM	O
)	O
)	O
;	O
id	int
=	O
ctf_add_type_internal	O
(	O
dst_fp	O
,	O
src_fp	O
,	O
src_type	O
,	O
src_fp	O
)	O
;	O
ctf_dynhash_empty	O
(	O
src_fp	O
->	O
ctf_add_processing	O
)	O
;	O
return	O
id	int
;	O
}	O
int	O
ctf_gzwrite	(*(struct),*(struct(int,*(char),long)))->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
gzFile	*(struct)
fd	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
buf	*(void)
;	O
ssize_t	long
resid	O
;	O
ssize_t	long
len	int
;	O
resid	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
buf	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
resid	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
gzwrite	(*(struct),*(void),int)->(int)
(	O
fd	int
,	O
buf	*(void)
,	O
resid	O
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
)	O
;	O
resid	O
-=	O
len	int
;	O
buf	*(void)
+=	O
len	int
;	O
}	O
resid	O
=	O
fp	*(struct)
->	O
ctf_size	O
;	O
buf	*(void)
=	O
fp	*(struct)
->	O
ctf_buf	O
;	O
while	O
(	O
resid	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
gzwrite	(*(struct),*(void),int)->(int)
(	O
fd	int
,	O
buf	*(void)
,	O
resid	O
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
)	O
;	O
resid	O
-=	O
len	int
;	O
buf	*(void)
+=	O
len	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
ctf_compress_write	(*(struct),int)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
fd	int
)	O
{	O
unsigned	O
char	O
*	O
buf	*(void)
;	O
unsigned	O
char	O
*	O
bp	O
;	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
h	O
;	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
=	O
&	O
h	O
;	O
ssize_t	long
header_len	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
ssize_t	long
compress_len	O
;	O
ssize_t	long
len	int
;	O
int	O
rc	O
;	O
int	O
err	long
=	O
0	int
;	O
if	O
(	O
ctf_serialize	O
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
memcpy	O
(	O
hp	O
,	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
,	O
header_len	O
)	O
;	O
hp	O
->	O
cth_flags	O
|=	O
CTF_F_COMPRESS	O
;	O
compress_len	O
=	O
compressBound	(long)->(long)
(	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
if	O
(	O
(	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
compress_len	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_ZALLOC	int
)	O
)	O
;	O
if	O
(	O
(	O
rc	O
=	O
compress	(*(char),*(long),*(char),long)->(int)
(	O
buf	*(void)
,	O
(	O
uLongf	long
*	O
)	O
&	O
compress_len	O
,	O
fp	*(struct)
->	O
ctf_buf	O
,	O
fp	*(struct)
->	O
ctf_size	O
)	O
)	O
!=	O
Z_OK	O
)	O
{	O
ctf_dprintf	O
(	O
"zlib deflate err: %s\n"	*(char)
,	O
zError	(int)->(*(char))
(	O
rc	O
)	O
)	O
;	O
err	long
=	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_COMPRESS	int
)	O
;	O
goto	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
while	O
(	O
header_len	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
hp	O
,	O
header_len	O
)	O
)	O
<	O
0	int
)	O
{	O
err	long
=	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
;	O
goto	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
header_len	O
-=	O
len	int
;	O
hp	O
+=	O
len	int
;	O
}	O
bp	O
=	O
buf	*(void)
;	O
while	O
(	O
compress_len	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
bp	O
,	O
compress_len	O
)	O
)	O
<	O
0	int
)	O
{	O
err	long
=	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
;	O
goto	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
compress_len	O
-=	O
len	int
;	O
bp	O
+=	O
len	int
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
:	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
err	long
;	O
}	O
unsigned	O
char	O
*	O
ctf_write_mem	(*(struct),*(long),long)->(*(char))
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
size_t	long
*	O
size	long
,	O
size_t	long
threshold	long
)	O
{	O
unsigned	O
char	O
*	O
buf	*(void)
;	O
unsigned	O
char	O
*	O
bp	O
;	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
hp	O
;	O
ssize_t	long
header_len	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
ssize_t	long
compress_len	O
;	O
int	O
rc	O
;	O
if	O
(	O
ctf_serialize	O
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
compress_len	O
=	O
compressBound	(long)->(long)
(	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_size	O
<	O
threshold	long
)	O
compress_len	O
=	O
fp	*(struct)
->	O
ctf_size	O
;	O
if	O
(	O
(	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
compress_len	O
+	O
sizeof	O
(	O
struct	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ENOMEM	O
)	O
;	O
return	O
NULL	O
;	O
}	O
hp	O
=	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
*	O
)	O
buf	*(void)
;	O
memcpy	O
(	O
hp	O
,	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
,	O
header_len	O
)	O
;	O
bp	O
=	O
buf	*(void)
+	O
sizeof	O
(	O
struct	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
*	O
size	long
=	O
sizeof	O
(	O
struct	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_size	O
<	O
threshold	long
)	O
{	O
hp	O
->	O
cth_flags	O
&=	O
~	O
CTF_F_COMPRESS	O
;	O
memcpy	O
(	O
bp	O
,	O
fp	*(struct)
->	O
ctf_buf	O
,	O
fp	*(struct)
->	O
ctf_size	O
)	O
;	O
*	O
size	long
+=	O
fp	*(struct)
->	O
ctf_size	O
;	O
}	O
else	O
{	O
hp	O
->	O
cth_flags	O
|=	O
CTF_F_COMPRESS	O
;	O
if	O
(	O
(	O
rc	O
=	O
compress	(*(char),*(long),*(char),long)->(int)
(	O
bp	O
,	O
(	O
uLongf	long
*	O
)	O
&	O
compress_len	O
,	O
fp	*(struct)
->	O
ctf_buf	O
,	O
fp	*(struct)
->	O
ctf_size	O
)	O
)	O
!=	O
Z_OK	O
)	O
{	O
ctf_dprintf	O
(	O
"zlib deflate err: %s\n"	*(char)
,	O
zError	(int)->(*(char))
(	O
rc	O
)	O
)	O
;	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
ECTF_COMPRESS	int
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
size	long
+=	O
compress_len	O
;	O
}	O
return	O
buf	*(void)
;	O
}	O
int	O
ctf_write	(*(struct),int)->(int)
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
int	O
fd	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
buf	*(void)
;	O
ssize_t	long
resid	O
;	O
ssize_t	long
len	int
;	O
if	O
(	O
ctf_serialize	O
(	O
fp	*(struct)
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
resid	O
=	O
sizeof	O
(	O
ctf_header_t	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
buf	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	*(struct)
->	O
ctf_header	struct(struct(short,char,char),int,int,int,int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
resid	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buf	*(void)
,	O
resid	O
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
)	O
;	O
resid	O
-=	O
len	int
;	O
buf	*(void)
+=	O
len	int
;	O
}	O
resid	O
=	O
fp	*(struct)
->	O
ctf_size	O
;	O
buf	*(void)
=	O
fp	*(struct)
->	O
ctf_buf	O
;	O
while	O
(	O
resid	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buf	*(void)
,	O
resid	O
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	O
(	O
fp	*(struct)
,	O
errno	O
)	O
)	O
;	O
resid	O
-=	O
len	int
;	O
buf	*(void)
+=	O
len	int
;	O
}	O
return	O
0	int
;	O
}	O
