const	O
char	O
*	O
argp_program_bug_address	*(char)
=	O
"<"	*(char)
PACKAGE_BUGREPORT	*(char)
">"	*(char)
;	O
static	O
char	O
doc	*(char)
[	O
]	O
=	O
N_	O
(	O
"generate a program flowgraph"	*(char)
)	O
"\v"	*(char)
N_	O
(	O
"* The effect of each option marked with an asterisk is reversed if the option's long name is prefixed with `no-'. For example, --no-cpp cancels --cpp."	*(char)
)	O
;	O
const	O
char	O
*	O
program_authors	array(*(char))
[	O
]	O
=	O
{	O
"Sergey Poznyakoff"	*(char)
,	O
NULL	O
}	O
;	O
enum	O
option_code	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
OPT_DEFINES	int
=	O
256	int
,	O
OPT_LEVEL_INDENT	int
,	O
OPT_DEBUG	int
,	O
OPT_PREPROCESS	int
,	O
OPT_NO_PREPROCESS	int
,	O
OPT_EMACS	int
,	O
OPT_NO_USE_INDENTATION	int
,	O
OPT_NO_ANSI	int
,	O
OPT_NO_TREE	int
,	O
OPT_NO_BRIEF	int
,	O
OPT_NO_EMACS	int
,	O
OPT_NO_MAIN	int
,	O
OPT_NO_VERBOSE	int
,	O
OPT_NO_NUMBER	int
,	O
OPT_NO_PRINT_LEVEL	int
,	O
OPT_NO_REVERSE	int
,	O
OPT_OMIT_ARGUMENTS	int
,	O
OPT_NO_OMIT_ARGUMENTS	int
,	O
OPT_OMIT_SYMBOL_NAMES	int
,	O
OPT_NO_OMIT_SYMBOL_NAMES	int
}	O
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"General options:"	*(char)
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"depth"	*(char)
,	O
'd'	O
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set the depth at which the flowgraph is cut off"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"include"	*(char)
,	O
'i'	O
,	O
N_	O
(	O
"CLASSES"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Include specified classes of symbols (see below). Prepend CLASSES with ^ or - to exclude them from the output"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"format"	*(char)
,	O
'f'	O
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Use given output format NAME. Valid names are `gnu' (default) and `posix'"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"reverse"	*(char)
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print reverse call tree"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"xref"	*(char)
,	O
'x'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Produce cross-reference listing only"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"print"	*(char)
,	O
'P'	O
,	O
N_	O
(	O
"OPT"	*(char)
)	O
,	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"Set printing option to OPT. Valid OPT values are: xref (or cross-ref), tree. Any unambiguous abbreviation of the above is also accepted"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"output"	*(char)
,	O
'o'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set output file name (default -, meaning stdout)"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Symbols classes for --include argument"	*(char)
)	O
,	O
GROUP_ID	int
+	O
2	int
}	O
,	O
{	O
"  x"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"all data symbols, both external and static"	*(char)
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  _"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"symbols whose names begin with an underscore"	*(char)
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  s"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"static symbols"	*(char)
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  t"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"typedefs (for cross-references only)"	*(char)
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Parser control:"	*(char)
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"use-indentation"	*(char)
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Rely on indentation"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-use-indentation"	*(char)
,	O
OPT_NO_USE_INDENTATION	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"ansi"	*(char)
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Accept only sources in ANSI C"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-ansi"	*(char)
,	O
OPT_NO_ANSI	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"pushdown"	*(char)
,	O
'p'	O
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Set initial token stack size to NUMBER"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"symbol"	*(char)
,	O
's'	O
,	O
N_	O
(	O
"SYMBOL:[=]TYPE"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Register SYMBOL with given TYPE, or define an alias (if := is used). Valid types are: keyword (or kw), modifier, qualifier, identifier, type, wrapper. Any unambiguous abbreviation of the above is also accepted"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"main"	*(char)
,	O
'm'	O
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Assume main function to be called NAME"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-main"	*(char)
,	O
OPT_NO_MAIN	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"There's no main function; print graphs for all functions in the program"	*(char)
)	O
}	O
,	O
{	O
"define"	*(char)
,	O
'D'	O
,	O
N_	O
(	O
"NAME[=DEFN]"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Predefine NAME as a macro"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"undefine"	*(char)
,	O
'U'	O
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Cancel any previous definition of NAME"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"include-dir"	*(char)
,	O
'I'	O
,	O
N_	O
(	O
"DIR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"Add the directory DIR to the list of directories to be searched for header files."	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"preprocess"	*(char)
,	O
OPT_PREPROCESS	int
,	O
N_	O
(	O
"COMMAND"	*(char)
)	O
,	O
OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"* Run the specified preprocessor command"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"cpp"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_ALIAS	int
,	O
NULL	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-preprocess"	*(char)
,	O
OPT_NO_PREPROCESS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-cpp"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_ALIAS	int
|	O
OPTION_HIDDEN	int
,	O
NULL	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Output control:"	*(char)
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"all"	*(char)
,	O
'A'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Show all functions, not only those reachable from main"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"number"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print line numbers"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-number"	*(char)
,	O
OPT_NO_NUMBER	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"print-level"	*(char)
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print nesting level along with the call tree"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-print-level"	*(char)
,	O
OPT_NO_PRINT_LEVEL	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"level-indent"	*(char)
,	O
OPT_LEVEL_INDENT	int
,	O
"ELEMENT"	*(char)
,	O
0	int
,	O
N_	O
(	O
"Control graph appearance"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"tree"	*(char)
,	O
'T'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Draw ASCII art tree"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-tree"	*(char)
,	O
OPT_NO_TREE	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"brief"	*(char)
,	O
'b'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Brief output"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-brief"	*(char)
,	O
OPT_NO_BRIEF	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"emacs"	*(char)
,	O
OPT_EMACS	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Additionally format output for use with GNU Emacs"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-emacs"	*(char)
,	O
OPT_NO_EMACS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"omit-arguments"	*(char)
,	O
OPT_OMIT_ARGUMENTS	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Do not print argument lists in function declarations"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-ignore-arguments"	*(char)
,	O
OPT_NO_OMIT_ARGUMENTS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"omit-symbol-names"	*(char)
,	O
OPT_OMIT_SYMBOL_NAMES	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Do not print symbol names in declaration strings"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-omit-symbol-names"	*(char)
,	O
OPT_NO_OMIT_SYMBOL_NAMES	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Informational options:"	*(char)
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Verbose error diagnostics"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-verbose"	*(char)
,	O
OPT_NO_VERBOSE	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	*(char)
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"debug"	*(char)
,	O
OPT_DEBUG	int
,	O
"NUMBER"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"Set debugging level"	*(char)
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
0	int
,	O
}	O
}	O
;	O
struct	O
option_type	struct(*(char),int,int)
{	O
char	O
*	O
str	*(char)
;	O
int	O
min_match	int
;	O
int	O
type	enum(int,int,int)
;	O
}	O
;	O
int	O
debug	int
;	O
char	O
*	O
outname	*(char)
=	O
"-"	*(char)
;	O
int	O
print_option	int
=	O
0	int
;	O
int	O
verbose	int
;	O
int	O
use_indentation	int
;	O
int	O
record_defines	int
;	O
int	O
strict_ansi	int
;	O
int	O
print_line_numbers	int
;	O
int	O
print_levels	int
;	O
int	O
print_as_tree	int
;	O
int	O
brief_listing	int
;	O
int	O
reverse_tree	int
;	O
int	O
max_depth	int
;	O
int	O
emacs_option	int
;	O
int	O
omit_arguments_option	int
;	O
int	O
omit_symbol_names_option	int
;	O
int	O
symbol_map	int
;	O
char	O
*	O
level_indent	array(*(char))
[	O
]	O
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
char	O
*	O
level_end	array(*(char))
[	O
]	O
=	O
{	O
""	*(char)
,	O
""	*(char)
}	O
;	O
char	O
*	O
level_begin	*(char)
=	O
""	*(char)
;	O
int	O
preprocess_option	int
=	O
0	int
;	O
char	O
*	O
start_name	*(char)
=	O
"main"	*(char)
;	O
int	O
all_functions	int
;	O
struct	O
linked_list	struct(*((*(void))->(void)),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(void))))
*	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
;	O
static	O
int	O
find_option_type	(*(struct(*(char),int,int)),*(char),int)->(int)
(	O
struct	O
option_type	struct(*(char),int,int)
*	O
optype	*(struct(*(char),int,int))
,	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
==	O
0	int
)	O
len	int
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
for	O
(	O
;	O
optype	*(struct(*(char),int,int))
->	O
str	*(char)
;	O
optype	*(struct(*(char),int,int))
++	O
)	O
{	O
if	O
(	O
len	int
>=	O
optype	*(struct(*(char),int,int))
->	O
min_match	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
str	*(char)
,	O
optype	*(struct(*(char),int,int))
->	O
str	*(char)
,	O
len	int
)	O
==	O
0	int
)	O
{	O
return	O
optype	*(struct(*(char),int,int))
->	O
type	enum(int,int,int)
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
option_type	struct(*(char),int,int)
symbol_optype	array(struct(*(char),int,int))
[	O
]	O
=	O
{	O
{	O
"keyword"	*(char)
,	O
2	int
,	O
WORD	int
}	O
,	O
{	O
"kw"	*(char)
,	O
2	int
,	O
WORD	int
}	O
,	O
{	O
"modifier"	*(char)
,	O
1	int
,	O
MODIFIER	int
}	O
,	O
{	O
"identifier"	*(char)
,	O
1	int
,	O
IDENTIFIER	int
}	O
,	O
{	O
"type"	*(char)
,	O
1	int
,	O
TYPE	int
}	O
,	O
{	O
"wrapper"	*(char)
,	O
1	int
,	O
PARM_WRAPPER	int
}	O
,	O
{	O
"qualifier"	*(char)
,	O
1	int
,	O
QUALIFIER	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
symbol_override	(*(char))->(void)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
const	O
char	O
*	O
ptr	*(char)
;	O
char	O
*	O
name	*(char)
;	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
ptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
str	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
ptr	*(char)
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"%s: no symbol type supplied"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
else	O
{	O
name	*(char)
=	O
strndup	(*(char),long)->(*(char))
(	O
str	*(char)
,	O
ptr	*(char)
-	O
str	*(char)
)	O
;	O
if	O
(	O
ptr	*(char)
[	O
1	int
]	O
==	O
'='	O
)	O
{	O
Symbol	struct
*	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
lookup	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ptr	*(char)
+	O
2	int
)	O
;	O
if	O
(	O
!	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
{	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
xstrdup	(*(char))->(*(char))
(	O
ptr	*(char)
+	O
2	int
)	O
,	O
INSTALL_OVERWRITE	int
)	O
;	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
=	O
SymToken	int
;	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
token_type	int
=	O
0	int
;	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
=	O
NULL	O
;	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
def_line	int
=	O
-	O
1	int
;	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
}	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
INSTALL_OVERWRITE	int
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
=	O
SymToken	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
alias	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
flag	*(int)
=	O
symbol_alias	int
;	O
}	O
else	O
{	O
int	O
type	enum(int,int,int)
=	O
find_option_type	(*(struct(*(char),int,int)),*(char),int)->(int)
(	O
symbol_optype	array(struct(*(char),int,int))
,	O
ptr	*(char)
+	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
type	enum(int,int,int)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown symbol type: %s"	*(char)
)	O
,	O
ptr	*(char)
+	O
1	int
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
INSTALL_OVERWRITE	int
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
=	O
SymToken	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
token_type	int
=	O
type	enum(int,int,int)
;	O
}	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
=	O
NULL	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
def_line	int
=	O
-	O
1	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
}	O
}	O
static	O
struct	O
option_type	struct(*(char),int,int)
print_optype	array(struct(*(char),int,int))
[	O
]	O
=	O
{	O
{	O
"xref"	*(char)
,	O
1	int
,	O
PRINT_XREF	int
}	O
,	O
{	O
"cross-ref"	*(char)
,	O
1	int
,	O
PRINT_XREF	int
}	O
,	O
{	O
"tree"	*(char)
,	O
1	int
,	O
PRINT_TREE	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
set_print_option	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
int	O
opt	int
;	O
opt	int
=	O
find_option_type	(*(struct(*(char),int,int)),*(char),int)->(int)
(	O
print_optype	array(struct(*(char),int,int))
,	O
str	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
opt	int
==	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown print option: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
;	O
}	O
print_option	int
|=	O
opt	int
;	O
}	O
static	O
int	O
number	(*(*(char)),int,int)->(int)
(	O
const	O
char	O
*	O
*	O
str_ptr	*(*(char))
,	O
int	O
base	int
,	O
int	O
count	long
)	O
{	O
int	O
c	int
,	O
n	long
;	O
unsigned	O
i	long
;	O
const	O
char	O
*	O
str	*(char)
=	O
*	O
str_ptr	*(*(char))
;	O
for	O
(	O
n	long
=	O
0	int
;	O
*	O
str	*(char)
&&	O
count	long
;	O
count	long
--	O
)	O
{	O
c	int
=	O
*	O
str	*(char)
++	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	int
)	O
)	O
i	long
=	O
c	int
-	O
'0'	O
;	O
else	O
i	long
=	O
toupper	(int)->(int)
(	O
c	int
)	O
-	O
'A'	O
+	O
10	int
;	O
if	O
(	O
i	long
>	O
base	int
)	O
{	O
break	O
;	O
}	O
n	long
=	O
n	long
*	O
base	int
+	O
i	long
;	O
}	O
*	O
str_ptr	*(*(char))
=	O
str	*(char)
-	O
1	int
;	O
return	O
n	long
;	O
}	O
static	O
struct	O
option_type	struct(*(char),int,int)
level_indent_optype	array(struct(*(char),int,int))
[	O
]	O
=	O
{	O
{	O
"begin"	*(char)
,	O
1	int
,	O
LEVEL_BEGIN	int
}	O
,	O
{	O
"start"	*(char)
,	O
1	int
,	O
LEVEL_BEGIN	int
}	O
,	O
{	O
"0"	*(char)
,	O
1	int
,	O
LEVEL_INDENT0	int
}	O
,	O
{	O
"1"	*(char)
,	O
1	int
,	O
LEVEL_INDENT1	int
}	O
,	O
{	O
"end0"	*(char)
,	O
4	int
,	O
LEVEL_END0	int
}	O
,	O
{	O
"end1"	*(char)
,	O
4	int
,	O
LEVEL_END1	int
}	O
,	O
}	O
;	O
static	O
void	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
const	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
*	O
return_ptr	*(*(char))
)	O
{	O
static	O
char	O
text	array(char)
[	O
MAXLEVELINDENT	int
]	O
;	O
char	O
*	O
p	*(void)
;	O
int	O
i	long
,	O
c	int
,	O
num	int
;	O
p	*(void)
=	O
text	array(char)
;	O
memset	(*(void),int,long)->(*(void))
(	O
text	array(char)
,	O
' '	O
,	O
sizeof	O
(	O
text	array(char)
)	O
)	O
;	O
text	array(char)
[	O
sizeof	O
(	O
text	array(char)
)	O
-	O
1	int
]	O
=	O
0	int
;	O
while	O
(	O
*	O
str	*(char)
)	O
{	O
switch	O
(	O
*	O
str	*(char)
)	O
{	O
case	O
'\\'	O
:	O
switch	O
(	O
*	O
++	O
str	*(char)
)	O
{	O
case	O
'a'	O
:	O
*	O
p	*(void)
++	O
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
p	*(void)
++	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'e'	O
:	O
*	O
p	*(void)
++	O
=	O
'\033'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
p	*(void)
++	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	*(void)
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	*(void)
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	*(void)
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
++	O
str	*(char)
;	O
*	O
p	*(void)
++	O
=	O
number	(*(*(char)),int,int)->(int)
(	O
&	O
str	*(char)
,	O
16	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
++	O
str	*(char)
;	O
*	O
p	*(void)
++	O
=	O
number	(*(*(char)),int,int)->(int)
(	O
&	O
str	*(char)
,	O
8	int
,	O
3	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
++	O
=	O
*	O
str	*(char)
;	O
}	O
++	O
str	*(char)
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
p	*(void)
==	O
text	array(char)
)	O
{	O
goto	O
copy	O
;	O
}	O
num	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
+	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
&	O
str	*(char)
,	O
10	int
)	O
;	O
c	int
=	O
p	*(void)
[	O
-	O
1	int
]	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
num	int
;	O
i	long
++	O
)	O
{	O
*	O
p	*(void)
++	O
=	O
c	int
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level indent string is too long"	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
copy	O
:	O
*	O
p	*(void)
++	O
=	O
*	O
str	*(char)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level indent string is too long"	*(char)
)	O
)	O
;	O
}	O
}	O
*	O
p	*(void)
=	O
0	int
;	O
*	O
return_ptr	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
text	array(char)
)	O
;	O
}	O
static	O
void	O
set_level_indent	(*(char))->(void)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
long	O
n	long
;	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
q	*(char)
;	O
n	long
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
q	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
==	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
s	long
=	O
xmalloc	(long)->(*(void))
(	O
n	long
+	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
s	long
,	O
' '	O
,	O
n	long
-	O
1	int
)	O
;	O
s	long
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
level_indent	array(*(char))
[	O
0	int
]	O
=	O
level_indent	array(*(char))
[	O
1	int
]	O
=	O
s	long
;	O
return	O
;	O
}	O
p	*(void)
=	O
str	*(char)
;	O
while	O
(	O
*	O
p	*(void)
!=	O
'='	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level-indent syntax"	*(char)
)	O
)	O
;	O
p	*(void)
++	O
;	O
}	O
++	O
p	*(void)
;	O
switch	O
(	O
find_option_type	(*(struct(*(char),int,int)),*(char),int)->(int)
(	O
level_indent_optype	array(struct(*(char),int,int))
,	O
str	*(char)
,	O
p	*(void)
-	O
str	*(char)
-	O
1	int
)	O
)	O
{	O
case	O
LEVEL_BEGIN	int
:	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
p	*(void)
,	O
&	O
level_begin	*(char)
)	O
;	O
break	O
;	O
case	O
LEVEL_INDENT0	int
:	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
p	*(void)
,	O
&	O
level_indent	array(*(char))
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_INDENT1	int
:	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
p	*(void)
,	O
&	O
level_indent	array(*(char))
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_END0	int
:	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
p	*(void)
,	O
&	O
level_end	array(*(char))
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_END1	int
:	O
parse_level_string	(*(char),*(*(char)))->(void)
(	O
p	*(void)
,	O
&	O
level_end	array(*(char))
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown level indent option: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
add_name	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
(	O
void	O
*	O
)	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
add_preproc_option	(int,*(char))->(void)
(	O
int	O
key	int
,	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
opt	int
=	O
xmalloc	(long)->(*(void))
(	O
3	int
+	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
opt	int
,	O
"-%c%s"	*(char)
,	O
key	int
,	O
arg	*(char)
)	O
;	O
add_name	(*(char))->(void)
(	O
opt	int
)	O
;	O
preprocess_option	int
=	O
1	int
;	O
}	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
int	O
num	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
all_functions	int
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
strict_ansi	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_ANSI	int
:	O
strict_ansi	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_DEBUG	int
:	O
debug	int
=	O
arg	*(char)
?	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
:	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
set_print_option	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
use_indentation	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_USE_INDENTATION	int
:	O
use_indentation	int
=	O
0	int
;	O
break	O
;	O
case	O
'T'	O
:	O
print_as_tree	int
=	O
1	int
;	O
set_level_indent	(*(char))->(void)
(	O
"0=  "	*(char)
)	O
;	O
set_level_indent	(*(char))->(void)
(	O
"1=| "	*(char)
)	O
;	O
set_level_indent	(*(char))->(void)
(	O
"end0=+-"	*(char)
)	O
;	O
set_level_indent	(*(char))->(void)
(	O
"end1=\\\\-"	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NO_TREE	int
:	O
print_as_tree	int
=	O
0	int
;	O
level_indent	array(*(char))
[	O
0	int
]	O
=	O
level_indent	array(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
level_end	array(*(char))
[	O
0	int
]	O
=	O
level_end	array(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
'b'	O
:	O
brief_listing	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_BRIEF	int
:	O
brief_listing	int
=	O
0	int
;	O
break	O
;	O
case	O
'd'	O
:	O
max_depth	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
max_depth	int
<	O
0	int
)	O
max_depth	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_DEFINES	int
:	O
record_defines	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_EMACS	int
:	O
emacs_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_EMACS	int
:	O
emacs_option	int
=	O
0	int
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
select_output_driver	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"%s: No such output driver"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
output_init	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
OPT_LEVEL_INDENT	int
:	O
set_level_indent	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
num	int
=	O
1	int
;	O
for	O
(	O
;	O
*	O
arg	*(char)
;	O
arg	*(char)
++	O
)	O
switch	O
(	O
*	O
arg	*(char)
)	O
{	O
case	O
'-'	O
:	O
case	O
'^'	O
:	O
num	int
=	O
0	int
;	O
break	O
;	O
case	O
'+'	O
:	O
num	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'_'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
if	O
(	O
num	int
)	O
SYMBOL_INCLUDE	O
(	O
*	O
arg	*(char)
)	O
;	O
else	O
SYMBOL_EXCLUDE	O
(	O
*	O
arg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"Unknown symbol class: %c"	*(char)
)	O
,	O
*	O
arg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
OPT_OMIT_ARGUMENTS	int
:	O
omit_arguments_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OMIT_ARGUMENTS	int
:	O
omit_arguments_option	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_OMIT_SYMBOL_NAMES	int
:	O
omit_symbol_names_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OMIT_SYMBOL_NAMES	int
:	O
omit_symbol_names_option	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
print_levels	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_PRINT_LEVEL	int
:	O
print_levels	int
=	O
0	int
;	O
break	O
;	O
case	O
'm'	O
:	O
start_name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NO_MAIN	int
:	O
start_name	*(char)
=	O
NULL	O
;	O
break	O
;	O
case	O
'n'	O
:	O
print_line_numbers	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_NUMBER	int
:	O
print_line_numbers	int
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
outname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
num	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
num	int
>	O
0	int
)	O
token_stack_length	int
=	O
num	int
;	O
break	O
;	O
case	O
'r'	O
:	O
reverse_tree	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_REVERSE	int
:	O
reverse_tree	int
=	O
0	int
;	O
break	O
;	O
case	O
's'	O
:	O
symbol_override	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_VERBOSE	int
:	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
print_option	int
=	O
PRINT_XREF	int
;	O
SYMBOL_EXCLUDE	O
(	O
's'	O
)	O
;	O
break	O
;	O
case	O
OPT_PREPROCESS	int
:	O
preprocess_option	int
=	O
1	int
;	O
set_preprocessor	(*(char))->(void)
(	O
arg	*(char)
?	O
arg	*(char)
:	O
CFLOW_PREPROC	*(char)
)	O
;	O
break	O
;	O
case	O
OPT_NO_PREPROCESS	int
:	O
preprocess_option	int
=	O
0	int
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	int
:	O
add_name	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
case	O
'D'	O
:	O
case	O
'U'	O
:	O
add_preproc_option	(int,*(char))->(void)
(	O
key	int
,	O
arg	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
N_	O
(	O
"[FILE]..."	*(char)
)	O
,	O
doc	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
globals_only	()->(int)
(	O
)	O
{	O
return	O
!	O
(	O
symbol_map	int
&	O
SM_STATIC	int
)	O
;	O
}	O
int	O
include_symbol	(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(int)
(	O
Symbol	struct
*	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
{	O
int	O
type	enum(int,int,int)
=	O
0	int
;	O
if	O
(	O
!	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
return	O
0	int
;	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
==	O
SymIdentifier	int
)	O
{	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
name	*(char)
[	O
0	int
]	O
==	O
'_'	O
&&	O
!	O
(	O
symbol_map	int
&	O
SM_UNDERSCORE	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
storage	enum(int,int,int,int,int)
==	O
StaticStorage	int
)	O
type	enum(int,int,int)
|=	O
SM_STATIC	int
;	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
==	O
-	O
1	int
&&	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
storage	enum(int,int,int,int,int)
!=	O
AutoStorage	int
)	O
type	enum(int,int,int)
|=	O
SM_DATA	int
;	O
else	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
>=	O
0	int
)	O
type	enum(int,int,int)
|=	O
SM_FUNCTIONS	int
;	O
if	O
(	O
!	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
)	O
type	enum(int,int,int)
|=	O
SM_UNDEFINED	int
;	O
}	O
else	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
==	O
SymToken	int
)	O
{	O
if	O
(	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
token_type	int
==	O
TYPE	int
&&	O
sym	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
)	O
type	enum(int,int,int)
|=	O
SM_TYPEDEF	int
;	O
else	O
return	O
0	int
;	O
}	O
return	O
(	O
symbol_map	int
&	O
type	enum(int,int,int)
)	O
==	O
type	enum(int,int,int)
;	O
}	O
void	O
xalloc_die	()->(void)
(	O
void	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EX_FATAL	int
,	O
ENOMEM	int
,	O
_	O
(	O
"Exiting"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
void	O
init	()->(void)
(	O
)	O
{	O
if	O
(	O
level_indent	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
level_indent	array(*(char))
[	O
0	int
]	O
=	O
"    "	*(char)
;	O
if	O
(	O
level_indent	array(*(char))
[	O
1	int
]	O
==	O
NULL	O
)	O
level_indent	array(*(char))
[	O
1	int
]	O
=	O
level_indent	array(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
level_end	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
level_end	array(*(char))
[	O
0	int
]	O
=	O
""	*(char)
;	O
if	O
(	O
level_end	array(*(char))
[	O
1	int
]	O
==	O
NULL	O
)	O
level_end	array(*(char))
[	O
1	int
]	O
=	O
""	*(char)
;	O
init_lex	(int)->(void)
(	O
debug	int
>	O
2	int
)	O
;	O
init_parse	()->(void)
(	O
)	O
;	O
}	O
const	O
char	O
version_etc_copyright	array(char)
[	O
]	O
=	O
"Copyright %s 2005-%d Sergey Poznyakoff"	*(char)
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
int	O
status	int
=	O
EX_OK	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
argp_version_setup	(*(char),*(*(char)))->(void)
(	O
"cflow"	*(char)
,	O
program_authors	array(*(char))
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
register_output	(*(char),*((enum(int,int,int,int,int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,*(void),*(void))->(int)),*(void))->(int)
(	O
"gnu"	*(char)
,	O
gnu_output_handler	(enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
register_output	(*(char),*((enum(int,int,int,int,int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,*(void),*(void))->(int)),*(void))->(int)
(	O
"posix"	*(char)
,	O
posix_output_handler	(enum(int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
symbol_map	int
=	O
SM_FUNCTIONS	int
|	O
SM_STATIC	int
|	O
SM_UNDEFINED	int
;	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"POSIXLY_CORRECT"	*(char)
)	O
)	O
{	O
if	O
(	O
select_output_driver	(*(char))->(int)
(	O
"posix"	*(char)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR: %s: No such output driver"	*(char)
)	O
,	O
"posix"	*(char)
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
output_init	()->(void)
(	O
)	O
;	O
}	O
sourcerc	(*(int),*(*(*(char))))->(void)
(	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
ARGP_IN_ORDER	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
)	O
exit	(int)->(void)
(	O
EX_USAGE	int
)	O
;	O
if	O
(	O
print_option	int
==	O
0	int
)	O
print_option	int
=	O
PRINT_TREE	int
;	O
init	()->(void)
(	O
)	O
;	O
if	O
(	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
{	O
struct	O
linked_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void))),*(struct),*(void))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
linked_list_head	O
(	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
;	O
p	*(void)
;	O
)	O
{	O
struct	O
linked_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void))),*(struct),*(void))
*	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
;	O
char	O
*	O
s	long
=	O
(	O
char	O
*	O
)	O
p	*(void)
->	O
data	*(void)
;	O
if	O
(	O
s	long
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
pp_option	(*(char))->(void)
(	O
s	long
)	O
;	O
linked_list_unlink	(*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`)),*(void))))->(void)
(	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
p	*(void)
)	O
;	O
}	O
p	*(void)
=	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
;	O
}	O
for	O
(	O
p	*(void)
=	O
linked_list_head	O
(	O
arglist	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
)	O
{	O
char	O
*	O
s	long
=	O
(	O
char	O
*	O
)	O
p	*(void)
->	O
data	*(void)
;	O
if	O
(	O
source	*(char)
(	O
s	long
)	O
==	O
0	int
)	O
yyparse	()->(int)
(	O
)	O
;	O
}	O
}	O
argc	int
-=	O
index	(*(char),int)->(*(char))
;	O
argv	*(*(char))
+=	O
index	(*(char),int)->(*(char))
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
if	O
(	O
source	*(char)
(	O
*	O
argv	*(*(char))
++	O
)	O
==	O
0	int
)	O
yyparse	()->(int)
(	O
)	O
;	O
else	O
status	int
=	O
EX_SOFT	int
;	O
}	O
if	O
(	O
input_file_count	int
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"no input files"	*(char)
)	O
)	O
;	O
output	()->(void)
(	O
)	O
;	O
return	O
status	int
;	O
}	O
