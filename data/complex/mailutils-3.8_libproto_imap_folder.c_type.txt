static	O
void	O
_mu_imap_folder_destroy	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
if	O
(	O
imap	*(struct)
)	O
{	O
mu_folder_close	(*(struct))->(int)
(	O
folder	*(struct)
)	O
;	O
mu_imap_destroy	(*(*(struct)))->(void)
(	O
&	O
imap	*(struct)
)	O
;	O
folder	*(struct)
->	O
data	*(void)
=	O
imap	*(struct)
;	O
}	O
}	O
static	O
void	O
_mu_folder_preauth_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
_	O
(	O
"IMAP server opened in preauth mode: %s"	*(char)
)	O
,	O
text	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
_mu_folder_bye_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
_	O
(	O
"IMAP server closing connection: %s"	*(char)
)	O
,	O
text	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
_mu_folder_bad_callback	(*(void),int,long,*(void))->(void)
(	O
void	O
*	O
data	*(void)
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	*(void)
)	O
{	O
const	O
char	O
*	O
text	*(char)
=	O
pdat	*(void)
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"IMAP server complains: %s"	*(char)
)	O
,	O
text	*(char)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"This probably indicates a bug in Mailutils client code."	*(char)
)	O
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Please, report that to <%s>."	*(char)
)	O
,	O
PACKAGE_BUGREPORT	*(char)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_open	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
sa	*(struct(short,array(char)))
;	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
hints	*(struct)
;	O
char	O
const	O
*	O
s	*(char)
;	O
int	O
tls	int
;	O
mu_stream_t	*(struct)
transport	*(struct)
;	O
mu_monitor_wrlock	(*(struct(*(void),*(void),int,int)))->(int)
(	O
folder	*(struct)
->	O
monitor	*(struct(*(void),*(void),int,int))
)	O
;	O
rc	int
=	O
mu_imap_session_state	enum(int,int,int,int)
(	O
imap	*(struct)
)	O
;	O
mu_monitor_unlock	(*(struct(*(void),*(void),int,int)))->(int)
(	O
folder	*(struct)
->	O
monitor	*(struct(*(void),*(void),int,int))
)	O
;	O
if	O
(	O
rc	int
!=	O
MU_IMAP_SESSION_INIT	int
)	O
return	O
0	int
;	O
mu_url_sget_scheme	(*(struct),*(*(char)))->(int)
(	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
s	*(char)
)	O
;	O
tls	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"imaps"	*(char)
)	O
==	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
hints	*(struct)
)	O
)	O
;	O
hints	*(struct)
.	O
flags	int
=	O
MU_AH_DETECT_FAMILY	int
;	O
hints	*(struct)
.	O
port	int
=	O
tls	int
?	O
MU_IMAP_DEFAULT_SSL_PORT	int
:	O
MU_IMAP_DEFAULT_PORT	int
;	O
hints	*(struct)
.	O
protocol	int
=	O
IPPROTO_TCP	int
;	O
hints	*(struct)
.	O
socktype	int
=	O
SOCK_STREAM	int
;	O
rc	int
=	O
mu_sockaddr_from_url	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(struct),*(struct(int,int,int,int,short)))->(int)
(	O
&	O
sa	*(struct(short,array(char)))
,	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
hints	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
s	*(char)
=	O
mu_url_to_string	(*(struct))->(*(char))
(	O
folder	*(struct)
->	O
url	*(struct)
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot create sockaddr from URL %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_tcp_stream_create_from_sa	(*(*(struct)),*(struct),*(struct),int)->(int)
(	O
&	O
transport	*(struct)
,	O
sa	*(struct(short,array(char)))
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
s	*(char)
=	O
mu_url_to_string	(*(struct))->(*(char))
(	O
folder	*(struct)
->	O
url	*(struct)
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot create stream from URL %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
mu_sockaddr_free	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(void)
(	O
sa	*(struct(short,array(char)))
)	O
;	O
return	O
rc	int
;	O
}	O
mu_imap_set_carrier	(*(struct),*(struct))->(int)
(	O
imap	*(struct)
,	O
transport	*(struct)
)	O
;	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_PROT	int
)	O
||	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_PROT	int
)	O
)	O
mu_imap_trace	(*(struct),int)->(int)
(	O
imap	*(struct)
,	O
MU_IMAP_TRACE_SET	int
)	O
;	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_TRACE6	int
)	O
||	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE6	int
)	O
)	O
mu_imap_trace_mask	(*(struct),int,int)->(int)
(	O
imap	*(struct)
,	O
MU_IMAP_TRACE_SET	int
,	O
MU_XSCRIPT_SECURE	int
)	O
;	O
if	O
(	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_TRACE7	int
)	O
||	O
mu_debug_level_p	(int,int)->(int)
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE7	int
)	O
)	O
mu_imap_trace_mask	(*(struct),int,int)->(int)
(	O
imap	*(struct)
,	O
MU_IMAP_TRACE_SET	int
,	O
MU_XSCRIPT_PAYLOAD	int
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_PREAUTH	int
,	O
_mu_folder_preauth_callback	(*(void),int,long,*(void))->(void)
,	O
folder	*(struct)
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_BYE	int
,	O
_mu_folder_bye_callback	(*(void),int,long,*(void))->(void)
,	O
folder	*(struct)
)	O
;	O
mu_imap_register_callback_function	(*(struct),int,*((*(void),int,long,*(void))->(void)),*(void))->(void)
(	O
imap	*(struct)
,	O
MU_IMAP_CB_BAD	int
,	O
_mu_folder_bad_callback	(*(void),int,long,*(void))->(void)
,	O
folder	*(struct)
)	O
;	O
rc	int
=	O
mu_imap_connect	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
s	*(char)
=	O
mu_url_to_string	(*(struct))->(*(char))
(	O
folder	*(struct)
->	O
url	*(struct)
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"failed to connect to %s: %s"	*(char)
)	O
,	O
s	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
if	O
(	O
mu_imap_strerror	(*(struct),*(*(char)))->(int)
(	O
imap	*(struct)
,	O
&	O
s	*(char)
)	O
)	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"server response: %s"	*(char)
)	O
,	O
s	*(char)
)	O
)	O
;	O
mu_imap_destroy	(*(*(struct)))->(void)
(	O
&	O
imap	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
mu_imap_session_state	enum(int,int,int,int)
(	O
imap	*(struct)
)	O
==	O
MU_IMAP_SESSION_NONAUTH	int
)	O
{	O
rc	int
=	O
mu_authority_authenticate	(*(struct))->(int)
(	O
folder	*(struct)
->	O
authority	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"IMAP authentication: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
mu_folder_close	(*(struct))->(int)
(	O
folder	*(struct)
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
_mu_imap_folder_close	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
if	O
(	O
mu_imap_session_state	enum(int,int,int,int)
(	O
imap	*(struct)
)	O
>	O
MU_IMAP_SESSION_INIT	int
)	O
{	O
mu_imap_clearerr	(*(struct))->(void)
(	O
imap	*(struct)
)	O
;	O
mu_imap_logout	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
mu_imap_disconnect	(*(struct))->(int)
(	O
imap	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
enumerate_closure	struct(*(struct(*(struct(*(void),*(struct`),*(struct`))),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void))
{	O
mu_folder_t	*(struct)
folder	*(struct)
;	O
mu_folder_enumerate_fp	*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int))
fun	*((*(char),*(void))->(int))
;	O
void	O
*	O
data	*(void)
;	O
}	O
;	O
static	O
int	O
_enumerate_helper	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
=	O
item	*(void)
;	O
struct	O
enumerate_closure	struct(*(struct(*(struct(*(void),*(struct`),*(struct`))),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void))
*	O
clos	*(void)
=	O
data	*(void)
;	O
return	O
clos	*(void)
->	O
fun	*((*(char),*(void))->(int))
(	O
clos	*(void)
->	O
folder	*(struct)
,	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
,	O
clos	*(void)
->	O
data	*(void)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_list	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
struct	O
mu_folder_scanner	struct(*(char),*(void),int,long,*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void),*(struct),*(struct))
*	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
int	O
rc	int
=	O
mu_imap_list_new	(*(struct),*(char),*(char),*(*(struct)))->(int)
(	O
imap	*(struct)
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
refname	*(*(char))
,	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
pattern	*(char)
,	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
max_depth	long
||	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
match_flags	int
&	O
MU_FOLDER_ATTRIBUTE_ALL	O
)	O
!=	O
MU_FOLDER_ATTRIBUTE_ALL	O
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
rc	int
=	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
list	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mu_list_response	struct(int,int,int,*(char),*(struct))
*	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
)	O
;	O
if	O
(	O
!	O
(	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
type	int
&	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
match_flags	int
)	O
||	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
max_depth	long
&&	O
rp	*(struct(int,int,int,*(char),*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int))))))
->	O
depth	int
>	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
max_depth	long
)	O
)	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumfun	*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int))
)	O
{	O
struct	O
enumerate_closure	struct(*(struct(*(struct(*(void),*(struct`),*(struct`))),*(struct),*(struct),*(struct(*(void),*(void),int,int)),*(struct),int,int,long,*(void),*((*(struct`))->(void)),*((*(struct`),int)->(int)),*((*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(char),*(char),*(struct`))->(int)),*((*(char),*(void),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*(*`))->(int)))),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int)),*(void))
clos	*(void)
;	O
clos	*(void)
.	O
folder	*(struct)
=	O
folder	*(struct)
;	O
clos	*(void)
.	O
fun	*((*(char),*(void))->(int))
=	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumfun	*((*(struct),*(struct(int,int,int,*(char),*(struct`))),*(void))->(int))
;	O
clos	*(void)
.	O
data	*(void)
=	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
enumdata	*(void)
;	O
rc	int
=	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
_enumerate_helper	(*(void),*(void))->(int)
,	O
&	O
clos	*(void)
)	O
;	O
}	O
if	O
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
result	*(struct)
)	O
mu_list_append_list	(*(struct),*(struct))->(void)
(	O
scn	*(struct(*(char),*(void),int,long,*((*(struct`),*(struct`),*(void))->(int)),*(void),*(struct),*(struct)))
->	O
result	*(struct)
,	O
list	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_mu_imap_folder_lsub	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
ref	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
flist	*(struct)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
return	O
mu_imap_lsub	(*(struct),*(char),*(char),*(struct))->(int)
(	O
imap	*(struct)
,	O
ref	*(char)
,	O
name	*(char)
,	O
flist	*(struct)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_subscribe	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
return	O
mu_imap_subscribe	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_unsubscribe	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
return	O
mu_imap_unsubscribe	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_delete	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
return	O
mu_imap_delete	(*(struct),*(char))->(int)
(	O
imap	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
_mu_imap_folder_rename	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
const	O
char	O
*	O
oldpath	*(char)
,	O
const	O
char	O
*	O
newpath	*(char)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
return	O
mu_imap_rename	(*(struct),*(char),*(char))->(int)
(	O
imap	*(struct)
,	O
oldpath	*(char)
,	O
newpath	*(char)
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
auth_method_t	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
)	O
(	O
mu_authority_t	*(struct)
)	O
;	O
static	O
int	O
authenticate_imap_login	(*(struct(*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*(struct))))->(int)
(	O
mu_authority_t	*(struct)
auth	*(char)
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
mu_authority_get_owner	(*(struct))->(*(void))
(	O
auth	*(char)
)	O
;	O
mu_imap_t	*(struct)
imap	*(struct)
=	O
folder	*(struct)
->	O
data	*(void)
;	O
mu_ticket_t	*(struct)
ticket	*(struct)
;	O
char	O
*	O
user	*(char)
;	O
int	O
rc	int
;	O
mu_secret_t	*(struct)
secret	*(struct)
;	O
rc	int
=	O
mu_imap_capability_test	(*(struct),*(char),*(*(char)))->(int)
(	O
imap	*(struct)
,	O
"LOGINDISABLED"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"IMAP LOGIN disabled"	*(char)
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
else	O
if	O
(	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot test server capabilities (%s), continuing anyway"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
mu_authority_get_ticket	(*(struct),*(*(struct)))->(int)
(	O
auth	*(char)
,	O
&	O
ticket	*(struct)
)	O
;	O
rc	int
=	O
mu_url_aget_user	(*(struct),*(*(char)))->(int)
(	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
user	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
rc	int
=	O
mu_ticket_get_cred	(*(struct),*(struct),*(char),*(*(char)),*(*(struct)))->(int)
(	O
ticket	*(struct)
,	O
folder	*(struct)
->	O
url	*(struct)
,	O
"Imap User: "	*(char)
,	O
&	O
user	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
||	O
user	*(char)
==	O
NULL	O
)	O
return	O
MU_ERR_NOUSERNAME	O
;	O
else	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_url_get_secret	(*(struct),*(*(struct)))->(int)
(	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
secret	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
rc	int
=	O
mu_ticket_get_cred	(*(struct),*(struct),*(char),*(*(char)),*(*(struct)))->(int)
(	O
ticket	*(struct)
,	O
folder	*(struct)
->	O
url	*(struct)
,	O
"Imap Passwd: "	*(char)
,	O
NULL	O
,	O
&	O
secret	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
||	O
!	O
secret	*(struct)
)	O
{	O
free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
return	O
MU_ERR_NOPASSWORD	O
;	O
}	O
else	O
if	O
(	O
rc	int
)	O
{	O
free	(*(void))->(void)
(	O
user	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_imap_login_secret	(*(struct),*(char),*(struct))->(int)
(	O
imap	*(struct)
,	O
user	*(char)
,	O
secret	*(struct)
)	O
;	O
mu_secret_unref	(*(struct))->(int)
(	O
secret	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
struct	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
{	O
char	O
*	O
name	*(char)
;	O
auth_method_t	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
;	O
}	O
;	O
static	O
struct	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
[	O
]	O
=	O
{	O
{	O
"login"	*(char)
,	O
authenticate_imap_login	(*(struct(*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*(struct))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
auth_method_t	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
find_auth_method	(*(char))->(*((*(struct(*`,*`,*`)))->(int)))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
;	O
p	*(char)
->	O
name	*(char)
;	O
p	*(char)
++	O
)	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(char)
->	O
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
authenticate_imap_select	(*(struct(*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*(struct))))->(int)
(	O
mu_authority_t	*(struct)
auth	*(char)
)	O
{	O
struct	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
*	O
p	*(char)
;	O
int	O
rc	int
=	O
ENOSYS	int
;	O
for	O
(	O
p	*(char)
=	O
auth_tab	struct(*(char),*((*(struct(*(void),*(struct`),*(struct`))))->(int)))
;	O
rc	int
==	O
ENOSYS	int
&&	O
p	*(char)
->	O
name	*(char)
;	O
p	*(char)
++	O
)	O
rc	int
=	O
p	*(char)
->	O
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
(	O
auth	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
folder_set_auth_method	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*((*(struct(*`,*`,*`)))->(int)))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
,	O
auth_method_t	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
)	O
{	O
if	O
(	O
!	O
folder	*(struct)
->	O
authority	*(struct)
)	O
{	O
int	O
rc	int
=	O
mu_authority_create	(*(*(struct)),*(struct),*(void))->(int)
(	O
&	O
folder	*(struct)
->	O
authority	*(struct)
,	O
NULL	O
,	O
folder	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
return	O
mu_authority_set_authenticate	(*(struct),*((*(struct))->(int)),*(void))->(int)
(	O
folder	*(struct)
->	O
authority	*(struct)
,	O
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
,	O
folder	*(struct)
)	O
;	O
}	O
static	O
int	O
_imap_folder_setup_authority	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
!	O
folder	*(struct)
->	O
authority	*(struct)
)	O
{	O
const	O
char	O
*	O
auth	*(char)
;	O
if	O
(	O
folder	*(struct)
->	O
url	*(struct)
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
mu_url_sget_auth	(*(struct),*(*(char)))->(int)
(	O
folder	*(struct)
->	O
url	*(struct)
,	O
&	O
auth	*(char)
)	O
)	O
rc	int
=	O
folder_set_auth_method	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*((*(struct(*`,*`,*`)))->(int)))->(int)
(	O
folder	*(struct)
,	O
authenticate_imap_select	(*(struct(*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*(struct))))->(int)
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
auth	*(char)
,	O
"*"	*(char)
)	O
==	O
0	int
)	O
rc	int
=	O
folder_set_auth_method	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*((*(struct(*`,*`,*`)))->(int)))->(int)
(	O
folder	*(struct)
,	O
authenticate_imap_select	(*(struct(*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*(struct))))->(int)
)	O
;	O
else	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
","	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
auth	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_NOVAR	O
|	O
MU_WRDSF_NOCMD	O
|	O
MU_WRDSF_DELIM	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot split out auth part: %s"	*(char)
)	O
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_FAILURE	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
auth_method_t	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
=	O
find_auth_method	(*(char))->(*((*(struct(*`,*`,*`)))->(int)))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
)	O
rc	int
=	O
folder_set_auth_method	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*((*(struct(*`,*`,*`)))->(int)))->(int)
(	O
folder	*(struct)
,	O
method	*((*(struct(*(void),*(struct`),*(struct`))))->(int))
)	O
;	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_FOLDER	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"unrecognized AUTH scheme %s"	*(char)
)	O
,	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_BAD_AUTH_SCHEME	O
;	O
}	O
}	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
}	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
_mu_imap_folder_init	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
mu_folder_t	*(struct)
folder	*(struct)
)	O
{	O
mu_imap_t	*(struct)
imap	*(struct)
;	O
int	O
rc	int
;	O
rc	int
=	O
_imap_folder_setup_authority	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
folder	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_imap_create	(*(*(struct)))->(int)
(	O
&	O
imap	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
folder	*(struct)
->	O
data	*(void)
=	O
imap	*(struct)
;	O
folder	*(struct)
->	O
_destroy	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void))
=	O
_mu_imap_folder_destroy	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
;	O
folder	*(struct)
->	O
_open	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int))
=	O
_mu_imap_folder_open	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
;	O
folder	*(struct)
->	O
_close	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int))
=	O
_mu_imap_folder_close	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
;	O
folder	*(struct)
->	O
_list	*(struct)
=	O
_mu_imap_folder_list	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(struct(*(char),*(void),int,long,*((*`,*`,*`)->(int)),*(void),*(struct),*(struct))))->(int)
;	O
folder	*(struct)
->	O
_lsub	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int))
=	O
_mu_imap_folder_lsub	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char),*(struct))->(int)
;	O
folder	*(struct)
->	O
_subscribe	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
_mu_imap_folder_subscribe	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
;	O
folder	*(struct)
->	O
_unsubscribe	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
_mu_imap_folder_unsubscribe	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
;	O
folder	*(struct)
->	O
_delete	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int))
=	O
_mu_imap_folder_delete	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char))->(int)
;	O
folder	*(struct)
->	O
_rename	*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int))
=	O
_mu_imap_folder_rename	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))),*(char),*(char))->(int)
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
_mu_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,*(struct`),*(struct`),*(struct`),*(char),int,*(struct`),*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,long,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,long,*`)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,int,long,*`)->(int)),*((*`,*`,*`,int)->(int)),*((*`,*`)->(int)))))->(int)),*((*(struct))->(int)),*((*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)),*(void),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(struct),int)->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(*((*`)->(int))))->(int)),*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(char),int)->(int)))
_imap_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,*`,*`,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
=	O
{	O
MU_IMAP_PRIO	int
,	O
MU_IMAP_SCHEME	*(char)
,	O
MU_RECORD_DEFAULT	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_CRED	O
|	O
MU_URL_INET	O
|	O
MU_URL_PATH	int
|	O
MU_URL_PARAM	int
,	O
MU_URL_HOST	int
,	O
_mu_imap_url_init	(*(struct))->(int)
,	O
_mu_imap_mailbox_init	(*(struct(*(struct),*(struct),*(struct),*(struct),*(struct),int,*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(*`,*`,int,int)),*(struct),*(char),int,*(struct(short,array(char))),*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,long,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,long,*`)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,int,long,*`)->(int)),*((*`,*`,*`,int)->(int)),*((*`,*`)->(int)))))->(int)
,	O
NULL	O
,	O
_mu_imap_folder_init	(*(struct(*(struct(*`,*`,*`)),*(struct),*(struct),*(struct(*`,*`,int,int)),*(struct),int,int,long,*(void),*((*`)->(void)),*((*`,int)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
mu_record_t	*(struct)
mu_imap_record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
=	O
&	O
_imap_record	struct(int,*(char),int,int,int,*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,*`,*`,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*((*(struct))->(int)),*((*(struct(*`,*`,*`,*`,*`,int,int,long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(void),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),int)->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(*((*`)->(int))))->(int)),*((*(struct(int,*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),int)->(int)))
;	O
mu_record_t	*(struct)
mu_imaps_record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
=	O
NULL	O
;	O
