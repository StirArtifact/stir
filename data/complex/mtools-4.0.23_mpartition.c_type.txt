static	O
__inline__	O
void	O
print_hsc	(*(struct(char,char,char,char)))->(void)
(	O
hsc	struct(char,char,char,char)
*	O
h	*(struct(char,char,char,char))
)	O
{	O
printf	(*(char))->(int)
(	O
" h=%d s=%d c=%d\n"	*(char)
,	O
head	int
(	O
*	O
h	*(struct(char,char,char,char))
)	O
,	O
sector	int
(	O
*	O
h	*(struct(char,char,char,char))
)	O
,	O
cyl	char
(	O
*	O
h	*(struct(char,char,char,char))
)	O
)	O
;	O
}	O
static	O
void	O
set_offset	(*(struct(char,char,char,char)),int,int,int)->(void)
(	O
hsc	struct(char,char,char,char)
*	O
h	*(struct(char,char,char,char))
,	O
int	O
offset	long
,	O
int	O
heads	short
,	O
int	O
sectors	short
)	O
{	O
int	O
head	int
,	O
sector	int
,	O
cyl	char
;	O
if	O
(	O
!	O
heads	short
||	O
!	O
sectors	short
)	O
head	int
=	O
sector	int
=	O
cyl	char
=	O
0	int
;	O
else	O
{	O
sector	int
=	O
offset	long
%	O
sectors	short
;	O
offset	long
=	O
offset	long
/	O
sectors	short
;	O
head	int
=	O
offset	long
%	O
heads	short
;	O
cyl	char
=	O
offset	long
/	O
heads	short
;	O
if	O
(	O
cyl	char
>	O
1023	int
)	O
cyl	char
=	O
1023	int
;	O
}	O
h	*(struct(char,char,char,char))
->	O
head	int
=	O
head	int
;	O
h	*(struct(char,char,char,char))
->	O
sector	int
=	O
(	O
(	O
sector	int
+	O
1	int
)	O
&	O
0x3f	int
)	O
|	O
(	O
(	O
cyl	char
&	O
0x300	int
)	O
>>	O
2	int
)	O
;	O
h	*(struct(char,char,char,char))
->	O
cyl	char
=	O
cyl	char
&	O
0xff	int
;	O
}	O
void	O
setBeginEnd	(*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char))),int,int,int,int,int,int,int)->(void)
(	O
struct	O
partition	int
*	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
,	O
unsigned	O
int	O
begin	int
,	O
unsigned	O
int	O
end	*(int)
,	O
unsigned	O
int	O
heads	short
,	O
unsigned	O
int	O
sectors	short
,	O
int	O
activate	int
,	O
int	O
type	enum(int,int,int,int)
,	O
int	O
fat_bits	int
)	O
{	O
set_offset	(*(struct(char,char,char,char)),int,int,int)->(void)
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
start	array(char)
,	O
begin	int
,	O
heads	short
,	O
sectors	short
)	O
;	O
set_offset	(*(struct(char,char,char,char)),int,int,int)->(void)
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
end	*(int)
,	O
end	*(int)
-	O
1	int
,	O
heads	short
,	O
sectors	short
)	O
;	O
set_dword	(*(char),int)->(void)
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
start_sect	array(char)
,	O
begin	int
)	O
;	O
set_dword	(*(char),int)->(void)
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
nr_sects	array(char)
,	O
end	*(int)
-	O
begin	int
)	O
;	O
if	O
(	O
activate	int
)	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
boot_ind	O
=	O
0x80	int
;	O
else	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
boot_ind	O
=	O
0	int
;	O
if	O
(	O
!	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
fat_bits	int
==	O
0	int
)	O
{	O
if	O
(	O
end	*(int)
-	O
begin	int
<	O
4096	int
)	O
fat_bits	int
=	O
12	int
;	O
else	O
fat_bits	int
=	O
16	int
;	O
}	O
if	O
(	O
fat_bits	int
==	O
32	int
)	O
type	enum(int,int,int,int)
=	O
0x0C	int
;	O
else	O
if	O
(	O
end	*(int)
<	O
65536	int
)	O
{	O
if	O
(	O
fat_bits	int
==	O
12	int
)	O
type	enum(int,int,int,int)
=	O
0x01	int
;	O
else	O
if	O
(	O
fat_bits	int
==	O
16	int
)	O
type	enum(int,int,int,int)
=	O
0x04	int
;	O
}	O
else	O
if	O
(	O
end	*(int)
<	O
sectors	short
*	O
heads	short
*	O
1024	int
)	O
type	enum(int,int,int,int)
=	O
0x06	int
;	O
else	O
type	enum(int,int,int,int)
=	O
0x0E	int
;	O
}	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
->	O
sys_ind	O
=	O
type	enum(int,int,int,int)
;	O
}	O
int	O
consistencyCheck	(*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char))),int,int,*(int),*(int),*(int),*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))),int)->(int)
(	O
struct	O
partition	int
*	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
,	O
int	O
doprint	int
,	O
int	O
verbose	int
,	O
int	O
*	O
has_activated	*(int)
,	O
unsigned	O
int	O
*	O
last_end	*(int)
,	O
unsigned	O
int	O
*	O
j	*(int)
,	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
int	O
target_partition	int
)	O
{	O
int	O
i	int
;	O
unsigned	O
int	O
inconsistency	int
;	O
*	O
j	*(int)
=	O
0	int
;	O
*	O
last_end	*(int)
=	O
1	int
;	O
inconsistency	int
=	O
0	int
;	O
*	O
has_activated	*(int)
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
sys_ind	O
)	O
continue	O
;	O
if	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
boot_ind	O
)	O
(	O
*	O
has_activated	*(int)
)	O
++	O
;	O
if	O
(	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
&&	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
heads	short
!=	O
head	int
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
+	O
1	int
||	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
sectors	short
!=	O
sector	int
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
)	O
)	O
||	O
sector	int
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
start	array(char)
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition %d is not aligned\n"	*(char)
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
j	*(int)
&&	O
*	O
last_end	*(int)
>	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partitions %d and %d badly ordered or overlapping\n"	*(char)
,	O
*	O
j	*(int)
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
*	O
last_end	*(int)
=	O
END	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
;	O
*	O
j	*(int)
=	O
i	int
;	O
if	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
&&	O
cyl	char
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
start	array(char)
)	O
!=	O
1023	int
&&	O
tolinear	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
start	array(char)
)	O
!=	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Start position mismatch for partition %d\n"	*(char)
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
&&	O
cyl	char
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
!=	O
1023	int
&&	O
tolinear	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
+	O
1	int
!=	O
END	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"End position mismatch for partition %d\n"	*(char)
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
doprint	int
&&	O
verbose	int
)	O
{	O
if	O
(	O
i	int
==	O
target_partition	int
)	O
putchar	(int)->(int)
(	O
'*'	O
)	O
;	O
else	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
printf	(*(char))->(int)
(	O
"Partition %d\n"	*(char)
,	O
i	int
)	O
;	O
printf	(*(char))->(int)
(	O
"  active=%x\n"	*(char)
,	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
boot_ind	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  start:"	*(char)
)	O
;	O
print_hsc	(*(struct(char,char,char,char)))->(void)
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
start	array(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  type=0x%x\n"	*(char)
,	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
sys_ind	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  end:"	*(char)
)	O
;	O
print_hsc	(*(struct(char,char,char,char)))->(void)
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
;	O
printf	(*(char))->(int)
(	O
"  start=%d\n"	*(char)
,	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  nr=%d\n"	*(char)
,	O
_DWORD	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
nr_sects	array(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
return	O
inconsistency	int
;	O
}	O
static	O
int	O
setsize	(long,*(int),*(short),*(short))->(int)
(	O
unsigned	O
long	O
capacity	long
,	O
unsigned	O
int	O
*	O
cyls	short
,	O
uint16_t	short
*	O
hds	*(short)
,	O
uint16_t	short
*	O
secs	*(short)
)	O
{	O
unsigned	O
int	O
rv	int
=	O
0	int
;	O
unsigned	O
long	O
heads	short
,	O
sectors	short
,	O
cylinders	short
,	O
temp	long
;	O
cylinders	short
=	O
1024L	int
;	O
sectors	short
=	O
62L	int
;	O
temp	long
=	O
cylinders	short
*	O
sectors	short
;	O
heads	short
=	O
capacity	long
/	O
temp	long
;	O
if	O
(	O
capacity	long
%	O
temp	long
)	O
{	O
heads	short
++	O
;	O
temp	long
=	O
cylinders	short
*	O
heads	short
;	O
sectors	short
=	O
capacity	long
/	O
temp	long
;	O
if	O
(	O
capacity	long
%	O
temp	long
)	O
{	O
sectors	short
++	O
;	O
temp	long
=	O
heads	short
*	O
sectors	short
;	O
cylinders	short
=	O
capacity	long
/	O
temp	long
;	O
}	O
}	O
if	O
(	O
cylinders	short
==	O
0	int
)	O
rv	int
=	O
(	O
unsigned	O
)	O
-	O
1	int
;	O
*	O
cyls	short
=	O
(	O
unsigned	O
int	O
)	O
cylinders	short
;	O
*	O
secs	*(short)
=	O
(	O
unsigned	O
int	O
)	O
sectors	short
;	O
*	O
hds	*(short)
=	O
(	O
unsigned	O
int	O
)	O
heads	short
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
static	O
void	O
setsize0	(long,*(int),*(short),*(short))->(void)
(	O
unsigned	O
long	O
capacity	long
,	O
unsigned	O
int	O
*	O
cyls	short
,	O
uint16_t	short
*	O
hds	*(short)
,	O
uint16_t	short
*	O
secs	*(short)
)	O
{	O
int	O
r	int
;	O
if	O
(	O
capacity	long
<	O
1024	int
*	O
2048	int
&&	O
!	O
(	O
capacity	long
%	O
1024	int
)	O
)	O
{	O
*	O
cyls	short
=	O
capacity	long
>>	O
11	int
;	O
*	O
hds	*(short)
=	O
64	int
;	O
*	O
secs	*(short)
=	O
32	int
;	O
return	O
;	O
}	O
r	int
=	O
setsize	(long,*(int),*(short),*(short))->(int)
(	O
capacity	long
,	O
cyls	short
,	O
hds	*(short)
,	O
secs	*(short)
)	O
;	O
if	O
(	O
r	int
||	O
*	O
hds	*(short)
>	O
255	int
||	O
*	O
secs	*(short)
>	O
63	int
)	O
{	O
*	O
cyls	short
=	O
capacity	long
>>	O
11	int
;	O
*	O
hds	*(short)
=	O
64	int
;	O
*	O
secs	*(short)
=	O
32	int
;	O
return	O
;	O
}	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
ret	int
)	O
NORETURN	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
ret	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Mtools version %s, dated %s\n"	*(char)
,	O
mversion	*(char)
,	O
mdate	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage: %s [-pradcv] [-I] [-B bootsect-template] [-s sectors] "	*(char)
"[-t cylinders] "	*(char)
"[-h heads] [-T type] [-b begin] [-l length] "	*(char)
"drive\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
ret	int
)	O
;	O
}	O
void	O
mpartition	(int,*(*(char)),int)->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
dummy	array(long)
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mpartition	(int,*(*(char)),int)->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
dummy	array(long)
UNUSEDP	O
)	O
{	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
;	O
unsigned	O
int	O
dummy2	int
;	O
unsigned	O
int	O
i	int
,	O
j	*(int)
;	O
int	O
sec_per_cyl	int
;	O
int	O
doprint	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
create	int
=	O
0	int
;	O
int	O
force	int
=	O
0	int
;	O
unsigned	O
int	O
length	int
=	O
0	int
;	O
int	O
do_remove	int
=	O
0	int
;	O
int	O
initialize	int
=	O
0	int
;	O
unsigned	O
int	O
tot_sectors	long
=	O
0	int
;	O
int	O
type	enum(int,int,int,int)
=	O
0	int
;	O
int	O
begin_set	int
=	O
0	int
;	O
int	O
size_set	int
=	O
0	int
;	O
int	O
end_set	int
=	O
0	int
;	O
unsigned	O
int	O
last_end	*(int)
=	O
0	int
;	O
int	O
activate	int
=	O
0	int
;	O
int	O
has_activated	*(int)
=	O
0	int
;	O
int	O
inconsistency	int
=	O
0	int
;	O
unsigned	O
int	O
begin	int
=	O
0	int
;	O
unsigned	O
int	O
end	*(int)
=	O
0	int
;	O
int	O
sizetest	int
=	O
0	int
;	O
int	O
dirty	int
=	O
0	int
;	O
int	O
open2flags	int
=	O
NO_OFFSET	int
;	O
int	O
c	char
;	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
int	O
argtracks	int
,	O
argheads	int
,	O
argsectors	int
;	O
char	O
drive	char
,	O
name	*(char)
[	O
EXPAND_BUF	int
]	O
;	O
unsigned	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
struct	O
partition	int
*	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
=	O
(	O
struct	O
partition	int
*	O
)	O
(	O
buf	*(char)
+	O
0x1ae	int
)	O
;	O
struct	O
device	struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
char	O
errmsg	*(char)
[	O
2100	int
]	O
;	O
char	O
*	O
bootSector	*(char)
=	O
0	int
;	O
argtracks	int
=	O
0	int
;	O
argheads	int
=	O
0	int
;	O
argsectors	int
=	O
0	int
;	O
if	O
(	O
helpFlag	(int,*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
)	O
usage	(int)->(void)
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	char
=	O
getopt	(int,*(*(char)),*(char))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"i:adprcIT:t:h:s:fvpb:l:S:B:"	*(char)
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	char
)	O
{	O
case	O
'i'	O
:	O
set_cmd_line_image	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
bootSector	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'a'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
activate	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
activate	int
=	O
-	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
doprint	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
do_remove	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
initialize	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
create	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
type	enum(int,int,int,int)
=	O
strtoi	(*(char),*(*(char)),int)->(int)
(	O
optarg	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
argtracks	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
argheads	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
argsectors	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
force	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'S'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
tot_sectors	long
=	O
strtoui	(*(char),*(*(char)),int)->(int)
(	O
optarg	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
sizetest	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
begin_set	int
=	O
1	int
;	O
begin	int
=	O
strtoui	(*(char),*(*(char)),int)->(int)
(	O
optarg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
size_set	int
=	O
1	int
;	O
length	int
=	O
strtoui	(*(char),*(*(char)),int)->(int)
(	O
optarg	*(char)
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
-	O
optind	int
!=	O
1	int
||	O
!	O
argv	*(*(char))
[	O
optind	int
]	O
[	O
0	int
]	O
||	O
argv	*(*(char))
[	O
optind	int
]	O
[	O
1	int
]	O
!=	O
':'	O
)	O
usage	(int)->(void)
(	O
1	int
)	O
;	O
drive	char
=	O
ch_toupper	(char)->(char)
(	O
argv	*(*(char))
[	O
optind	int
]	O
[	O
0	int
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
errmsg	*(char)
,	O
"Drive '%c:' not supported"	*(char)
,	O
drive	char
)	O
;	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
0	int
;	O
for	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
=	O
devices	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
drive	char
;	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
++	O
)	O
{	O
int	O
mode	int
;	O
FREE	O
(	O
&	O
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
)	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
drive	char
!=	O
drive	char
)	O
continue	O
;	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
<	O
1	int
||	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
>	O
4	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
errmsg	*(char)
,	O
"Drive '%c:' is not a partition"	*(char)
,	O
drive	char
)	O
;	O
continue	O
;	O
}	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
=	O
*	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
;	O
SET_INT	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
tracks	int
,	O
argtracks	int
)	O
;	O
SET_INT	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
,	O
argheads	int
)	O
;	O
SET_INT	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
,	O
argsectors	int
)	O
;	O
expand	(*(char),*(char))->(*(char))
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
mode	int
=	O
dirty	int
?	O
O_RDWR	int
:	O
O_RDONLY	int
;	O
if	O
(	O
initialize	int
)	O
mode	int
|=	O
O_CREAT	int
;	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
SimpleFileOpen	(*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))),*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))),*(char),int,*(char),int,int,*(long))->(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))
(	O
&	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
name	*(char)
,	O
mode	int
,	O
errmsg	*(char)
,	O
open2flags	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
errmsg	*(char)
,	O
sizeof	O
(	O
errmsg	*(char)
)	O
-	O
1	int
,	O
"init: open: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
sizetest	int
)	O
tot_sectors	long
=	O
0	int
;	O
if	O
(	O
IS_SCSI	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
{	O
unsigned	O
char	O
cmd	array(char)
[	O
10	int
]	O
;	O
unsigned	O
char	O
data	*(char)
[	O
10	int
]	O
;	O
cmd	array(char)
[	O
0	int
]	O
=	O
SCSI_READ_CAPACITY	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
void	O
*	O
)	O
&	O
cmd	array(char)
[	O
2	int
]	O
,	O
0	int
,	O
8	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
void	O
*	O
)	O
&	O
data	*(char)
[	O
0	int
]	O
,	O
137	int
,	O
10	int
)	O
;	O
scsi_cmd	(int,array(char),int,enum(int,int),*(void),long,*(void))->(int)
(	O
get_fd	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(int)
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
,	O
cmd	array(char)
,	O
10	int
,	O
SCSI_IO_READ	int
,	O
data	*(char)
,	O
10	int
,	O
get_extra_data	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(*(void))
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
)	O
;	O
tot_sectors	long
=	O
1	int
+	O
(	O
data	*(char)
[	O
0	int
]	O
<<	O
24	int
)	O
+	O
(	O
data	*(char)
[	O
1	int
]	O
<<	O
16	int
)	O
+	O
(	O
data	*(char)
[	O
2	int
]	O
<<	O
8	int
)	O
+	O
(	O
data	*(char)
[	O
3	int
]	O
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"%d sectors in total\n"	*(char)
,	O
tot_sectors	long
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
==	O
0	int
)	O
{	O
ioctl	(int,long)->(int)
(	O
get_fd	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(int)
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
,	O
BLKGETSIZE	O
,	O
&	O
tot_sectors	long
)	O
;	O
}	O
if	O
(	O
READS	O
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
0	int
,	O
512	int
)	O
!=	O
512	int
&&	O
!	O
initialize	int
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
errmsg	*(char)
,	O
sizeof	O
(	O
errmsg	*(char)
)	O
-	O
1	int
,	O
"Error reading from '%s', wrong parameters?"	*(char)
,	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
>=	O
2	int
)	O
print_sector	(*(char),*(char),int)->(void)
(	O
"Read sector"	*(char)
,	O
buf	*(char)
,	O
512	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
drive	char
==	O
0	int
)	O
{	O
FREE	O
(	O
&	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
errmsg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
||	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
)	O
&&	O
(	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
||	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"You should either indicate both the number of sectors and the number of heads,\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" or none of them\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
initialize	int
)	O
{	O
if	O
(	O
bootSector	*(char)
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
bootSector	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
|	O
O_LARGEFILE	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"open MBR"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
512	int
)	O
<	O
512	int
)	O
{	O
perror	(*(char))->(void)
(	O
"read MBR"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
+	O
1	int
)	O
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
*	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
)	O
)	O
;	O
set_word	(*(char),short)->(void)
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(char)
)	O
+	O
510	int
,	O
0xaa55	int
)	O
;	O
}	O
if	O
(	O
(	O
buf	*(char)
[	O
510	int
]	O
!=	O
0x55	int
)	O
||	O
(	O
buf	*(char)
[	O
511	int
]	O
!=	O
0xaa	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Boot signature not set\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Use the -I flag to initialize the partition table, and set the boot signature\n"	*(char)
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
do_remove	int
)	O
{	O
if	O
(	O
!	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition for drive %c: does not exist\n"	*(char)
,	O
drive	char
)	O
;	O
if	O
(	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
sys_ind	O
&	O
0x3f	int
)	O
==	O
5	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition for drive %c: may be an extended partition\n"	*(char)
,	O
drive	char
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Use the -f flag to remove it anyways\n"	*(char)
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
)	O
)	O
;	O
}	O
if	O
(	O
create	int
&&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition for drive %c: already exists\n"	*(char)
,	O
drive	char
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Use the -r flag to remove it before attempting to recreate it\n"	*(char)
)	O
;	O
}	O
has_activated	*(int)
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
sys_ind	O
)	O
continue	O
;	O
if	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
boot_ind	O
)	O
has_activated	*(int)
++	O
;	O
if	O
(	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
)	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
=	O
head	int
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
+	O
1	int
;	O
if	O
(	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
)	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
=	O
sector	int
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
.	O
end	*(int)
)	O
;	O
if	O
(	O
i	int
<	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
&&	O
!	O
begin_set	int
)	O
begin	int
=	O
END	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
i	int
>	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
&&	O
!	O
end_set	int
&&	O
!	O
size_set	int
)	O
{	O
end	*(int)
=	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
i	int
]	O
)	O
;	O
end_set	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
&&	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
)	O
{	O
if	O
(	O
!	O
IS_SCSI	O
(	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
)	O
)	O
{	O
struct	O
hd_geometry	struct(char,char,short,long)
geom	struct(char,char,short,long)
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
get_fd	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(int)
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
,	O
HDIO_GETGEO	int
,	O
&	O
geom	struct(char,char,short,long)
)	O
==	O
0	int
)	O
{	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
=	O
geom	struct(char,char,short,long)
.	O
heads	short
;	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
=	O
geom	struct(char,char,short,long)
.	O
sectors	short
;	O
}	O
}	O
}	O
if	O
(	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
&&	O
!	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
)	O
{	O
if	O
(	O
tot_sectors	long
)	O
setsize0	(long,*(int),*(short),*(short))->(void)
(	O
tot_sectors	long
,	O
&	O
dummy2	int
,	O
&	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
,	O
&	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
)	O
;	O
else	O
{	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
=	O
64	int
;	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
=	O
32	int
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"sectors: %d heads: %d %d\n"	*(char)
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
,	O
tot_sectors	long
)	O
;	O
sec_per_cyl	int
=	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
*	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
;	O
if	O
(	O
create	int
)	O
{	O
if	O
(	O
!	O
end_set	int
&&	O
tot_sectors	long
)	O
{	O
end	*(int)
=	O
tot_sectors	long
-	O
tot_sectors	long
%	O
sec_per_cyl	int
;	O
end_set	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
begin	int
&&	O
!	O
begin_set	int
)	O
begin	int
=	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
;	O
if	O
(	O
!	O
size_set	int
&&	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
tracks	int
)	O
{	O
size_set	int
=	O
2	int
;	O
length	int
=	O
sec_per_cyl	int
*	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
tracks	int
;	O
if	O
(	O
begin_set	int
||	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
<=	O
2	int
||	O
!	O
end_set	int
)	O
length	int
-=	O
begin	int
%	O
sec_per_cyl	int
;	O
else	O
if	O
(	O
end	*(int)
-	O
length	int
<	O
begin	int
)	O
length	int
=	O
end	*(int)
-	O
begin	int
;	O
}	O
if	O
(	O
size_set	int
)	O
{	O
if	O
(	O
!	O
begin_set	int
&&	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
>	O
2	int
&&	O
end_set	int
)	O
begin	int
=	O
end	*(int)
-	O
length	int
;	O
else	O
end	*(int)
=	O
begin	int
+	O
length	int
;	O
}	O
else	O
if	O
(	O
!	O
end_set	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown size\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
setBeginEnd	(*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char))),int,int,int,int,int,int,int)->(void)
(	O
&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
,	O
begin	int
,	O
end	*(int)
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
,	O
!	O
has_activated	*(int)
,	O
type	enum(int,int,int,int)
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
fat_bits	int
)	O
;	O
}	O
if	O
(	O
activate	int
)	O
{	O
if	O
(	O
!	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition for drive %c: does not exist\n"	*(char)
,	O
drive	char
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
activate	int
)	O
{	O
case	O
1	int
:	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
boot_ind	O
=	O
0x80	int
;	O
break	O
;	O
case	O
-	O
1	int
:	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
boot_ind	O
=	O
0x00	int
;	O
break	O
;	O
}	O
}	O
}	O
inconsistency	int
|=	O
consistencyCheck	(*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char))),int,int,*(int),*(int),*(int),*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char))),int)->(int)
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
,	O
doprint	int
,	O
verbose	int
,	O
&	O
has_activated	*(int)
,	O
&	O
last_end	*(int)
,	O
&	O
j	*(int)
,	O
&	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
,	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
)	O
;	O
if	O
(	O
doprint	int
&&	O
!	O
inconsistency	int
&&	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
printf	(*(char))->(int)
(	O
"The following command will recreate the partition for drive %c:\n"	*(char)
,	O
drive	char
)	O
;	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
tracks	int
=	O
(	O
_DWORD	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
.	O
nr_sects	array(char)
)	O
+	O
(	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
)	O
%	O
sec_per_cyl	int
)	O
)	O
/	O
sec_per_cyl	int
;	O
printf	(*(char))->(int)
(	O
"mpartition -c -t %d -h %d -s %d -b %u %c:\n"	*(char)
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
tracks	int
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
heads	short
,	O
used_dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
.	O
sectors	short
,	O
BEGIN	O
(	O
partTable	*(struct(struct(char,char,char,char),struct(char,char,char,char),array(char),array(char)))
[	O
dev	*(struct(*(char),char,int,int,int,short,short,int,long,int,int,char,int,*(char),int,int,int,*(char)))
->	O
partition	int
]	O
)	O
,	O
drive	char
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
&&	O
last_end	*(int)
>	O
tot_sectors	long
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Partition %d exceeds beyond end of disk\n"	*(char)
,	O
j	*(int)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
has_activated	*(int)
)	O
{	O
case	O
0	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: no active (bootable) partition present\n"	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: %d active (bootable) partitions present\n"	*(char)
,	O
has_activated	*(int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usually, a disk should have exactly one active partition\n"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
inconsistency	int
&&	O
!	O
force	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"inconsistency detected!\n"	*(char)
)	O
;	O
if	O
(	O
dirty	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Retry with the -f switch to go ahead anyways\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dirty	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
2	int
)	O
print_sector	(*(char),*(char),int)->(void)
(	O
"Writing sector"	*(char)
,	O
buf	*(char)
,	O
512	int
)	O
;	O
if	O
(	O
WRITES	O
(	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
0	int
,	O
512	int
)	O
!=	O
512	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Error writing partition table"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
verbose	int
>=	O
3	int
)	O
print_sector	(*(char),*(char),int)->(void)
(	O
"Sector written"	*(char)
,	O
buf	*(char)
,	O
512	int
)	O
;	O
}	O
FREE	O
(	O
&	O
Stream	*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
