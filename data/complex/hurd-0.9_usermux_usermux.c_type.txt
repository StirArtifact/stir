const	O
char	O
*	O
argp_program_version	*(char)
=	O
STANDARD_HURD_VERSION	()->(int)
(	O
usermux	struct(*(struct),int,*(char),long,*(char),*(char),*(char),struct,int)
)	O
;	O
char	O
*	O
netfs_server_name	*(char)
=	O
"usermux"	*(char)
;	O
char	O
*	O
netfs_server_version	*(char)
=	O
HURD_VERSION	O
;	O
int	O
netfs_maxsymlinks	int
=	O
25	int
;	O
volatile	O
struct	O
mapped_time_value	O
*	O
usermux_mapped_time	*(struct)
;	O
static	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"user-pattern"	*(char)
,	O
OPT_USER_PAT	int
,	O
"PAT"	*(char)
,	O
0	int
,	O
"The string to replace in the translator specification with the user name"	*(char)
" (default `${user}')"	*(char)
}	O
,	O
{	O
"home-pattern"	*(char)
,	O
OPT_HOME_PAT	int
,	O
"PAT"	*(char)
,	O
0	int
,	O
"The string to replace in the translator specification with the user's"	*(char)
" home directory (default `${home}')"	*(char)
}	O
,	O
{	O
"uid-pattern"	*(char)
,	O
OPT_UID_PAT	int
,	O
"PAT"	*(char)
,	O
0	int
,	O
"The string to replace in the translator specification with the uid"	*(char)
" (default `${uid}')"	*(char)
}	O
,	O
{	O
"clear-patterns"	*(char)
,	O
'C'	O
,	O
0	int
,	O
0	int
,	O
"Reset all patterns to empty; this option may then be followed by options"	*(char)
" to set specific patterns"	*(char)
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
args_doc	*(char)
[	O
]	O
=	O
"[TRANSLATOR [ARG...]]"	*(char)
;	O
static	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"A translator for invoking user-specific translators."	*(char)
"\vThis translator appears like a directory in which user names can be"	*(char)
" looked up, and will start TRANSLATOR to service each resulting node."	*(char)
"  If no pattern occurs in the translator specification, the users's"	*(char)
" home directory is appended to it instead; TRANSLATOR defaults to"	*(char)
" "	*(char)
_HURD_SYMLINK	O
"."	*(char)
;	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
error_t	int
err	int
;	O
struct	O
stat	O
ul_stat	struct
;	O
mach_port_t	O
bootstrap	O
;	O
struct	O
usermux	struct(*(struct),int,*(char),long,*(char),*(char),*(char),struct,int)
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
=	O
{	O
user_pat	*(char)
:	O
"${user}"	*(char)
,	O
home_pat	*(char)
:	O
"${home}"	*(char)
,	O
uid_pat	*(char)
:	O
"${uid}"	*(char)
}	O
;	O
struct	O
netnode	struct(*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*(char),*(struct`),*(struct`))))),*(char),long)
root_nn	struct(*(struct(*(struct(*`,*`,*`)),int,*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*`,*`,*`)))),*(char),long)
=	O
{	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
:	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
}	O
;	O
error_t	int
parse_opt	O
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void)))
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
OPT_USER_PAT	int
:	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
user_pat	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
OPT_HOME_PAT	int
:	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
home_pat	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
OPT_UID_PAT	int
:	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
uid_pat	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'C'	O
:	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
,	O
0	int
,	O
sizeof	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_NO_ARGS	int
:	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
,	O
0	int
,	O
sizeof	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
)	O
;	O
return	O
argz_create_sep	(*(char),int,*(*(char)),*(long))->(int)
(	O
_HURD_SYMLINK	O
,	O
0	int
,	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
trans_template	*(char)
,	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
trans_template_len	long
)	O
;	O
case	O
ARGP_KEY_ARGS	int
:	O
return	O
argz_create	(array(*(char)),*(*(char)),*(long))->(int)
(	O
state	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void)))
->	O
argv	*(*(char))
+	O
state	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void)))
->	O
next	int
,	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
trans_template	*(char)
,	O
&	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
trans_template_len	long
)	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	O
,	O
args_doc	*(char)
,	O
doc	*(char)
}	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
netfs_init	()->(int)
(	O
)	O
;	O
netfs_root_node	O
=	O
netfs_make_node	()->(int)
(	O
&	O
root_nn	struct(*(struct(*(struct(*`,*`,*`)),int,*(char),long,*(char),*(char),*(char),struct,int)),*(struct(*(char),*(struct),*(struct(*`,*`,*`)))),*(char),long)
)	O
;	O
if	O
(	O
!	O
netfs_root_node	O
)	O
error	(int,int,*(char))->(void)
(	O
5	int
,	O
ENOMEM	int
,	O
"Cannot create root node"	*(char)
)	O
;	O
err	int
=	O
maptime_map	()->(int)
(	O
0	int
,	O
0	int
,	O
&	O
usermux_maptime	*(struct)
)	O
;	O
if	O
(	O
err	int
)	O
error	(int,int,*(char))->(void)
(	O
6	int
,	O
err	int
,	O
"Cannot map time"	*(char)
)	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
underlying	int
=	O
netfs_startup	()->(int)
(	O
bootstrap	O
,	O
0	int
)	O
;	O
err	int
=	O
io_stat	()->(int)
(	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
underlying	int
,	O
&	O
ul_stat	struct
)	O
;	O
if	O
(	O
err	int
)	O
error	(int,int,*(char))->(void)
(	O
7	int
,	O
err	int
,	O
"Cannot stat underlying node"	*(char)
)	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_uid	O
=	O
ul_stat	struct
.	O
st_uid	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_gid	O
=	O
ul_stat	struct
.	O
st_gid	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_author	O
=	O
ul_stat	struct
.	O
st_author	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_nlink	O
=	O
1	int
;	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_fstype	O
=	O
FSTYPE_MISC	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
trans_template	*(char)
,	O
_HURD_SYMLINK	O
)	O
==	O
0	int
)	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_mode	O
=	O
S_IFLNK	O
|	O
0666	int
;	O
else	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
.	O
st_mode	O
=	O
S_IFREG	O
|	O
S_IPTRANS	O
|	O
0666	int
;	O
netfs_root_node	O
->	O
nn_stat	O
=	O
mux	*(struct(*(struct(*(char),*(struct`),*(struct`))),int,*(char),long,*(char),*(char),*(char),struct,int))
.	O
stat_template	struct
;	O
netfs_root_node	O
->	O
nn_stat	O
.	O
st_ino	O
=	O
2	int
;	O
netfs_root_node	O
->	O
nn_stat	O
.	O
st_mode	O
=	O
S_IFDIR	O
|	O
(	O
ul_stat	struct
.	O
st_mode	O
&	O
~	O
S_IFMT	O
&	O
~	O
S_ITRANS	O
)	O
;	O
netfs_root_node	O
->	O
nn_translated	O
=	O
0	int
;	O
fshelp_touch	()->(int)
(	O
&	O
netfs_root_node	O
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
|	O
TOUCH_MTIME	O
|	O
TOUCH_CTIME	O
,	O
usermux_maptime	*(struct)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
netfs_server_loop	()->(int)
(	O
)	O
;	O
}	O
