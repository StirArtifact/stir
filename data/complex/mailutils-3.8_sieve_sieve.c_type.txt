int	O
keep_going	int
;	O
int	O
compile_only	int
;	O
char	O
*	O
mbox_url	*(char)
;	O
int	O
sieve_debug	int
;	O
int	O
verbose	int
;	O
char	O
*	O
script	*(char)
;	O
int	O
expression_option	int
;	O
int	O
dry_run	int
;	O
static	O
int	O
sieve_print_locus	int
=	O
1	int
;	O
static	O
int	O
no_program_name	int
;	O
static	O
mu_list_t	*(struct)
env_list	*(struct)
;	O
static	O
mu_list_t	*(struct)
var_list	*(struct)
;	O
static	O
int	O
sieve_setenv	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
str	*(char)
=	O
item	*(void)
;	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
=	O
data	*(void)
;	O
int	O
rc	int
=	O
mu_sieve_set_environ	(*(struct),*(char),*(char))->(int)
(	O
mach	*(struct)
,	O
str	*(char)
,	O
str	*(char)
+	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"can't set environment item %s: %s"	*(char)
)	O
,	O
str	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_setvar	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
str	*(char)
=	O
item	*(void)
;	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
=	O
data	*(void)
;	O
mu_sieve_variable_initialize	(*(struct),*(char),*(char))->(int)
(	O
mach	*(struct)
,	O
str	*(char)
,	O
str	*(char)
+	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
modify_debug_flags	(int,int)->(void)
(	O
mu_debug_level_t	int
set	*(struct)
,	O
mu_debug_level_t	int
clr	int
)	O
{	O
mu_debug_level_t	int
lev	int
;	O
mu_debug_get_category_level	(int,*(int))->(int)
(	O
mu_sieve_debug_handle	int
,	O
&	O
lev	int
)	O
;	O
mu_debug_set_category_level	(int,int)->(int)
(	O
mu_sieve_debug_handle	int
,	O
(	O
lev	int
&	O
~	O
clr	int
)	O
|	O
set	*(struct)
)	O
;	O
}	O
static	O
void	O
set_debug_level	(*(char))->(void)
(	O
const	O
char	O
*	O
arg	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
arg	*(char)
;	O
arg	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
arg	*(char)
)	O
{	O
case	O
'T'	O
:	O
modify_debug_flags	(int,int)->(void)
(	O
MU_DEBUG_LEVEL_UPTO	O
(	O
MU_DEBUG_TRACE9	int
)	O
,	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_ERROR	int
)	O
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
modify_debug_flags	(int,int)->(void)
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_PROT	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
modify_debug_flags	(int,int)->(void)
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE1	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
modify_debug_flags	(int,int)->(void)
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE4	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
modify_debug_flags	(int,int)->(void)
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE9	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%c is not a valid debug flag"	*(char)
)	O
,	O
*	O
arg	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
void	O
cli_compile_and_dump	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
compile_only	int
=	O
2	int
;	O
}	O
static	O
void	O
cli_debug	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
set_debug_level	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
static	O
void	O
cli_email	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
int	O
rc	int
=	O
mu_set_user_email	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"invalid email: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
static	O
void	O
assign	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char),*(*(struct)),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
,	O
mu_list_t	*(struct)
*	O
plist	*(*(struct))
,	O
char	O
const	O
*	O
what	*(char)
)	O
{	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
arg	*(char)
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"malformed %s: %s"	*(char)
)	O
,	O
what	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
{	O
char	O
*	O
str	*(char)
;	O
str	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
str	*(char)
[	O
p	*(char)
-	O
arg	*(char)
]	O
=	O
0	int
;	O
if	O
(	O
!	O
*	O
plist	*(*(struct))
)	O
{	O
mu_list_create	(*(*(struct)))->(int)
(	O
plist	*(*(struct))
)	O
;	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
*	O
plist	*(*(struct))
,	O
mu_list_free_item	(*(void))->(void)
)	O
;	O
}	O
mu_list_append	(*(struct),*(void))->(int)
(	O
*	O
plist	*(*(struct))
,	O
str	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
cli_env	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
assign	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char),*(*(struct)),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
arg	*(char)
,	O
&	O
env_list	*(struct)
,	O
_	O
(	O
"environment setting"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
cli_var	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
assign	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char),*(*(struct)),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
arg	*(char)
,	O
&	O
var_list	*(struct)
,	O
_	O
(	O
"variable assignment"	*(char)
)	O
)	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
sieve_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"dry-run"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not execute any actions, just print what would be done"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
dry_run	int
}	O
,	O
{	O
"no-actions"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
{	O
"keep-going"	*(char)
,	O
'k'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"keep on going if execution fails on a message"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
keep_going	int
}	O
,	O
{	O
"compile-only"	*(char)
,	O
'c'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"compile script and exit"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
compile_only	int
}	O
,	O
{	O
"dump"	*(char)
,	O
'D'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"compile script, dump disassembled sieve code to terminal and exit"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_compile_and_dump	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"mbox-url"	*(char)
,	O
'f'	O
,	O
N_	O
(	O
"MBOX"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"mailbox to sieve (defaults to user's mail spool)"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
mbox_url	*(char)
}	O
,	O
{	O
"ticket"	*(char)
,	O
't'	O
,	O
N_	O
(	O
"TICKET"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"ticket file for user authentication"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
mu_ticket_file	*(char)
}	O
,	O
{	O
"debug"	*(char)
,	O
'd'	O
,	O
N_	O
(	O
"FLAGS"	*(char)
)	O
,	O
MU_OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"debug flags (defaults to \""	*(char)
D_DEFAULT	*(char)
"\")"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_debug	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
,	O
D_DEFAULT	*(char)
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"log all actions"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
verbose	int
}	O
,	O
{	O
"line-info"	*(char)
,	O
0	int
,	O
N_	O
(	O
"BOOL"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"print source location along with action logs (default)"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
sieve_print_locus	int
}	O
,	O
{	O
"email"	*(char)
,	O
'e'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"override user email address"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_email	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"expression"	*(char)
,	O
'E'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"treat SCRIPT as Sieve program text"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
expression_option	int
}	O
,	O
{	O
"no-program-name"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not prefix diagnostic messages with the program name"	*(char)
)	O
,	O
mu_c_int	int
,	O
&	O
no_program_name	int
}	O
,	O
{	O
"environment"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NAME=VALUE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set sieve environment value"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_env	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"variable"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NAME=VALUE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set sieve variable"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_var	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
[	O
]	O
=	O
{	O
sieve_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
NULL	O
}	O
;	O
int	O
mu_compat_printer	(*(void),int,*(char))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_log_level_t	int
level	int
,	O
const	O
char	O
*	O
buf	*(char)
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_debug	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	*(char)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
set_debug_level	(*(char))->(void)
(	O
val	*(char)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_email	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	*(char)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	*(char)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_user_email	(*(char))->(int)
(	O
val	*(char)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid email: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
sieve_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"keep-going"	*(char)
,	O
mu_c_bool	int
,	O
&	O
keep_going	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Do not abort if execution fails on a message."	*(char)
)	O
}	O
,	O
{	O
"mbox-url"	*(char)
,	O
mu_c_string	int
,	O
&	O
mbox_url	*(char)
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Mailbox to sieve (defaults to user's mail spool)."	*(char)
)	O
,	O
N_	O
(	O
"url"	*(char)
)	O
}	O
,	O
{	O
"ticket"	*(char)
,	O
mu_c_string	int
,	O
&	O
mu_ticket_file	*(char)
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Ticket file for user authentication."	*(char)
)	O
,	O
N_	O
(	O
"ticket"	*(char)
)	O
}	O
,	O
{	O
"debug"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_debug	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Debug flags.  Argument consists of one or more of the following "	*(char)
"flags:\n"	*(char)
"   g - main parser traces\n"	*(char)
"   T - mailutils traces (sieve.trace9)\n"	*(char)
"   P - network protocols (sieve.prot)\n"	*(char)
"   t - sieve trace (MU_SIEVE_DEBUG_TRACE)\n"	*(char)
"   i - sieve instructions trace (MU_SIEVE_DEBUG_INSTR)."	*(char)
)	O
,	O
N_	O
(	O
"arg: string"	*(char)
)	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
mu_c_bool	int
,	O
&	O
verbose	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Log all executed actions."	*(char)
)	O
}	O
,	O
{	O
"line-info"	*(char)
,	O
mu_c_bool	int
,	O
&	O
sieve_print_locus	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Print source locations along with action logs (default)."	*(char)
)	O
}	O
,	O
{	O
"email"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_email	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set user email address."	*(char)
)	O
,	O
N_	O
(	O
"arg: string"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
sieve_capa	array(*(char))
[	O
]	O
=	O
{	O
"debug"	*(char)
,	O
"mailbox"	*(char)
,	O
"locking"	*(char)
,	O
"logging"	*(char)
,	O
"mailer"	*(char)
,	O
"sieve"	*(char)
,	O
NULL	O
}	O
;	O
static	O
struct	O
mu_cli_setup	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
=	O
{	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
,	O
sieve_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
N_	O
(	O
"GNU sieve -- a mail filtering tool."	*(char)
)	O
,	O
"SCRIPT"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"Sieve-specific debug levels:\n\n  trace1  -  print parse tree before optimization\n  trace2  -  print parse tree after optimization\n  trace3  -  print parser traces\n  trace4  -  print tests and actions being executed\n  trace9  -  print each Sieve instruction being executed\n\nCompatibility debug flags:\n  g - main parser traces\n  T - mailutils traces (same as --debug-level=sieve.trace0-trace1)\n  P - network protocols (same as --debug-level=sieve.=prot)\n  t - sieve trace (same as --debug-level=sieve.=trace4)\n  i - sieve instructions trace (same as --debug-level=sieve.=trace9)\n"	*(char)
)	O
}	O
;	O
static	O
void	O
_sieve_action_log	(*(struct),*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
const	O
char	O
*	O
action	*((*(char),*(void),*(void))->(int))
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
size_t	long
uid	int
=	O
0	int
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
mu_sieve_get_diag_stream	(*(struct),*(*(struct)))->(void)
(	O
mach	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
msg	*(struct)
=	O
mu_sieve_get_message	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
mu_message_get_uid	(*(struct),*(long))->(int)
(	O
msg	*(struct)
,	O
&	O
uid	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"\033s<%d>\033%c<%d>"	*(char)
,	O
MU_LOG_NOTICE	int
,	O
sieve_print_locus	int
?	O
'O'	O
:	O
'X'	O
,	O
MU_LOGMODE_LOCUS	int
)	O
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
_	O
(	O
"%s on msg uid %lu"	*(char)
)	O
,	O
action	*((*(char),*(void),*(void))->(int))
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
if	O
(	O
fmt	*(char)
&&	O
strlen	(*(char))->(long)
(	O
fmt	*(char)
)	O
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
": "	*(char)
)	O
;	O
mu_stream_vprintf	(*(struct),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stream	*(struct)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
stream	*(struct)
,	O
"\n"	*(char)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
stream	*(struct)
)	O
;	O
}	O
static	O
int	O
sieve_message	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
instr	*(struct)
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
rc	int
=	O
mu_stdio_stream_create	(*(*(struct)),int,int)->(int)
(	O
&	O
instr	*(struct)
,	O
MU_STDIN_FD	int
,	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
rc	int
=	O
mu_stream_to_message	(*(struct),*(*(struct)))->(int)
(	O
instr	*(struct)
,	O
&	O
msg	*(struct)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
instr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot create message from stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_unset_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
rc	int
=	O
mu_sieve_message	(*(struct),*(struct))->(int)
(	O
mach	*(struct)
,	O
msg	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
EX_SOFTWARE	int
;	O
return	O
mu_attribute_is_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
?	O
1	int
:	O
EX_OK	int
;	O
}	O
static	O
int	O
sieve_mailbox	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
int	O
rc	int
;	O
mu_mailbox_t	*(struct)
mbox	*(struct)
=	O
NULL	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_create_default	(*(*(struct)),*(char))->(int)
(	O
&	O
mbox	*(struct)
,	O
mbox_url	*(char)
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	*(struct)
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"could not create mailbox `%s': %s"	*(char)
)	O
,	O
mbox_url	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"could not create default mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
rc	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
MU_STREAM_READ	int
)	O
;	O
else	O
rc	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	*(struct)
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open mailbox %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot open default mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
goto	O
cleanup	O
;	O
}	O
rc	int
=	O
mu_sieve_mailbox	(*(struct),*(struct))->(int)
(	O
mach	*(struct)
,	O
mbox	*(struct)
)	O
;	O
cleanup	O
:	O
if	O
(	O
mbox	*(struct)
&&	O
!	O
dry_run	int
)	O
{	O
int	O
e	*(void)
;	O
if	O
(	O
(	O
e	*(void)
=	O
mu_mailbox_expunge	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	*(struct)
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expunge on mailbox `%s' failed: %s"	*(char)
)	O
,	O
mbox_url	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
e	*(void)
)	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expunge on default mailbox failed: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
e	*(void)
)	O
)	O
;	O
}	O
if	O
(	O
e	*(void)
&&	O
!	O
rc	int
)	O
rc	int
=	O
e	*(void)
;	O
}	O
mu_sieve_machine_destroy	(*(*(struct)))->(void)
(	O
&	O
mach	*(struct)
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
return	O
rc	int
?	O
EX_SOFTWARE	int
:	O
EX_OK	int
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
;	O
int	O
rc	int
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_auth_register_module	(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_auth_tls_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
mu_cli_capa_register	(*(struct(*(char),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_cli_capa_sieve	struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
mu_sieve_debug_init	()->(void)
(	O
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mu_cli	(int,*(*(char)),*(struct(*(*(struct`)),*(struct(*`,int,*`,long,*`,*`,*`)),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*`)->(void)))),*(*(char)),*(void),*(int),*(*(*(char))))->(void)
(	O
argc	long
,	O
argv	*(*(char))
,	O
&	O
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
,	O
sieve_capa	array(*(char))
,	O
NULL	O
,	O
&	O
argc	long
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
dry_run	int
)	O
verbose	int
++	O
;	O
if	O
(	O
no_program_name	int
)	O
{	O
mu_stream_t	*(struct)
errstr	*(struct)
;	O
mu_log_tag	*(char)
=	O
NULL	O
;	O
rc	int
=	O
mu_stdstream_strerr_create	(*(*(struct)),int,int,int,*(char),*(char))->(int)
(	O
&	O
errstr	*(struct)
,	O
MU_STRERR_STDERR	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_strerr	*(struct)
)	O
;	O
mu_strerr	*(struct)
=	O
errstr	*(struct)
;	O
}	O
}	O
if	O
(	O
argc	long
==	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"script must be specified"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EX_USAGE	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	long
==	O
1	int
)	O
{	O
if	O
(	O
expression_option	int
)	O
script	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
mu_stream_t	*(struct)
mstr	*(struct)
;	O
mu_off_t	long
size	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_memory_stream_create	(*(*(struct)),int)->(int)
(	O
&	O
mstr	*(struct)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_memory_stream_create"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
mstr	*(struct)
,	O
mu_strin	*(struct)
,	O
0	int
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_copy"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
mstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
script	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
size	long
+	O
1	int
)	O
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
mstr	*(struct)
,	O
script	*(char)
,	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_read"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
script	*(char)
[	O
size	long
]	O
=	O
0	int
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
mstr	*(struct)
)	O
;	O
expression_option	int
=	O
1	int
;	O
}	O
else	O
script	*(char)
=	O
mu_tilde_expansion	(*(char),int,*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"only one SCRIPT can be specified"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EX_USAGE	int
)	O
;	O
}	O
rc	int
=	O
mu_sieve_machine_create	(*(*(struct)))->(int)
(	O
&	O
mach	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot initialize sieve machine: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
mu_sieve_set_environ	(*(struct),*(char),*(char))->(int)
(	O
mach	*(struct)
,	O
"location"	*(char)
,	O
"MS"	*(char)
)	O
;	O
mu_sieve_set_environ	(*(struct),*(char),*(char))->(int)
(	O
mach	*(struct)
,	O
"phase"	*(char)
,	O
"post"	*(char)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
env_list	*(struct)
,	O
sieve_setenv	(*(void),*(void))->(int)
,	O
mach	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
env_list	*(struct)
)	O
;	O
if	O
(	O
var_list	*(struct)
)	O
{	O
mu_sieve_require_variables	(*(struct))->(int)
(	O
mach	*(struct)
)	O
;	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
var_list	*(struct)
,	O
sieve_setvar	(*(void),*(void))->(int)
,	O
mach	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
var_list	*(struct)
)	O
;	O
}	O
if	O
(	O
verbose	int
)	O
mu_sieve_set_logger	(*(struct),*((*(struct),*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)))->(void)
(	O
mach	*(struct)
,	O
_sieve_action_log	(*(struct),*(char),*(char),array(struct(int,int,*(void),*(void))))->(void)
)	O
;	O
if	O
(	O
expression_option	int
)	O
{	O
struct	O
mu_locus_point	struct(*(char),int,int)
pt	*(struct(*(char),int,int))
;	O
pt	*(struct(*(char),int,int))
.	O
mu_file	*(char)
=	O
"stdin"	*(char)
;	O
pt	*(struct(*(char),int,int))
.	O
mu_line	int
=	O
1	int
;	O
pt	*(struct(*(char),int,int))
.	O
mu_col	int
=	O
0	int
;	O
rc	int
=	O
mu_sieve_compile_text	(*(struct),*(char),long,*(struct(*(char),int,int)))->(int)
(	O
mach	*(struct)
,	O
script	*(char)
,	O
strlen	(*(char))->(long)
(	O
script	*(char)
)	O
,	O
&	O
pt	*(struct(*(char),int,int))
)	O
;	O
}	O
else	O
rc	int
=	O
mu_sieve_compile	(*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
script	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
EX_CONFIG	int
;	O
if	O
(	O
compile_only	int
)	O
{	O
if	O
(	O
compile_only	int
==	O
2	int
)	O
{	O
mu_sieve_set_dbg_stream	(*(struct),*(struct))->(void)
(	O
mach	*(struct)
,	O
mu_strout	*(struct)
)	O
;	O
mu_sieve_disass	(*(struct))->(int)
(	O
mach	*(struct)
)	O
;	O
}	O
return	O
EX_OK	int
;	O
}	O
mu_sieve_set_dry_run	(*(struct),int)->(int)
(	O
mach	*(struct)
,	O
dry_run	int
)	O
;	O
if	O
(	O
mbox_url	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
mbox_url	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
rc	int
=	O
sieve_message	(*(struct))->(int)
(	O
mach	*(struct)
)	O
;	O
else	O
rc	int
=	O
sieve_mailbox	(*(struct))->(int)
(	O
mach	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
