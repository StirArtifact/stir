static	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
static	O
int	O
p_says_nonexistent	array(int)
[	O
2	int
]	O
;	O
static	O
int	O
p_rfc934_nesting	int
;	O
static	O
char	O
*	O
p_name	array(*(char))
[	O
3	int
]	O
;	O
static	O
char	O
const	O
*	O
invalid_names	array(*(char))
[	O
2	int
]	O
;	O
bool	bool
p_copy	array(bool)
[	O
2	int
]	O
;	O
bool	bool
p_rename	array(bool)
[	O
2	int
]	O
;	O
static	O
char	O
*	O
p_timestr	array(*(char))
[	O
2	int
]	O
;	O
static	O
char	O
*	O
p_sha1	array(*(char))
[	O
2	int
]	O
;	O
static	O
mode_t	int
p_mode	array(int)
[	O
2	int
]	O
;	O
static	O
off_t	long
p_filesize	long
;	O
static	O
lin	long
p_first	long
;	O
static	O
lin	long
p_newfirst	long
;	O
static	O
lin	long
p_ptrn_lines	long
;	O
static	O
lin	long
p_repl_lines	long
;	O
static	O
lin	long
p_end	long
=	O
-	O
1	int
;	O
static	O
lin	long
p_max	long
;	O
static	O
lin	long
p_prefix_context	long
;	O
static	O
lin	long
p_suffix_context	long
;	O
static	O
lin	long
p_input_line	long
;	O
static	O
char	O
*	O
*	O
p_line	*(*(char))
;	O
static	O
size_t	long
*	O
p_len	*(long)
;	O
static	O
char	O
*	O
p_Char	*(char)
;	O
static	O
lin	long
hunkmax	long
=	O
INITHUNKMAX	int
;	O
static	O
size_t	long
p_indent	long
;	O
static	O
bool	bool
p_strip_trailing_cr	bool
;	O
static	O
bool	bool
p_pass_comments_through	bool
;	O
static	O
file_offset	long
p_base	long
;	O
static	O
lin	long
p_bline	long
;	O
static	O
file_offset	long
p_start	long
;	O
static	O
lin	long
p_sline	long
;	O
static	O
lin	long
p_hunk_beg	long
;	O
static	O
lin	long
p_efake	long
=	O
-	O
1	int
;	O
static	O
lin	long
p_bfake	long
=	O
-	O
1	int
;	O
static	O
char	O
*	O
p_c_function	*(char)
;	O
static	O
bool	bool
p_git_diff	bool
;	O
static	O
char	O
*	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
char	O
*	O
,	O
lin	long
*	O
)	O
;	O
static	O
enum	O
diff	enum(int,int,int,int,int,int,int)
intuit_diff_type	(bool,*(int))->(enum(int,int,int,int,int,int,int))
(	O
bool	bool
,	O
mode_t	int
*	O
)	O
;	O
static	O
enum	O
nametype	enum(int,int,int,int)
best_name	(*(*(char)),*(int))->(enum(int,int,int,int))
(	O
char	O
*	O
const	O
*	O
,	O
int	O
const	O
*	O
)	O
;	O
static	O
int	O
prefix_components	(*(char),bool)->(int)
(	O
char	O
*	O
,	O
bool	bool
)	O
;	O
static	O
size_t	long
pget_line	(long,int,bool,bool)->(long)
(	O
size_t	long
,	O
int	O
,	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
size_t	long
get_line	()->(long)
(	O
void	O
)	O
;	O
static	O
bool	bool
incomplete_line	()->(bool)
(	O
void	O
)	O
;	O
static	O
bool	bool
grow_hunkmax	()->(bool)
(	O
void	O
)	O
;	O
static	O
void	O
malformed	()->(void)
(	O
void	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
next_intuit_at	(long,long)->(void)
(	O
file_offset	long
,	O
lin	long
)	O
;	O
static	O
void	O
skip_to	(long,long)->(void)
(	O
file_offset	long
,	O
lin	long
)	O
;	O
static	O
char	O
get_ed_command_letter	(*(char))->(char)
(	O
char	O
const	O
*	O
)	O
;	O
void	O
re_patch	()->(void)
(	O
void	O
)	O
{	O
p_first	long
=	O
0	int
;	O
p_newfirst	long
=	O
0	int
;	O
p_ptrn_lines	long
=	O
0	int
;	O
p_repl_lines	long
=	O
0	int
;	O
p_end	long
=	O
-	O
1	int
;	O
p_max	long
=	O
0	int
;	O
p_indent	long
=	O
0	int
;	O
p_strip_trailing_cr	bool
=	O
false	int
;	O
}	O
void	O
open_patch_file	(*(char))->(void)
(	O
char	O
const	O
*	O
filename	*(char)
)	O
{	O
file_offset	long
file_pos	long
=	O
0	int
;	O
file_offset	long
pos	long
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
if	O
(	O
!	O
filename	*(char)
||	O
!	O
*	O
filename	*(char)
||	O
strEQ	O
(	O
filename	*(char)
,	O
"-"	*(char)
)	O
)	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
binary_transput	int
?	O
"rb"	*(char)
:	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Can't open patch file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
filename	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
pfatal	(*(char))->(void)
(	O
"fstat"	*(char)
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_mode	int
)	O
&&	O
(	O
pos	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
-	O
1	int
)	O
file_pos	long
=	O
pos	long
;	O
else	O
{	O
size_t	long
charsread	long
;	O
int	O
fd	int
=	O
make_tempfile	(*(*(char)),char,*(char),int,int)->(int)
(	O
&	O
TMPPATNAME	*(char)
,	O
'p'	O
,	O
NULL	O
,	O
O_RDWR	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
FILE	struct
*	O
read_pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
TMPPATNAME_needs_removal	int
=	O
1	int
;	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"w+b"	*(char)
)	O
;	O
if	O
(	O
!	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Can't open stream for file %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
TMPPATNAME	*(char)
)	O
)	O
;	O
for	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_size	long
=	O
0	int
;	O
(	O
charsread	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
bufsize	long
,	O
read_pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
0	int
;	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_size	long
+=	O
charsread	long
)	O
if	O
(	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
charsread	long
,	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
charsread	long
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
read_pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
read_pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
read_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
||	O
file_seek	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
file_offset	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
}	O
p_filesize	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_size	long
;	O
if	O
(	O
p_filesize	long
!=	O
(	O
file_offset	long
)	O
p_filesize	long
)	O
fatal	(*(char))->(void)
(	O
"patch file is too long"	*(char)
)	O
;	O
next_intuit_at	(long,long)->(void)
(	O
file_pos	long
,	O
1	int
)	O
;	O
set_hunkmax	()->(void)
(	O
)	O
;	O
}	O
void	O
set_hunkmax	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
p_line	*(*(char))
)	O
p_line	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
malloc	(long)->(*(void))
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_line	*(*(char))
)	O
;	O
if	O
(	O
!	O
p_len	*(long)
)	O
p_len	*(long)
=	O
(	O
size_t	long
*	O
)	O
malloc	(long)->(*(void))
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_len	*(long)
)	O
;	O
if	O
(	O
!	O
p_Char	*(char)
)	O
p_Char	*(char)
=	O
malloc	(long)->(*(void))
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_Char	*(char)
)	O
;	O
}	O
static	O
bool	bool
grow_hunkmax	()->(bool)
(	O
void	O
)	O
{	O
hunkmax	long
*=	O
2	int
;	O
assert	O
(	O
p_line	*(*(char))
&&	O
p_len	*(long)
&&	O
p_Char	*(char)
)	O
;	O
if	O
(	O
(	O
p_line	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
p_line	*(*(char))
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_line	*(*(char))
)	O
)	O
)	O
&&	O
(	O
p_len	*(long)
=	O
(	O
size_t	long
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
p_len	*(long)
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_len	*(long)
)	O
)	O
)	O
&&	O
(	O
p_Char	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
p_Char	*(char)
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_Char	*(char)
)	O
)	O
)	O
)	O
return	O
true	int
;	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
return	O
false	int
;	O
}	O
static	O
bool	bool
maybe_reverse	(*(char),bool,bool)->(bool)
(	O
char	O
const	O
*	O
name	*(char)
,	O
bool	bool
nonexistent	bool
,	O
bool	bool
is_empty	bool
)	O
{	O
bool	bool
looks_reversed	bool
=	O
(	O
!	O
is_empty	bool
)	O
<	O
p_says_nonexistent	array(int)
[	O
reverse	bool
^	O
is_empty	bool
]	O
;	O
if	O
(	O
is_empty	bool
&&	O
p_says_nonexistent	array(int)
[	O
reverse	bool
^	O
nonexistent	bool
]	O
==	O
1	int
&&	O
p_says_nonexistent	array(int)
[	O
!	O
reverse	bool
^	O
nonexistent	bool
]	O
==	O
2	int
)	O
return	O
false	int
;	O
if	O
(	O
looks_reversed	bool
)	O
reverse	bool
^=	O
ok_to_reverse	(*(char))->(bool)
(	O
"The next patch%s would %s the file %s,\nwhich %s!"	*(char)
,	O
reverse	bool
?	O
", when reversed,"	*(char)
:	O
""	*(char)
,	O
(	O
nonexistent	bool
?	O
"delete"	*(char)
:	O
is_empty	bool
?	O
"empty out"	*(char)
:	O
"create"	*(char)
)	O
,	O
quotearg	(*(char))->(*(char))
(	O
name	*(char)
)	O
,	O
(	O
nonexistent	bool
?	O
"does not exist"	*(char)
:	O
is_empty	bool
?	O
"is already empty"	*(char)
:	O
"already exists"	*(char)
)	O
)	O
;	O
return	O
looks_reversed	bool
;	O
}	O
bool	bool
there_is_another_patch	(bool,*(int))->(bool)
(	O
bool	bool
need_header	bool
,	O
mode_t	int
*	O
file_type	*(int)
)	O
{	O
if	O
(	O
p_base	long
!=	O
0	int
&&	O
p_base	long
>=	O
p_filesize	long
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"done\n"	*(char)
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"Hmm..."	*(char)
)	O
;	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
intuit_diff_type	(bool,*(int))->(enum(int,int,int,int,int,int,int))
(	O
need_header	bool
,	O
file_type	*(int)
)	O
;	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
p_base	long
?	O
"  Ignoring the trailing garbage.\ndone\n"	*(char)
:	O
"  I can't seem to find a patch in there anywhere.\n"	*(char)
)	O
;	O
if	O
(	O
!	O
p_base	long
&&	O
p_filesize	long
)	O
fatal	(*(char))->(void)
(	O
"Only garbage was found in the patch input."	*(char)
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
skip_rest_of_patch	bool
)	O
{	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p_start	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
p_sline	long
-	O
1	int
;	O
return	O
true	int
;	O
}	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"  %sooks like %s to me...\n"	*(char)
,	O
(	O
p_base	long
==	O
0	int
?	O
"L"	*(char)
:	O
"The next patch l"	*(char)
)	O
,	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
?	O
"a unified diff"	*(char)
:	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
CONTEXT_DIFF	int
?	O
"a context diff"	*(char)
:	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NEW_CONTEXT_DIFF	int
?	O
"a new-style context diff"	*(char)
:	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NORMAL_DIFF	int
?	O
"a normal diff"	*(char)
:	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
GIT_BINARY_DIFF	int
?	O
"a git binary diff"	*(char)
:	O
"an ed script"	*(char)
)	O
;	O
if	O
(	O
no_strip_trailing_cr	bool
)	O
p_strip_trailing_cr	bool
=	O
false	int
;	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
{	O
if	O
(	O
p_indent	long
)	O
say	(*(char))->(void)
(	O
"(Patch is indented %lu space%s.)\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
p_indent	long
,	O
p_indent	long
==	O
1	int
?	O
""	*(char)
:	O
"s"	*(char)
)	O
;	O
if	O
(	O
p_strip_trailing_cr	bool
)	O
say	(*(char))->(void)
(	O
"(Stripping trailing CRs from patch.)\n"	*(char)
)	O
;	O
if	O
(	O
!	O
inname	*(char)
)	O
{	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	(*(char))->(void)
(	O
"can't find file to patch at input line %s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_sline	long
)	O
)	O
;	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
!=	O
ED_DIFF	int
&&	O
diff_type	enum(int,int,int,int,int,int,int)
!=	O
NORMAL_DIFF	int
)	O
say	(*(char))->(void)
(	O
strippath	int
==	O
-	O
1	int
?	O
"Perhaps you should have used the -p or --strip option?\n"	*(char)
:	O
"Perhaps you used the wrong -p or --strip option?\n"	*(char)
)	O
;	O
}	O
}	O
skip_to	(long,long)->(void)
(	O
p_start	long
,	O
p_sline	long
)	O
;	O
while	O
(	O
!	O
inname	*(char)
)	O
{	O
char	O
*	O
t	struct(long,long)
;	O
if	O
(	O
force	bool
|	O
batch	bool
)	O
{	O
say	(*(char))->(void)
(	O
"No file to patch.  Skipping patch.\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
ask	(*(char))->(void)
(	O
"File to patch: "	*(char)
)	O
;	O
t	struct(long,long)
=	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
t	struct(long,long)
>	O
buf	*(char)
+	O
1	int
&&	O
*	O
(	O
t	struct(long,long)
-	O
1	int
)	O
==	O
'\n'	O
)	O
{	O
inname	*(char)
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
t	struct(long,long)
-	O
buf	*(char)
)	O
;	O
inname	*(char)
[	O
t	struct(long,long)
-	O
buf	*(char)
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
inname	*(char)
,	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
inerrno	int
=	O
0	int
;	O
invc	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
perror	(*(char))->(void)
(	O
inname	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
inname	*(char)
)	O
;	O
inname	*(char)
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
inname	*(char)
)	O
{	O
ask	(*(char))->(void)
(	O
"Skip this patch? [y] "	*(char)
)	O
;	O
if	O
(	O
*	O
buf	*(char)
!=	O
'n'	O
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
!=	O
SILENT	int
)	O
say	(*(char))->(void)
(	O
"Skipping patch.\n"	*(char)
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
mode_t	int
_GL_ATTRIBUTE_PURE	O
fetchmode	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
const	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
mode_t	int
mode	int
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
str	*(char)
,	O
mode	int
=	O
0	int
;	O
s	enum(int,int,int,int,int,int,int,int,int)
<	O
str	*(char)
+	O
6	int
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
{	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
>=	O
'0'	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
<=	O
'7'	O
)	O
mode	int
=	O
(	O
mode	int
<<	O
3	int
)	O
+	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
-	O
'0'	O
)	O
;	O
else	O
{	O
mode	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\r'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\n'	O
)	O
mode	int
=	O
0	int
;	O
return	O
mode	int
;	O
}	O
static	O
void	O
get_sha1	(*(*(char)),*(char),*(char))->(void)
(	O
char	O
*	O
*	O
sha1	*(*(char))
,	O
char	O
const	O
*	O
start	*(char)
,	O
char	O
const	O
*	O
end	*(char)
)	O
{	O
unsigned	O
int	O
len	int
=	O
end	*(char)
-	O
start	*(char)
;	O
*	O
sha1	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
*	O
sha1	*(*(char))
,	O
start	*(char)
,	O
len	int
)	O
;	O
(	O
*	O
sha1	*(*(char))
)	O
[	O
len	int
]	O
=	O
0	int
;	O
}	O
static	O
int	O
_GL_ATTRIBUTE_PURE	O
sha1_says_nonexistent	(*(char))->(int)
(	O
char	O
const	O
*	O
sha1	*(*(char))
)	O
{	O
char	O
const	O
*	O
empty_sha1	*(char)
=	O
"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"	*(char)
;	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
sha1	*(*(char))
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'0'	O
)	O
break	O
;	O
if	O
(	O
!	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
return	O
2	int
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
sha1	*(*(char))
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
,	O
empty_sha1	*(char)
++	O
)	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
*	O
empty_sha1	*(char)
)	O
break	O
;	O
return	O
!	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
static	O
char	O
const	O
*	O
_GL_ATTRIBUTE_PURE	O
skip_hex_digits	(*(char))->(*(char))
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
char	O
const	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
str	*(char)
;	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
>=	O
'0'	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
<=	O
'9'	O
)	O
||	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
>=	O
'a'	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
<=	O
'f'	O
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
;	O
return	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
str	*(char)
?	O
NULL	O
:	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
static	O
bool	bool
name_is_valid	(*(char))->(bool)
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
char	O
const	O
*	O
n	int
;	O
int	O
i	int
;	O
bool	bool
is_valid	bool
=	O
true	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array(*(char))
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
invalid_names	array(*(char))
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
invalid_names	array(*(char))
[	O
i	int
]	O
,	O
name	*(char)
)	O
)	O
return	O
false	int
;	O
}	O
if	O
(	O
IS_ABSOLUTE_FILE_NAME	O
(	O
name	*(char)
)	O
)	O
is_valid	bool
=	O
false	int
;	O
else	O
for	O
(	O
n	int
=	O
name	*(char)
;	O
*	O
n	int
;	O
)	O
{	O
if	O
(	O
*	O
n	int
==	O
'.'	O
&&	O
*	O
++	O
n	int
==	O
'.'	O
&&	O
(	O
!	O
*	O
++	O
n	int
||	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
)	O
{	O
is_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
while	O
(	O
*	O
n	int
&&	O
!	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
n	int
++	O
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
n	int
++	O
;	O
}	O
if	O
(	O
!	O
is_valid	bool
)	O
{	O
say	(*(char))->(void)
(	O
"Ignoring potentially dangerous file name %s\n"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array(*(char))
)	O
)	O
invalid_names	array(*(char))
[	O
i	int
]	O
=	O
name	*(char)
;	O
}	O
return	O
is_valid	bool
;	O
}	O
static	O
enum	O
diff	enum(int,int,int,int,int,int,int)
intuit_diff_type	(bool,*(int))->(enum(int,int,int,int,int,int,int))
(	O
bool	bool
need_header	bool
,	O
mode_t	int
*	O
p_file_type	*(int)
)	O
{	O
file_offset	long
this_line	long
=	O
0	int
;	O
file_offset	long
first_command_line	long
=	O
-	O
1	int
;	O
char	O
first_ed_command_letter	char
=	O
0	int
;	O
lin	long
fcl_line	long
=	O
0	int
;	O
bool	bool
this_is_a_command	bool
=	O
false	int
;	O
bool	bool
stars_this_line	bool
=	O
false	int
;	O
bool	bool
extended_headers	bool
=	O
false	int
;	O
enum	O
nametype	enum(int,int,int,int)
i	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
3	int
]	O
;	O
int	O
stat_errno	array(int)
[	O
3	int
]	O
;	O
int	O
version_controlled	array(int)
[	O
3	int
]	O
;	O
enum	O
diff	enum(int,int,int,int,int,int,int)
retval	enum(int,int,int,int,int,int,int)
;	O
mode_t	int
file_type	*(int)
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
p_name	array(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array(*(char))
)	O
;	O
i	int
++	O
)	O
invalid_names	array(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
if	O
(	O
p_timestr	array(*(char))
[	O
i	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
p_timestr	array(*(char))
[	O
i	int
]	O
)	O
;	O
p_timestr	array(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
if	O
(	O
p_sha1	array(*(char))
[	O
i	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
p_sha1	array(*(char))
[	O
i	int
]	O
)	O
;	O
p_sha1	array(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
p_git_diff	bool
=	O
false	int
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
p_mode	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
p_copy	array(bool)
[	O
i	int
]	O
=	O
false	int
;	O
p_rename	array(bool)
[	O
i	int
]	O
=	O
false	int
;	O
}	O
if	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
ED_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NORMAL_DIFF	int
)	O
need_header	bool
=	O
false	int
;	O
version_controlled	array(int)
[	O
OLD	int
]	O
=	O
-	O
1	int
;	O
version_controlled	array(int)
[	O
NEW	int
]	O
=	O
-	O
1	int
;	O
version_controlled	array(int)
[	O
INDEX	int
]	O
=	O
-	O
1	int
;	O
p_rfc934_nesting	int
=	O
0	int
;	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
.	O
tv_sec	long
=	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
.	O
tv_sec	long
=	O
-	O
1	int
;	O
p_says_nonexistent	array(int)
[	O
OLD	int
]	O
=	O
p_says_nonexistent	array(int)
[	O
NEW	int
]	O
=	O
0	int
;	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p_base	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
p_bline	long
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
char	O
*	O
t	struct(long,long)
;	O
file_offset	long
previous_line	long
=	O
this_line	long
;	O
bool	bool
last_line_was_command	bool
=	O
this_is_a_command	bool
;	O
bool	bool
stars_last_line	bool
=	O
stars_this_line	bool
;	O
size_t	long
indent	long
=	O
0	int
;	O
char	O
ed_command_letter	char
;	O
bool	bool
strip_trailing_cr	bool
;	O
size_t	long
chars_read	long
;	O
this_line	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
chars_read	long
=	O
pget_line	(long,int,bool,bool)->(long)
(	O
0	int
,	O
0	int
,	O
false	int
,	O
false	int
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
first_ed_command_letter	char
)	O
{	O
p_start	long
=	O
first_command_line	long
;	O
p_sline	long
=	O
fcl_line	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
ED_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
else	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
if	O
(	O
extended_headers	bool
)	O
{	O
retval	enum(int,int,int,int,int,int,int)
=	O
UNI_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
return	O
NO_DIFF	int
;	O
}	O
}	O
strip_trailing_cr	bool
=	O
2	int
<=	O
chars_read	long
&&	O
buf	*(char)
[	O
chars_read	long
-	O
2	int
]	O
==	O
'\r'	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
||	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\t'	O
||	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'X'	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
{	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\t'	O
)	O
indent	long
=	O
(	O
indent	long
+	O
8	int
)	O
&	O
~	O
7	int
;	O
else	O
indent	long
++	O
;	O
}	O
if	O
(	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
{	O
for	O
(	O
t	struct(long,long)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
;	O
ISDIGIT	O
(	O
*	O
t	struct(long,long)
)	O
||	O
*	O
t	struct(long,long)
==	O
','	O
;	O
t	struct(long,long)
++	O
)	O
;	O
if	O
(	O
*	O
t	struct(long,long)
==	O
'd'	O
||	O
*	O
t	struct(long,long)
==	O
'c'	O
||	O
*	O
t	struct(long,long)
==	O
'a'	O
)	O
{	O
for	O
(	O
t	struct(long,long)
++	O
;	O
ISDIGIT	O
(	O
*	O
t	struct(long,long)
)	O
||	O
*	O
t	struct(long,long)
==	O
','	O
;	O
t	struct(long,long)
++	O
)	O
;	O
for	O
(	O
;	O
*	O
t	struct(long,long)
==	O
' '	O
||	O
*	O
t	struct(long,long)
==	O
'\t'	O
;	O
t	struct(long,long)
++	O
)	O
;	O
if	O
(	O
*	O
t	struct(long,long)
==	O
'\r'	O
)	O
t	struct(long,long)
++	O
;	O
this_is_a_command	bool
=	O
(	O
*	O
t	struct(long,long)
==	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
need_header	bool
&&	O
first_command_line	long
<	O
0	int
&&	O
(	O
(	O
ed_command_letter	char
=	O
get_ed_command_letter	(*(char))->(char)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
||	O
this_is_a_command	bool
)	O
)	O
{	O
first_command_line	long
=	O
this_line	long
;	O
first_ed_command_letter	char
=	O
ed_command_letter	char
;	O
fcl_line	long
=	O
p_input_line	long
;	O
p_indent	long
=	O
indent	long
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
if	O
(	O
!	O
stars_last_line	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"*** "	*(char)
,	O
4	int
)	O
)	O
{	O
fetchname	(*(char),int,*(*(char)),*(*(char)),*(struct(long,long)))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array(*(char))
[	O
OLD	int
]	O
,	O
&	O
p_timestr	array(*(char))
[	O
OLD	int
]	O
,	O
&	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"+++ "	*(char)
,	O
4	int
)	O
)	O
{	O
fetchname	(*(char),int,*(*(char)),*(*(char)),*(struct(long,long)))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array(*(char))
[	O
OLD	int
]	O
,	O
&	O
p_timestr	array(*(char))
[	O
OLD	int
]	O
,	O
&	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"Index:"	*(char)
,	O
6	int
)	O
)	O
{	O
fetchname	(*(char),int,*(*(char)),*(*(char)),*(struct(long,long)))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
6	int
,	O
strippath	int
,	O
&	O
p_name	array(*(char))
[	O
INDEX	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
0	int
,	O
NULL	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"Prereq:"	*(char)
,	O
7	int
)	O
)	O
{	O
for	O
(	O
t	struct(long,long)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
7	int
;	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct(long,long)
)	O
;	O
t	struct(long,long)
++	O
)	O
;	O
revision	*(char)
=	O
t	struct(long,long)
;	O
for	O
(	O
t	struct(long,long)
=	O
revision	*(char)
;	O
*	O
t	struct(long,long)
;	O
t	struct(long,long)
++	O
)	O
if	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct(long,long)
)	O
)	O
{	O
char	O
const	O
*	O
u	*(char)
;	O
for	O
(	O
u	*(char)
=	O
t	struct(long,long)
+	O
1	int
;	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
u	*(char)
)	O
;	O
u	*(char)
++	O
)	O
;	O
if	O
(	O
*	O
u	*(char)
)	O
{	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	(*(char))->(void)
(	O
"Prereq: with multiple words at line %s of patch\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
this_line	long
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
t	struct(long,long)
==	O
revision	*(char)
)	O
revision	*(char)
=	O
0	int
;	O
else	O
{	O
char	O
oldc	char
=	O
*	O
t	struct(long,long)
;	O
*	O
t	struct(long,long)
=	O
'\0'	O
;	O
revision	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
revision	*(char)
)	O
;	O
*	O
t	struct(long,long)
=	O
oldc	char
;	O
}	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"diff --git "	*(char)
,	O
11	int
)	O
)	O
{	O
char	O
const	O
*	O
u	*(char)
;	O
if	O
(	O
extended_headers	bool
)	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
UNI_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
p_name	array(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
(	O
p_name	array(*(char))
[	O
OLD	int
]	O
=	O
parse_name	(*(char),int,*(*(char)))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
11	int
,	O
strippath	int
,	O
&	O
u	*(char)
)	O
)	O
&&	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
u	*(char)
)	O
&&	O
(	O
p_name	array(*(char))
[	O
NEW	int
]	O
=	O
parse_name	(*(char),int,*(*(char)))->(*(char))
(	O
u	*(char)
,	O
strippath	int
,	O
&	O
u	*(char)
)	O
)	O
&&	O
(	O
u	*(char)
=	O
skip_spaces	(*(char))->(*(char))
(	O
u	*(char)
)	O
,	O
!	O
*	O
u	*(char)
)	O
)	O
)	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
p_name	array(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
}	O
p_git_diff	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"index "	*(char)
,	O
6	int
)	O
)	O
{	O
char	O
const	O
*	O
u	*(char)
,	O
*	O
v	*(char)
;	O
if	O
(	O
(	O
u	*(char)
=	O
skip_hex_digits	(*(char))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
6	int
)	O
)	O
&&	O
u	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
u	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
v	*(char)
=	O
skip_hex_digits	(*(char))->(*(char))
(	O
u	*(char)
+	O
2	int
)	O
)	O
&&	O
(	O
!	O
*	O
v	*(char)
||	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
v	*(char)
)	O
)	O
)	O
{	O
get_sha1	(*(*(char)),*(char),*(char))->(void)
(	O
&	O
p_sha1	array(*(char))
[	O
OLD	int
]	O
,	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
6	int
,	O
u	*(char)
)	O
;	O
get_sha1	(*(*(char)),*(char),*(char))->(void)
(	O
&	O
p_sha1	array(*(char))
[	O
NEW	int
]	O
,	O
u	*(char)
+	O
2	int
,	O
v	*(char)
)	O
;	O
p_says_nonexistent	array(int)
[	O
OLD	int
]	O
=	O
sha1_says_nonexistent	(*(char))->(int)
(	O
p_sha1	array(*(char))
[	O
OLD	int
]	O
)	O
;	O
p_says_nonexistent	array(int)
[	O
NEW	int
]	O
=	O
sha1_says_nonexistent	(*(char))->(int)
(	O
p_sha1	array(*(char))
[	O
NEW	int
]	O
)	O
;	O
if	O
(	O
*	O
(	O
v	*(char)
=	O
skip_spaces	(*(char))->(*(char))
(	O
v	*(char)
)	O
)	O
)	O
p_mode	array(int)
[	O
OLD	int
]	O
=	O
p_mode	array(int)
[	O
NEW	int
]	O
=	O
fetchmode	(*(char))->(int)
(	O
v	*(char)
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"old mode "	*(char)
,	O
9	int
)	O
)	O
{	O
p_mode	array(int)
[	O
OLD	int
]	O
=	O
fetchmode	(*(char))->(int)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
9	int
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"new mode "	*(char)
,	O
9	int
)	O
)	O
{	O
p_mode	array(int)
[	O
NEW	int
]	O
=	O
fetchmode	(*(char))->(int)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
9	int
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"deleted file mode "	*(char)
,	O
18	int
)	O
)	O
{	O
p_mode	array(int)
[	O
OLD	int
]	O
=	O
fetchmode	(*(char))->(int)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
18	int
)	O
;	O
p_says_nonexistent	array(int)
[	O
NEW	int
]	O
=	O
2	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"new file mode "	*(char)
,	O
14	int
)	O
)	O
{	O
p_mode	array(int)
[	O
NEW	int
]	O
=	O
fetchmode	(*(char))->(int)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
14	int
)	O
;	O
p_says_nonexistent	array(int)
[	O
OLD	int
]	O
=	O
2	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"rename from "	*(char)
,	O
12	int
)	O
)	O
{	O
p_rename	array(bool)
[	O
OLD	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"rename to "	*(char)
,	O
10	int
)	O
)	O
{	O
p_rename	array(bool)
[	O
NEW	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"copy from "	*(char)
,	O
10	int
)	O
)	O
{	O
p_copy	array(bool)
[	O
OLD	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"copy to "	*(char)
,	O
8	int
)	O
)	O
{	O
p_copy	array(bool)
[	O
NEW	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"GIT binary patch"	*(char)
,	O
16	int
)	O
)	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
GIT_BINARY_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
else	O
{	O
for	O
(	O
t	struct(long,long)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
t	struct(long,long)
[	O
0	int
]	O
==	O
'-'	O
&&	O
t	struct(long,long)
[	O
1	int
]	O
==	O
' '	O
;	O
t	struct(long,long)
+=	O
2	int
)	O
;	O
if	O
(	O
strnEQ	O
(	O
t	struct(long,long)
,	O
"--- "	*(char)
,	O
4	int
)	O
)	O
{	O
struct	O
timespec	struct(long,long)
timestamp	struct(long,long)
;	O
timestamp	struct(long,long)
.	O
tv_sec	long
=	O
-	O
1	int
;	O
fetchname	(*(char),int,*(*(char)),*(*(char)),*(struct(long,long)))->(void)
(	O
t	struct(long,long)
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array(*(char))
[	O
NEW	int
]	O
,	O
&	O
p_timestr	array(*(char))
[	O
NEW	int
]	O
,	O
&	O
timestamp	struct(long,long)
)	O
;	O
need_header	bool
=	O
false	int
;	O
if	O
(	O
timestamp	struct(long,long)
.	O
tv_sec	long
!=	O
-	O
1	int
)	O
{	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
=	O
timestamp	struct(long,long)
;	O
p_rfc934_nesting	int
=	O
(	O
t	struct(long,long)
-	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
>>	O
1	int
;	O
}	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
}	O
if	O
(	O
need_header	bool
)	O
continue	O
;	O
if	O
(	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
ED_DIFF	int
)	O
&&	O
first_command_line	long
>=	O
0	int
&&	O
strEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
".\n"	*(char)
)	O
)	O
{	O
p_start	long
=	O
first_command_line	long
;	O
p_sline	long
=	O
fcl_line	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
ED_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
if	O
(	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
)	O
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"@@ -"	*(char)
,	O
4	int
)	O
)	O
{	O
struct	O
timespec	struct(long,long)
ti	struct(long,long)
=	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
;	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
=	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
;	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
=	O
ti	struct(long,long)
;	O
t	struct(long,long)
=	O
p_name	array(*(char))
[	O
OLD	int
]	O
;	O
p_name	array(*(char))
[	O
OLD	int
]	O
=	O
p_name	array(*(char))
[	O
NEW	int
]	O
;	O
p_name	array(*(char))
[	O
NEW	int
]	O
=	O
t	struct(long,long)
;	O
t	struct(long,long)
=	O
p_timestr	array(*(char))
[	O
OLD	int
]	O
;	O
p_timestr	array(*(char))
[	O
OLD	int
]	O
=	O
p_timestr	array(*(char))
[	O
NEW	int
]	O
;	O
p_timestr	array(*(char))
[	O
NEW	int
]	O
=	O
t	struct(long,long)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
+=	O
4	int
;	O
if	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
)	O
)	O
p_says_nonexistent	array(int)
[	O
OLD	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
.	O
tv_sec	long
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
' '	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\n'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
==	O
'+'	O
&&	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
2	int
]	O
)	O
)	O
p_says_nonexistent	array(int)
[	O
NEW	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
.	O
tv_sec	long
;	O
p_indent	long
=	O
indent	long
;	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
UNI_DIFF	int
;	O
if	O
(	O
!	O
(	O
(	O
p_name	array(*(char))
[	O
OLD	int
]	O
||	O
!	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
.	O
tv_sec	long
)	O
&&	O
(	O
p_name	array(*(char))
[	O
NEW	int
]	O
||	O
!	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
.	O
tv_sec	long
)	O
)	O
&&	O
!	O
p_name	array(*(char))
[	O
INDEX	int
]	O
&&	O
need_header	bool
)	O
{	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	(*(char))->(void)
(	O
"missing header for unified diff at line %s of patch\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_sline	long
)	O
)	O
;	O
}	O
goto	O
scan_exit	O
;	O
}	O
stars_this_line	bool
=	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"********"	*(char)
,	O
8	int
)	O
;	O
if	O
(	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
CONTEXT_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NEW_CONTEXT_DIFF	int
)	O
&&	O
stars_last_line	bool
&&	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"*** "	*(char)
,	O
4	int
)	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
+=	O
4	int
;	O
if	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
0	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
[	O
1	int
]	O
)	O
)	O
p_says_nonexistent	array(int)
[	O
OLD	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
.	O
tv_sec	long
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\n'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
p_indent	long
=	O
indent	long
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
p_start	long
=	O
previous_line	long
;	O
p_sline	long
=	O
p_input_line	long
-	O
1	int
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
(	O
*	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
-	O
1	int
)	O
==	O
'*'	O
?	O
NEW_CONTEXT_DIFF	int
:	O
CONTEXT_DIFF	int
)	O
;	O
{	O
file_offset	long
saved_p_base	long
=	O
p_base	long
;	O
lin	long
saved_p_bline	long
=	O
p_bline	long
;	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
previous_line	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
-=	O
2	int
;	O
if	O
(	O
another_hunk	(enum(int,int,int,int,int,int,int),bool)->(int)
(	O
retval	enum(int,int,int,int,int,int,int)
,	O
false	int
)	O
&&	O
!	O
p_repl_lines	long
&&	O
p_newfirst	long
==	O
1	int
)	O
p_says_nonexistent	array(int)
[	O
NEW	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
.	O
tv_sec	long
;	O
next_intuit_at	(long,long)->(void)
(	O
saved_p_base	long
,	O
saved_p_bline	long
)	O
;	O
}	O
if	O
(	O
!	O
(	O
(	O
p_name	array(*(char))
[	O
OLD	int
]	O
||	O
!	O
p_timestamp	array(struct(long,long))
[	O
OLD	int
]	O
.	O
tv_sec	long
)	O
&&	O
(	O
p_name	array(*(char))
[	O
NEW	int
]	O
||	O
!	O
p_timestamp	array(struct(long,long))
[	O
NEW	int
]	O
.	O
tv_sec	long
)	O
)	O
&&	O
!	O
p_name	array(*(char))
[	O
INDEX	int
]	O
&&	O
need_header	bool
)	O
{	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	(*(char))->(void)
(	O
"missing header for context diff at line %s of patch\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_sline	long
)	O
)	O
;	O
}	O
goto	O
scan_exit	O
;	O
}	O
if	O
(	O
(	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NO_DIFF	int
||	O
diff_type	enum(int,int,int,int,int,int,int)
==	O
NORMAL_DIFF	int
)	O
&&	O
last_line_was_command	bool
&&	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"< "	*(char)
,	O
2	int
)	O
||	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"> "	*(char)
,	O
2	int
)	O
)	O
)	O
{	O
p_start	long
=	O
previous_line	long
;	O
p_sline	long
=	O
p_input_line	long
-	O
1	int
;	O
p_indent	long
=	O
indent	long
;	O
retval	enum(int,int,int,int,int,int,int)
=	O
NORMAL_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
}	O
scan_exit	O
:	O
file_type	*(int)
=	O
p_mode	array(int)
[	O
OLD	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
file_type	*(int)
)	O
{	O
mode_t	int
new_file_type	int
=	O
p_mode	array(int)
[	O
NEW	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
new_file_type	int
&&	O
file_type	*(int)
!=	O
new_file_type	int
)	O
file_type	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
file_type	*(int)
=	O
p_mode	array(int)
[	O
NEW	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
!	O
file_type	*(int)
)	O
file_type	*(int)
=	O
S_IFREG	O
;	O
}	O
*	O
p_file_type	*(int)
=	O
file_type	*(int)
;	O
i	int
=	O
NONE	int
;	O
if	O
(	O
!	O
inname	*(char)
)	O
{	O
enum	O
nametype	enum(int,int,int,int)
i0	enum(int,int,int,int)
=	O
NONE	int
;	O
if	O
(	O
!	O
posixly_correct	bool
&&	O
(	O
p_name	array(*(char))
[	O
OLD	int
]	O
||	O
p_name	array(*(char))
[	O
NEW	int
]	O
)	O
&&	O
p_name	array(*(char))
[	O
INDEX	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
p_name	array(*(char))
[	O
INDEX	int
]	O
)	O
;	O
p_name	array(*(char))
[	O
INDEX	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
{	O
if	O
(	O
i0	enum(int,int,int,int)
!=	O
NONE	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
p_name	array(*(char))
[	O
i0	enum(int,int,int,int)
]	O
,	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
==	O
0	int
)	O
{	O
stat_errno	array(int)
[	O
i	int
]	O
=	O
stat_errno	array(int)
[	O
i0	enum(int,int,int,int)
]	O
;	O
if	O
(	O
!	O
stat_errno	array(int)
[	O
i	int
]	O
)	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i0	enum(int,int,int,int)
]	O
;	O
}	O
else	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
p_name	array(*(char))
[	O
i	int
]	O
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
stat_errno	array(int)
[	O
i	int
]	O
=	O
errno	O
;	O
else	O
if	O
(	O
lookup_file_id	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(enum(int,int,int,int))
(	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
)	O
==	O
DELETE_LATER	int
)	O
stat_errno	array(int)
[	O
i	int
]	O
=	O
ENOENT	int
;	O
else	O
{	O
stat_errno	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
posixly_correct	bool
&&	O
name_is_valid	(*(char))->(bool)
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
i0	enum(int,int,int,int)
=	O
i	int
;	O
}	O
if	O
(	O
!	O
posixly_correct	bool
)	O
{	O
i	int
=	O
best_name	(*(*(char)),*(int))->(enum(int,int,int,int))
(	O
p_name	array(*(char))
,	O
stat_errno	array(int)
)	O
;	O
if	O
(	O
i	int
==	O
NONE	int
&&	O
patch_get	int
)	O
{	O
enum	O
nametype	enum(int,int,int,int)
nope	enum(int,int,int,int)
=	O
NONE	int
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
{	O
char	O
const	O
*	O
cs	*(char)
;	O
char	O
*	O
getbuf	*(char)
;	O
char	O
*	O
diffbuf	*(char)
;	O
bool	bool
readonly	bool
=	O
(	O
outfile	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
outfile	*(char)
,	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
nope	enum(int,int,int,int)
==	O
NONE	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
p_name	array(*(char))
[	O
nope	enum(int,int,int,int)
]	O
,	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
{	O
cs	*(char)
=	O
(	O
version_controller	(*(char),bool,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(*(char)),*(*(char)))->(*(char))
(	O
p_name	array(*(char))
[	O
i	int
]	O
,	O
readonly	bool
,	O
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
)	O
0	int
,	O
&	O
getbuf	*(char)
,	O
&	O
diffbuf	*(char)
)	O
)	O
;	O
version_controlled	array(int)
[	O
i	int
]	O
=	O
!	O
!	O
cs	*(char)
;	O
if	O
(	O
cs	*(char)
)	O
{	O
if	O
(	O
version_get	(*(char),*(char),bool,bool,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(bool)
(	O
p_name	array(*(char))
[	O
i	int
]	O
,	O
cs	*(char)
,	O
false	int
,	O
readonly	bool
,	O
getbuf	*(char)
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
)	O
)	O
stat_errno	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
else	O
version_controlled	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
free	(*(void))->(void)
(	O
getbuf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
diffbuf	*(char)
)	O
;	O
if	O
(	O
!	O
stat_errno	array(int)
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
nope	enum(int,int,int,int)
=	O
i	int
;	O
}	O
}	O
if	O
(	O
i0	enum(int,int,int,int)
!=	O
NONE	int
&&	O
(	O
i	int
==	O
NONE	int
||	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
file_type	*(int)
)	O
&&	O
maybe_reverse	(*(char),bool,bool)->(bool)
(	O
p_name	array(*(char))
[	O
i	int
==	O
NONE	int
?	O
i0	enum(int,int,int,int)
:	O
i	int
]	O
,	O
i	int
==	O
NONE	int
,	O
i	int
==	O
NONE	int
||	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
.	O
st_size	long
==	O
0	int
)	O
&&	O
i	int
==	O
NONE	int
)	O
i	int
=	O
i0	enum(int,int,int,int)
;	O
if	O
(	O
i	int
==	O
NONE	int
&&	O
p_says_nonexistent	array(int)
[	O
reverse	bool
]	O
)	O
{	O
int	O
newdirs	array(int)
[	O
3	int
]	O
;	O
int	O
newdirs_min	int
=	O
INT_MAX	O
;	O
int	O
distance_from_minimum	array(int)
[	O
3	int
]	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
{	O
newdirs	array(int)
[	O
i	int
]	O
=	O
(	O
prefix_components	(*(char),bool)->(int)
(	O
p_name	array(*(char))
[	O
i	int
]	O
,	O
false	int
)	O
-	O
prefix_components	(*(char),bool)->(int)
(	O
p_name	array(*(char))
[	O
i	int
]	O
,	O
true	int
)	O
)	O
;	O
if	O
(	O
newdirs	array(int)
[	O
i	int
]	O
<	O
newdirs_min	int
)	O
newdirs_min	int
=	O
newdirs	array(int)
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
distance_from_minimum	array(int)
[	O
i	int
]	O
=	O
newdirs	array(int)
[	O
i	int
]	O
-	O
newdirs_min	int
;	O
i	int
=	O
best_name	(*(*(char)),*(int))->(enum(int,int,int,int))
(	O
p_name	array(*(char))
,	O
distance_from_minimum	array(int)
)	O
;	O
}	O
}	O
}	O
if	O
(	O
i	int
==	O
NONE	int
)	O
{	O
if	O
(	O
inname	*(char)
)	O
{	O
inerrno	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
inname	*(char)
,	O
&	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
if	O
(	O
inerrno	int
||	O
(	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
file_type	*(int)
)	O
maybe_reverse	(*(char),bool,bool)->(bool)
(	O
inname	*(char)
,	O
inerrno	int
,	O
inerrno	int
||	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
==	O
0	int
)	O
;	O
}	O
else	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
inname	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
p_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
inerrno	int
=	O
stat_errno	array(int)
[	O
i	int
]	O
;	O
invc	int
=	O
version_controlled	array(int)
[	O
i	int
]	O
;	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
[	O
i	int
]	O
;	O
}	O
return	O
retval	enum(int,int,int,int,int,int,int)
;	O
}	O
static	O
int	O
prefix_components	(*(char),bool)->(int)
(	O
char	O
*	O
filename	*(char)
,	O
bool	bool
checkdirs	bool
)	O
{	O
int	O
count	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat_buf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
stat_result	int
;	O
char	O
*	O
f	*(char)
=	O
filename	*(char)
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
filename	*(char)
)	O
;	O
if	O
(	O
*	O
f	*(char)
)	O
while	O
(	O
*	O
++	O
f	*(char)
)	O
if	O
(	O
ISSLASH	O
(	O
f	*(char)
[	O
0	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
f	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
checkdirs	bool
)	O
{	O
*	O
f	*(char)
=	O
'\0'	O
;	O
stat_result	int
=	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
filename	*(char)
,	O
&	O
stat_buf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
*	O
f	*(char)
=	O
'/'	O
;	O
if	O
(	O
!	O
(	O
stat_result	int
==	O
0	int
&&	O
S_ISDIR	O
(	O
stat_buf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
break	O
;	O
}	O
count	int
++	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
enum	O
nametype	enum(int,int,int,int)
best_name	(*(*(char)),*(int))->(enum(int,int,int,int))
(	O
char	O
*	O
const	O
*	O
name	*(char)
,	O
int	O
const	O
*	O
ignore	*(int)
)	O
{	O
enum	O
nametype	enum(int,int,int,int)
i	int
;	O
int	O
components	array(int)
[	O
3	int
]	O
;	O
int	O
components_min	int
=	O
INT_MAX	O
;	O
size_t	long
basename_len	array(long)
[	O
3	int
]	O
;	O
size_t	long
basename_len_min	long
=	O
SIZE_MAX	O
;	O
size_t	long
len	int
[	O
3	int
]	O
;	O
size_t	long
len_min	long
=	O
SIZE_MAX	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
name	*(char)
[	O
i	int
]	O
&&	O
!	O
ignore	*(int)
[	O
i	int
]	O
)	O
{	O
components	array(int)
[	O
i	int
]	O
=	O
prefix_components	(*(char),bool)->(int)
(	O
name	*(char)
[	O
i	int
]	O
,	O
false	int
)	O
;	O
if	O
(	O
components_min	int
<	O
components	array(int)
[	O
i	int
]	O
)	O
continue	O
;	O
components_min	int
=	O
components	array(int)
[	O
i	int
]	O
;	O
basename_len	array(long)
[	O
i	int
]	O
=	O
base_len	(*(char))->(long)
(	O
name	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
basename_len_min	long
<	O
basename_len	array(long)
[	O
i	int
]	O
)	O
continue	O
;	O
basename_len_min	long
=	O
basename_len	array(long)
[	O
i	int
]	O
;	O
len	int
[	O
i	int
]	O
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
len_min	long
<	O
len	int
[	O
i	int
]	O
)	O
continue	O
;	O
len_min	long
=	O
len	int
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
name	*(char)
[	O
i	int
]	O
&&	O
!	O
ignore	*(int)
[	O
i	int
]	O
&&	O
name_is_valid	(*(char))->(bool)
(	O
name	*(char)
[	O
i	int
]	O
)	O
&&	O
components	array(int)
[	O
i	int
]	O
==	O
components_min	int
&&	O
basename_len	array(long)
[	O
i	int
]	O
==	O
basename_len_min	long
&&	O
len	int
[	O
i	int
]	O
==	O
len_min	long
)	O
break	O
;	O
return	O
i	int
;	O
}	O
static	O
void	O
next_intuit_at	(long,long)->(void)
(	O
file_offset	long
file_pos	long
,	O
lin	long
file_line	long
)	O
{	O
p_base	long
=	O
file_pos	long
;	O
p_bline	long
=	O
file_line	long
;	O
}	O
static	O
void	O
skip_to	(long,long)->(void)
(	O
file_offset	long
file_pos	long
,	O
lin	long
file_line	long
)	O
{	O
FILE	struct
*	O
i	int
=	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
o	*(struct)
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	char
;	O
assert	O
(	O
p_base	long
<=	O
file_pos	long
)	O
;	O
if	O
(	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
||	O
!	O
inname	*(char)
)	O
&&	O
p_base	long
<	O
file_pos	long
)	O
{	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
i	int
,	O
p_base	long
,	O
SEEK_SET	int
)	O
;	O
say	(*(char))->(void)
(	O
"The text leading up to this was:\n--------------------------\n"	*(char)
)	O
;	O
while	O
(	O
file_tell	O
(	O
i	int
)	O
<	O
file_pos	long
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'|'	O
,	O
o	*(struct)
)	O
;	O
do	O
{	O
if	O
(	O
(	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
i	int
)	O
)	O
==	O
EOF	O
)	O
read_fatal	()->(void)
(	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	char
,	O
o	*(struct)
)	O
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
}	O
say	(*(char))->(void)
(	O
"--------------------------\n"	*(char)
)	O
;	O
}	O
else	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
i	int
,	O
file_pos	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
file_line	long
-	O
1	int
;	O
}	O
static	O
void	O
malformed	()->(void)
(	O
void	O
)	O
{	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
fatal	(*(char))->(void)
(	O
"malformed patch at line %s: %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_input_line	long
)	O
,	O
buf	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
char	O
*	O
s0	*(char)
,	O
lin	long
*	O
linenum	*(long)
)	O
{	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
lin	long
n	int
=	O
0	int
;	O
bool	bool
overflow	bool
=	O
false	int
;	O
char	O
numbuf	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
s0	*(char)
;	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
{	O
lin	long
new_n	long
=	O
10	int
*	O
n	int
+	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
-	O
'0'	O
)	O
;	O
overflow	bool
|=	O
new_n	long
/	O
10	int
!=	O
n	int
;	O
n	int
=	O
new_n	long
;	O
}	O
if	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
s0	*(char)
)	O
fatal	(*(char))->(void)
(	O
"missing line number at line %s: %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_input_line	long
)	O
,	O
buf	*(char)
)	O
;	O
if	O
(	O
overflow	bool
)	O
fatal	(*(char))->(void)
(	O
"line number %.*s is too large at line %s: %s"	*(char)
,	O
(	O
int	O
)	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
-	O
s0	*(char)
)	O
,	O
s0	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf	array(char)
,	O
p_input_line	long
)	O
,	O
buf	*(char)
)	O
;	O
*	O
linenum	*(long)
=	O
n	int
;	O
return	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
int	O
another_hunk	(enum(int,int,int,int,int,int,int),bool)->(int)
(	O
enum	O
diff	enum(int,int,int,int,int,int,int)
difftype	enum(int,int,int,int,int,int,int)
,	O
bool	bool
rev	bool
)	O
{	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
lin	long
context	*(char)
=	O
0	int
;	O
size_t	long
chars_read	long
;	O
char	O
numbuf0	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf2	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf3	array(char)
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
while	O
(	O
p_end	long
>=	O
0	int
)	O
{	O
if	O
(	O
p_end	long
==	O
p_efake	long
)	O
p_end	long
=	O
p_bfake	long
;	O
else	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
p_end	long
]	O
)	O
;	O
p_end	long
--	O
;	O
}	O
assert	O
(	O
p_end	long
==	O
-	O
1	int
)	O
;	O
p_efake	long
=	O
-	O
1	int
;	O
if	O
(	O
p_c_function	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
p_c_function	*(char)
)	O
;	O
p_c_function	*(char)
=	O
NULL	O
;	O
}	O
p_max	long
=	O
hunkmax	long
;	O
if	O
(	O
difftype	enum(int,int,int,int,int,int,int)
==	O
CONTEXT_DIFF	int
||	O
difftype	enum(int,int,int,int,int,int,int)
==	O
NEW_CONTEXT_DIFF	int
)	O
{	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
lin	long
repl_beginning	long
=	O
0	int
;	O
lin	long
fillcnt	long
=	O
0	int
;	O
lin	long
fillsrc	long
;	O
lin	long
filldst	long
;	O
bool	bool
ptrn_spaces_eaten	bool
=	O
false	int
;	O
bool	bool
some_context	bool
=	O
false	int
;	O
bool	bool
repl_could_be_missing	bool
=	O
true	int
;	O
bool	bool
ptrn_missing	bool
=	O
false	int
;	O
bool	bool
repl_missing	bool
=	O
false	int
;	O
file_offset	long
repl_backtrack_position	long
=	O
0	int
;	O
lin	long
repl_patch_line	long
;	O
lin	long
repl_context	long
;	O
lin	long
ptrn_prefix_context	long
=	O
-	O
1	int
;	O
lin	long
ptrn_suffix_context	long
=	O
-	O
1	int
;	O
lin	long
repl_prefix_context	long
=	O
-	O
1	int
;	O
lin	long
ptrn_copiable	long
=	O
0	int
;	O
lin	long
repl_copiable	long
=	O
0	int
;	O
fillsrc	long
=	O
filldst	long
=	O
repl_patch_line	long
=	O
repl_context	long
=	O
0	int
;	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
chars_read	long
<=	O
8	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
"********"	*(char)
,	O
8	int
)	O
!=	O
0	int
)	O
{	O
next_intuit_at	(long,long)->(void)
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'*'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
)	O
{	O
p_c_function	*(char)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\n'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
'\0'	O
;	O
p_c_function	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
p_c_function	*(char)
)	O
;	O
}	O
p_hunk_beg	long
=	O
p_input_line	long
+	O
1	int
;	O
while	O
(	O
p_end	long
<	O
p_max	long
)	O
{	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
if	O
(	O
p_max	long
-	O
p_end	long
<	O
4	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"  \n"	*(char)
)	O
;	O
chars_read	long
=	O
3	int
;	O
}	O
else	O
{	O
fatal	(*(char))->(void)
(	O
"unexpected end of file in patch"	*(char)
)	O
;	O
}	O
}	O
p_end	long
++	O
;	O
if	O
(	O
p_end	long
==	O
hunkmax	long
)	O
fatal	(*(char))->(void)
(	O
"unterminated hunk starting at line %s; giving up at line %s: %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
pch_hunk_beg	()->(long)
(	O
)	O
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_input_line	long
)	O
,	O
buf	*(char)
)	O
;	O
assert	O
(	O
p_end	long
<	O
hunkmax	long
)	O
;	O
p_Char	*(char)
[	O
p_end	long
]	O
=	O
*	O
buf	*(char)
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
0	int
;	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
0	int
;	O
switch	O
(	O
*	O
buf	*(char)
)	O
{	O
case	O
'*'	O
:	O
if	O
(	O
strnEQ	O
(	O
buf	*(char)
,	O
"********"	*(char)
,	O
8	int
)	O
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
else	O
fatal	(*(char))->(void)
(	O
"unexpected end of hunk at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
}	O
if	O
(	O
p_end	long
!=	O
0	int
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
fatal	(*(char))->(void)
(	O
"unexpected '***' at line %s: %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
,	O
buf	*(char)
)	O
;	O
}	O
context	*(char)
=	O
0	int
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
;	O
if	O
(	O
strnEQ	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"0,0"	*(char)
,	O
3	int
)	O
)	O
remove_prefix	(*(char),long)->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
2	int
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
{	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
&	O
p_ptrn_lines	long
)	O
;	O
p_ptrn_lines	long
+=	O
1	int
-	O
p_first	long
;	O
}	O
else	O
if	O
(	O
p_first	long
)	O
p_ptrn_lines	long
=	O
1	int
;	O
else	O
{	O
p_ptrn_lines	long
=	O
0	int
;	O
p_first	long
=	O
1	int
;	O
}	O
p_max	long
=	O
p_ptrn_lines	long
+	O
6	int
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	()->(bool)
(	O
)	O
)	O
return	O
-	O
1	int
;	O
p_max	long
=	O
hunkmax	long
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
buf	*(char)
[	O
1	int
]	O
!=	O
'-'	O
)	O
goto	O
change_line	O
;	O
if	O
(	O
ptrn_prefix_context	long
==	O
-	O
1	int
)	O
ptrn_prefix_context	long
=	O
context	*(char)
;	O
ptrn_suffix_context	long
=	O
context	*(char)
;	O
if	O
(	O
repl_beginning	long
||	O
(	O
p_end	long
!=	O
p_ptrn_lines	long
+	O
1	int
+	O
(	O
p_Char	*(char)
[	O
p_end	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
)	O
{	O
if	O
(	O
p_end	long
==	O
1	int
)	O
{	O
ptrn_missing	bool
=	O
true	int
;	O
p_end	long
=	O
p_ptrn_lines	long
+	O
1	int
;	O
ptrn_prefix_context	long
=	O
ptrn_suffix_context	long
=	O
-	O
1	int
;	O
fillsrc	long
=	O
p_end	long
+	O
1	int
;	O
filldst	long
=	O
1	int
;	O
fillcnt	long
=	O
p_ptrn_lines	long
;	O
}	O
else	O
if	O
(	O
!	O
repl_beginning	long
)	O
fatal	(*(char))->(void)
(	O
"%s '---' at line %s; check line numbers at line %s"	*(char)
,	O
(	O
p_end	long
<=	O
p_ptrn_lines	long
?	O
"Premature"	*(char)
:	O
"Overdue"	*(char)
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_hunk_beg	long
)	O
)	O
;	O
else	O
if	O
(	O
!	O
repl_could_be_missing	bool
)	O
fatal	(*(char))->(void)
(	O
"duplicate '---' at line %s; check line numbers at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_hunk_beg	long
+	O
repl_beginning	long
)	O
)	O
;	O
else	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
}	O
repl_beginning	long
=	O
p_end	long
;	O
repl_backtrack_position	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
repl_patch_line	long
=	O
p_input_line	long
;	O
repl_context	long
=	O
context	*(char)
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
p_end	long
]	O
=	O
'='	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
&	O
p_newfirst	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
{	O
do	O
{	O
if	O
(	O
!	O
*	O
++	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
malformed	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
!	O
ISDIGIT	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
&	O
p_repl_lines	long
)	O
;	O
p_repl_lines	long
+=	O
1	int
-	O
p_newfirst	long
;	O
}	O
else	O
if	O
(	O
p_newfirst	long
)	O
p_repl_lines	long
=	O
1	int
;	O
else	O
{	O
p_repl_lines	long
=	O
0	int
;	O
p_newfirst	long
=	O
1	int
;	O
}	O
p_max	long
=	O
p_repl_lines	long
+	O
p_end	long
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	()->(bool)
(	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p_repl_lines	long
!=	O
ptrn_copiable	long
&&	O
(	O
p_prefix_context	long
!=	O
0	int
||	O
context	*(char)
!=	O
0	int
||	O
p_repl_lines	long
!=	O
1	int
)	O
)	O
repl_could_be_missing	bool
=	O
false	int
;	O
context	*(char)
=	O
0	int
;	O
break	O
;	O
case	O
'+'	O
:	O
case	O
'!'	O
:	O
repl_could_be_missing	bool
=	O
false	int
;	O
change_line	O
:	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
+	O
1	int
;	O
chars_read	long
--	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\n'	O
&&	O
canonicalize	bool
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
" \n"	*(char)
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
||	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\t'	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
chars_read	long
--	O
;	O
}	O
else	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
if	O
(	O
!	O
repl_beginning	long
)	O
{	O
if	O
(	O
ptrn_prefix_context	long
==	O
-	O
1	int
)	O
ptrn_prefix_context	long
=	O
context	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
repl_prefix_context	long
==	O
-	O
1	int
)	O
repl_prefix_context	long
=	O
context	*(char)
;	O
}	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	()->(bool)
(	O
)	O
)	O
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
savebuf	(*(char),long)->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	*(*(char))
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
context	*(char)
=	O
0	int
;	O
break	O
;	O
case	O
'\t'	O
:	O
case	O
'\n'	O
:	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
;	O
if	O
(	O
*	O
buf	*(char)
==	O
'\t'	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
chars_read	long
--	O
;	O
}	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
&&	O
(	O
!	O
ptrn_spaces_eaten	bool
||	O
difftype	enum(int,int,int,int,int,int,int)
==	O
NEW_CONTEXT_DIFF	int
)	O
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	()->(bool)
(	O
)	O
)	O
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	*(*(char))
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
p_end	long
!=	O
p_ptrn_lines	long
+	O
1	int
)	O
{	O
ptrn_spaces_eaten	bool
|=	O
(	O
repl_beginning	long
!=	O
0	int
)	O
;	O
some_context	bool
=	O
true	int
;	O
context	*(char)
++	O
;	O
if	O
(	O
repl_beginning	long
)	O
repl_copiable	long
++	O
;	O
else	O
ptrn_copiable	long
++	O
;	O
p_Char	*(char)
[	O
p_end	long
]	O
=	O
' '	O
;	O
}	O
break	O
;	O
case	O
' '	O
:	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
buf	*(char)
+	O
1	int
;	O
chars_read	long
--	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\n'	O
&&	O
canonicalize	bool
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
"\n"	*(char)
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
||	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'\t'	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
chars_read	long
--	O
;	O
}	O
else	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
some_context	bool
=	O
true	int
;	O
context	*(char)
++	O
;	O
if	O
(	O
repl_beginning	long
)	O
repl_copiable	long
++	O
;	O
else	O
ptrn_copiable	long
++	O
;	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	()->(bool)
(	O
)	O
)	O
;	O
p_len	*(long)
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	*(*(char))
[	O
p_end	long
]	O
=	O
savebuf	(*(char),long)->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	*(*(char))
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
malformed	()->(void)
(	O
)	O
;	O
}	O
}	O
hunk_done	O
:	O
if	O
(	O
p_end	long
>=	O
0	int
&&	O
!	O
repl_beginning	long
)	O
fatal	(*(char))->(void)
(	O
"no '---' found in patch at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
pch_hunk_beg	()->(long)
(	O
)	O
)	O
)	O
;	O
if	O
(	O
repl_missing	bool
)	O
{	O
p_input_line	long
=	O
repl_patch_line	long
;	O
context	*(char)
=	O
repl_context	long
;	O
for	O
(	O
p_end	long
--	O
;	O
p_end	long
>	O
repl_beginning	long
;	O
p_end	long
--	O
)	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
p_end	long
]	O
)	O
;	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
repl_backtrack_position	long
,	O
SEEK_SET	int
)	O
;	O
fillsrc	long
=	O
1	int
;	O
filldst	long
=	O
repl_beginning	long
+	O
1	int
;	O
fillcnt	long
=	O
p_repl_lines	long
;	O
p_end	long
=	O
p_max	long
;	O
}	O
else	O
if	O
(	O
!	O
ptrn_missing	bool
&&	O
ptrn_copiable	long
!=	O
repl_copiable	long
)	O
fatal	(*(char))->(void)
(	O
"context mangled in hunk at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_hunk_beg	long
)	O
)	O
;	O
else	O
if	O
(	O
!	O
some_context	bool
&&	O
fillcnt	long
==	O
1	int
)	O
{	O
while	O
(	O
filldst	long
<	O
p_end	long
)	O
{	O
p_line	*(*(char))
[	O
filldst	long
]	O
=	O
p_line	*(*(char))
[	O
filldst	long
+	O
1	int
]	O
;	O
p_Char	*(char)
[	O
filldst	long
]	O
=	O
p_Char	*(char)
[	O
filldst	long
+	O
1	int
]	O
;	O
p_len	*(long)
[	O
filldst	long
]	O
=	O
p_len	*(long)
[	O
filldst	long
+	O
1	int
]	O
;	O
filldst	long
++	O
;	O
}	O
p_end	long
--	O
;	O
p_first	long
++	O
;	O
fillcnt	long
=	O
0	int
;	O
p_ptrn_lines	long
=	O
0	int
;	O
}	O
p_prefix_context	long
=	O
(	O
(	O
repl_prefix_context	long
==	O
-	O
1	int
||	O
(	O
ptrn_prefix_context	long
!=	O
-	O
1	int
&&	O
ptrn_prefix_context	long
<	O
repl_prefix_context	long
)	O
)	O
?	O
ptrn_prefix_context	long
:	O
repl_prefix_context	long
)	O
;	O
p_suffix_context	long
=	O
(	O
(	O
ptrn_suffix_context	long
!=	O
-	O
1	int
&&	O
ptrn_suffix_context	long
<	O
context	*(char)
)	O
?	O
ptrn_suffix_context	long
:	O
context	*(char)
)	O
;	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
||	O
p_suffix_context	long
==	O
-	O
1	int
)	O
fatal	(*(char))->(void)
(	O
"replacement text or line numbers mangled in hunk at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_hunk_beg	long
)	O
)	O
;	O
if	O
(	O
difftype	enum(int,int,int,int,int,int,int)
==	O
CONTEXT_DIFF	int
&&	O
(	O
fillcnt	long
||	O
(	O
p_first	long
>	O
1	int
&&	O
p_prefix_context	long
+	O
p_suffix_context	long
<	O
ptrn_copiable	long
)	O
)	O
)	O
{	O
if	O
(	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
)	O
say	(*(char))->(void)
(	O
"%s\n%s\n%s\n"	*(char)
,	O
"(Fascinating -- this is really a new-style context diff but without"	*(char)
,	O
"the telltale extra asterisks on the *** line that usually indicate"	*(char)
,	O
"the new style...)"	*(char)
)	O
;	O
diff_type	enum(int,int,int,int,int,int,int)
=	O
difftype	enum(int,int,int,int,int,int,int)
=	O
NEW_CONTEXT_DIFF	int
;	O
}	O
if	O
(	O
fillcnt	long
)	O
{	O
p_bfake	long
=	O
filldst	long
;	O
p_efake	long
=	O
filldst	long
+	O
fillcnt	long
-	O
1	int
;	O
while	O
(	O
fillcnt	long
--	O
>	O
0	int
)	O
{	O
while	O
(	O
fillsrc	long
<=	O
p_end	long
&&	O
fillsrc	long
!=	O
repl_beginning	long
&&	O
p_Char	*(char)
[	O
fillsrc	long
]	O
!=	O
' '	O
)	O
fillsrc	long
++	O
;	O
if	O
(	O
p_end	long
<	O
fillsrc	long
||	O
fillsrc	long
==	O
repl_beginning	long
)	O
{	O
fatal	(*(char))->(void)
(	O
"replacement text or line numbers mangled in hunk at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_hunk_beg	long
)	O
)	O
;	O
}	O
p_line	*(*(char))
[	O
filldst	long
]	O
=	O
p_line	*(*(char))
[	O
fillsrc	long
]	O
;	O
p_Char	*(char)
[	O
filldst	long
]	O
=	O
p_Char	*(char)
[	O
fillsrc	long
]	O
;	O
p_len	*(long)
[	O
filldst	long
]	O
=	O
p_len	*(long)
[	O
fillsrc	long
]	O
;	O
fillsrc	long
++	O
;	O
filldst	long
++	O
;	O
}	O
while	O
(	O
fillsrc	long
<=	O
p_end	long
&&	O
fillsrc	long
!=	O
repl_beginning	long
)	O
{	O
if	O
(	O
p_Char	*(char)
[	O
fillsrc	long
]	O
==	O
' '	O
)	O
fatal	(*(char))->(void)
(	O
"replacement text or line numbers mangled in hunk at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_hunk_beg	long
)	O
)	O
;	O
fillsrc	long
++	O
;	O
}	O
if	O
(	O
debug	int
&	O
64	int
)	O
printf	(*(char))->(int)
(	O
"fillsrc %s, filldst %s, rb %s, e+1 %s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
fillsrc	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
filldst	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf2	array(char)
,	O
repl_beginning	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf3	array(char)
,	O
p_end	long
+	O
1	int
)	O
)	O
;	O
assert	O
(	O
fillsrc	long
==	O
p_end	long
+	O
1	int
||	O
fillsrc	long
==	O
repl_beginning	long
)	O
;	O
assert	O
(	O
filldst	long
==	O
p_end	long
+	O
1	int
||	O
filldst	long
==	O
repl_beginning	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
difftype	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
)	O
{	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
lin	long
fillsrc	long
;	O
lin	long
filldst	long
;	O
char	O
ch	char
=	O
'\0'	O
;	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
chars_read	long
<=	O
4	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
"@@ -"	*(char)
,	O
4	int
)	O
!=	O
0	int
)	O
{	O
next_intuit_at	(long,long)->(void)
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
buf	*(char)
+	O
4	int
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
p_ptrn_lines	long
)	O
;	O
else	O
p_ptrn_lines	long
=	O
1	int
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'+'	O
)	O
malformed	()->(void)
(	O
)	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
p_newfirst	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
p_repl_lines	long
)	O
;	O
else	O
p_repl_lines	long
=	O
1	int
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
!=	O
'@'	O
)	O
malformed	()->(void)
(	O
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
==	O
'@'	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
' '	O
&&	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\0'	O
)	O
{	O
p_c_function	*(char)
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
while	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'\n'	O
)	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
'\0'	O
;	O
p_c_function	*(char)
=	O
savestr	(*(char))->(*(char))
(	O
p_c_function	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
p_ptrn_lines	long
)	O
p_first	long
++	O
;	O
if	O
(	O
!	O
p_repl_lines	long
)	O
p_newfirst	long
++	O
;	O
p_max	long
=	O
p_ptrn_lines	long
+	O
p_repl_lines	long
+	O
1	int
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	()->(bool)
(	O
)	O
)	O
return	O
-	O
1	int
;	O
fillsrc	long
=	O
1	int
;	O
filldst	long
=	O
fillsrc	long
+	O
p_ptrn_lines	long
;	O
p_end	long
=	O
filldst	long
+	O
p_repl_lines	long
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"*** %s,%s ****\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_first	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_first	long
+	O
p_ptrn_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	*(long)
[	O
0	int
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
0	int
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
0	int
]	O
=	O
'*'	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"--- %s,%s ----\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_newfirst	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_newfirst	long
+	O
p_repl_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	*(long)
[	O
filldst	long
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
filldst	long
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
filldst	long
++	O
]	O
=	O
'='	O
;	O
p_prefix_context	long
=	O
-	O
1	int
;	O
p_hunk_beg	long
=	O
p_input_line	long
+	O
1	int
;	O
while	O
(	O
fillsrc	long
<=	O
p_ptrn_lines	long
||	O
filldst	long
<=	O
p_end	long
)	O
{	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
p_max	long
-	O
filldst	long
<	O
3	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
" \n"	*(char)
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
else	O
{	O
fatal	(*(char))->(void)
(	O
"unexpected end of file in patch"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
0	int
;	O
else	O
if	O
(	O
*	O
buf	*(char)
==	O
'\t'	O
||	O
*	O
buf	*(char)
==	O
'\n'	O
)	O
{	O
ch	char
=	O
' '	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
chars_read	long
)	O
;	O
}	O
else	O
{	O
ch	char
=	O
*	O
buf	*(char)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
+	O
1	int
,	O
--	O
chars_read	long
)	O
;	O
}	O
if	O
(	O
chars_read	long
&&	O
!	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
fillsrc	long
>	O
p_ptrn_lines	long
)	O
{	O
free	(*(void))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
p_end	long
=	O
filldst	long
-	O
1	int
;	O
malformed	()->(void)
(	O
)	O
;	O
}	O
chars_read	long
-=	O
fillsrc	long
==	O
p_ptrn_lines	long
&&	O
incomplete_line	()->(bool)
(	O
)	O
;	O
p_Char	*(char)
[	O
fillsrc	long
]	O
=	O
ch	char
;	O
p_line	*(*(char))
[	O
fillsrc	long
]	O
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
p_len	*(long)
[	O
fillsrc	long
++	O
]	O
=	O
chars_read	long
;	O
break	O
;	O
case	O
'='	O
:	O
ch	char
=	O
' '	O
;	O
case	O
' '	O
:	O
if	O
(	O
fillsrc	long
>	O
p_ptrn_lines	long
)	O
{	O
free	(*(void))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
malformed	()->(void)
(	O
)	O
;	O
}	O
context	*(char)
++	O
;	O
chars_read	long
-=	O
fillsrc	long
==	O
p_ptrn_lines	long
&&	O
incomplete_line	()->(bool)
(	O
)	O
;	O
p_Char	*(char)
[	O
fillsrc	long
]	O
=	O
ch	char
;	O
p_line	*(*(char))
[	O
fillsrc	long
]	O
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
p_len	*(long)
[	O
fillsrc	long
++	O
]	O
=	O
chars_read	long
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
savebuf	(*(char),long)->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
case	O
'+'	O
:	O
if	O
(	O
filldst	long
>	O
p_end	long
)	O
{	O
free	(*(void))->(void)
(	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
malformed	()->(void)
(	O
)	O
;	O
}	O
chars_read	long
-=	O
filldst	long
==	O
p_end	long
&&	O
incomplete_line	()->(bool)
(	O
)	O
;	O
p_Char	*(char)
[	O
filldst	long
]	O
=	O
ch	char
;	O
p_line	*(*(char))
[	O
filldst	long
]	O
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
p_len	*(long)
[	O
filldst	long
++	O
]	O
=	O
chars_read	long
;	O
break	O
;	O
default	O
:	O
p_end	long
=	O
filldst	long
;	O
malformed	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
ch	char
!=	O
' '	O
)	O
{	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
)	O
p_prefix_context	long
=	O
context	*(char)
;	O
context	*(char)
=	O
0	int
;	O
}	O
}	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
)	O
malformed	()->(void)
(	O
)	O
;	O
p_suffix_context	long
=	O
context	*(char)
;	O
}	O
else	O
{	O
char	O
hunk_type	char
;	O
int	O
i	int
;	O
lin	long
min	long
,	O
max	long
;	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
p_prefix_context	long
=	O
p_suffix_context	long
=	O
0	int
;	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
chars_read	long
||	O
!	O
ISDIGIT	O
(	O
*	O
buf	*(char)
)	O
)	O
{	O
next_intuit_at	(long,long)->(void)
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
buf	*(char)
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
p_ptrn_lines	long
)	O
;	O
p_ptrn_lines	long
+=	O
1	int
-	O
p_first	long
;	O
}	O
else	O
p_ptrn_lines	long
=	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
!=	O
'a'	O
)	O
;	O
hunk_type	char
=	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
hunk_type	char
==	O
'a'	O
)	O
p_first	long
++	O
;	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
min	long
)	O
;	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
','	O
)	O
scan_linenum	(*(char),*(long))->(*(char))
(	O
s	enum(int,int,int,int,int,int,int,int,int)
+	O
1	int
,	O
&	O
max	long
)	O
;	O
else	O
max	long
=	O
min	long
;	O
if	O
(	O
hunk_type	char
==	O
'd'	O
)	O
min	long
++	O
;	O
p_end	long
=	O
p_ptrn_lines	long
+	O
1	int
+	O
max	long
-	O
min	long
+	O
1	int
;	O
while	O
(	O
p_end	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	()->(bool)
(	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_newfirst	long
=	O
min	long
;	O
p_repl_lines	long
=	O
max	long
-	O
min	long
+	O
1	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"*** %s,%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_first	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_first	long
+	O
p_ptrn_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	*(long)
[	O
0	int
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
0	int
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
0	int
]	O
=	O
'*'	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
p_ptrn_lines	long
;	O
i	int
++	O
)	O
{	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	(*(char))->(void)
(	O
"unexpected end of file in patch at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
!=	O
'<'	O
||	O
(	O
buf	*(char)
[	O
1	int
]	O
!=	O
' '	O
&&	O
buf	*(char)
[	O
1	int
]	O
!=	O
'\t'	O
)	O
)	O
fatal	(*(char))->(void)
(	O
"'<' expected at line %s of patch"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
chars_read	long
-=	O
2	int
+	O
(	O
i	int
==	O
p_ptrn_lines	long
&&	O
incomplete_line	()->(bool)
(	O
)	O
)	O
;	O
p_len	*(long)
[	O
i	int
]	O
=	O
chars_read	long
;	O
p_line	*(*(char))
[	O
i	int
]	O
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
+	O
2	int
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	*(*(char))
[	O
i	int
]	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
i	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
hunk_type	char
==	O
'c'	O
)	O
{	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	(*(char))->(void)
(	O
"unexpected end of file in patch at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
*	O
buf	*(char)
!=	O
'-'	O
)	O
fatal	(*(char))->(void)
(	O
"'---' expected at line %s of patch"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"--- %s,%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
min	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
max	long
)	O
)	O
;	O
p_len	*(long)
[	O
i	int
]	O
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
p_line	*(*(char))
[	O
i	int
]	O
=	O
savestr	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
i	int
]	O
=	O
'='	O
;	O
for	O
(	O
i	int
++	O
;	O
i	int
<=	O
p_end	long
;	O
i	int
++	O
)	O
{	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	(*(char))->(void)
(	O
"unexpected end of file in patch at line %s"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
!=	O
'>'	O
||	O
(	O
buf	*(char)
[	O
1	int
]	O
!=	O
' '	O
&&	O
buf	*(char)
[	O
1	int
]	O
!=	O
'\t'	O
)	O
)	O
fatal	(*(char))->(void)
(	O
"'>' expected at line %s of patch"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_input_line	long
)	O
)	O
;	O
chars_read	long
-=	O
2	int
+	O
(	O
i	int
==	O
p_end	long
&&	O
incomplete_line	()->(bool)
(	O
)	O
)	O
;	O
p_len	*(long)
[	O
i	int
]	O
=	O
chars_read	long
;	O
p_line	*(*(char))
[	O
i	int
]	O
=	O
savebuf	(*(char),long)->(*(char))
(	O
buf	*(char)
+	O
2	int
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	*(*(char))
[	O
i	int
]	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	*(char)
[	O
i	int
]	O
=	O
'+'	O
;	O
}	O
}	O
if	O
(	O
rev	bool
)	O
if	O
(	O
!	O
pch_swap	()->(bool)
(	O
)	O
)	O
say	(*(char))->(void)
(	O
"Not enough memory to swap next hunk!\n"	*(char)
)	O
;	O
assert	O
(	O
p_end	long
+	O
1	int
<	O
hunkmax	long
)	O
;	O
p_Char	*(char)
[	O
p_end	long
+	O
1	int
]	O
=	O
'^'	O
;	O
if	O
(	O
debug	int
&	O
2	int
)	O
{	O
lin	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
p_end	long
+	O
1	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %c"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
i	int
)	O
,	O
p_Char	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
p_Char	*(char)
[	O
i	int
]	O
==	O
'*'	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s,%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_first	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_ptrn_lines	long
)	O
)	O
;	O
else	O
if	O
(	O
p_Char	*(char)
[	O
i	int
]	O
==	O
'='	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s,%s\n"	*(char)
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf0	array(char)
,	O
p_newfirst	long
)	O
,	O
format_linenum	(array(char),long)->(*(char))
(	O
numbuf1	array(char)
,	O
p_repl_lines	long
)	O
)	O
;	O
else	O
if	O
(	O
p_Char	*(char)
[	O
i	int
]	O
!=	O
'^'	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" |"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
i	int
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
size_t	long
get_line	()->(long)
(	O
void	O
)	O
{	O
return	O
pget_line	(long,int,bool,bool)->(long)
(	O
p_indent	long
,	O
p_rfc934_nesting	int
,	O
p_strip_trailing_cr	bool
,	O
p_pass_comments_through	bool
)	O
;	O
}	O
static	O
size_t	long
pget_line	(long,int,bool,bool)->(long)
(	O
size_t	long
indent	long
,	O
int	O
rfc934_nesting	int
,	O
bool	bool
strip_trailing_cr	bool
,	O
bool	bool
pass_comments_through	bool
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	char
;	O
size_t	long
i	int
;	O
char	O
*	O
b	struct(long,long)
;	O
size_t	long
s	enum(int,int,int,int,int,int,int,int,int)
;	O
do	O
{	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
read_fatal	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
indent	long
<=	O
i	int
)	O
break	O
;	O
if	O
(	O
c	char
==	O
' '	O
||	O
c	char
==	O
'X'	O
)	O
i	int
++	O
;	O
else	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
i	int
=	O
(	O
i	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
else	O
break	O
;	O
}	O
i	int
=	O
0	int
;	O
b	struct(long,long)
=	O
buf	*(char)
;	O
while	O
(	O
c	char
==	O
'-'	O
&&	O
0	int
<=	O
--	O
rfc934_nesting	int
)	O
{	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
if	O
(	O
c	char
!=	O
' '	O
)	O
{	O
i	int
=	O
1	int
;	O
b	struct(long,long)
[	O
0	int
]	O
=	O
'-'	O
;	O
break	O
;	O
}	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
}	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
bufsize	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
i	int
==	O
s	enum(int,int,int,int,int,int,int,int,int)
-	O
1	int
)	O
{	O
s	enum(int,int,int,int,int,int,int,int,int)
*=	O
2	int
;	O
b	struct(long,long)
=	O
realloc	(*(void),long)->(*(void))
(	O
b	struct(long,long)
,	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
!	O
b	struct(long,long)
)	O
{	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
return	O
(	O
size_t	long
)	O
-	O
1	int
;	O
}	O
buf	*(char)
=	O
b	struct(long,long)
;	O
bufsize	long
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
b	struct(long,long)
[	O
i	int
++	O
]	O
=	O
c	char
;	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
break	O
;	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
}	O
p_input_line	long
++	O
;	O
}	O
while	O
(	O
*	O
b	struct(long,long)
==	O
'#'	O
&&	O
!	O
pass_comments_through	bool
)	O
;	O
if	O
(	O
strip_trailing_cr	bool
&&	O
2	int
<=	O
i	int
&&	O
b	struct(long,long)
[	O
i	int
-	O
2	int
]	O
==	O
'\r'	O
)	O
b	struct(long,long)
[	O
i	int
--	O
-	O
2	int
]	O
=	O
'\n'	O
;	O
b	struct(long,long)
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
i	int
;	O
patch_ends_in_middle_of_line	O
:	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
read_fatal	()->(void)
(	O
)	O
;	O
say	(*(char))->(void)
(	O
"patch unexpectedly ends in middle of line\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
bool	bool
incomplete_line	()->(bool)
(	O
void	O
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	char
;	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
'\\'	O
)	O
{	O
while	O
(	O
(	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
&&	O
c	char
!=	O
EOF	O
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
Fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(void)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line_beginning	long
,	O
SEEK_SET	int
)	O
;	O
return	O
false	int
;	O
}	O
}	O
bool	bool
pch_swap	()->(bool)
(	O
void	O
)	O
{	O
char	O
*	O
*	O
tp_line	*(*(char))
;	O
size_t	long
*	O
tp_len	*(long)
;	O
char	O
*	O
tp_char	*(char)
;	O
lin	long
i	int
;	O
lin	long
n	int
;	O
bool	bool
blankline	bool
=	O
false	int
;	O
char	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
i	int
=	O
p_first	long
;	O
p_first	long
=	O
p_newfirst	long
;	O
p_newfirst	long
=	O
i	int
;	O
tp_line	*(*(char))
=	O
p_line	*(*(char))
;	O
tp_len	*(long)
=	O
p_len	*(long)
;	O
tp_char	*(char)
=	O
p_Char	*(char)
;	O
p_line	*(*(char))
=	O
0	int
;	O
p_len	*(long)
=	O
0	int
;	O
p_Char	*(char)
=	O
0	int
;	O
set_hunkmax	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
p_line	*(*(char))
||	O
!	O
p_len	*(long)
||	O
!	O
p_Char	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
p_line	*(*(char))
)	O
;	O
p_line	*(*(char))
=	O
tp_line	*(*(char))
;	O
free	(*(void))->(void)
(	O
p_len	*(long)
)	O
;	O
p_len	*(long)
=	O
tp_len	*(long)
;	O
free	(*(void))->(void)
(	O
p_Char	*(char)
)	O
;	O
p_Char	*(char)
=	O
tp_char	*(char)
;	O
return	O
false	int
;	O
}	O
i	int
=	O
p_ptrn_lines	long
+	O
1	int
;	O
if	O
(	O
tp_char	*(char)
[	O
i	int
]	O
==	O
'\n'	O
)	O
{	O
blankline	bool
=	O
true	int
;	O
i	int
++	O
;	O
}	O
if	O
(	O
p_efake	long
>=	O
0	int
)	O
{	O
if	O
(	O
p_efake	long
<=	O
i	int
)	O
n	int
=	O
p_end	long
-	O
i	int
+	O
1	int
;	O
else	O
n	int
=	O
-	O
i	int
;	O
p_efake	long
+=	O
n	int
;	O
p_bfake	long
+=	O
n	int
;	O
}	O
for	O
(	O
n	int
=	O
0	int
;	O
i	int
<=	O
p_end	long
;	O
i	int
++	O
,	O
n	int
++	O
)	O
{	O
p_line	*(*(char))
[	O
n	int
]	O
=	O
tp_line	*(*(char))
[	O
i	int
]	O
;	O
p_Char	*(char)
[	O
n	int
]	O
=	O
tp_char	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
p_Char	*(char)
[	O
n	int
]	O
==	O
'+'	O
)	O
p_Char	*(char)
[	O
n	int
]	O
=	O
'-'	O
;	O
p_len	*(long)
[	O
n	int
]	O
=	O
tp_len	*(long)
[	O
i	int
]	O
;	O
}	O
if	O
(	O
blankline	bool
)	O
{	O
i	int
=	O
p_ptrn_lines	long
+	O
1	int
;	O
p_line	*(*(char))
[	O
n	int
]	O
=	O
tp_line	*(*(char))
[	O
i	int
]	O
;	O
p_Char	*(char)
[	O
n	int
]	O
=	O
tp_char	*(char)
[	O
i	int
]	O
;	O
p_len	*(long)
[	O
n	int
]	O
=	O
tp_len	*(long)
[	O
i	int
]	O
;	O
n	int
++	O
;	O
}	O
assert	O
(	O
p_Char	*(char)
[	O
0	int
]	O
==	O
'='	O
)	O
;	O
p_Char	*(char)
[	O
0	int
]	O
=	O
'*'	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
p_line	*(*(char))
[	O
0	int
]	O
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'-'	O
)	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
'*'	O
;	O
assert	O
(	O
tp_char	*(char)
[	O
0	int
]	O
==	O
'*'	O
)	O
;	O
tp_char	*(char)
[	O
0	int
]	O
=	O
'='	O
;	O
for	O
(	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
tp_line	*(*(char))
[	O
0	int
]	O
;	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
s	enum(int,int,int,int,int,int,int,int,int)
++	O
)	O
if	O
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
==	O
'*'	O
)	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
'-'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
n	int
<=	O
p_end	long
;	O
i	int
++	O
,	O
n	int
++	O
)	O
{	O
p_line	*(*(char))
[	O
n	int
]	O
=	O
tp_line	*(*(char))
[	O
i	int
]	O
;	O
p_Char	*(char)
[	O
n	int
]	O
=	O
tp_char	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
p_Char	*(char)
[	O
n	int
]	O
==	O
'-'	O
)	O
p_Char	*(char)
[	O
n	int
]	O
=	O
'+'	O
;	O
p_len	*(long)
[	O
n	int
]	O
=	O
tp_len	*(long)
[	O
i	int
]	O
;	O
}	O
assert	O
(	O
i	int
==	O
p_ptrn_lines	long
+	O
1	int
)	O
;	O
i	int
=	O
p_ptrn_lines	long
;	O
p_ptrn_lines	long
=	O
p_repl_lines	long
;	O
p_repl_lines	long
=	O
i	int
;	O
p_Char	*(char)
[	O
p_end	long
+	O
1	int
]	O
=	O
'^'	O
;	O
free	(*(void))->(void)
(	O
tp_line	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
tp_len	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
tp_char	*(char)
)	O
;	O
return	O
true	int
;	O
}	O
int	O
pch_says_nonexistent	(bool)->(int)
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_says_nonexistent	array(int)
[	O
which	bool
]	O
;	O
}	O
const	O
char	O
*	O
pch_name	(enum(int,int,int,int))->(*(char))
(	O
enum	O
nametype	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
return	O
type	enum(int,int,int,int)
==	O
NONE	int
?	O
NULL	O
:	O
p_name	array(*(char))
[	O
type	enum(int,int,int,int)
]	O
;	O
}	O
bool	bool
pch_copy	()->(bool)
(	O
void	O
)	O
{	O
return	O
p_copy	array(bool)
[	O
OLD	int
]	O
&&	O
p_copy	array(bool)
[	O
NEW	int
]	O
&&	O
p_name	array(*(char))
[	O
OLD	int
]	O
&&	O
p_name	array(*(char))
[	O
NEW	int
]	O
;	O
}	O
bool	bool
pch_rename	()->(bool)
(	O
void	O
)	O
{	O
return	O
p_rename	array(bool)
[	O
OLD	int
]	O
&&	O
p_rename	array(bool)
[	O
NEW	int
]	O
&&	O
p_name	array(*(char))
[	O
OLD	int
]	O
&&	O
p_name	array(*(char))
[	O
NEW	int
]	O
;	O
}	O
lin	long
pch_first	()->(long)
(	O
void	O
)	O
{	O
return	O
p_first	long
;	O
}	O
lin	long
pch_ptrn_lines	()->(long)
(	O
void	O
)	O
{	O
return	O
p_ptrn_lines	long
;	O
}	O
lin	long
pch_newfirst	()->(long)
(	O
void	O
)	O
{	O
return	O
p_newfirst	long
;	O
}	O
lin	long
pch_repl_lines	()->(long)
(	O
void	O
)	O
{	O
return	O
p_repl_lines	long
;	O
}	O
lin	long
pch_end	()->(long)
(	O
void	O
)	O
{	O
return	O
p_end	long
;	O
}	O
lin	long
pch_prefix_context	()->(long)
(	O
void	O
)	O
{	O
return	O
p_prefix_context	long
;	O
}	O
lin	long
pch_suffix_context	()->(long)
(	O
void	O
)	O
{	O
return	O
p_suffix_context	long
;	O
}	O
size_t	long
pch_line_len	(long)->(long)
(	O
lin	long
line	long
)	O
{	O
return	O
p_len	*(long)
[	O
line	long
]	O
;	O
}	O
char	O
pch_char	(long)->(char)
(	O
lin	long
line	long
)	O
{	O
return	O
p_Char	*(char)
[	O
line	long
]	O
;	O
}	O
char	O
*	O
pfetch	(long)->(*(char))
(	O
lin	long
line	long
)	O
{	O
return	O
p_line	*(*(char))
[	O
line	long
]	O
;	O
}	O
bool	bool
pch_write_line	(long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(bool)
(	O
lin	long
line	long
,	O
FILE	struct
*	O
file	*(char)
)	O
{	O
bool	bool
after_newline	bool
=	O
p_line	*(*(char))
[	O
line	long
]	O
[	O
p_len	*(long)
[	O
line	long
]	O
-	O
1	int
]	O
==	O
'\n'	O
;	O
if	O
(	O
!	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
p_line	*(*(char))
[	O
line	long
]	O
,	O
sizeof	O
(	O
*	O
p_line	*(*(char))
[	O
line	long
]	O
)	O
,	O
p_len	*(long)
[	O
line	long
]	O
,	O
file	*(char)
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
return	O
after_newline	bool
;	O
}	O
lin	long
pch_hunk_beg	()->(long)
(	O
void	O
)	O
{	O
return	O
p_hunk_beg	long
;	O
}	O
char	O
const	O
*	O
pch_c_function	()->(*(char))
(	O
void	O
)	O
{	O
return	O
p_c_function	*(char)
;	O
}	O
bool	bool
pch_git_diff	()->(bool)
(	O
void	O
)	O
{	O
return	O
p_git_diff	bool
;	O
}	O
char	O
const	O
*	O
pch_timestr	(bool)->(*(char))
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_timestr	array(*(char))
[	O
which	bool
]	O
;	O
}	O
char	O
const	O
*	O
pch_sha1	(bool)->(*(char))
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_sha1	array(*(char))
[	O
which	bool
]	O
;	O
}	O
mode_t	int
pch_mode	(bool)->(int)
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_mode	array(int)
[	O
which	bool
]	O
;	O
}	O
static	O
char	O
_GL_ATTRIBUTE_PURE	O
get_ed_command_letter	(*(char))->(char)
(	O
char	O
const	O
*	O
line	long
)	O
{	O
char	O
const	O
*	O
p	*(void)
=	O
line	long
;	O
char	O
letter	char
;	O
bool	bool
pair	bool
=	O
false	int
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	*(void)
)	O
)	O
{	O
while	O
(	O
ISDIGIT	O
(	O
*	O
++	O
p	*(void)
)	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
','	O
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
++	O
p	*(void)
)	O
)	O
return	O
0	int
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
++	O
p	*(void)
)	O
)	O
;	O
pair	bool
=	O
true	int
;	O
}	O
}	O
letter	char
=	O
*	O
p	*(void)
++	O
;	O
switch	O
(	O
letter	char
)	O
{	O
case	O
'a'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
pair	bool
)	O
return	O
0	int
;	O
break	O
;	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"/.//"	*(char)
,	O
4	int
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
p	*(void)
+=	O
4	int
;	O
break	O
;	O
default	O
:	O
return	O
0	int
;	O
}	O
while	O
(	O
*	O
p	*(void)
==	O
' '	O
||	O
*	O
p	*(void)
==	O
'\t'	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'\n'	O
)	O
return	O
letter	char
;	O
return	O
0	int
;	O
}	O
void	O
do_ed_script	(*(char),*(char),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
char	O
const	O
*	O
inname	*(char)
,	O
char	O
const	O
*	O
outname	*(char)
,	O
int	O
*	O
outname_needs_removal	*(int)
,	O
FILE	struct
*	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
static	O
char	O
const	O
editor_program	array(char)
[	O
]	O
=	O
EDITOR_PROGRAM	*(char)
;	O
file_offset	long
beginning_of_this_line	long
;	O
FILE	struct
*	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
size_t	long
chars_read	long
;	O
if	O
(	O
!	O
dry_run	bool
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
int	O
exclusive	int
=	O
*	O
outname_needs_removal	*(int)
?	O
0	int
:	O
O_EXCL	int
;	O
assert	O
(	O
!	O
inerrno	int
)	O
;	O
*	O
outname_needs_removal	*(int)
=	O
1	int
;	O
copy_file	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,int,bool)->(void)
(	O
inname	*(char)
,	O
outname	*(char)
,	O
0	int
,	O
exclusive	int
,	O
instat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
,	O
true	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s %s%s"	*(char)
,	O
editor_program	array(char)
,	O
verbosity	enum(int,int,int)
==	O
VERBOSE	int
?	O
""	*(char)
:	O
"- "	*(char)
,	O
outname	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
buf	*(char)
,	O
binary_transput	int
?	O
"wb"	*(char)
:	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"Can't open pipe to %s"	*(char)
,	O
quotearg	(*(char))->(*(char))
(	O
buf	*(char)
)	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
ed_command_letter	char
;	O
beginning_of_this_line	long
=	O
file_tell	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
next_intuit_at	(long,long)->(void)
(	O
beginning_of_this_line	long
,	O
p_input_line	long
)	O
;	O
break	O
;	O
}	O
ed_command_letter	char
=	O
get_ed_command_letter	(*(char))->(char)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
ed_command_letter	char
)	O
{	O
if	O
(	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
if	O
(	O
!	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
*	O
buf	*(char)
,	O
chars_read	long
,	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
ed_command_letter	char
!=	O
'd'	O
&&	O
ed_command_letter	char
!=	O
's'	O
)	O
{	O
p_pass_comments_through	bool
=	O
true	int
;	O
while	O
(	O
(	O
chars_read	long
=	O
get_line	()->(long)
(	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
if	O
(	O
!	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
*	O
buf	*(char)
,	O
chars_read	long
,	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
2	int
&&	O
strEQ	O
(	O
buf	*(char)
,	O
".\n"	*(char)
)	O
)	O
break	O
;	O
}	O
p_pass_comments_through	bool
=	O
false	int
;	O
}	O
}	O
else	O
{	O
next_intuit_at	(long,long)->(void)
(	O
beginning_of_this_line	long
,	O
p_input_line	long
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
;	O
if	O
(	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
"w\nq\n"	*(char)
,	O
sizeof	O
(	O
char	O
)	O
,	O
(	O
size_t	long
)	O
4	int
,	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
||	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pipefp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
fatal	(*(char))->(void)
(	O
"%s FAILED"	*(char)
,	O
editor_program	array(char)
)	O
;	O
if	O
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
FILE	struct
*	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
outname	*(char)
,	O
binary_transput	int
?	O
"rb"	*(char)
:	O
"r"	*(char)
)	O
;	O
int	O
c	char
;	O
if	O
(	O
!	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
pfatal	(*(char))->(void)
(	O
"can't open '%s'"	*(char)
,	O
outname	*(char)
)	O
;	O
while	O
(	O
(	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
if	O
(	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	char
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
write_fatal	()->(void)
(	O
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
||	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ifp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
read_fatal	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
pch_normalize	(enum(int,int,int,int,int,int,int))->(void)
(	O
enum	O
diff	enum(int,int,int,int,int,int,int)
format	enum(int,int,int,int,int,int,int)
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
new	long
=	O
p_ptrn_lines	long
+	O
1	int
;	O
while	O
(	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'='	O
||	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
if	O
(	O
format	enum(int,int,int,int,int,int,int)
==	O
UNI_DIFF	int
)	O
{	O
for	O
(	O
;	O
old	long
<=	O
p_ptrn_lines	long
;	O
old	long
++	O
)	O
if	O
(	O
p_Char	*(char)
[	O
old	long
]	O
==	O
'!'	O
)	O
p_Char	*(char)
[	O
old	long
]	O
=	O
'-'	O
;	O
for	O
(	O
;	O
new	long
<=	O
p_end	long
;	O
new	long
++	O
)	O
if	O
(	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'!'	O
)	O
p_Char	*(char)
[	O
new	long
]	O
=	O
'+'	O
;	O
}	O
else	O
{	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
)	O
{	O
if	O
(	O
p_Char	*(char)
[	O
old	long
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'+'	O
)	O
{	O
do	O
{	O
p_Char	*(char)
[	O
old	long
]	O
=	O
'!'	O
;	O
old	long
++	O
;	O
}	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
&&	O
p_Char	*(char)
[	O
old	long
]	O
==	O
'-'	O
)	O
;	O
do	O
{	O
p_Char	*(char)
[	O
new	long
]	O
=	O
'!'	O
;	O
new	long
++	O
;	O
}	O
while	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'+'	O
)	O
;	O
}	O
else	O
{	O
do	O
old	long
++	O
;	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
&&	O
p_Char	*(char)
[	O
old	long
]	O
==	O
'-'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'+'	O
)	O
{	O
do	O
new	long
++	O
;	O
while	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	*(char)
[	O
new	long
]	O
==	O
'+'	O
)	O
;	O
}	O
else	O
{	O
old	long
++	O
;	O
new	long
++	O
;	O
}	O
}	O
}	O
}	O
