error_t	O
netfs_S_dir_lookup	(*(struct(struct,*(struct),*(struct(int,int,int,int,*`,int,int,*`,*`)),int,*(struct))),*(char),int,int,*(int),*(char),*(int),*(int))->(int)
(	O
struct	O
protid	struct(struct,*(struct),*(struct),int,*(struct))
*	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
,	O
char	O
*	O
filename	*(char)
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
retry_type	O
*	O
do_retry	*(int)
,	O
char	O
*	O
retry_name	*(char)
,	O
mach_port_t	O
*	O
retry_port	*(int)
,	O
mach_msg_type_name_t	O
*	O
retry_port_type	*(int)
)	O
{	O
int	O
create	int
;	O
int	O
excl	int
;	O
int	O
mustbedir	int
=	O
0	int
;	O
int	O
lastcomp	int
=	O
0	int
;	O
int	O
newnode	int
=	O
0	int
;	O
int	O
nsymlinks	int
=	O
0	int
;	O
struct	O
node	struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))
*	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
,	O
*	O
np	*(struct)
;	O
char	O
*	O
nextname	*(char)
;	O
char	O
*	O
relpath	*(char)
;	O
error_t	O
err	O
;	O
struct	O
protid	struct(struct,*(struct),*(struct),int,*(struct))
*	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
=	O
NULL	O
;	O
struct	O
iouser	O
*	O
user	*(struct)
;	O
if	O
(	O
!	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
return	O
EOPNOTSUPP	O
;	O
create	int
=	O
(	O
flags	int
&	O
O_CREAT	int
)	O
;	O
excl	int
=	O
(	O
flags	int
&	O
O_EXCL	int
)	O
;	O
while	O
(	O
*	O
filename	*(char)
==	O
'/'	O
)	O
filename	*(char)
++	O
;	O
relpath	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
relpath	*(char)
)	O
return	O
ENOMEM	O
;	O
char	O
*	O
filename_start	*(char)
=	O
filename	*(char)
;	O
*	O
retry_port_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
do_retry	*(int)
=	O
FS_RETRY_NORMAL	O
;	O
*	O
retry_name	*(char)
=	O
'\0'	O
;	O
if	O
(	O
*	O
filename	*(char)
==	O
'\0'	O
)	O
{	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
=	O
0	int
;	O
np	*(struct)
=	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
np	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	int
)	O
;	O
netfs_nref	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
np	*(struct)
)	O
;	O
goto	O
gotit	O
;	O
}	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
=	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
np	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
netfs_nref	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
)	O
;	O
do	O
{	O
assert	O
(	O
!	O
lastcomp	int
)	O
;	O
nextname	*(char)
=	O
index	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
nextname	*(char)
)	O
{	O
*	O
nextname	*(char)
++	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
nextname	*(char)
==	O
'/'	O
)	O
nextname	*(char)
++	O
;	O
if	O
(	O
*	O
nextname	*(char)
==	O
'\0'	O
)	O
{	O
nextname	*(char)
=	O
0	int
;	O
lastcomp	int
=	O
1	int
;	O
mustbedir	int
=	O
1	int
;	O
create	int
=	O
0	int
;	O
}	O
else	O
lastcomp	int
=	O
0	int
;	O
}	O
else	O
lastcomp	int
=	O
1	int
;	O
np	*(struct)
=	O
0	int
;	O
retry_lookup	O
:	O
if	O
(	O
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
==	O
netfs_root_node	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
||	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
==	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
shadow_root	*(struct)
)	O
&&	O
filename	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
filename	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
filename	*(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
if	O
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
==	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
shadow_root	*(struct)
)	O
{	O
if	O
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
shadow_root_parent	int
==	O
MACH_PORT_NULL	O
)	O
{	O
err	O
=	O
0	int
;	O
np	*(struct)
=	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
;	O
netfs_nref	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
np	*(struct)
)	O
;	O
}	O
else	O
{	O
*	O
do_retry	*(int)
=	O
FS_RETRY_REAUTH	O
;	O
*	O
retry_port	*(int)
=	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
shadow_root_parent	int
;	O
*	O
retry_port_type	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
if	O
(	O
lastcomp	int
&&	O
mustbedir	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
retry_name	*(char)
,	O
"/"	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
lastcomp	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
retry_name	*(char)
,	O
nextname	*(char)
)	O
;	O
err	O
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
goto	O
out	O
;	O
}	O
}	O
else	O
if	O
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
root_parent	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
*	O
do_retry	*(int)
=	O
FS_RETRY_REAUTH	O
;	O
*	O
retry_port	*(int)
=	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
root_parent	int
;	O
*	O
retry_port_type	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
if	O
(	O
lastcomp	int
&&	O
mustbedir	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
retry_name	*(char)
,	O
"/"	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
lastcomp	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
retry_name	*(char)
,	O
nextname	*(char)
)	O
;	O
err	O
=	O
0	int
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
goto	O
out	O
;	O
}	O
else	O
{	O
err	O
=	O
0	int
;	O
np	*(struct)
=	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
;	O
netfs_nref	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
np	*(struct)
)	O
;	O
}	O
else	O
err	O
=	O
netfs_attempt_lookup	(*(struct),*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),*(char),*(*(struct(*(struct`),int,int,int,int,int,int,struct,struct,struct,*(struct`)))))->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
,	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
,	O
filename	*(char)
,	O
&	O
np	*(struct)
)	O
;	O
if	O
(	O
lastcomp	int
&&	O
create	int
&&	O
excl	int
&&	O
!	O
err	O
)	O
err	O
=	O
EEXIST	O
;	O
if	O
(	O
lastcomp	int
&&	O
create	int
&&	O
err	O
==	O
ENOENT	O
)	O
{	O
mode	int
&=	O
~	O
(	O
S_IFMT	O
|	O
S_ISPARE	O
|	O
S_ISVTX	O
)	O
;	O
mode	int
|=	O
S_IFREG	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
err	O
=	O
netfs_attempt_create_file	(*(struct),*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),*(char),int,*(*(struct(*(struct`),int,int,int,int,int,int,struct,struct,struct,*(struct`)))))->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
,	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
,	O
filename	*(char)
,	O
mode	int
,	O
&	O
np	*(struct)
)	O
;	O
if	O
(	O
err	O
==	O
EEXIST	O
&&	O
!	O
excl	int
)	O
{	O
pthread_mutex_lock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
goto	O
retry_lookup	O
;	O
}	O
newnode	int
=	O
1	int
;	O
}	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
err	O
=	O
netfs_validate_stat	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),*(struct))->(int)
(	O
np	*(struct)
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
if	O
(	O
(	O
(	O
(	O
flags	int
&	O
O_NOTRANS	O
)	O
==	O
0	int
)	O
||	O
!	O
lastcomp	int
||	O
mustbedir	int
)	O
&&	O
(	O
(	O
np	*(struct)
->	O
nn_translated	int
&	O
S_IPTRANS	O
)	O
||	O
S_ISFIFO	()->(int)
(	O
np	*(struct)
->	O
nn_translated	int
)	O
||	O
S_ISCHR	()->(int)
(	O
np	*(struct)
->	O
nn_translated	int
)	O
||	O
S_ISBLK	()->(int)
(	O
np	*(struct)
->	O
nn_translated	int
)	O
||	O
fshelp_translated	()->(int)
(	O
&	O
np	*(struct)
->	O
transbox	struct
)	O
)	O
)	O
{	O
mach_port_t	O
dirport	O
;	O
err	O
=	O
iohelp_create_empty_iouser	()->(int)
(	O
&	O
user	*(struct)
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
=	O
netfs_make_protid	(*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))),*(struct))->(*(struct(struct,*(struct),*(struct(int,int,int,int,*`,int,int,*`,*`)),int,*(struct))))
(	O
netfs_make_peropen	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),int,*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))))->(*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))))
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
,	O
0	int
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
)	O
,	O
user	*(struct)
)	O
;	O
if	O
(	O
!	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
{	O
err	O
=	O
errno	O
;	O
iohelp_free_iouser	()->(int)
(	O
user	*(struct)
)	O
;	O
}	O
}	O
boolean_t	O
register_translator	O
=	O
0	int
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
fshelp_stat_cookie2	O
cookie	struct
=	O
{	O
.	O
statp	O
=	O
&	O
np	*(struct)
->	O
nn_stat	int
,	O
.	O
modep	O
=	O
&	O
np	*(struct)
->	O
nn_translated	int
,	O
.	O
next	O
=	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
,	O
}	O
;	O
dirport	O
=	O
ports_get_send_right	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
register_translator	O
=	O
np	*(struct)
->	O
transbox	struct
.	O
active	O
==	O
MACH_PORT_NULL	O
;	O
err	O
=	O
fshelp_fetch_root	()->(int)
(	O
&	O
np	*(struct)
->	O
transbox	struct
,	O
&	O
cookie	struct
,	O
dirport	O
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
,	O
lastcomp	int
?	O
flags	int
:	O
0	int
,	O
(	O
(	O
np	*(struct)
->	O
nn_translated	int
&	O
S_IPTRANS	O
)	O
?	O
_netfs_translator_callback1	O
:	O
fshelp_short_circuited_callback1	O
)	O
,	O
_netfs_translator_callback2	O
,	O
do_retry	*(int)
,	O
retry_name	*(char)
,	O
retry_port	*(int)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
dirport	O
)	O
;	O
}	O
if	O
(	O
err	O
!=	O
ENOENT	O
)	O
{	O
*	O
retry_port_type	*(int)
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
char	O
*	O
end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
retry_name	*(char)
,	O
'\0'	O
)	O
;	O
if	O
(	O
mustbedir	int
)	O
*	O
end	*(char)
++	O
=	O
'/'	O
;	O
else	O
if	O
(	O
!	O
lastcomp	int
)	O
{	O
if	O
(	O
end	*(char)
!=	O
retry_name	*(char)
)	O
*	O
end	*(char)
++	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
end	*(char)
,	O
nextname	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
register_translator	O
)	O
{	O
char	O
*	O
translator_path	*(char)
=	O
strdupa	O
(	O
relpath	*(char)
)	O
;	O
char	O
*	O
complete_path	*(char)
;	O
if	O
(	O
nextname	*(char)
!=	O
NULL	O
)	O
{	O
char	O
*	O
end	*(char)
=	O
nextname	*(char)
;	O
while	O
(	O
*	O
end	*(char)
!=	O
0	int
)	O
end	*(char)
--	O
;	O
translator_path	*(char)
[	O
end	*(char)
-	O
filename_start	*(char)
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
==	O
NULL	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
,	O
"."	*(char)
)	O
)	O
complete_path	*(char)
=	O
translator_path	*(char)
;	O
else	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
complete_path	*(char)
,	O
"%s/%s"	*(char)
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
,	O
translator_path	*(char)
)	O
;	O
err	O
=	O
fshelp_set_active_translator	()->(int)
(	O
&	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
pi	struct
,	O
complete_path	*(char)
,	O
np	*(struct)
->	O
transbox	struct
.	O
active	O
)	O
;	O
if	O
(	O
complete_path	*(char)
!=	O
translator_path	*(char)
)	O
free	()->(int)
(	O
complete_path	*(char)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
ports_port_deref	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
goto	O
out	O
;	O
}	O
}	O
ports_port_deref	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
goto	O
out	O
;	O
}	O
ports_port_deref	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
err	O
=	O
0	int
;	O
}	O
if	O
(	O
S_ISLNK	()->(int)
(	O
np	*(struct)
->	O
nn_translated	int
)	O
&&	O
(	O
!	O
lastcomp	int
||	O
mustbedir	int
||	O
!	O
(	O
flags	int
&	O
(	O
O_NOLINK	O
|	O
O_NOTRANS	O
)	O
)	O
)	O
)	O
{	O
size_t	long
nextnamelen	long
,	O
newnamelen	long
,	O
linklen	long
;	O
char	O
*	O
linkbuf	*(char)
;	O
if	O
(	O
nsymlinks	int
++	O
>	O
netfs_maxsymlinks	int
)	O
{	O
err	O
=	O
ELOOP	O
;	O
goto	O
out	O
;	O
}	O
linklen	long
=	O
np	*(struct)
->	O
nn_stat	int
.	O
st_size	long
;	O
nextnamelen	long
=	O
nextname	*(char)
?	O
strlen	(*(char))->(long)
(	O
nextname	*(char)
)	O
+	O
1	int
:	O
0	int
;	O
newnamelen	long
=	O
nextnamelen	long
+	O
linklen	long
+	O
1	int
+	O
1	int
;	O
linkbuf	*(char)
=	O
alloca	O
(	O
newnamelen	long
)	O
;	O
err	O
=	O
netfs_attempt_readlink	(*(struct),*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),*(char))->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
,	O
np	*(struct)
,	O
linkbuf	*(char)
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
if	O
(	O
nextname	*(char)
)	O
{	O
linkbuf	*(char)
[	O
linklen	long
]	O
=	O
'/'	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
linkbuf	*(char)
+	O
linklen	long
+	O
1	int
,	O
nextname	*(char)
,	O
nextnamelen	long
-	O
1	int
)	O
;	O
}	O
if	O
(	O
mustbedir	int
)	O
{	O
linkbuf	*(char)
[	O
nextnamelen	long
+	O
linklen	long
]	O
=	O
'/'	O
;	O
linkbuf	*(char)
[	O
nextnamelen	long
+	O
linklen	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
linkbuf	*(char)
[	O
nextnamelen	long
+	O
linklen	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
linkbuf	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
*	O
do_retry	*(int)
=	O
FS_RETRY_MAGICAL	O
;	O
*	O
retry_port	*(int)
=	O
MACH_PORT_NULL	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
retry_name	*(char)
,	O
linkbuf	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
filename	*(char)
=	O
linkbuf	*(char)
;	O
mustbedir	int
=	O
0	int
;	O
if	O
(	O
lastcomp	int
)	O
{	O
lastcomp	int
=	O
0	int
;	O
create	int
=	O
0	int
;	O
}	O
netfs_nput	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
np	*(struct)
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
->	O
lock	int
)	O
;	O
np	*(struct)
=	O
0	int
;	O
}	O
else	O
{	O
filename	*(char)
=	O
nextname	*(char)
;	O
netfs_nrele	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
)	O
;	O
if	O
(	O
lastcomp	int
)	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
=	O
0	int
;	O
else	O
{	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
=	O
np	*(struct)
;	O
np	*(struct)
=	O
0	int
;	O
}	O
}	O
}	O
while	O
(	O
filename	*(char)
&&	O
*	O
filename	*(char)
)	O
;	O
gotit	O
:	O
if	O
(	O
mustbedir	int
)	O
{	O
netfs_validate_stat	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),*(struct))->(int)
(	O
np	*(struct)
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
)	O
;	O
if	O
(	O
!	O
S_ISDIR	()->(int)
(	O
np	*(struct)
->	O
nn_stat	int
.	O
st_mode	int
)	O
)	O
{	O
err	O
=	O
ENOTDIR	O
;	O
goto	O
out	O
;	O
}	O
}	O
err	O
=	O
netfs_check_open_permissions	(*(struct),*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),int,int)->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
,	O
np	*(struct)
,	O
flags	int
,	O
newnode	int
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
flags	int
&=	O
~	O
OPENONLY_STATE_MODES	O
;	O
err	O
=	O
iohelp_dup_iouser	()->(int)
(	O
&	O
user	*(struct)
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
user	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
=	O
netfs_make_protid	(*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))),*(struct))->(*(struct(struct,*(struct),*(struct(int,int,int,int,*`,int,int,*`,*`)),int,*(struct))))
(	O
netfs_make_peropen	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))),int,*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))))->(*(struct(int,int,int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),int,int,*(struct(*`,int,int,int,int,int,int,struct`,struct`,struct`,*`)),*(char))))
(	O
np	*(struct)
,	O
flags	int
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
)	O
,	O
user	*(struct)
)	O
;	O
if	O
(	O
!	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
{	O
iohelp_free_iouser	()->(int)
(	O
user	*(struct)
)	O
;	O
err	O
=	O
errno	O
;	O
goto	O
out	O
;	O
}	O
free	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
)	O
;	O
if	O
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
==	O
NULL	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
,	O
"."	*(char)
)	O
)	O
{	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
=	O
relpath	*(char)
;	O
relpath	*(char)
=	O
NULL	O
;	O
}	O
else	O
{	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
=	O
NULL	O
;	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
,	O
"%s/%s"	*(char)
,	O
dircred	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
,	O
relpath	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
->	O
po	*(struct)
->	O
path	*(char)
)	O
err	O
=	O
errno	O
;	O
*	O
retry_port	*(int)
=	O
ports_get_right	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
ports_port_deref	()->(int)
(	O
newpi	*(struct(struct,*(struct),*(struct(int,int,int,int,*(struct`),int,int,*(struct`),*(char))),int,*(struct)))
)	O
;	O
out	O
:	O
if	O
(	O
np	*(struct)
)	O
netfs_nput	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
np	*(struct)
)	O
;	O
if	O
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
)	O
netfs_nrele	(*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct))))->(void)
(	O
dnp	*(struct(*(struct),int,int,int,int,int,int,struct,struct,struct,*(struct)))
)	O
;	O
free	()->(int)
(	O
relpath	*(char)
)	O
;	O
return	O
err	O
;	O
}	O
