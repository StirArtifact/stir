static	O
const	O
char	O
revid	array(char)
[	O
]	O
=	O
"$Id: mut_pthread.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	*(char)
;	O
int	O
__db_pthread_mutex_init	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*((*`,*`)->(void)),*((*`,int,int)->(void)),*((*`,int)->(void)),*((*`)->(int)),int,*(char),int,int,int,int,int,int,int,long,int,long,*(struct(*`,*`,char,char,*`)),*(void),*(void),int,long,*((*`,*`,*`,enum(int,int,int,int),*`)->(int)),int,*(char),*(char),*(char),*(*(char)),int,int,int,*(void),*(struct),long,*(void),*(void),*(void),*(void),*(*((*`,*`,*`,enum(int,int,int,int),*`)->(int))),long,*(void),long,int,struct(*(struct`),*(*`)),int,*(struct),*(void),*((*`,int)->(int)),*((*`,int,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,int,int)->(int)),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,long,long,int)->(int)),*((*`,long)->(int)),*((*`,*`)->(int)),*((*`,int,int)->(int)),*((*`,int)->(int)),*((*`,*`)->(int)),*((*`,int)->(int)),*((*`,*`,int)->(int)),*((*`,int)->(int)),*((*`,int)->(int)),*((*`,long)->(int)),*((*`,int,int,int)->(int)),*((*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),int)),*(struct(union(struct(int,int,int,int,int,short,short,struct`),array(char),long),union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long),int,int,int,int,char)),int)->(int)
(	O
dbenv	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*((*(char),*(char))->(void)),*((*(struct`),int,int)->(void)),*((*(struct`),int)->(void)),*((*(struct`))->(int)),int,*(char),int,int,int,int,int,int,int,long,int,long,*(struct(*((*`,*`,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`)->(int)),char,char,*(void))),*(void),*(void),int,long,*((*(struct`),*(struct`),*(struct`),enum(int,int,int,int),*(void))->(int)),int,*(char),*(char),*(char),*(*(char)),int,int,int,*(void),*(struct),long,*(void),*(void),*(void),*(void),*(*((*`,*`,*`,enum(int,int,int,int),*`)->(int))),long,*(void),long,int,struct(*(struct(*`,*`,*`,*`,*`,*`,int,*`,int,int,int,int,int,int,int,long,int,long,*`,*`,*`,int,long,*`,int,*`,*`,*`,*`,int,int,int,*`,*`,long,*`,*`,*`,*`,*`,long,*`,long,int,struct`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int)),*(*(struct`))),int,*(struct),*(void),*((*(struct`),int)->(int)),*((*(struct`),int,*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char),int,int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*((*`,*`)->(void)))->(void)),*((*(struct`),*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*((*`,int,int)->(void)))->(int)),*((*(struct`),*((*`,int)->(void)))->(int)),*((*(struct`),*((*`)->(int)))->(int)),*((*(struct`),*(char),long,long,int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),int,int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*((*`,*`,*`,enum(int,int,int,int),*`)->(int)))->(int)),*((*(struct`),*(long))->(int)),int))
,	O
mutexp	*(void)
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*((*(char),*(char))->(void)),*((*(struct`),int,int)->(void)),*((*(struct`),int)->(void)),*((*(struct`))->(int)),int,*(char),int,int,int,int,int,int,int,long,int,long,*(struct(*((*`,*`,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`)->(int)),char,char,*(void))),*(void),*(void),int,long,*((*(struct`),*(struct`),*(struct`),enum(int,int,int,int),*(void))->(int)),int,*(char),*(char),*(char),*(*(char)),int,int,int,*(void),*(struct),long,*(void),*(void),*(void),*(void),*(*((*`,*`,*`,enum(int,int,int,int),*`)->(int))),long,*(void),long,int,struct(*(struct(*`,*`,*`,*`,*`,*`,int,*`,int,int,int,int,int,int,int,long,int,long,*`,*`,*`,int,long,*`,int,*`,*`,*`,*`,int,int,int,*`,*`,long,*`,*`,*`,*`,*`,long,*`,long,int,struct`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int)),*(*(struct`))),int,*(struct),*(void),*((*(struct`),int)->(int)),*((*(struct`),int,*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char),int,int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*((*`,*`)->(void)))->(void)),*((*(struct`),*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*((*`,int,int)->(void)))->(int)),*((*(struct`),*((*`,int)->(void)))->(int)),*((*(struct`),*((*`)->(int)))->(int)),*((*(struct`),*(char),long,long,int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),int,int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*((*`,*`,*`,enum(int,int,int,int),*`)->(int)))->(int)),*((*(struct`),*(long))->(int)),int))
;	O
MUTEX	struct
*	O
mutexp	*(void)
;	O
u_int32_t	int
flags	int
;	O
{	O
int	O
ret	int
;	O
ret	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mutexp	*(void)
,	O
0	int
,	O
sizeof	O
(	O
*	O
mutexp	*(void)
)	O
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
MUTEX_THREAD	int
)	O
||	O
F_ISSET	O
(	O
dbenv	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*((*(char),*(char))->(void)),*((*(struct`),int,int)->(void)),*((*(struct`),int)->(void)),*((*(struct`))->(int)),int,*(char),int,int,int,int,int,int,int,long,int,long,*(struct(*((*`,*`,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`)->(int)),char,char,*(void))),*(void),*(void),int,long,*((*(struct`),*(struct`),*(struct`),enum(int,int,int,int),*(void))->(int)),int,*(char),*(char),*(char),*(*(char)),int,int,int,*(void),*(struct),long,*(void),*(void),*(void),*(void),*(*((*`,*`,*`,enum(int,int,int,int),*`)->(int))),long,*(void),long,int,struct(*(struct(*`,*`,*`,*`,*`,*`,int,*`,int,int,int,int,int,int,int,long,int,long,*`,*`,*`,int,long,*`,int,*`,*`,*`,*`,int,int,int,*`,*`,long,*`,*`,*`,*`,*`,long,*`,long,int,struct`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int)),*(*(struct`))),int,*(struct),*(void),*((*(struct`),int)->(int)),*((*(struct`),int,*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char),int,int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*((*`,*`)->(void)))->(void)),*((*(struct`),*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*((*`,int,int)->(void)))->(int)),*((*(struct`),*((*`,int)->(void)))->(int)),*((*(struct`),*((*`)->(int)))->(int)),*((*(struct`),*(char),long,long,int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),int,int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*((*`,*`,*`,enum(int,int,int,int),*`)->(int)))->(int)),*((*(struct`),*(long))->(int)),int))
,	O
DB_ENV_PRIVATE	int
)	O
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*((*(char),*(char))->(void)),*((*(struct`),int,int)->(void)),*((*(struct`),int)->(void)),*((*(struct`))->(int)),int,*(char),int,int,int,int,int,int,int,long,int,long,*(struct(*((*`,*`,int,*`,*`,*`)->(int)),*((*`,*`,int,*`,int,*`)->(int)),char,char,*(void))),*(void),*(void),int,long,*((*(struct`),*(struct`),*(struct`),enum(int,int,int,int),*(void))->(int)),int,*(char),*(char),*(char),*(*(char)),int,int,int,*(void),*(struct),long,*(void),*(void),*(void),*(void),*(*((*`,*`,*`,enum(int,int,int,int),*`)->(int))),long,*(void),long,int,struct(*(struct(*`,*`,*`,*`,*`,*`,int,*`,int,int,int,int,int,int,int,long,int,long,*`,*`,*`,int,long,*`,int,*`,*`,*`,*`,int,int,int,*`,*`,long,*`,*`,*`,*`,*`,long,*`,long,int,struct`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int)),*(*(struct`))),int,*(struct),*(void),*((*(struct`),int)->(int)),*((*(struct`),int,*(char))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*(char),int,int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),*((*`,*`)->(void)))->(void)),*((*(struct`),*(struct`))->(void)),*((*(struct`),*(char))->(void)),*((*(struct`),*((*`,int,int)->(void)))->(int)),*((*(struct`),*((*`,int)->(void)))->(int)),*((*(struct`),*((*`)->(int)))->(int)),*((*(struct`),*(char),long,long,int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char))->(int)),*((*(struct`),int)->(int)),*((*(struct`),*(char),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),long)->(int)),*((*(struct`),int,int,int)->(int)),*((*(struct`),int)->(int)),*((*(struct`),*((*`,*`,*`,enum(int,int,int,int),*`)->(int)))->(int)),*((*(struct`),*(long))->(int)),int))
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
F_SET	O
(	O
mutexp	*(void)
,	O
MUTEX_IGNORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
F_SET	O
(	O
mutexp	*(void)
,	O
MUTEX_THREAD	int
)	O
;	O
}	O
{	O
pthread_condattr_t	union(array(char),int)
condattr	union(array(char),int)
,	O
*	O
condattrp	*(union(array(char),int))
=	O
NULL	O
;	O
pthread_mutexattr_t	union(array(char),int)
mutexattr	union(array(char),int)
,	O
*	O
mutexattrp	*(union(array(char),int))
=	O
NULL	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
mutexp	*(void)
,	O
MUTEX_THREAD	int
)	O
)	O
{	O
ret	int
=	O
pthread_condattr_init	(*(union(array(char),int)))->(int)
(	O
&	O
condattr	union(array(char),int)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
pthread_condattr_setpshared	(*(union(array(char),int)),int)->(int)
(	O
&	O
condattr	union(array(char),int)
,	O
PTHREAD_PROCESS_SHARED	int
)	O
;	O
condattrp	*(union(array(char),int))
=	O
&	O
condattr	union(array(char),int)
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
pthread_mutexattr_init	(*(union(array(char),int)))->(int)
(	O
&	O
mutexattr	union(array(char),int)
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
pthread_mutexattr_setpshared	(*(union(array(char),int)),int)->(int)
(	O
&	O
mutexattr	union(array(char),int)
,	O
PTHREAD_PROCESS_SHARED	int
)	O
;	O
mutexattrp	*(union(array(char),int))
=	O
&	O
mutexattr	union(array(char),int)
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
pthread_mutex_init	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)),*(union(array(char),int)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
,	O
mutexattrp	*(union(array(char),int))
)	O
;	O
if	O
(	O
mutexattrp	*(union(array(char),int))
!=	O
NULL	O
)	O
pthread_mutexattr_destroy	(*(union(array(char),int)))->(int)
(	O
mutexattrp	*(union(array(char),int))
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
MUTEX_SELF_BLOCK	int
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
&	O
mutexp	*(void)
->	O
cond	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
condattrp	*(union(array(char),int))
)	O
;	O
F_SET	O
(	O
mutexp	*(void)
,	O
MUTEX_SELF_BLOCK	int
)	O
;	O
if	O
(	O
condattrp	*(union(array(char),int))
!=	O
NULL	O
)	O
pthread_condattr_destroy	(*(union(array(char),int)))->(int)
(	O
condattrp	*(union(array(char),int))
)	O
;	O
}	O
}	O
mutexp	*(void)
->	O
spins	int
=	O
CDB___os_spin	()->(int)
(	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
__db_pthread_mutex_lock	(*(struct(union(struct(int,int,int,int,int,short,short,struct`),array(char),long),union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long),int,int,int,int,char)))->(int)
(	O
mutexp	*(void)
)	O
MUTEX	struct
*	O
mutexp	*(void)
;	O
{	O
u_int32_t	int
nspins	int
;	O
int	O
ret	int
,	O
waited	int
;	O
if	O
(	O
!	O
DB_GLOBAL	O
(	O
db_mutexlocks	int
)	O
||	O
F_ISSET	O
(	O
mutexp	*(void)
,	O
MUTEX_IGNORE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
nspins	int
=	O
mutexp	*(void)
->	O
spins	int
;	O
nspins	int
>	O
0	int
;	O
--	O
nspins	int
)	O
if	O
(	O
pthread_mutex_trylock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
nspins	int
==	O
0	int
&&	O
(	O
ret	int
=	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
mutexp	*(void)
,	O
MUTEX_SELF_BLOCK	int
)	O
)	O
{	O
for	O
(	O
waited	int
=	O
0	int
;	O
mutexp	*(void)
->	O
locked	int
!=	O
0	int
;	O
waited	int
=	O
1	int
)	O
{	O
ret	int
=	O
pthread_cond_wait	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
cond	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
&&	O
ret	int
!=	O
ETIME	int
&&	O
ret	int
!=	O
ETIMEDOUT	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
waited	int
)	O
++	O
mutexp	*(void)
->	O
mutex_set_wait	int
;	O
else	O
++	O
mutexp	*(void)
->	O
mutex_set_nowait	int
;	O
mutexp	*(void)
->	O
locked	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
nspins	int
==	O
mutexp	*(void)
->	O
spins	int
)	O
++	O
mutexp	*(void)
->	O
mutex_set_nowait	int
;	O
else	O
++	O
mutexp	*(void)
->	O
mutex_set_wait	int
;	O
mutexp	*(void)
->	O
locked	int
=	O
1	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
__db_pthread_mutex_unlock	(*(struct(union(struct(int,int,int,int,int,short,short,struct`),array(char),long),union(struct(union`,union`,array(int),array(int),int,int,array(int)),array(char),long long),int,int,int,int,char)))->(int)
(	O
mutexp	*(void)
)	O
MUTEX	struct
*	O
mutexp	*(void)
;	O
{	O
int	O
ret	int
;	O
if	O
(	O
!	O
DB_GLOBAL	O
(	O
db_mutexlocks	int
)	O
||	O
F_ISSET	O
(	O
mutexp	*(void)
,	O
MUTEX_IGNORE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
mutexp	*(void)
,	O
MUTEX_SELF_BLOCK	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
mutexp	*(void)
->	O
locked	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
pthread_cond_signal	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
cond	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
mutexp	*(void)
->	O
locked	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
mutexp	*(void)
->	O
mutex	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
